<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2015-10-23" data-pagefind-meta="published:2015-10-23"><a href="https://neue.cc/2015/10/23_518.html">同期（風）コードと対比させたUnity+UniRxで非同期を扱う場合のパターン集</a></h1>
<ul class="date"><li>2015-10-23</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx/">UniRx</a>のGitHubのStar数が500行きました！</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10682950/165b9eea-7977-11e5-87ec-9b98269e912a.png" alt="image" /></p>
<p>今のところGitHub上での<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93">Unity + C#</a>でスター順の検索だと、世界5位です。おおー。更に上を狙いたいところですね。最近はちょっと更新が滞っていますが、ネタはあるのでより完成度を高めたい。(滞った理由は、<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>とか色々他のところに手を出していたため……)</p>
<p>さて、本題。イベント結合に使う際はあてはまりませんが、Rx(<a href="https://github.com/neuecc/UniRx/">UniRx</a>)を非同期（長さ1のIOservableシーケンス)として扱う場合、それなりに癖があります。とはいえ、基本的には同期（或いはyield return)で書いていた際と、1:1で対比できるパターン化した形で概ね対応できるので、そのためのチートシートを考えてみました。コード例はC# 5.0のasync/awaitで出しますが、同期コード or IEnumeratorと同じように思ってもらえればいいです。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Sync()
{
    /* before action */
    Method();
    /* after action */
}

public IEnumerator IEnumerator()
{
    /* before action */
    yield return StartCoroutine(Method());
    /* after action */
}

public async Task Task()
{
    /* before action */
    await MethodAsync();
    /* after action */
}
</code></pre>
<p>みたいな感じです、awaitに馴染みのない人も、なんとなくイメージしながら眺めてみてもらえると嬉しいです。</p>
<h2>非同期汚染</h2>
<p>コード例の前に非同期汚染、或いは非同期の伝搬について。まぁ、あんまし汚染という言い方は好きじゃないのですが、基本的に非同期、つまりTaskでもFutureでもPromiseでもIObservableでも、は、下層から上層まで伝搬していきます。メソッドが非同期であるなら戻り値はIObservableであり、そのIObservableを呼ぶメソッドもまた自然と非同期でなければならないので、IObservableになる、と。何故非同期の連鎖でなければならないのか。消費(Subscribe)してしまうと、その瞬間Fire and Forgetになってしまい、戻りを待ったりキャンセルしたりなどの別の操作が行えなくなってしまうからです。別にFire and Forgetしたければ、呼び元がそれを選択(Subscribeして放置)すればいいわけで、呼ばれる側が決定することではない。</p>
<p>もちろん、最終的にはどこかの層で消費(Subscribe)しなければならないので、そこで伝搬は止まるのですけれど、それは、基本的には上層であればあるほどよいということですね。どこが上層やねんって話はあるかもしれませんが、ユーザーインタラクションに近かったり、MonoBehaviourのイベント層に近かったり、あたりがそうですかねー。あとは、ごく一部でしか使わないんだ！という確固たる思いがあれば、早い段階でSubscribeして伝搬を止めるのも策ではあります、その辺はケースバイケースで。</p>
<p>非同期の伝搬に都合の良いメソッドが現状のUniRxには足りてません。実は！というわけで、次期バージョンではForEachAsyncというものを足したいのですが、それまでは以下のものをコピペって代用してください。挙動的にはシーケンスを消費して長さ1のIObservable[Unit]を返すもので、元シーケンスが非同期(長さ1)ならDoやSelectと、概ね一緒です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 次期バージョンに入るので、それまでの代用ということで。
// 元シーケンスが非同期なら .Select(x =&gt; { /* action(); */ return Unit.Default; }) とほぼ同様
namespace UniRx
{
    public static class UniRxExtensions
    {
        public static IObservable&lt;Unit&gt; ForEachAsync&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext)
        {
            return Observable.Create&lt;Unit&gt;(observer =&gt;
            {
                return source.Subscribe(x =&gt;
                {
                    try
                    {
                        onNext(x);
                    }
                    catch (Exception ex)
                    {
                        observer.OnError(ex);
                        return;
                    }
                }, observer.OnError, () =&gt;
                {
                    observer.OnNext(Unit.Default);
                    observer.OnCompleted();
                });
            });
        }
    }
}
</code></pre>
<p>また、副作用（外の変数への代入など）に関しては、あまり気にしないほうが吉です。いや、Rxのパイプラインに押し込めたほうが美しくはあるんですが、それがオブジェクトであるなら、副作用かけてフィールド変数を変えたり、ReactivePropertyに結果を伝えたりとかは、あって然りかな、と。考える際には「もしこれが同期コードだったらどうなのか」を意識したほうがいいかもしれません、同期コードで自然なら、別にRxでそれを行っても、構わないのです。とはいえ、以下に紹介するコードは全部、副作用大前提みたいな説明なので、それはそれで若干の狂気でもありますが、その辺は慣れてきてからでよいかと。</p>
<h2>戻り値のない場合</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task Demo1_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
}

public IObservable&lt;Unit&gt; Demo1_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .ForEachAsync(_ =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>メソッドに戻り値がない場合は、awaitの位置にForEachAsyncで、その中にactionを書く形になります。RxにおいてはIObservable[Unit]を戻り値のないことの表明として使います。</p>
<h2>内部に複数の非同期がある場合</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task Demo2_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action 1 */
    var y = await Task.Factory.StartNew(() =&gt; 200);
    /* after action 2 */
}

public IObservable&lt;Unit&gt; Demo2_IO_1Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */

            return Observable.Start(() =&gt; 200);
        })
        .ForEachAsync(y =&gt;
        {
            /* after action 2 */
        });
}
</code></pre>
<p>awaitの位置にSelectManyを置くことで繋げることができます。最後の消費だけForEachAsyncで。</p>
<h2>パイプライン中に複数の値を伝搬したい場合</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y }) // transport argument to next chain
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y } 
        });
}

public IObservable&lt;Unit&gt; Demo2_IO_2_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            var z = SyncMethod();
            return Observable.Start(() =&gt; 200).Select(y =&gt; new { x, y, z });
        })
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>同期コードでは、そのスコープ中の全ての値が使えるわけですが、Rxのメソッドチェーンでは次のパイプラインに送り込める値は一つしかありません。というわけで、匿名型（もしくはUniRx.Tuple）を使って、次のパイプラインへは値をまとめて上げる必要があります。SelectManyには第二引数があり、それにより前の値と次の値をまとめることができます。また、SelectMany内部で作った値を送り込みたい場合は、戻り値のところでSelectを使ってスコープ内でキャプチャして返してあげればいいでしょう。(匿名型、Tupleともにclassなので、気になる場合はstructの入れ物を用意してもいいかもしれない、何か箱を作って運搬しなきゃいけないのは残念ながら仕様です)</p>
<h2>非同期が連鎖する場合</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2_MoreChainAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y })
        .SelectMany(o =&gt;
        {
            /* after action 2 */
            return Observable.Start(() =&gt; 300);
        }, (o, z) =&gt; new { o.x, o.y, z }) // re-construct self
        .ForEachAsync(o =&gt;
        {
            /* after action 3 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>SelectManyの連打になります。また、伝搬する値は自分で分解して付け直してあげる必要があります、これは面倒くさいですね！この辺はクエリ構文を使った場合、Transparent Identifierという仕組みで自動的にコンパイラが行うのですが(<a href="http://www.slideshare.net/neuecc/an-internal-of-linq-to-objects-29200657">An Internal of LINQ to Objects</a>の35P、Rxでクエリ構文は結構頻繁にクエリ構文の範疇を逸脱するのと、副作用をパイプライン途中に書けないためあまり使い勝手は良くないので、面倒くさいながら手作業再構築を薦めます。</p>
<h2>戻り値を返す場合</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task&lt;int&gt; Demo3_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
    return x; // return value
}

public IObservable&lt;int&gt; Demo3_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Select(x =&gt;
        {
            /* after action */
            return x; // return value
        });
}
</code></pre>
<p>ForEachAsyncではなく、Selectを使っていきましょう。戻り値の型が同一で副作用だけ起こしたいならDoでも構わないのですが、まぁどっちでもいいです。また、awaitが複数になる場合は、SelectManyになります。そのうえでSelectManyのままreturnするか、最後に再びSelect(もしくはDo)を使うかどうかは、状況次第、かな。</p>
<h2>例外をキャッチ</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task Demo4_TaskAsync()
{
    /* before action */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    catch (Exception ex)
    {
        /* onerror action */
        throw;
    }

    /* after action */
}

public IObservable&lt;Unit&gt; Demo4_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Catch((Exception ex) =&gt;
        {
            /* onerror action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>これはCatchで賄えます。なお、Catchメソッドを使う際は、Catch&lt;T&gt;で例外の型を指定するよりも、ラムダ式の引数側で例外の型を書いたほうが書きやすいです（そうしたほうが型推論の関係上、ソースシーケンスの型を書かなくて済むため）。Catchの戻り値では再スローをObservable.Throw、握りつぶしをObservable.Return/Emptyで表現可能です。</p>
<h2>Finally</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task Demo5_TaskAsync()
{
    /* before action(1) */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    finally
    {
        /* finally action(2) */
    }

    /* after action(3) */
}

// not equivant try-finally
public IObservable&lt;Unit&gt; Demo5_IO_PseudoAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Finally(() =&gt;
        {
            /* finally action(3) */
        })
        .ForEachAsync(x =&gt;
        {
            /* after action(2) */
        });
}

public IObservable&lt;Unit&gt; Demo5_IO_CorrectLightweightButIsNotDryAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Do(_ =&gt; { /* finally action(2) */}, _ =&gt; {/* same finally action(2) */})
        .ForEachAsync(x =&gt;
        {
            /* after action(3) */
        });
}
</code></pre>
<p>Finallyに関しては、実は同じに扱える表現がありません!RxのFinallyはパイプラインの終了時の実行なので、実行順序がベタtry-finallyで書いた時と異なるんですよねえ。いちおう、DoでOnNextとOnErrorのところに同じコードを書くことでそれっぽい表現は可能ではありますが……。</p>
<h2>並列処理</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task ParallelAsync()
{
    var a = Task.Factory.StartNew(() =&gt; 100);
    var b = Task.Factory.StartNew(() =&gt; 200);
    var c = Task.Factory.StartNew(() =&gt; 300);
    
    var xs = await Task.WhenAll(a, b, c);
    /* after action */
}


public IObservable&lt;Unit&gt; ParallelIO()
{
    var a = Observable.Start(() =&gt; 100);
    var b = Observable.Start(() =&gt; 200);
    var c = Observable.Start(() =&gt; 300);
    
    return Observable.WhenAll(a, b, c)
        .ForEachAsync(xs =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>並列処理は非同期固有の実行ですが、WhenAllでドバッとまとめるというのが基本方針。</p>
<h2>タイムアウト</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public async Task TimeoutAsync(TimeSpan timeout)
{
    var task = Task.Factory.StartNew(() =&gt; 100);    
    var delay = Task.Delay(timeout);
    if (await Task.WhenAny(task, delay) == delay)
    {
        /* timeout action */
        throw new TimeoutException();
    }
    /* after action */
}


public IObservable&lt;Unit&gt; TimeoutIO(TimeSpan timeout)
{
    return Observable.Start(() =&gt; 100)
        .Timeout(timeout)
        .Catch((TimeoutException ex) =&gt;
        {
            /* timeout action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>タイマウトも非同期固有の処理。async/awaitの場合、特有のイディオムがあります。UniRxの場合はTimeoutだけでOK。特に例外時に処理するものもないなら、Catchは不要です。</p>
<h2>IEnumeratorに戻す</h2>
<pre data-pagefind-ignore="all"><code class="language-csharp">public IObservable&lt;Unit&gt; Demo6_IE()
{
    /* before action(1) */
    return Observable.FromCoroutine(() =&gt; Demo6_IECore());
}

IEnumerator Demo6_IECore()
{
    // 戻り値の不要な場合
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine();
    
    int ret;
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine(x =&gt; ret = x);
}
</code></pre>
<p>SelectManyの連打が辛い場合、ふつーのコルーチンに戻して、更にIObservableでラップするという手段も取れます。まあ、この辺は複雑さ度合いで自由に！</p>
<p>だったらもはや最初から全部コルーチンでええやん！Rxでメソッドチェーン複雑だし見た目だけならコルーチン最強にスッキリじゃん！というのは正しい。正しいんですが、例外処理・戻り値・合成可能性・並列処理・マルチスレッド、などといった要素が欠落してるので、コルーチンはコルーチンで苦しいところが多いというか実際のところシンプルなケース以外では相当苦しいので、基本的にはRxのほうが有利です。</p>
<h2>async/awaitは必要？</h2>
<p>みたとーり、必要です。どう考えても。さすがにSelectManyの連打を同期コードほどスッキリと言い張るのは無理があるでしょう。とはいえまぁ、書いて書けないこともないので、今あるツールの中でベストを尽くすのまた良きかな、とは思いますねー。というわけで良き非同期生活を！UniRxでイベントを扱う際のパターン集は、またそのうちにでも！</p>
</div>
<h1 data-pagefind-sort="date:2015-09-29" data-pagefind-meta="published:2015-09-29"><a href="https://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a></h1>
<ul class="date"><li>2015-09-29</li></ul>
<div class="entry_body"><p>Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用、という題で<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>にて話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/pF55iU0qXIeRFv" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/metaprogramming-universe-in-c-ilroslyn" title="Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例" target="_blank">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>現在、PhotonWireというフレームワークを作っているのですが、それで使ったメタプロ技法を紹介しました。ExpressionTree, T4, ILGenerator, Roslyn(Analyzer), Mono.Cecilとそれなりに満遍なく使っているので、それらをどーいう時に使えばいいのかというヒントになれば幸いです。まとめに書きましたが、手法自体は少なくするに越したこたぁないです、メタプロってついやりすぎちゃう傾向にあるんで、目的Firstを忘れないようにしないと本末転倒になりがちです。あと、それぞれは別にそんなに難しくない、というか難しくやらないようにするのが良いですね、そもそも長い式木とか長いILとか書きたくないですし……。</p>
<p>Proxyのvirtual強制は制約強くてゲロなので喪われた技法って感じですが、Roslyn Analyzerでコンパイラエラーに制限できることによって復活したかもしれない気がするかもしれない！あと、Taskは大事ですね、非同期のシグネチャとしてTaskで表明できるようになったのはひじょーーーーーーに大きな事です。これは実際めちゃくちゃ大きなことなのに過小評価してたり勘違いしてたりすると、いくない。もちろん、async/awaitで手軽にハンドリングできるようになったことも大事。RPC Revisitedですよ。そんなわけでごった煮しつつも、私的な独断と偏見に基づくバランス感覚で取捨してます。この辺の感覚はかなり大事だと思うんだな。</p>
<p>なお、書籍では<a href="http://www.amazon.co.jp/dp/4048867741">メタプログラミング.NET</a>が良書なのでオススメです。</p>
<h2>PhotonWire</h2>
<p>題材のPhotonWireは、<a href="http://grani.jp/">グラニ</a>で現在開発中のリアルタイムネットワーク通信用フレームワークです(ところでUnity、特にUniRxをゴリゴリ活用した先端的(エキセントリックともいう)なスクリプティング環境や、クライアントからサーバーまで全てC#で統一したあいそもーふぃっくな開発に興味のある人はいつでもウェルカムで採用募集中です)。といってもレイヤー的には比較的高レベルで、下回りでは<a href="https://www.photonengine.com/">Photon Server</a>というミドルウェアを採用していて、その上のRPCフレームワークを提供という感じです。キャッチコピーは「Typed Asynchronous RPC Layer for Photon Server + Unity」ということで、特にUnityとの繋ぎ込みを重視していて、クライアント-サーバー、サーバー-クライアント、サーバー-サーバーの方向のRPCを提供します。クライアント-クライアントは非サポート（あれは百害あって一利なし）。</p>
<p>クライアント-サーバーはご存知<a href="https://github.com/SignalR/SignalR">SignalR</a>、サーバー-サーバーは<a href="https://github.com/dotnet/orleans">Orleans</a>という分散アクターフレームワークのAPIを参考にしています、が、サーバーの分散に関しては、別に全然賢くないです。というか機能全く無いです。もともとのPhotonがそこに対するサポートがゼロで、PhotonWireでもたいしたサポートを入れてません。私的にはこの素朴な割り切りは結構好きですね。変に透過的に見せるよりも、それぞれのサーバー/それぞれのレイヤーを独立して、ある程度プリミティブな操作を可能にしたほうがはまりどころも少ないし。別に賢くはないんだけど、手堅い。ゲームという用途で考えると、あまりカシコイものよりも、愚直なシステムのほうがマッチしそうな感触があります。必要になったら、まぁ適当に考える。</p>
<p>Photon(+Unity)にはもともとPhoton Unity Network(PUN)という高レベルなクライアントが用意されているのですが、正直あんまり良いものでもない（特にPhoton Serverで自前ロジックを入れてくような場合は）ので、無視です、無視。で、PUNを通さない低レベルのSDKもあって、こちらは相当低レベルで本当に接続とデータ転送しか提供していないので（ただし低レベルSDKとしてはこのぐらいのほうが好ましい、へたに変なのがゴチャゴチャついてるよりも）、サーバーSDK（こちらもかなり低レベル）ともども統一した形で、ちょっと高レベルなもの、ぐらいの位置づけで作り上げてみました。</p>
<p>クラスとメソッドに属性でIDつけさせて、それで振り分けしているのでJSON-RPC的なメソッド名なども送っちゃうのでサイズが大きくなる、ということはなく、通常の転送に較べてもオーバーヘッドは2byteです。別に全然ない。ユーザー定義の型を送る場合（通常のPhotonはこれをサポートしてない）は<a href="https://github.com/msgpack/msgpack-cli">MsgPack-CLI</a>でシリアライズ/デシリアライズするため、その際の容量増大も極小です。また、シリアライザ/デシリアライザはその型に合致したものを事前生成するため、Unityにおいても高速に動作させられます、といったシステムも含まれています。</p>
<p>デバッグ用の専用クライアント（WPF製）なども込み込みで(これのデザイン面の話は<a href="http://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a>に書いてます)、痒い所に手が届きつつも、機能自体は小さく「型付きの非同期RPCの提供」から逸脱しない程度におさめているので、まーまー使いやすいんじゃないかなー、と思いますね。もちろん、クライアント側は<a href="https://github.com/neuecc/UniRx">UniRx</a>前提です。</p>
<p>UniRx同様、GitHub/AssetStoreでの公開予定はあるというか、早く公開したいんですが、Photonの次バージョンのベータ版を使って開発してるので、そっちが正式リリースされないと公開できないので早く出ないかなぁ(ﾁﾗｯ とオモッテマス。</p>
</div>
<h1 data-pagefind-sort="date:2015-09-10" data-pagefind-meta="published:2015-09-10"><a href="https://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a></h1>
<ul class="date"><li>2015-09-10</li></ul>
<div class="entry_body"><p>なんとブログ書くのは3ヶ月ぶり近い！えー、うーん、そんな経っちゃってるのか、こりゃいかん。と、いうわけかでWPFアプリを入り用で作ったんですが、見た目がショボくてゲッソリしてました。WPFでアプリ書いても別に綺麗な見た目にならんのですよね、むしろショボいというか。自分でデザイン作りこんだりなんて出来ないし、でもWPFのテーマ集なんかを適用してもクソダサいテーマしかなかったりして一層ダサくなるだけで全く意味ないとかそんなこんなんで、まぁ割とげっそりだったのですが、<a href="https://github.com/ButchersBoy/MaterialDesignInXamlToolkit">Material Design In XAML Toolkit</a>は相当良い！良かった、のでちょうど手元に作り中のWPFアプリがあって適用してみたんで紹介してきます。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>最終的に↑のような感じになりました。サクサクッとテーマ適用してくだけでこの程度に整えられるならば、上等すぎるかな、と。私的にはマテリアルデザイン、相当気に入りました。WindowsのModern UI風のフラットテーマは普通に適用しただけだと超絶ダサくなるという、センスが要求されすぎてキツかったんですが、マテリアルデザインはそれなりに質感が乗っかってるのでまぁまぁ見れる感じになる。また、画像からは分かりませんが結構細かくアニメーションが設定されていて感触が良い（マテリアルデザインの重要な要素だそうで）のも嬉しい。</p>
<h2>Before</h2>
<p>Beforeはこんな感じです。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml2.jpg' alt='' /></p>
<p>TextBoxとボタンの羅列、実にギョーミーな雰囲気。機能的には私の要件はこれで満たしてるんですが（ちなみにコレが何かは後日紹介するしGitHubで公開もするつもりですが今は本題ではないのでスルーします）、いかんせん見た目が悲しいかな、と。そこで現れたMaterial Design In XAML Toolkit！NuGetからのインストールとコピペ一発で素敵な見た目に……。
なるほど世の中はさすがに甘くなかったですね:)</p>
<p>適用は簡単で、NuGetからMaterialDesignThemesをダウンロード、そしてApp.xaml.csに<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MainDemo.Wpf/App.xaml">このApp.xaml</a>のApplication.Resourcesをコピペ。そしてMainWindowに以下の4項目を貼っつけてあげればできあがり。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;MainWindow
    xmlns:wpf=&quot;clr-namespace:MaterialDesignThemes.Wpf;assembly=MaterialDesignThemes.Wpf&quot;
    TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
    Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
    FontFamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;&gt;
</code></pre>
<p>簡単簡単。これで美しくなるなら素晴らしいですね？そしてその結果がこれ。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml3.jpg' alt='' /></p>
<p>うん、ダメ、理想とは程遠いダサさに溢れてます。Bootstrapを適用しただけじゃ普通にダサいままってのと同じ。ボーダーが吹っ飛んだので境目がわからず使いにくくなったし、やっぱダサ……、なんか一部のボタンは文字埋まっちゃってるし。で、引き返そうと思ったんですが、なんとなく良さそうな気配は感じたのでもう少し粘って作業することにしました。</p>
<h2>デモアプリを見ながら細工</h2>
<p>まずMaterialDesignInXamlToolkitのプロジェクトを落としましょう。CloneしてもいいしDownload Zipでもいいので。で、MainDemo.Wpfをビルドして実行しましょう、特に躓くことなくビルドできるはずですので。このデモアプリが非常によく出来ていて、出来ること全ての解説になってますし、当然それをやりたければそのxamlを開いてコピペすればなんとかなります！</p>
<p>というわけでデモアプリを眺めつつ自分のクソダサアプリのどこから手を入れようか。まず画面の構成要素のうち、上の部分のテキストボックスとボタンが並んでるところはコンフィグに近いので色分けしようかな、と。ヘッダ部分の色分け例はマテリアルデザインでよく見るパターンですしね。よく見るパターンということは、専用のパーツがしっかり用意されています。ColorZoneで囲むことで色がガラッと変わります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Inverted&quot; Padding=&quot;0&quot;&gt;
    ...
&lt;/wpf:ColorZone&gt;
</code></pre>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml4.jpg' alt='' /></p>
<p>ModeのInvertedは逆転した色、というわけで、これだけでまぁまぁ引き締まった雰囲気が出てきました、これはやって正解。また、ボタンの文字が埋まっているのはMargin入れて小さくしてたせいだったので、Heightを設定する形で小さくすることにしました。この状態でちょっとだけ問題があって、コンボボックスの選択時のフォントが通常カラーのままなので色が薄く見えなくなってしまうことに……。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml5.jpg' alt='' /></p>
<p>これはテーマから外れたItemContainerStyleを設定して回避。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;ComboBox ItemsSource=&quot;{Binding UseConnectionType}&quot;&gt;
    &lt;ComboBox.ItemContainerStyle&gt;
        &lt;Style TargetType=&quot;ComboBoxItem&quot;&gt;
            &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Gray&quot; /&gt;
        &lt;/Style&gt;
    &lt;/ComboBox.ItemContainerStyle&gt;
&lt;/ComboBox&gt;
</code></pre>
<p>よくわからんけどこんなんでいいでしょふ、よくわからんけど。真面目にXAML書くの5年ぶりぐらいなんで正直もう全然覚えてないんですよね。</p>
<p>そういえば、オマケコントロール（？）としてTextBoxにウォーターマークがつけれるのが入ってます。使い方はwpf:TextFieldAssist.Hintを入れるだけ。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;TextBox wpf:TextFieldAssist.Hint=&quot;うぉーたーまーく&quot; /&gt;
</code></pre>
<p>かなり綺麗に出て素敵なので最高だと思いました、まる。</p>
<h2>MahAppsの導入</h2>
<p>タイトルウィンドウが乖離しててダサいというか気になってきた。ので、ここを手軽に改変できる<a href="http://mahapps.com/">MahApps</a>を入れましょう。MahAppsだけだと、Metro風ということでこれ単体では別に素敵な見た目に出来ないんですが（ほんとメトロ風はムズカスぃ！）、Material Design In XAML Toolkitと合わせるとお互いの領域をカバーできる。ちゃんとMaterial Design In XAML Toolkit側で統合のための設定が用意されているので組み合わせるのは簡単です。MahAppsの基本的な導入は<a href="http://mahapps.com/guides/quick-start.html">Quick Start</a>に従う通り、まずWindowをMetroWindowに差し替えて</p>
<pre data-pagefind-ignore="all"><code class="language-xml">// Xaml 
&lt;Controls:MetroWindow
    xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;&gt;

// CodeBehind
public partial class MainWindow : MahApps.Metro.Controls.MetroWindow
</code></pre>
<p>App.xamlにリソースを投下、なのですが、MaterialDesignInXamlToolkitと統合するためのサンプルがMaterialDesignInXamlToolkit側に用意されているので、リソースは<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MahMaterialDragablzMashUp/App.xaml">MahMaterialDragablzMashUp/App.xaml</a>からコピペってきましょう。DragablzというChromeみたいなドラッグアンドドロップで切り離せるタブのためのライブラリを使わない場合（今回は使いませんでした）は、Dragablzに対する行は削除しておｋ（というか削除しないと動きません）。これで</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml6.jpg' alt='' /></p>
<p>となりました。うーん、よくなってきた！タイトルバーのところにテキストでいい感じなレイアウトで手軽にコマンドを突っ込めるのも嬉しかった。というわけでBeforeではステータスバーのところにやけくそにダサい感じで置いてたDuplicate Windowボタン（ウィンドウを複製する）をタイトルバーに移動。ついでにAlign Window（複数ウィンドウを整列させる）コマンドも追加。ちなみにこのアプリは複数ウィンドウを並べて使うのが前提なので、並べた時に重なって鬱陶しいためウィンドウ枠を光らせるのはあえて切ってるんですが、単体アプリなら光らせたほうが見栄え良いかもですね。入れるの自体は簡単で</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!-- 光らせるところ、GlowBrushを削れば光らない --&gt;
&lt;Controls:MetroWindow
    GlowBrush=&quot;{DynamicResource AccentColorBrush}&quot;&gt;    

    &lt;!-- コマンド入れるところ --&gt;
    &lt;Controls:MetroWindow.RightWindowCommands&gt;
        &lt;Controls:WindowCommands&gt;
            &lt;Button Content=&quot;Align Window&quot; Click=&quot;AlignWindow_Click&quot; /&gt;
            &lt;Button Content=&quot;Duplicate Window&quot; Click=&quot;DuplicateWindow_Click&quot; /&gt;
        &lt;/Controls:WindowCommands&gt;
    &lt;/Controls:MetroWindow.RightWindowCommands&gt;
</code></pre>
<p>をMainWindows.xamlに突っ込むだけです。お手軽素敵。</p>
<h2>最終調整</h2>
<p>Purpleじゃない色調にしたかったのでテーマをデモアプリのパレットから眺めてBlueGrayに決定。テーマはApp.xamlを弄ればヨイデス。MaterialDesignColor.xxx.xamlの部分ですね、他の色とかはデモアプリのPaletteで確認できます。その他Light/Darkの切り替えやSecondaryColourの設定なんかも、xxx.xamlのそれっぽい部分をなんとなく書き換えれば書き換わります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!-- include your primary palette --&gt;
&lt;ResourceDictionary.MergedDictionaries&gt;
    &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/MaterialDesignColor.BlueGrey.xaml&quot; /&gt;
&lt;/ResourceDictionary.MergedDictionaries&gt;
</code></pre>
<p>これで全体の色が変わったので、最後に、中央部分がMarginが消えてて区切りめがわからず使いづらいのは変わらずだったので、ここは枠をいれて明確な分離を。最初はボーダー入れて調整とかしてみたんですがイマイチしっくりこなかったんで、まぁ枠かな、と。マテリアルデザイン風のシャドウのある枠はヘッダーで色分けした時と同じく ColorZone で囲むだけです、ModeはStandardを選択。モードがどんなのがあるかもデモアプリを見れば一発で分かります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Standard&quot; Padding=&quot;5&quot; CornerRadius=&quot;3&quot; Effect=&quot;{DynamicResource MaterialDesignShadowDepth1}&quot; Margin=&quot;2&quot;&gt;
    &lt;local:OperationItem /&gt;
&lt;/wpf:ColorZone&gt;
</code></pre>
<p>影の出方はMaterialDesignShadowDepthの1~5で調整可能で、今回は1にしてます。その他の調整として、ログを表示しているテキストボックスのボーダーを上にも出すようにしたり、中身によって拡縮するようになっちゃたのでVerticalContentAlignmentを設定したりとちょっとした調整を少し入れて、最初に出した画像のものになりました。もっかい同じのを載せますけれど。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>アプリの見た目が良くなるってのは純粋にテンション上がるんでいいものですねぇ、機能的には何も変わっちゃいないですが、気分は随分と良いです。まぁギョームコウリツとは関係ないとこなんであんまり手を入れまくってもアレですが、ちょっとテーマ適用して調整するだけで必要最低限整ってくれるのは実に良いです。</p>
<h2>＋アイコン</h2>
<p>あとパラメータのコピペが欲しくなりました、複数ウィンドウ間で貼って回ったりするので。というわけでボタンにアイコンを用意したくて、それもマテリアルデザインなら簡単！</p>
<img src='http://neue.cc/wp-content/uploads/2015/09/materialxamlicon.jpg' alt='' />
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Button Background=&quot;{StaticResource PrimaryHueLightBrush}&quot;
        HorizontalAlignment=&quot;Left&quot;
        Width=&quot;24&quot; Height=&quot;24&quot; Padding=&quot;0&quot; Margin=&quot;5&quot;
        Command=&quot;{Binding PasteCommand}&quot;
        ToolTip=&quot;Paste&quot;&gt;
    &lt;Viewbox Width=&quot;16&quot; Height=&quot;16&quot;&gt;
        &lt;Canvas Width=&quot;24&quot; Height=&quot;24&quot;&gt;
            &lt;Path Data=&quot;M19,20H5V4H7V7H17V4H19M12,2A1,1 0 0,1 13,3A1,1 0 0,1 12,4A1,1 0 0,1 11,3A1,1 0 0,1 12,2M19,2H14.82C14.4,0.84 13.3,0 12,0C10.7,0 9.6,0.84 9.18,2H5A2,2 0 0,0 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V4A2,2 0 0,0 19,2Z&quot;
                     Fill=&quot;{DynamicResource MaterialDesignBody}&quot; /&gt;
        &lt;/Canvas&gt;
    &lt;/Viewbox&gt;
&lt;/Button&gt;
</code></pre>
<p>これは<a href="https://materialdesignicons.com/">Material Design Icons</a>にあるアイコンから取ってきてます。そこにはXAMLのPath Dataも載ってるので、タグをそのまま貼り付けるだけでアイコンとして使えます。これは楽ちんでめっちゃ良い！アイコンは揃えるのどうしても面倒ですからねー、このお手軽さは嬉しすぎます。色とかを用意されてるMaterialDesignのスタイルを入れ込んでやればそれだけで中々見栄えのするアイコンの出来上がり。</p>
<h2>ReactiveCommand</h2>
<p>えむぶいぶいえむ的なのは<a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a>で実装してます。で、ReactivePropertyもいーんですが、私的には昔から結構ReactiveCommand押しなんですよ、ReactiveCommandいいんだけどなー。例えば実際こんなコードになってます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// peer = ReactiveProperty&lt;Connection&gt;
// ObserveStatusChangedで状態の変化の監視 + コネクションは切り替わることがあるので前のを破棄するSwitch
// Disconnectが押せるのはStatusがConnectの時だけ
Disconnect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .Select(x =&gt; x == StatusCode.Connect)
    .ToReactiveCommand();

// Disconnectの逆、だけどConnectが押せるのはそれに加えて接続先アドレス入力欄が空でない場合
Connect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .CombineLatest(Address, (x, y) =&gt; x != StatusCode.Connect &amp;&amp; !string.IsNullOrEmpty(y))
    .ToReactiveCommand();
</code></pre>
<p>とか。若干込み入って面倒くさいのがスッキリ + ボタンのCanExecuteとぴったり来る。あとはプロセスを監視してて、存在してれば止めるボタンが押せるというのは、一秒毎のチェックにしていて、Observable.Intervalで繋ぎあわせてます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// PhotonSocketServerが存在すれば押せるコマンド、1秒毎のポーリングで監視
KillPhotonProcess = Observable.Interval(TimeSpan.FromSeconds(1))
    .Select(x =&gt; Process.GetProcessesByName(&quot;PhotonSocketServer&quot;).Any()); 
    .ToReactiveCommand();
</code></pre>
<p>こういうの悩まずサクサク書けるのは幸せ度高い。</p>
<h2>で、これ何なの？</h2>
<p>なんなんでしょーねぇ。ということの一端は<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>という勉強会で「IL から Roslyn まで - Metaprogramming Universe in C#」というタイトルでお話しますよ！2015-09-16（水）19:30 - 22:00に渋谷でやりますので、気になる人は是非是非参加くだしあ。内容はRoslyn 20%, C#全般 60%, WPF 10%, Unity 10%ぐらいなイメージですかしらん。このWPFのどこにメタプログラミング要素があるかというと、中身は<a href="https://github.com/jbevain/cecil">Mono.Cecil</a>使ってアセンブリ解析してるからです。へー。とかそういうことを話します。</p>
</div>
<h1 data-pagefind-sort="date:2015-06-20" data-pagefind-meta="published:2015-06-20"><a href="https://neue.cc/2015/06/20_514.html">第一回UniRx勉強会を開催しました＋スライドまとめ</a></h1>
<ul class="date"><li>2015-06-20</li></ul>
<div class="entry_body"><p>と、いうわけかで<a href="https://unirx.doorkeeper.jp/events/25218">UniRx勉強会</a>を開催しました。当日の模様は<a href="http://togetter.com/li/837045">togetterまとめ</a>で。登録が150人ほど、生憎の雨天でしたが130人以上来てくださってめっちゃ嬉しかったですね。慣れないというかはぢめての主催＋司会でその辺アレだったのですが、会場をお貸し下さったgloopsさんの手厚い協力のお陰で、なんとか成立させることができ、ほんとうに感謝です。</p>
<p>私の発表資料は「History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法」になります。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/5F9QtUqHz35hz6" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/history-practices-for-unirx-unirx" title="History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法" target="_blank">History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>あまりUniRx固有、という感じでもなく、また凄い話、でもなんでもない地味な内容なのですけれど、ちょっとはまると嫌だなー、けどはまりがちなポイントを説明してみた、といった感。地味すぎてトリとしてはなんともいえない感じでしたね、うむむむ。ちなみにReal World UniRxというのは、<a href="http://www.amazon.co.jp/dp/4873114233">Real World Haskell―実戦で学ぶ関数型言語プログラミング</a>という本が名前的には元ネタです。Real World、現実世界で使われるUniRx。というわけで要約すれば事例求む、みたいな。</p>
<h2>はじめてのUniRx</h2>
<p>toRisouPさんの発表です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/y3Mc90k0Kg2W6h" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/torisoup/uni-rx" title="はじめてのUniRx" target="_blank">はじめてのUniRx</a> </strong> from <strong><a href="//www.slideshare.net/torisoup" target="_blank">torisoup</a></strong> </div>
<p>資料的価値が非常に高く、わかりやすい。めっちゃ読みこむと良いと思います、スゴクイイ！Cold/Hotとか大事なんですがむつかしいところですしねー。</p>
<h2>若輩エンジニアから見たUniRxを利用したゲーム開発</h2>
<p>gloopsの森永さんの発表です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/Lm53c7Fx4wEkiW" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/HirohitoMorinaga/unirx" title="若輩エンジニアから見たUniRxを利用したゲーム開発" target="_blank">若輩エンジニアから見たUniRxを利用したゲーム開発</a> </strong> from <strong><a href="//www.slideshare.net/HirohitoMorinaga" target="_blank">Hirohito Morinaga</a></strong> </div>
<p>toRisouPさんのが中級者向けでしたので、こちらが初心者向けでしたね。UniRxがどういう風に自分の中で浸透というか理解が進んでいくか、というのがstep by stepで紹介されていて、伝わりやすいと思います。あと、全然紹介していなかったObservableTriggerまわりの応用が完璧に書かれていてすばら。</p>
<h2>Interactive UI with UniRx</h2>
<p>トライフォートの岩下さんのセッションです。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/peEH4Z6NuD6iaJ" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/yutoiwashita/reactive-ui-withunirx" title="Interactive UI with UniRx" target="_blank">Interactive UI with UniRx</a> </strong> from <strong><a href="//www.slideshare.net/yutoiwashita" target="_blank">Yuto Iwashita</a></strong> </div>
<p>UniRxって基本的にスクリプティング領域の技術なので、とにかく地味！なのですが、このセッションは地味どころかDemo含め、めっちゃ伝わるし美しさ、手触りが伝わって凄かった。実際本日一番の感動でしたにゃ。</p>
<h2>「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜</h2>
<p>ユニティ・テクノロジーズ・ジャパンの名雪さんのLTです。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/JkKnfNJRjYkkKY" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/tnayuki/uni-rx-49594996" title="「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜" target="_blank">「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜</a> </strong> from <strong><a href="//www.slideshare.net/tnayuki" target="_blank">Toru Nayuki</a></strong> </div>
<p>色々なものへのReactiveな入力/出力ができるんじゃもん！と言ってはいるし興味はかなりあるのだけれど、自分でやったことが全くない領域で、それが実際になされてる様を目にするとオオーッってなりました。</p>
<h2>その他</h2>
<p>そういえば、ブログに書いてなかったんですがちょっと前に「Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方」という発表をしていました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/sPOoYnUU3lXtpq" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/observable-everywhere-rxuni-rx" title="Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方" target="_blank">Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>これ、自分的には結構良い内容だなー、と思っているので見たことないかたは是非目を通してもらえると。</p>
<h2>まとめ</h2>
<p>第一回、というわけなんですがかなり密度濃い内容になったのでは！？懇親会でも、自分の思っていたよりもずっと遥かに使い出している、注目している、という声をいただき嬉しかったですねー。もっとドンドン良くしていかなければ、と気が引き締まります。次回がいつになるかは完全不明（というか当分後かな？）ですが、やっていきたいなー、と思いましたです。</p>
</div>
<h1 data-pagefind-sort="date:2015-06-13" data-pagefind-meta="published:2015-06-13"><a href="https://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a></h1>
<ul class="date"><li>2015-06-13</li></ul>
<div class="entry_body"><p>半月前にIntroduction to NotifyPropertyChangedGeneratorというタイトルでセッションしてきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/2wWO7MM7GaH1Uc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/introduction-to-notifypropertychangedgenerator" title="Introduction to NotifyPropertyChangedGenerator" target="_blank">Introduction to NotifyPropertyChangedGenerator</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>コードはGitHubで公開しているのと、NuGetでインストールもできます。</p>
<ul>
<li><a href="https://github.com/neuecc/NotifyPropertyChangedGenerator">GitHub - NotifyPropertyChangedGenerator</a></li>
<li><a href="http://www.nuget.org/packages/NotifyPropertyChangedGenerator">Install-Package NotifyPropertyChangedGenerator</a></li>
</ul>
<p>なにかというとVS2015のRoslynでのAnalyzerです。AnalyzerというとStyle Copに毛の生えたようなもの、をイメージしてしまうかもなのですが、全くそれだけじゃなく、真価はコードジェネレーターのほうにあると思っています。コンパイラでのエラーや警告も出せて、自然にVSやプロジェクトと統合されることから、Compiler Extension + Code Generatorとして私は捉えています。その例としてのINotifyPropertyChangedの生成となります。</p>
<h2>POMO</h2>
<p>Plain Old MVVM Object（笑）を定着させたいという意図は特にないのですが、割と語感が気に入ったので使ってみまふ。まぁとはいえ、やっぱ変更通知プロパティ程度で基底クラスを継承させるのは、そんなによろしいことではない、という認識はあるかなぁ、と。そのためのアプローチとして、こういったものが現実解にはなってくると思います、VS2015時代では。</p>
<p>さて、ちょうどufcppさんが<a href="http://ufcpp.net/blog/2015/6/valuechangedganerator/">【Roslynメタプログラミング】ValueChangedGanerator</a>を公開されました。アプローチが異なるわけですが、結構好みも出てくるかな、と思います。特に違いはpartialで外部ファイルに隔離 or 同一ファイル内で成形、は根本的に違うかもです。私はあまりpartialって好きではなくて、というのも結構迷子になるんですよね。いや、partial自体は素晴らしい機構でT4生成の時などに捗るんですが、このINotifyPropertyChanged程度のものでファイル分離されると、ファイル数が膨大になって、ちょっと……。また、プロパティのようなコードで触るものが外のファイルにあるのも、綺麗にはなるものの見通しは低下してしまうのではないかなあ、と。まぁ、この辺は良し悪しというかは好みかなー、といった感ですね。</p>
<p>色々なアプローチが考えられると思うので、色々試してみるのが良いと思います、Analyzer、可能性あって面白いです。ぜひ触ってみてくださいな。</p>
</div>
<h1 data-pagefind-sort="date:2015-05-11" data-pagefind-meta="published:2015-05-11"><a href="https://neue.cc/2015/05/11_512.html">UniRxでの空呼び出し検出、或いはRoslynによるCode Aware Libraries時代の到来について</a></h1>
<ul class="date"><li>2015-05-11</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx - Reactive Extensions for Unity</a>用に、メソッド呼んだだけで何も処理してないIObservable&lt;T&gt;があったらWarningを出すAnalyzerを作ってみました。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/AnalyzerReference.jpg" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/VSAnalyzer.jpg" alt="" /></p>
<p>AnalyzerはVisual Studio 2015からの機能です。というわけで<a href="https://www.microsoft.com/ja-jp/dev/products/visual-studio-2015.aspx">Visual Studio 2015 RC</a>が必要です。あとは、NuGetからAnalyzerが入れられるようになっているので</p>
<ul>
<li>Install-Package <a href="http://www.nuget.org/packages/UniRxAnalyzer">UniRxAnalyzer</a></li>
</ul>
<p>でOK。Unityのプロジェクトであっても問題なく使えます(ただしVSTUのcsproj自動生成でAnalyzerタグは吹っ飛ぶので、生成をフックして復元する必要はあります、フック方法の詳細は<a href="https://speakerdeck.com/grabacr07/minnada-hao-ki-boo-dot-lang-wo-satsugai-surufang-fa">みんな大好き Boo.Lang を SATSUGAI する方法</a>を参照のこと)。もし、他にこういうAnalyzerがあったら便利なのになー、とかってアイディアあったら気楽に言ってください！作りますので！</p>
<p>現在の<a href="http://grani.jp/">うちの会社（グラニ）</a>のプロジェクトはRxが土台から、ありとあらゆる全てで使われているので、ちょっとした呼び出しのつもりでやってたら何もおこらなくて(Susbcribe漏れ)クソが！となるシチュエーションが少なくなかったので、こういうAnalyzerが必需品だったのでした。</p>
<p>ようするにC# 5.0のTaskでawaitしてないと警告が出るのと同じ話なのですが、そういうのが言語組み込みキーワードでなくても自由に、（VS2015で動かせるなら）簡単にプロジェクト単位で追加出来る、というのがミソです。こういったライブラリとアナライザーの組み合わせは、Code Aware Librariesという言葉でまとめられます。<a href="http://channel9.msdn.com/Events/Build/2015/3-725">.NET Compiler Platform (&quot;Roslyn&quot;): Analyzers and the Rise of Code-Aware Libraries</a>。従来はライブラリのみの提供でしたが、そこにAnalyzerも組み合わせて、Best Practiceを一体化して伝えていくような世界観が広がっています。</p>
<p>例えば、私は<a href="https://github.com/neuecc/LightNode">LightNode</a>というWebAPIフレームワークを作っていますが、これは引数の型に幾つかの制約があります。また、メソッドのオーバーロードを許していなかったりします。それらは実行時のウォームアップのタイミングでフェイルファストとして気づかせるようにしていますが、それよりも前のタイミング、コードを書いている最中にリアルタイムで警告できれば、より良いでしょう。なので、Analyzerを同梱すれば、より良い形、より良いライブラリの有り様になります。</p>
<h2>DiagnosticAnalyzerの作り方 Part2</h2>
<p>以前に<a href="http://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a>と<a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a>という記事を書きましたが、基本的にはそれらと同じです、アタリマエですが。↑の記事はCTPの頃のもので、若干インターフェイスが変わっちゃっていますが、少し修正するだけでほぼほぼ同じかな。</p>
<p>今回作ったのはCode Analyzerで、Fixは含めていないのでcsファイル一個だけで済んでいます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class HandleObservableAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = &quot;HandleObservable&quot;;

    internal const string Title = &quot;IObservable&lt;T&gt; does not handled.&quot;;
    internal const string MessageFormat = &quot;This call does not handle IObservable&lt;T&gt;.&quot;;
    internal const string Description = &quot;IObservable&lt;T&gt; should be handled(assign, subscribe, chain operator).&quot;;
    internal const string Category = &quot;Usage&quot;;

    internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);

    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        var invocationExpressions = context.Node
            .DescendantNodes(descendIntoChildren: x =&gt; !(x is InvocationExpressionSyntax))
            .OfType&lt;InvocationExpressionSyntax&gt;();

        foreach (var expr in invocationExpressions)
        {
            var type = context.SemanticModel.GetTypeInfo(expr).Type;
            // UniRx.IObservable? System.IObservable?
            if (new[] { type }.Concat(type.AllInterfaces).Any(x =&gt; x.Name == &quot;IObservable&quot;))
            {
                // Okay =&gt; x = M(), var x = M(), return M(), from x in M()
                if (expr.Parent.IsKind(SyntaxKind.SimpleAssignmentExpression)) continue;
                if (expr.Parent.IsKind(SyntaxKind.EqualsValueClause) &amp;&amp; expr.Parent.Parent.IsKind(SyntaxKind.VariableDeclarator)) continue;
                if (expr.Parent.IsKind(SyntaxKind.ReturnStatement)) continue;
                if (expr.Parent.IsKind(SyntaxKind.FromClause)) continue;

                // Okay =&gt; M().M()
                if (expr.DescendantNodes().OfType&lt;InvocationExpressionSyntax&gt;().Any()) continue;

                // Report Warning
                var diagnostic = Diagnostic.Create(Rule, expr.GetLocation());
                context.ReportDiagnostic(diagnostic);
            }
        }
    }
}
</code></pre>
<p>戦略的には、メソッド呼び出し、つまりInvocationExpressionを拾いだして、そこからローカル変数代入/フィールド代入/return/LINQクエリ構文/メソッド呼び出しで使われていなければダメ扱いにする、という流れ。コード自体は行数も少なくて難しくはないのですけれど、戦略を決定するまでは割と悩みました。SyntaxTree自体も大量のメソッドがあり、SemanticModelも絡めると、色々な手段が取れそうでいて取れなさそうで、相当悩ましい。最終的にはかなり単純な手法に落ち着きましたが、直線距離で到達できるようになるまでには、かなり慣れが必要そうです。あと、最初作った時はクエリ構文のチェックを見落としてたりとか（さすがにこれを最初から気づくのは無理）、必要なケースを全て洗い出すのはそこそこ大変かな、といった感はあります。</p>
<p>DescendantNodesのdescendIntoChildrenという引数が中々面白くて、これは子孫ノードの探索を打ち切る条件を指定できます。これの何がいいって、例えばメソッド Observable.Range().Where().Select() があった場合、最上位のInvocationExpressionはObservable.Range().Where().Select()なのですが、その子孫に Observable.Range().Where() や Observable.Range() がいます。ふつーのDescendantNodesだとそれら全部を列挙してしまうんですが、今回は欲しいのは最上位だけなので、descendIntoChildrenで条件フィルタを足しています。</p>
<p>以前には紹介していない、ユニットテストのやり方も紹介しましょう。といっても、テンプレートに最初からTestプロジェクトと、便利クラス群が同梱されています。Analyzerだけの場合は基底クラスをDiagnosticVerifierに変えて……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace UniRxAnalyzer.Test
{
    [TestClass]
    public class HandleObservableAnalyzerTest : DiagnosticVerifier
    {
        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()
        {
            return new UniRxAnalyzer.HandleObservableAnalyzer();
        }

        [TestMethod]
        public void UnHandle()
        {
            var source = @&quot;
using System;
   
class Test
{
    IObservable&lt;int&gt; GetObservable() =&gt; null;

    void Hoge()
    {
        GetObservable();
    }
}&quot;;
            var expected = new DiagnosticResult
            {
                Id = UniRxAnalyzer.HandleObservableAnalyzer.DiagnosticId,
                Message = &quot;This call does not handle IObservable&lt;T&gt;.&quot;,
                Severity = DiagnosticSeverity.Warning,
                Locations = new[]
                {
                    new DiagnosticResultLocation(&quot;Test0.cs&quot;, 10, 9)
                }
            };

            this.VerifyCSharpDiagnostic(source, expected);
        }
    }
}
</code></pre>
<p>ようするにVerifyCSharpDiagnosticにテスト用のC#コードと、期待するDiagnosticResultを渡すだけです、実に簡単。もしエラーじゃなくOKの場合はsourceだけをVerifyCSharpDiagnosticに渡せば、そういうことになります。</p>
<h2>まとめ</h2>
<p>Analyzer、かなりイイです。実際。とにかくとりあえず触ってみませう。現状リファレンスとかは特にないですが、まぁLINQ to XML辺りがわかっていればSyntaxVisualizerとIntelliSenseを頼りになんとか作り上げられるでしょう！メソッド名を見ながらカンを働かせましょう。大丈夫大丈夫。また、GitHubには既にお手本となるAnalyzerが出回っているので、それを参照にすればかなりいけます。代表的なところでは<a href="http://nr6pack.net/">NR6Pack</a>, <a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers">StyleCopAnalyzers</a>, <a href="https://github.com/code-cracker/code-cracker">Code Cracker</a>などがあります。</p>
<p>では、よきRoslynライフを！</p>
</div>
<h1 data-pagefind-sort="date:2015-04-19" data-pagefind-meta="published:2015-04-19"><a href="https://neue.cc/2015/04/19_511.html">LightNode 1.2.0 - Swagger統合によるAPIのデバッグ実行</a></h1>
<ul class="date"><li>2015-04-19</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2015/03/25_508.html">グラニのC#フレームワークの過去と未来、現代的なASP.NETライブラリの選び方</a>という記事で、スライドと補足は先に上げましたが、以前に弊社で行った勉強会「Build Insider MEETUP with Grani 第1回」のレポートがBuild Insiderに上がっています。<a href="http://www.buildinsider.net/enterprise/granireport/0101">「using CSharp;」な企業を支える技術方針とベスト.NETライブラリ</a>記事によるレポートは、さくさく読めるし、スライドで欠けていた部分も補完できていーんじゃないでしょーか。まる。</p>
<p>さて、で、基本的にAPIサーバーはOWINで行くんですが、API開発はとにかくふつーのウェブよりも開発がしにくい！の欠点を、前回<a href="http://neue.cc/2015/02/16_505.html">LightNode 1.0、或いはWeb APIでのGlimpseの使い方</a>はGlimpseフル統合で補おうとしました。それはそれでいいんですが、もう一つ足りない。それはともかく根本的にそもそも実行しづらい。さすがにモバイルのエミュレーターなりUnityのEditorなりから毎度実行は効率悪すぎてありえないし、<a href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm">POSTMAN</a>や<a href="http://www.telerik.com/fiddler">Fiddler</a>で叩くのも面倒くせえ。</p>
<p>そこで<a href="http://swagger.io/">Swagger</a>。とはなにか、というのは見てもらえれば。</p>
<p class="noindent">
<img src="https://raw.githubusercontent.com/neuecc/LightNode/master/Img/swagger_support.jpg" width="640" />
</p>
<p>実行機付きのAPIのヘルプ・ドキュメントです。ヘルプ/ドキュメントはどうでもいいんですが、この実行機がかなり使いやすくいい！パラメータ入力してTry it out!でOK。認証が必要な場合も、右上にapi_keyというのが見えてますが、ちょっとindex.htmlを書き換えてこのapi_keyの部分を好きに都合のいい形態に変えてしまえば、機能します。実に便利。</p>
<p>SwaggerはAzureのAPI Appsでも利用されるようになったので、今後.NETでも目にする機会はちょっとずつ増えていくのではないでしょうか？ASP.NET Web APIで利用する方法はみそせんせーの<a href="http://miso-soup3.hateblo.jp/entry/2014/12/17/233409">Swagger を使った ASP.NET Web API のドキュメント生成</a>を参照すれば良いでしょふ。</p>
<p>さて、<a href="https://github.com/neuecc/LightNode">LightNode</a>(ってここではじめて解説しますが、私の作っているOwin上で動くMicro REST/RPCフレームワークです)では、Swagger統合はMiddlewareとして実装してあります。</p>
<ul>
<li>PM&gt; Install-Package <a href="https://www.nuget.org/packages/LightNode.Swagger/">LightNode.Swagger</a></li>
</ul>
<p>ルートをapiと別系統にswaggerとして切ってもらって、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 今のところPOSTしかサポートしてないのでPostを有効にしてね
app.Map(&quot;/api&quot;, builder =&gt;
{
    builder.UseLightNode(new LightNodeOptions(AcceptVerbs.Get | AcceptVerbs.Post, new JilContentFormatter(), new GZipJilContentFormatter())
    {
        ParameterEnumAllowsFieldNameParse = true, // Enumを文字列で並べたいならこれをONにして
        // 下2つはSwagger前提で使うならエラー表示的に便利
        ErrorHandlingPolicy = ErrorHandlingPolicy.ReturnInternalServerErrorIncludeErrorDetails,
        OperationMissingHandlingPolicy = OperationMissingHandlingPolicy.ReturnErrorStatusCodeIncludeErrorDetails
    });
});

// こっちでSwaggerを有効にする
app.Map(&quot;/swagger&quot;, builder =&gt;
{
    // XMLコメントから引っ張ってくるばあい（オプション）はパスを指定してください
    // メソッドに付与されているsummary, remarks, paramを情報として使います     
    var xmlName = &quot;LightNode.Sample.GlimpseUse.xml&quot;;
    var xmlPath = System.AppDomain.CurrentDomain.BaseDirectory + &quot;\\bin\\&quot; + xmlName; // もしくは HttpContext.Current.Server.MapPath(&quot;~/bin/&quot; + xmlName);

    // LightNode側のAPIのbasePathを指定
    builder.UseLightNodeSwagger(new Swagger.SwaggerOptions(&quot;LightNodeSample&quot;, &quot;/api&quot;)
    {
        XmlDocumentPath = xmlPath,
        IsEmitEnumAsString = true // Enumを文字列で並べたいならtrueに
    });
});
</code></pre>
<p>といった感じです。ちょっとややこしーですが、基本的にはUseLightNodeSwaggerだけでOK、ということで。これで、例えば http://localhost:41932/Swagger/ にアクセスすればSwaggerの画面が出てきます。Swagger-UI自体はdllに埋め込まれています。また、定義ファイル(JSON)はapi-default.jsonにアクセスすることで、直接取得できます。</p>
<p>もしOwinをIISでホストしている場合、IISのStaticFileハンドラーが邪魔してうまくホストできない場合があります。その場合、StaticFileハンドラーを殺してください。Owinでやる場合は、とにかくOwinに寄せたほうがいいですね（StaticFile系はMicrosoft.Owin.StaticFiles使いましょう）</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;system.webServer&gt;
    &lt;handlers&gt;
        &lt;remove name=&quot;StaticFile&quot; /&gt;
        &lt;!-- もしGlimpseもホストする場合はGlimpseのを先に書いといて --&gt;
        &lt;add name=&quot;Glimpse&quot; path=&quot;glimpse.axd&quot; verb=&quot;GET&quot; type=&quot;Glimpse.AspNet.HttpHandler, Glimpse.AspNet&quot; preCondition=&quot;integratedMode&quot; /&gt;
        &lt;add name=&quot;OWIN&quot; path=&quot;*&quot; verb=&quot;*&quot; type=&quot;Microsoft.Owin.Host.SystemWeb.OwinHttpHandler&quot; /&gt;
    &lt;/handlers&gt;
&lt;/system.webServer&gt;
</code></pre>
<p>もし、例えば最初に例に出しましたが、認証情報を付与するとかでindex.htmlを埋め込みのではなくカスタムのを使いたい場合、OptionのResolveCustomResourceをハンドリングすればできます。例えばこんな感じに、別の埋め込みリソースから取り出したものに差し替えたり。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">app.Map(&quot;/swagger&quot;, builder =&gt;
{
    builder.UseLightNodeSwagger(new LightNode.Swagger.SwaggerOptions(&quot;MySample&quot;, &quot;/api&quot;)
    {
        ResolveCustomResource = (filePath, loadedEmbeddedBytes) =&gt;
        {
            if (filePath == &quot;index.html&quot;)
            {
                using (var resourceStream = typeof(Startup).Assembly.GetManifestResourceStream(&quot;MySample.Swagger.index.html&quot;))
                using (var ms = new MemoryStream())
                {
                    resourceStream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return loadedEmbeddedBytes;
        }
    });
});
</code></pre>
<p>当然、index以外でもハンドリングできます。</p>
<h2>まとめ</h2>
<p>GlimpseとSwaggerがあわさって最強に見える！あとはもともとあるクライアント自動生成もあるので、三種の神器コンプリート。実際、これでAPI開発の苦痛に思えるところがかなり取り除かれたのではないかなー、って思ってます。これを全部自分で用意するのはそれはそれは大変なので、Owinで良かったし、組み合わせに関しても、.NETでOSSを使うってこういうことですよね？という例になればよいかな。</p>
</div>
<h1 data-pagefind-sort="date:2015-04-13" data-pagefind-meta="published:2015-04-13"><a href="https://neue.cc/2015/04/13_510.html">UniRx 4.8 - 軽量イベントフックとuGUI連携によるデータバインディング</a></h1>
<ul class="date"><li>2015-04-13</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx(Reactive Extensions for Unity)</a>のVer 4.8が昨日、AssetStoreにリリースされました。UniRxとはなにか、というと、巷で流行りのReactive Programming、の.NET実装のReactive Extensions、のUnity実装で、私が去年ぐらいからチマチマと作っています。実際のところ細かいリリースは何度も行っているんで（差分は<a href="https://github.com/neuecc/UniRx/releases">GitHubのReleases</a>に書いてあります)、開発/アップデートはかなりアクティブな状態でした。その間に、Google PlayやiOSのAppStoreでもチラホラと使用しているタイトルがあったりと（ありがとうございます！！！）、案外存外しっかりRealWorldしていました。GitHubのStarも順調に伸びていて、まぁまぁメジャーになってきた気はします。</p>
<p>その間に、いくつか素晴らしいプレゼン資料も作っていただきました！<a href="https://twitter.com/torisoup">@torisoup</a>さんの<a href="http://www.slideshare.net/torisoup/unity-unirx">未来のプログラミング技術をUnityで -UniRx-</a>は、分かりやすく魅力を感じさせてくれる内容になっていて、とても素晴らしいです。読むべし読むべし。<a href="http://qiita.com/toRisouP">toRisouPさんはQiita</a>でも多くの記事を書いてくださっていて、（私がｇｄｇｄ書くよりも）はるかに分かりやすくていいですね！</p>
<p>また、<a href="https://twitter.com/Grabacr07">@Grabacr07</a>さんの<a href="https://speakerdeck.com/grabacr07/unirx-toka-reactive-property-toka">UniRx とか ReactiveProperty とか</a>は、今回紹介するuGUI連携についての話が、分かりやすく綺麗に紹介されているので、こちらも必読です。必読。</p>
<p>UniRxの最初の発表は2014/04/19の<a href="http://www.slideshare.net/neuecc/unityrx-reactive-extensions-for-unity">UniRx - Reactive Extensions for Unity</a>というところで、発端は非同期処理の解消、という一面からスタートしていたのですが、すぐにUnityの発する色々なイベント処理をRxで行おうという、本来の、でありつつも応用的なところが盛んに試されるようになったのは素晴らしいことだなぁ、と思っています。これはゲームプログラミングの持つ複雑さが、Reactive Programmingの使い道を無数に産むという、相性の良さがあるのかしらん。非同期だけじゃない、データバインドだけじゃないRealなReactive Programmingがここにあり、プログラミングを、C#の可能性を、パラダイムシフトを大いに楽しめる環境です。是非楽しんでください。もちろん、実用性もありますしね！</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub - UniRx</a></li>
<li><a href="http://u3d.as/7tT">UnityAssetStore - UniRx</a></li>
</ul>
<p>当然（？）フリーです。</p>
<h2>ObservableTriggers</h2>
<p>UniRx 4.8から、MonoBehaviourのイベントハンドリング手法をObservableTriggersという概念に全面移行しました。どういうことかというと、まず、ObservableMonoBehaviourは廃止です:) Obsoleteはつけていないし、動作はしますが、非推奨になりました。その代わりとなるのがObservableTriggersです。まず利用例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using UniRx;
using UniRx.Triggers; // この名前空間以下にTriggerは入ってるのでusingしときましょう

public class MyComponent : MonoBehaviour
{
    void Start()
    {
        // AddComponentでTriggerを付与する
        var trigger = this.gameObject.AddComponent&lt;ObservableUpdateTrigger&gt;();

        // すると*Event*AsObservableが使えるようになる
        trigger.UpdateAsObservable()
            .SampleFrame(30)
            .Subscribe(x =&gt; Debug.Log(x), () =&gt; Debug.Log(&quot;destroy&quot;));

        // 3秒後に自殺:)
        GameObject.Destroy(this, 3f);
    }
}
</code></pre>
<p>Triggerは対象GameObjectがDestroyされると、OnCompletedを流してイベント発火を終了します。</p>
<p>ObservableMonoBehaviourを継承するのではなく、AddComponentで必要なイベントのためのTriggerを与えてください。そうすれば、そのイベントがRxで取り扱えるようになります。標準では ObservableAnimatorTrigger, ObservableCollision2DTrigger, ObservableCollisionTrigger, ObservableDestroyTrigger, ObservableEnableTrigger, ObservableFixedUpdateTrigger, ObservableUpdateTrigger, ObservableLastUpdateTrigger, ObservableMouseTrigger, ObservableTrigger2DTrigger, ObservableTriggerTrigger, ObservableVisibleTrigger, ObservableTransformChangedTrigger, ObservableRectTransformTrigger, ObservableCanvasGroupChangedTrigger, ObservableStateMachineTrigger, ObservableEventTrigger を用意してあります。「ほぼ」全部です。4.6から追加された新しいイベント(OnTransformChildrenChangedとか)も網羅しています。（とはいえ全部ではないので、足りなくて必要なものがあったら自分で追加するか、私にリクエストください、単純にあまり需要なさそうだと勝手に判断したものはオミットしちゃっているので……）</p>
<p>また、AddComponentが面倒くさい！ので、GameObject/Componentに対して、UniRx.Triggersをusingしている場合は、XxxAsObservableメソッドを直接拡張メソッドから呼べて、するとTriggerが自動付与されるようになっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using UniRx;
using UniRx.Triggers; // 必ずこのusingが必要です

public class DragAndDropOnce : MonoBehaviour
{
    void Start()
    {
        // OnMouseDownAsObservableが生えてる
        this.OnMouseDownAsObservable()
            .SelectMany(_ =&gt; this.UpdateAsObservable()) // UpdateAsObservableが生えてる
            .TakeUntil(this.OnMouseUpAsObservable()) // OnMouseUpAsObservableが生えてる
            .Select(_ =&gt; Input.mousePosition)
            .Subscribe(x =&gt; Debug.Log(x));
    }
}
</code></pre>
<p>なので、通常使う場合は、Triggerに関しては意識する必要はありません。(ObservableEventTrigger(uGUI用)とObservableStateMachineTrigger(Animation用)だけは自動付与がないので、これらの場合だけ自分で意識的に付与する必要があります)</p>
<p>ObservableMonoBehaviourは継承が必要だったり（基底クラスが強制される！）、baseメソッドの呼び出しが必須だったり、空イベントの呼び出しが必ず含まれるパフォーマンス低下などなど、決して使い勝手の良いものではありませんでした。というか使い勝手は最悪でした。なんで当初からObservableTriggerのようなやり方じゃなかったか、というと……、まぁ、単純に私のUnityへの理解不足です、すびばせん。ObservableTriggerは、Unityのコンポーネント指向を活かしつつ、Rxによってイベントを自然に外側で取り出せるようになっているので、圧倒的に便利な形になったのではないかなと思います。</p>
<h2>uGUI</h2>
<p>uGUIのイベントがUniRxでパーフェクトにハンドリングできます！この辺の話は前述のスライド<a href="https://speakerdeck.com/grabacr07/unirx-toka-reactive-property-toka">UniRx とか ReactiveProperty とか</a>に綺麗にまとまっているのですが、例えばボタンとかが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// インスペクタから貼っつけるとか
public Button MyButton;

// こんな感じで取る(onClick.AsObservable もしくは OnClickAsObservable)
MyButton.onClick.AsObservable().Subscribe(_ =&gt; Debug.Log(&quot;clicked&quot;));
</code></pre>
<p>ほぅ……。普通だ。どうでも良さそうだ。と、いう具合にuGUIのEvent + AsObservableでイベントハンドリングができるようになっています。もう少し例を出すと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ビューからのコントロールはインスペクタでペタペタ貼り付ける
public Toggle MyToggle;
public InputField MyInput;
public Text MyText;
public Slider MySlider;

// Startとかで宣言的にUIを記述していきましょう
void Start()
{
    // チェックボックスのオン/オフでボタンの有効/非有効が切り替わるようにします
    // OnValueChangedAsObservableは.onValueChanged.AsObservableのヘルパーで、単純に省略が楽という他に、
    // 初期値(最初のisOnの値)がSubscribe時に流れていきます
    // また、SubscribeToInteractableはUniRxのヘルパーで、 x =&gt; .interactable = x を省略できます
    MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);

    // 入力文字は1秒後にテキストラベルに反映されます
    MyInput.OnValueChangeAsObservable()
        .Where(x =&gt; x != null)
        .Delay(TimeSpan.FromSeconds(1))
        .SubscribeToText(MyText); // SubscribeToTextを使うと簡単に紐付けできます

    // SubscribeToTextの人間の読める形に変換したい場合用ヘルパ
    MySlider.OnValueChangedAsObservable()
        .SubscribeToText(MyText, x =&gt; Math.Round(x, 2).ToString());
}
</code></pre>
<p>こんな風になります。uGUIの標準コントロールに関しては直接EventAsObservableできるように拡張されてます。ともあれ、uGUIのイベントハンドリングはスクリプトで行いましょう。uGUI標準のAddHandlerなどはやりづらいですが、UniRxはそれを簡単に行える仕組みが用意してあります。uGUIのチュートリアルや解説本では、インスペクタのイベントの部分をクリックしてメソッドと紐付けてー、などとやるかもしれませんが、あのやり方は最低最悪なので忘れましょう。スクリプトレスでイベント設定できるとか幻想なんで、少なくともRxを使おうとしているようなプログラマなら、一切見なかったことにしましょう。100億パーセントどうでもいい次元の話なので無視しておきましょう。やりづらいだけです。</p>
<p>unityEvent.AsObservableのかわりに、全てのUnityコントロールにはUnityEventAsObservableが定義されています。ButtonのonClickの場合は違いはないのですが、一部の値が流れるものに関しては違いがあって、コントロールに直接生えているものは初期値が流れるようになっています。この初期値が流れる、という性質は非常に重要です。と、いうのも、今回のようにUIを宣言的に記述した場合、初期値が流れないと、初期値を設定して回らなければならなくて全体の構築が狂ってしまうからです。と、いうわけで、基本的にはコントロールに生えているAsObservableを使いましょう。</p>
<h2>ReactiveProperty</h2>
<p>UniRx 4.8からReactivePropertyという特別な型が用意されています（あとReactiveCollectionとReactiveDictionary）。これは何かというと、通知可能なプロパティ。なんのこっちゃ。うーん、イベントと値がセットになった型。うーん、なんのこっちゃ……。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 変更通知付きなモデル
public class Enemy
{
    // HPは変更あったら通知して他のところでなんか変化を起こすよね？
    public ReactiveProperty&lt;long&gt; CurrentHp { get; private set; }

    // 死んだら通知起こすよね？
    public ReadOnlyReactiveProperty&lt;bool&gt; IsDead { get; private set; }

    public Enemy(int initialHp)
    {
        // 宣言的に記述していく。
        // ReactivePropertyはそれ自体がIObservable&lt;T&gt;なので、Rxでチェーン可能で、更にそれをReactivePropertyに変換も可能
        // 死んだかどうかというのはHPが0以下になったら、で表現できる         
        CurrentHp = new ReactiveProperty&lt;long&gt;(initialHp);
        IsDead = CurrentHp.Select(x =&gt; x &lt;= 0).ToReadOnlyReactiveProperty();
    }
}

// こんなふうにして使う
// ボタンクリックしたらHPが99減ってくとする（実際はなんかCollision受けたら減るとか色々）
// ReactivePropertyの値は.Valueで取り出せる)
MyButton.OnClickAsObservable().Subscribe(_ =&gt; enemy.CurrentHp.Value -= 99);

// その変更を受けてUIに変更を戻す
enemy.CurrentHp.SubscribeToText(MyText); // とりあえず現在HPをTextに表示

// もし死んだらボタンクリックできないようにする
enemy.IsDead.Select(isDead =&gt; !isDead).SubscribeToInteractable(MyButton);
</code></pre>
<p>今まではイベント＋普通の値で表現していたものが、プロパティ一個で表現できるようになります。また、イベント自体の取り扱いもRxなので合成可能になっていて、取り回しが向上します。というわけで、めちゃくちゃ便利。実際便利。通知が必要な値は片っ端からReactivePropertyにしましょう、それで幸せになれます！</p>
<p>更にReactivePropertyはInspectorで利便性が向上しています。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/RxPropInspector.png" alt="" /></p>
<p>IntRxPropのところ、インスペクタに値を表示しているのですが、これの値をインスペクタで変更すると、紐付けていたイベント(.Subscribeしているもの)への通知も飛んでいきます。地味に捗る神機能。注意点としては、ジェネリックの型はインスペクタに表示できないという制限を引き継いでいるので、インスペクタに表示したいReactiveProeprtyは、専用のReactivePropertyを使いましょう。例えばIntReactivePropertyやBoolReactiveProperty、Vector2ReactivePropertyなどが標準では用意されています。EnumをReactiveProeprtyとして表示したい、というシチュエーションも多いと思います。その場合はSpecializedなReactivePropertyを定義していきましょう。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなEnumがあるとして
public enum Fruit
{
    Apple, Grape
}

// こういう特化したReactiveProeprtyを作ればOK
[Serializable]
public class FruitReactiveProperty : ReactiveProperty&lt;Fruit&gt;
{
    public FruitReactiveProperty()
    {
    }

    public FruitReactiveProperty(Fruit initialValue)
        :base(initialValue)
    {
    }
}

// また、InspectorDisplayDrawerにたいしてCustomPropertyDrawerを指定するとインスペクタでの表示が向上/イベント通知が可能になるので
// 特化ReactiveProeprtyの作成とワンセットで行いましょう
// ExtendInspectorDisplayDrawer自体は一個あればそれで大丈夫です
[UnityEditor.CustomPropertyDrawer(typeof(FruitReactiveProperty))]
[UnityEditor.CustomPropertyDrawer(typeof(YourSpecializedReactiveProperty2))] // 他、沢山ここにtypeofを追加していく
public class ExtendInspectorDisplayDrawer : InspectorDisplayDrawer
{
}
</code></pre>
<p>といった感じに拡張することで、より便利になっていきます。</p>
<h2>MV(R)P</h2>
<p>これらのUIの作り方を指して、Model-View-(Reactive)Presenterパターンというものを提唱します。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVP_Pattern.png" alt="" /></p>
<p>なぜMVPか、なんでMVVMではないか。まず、Unityはバインディングエンジンを持っていません。一般的にMVVMはViewとViewModelの間をバインディングエンジンが受け持ちます。なので、素の状態ではそもそもMVVMはできません。じゃあバインディングエンジンを作るか、となると、そんなレイヤーを挟むのは複雑になるしパフォーマンスも低下するし、デメリットがメリットを上回るバインディングエンジンを作るのは難しい。バインディングは誰かが動的レイヤーを引き受けなければならなくて（例えばName直書きなINotifyPropertyChangedであったり)、ピュアC#の世界とは相性が悪い。それをWPFではXAMLに押し付けているが、動的コード生成高速化の手段が取れないUnityでは、無理して実現する価値はない。</p>
<p>そんなわけで、MVVMはやらない。やらないとなると、バインディング機構が存在しない都合上、どこかで、だれかが、Vを知る必要がある(じゃなきゃViewのUpdateがかけれない)。というわけでVMは存在できず、Presenterを立てる。Model自体はPresenterにも依存しないし、Viewは知らない。ただしViewまで伝搬するため通知は可能でなければならない。それらをRxが繋ぎます。従来のMVPはステートの複雑化や伝搬に困難があったが、Observableはバインディングのようにシンプルに通知を行うことができるし、Viewへの適用もバインディングであるかのように綺麗に見せることができる。Rxを介すことによって、アプリケーションを作る上での問題が解消する。しかもレイヤー的にはないに等しく薄いので、一切のデメリットはない。</p>
<p>再度、コードと当てはめてみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Presenter(Canvasのルートだったり、Prefabやパーツ分割単位のルート)
public class ReactivePresenter : MonoBehaviour
{
    // PresenterはViewのコンポーネントを知っている（さわれる）
    public Button MyButton;
    public Toggle MyToggle;
    
    // ModelからのState-Change-EventsはReactivePropertyによって伝搬される
    // Modelの変更は基本的に自身が上層に通知可能であり、それはReactiveProeprtyで表現される
    Enemy enemy = new Enemy(1000);

    void Start()
    {
        // Viewからのuser eventsはRxによって伝搬され、Modelにまでリアクティブに浸透していく
        MyButton.OnClickAsObservable().Subscribe(_ =&gt; enemy.CurrentHp.Value -= 99);
        MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);

        // Modelからの伝搬もまた、Presenterを介してRxによってViewのUpdateをかける
        enemy.CurrentHp.SubscribeToText(MyText);
        enemy.IsDead.Where(isDead =&gt; isDead == true)
            .Subscribe(_ =&gt;
            {
                MyToggle.interactable = MyButton.interactable = false;
            });
    }
}
</code></pre>
<p>この場合、ViewとPresenterの紐付けはUnityのインスペクタでやります、ぴっ、ぴっ、ぴっってドラッグアンドドロップですねん。ふつーの（？）MVPだと、このViewをIViewとしてモックと差し替え可能にしたりもしたりしなかったりですが、そこまでやってもメリットゼロなんでそんなことはやらないでダイレクトにViewの実体とひもづける形でOK。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVRP_Loop.png" alt="" /></p>
<p>それぞれの伝搬ポイントにUniRxのメソッドやクラスが用意されているので、全てをシームレスに、Reactiveにつなぎ合わせることが可能です。UniRxならね。これの何が嬉しいかというと、見通しが良く、コード量が減ります。それがもう単純に嬉しい。また、イベントの関連付けはスクリプト側に寄っているので、インスペクタがカオティックにならずに済みます。かなりUnity(+Rx)の現実に沿った作り方なのではないかなー、と思うのですがどうでしょう？この辺は意見大募集中といったところです。</p>
<h2>カスタムトリガーを作ろう</h2>
<p>そんな風にアプリケーションを作っていくと、イベントはRx的に発動させるのが都合が良い、ということがわかってきます。実際そう。で、SubjectやReactivePropertyなどを駆使することによりModelをRx的に作っていくのは可能なのですが、ViewからのイベントをRx的に流すためにはどうすればいいのか。標準ではTriggerが用意されてますが、それだけじゃ足りない、例えばロングタップ作りたいとかジェスチャー作りたいとか……。という場合はTriggerを自作します。作り方は、ObservableTriggerBaseを継承して……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ObservableLongPointerDownTrigger : ObservableTriggerBase, IPointerDownHandler, IPointerUpHandler
{
    public float IntervalSecond = 1f;

    Subject&lt;Unit&gt; onLongPointerDown;

    float? raiseTime;

    void Update()
    {
        if (raiseTime != null &amp;&amp; raiseTime &lt;= Time.realtimeSinceStartup)
        {
            if (onLongPointerDown != null) onLongPointerDown.OnNext(Unit.Default);
            raiseTime = null;
        }
    }

    void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
    {
        raiseTime = Time.realtimeSinceStartup + IntervalSecond;
    }

    void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
    {
        raiseTime = null;
    }

    public IObservable&lt;Unit&gt; OnLongPointerDownAsObservable()
    {
        return onLongPointerDown ?? (onLongPointerDown = new Subject&lt;Unit&gt;());
    }

    protected override void RaiseOnCompletedOnDestroy()
    {
        if (onLongPointerDown != null)
        {
            onLongPointerDown.OnCompleted();
        }
    }
}
</code></pre>
<p>こんな感じ、これで他のTriggerと同じノリ、OnPointerDownAsObservableでタップを拾えるように、OnLongPointerDownAsObservableでロングタップを拾えるようになります。Subjectでイベント通知することと、RaiseOnCompletedOnDestroyのところでOnCompletedを発行するのが原則です。こういう形でイベントを拡張すると、よりスムーズにRxで全てが繋がっていきます！</p>
<h2>ライフサイクル管理</h2>
<p>で、全部がRxになると、イベントをSubscribeしたのをどこで解除すればいーんですかー、って話になってきたりこなかったりする。基本的にTrigger系は自身が死んだ時に終了するからいいんですが、それ意外のもの、例えばObservable.TimerやObservable.EveryUpdateは自動的に止まらないので、自分で登録解除する必要があります。そのためのヘルパーとして、IDisposable.AddToがUniRxには用意されています。また、CompositeDisposableがSubscriptionの管理に使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// CompositeDisposableはList&lt;IDisposable&gt;のようなもので、複数のIDisposableが管理できます
CompositeDisposable disposables = new CompositeDisposable(); // これをfieldにおいておいて

void Start()
{
    Observable.EveryUpdate().Subscribe(x =&gt; Debug.Log(x)).AddTo(disposables); // AddToで詰める
}

void OnTriggerEnter(Collider other)
{
    // .Clear() =&gt; 中の全てのdisposableのDisposeが呼ばれて、Listが空になります
    // .Dispose() =&gt; 中の全てのdisposableのDisposeが呼ばれて、以降はAddされたら即対象をDisposeするようになります
    disposables.Clear();
}
</code></pre>
<p>よくあるシチュエーションとして、Destroyした瞬間に解除したい、というのがあると思います。その場合AddTo(gameObject/component)が使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">void Start()
{
    // 自分が消滅したらDispose
    Observable.IntervalFrame(30).Subscribe(x =&gt; Debug.Log(x)).AddTo(this);
}
</code></pre>
<p>DisposeじゃなくてOnCompletedを出して欲しい、という場合にはTakeWhile, TakeUntil, TakeUntilDestroy, TakeUntilDisable辺りが使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.IntervalFrame(30).TakeUntilDisable(this)
    .Subscribe(x =&gt; Debug.Log(x), () =&gt; Debug.Log(&quot;completed!&quot;));
</code></pre>
<p>イベントを「繰り返す」場合に、Repeatが通常使われますが、実は危険です。源流がOnCompletedを発行すると無限ループ化するからです。ObservableTriggersが終了するとOnCompletedを発行するため、安易なRepeatの使用は無限ループ行きとなります。それを避けるには、RepeatUntilDestroy(gameObject/component), RepeatUntilDisable(gameObject/component), RepeatSafeが使えます。RepeatUntilDestroyとかは文字通りなんですが、RepeatSafeは連続してOnCompltedが発行された場合はRepeatを取りやめるという、無限ループ禁止機構のついたRepeatです。ベンリ。</p>
<p>最後に、ObserveEveryValueChangedを紹介します。これは、ラムダ式で指定した値を変更のあった時にだけ通知するという、つまり変更通知のない値を変更通知付きに変換するという魔法のような（実際ベンリ！）機能です（実際は毎フレーム監視してるんで、ポーリングによる擬似的なPull→Push変換）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// watch position change
this.transform.ObserveEveryValueChanged(x =&gt; x.position).Subscribe(x =&gt; Debug.Log(x));
</code></pre>
<p>これは監視対象がGameObjectの場合はDestroy時にOnCompletedを発行して監視を止めます。通常のC#クラス（POCO）の場合は、GCされた時に、同様にOnCompletedを発行して監視を止めるようになっています（内部的にはWeakReferenceを用いて実装されています）。ただのポーリングなので多用すぎるとアレですが、お手軽でベンリには違いないので適宜どうぞ。</p>
<h2>パフォーマンス</h2>
<p>パフォーマンスの話は一口で言うには結構難しいところです。まずいうと、RxとLINQを関連付けてLINQだからパフォーマンスがー、というのは微妙にあてはまりません。RxはPush型、最初のタイミングでパイプラインを構築し、それを（大抵の場合）かなり長い期間（最長でObjectが消滅するまで）購読する形になります。つまり、ライフサイクルが非常に長い。だから、パイプライン構築のためのオブジェクト（のGC）のコストというのは、そんなでもないと思ってもらっていいでしょふ。Updateの度に頻繁に数千構築/解体を繰り返すようなものではない、ということですねん。パイプラインに流れる値に関しては、その頻度と書きよう次第ですけれど。また、Rxのメソッドも軽いメソッドと重いメソッドがあるので、それ次第という面もあります。とはいえそこまで気にするほどではないかなー、と。</p>
<p>全体的にRxを適用すると、アプリケーションはPushベースで構築されることになるので、頻繁な問い合わせ処理(Pullベース)が消え、つまり更新駆動の最小限の差分処理だけが走るので、逆にパフォーマンスは上がる、という見方もできなくもないですが、まぁさすがにそれは都合の良すぎる捉え方でしょう:) ともあれ、そういったアプリケーション構築手法の変革もあるので、そこのところも含めて評価しなければなりません。</p>
<p>単純なコルーチンの代替、非同期通信処理の代替レベルでなら、実質ない、と言っても過言ではないところなので、それぐらいならばもうまるっきり気にせず、ですね。また、今まではObservableMonoBehaviourが不要な場合にも空イベントを回していて、それが若干の消費があったのですが、今回からは軽量なTriggerベースで必要なものにしかイベントを付与しないスタイルになったので、全体的にはかなり取り回しよくなってきたんじゃないかなー、と思います。</p>
<p>まだまだ全然パフォーマンスチューニングできる領域は沢山あるので、都度行っていくつもりです（分かりやすく効果の出るところでいえばWhere.Where.Whereチェーンは1個のWhereにできたり、かなり多用されるWhere.Selectチェーンも1個のWhereSelectチェーンにまとめあげられたり、などなど）</p>
<h2>LINQ to GameObject</h2>
<p>あと、これはUniRxとは関係ないのですがLINQ to GameObjectもアップデートしてます。</p>
<ul>
<li><a href="https://github.com/neuecc/LINQ-to-GameObject-for-Unity">GitHub - LINQ to GameObject</a></li>
<li><a href="http://u3d.as/content/neuecc/linq-to-game-object">UnityAssetStore - LINQ to GameObject</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/neuecc/LINQ-to-GameObject-for-Unity/master/Images/axis.jpg" alt="" /></p>
<p>メインはLINQ風メソッドでtransformを自在に辿れるってところで、それは<a href="http://neue.cc/2014/11/11_482.html">LINQ to GameObjectによるUnityでのLINQの活用</a>を読んでいたたきたいのですが、もう一つの機能に、階層上の任意の位置にGameObjectをAddしたりMoveしたりするメソッドもあります。今回のアップデートで、これがuGUIのRectTransformに対応しました！uGUIはヒエラルキーの位置を表示情報としてかなり大事に扱うため、それのコントロールが容易になるLINQ to GameObjectは役立つはずです。</p>
<h2>まとめ</h2>
<p>今回のObservableTrigger、uGUI連携、そしてLifetime管理といった機能によって、より様々なところに導入しやすくなった、より使いやすくなったのではないでしょうか！</p>
<p>直近では4/16 18:30~の<a href="http://kbkz.connpass.com/event/12597/">歌舞伎座.tech#7「Reactive Extensions」</a>で「Observable Everywhere - UniRxによるUnityでのReactive Programming」と題して発表を行います。こちらはニコ生での放送もあるようなので、見るといいんじゃないかなー、ということで！</p>
</div>
<h1 data-pagefind-sort="date:2015-04-02" data-pagefind-meta="published:2015-04-02"><a href="https://neue.cc/2015/04/02_509.html">Microsoft MVP for .NET(C#)を再々々々受賞しました</a></h1>
<ul class="date"><li>2015-04-02</li></ul>
<div class="entry_body"><p>今年も受賞で、5年目です。実は今年から受賞分野がC#が.NETに統合されたので、エキスパタイズとしてはfor .NETになります。</p>
<p>会社は第一段階が終わり、といった感じで、それに付随する活動内容としても総まとめみたいなものが多かったかな、といったところでしょうか。今年はまた次の段階の始まりということで、より新しい勝負が必要になってきています。今、私が主に力を入れているのはUnityと、そのReactive Extensions実装の<a href="https://github.com/neuecc/UniRx">UniRx</a>で、特にUniRxはかなりヒットさせられたとは思います。が、まだまだ兆しといったところなので、確固たるものにしなければならない。また、それを基盤にして、C#の強さというのを、ただの今までの.NETコミュニティにだけに留まらず、幅広い世界に届ける、伝えていきたいし、幸いにして私はそれが出来る立場にいると思っています。</p>
<p>より力強く、Real World C#というのを示し続けてきます。そんなわけで引き続き、今年もよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2015-03-25" data-pagefind-meta="published:2015-03-25"><a href="https://neue.cc/2015/03/25_508.html">グラニのC#フレームワークの過去と未来、現代的なASP.NETライブラリの選び方</a></h1>
<ul class="date"><li>2015-03-25</li></ul>
<div class="entry_body"><p><a href="http://www.buildinsider.net/event/meetup/grani01">Build Insider MEETUP with Grani</a>というイベントで、グラニのC#フレームワーク（というほどのものはない！）の今までとこれからってのを話しました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/46267391" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/a-framework-for-light-up-applications-of-grani" title="A framework for light up applications of grani" target="_blank">A framework for light up applications of grani</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>そのうちBuild Insiderで文字起こしとか公開されると思います。</p>
<p>2015年の今、どういうライブラリを選んだか、とかNLog大脱却、とかって話が見どころですかね。うちの考えるモダンなやり方、みたいな感じです。</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/2015/03/dotnetlibraries2015.png' alt='' />
</p>
<p>実際、<a href="https://msdn.microsoft.com/ja-jp/library/system.diagnostics.tracing.eventsource.aspx">EventSource</a>や<a href="https://msdn.microsoft.com/en-us/library/dn440729.aspx">Semantic Logging Application Block</a>は良いと思いますので、触ってみるといいですね。少なくとも、イマドキにハイパーヒューマンリーダブル非構造化テキストログはないかなぁ、といったところです。</p>
<p>スライドにしたら判別不能になったOWINのStartup部分も置いておきます、参考までに。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 開発環境用Startup（本番では使わないミドルウェア/設定込み）
public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        app = new ProfilingAppBuilder(app); // 内製Glimpse表示用AppBuilderラッパー(Middlewareトラッカー)
        app.EnableGlimpse(); // Glimpse.LightNdoe同梱ユーティリティ
        app.Use&lt;GlobalLoggingMiddleware&gt;(); // 内製ロギングミドルウェア
        app.Use&lt;ShowErrorMiddleware&gt;(); // 内製例外時表示ミドルウェア

        app.Map(&quot;/api&quot;, builder =&gt;
        {
            var option = new LightNodeOptions(AcceptVerbs.Get | AcceptVerbs.Post,
                new LightNode.Formatter.Jil.JilContentFormatter(),
                new LightNode.Formatter.Jil.GZipJilContentFormatter())
            {
                OperationCoordinatorFactory = new GlimpseProfilingOperationCoordinatorFactory(),
                ErrorHandlingPolicy = ErrorHandlingPolicy.ThrowException,
                OperationMissingHandlingPolicy = OperationMissingHandlingPolicy.ThrowException,
            };

            builder.UseLightNode(option);
        });
        // Indexはデバッグ画面に回す
        app.MapWhen(x =&gt; x.Request.Path.Value == &quot;/&quot; || x.Request.Path.Value.StartsWith(&quot;/DebugMenu&quot;), builder =&gt;
        {
            builder.UseFileServer(new FileServerOptions()
            {
                EnableDefaultFiles = true,
                EnableDirectoryBrowsing = false,
                FileSystem = new PhysicalFileSystem(@&quot;.\DebugMenu&quot;),
            });
        });
        // それ以外は全部404
        app.MapWhen(x =&gt; !x.Request.Path.Value.StartsWith(&quot;/Glimpse.axd&quot;, StringComparison.InvariantCultureIgnoreCase), builder =&gt;
        {
            builder.Run(ctx =&gt;
            {
                ctx.Response.StatusCode = 404;
                return Grani.Threading.TaskEx.Empty;
            });
        });
    }
}
</code></pre>
<p>インデックスでアクセスすると表示するページはGlimpse.axdと、シングル全画面ページで表示できるローンチ部分へのリンクを貼っつけてあります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Debug Index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    APIのデバッグ&lt;br /&gt;
    &lt;p&gt;
        &lt;a href=&quot;../../Glimpse.axd?n=glimpse_redirect_popup&quot;&gt;Glimpse Launch&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;a href=&quot;../../glimpse.axd&quot;&gt;Glimpse Config&lt;/a&gt;
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>まぁ、こういうのあると、Glimpseへのアクセスが近くで非常に便利です。</p>
<p>あと最後に、OWINでやるならこーいうのどうでしょう、というWeb.config。Owin Middlewareと機能重複して鬱陶しいからHttpModule丸ごと消そうぜ、という過激派な案ですにゃ。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;!-- OWIN向けウェブコン --&gt;
&lt;!-- Glimpse系のはリリース時にはxsltでまるっと消す --&gt;
&lt;configuration&gt;
    &lt;configSections&gt;
        &lt;section name=&quot;glimpse&quot; type=&quot;Glimpse.Core.Configuration.Section, Glimpse.Core&quot; /&gt;
    &lt;/configSections&gt;
    &lt;connectionStrings configSource=&quot;&lt;!-- 接続文字列は外部に回す(DebugとReleaseでxsltで変換して別参照見るように) --&gt;&quot; /&gt;
    &lt;appSettings&gt;
        &lt;!-- なんかここに書いたり外部ファイルとmergeしたり:) --&gt;
    &lt;/appSettings&gt;
    &lt;system.web&gt;
        &lt;!-- system.web配下のは片っ端から消してしまう --&gt;
        &lt;httpModules&gt;
            &lt;clear /&gt;
            &lt;add name=&quot;Glimpse&quot; type=&quot;Glimpse.AspNet.HttpModule, Glimpse.AspNet&quot; /&gt;
        &lt;/httpModules&gt;
        &lt;httpHandlers&gt;
            &lt;clear /&gt;
            &lt;add path=&quot;glimpse.axd&quot; verb=&quot;GET&quot; type=&quot;Glimpse.AspNet.HttpHandler, Glimpse.AspNet&quot; /&gt;
        &lt;/httpHandlers&gt;
        &lt;roleManager&gt;
            &lt;providers&gt;
                &lt;clear /&gt;
            &lt;/providers&gt;
        &lt;/roleManager&gt;
        &lt;customErrors mode=&quot;Off&quot; /&gt;
        &lt;trace enabled=&quot;false&quot; /&gt;
        &lt;sessionState mode=&quot;Off&quot; /&gt;
        &lt;httpRuntime targetFramework=&quot;4.5&quot; requestPathInvalidCharacters=&quot;&quot; /&gt;
        &lt;globalization culture=&quot;ja-jp&quot; uiCulture=&quot;ja-jp&quot; /&gt;
        &lt;!-- リリース時にxsltでfalseにする --&gt;
        &lt;compilation debug=&quot;true&quot; /&gt;
    &lt;/system.web&gt;
    &lt;system.webServer&gt;
        &lt;validation validateIntegratedModeConfiguration=&quot;false&quot; /&gt;
        &lt;globalModules&gt;
            &lt;clear /&gt;
        &lt;/globalModules&gt;
        &lt;modules&gt;
            &lt;!-- モジュールも全消し --&gt;
            &lt;remove name=&quot;OutputCache&quot; /&gt;
            &lt;remove name=&quot;Session&quot; /&gt;
            &lt;remove name=&quot;UrlRoutingModule-4.0&quot; /&gt;
            &lt;!-- 以下デフォで読まれるモジュール名が延々と続く(system.webServer下は一括clearが使えなくて辛い)... --&gt;
            &lt;add name=&quot;Glimpse&quot; type=&quot;Glimpse.AspNet.HttpModule, Glimpse.AspNet&quot; preCondition=&quot;integratedMode&quot; /&gt;
        &lt;/modules&gt;
        &lt;handlers&gt;
            &lt;add name=&quot;Glimpse&quot; path=&quot;glimpse.axd&quot; verb=&quot;GET&quot; type=&quot;Glimpse.AspNet.HttpHandler, Glimpse.AspNet&quot; preCondition=&quot;integratedMode&quot; /&gt;
        &lt;/handlers&gt;
    &lt;/system.webServer&gt;
    &lt;!-- おまじない（笑）セクション --&gt;
    &lt;system.net&gt;
        &lt;connectionManagement&gt;
            &lt;add address=&quot;*&quot; maxconnection=&quot;1024&quot; /&gt;
        &lt;/connectionManagement&gt;
        &lt;settings&gt;
            &lt;servicePointManager expect100Continue=&quot;false&quot; useNagleAlgorithm=&quot;false&quot; /&gt;
        &lt;/settings&gt;
    &lt;/system.net&gt;
    &lt;!-- WebServiceでやるならPersistResultsで（当然このセクションもリリースでは消す） --&gt;
    &lt;glimpse defaultRuntimePolicy=&quot;PersistResults&quot; endpointBaseUri=&quot;~/Glimpse.axd&quot;&gt;
        &lt;tabs&gt;
            &lt;ignoredTypes&gt;
                &lt;add type=&quot;Glimpse.AspNet.Tab.Cache, Glimpse.AspNet&quot; /&gt;
                &lt;add type=&quot;Glimpse.AspNet.Tab.Routes, Glimpse.AspNet&quot; /&gt;
                &lt;add type=&quot;Glimpse.AspNet.Tab.Session, Glimpse.AspNet&quot; /&gt;
                &lt;add type=&quot;Glimpse.Core.Tab.Trace, Glimpse.Core&quot; /&gt;
            &lt;/ignoredTypes&gt;
        &lt;/tabs&gt;
        &lt;runtimePolicies&gt;
            &lt;ignoredTypes&gt;
                &lt;add type=&quot;Glimpse.Core.Policy.ControlCookiePolicy, Glimpse.Core&quot; /&gt;
                &lt;add type=&quot;Glimpse.Core.Policy.StatusCodePolicy, Glimpse.Core&quot; /&gt;
                &lt;add type=&quot;Glimpse.Core.Policy.AjaxPolicy, Glimpse.Core&quot; /&gt;
                &lt;add type=&quot;Glimpse.AspNet.Policy.LocalPolicy, Glimpse.AspNet&quot; /&gt;
                &lt;add type=&quot;Glimpse.Core.Tab.Trace, Glimpse.Core&quot; /&gt;
            &lt;/ignoredTypes&gt;
        &lt;/runtimePolicies&gt;
    &lt;/glimpse&gt;
&lt;/configuration&gt;
</code></pre>
<p>Web API的なサービスでもGlimpse使えるよ！ってのはもっと知ってほしいかしらん。その辺は<a href="http://neue.cc/2015/02/16_505.html">LightNode 1.0、或いはWeb APIでのGlimpseの使い方</a>で詳しく解説しています。</p>
</div>
<h1 data-pagefind-sort="date:2015-02-16" data-pagefind-meta="published:2015-02-16"><a href="https://neue.cc/2015/02/16_505.html">LightNode 1.0、或いはWeb APIでのGlimpseの使い方</a></h1>
<ul class="date"><li>2015-02-16</li></ul>
<div class="entry_body"><p>こないだ、Redisクライアントの<a href="http://neue.cc/2015/02/06_504.html">CloudStructuresを1.0にしたばかり</a>ですが、今回は大昔に作った自作Web APIフレームワークのLightNodeを1.0にしました。なんでドタバタやってるのかというと、<a href="https://github.com/aspnet/XRE">.NET XRE</a>(ASP.NET vNext)を様子見してたんですが、そろそろ今年一年どうしていくかの態度を決めなければならなくて、結論としては、OWINで行くことにしたからです。ちゃんちゃん。その辺の理由なんかは後ほど。</p>
<p>さて、<a href="http://getglimpse.com/">Glimpse</a>です。なにはなくともGlimpseです。イマドキでC#でウェブ作るんなら、まずはGlimpse入れましょう。絶対必須です。使ったことないんなら今すぐ使ってください。圧倒的なVisual Profiling！ボトルネックが一目瞭然。コンフィグも一覧されるので、普段気にしていなかったところも丸見え。データアクセスが何やってるかも一発で分かる。ちなみに、競合としては昔あったMiniProfilerは窓から投げ捨てましょう。ASP.NET開発はもはやGlimpse以前と以後で分けられると言っても過言ではない。</p>
<p>で、LightNode 1.0です。変更点はGlimpseにフル対応させたことで、ついでに細かいとこ直しまくりました、と。ともあれGlimpse対応が全てです。</p>
<ul>
<li><a href="https://github.com/neuecc/LightNode">GitHub - LightNode</a></li>
<li><a href="https://www.nuget.org/packages/LightNode.Server/">NuGet- PM&gt; Install-Package LightNode.Server</a></li>
</ul>
<p>で、作ってる間にGlimpseをWeb API(ASP.NET Web APIとは言ってない)系で使ったり、Owinと合わせて使ったりすることのノウハウも溜まったので、LightNodeの話というかは、そっちのことを放出したいな、というのがこの記事の趣旨ですね！</p>
<h2>OwinでGlimpseを使う</h2>
<p>Glimpse自体はOwinに対応していません。勿論、vNextへの対応も含めてSystem.Webへの依存を断ち切ろうとしたGlimpse v2の計画は随分前から始まっているんですが、Issueをずっと見ている限り、かなり進捗は悪く、難航しているようです。正直、いつ完了するか全く期待持てない感じで、残念ながら待っていても使えるようにはなりません。</p>
<p>しかし、そもそもGlimpseのシステムはただのHttpModuleとHttpHandlerで動いています。つまり、Microsoft.Owin.Host.SystemWebでホストしている限りは、Owinであろうと関係なく動きます。動くはずです。実際Glimpse.axdにアクセスすれば表示されるし、一見動いています。そしてGlimpseにはページ埋め込みの他、Standaloneでの起動が可能(Glimpse.axdでの右側)なのでそこから起動すると……</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/glimpse_standalone_launch.jpg" />
</p>
<p>いくらOwinでページ作ってアクセスしても何も表示されません、データがHistoryに蓄積されません。これにめっちゃハマって以前は諦めたんですが、今回LightNodeをOwinに何が何でも対応させたくて改めて調べた結果、対策分かりました。原因としては、Glimpseはリクエストの完了をPostReleaseRequestStateで受け止めているんですが、Microsoft.Owin.Host.SystemWebでホストしてOwinによるリクエストハンドリングでは、完了してもPostReleaseRequestStateが呼ばれません。結果的にOwinでふつーにやってる限りではGlimpseでモニタできない。</p>
<p>対策としては、単純に手動でEndRequestを叩いてやればいいでしょう。Middlewareを作るなら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public Task Invoke(IDictionary&lt;string, object&gt; environment)
{
    return next(environment).ContinueWith((_, state) =&gt;
    {
        ((state as HttpContext).Application[&quot;__GlimpseRuntime&quot;] as IGlimpseRuntime).EndRequest();
    }, System.Web.HttpContext.Current);
}
</code></pre>
<p>ということになります。このMiddlewareを真っ先に有効にしてやれば、全てのOwinパイプラインが完了した際にEndRequestが叩かれる、という構造が出来上がります。System.Webをガッツリ使ったMiddlewareなんて気持ち悪いって？いやいや、まぁいーんですよ、そもそもGlimpseがSystem.Webでしか現状動かないんだから、ガタガタ言うでない。</p>
<p>さて、LightNodeのGlimpse対応DLLにはこのMiddlewareを最初から同梱してあります。LightNodeでGlimpse対応のConfigurationを書く場合は、以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Configuration(Owin.IAppBuilder app)
{
    app.EnableGlimpse();
    app.MapWhen(x =&gt; !x.Request.Path.Value.StartsWith(&quot;/glimpse.axd&quot;, StringComparison.OrdinalIgnoreCase), x =&gt;
    {
        x.UseLightNode(new LightNodeOptions()
        {
            OperationCoordinatorFactory = new GlimpseProfilingOperationCoordinatorFactory()
        });
    });
}
</code></pre>
<p>まずEnableGlimpse、これが先のEndRequestを手動で叩くものになってます。次にMapWhenで、Glimpse.axdだけOwinパイプラインから外してやることで、LightNodeと共存させられます！ついでに、LigthNodeでのGlimpseモニタリングを有効にする場合はGlimpseProfilingOperationCoordinatorFactoryをOptionに渡してあげれば全部完了。</p>
<h2>LightNode+GlimpseによるWeb APIモニタリング</h2>
<p>何ができるようになるの？何が嬉しいの？というと、勿論当然まずはTimelineへの表示。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/glimpse_lightnode_timeline.jpg" width="640" />
</p>
<p>フィルター(Before/After)とメソッド本体がTimeline上で見えるようになります。これは中身何もないですが、勿論DatabaseやRedis、Httpアクセスなどがあれば、それらもGlimpseは全部乗っけることができるし、それらをWeb APIでも見ることができる。圧倒的に捗る。</p>
<p>そしてもう一つがLightNodeタブ。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/lightnode_glimpse_infotab.jpg" width="640" />
</p>
<p>一回のリクエストのパラメータと、戻り値が表示されます。API開発の辛さって、戻り値が見えない（クライアント側でハンドリングして何か表示したりするも、領域的に見づらかったりする）のが結構あるなーって私は思っていて、それがこのLightNodeタブで解消されます。ちなみにもし例外があった場合は、ちゃんと例外を表示します。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/glimpse_infotab_exception.jpg" width="640" />
</p>
<p>また、ExecutionのPhaseが以降はすべてExceptionになってるので、フィルターが遠ったパスも確認しやすいはずです。</p>
<h2>Web APIのためのGlimpseコンフィグ</h2>
<p>Web APIのためにGlimpseを使う場合、ふつーのWeb用のコンフィグだと些か不便なところがあるので、調整したほうがいいでしょう。私のお薦めは以下の感じです。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!-- GlimpseはHUDディスプレイ表示のためなどでレスポンスを書き換えることがありますが、勿論APIには不都合です。
     デフォルトはPersistResults（結果のHistory保存のみ）にしましょう --&gt;
&lt;glimpse defaultRuntimePolicy=&quot;PersistResults&quot; endpointBaseUri=&quot;~/Glimpse.axd&quot;&gt;
    &lt;tabs&gt;
        &lt;ignoredTypes&gt;
            &lt;!-- OWINで使うならこれらは不要でしょう、出てるだけ邪魔なので消します --&gt;
            &lt;add type=&quot;Glimpse.AspNet.Tab.Cache, Glimpse.AspNet&quot; /&gt;
            &lt;add type=&quot;Glimpse.AspNet.Tab.Routes, Glimpse.AspNet&quot; /&gt;
            &lt;add type=&quot;Glimpse.AspNet.Tab.Session, Glimpse.AspNet&quot; /&gt;
        &lt;/ignoredTypes&gt;
    &lt;/tabs&gt;
    &lt;runtimePolicies&gt;
        &lt;ignoredTypes&gt;
            &lt;!-- クライアントがクッキー使うとは限らないので、無視しましょう、そうしないとHistoryに表示されません --&gt;
            &lt;add type=&quot;Glimpse.Core.Policy.ControlCookiePolicy, Glimpse.Core&quot; /&gt;
            &lt;!-- 404とかもAPIならハンドリングして表示したい --&gt;
            &lt;add type=&quot;Glimpse.Core.Policy.StatusCodePolicy, Glimpse.Core&quot; /&gt;
            &lt;!-- Ajaxじゃないなら --&gt;
            &lt;add type=&quot;Glimpse.Core.Policy.AjaxPolicy, Glimpse.Core&quot; /&gt;
            &lt;!-- リモートで起動（APIならそのほうが多いよね？）でも有効にする --&gt;
            &lt;add type=&quot;Glimpse.AspNet.Policy.LocalPolicy, Glimpse.AspNet&quot; /&gt;
        &lt;/ignoredTypes&gt;
    &lt;/runtimePolicies&gt;
&lt;/glimpse&gt;
</code></pre>
<p>defaultRuntimePolicyと、そして特にControlCookiePolicyが重要です。利用シチュエーションとしてStandalone Glimpseで起動してHistoryから結果を見る、という使い方になってくるはずなので（というかWeb APIだとそうしか方法ないし）、Cookieで選別されても不便すぎるかな、ブラウザからのAjaxならともかくモバイル機器から叩かれてる場合とかね。</p>
<p>さて、それは別として、様々なクライアントからのリクエストが混ざって判別できないというのも、それはそれで不便です。これを区別する手段は、あります。それは、クッキーです（笑） 判別用にクッキーでID振ってやるとわかりやすくていいでしょう。例えば以下の様な感じです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.CreateHttp(&quot;http://localhost:41932/Member/Random?seed=13&quot;);
// &quot;glimpseid&quot; is Glimpse's client grouping key
req.CookieContainer = new CookieContainer();
req.CookieContainer.Add(new Uri(&quot;http://localhost:41932&quot;), new Cookie(&quot;glimpseid&quot;, &quot;UserId:4&quot;));
</code></pre>
<p>glimpseidというのがキーなので、例えばそこにユーザーIDとか振っておくと見分けがついてすごく便利になります。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/glimpse_history_clientgrouping.jpg" />
</p>
<p>こんな感じです。これはデバッグビルド時のみといった形で、クライアントサイドで埋め込んであげたいですね。</p>
<h2>LightNodeを使う利点</h2>
<p>というわけでGlimpseとの連携が超強力なわけですが、LightNode自体はまず言っておくと、誰にでも薦めはしません。この手のフレームワークで何より大事なのが標準に乗っかることです。C#での大正義はASP.NET Web APIです、そこは揺るぎません。その上でLightNodeの利点は「シンプルなAPIがシンプルに作れる」「Glimpseによる強力なデバッグ支援」「クライアントコード自動生成」です。特に非公開のインターナルなWeb API層向けですね。反面お薦めしないのは、RESTfulにこだわりたい人です。LightNodeは設計思想として徹底的にRESTfulを無視してるんで、準拠するつもりは1ミリもありません。例えば、インターナルなAPIでRESTfulのために1つのURIを決めるのに3日議論するとか、凄まじく馬鹿げているわけで。LightNodeは悩みを与えません、そもそもメソッド書くしかできないという制約を与えているから。</p>
<p>凝ったルーティングもアホくさい。インターナルなWeb APIで、モバイル機器からのアクセスを前提にすると、クライアントサイドでのAPIライブラリを書くことになりますが、ルーティングが凝っていれば凝っているほど対応が面倒くさいだけ、という。嬉しさなんて0.1ミリもない。結局、ルールはある程度固定のほうが良いんですよ。さすがにパブリックAPIなら長いものに適当に巻かれて適当に誤魔化しますが。</p>
<p>というわけで、どういう人に薦めるかというと「とりあえずサクッとWeb API作りたい人」「モバイルクライアントからアクセスするインターナルなWeb APIを作りたい人」ですかねー。別にパブリックなのも作れないことはないですけど、別にそこまで違和感あるURLになるわけでもないですしね。</p>
<p>ちなみに、MVCとの共存は可能です。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Configuration(IAppBuilder app)
{
    app.Map(&quot;/api&quot;,  x =&gt;
    {
        x.UseLightNode();
    });
}
</code></pre>
<p>といった感じにapi以下をLightNodeのパスってことにすればOK。それ以外のパスではASP.NET MVCが呼ばれます。ルートが変わるだけなので、他のコンフィグは不要です。あんまり細かくゴチャゴチャやると辛いだけなので、このぐらいにしておくのがいいですね。ちなみに、Owinで困るのはHttpModuleとの共存だったりします。実行順序もグチャグチャになるし(一応、少しはOwin側でコントロールかけられますが、辛いしね)同じようなものが複数箇所にあるというのは、普通にイけてない。これはMiddlewareのほうに寄せていきたいところ。脱HttpModule。</p>
<h2>まとめ</h2>
<p>あ、で、OWINな理由って言ってませんでしたっけ。なんかねー、XREは壮大すぎて危険な香りしかしないんですよ。少なくとも、今年の頭（今）に、今年に使う分のテクノロジーを仕込むには、賭けられないレベルで危なっかしい。Previewで遊びながら生暖かく見守るぐらいがちょうどいいです。まあ、アタリマエだろっていえばアタリマエ(ベータすら出てないものを実運用前提で使い出すとかマジキチである)ですけどね、だから別にXREがダメとかそういう話じゃないですよ。むしろXREはまだ評価できる段階ですらないし。</p>
<p>で、今は過渡期で宙ぶらりんなのが凄く困る話で、そのブリッジとしてOWINはアリかな、と。OWIN自体の未来は、まぁ<a href="http://blog.xin9le.net/entry/2015/01/18/161631">ASP.NET 5はどうしてOWIN上に乗らなかったのか</a>にあるように、Deadでしょう。しかし、今から来年の分(XREが実用になった世代)を仕込むには、System.Webへの依存の切り離しや、Owin的なパイプラインシステムへの適用は間違いなく重要。OWINならコーディングのノリもASP.NET 5と変わらないしコードの修正での移行も容易になる、最悪互換レイヤーを挟んで適用できるので、「今」の選択としては、消極的にアリです。</p>
<p>ASP.NET Web APIは、うーん、ASP.NET MVCとの統合が見えてる今、改めて選びたくない感半端ないんだよねぇ。GlimpseはASP.NET Web API対応しないの？というと、そういう話もあるにはあったようですが、色々難航していて、PullRequestで物凄く時間かけて（70レス以上！一年近く！）、それでも結局取り込まれてないんですよ。ここまで来るともはやGlimpse v2でのvNext対応でMVC統合されてるんだからそれでいいじゃん、に落ち着きそうで、恐らくもう動きはないでしょう。とか、そういう周辺のエコシステムの動きも今のASP.NET Web APIは鈍化させる状況にあるわけで、あんまポジティブにはなれないなぁ。とはいえ、現状のスタンダードなWeb API構築フレームワークとして消極的にアリ、と言わざるをえないけれど。ちなみにNancyは個人的には全くナシです、あれのどこがいいのかさっぱりわからない。</p>
<p>Glimpseの拡張は、ちょうど社内用拡張も全部書き換えたりして、ここ数日でめちゃくちゃ書きまくったんで、完全に極めた！うぉぉぉぉ、というわけで拡張ガイダンスはいつかそのうち書くかもしれませんし、多分書きません。つーかGlimpseちゃんと日本の世の中で使われてます？大丈夫かなー、さすがにGlimpseは圧倒的に良いので標準レベルで使われなければならないと思うのですけれど。</p>
<p>あー、で、LightNodeは、まあ良く出来てますよ、用途の絞り方というか課題設定が明確で、実装もきっちりしてありますし。うん、私は好きですけど（そりゃそうだ）、人に薦めるかといったら、Microsoftの方針がOwin的なオープンの流れから、やっぱり大Microsoft的なところに一瞬で戻ったりしてるんで(Hanselmanには少し幻滅している)、まぁ長いものには巻かれておきましょう。</p>
</div>
<h1 data-pagefind-sort="date:2015-02-06" data-pagefind-meta="published:2015-02-06"><a href="https://neue.cc/2015/02/06_504.html">CloudStructures 1.0 - StackExchange.Redis対応、RedisInfoタブ(Glimpse)</a></h1>
<ul class="date"><li>2015-02-06</li></ul>
<div class="entry_body"><p>CloudStructures、というRedisライブラリを以前に作ってたわけなのですが(<a href="http://neue.cc/2013/04/05_403.html">CloudStructures - ローカルとクラウドのデータ構造を透過的に表現するC# + Redisライブラリ</a>)、2013年末にGlimpseプラグインを追加してから一切音沙汰がなかった。私お得意の作るだけ作って放置パターンか！と思いきや、ここにきて突然の大更新。APIも破壊的大変更祭り。バージョンもどどーんと上げて1.0。ほぅ……。</p>
<ul>
<li>GitHub - <a href="https://github.com/neuecc/CloudStructures">neuecc/CloudStructures</a></li>
<li>NuGet - <a href="https://nuget.org/packages/CloudStructures/">CloudStructures</a></li>
</ul>
<p>一番大きいのが、ベースにしてるライブラリが<a href="https://code.google.com/p/booksleeve/">BookSleeve</a>から<a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>になりました。StackExchange.RedisはBookSleeveの後継で、そして<a href="http://azure.microsoft.com/ja-jp/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/">Azure Redis Cacheのドキュメント</a>でもマニュアルに使用されているなど、今どきの.NETにおけるRedisクライアントのデファクトの位置にあると言ってよいでしょう。当然、移行する必要があったんですが腰が重くて……。</p>
<p>APIを変えた理由は、以前は「ローカルとクラウドのデータ構造を透過的に表現」というのに拘ってIAsyncCollection的に見せるのに気を配ってたんですが、Redis本来のコマンド表現と乖離があって、かなり使いづらかったんでやめたほうがいーな、と。メソッド名が変わっただけで使い方は一緒なんですが、とりあえずRedisのコマンド名が露出するようになりました。ま、このほうが全然イイですね。抽象化なんて幻想だわさ、特に名前の。</p>
<h2>CloudStructuresの必要性</h2>
<p>こんな得体のしれない野良ライブラリなんて使いたくねーよ、StackExchange.Redisを生で使えばいいじゃん。と、思う気持ちは至極当然でまっとうな感覚だと思います。私もそう思う。そして、単純なStringGet/Setぐらいしか使わないならそれでOKです、本当にただのキャッシュストアとして使うだけならば。しかし、本気でRedisを使い倒す、本気でRedisの様々なデータ構造を活用していこうとすると、StackExchange.Redisを生で使うのは限界が来ます。戻り値のオブジェクトへのマッピングすらないので、そこら中にSeiralize/Deserializeしなければならなくなる。ADO.NETのDbDataReaderを生で使うようなもので、そうなったら普通はなんかラップするよね？ADO.NETにはDapperのようなMicro ORMからEntity FrameworkのようなフルセットのORMまである。StackExchange.Redisが生ADO.NETを志向するならば（これは作者も言明していて、付随機能は足さない方針のようです）ならば、そこにO/R(Object/Redis)マッパーが必要なのは自然のことで、それがCloudStructuresです。</p>
<p>CloudStructuresが提供するのは自動シリアライズ/デシリアライズ、キーからの分散コネクション（シャーディング）、コマンドのロギング、Web.configからの接続管理、そしてGlimpse用の各種可視化プロファイラーです。元々、というか今もCloudStructuresはうちの会社でかなりヘヴィに使ってて（このことは何度か記事でも推してます、技評の<a href="http://gihyo.jp/dev/serial/01/grani/0001">グラニがC#にこだわる理由</a>とか)、コマンドのロギングとかは執拗に拘ってます。今回はそうした長い利用経験から、やっぱイケてない部分も沢山あったので徹底的に見直しました。</p>
<p>シャーディングは、StackExchange.RedisはそもそもConnectionMultiplexerという形で内部で複数の台への接続を抱えられるんですが、これはどちらかというと障害耐性的な機能(Master/Slaveや障害検知時の自動昇格など)が主なので、Memcached的なクライアントサイドでの分散はBookSleeveの時と変わらず持っていません。なので引き続きシャーディングはCloudStructures側の機能として提供しています。</p>
<p>そもそも<a href="http://redis.io/">Redis</a>が必要かどうかだと、んー、私としては規模に関わらず絶対に入れたほうがいいと思ってます。RDBMSの不得意なところを綺麗に補完できるので、RDBMSだけで頑張るよりも、ちょっとしたとこに使ってやると物凄く楽になると思います。導入も<a href="http://azure.microsoft.com/ja-jp/services/cache/">Azure Redis Cache</a>やAWSの<a href="http://aws.amazon.com/jp/elasticache/">ElastiCache for Redis</a>のようにマネージドのキャッシュサービスが用意されているので、特にクラウド環境ならば簡単に導入できますしね。</p>
<h2>使い方の基本</h2>
<p>RedisSettingsまたはRedisGroupを保持して、各データ構造用のクラスをキー付きで作って、メソッド（全部async）を呼ぶ、です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 設定はスタティックに保持しといてください
public static class RedisServer
{
    public static readonly RedisSettings Default = new RedisSettings(&quot;127.0.0.1&quot;);
}

// こんなクラスがあるとして
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

// RedisStringという型を作って... (RedisSettings.Default.String&lt;Person&gt;(&quot;key&quot;)でも作れます)
var redis = new RedisString&lt;Person&gt;(RedisServer.Default, &quot;test-string-key&quot;);

// コマンドをがしがし呼ぶ、何があるかはIntelliSenseで分かる
await redis.Set(new Person { Name = &quot;John&quot;, Age = 34 });

// 取得もそのまま呼ぶ 
var copy = await redis.Get();

// Listも同じ感じ
var list = new RedisList&lt;Person&gt;(RedisServer.Default, &quot;test-list-key&quot;);
await list.LeftPush(new[] { new Person { Name = &quot;Tom&quot; }, new Person { Name = &quot;Mary&quot; } });

var persons = await list.Range(0, 10);
</code></pre>
<p>難しいところはなく、割と直感的。StackExchange.Redisのままだと、特にListが辛かったりするんで、相当楽になれるかな。</p>
<p>メソッド名は基本的にStackExchange.Redisのメソッド名からデータ構造名のプリフィックスとAsyncサフィックスを抜いたものになってます。例えばSetAddAsync()はRedisSet.Add()になります。SetAddなんて最悪ですからね、そのまんま扱いたくない名前。Asyncをつけるかどうかはちょっと悩ましかったんですが、まぁ全部Asyncだしいっか、と思ったんで抜いちゃいました。</p>
<p>他の特徴としては全てのセット系のメソッドにRedisExpiryという引数を足してます。これは、SetのついでにExpireを足すって奴ですね。標準だとStringSetぐらいにしかないんですが、元々Redisは個別にExpireを呼べば自由につけれるので、自動でセットでつけてくれるような仕組みにしました。なんだかんだでExpireはつける必要があったりして、今までは毎回Task.WhenAllでまとめててたりしてたんですがすっごく面倒だったので、これで相当楽になれる、かな？</p>
<p>RedisExpiryはTimeSpanかDateTimeから暗黙的変換で生成されるので、明示的に作る必要はありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var list = new RedisList&lt;int&gt;(settings);
await list.LeftPush(1, expiry: TimeSpan.FromSeconds(30));
await list.LeftPush(10, expiry: DateTime.Now.AddDays(1));
</code></pre>
<p>こんな感じ。これは、StackExchange.RedisがRedisKey(stringかbyte[]から暗黙的に変換可能)やRedisValue(基本型に暗黙的/明示的に変換可能)な仕組みなので、それに似せてみました。違和感なく繋がるのではないかな。</p>
<h2>コンフィグ</h2>
<p>Web.configかapp.cofingから設定情報を引っ張ってこれます。トランスフォームとかもあるので、なんのかんのでWeb.configは重宝しますからねー、あると嬉しいんじゃないでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;configSections&gt;
    &lt;section name=&quot;cloudStructures&quot; type=&quot;CloudStructures.CloudStructuresConfigurationSection, CloudStructures&quot; /&gt;
&lt;/configSections&gt;

&lt;cloudStructures&gt;
    &lt;redis&gt;
        &lt;group name=&quot;Cache&quot;&gt;
            &lt;!-- Simple Grouping(key sharding) --&gt;
            &lt;add connectionString=&quot;127.0.0.1,allowAdmin=true&quot; db=&quot;0&quot; /&gt;
            &lt;add connectionString=&quot;127.0.0.1,allowAdmin=true&quot; db=&quot;1&quot; /&gt;
        &lt;/group&gt;
        &lt;group name=&quot;Session&quot;&gt;
            &lt;!-- Full option --&gt;
            &lt;add connectionString=&quot;127.0.0.1,allowAdmin=true&quot; db=&quot;2&quot; valueConverter=&quot;CloudStructures.GZipJsonRedisValueConverter, CloudStructures&quot;  commandTracer=&quot;Glimpse.CloudStructures.Redis.GlimpseRedisCommandTracer, Glimpse.CloudStructures.Redis&quot; /&gt;
        &lt;/group&gt;
    &lt;/redis&gt;
&lt;/cloudStructures&gt;
</code></pre>
<p>こんな感じに定義して、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class RedisGroups
{
    // load from web.config
    static Dictionary&lt;string, RedisGroup&gt; configDict = CloudStructures.CloudStructuresConfigurationSection
        .GetSection()
        .ToRedisGroups()
        .ToDictionary(x =&gt; x.GroupName);

    // setup group
    public static readonly RedisGroup Cache = configDict[&quot;Cache&quot;];
    public static readonly RedisGroup Session = configDict[&quot;Session&quot;];

    static RedisGroups()
    {
        // 後述しますがGlimpseのRedisInfoを有効にする場合はここで登録する
        Glimpse.CloudStructures.Redis.RedisInfoTab.RegisiterConnection(new[] { Cache, Session });
    }
}
</code></pre>
<p>こんな風にstatic変数に詰めてやると楽に扱えます。</p>
<h2>シリアライズ</h2>
<p>CloudStructuresは基本型（int, double, string, etc）はそのまま格納し、オブジェクトはシリアライザを通します。シリアライザとして標準ではJSONシリアライザの<a href="https://github.com/kevin-montrose/Jil">Jil</a>を使っています。理由は、速いから。JilはJSON.NETと違って、JsonReader/Writerも提供しないし、複雑なカスタムオプションもフォールバックもありません（多少の（特にDateTime周りの）オプションはありますが）。単純にJSONをシリアライズ/デシリアライズする、もしくはdynamicで受け取る。それだけです。まぁ、CloudStructuresの用途には全然合ってる。</p>
<p>以前は<a href="https://code.google.com/p/protobuf-net/">protobuf-net</a>を使っていたんですが、今後はやめようと思ってます。理由は、DataMemberをつけて回るのが面倒だから、ではなくて、空配列/空文字列/nullのハンドリングが凄く大変だったり（ネストしたオブジェクトの空配列がデシリアライズしたらnullになってた、とかね……これは正直ヤバすぎた）、バージョニング（特にEnumの！）が辛かったり、型がないとデシリアライズできないのでちょっとしたDumpすらできなかったりと、実運用上クリティカルすぎる案件が多くてそろそろもう無理。</p>
<p>かわりに、ではないですが圧縮することを提案します。CloudStructuresは標準でGZipJsonRedisValueConverterというものも用意していまして、それに差し替えることでJSONをGZipで圧縮して格納/展開します。圧縮は、特にデカい配列を突っ込んだりするときに物凄く効きます。めちゃくちゃ容量縮みます。protobufにせよmsgpackにせよ、シリアライザは圧縮、ではないんで、バイナリフォーマットとして小さくはなっても、配列にたいしてめちゃくちゃ縮むとかそういうことは起こり得ません（勿論、別にmsgpack+GZipとか併用するのは構わないけれど）。</p>
<p>圧縮の欠点は圧縮なんで、圧縮/解凍にそれなりにパフォーマンスを取られること。と、いうわけでCloudStructuresでは<a href="https://code.google.com/p/lz4/">LZ4</a>で圧縮するものも用意しました。LZ4はfastest compression algorithmということで、GZipと比べて数倍、圧縮/解凍が速い、です（ただしサイズ自体はGZipよりは縮まない)。この手の用途ではかなり適しているかなー、と。LZ4のライブラリは<a href="http://lz4net.codeplex.com/">LZ4 for .NET</a>を用いてます。</p>
<ul>
<li>NuGet - <a href="https://nuget.org/packages/CloudStructures.LZ4/">CloudStructures.LZ4</a></li>
</ul>
<p>インストールはNuGetから入れてもらった後に、LZ4JsonRedisValueConverterに差し替えるだけ。</p>
<p>ふつーはそのまま生JSON、気にしたいけど色々入れたくない人はGZip、エクストリームに頑張ってみたい人はLZ4を選べばいいと思います。更にもっとやりたい人はObjectRedisValueConverterBaseを継承して、自作のRedisValueConverterを作ってみてくださいな。</p>
<h2>Glimpseプラグイン</h2>
<p>もはやASP.NET開発で<a href="http://getglimpse.com/">Glimpse</a>は絶対に欠かせません。使わないのはありえないレベル。あ、<a href="http://miniprofiler.com/">MiniProfiler</a>はもういらないので投げ捨てましょう。というわけでCloudStructuresはGlimpse用のプラグインをしっかり用意してあります。相当気合入れて作りこんであるので、これのためにもRedis使うならCloudStructuresで触るべき、と言えます。マジで。</p>
<ul>
<li>NuGet - <a href="https://nuget.org/packages/Glimpse.CloudStructures.Redis/">Glimpse.CloudStructures.Redis</a></li>
</ul>
<p>インストールはNuGetから本体とは別に。それとGlimpseを使う場合は、commandTracerにGlimpseRedisCommandTracerを渡しておいてあげてください。またRedisInfoで情報を出す場合、接続文字列でallowAdminをtrueにしておく必要があります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;add connectionString=&quot;127.0.0.1,allowAdmin=true&quot; db=&quot;0&quot; commandTracer=&quot;Glimpse.CloudStructures.Redis.GlimpseRedisCommandTracer, Glimpse.CloudStructures.Redis&quot; /&gt;
</code></pre>
<p>まず、Timeline。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/RedisTimeline.png" width="640" />
</p>
<p>コマンドの並列実行具合がしっかりタイムラインで確認できます。</p>
<p>Redisタブ。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/RedisTab.png" width="640" />
</p>
<p>コマンド名、キー名、送受信オブジェクトのダンプとサイズ、Expire時間と処理にかかった時間、そしてキーとコマンドで重複して発行してたら警告。これを見れば一回のページリクエストの中でどうRedisを使ったかが完全に分かるようになってます。不足してる情報は一切なし、とにかく全部出せる仕組みにしました。</p>
<p>最後にRedisInfoタブ。RedisInfoタブを使うには、最初に言ったallowAdmin=trueにすることと、もう一つ、最初に情報表示に使うRedisGroupを登録しておく必要があります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Glimpse.CloudStructures.Redis.RedisInfoTab.RegisiterConnection(new[] { Cache, Session });
</code></pre>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/RedisInfoTab.png" width="640" />
</p>
<p>ServerInfoからCmdStat、コンフィグ、クライアント側のコンフィグやコネクションの状態を全部表示します。全部。全部。出せそうな情報は全部収集してきてます。こういうの何気に結構地味に相当大事だったりしますのよ、特にRedisサーバーの情報やコンフィグなんて普段は見ないですからね、こうして超絶カジュアルに見れるっての、かなりありがたい。</p>
<h2>まとめ</h2>
<p>そんなわけで凄く良くなったんで、かなりお薦めデス。ネーミングが直球なものしか付けないことの多い私にしては、CloudStructuresってライブラリ名はかなりカッコイイという点でもお薦めですね！</p>
<p>問題は旧CloudStructuresとの互換性が、かなり無いので既に使ってる場合は移行が大変ってことデスネ。うちはどうしたんだって？移行してないよ！どーしようかなぁ、うーん、そこはちょっとかなり悩ましい……。</p>
<p>まぁCloudStructuresを使うかどうかはともかくとして、RedisはC#界隈でももっとばんばん使われて欲すぃですねー、そして使うならStringGet/Setだけじゃもったいない。</p>
</div>
<h1 data-pagefind-sort="date:2015-01-14" data-pagefind-meta="published:2015-01-14"><a href="https://neue.cc/2015/01/14_503.html">Open on GitHub - Visual StudioからGitHubのページを開くVS拡張</a></h1>
<ul class="date"><li>2015-01-14</li></ul>
<div class="entry_body"><p>を、作りました。</p>
<img src='http://neue.cc/wp-content/uploads/2015/01/wp_openongithub.jpg' alt='' />
<p>機能は見たまんま？です。ソースコード上で右クリックすると「Open on GitHub」メニューが出るので、そこからmasterかbranchかrevisionを選ぶと、該当のGitHubのブロブページが開きます。便利。</p>
<ul>
<li><a href="https://visualstudiogallery.msdn.microsoft.com/79bf2ea3-9e78-4212-b22f-cdcdd75e791d">Visual Studio Gallery - Open on GitHub</a></li>
<li><a href="https://github.com/neuecc/Open-on-GitHub">GitHub - Open-on-GitHub</a></li>
</ul>
<p>インストールはVisual Studio Galleryからどうぞ。例によってソースコードはGitHubで公開しています。</p>
<h2>How to make VSIX</h2>
<p>VS拡張はドキュメントがあるんだかないんだか、一応あるんですけど、どうも取っ付きが悪いのが難点。今回は<a href="http://msdn.microsoft.com/en-us/library/vstudio/bb165739.aspx">Walkthrough: Adding a Submenu to a Menu</a>をベースに弄ってます。といってもやることは簡単なので、そんな大したことはないですが。</p>
<p>まず、メニュー系は全部vsctというクソ書きづらいXMLを弄って作っていきます。テンプレートは「Visual Studio Package」でウィザードで「Menu Command」を選んどくといいでしょふ、というかそれ以外だと詰む。で、vsctのうち</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Group guid=&quot;guidOpenOnGitHubCmdSet&quot; id=&quot;ContextMenuGroup&quot; priority=&quot;0x0600&quot;&gt;
    &lt;Parent guid=&quot;guidSHLMainMenu&quot; id=&quot;IDM_VS_CTXT_CODEWIN&quot; /&gt;
&lt;/Group&gt;
</code></pre>
<p>Parentを「guidSHLMainMenu, IDM_VS_CTXT_CODEWIN」にするとエディタのコンテキストメニューに出てきます。あとはまぁ、適当にどうぞ。<a href="https://github.com/neuecc/Open-on-GitHub/blob/master/OpenOnGitHub/OpenOnGitHub.vsct">OpenOnGitHub.vsct</a>と<a href="https://github.com/neuecc/Open-on-GitHub/blob/master/OpenOnGitHub/OpenOnGitHubPackage.cs">OpenOnGitHubPackage.cs</a>が全て。分かれば難しくない、分かるまでがダルい。</p>
<p>と、ここまでが普通の感じなんですが<a href="http://msdn.microsoft.com/en-us/library/bb164699.aspx">VSCT(Visual Studio Command Table)</a>は闇が深くて、IDM_VS_CTXT_CODEWINだとcshtmlとかjsonとかcssでは出てきません！これは別のParentを設定する必要があります。しかも、そのGUIDとかはノーヒント……。既存の拡張を観て研究してもいいんですが、本質的には<a href="http://blogs.msdn.com/b/dr._ex/archive/2007/04/17/using-enablevsiplogging-to-identify-menus-and-commands-with-vs-2005-sp1.aspx">Using EnableVSIPLogging to identify menus and commands with VS 2005 + SP1</a>の記事にある、レジストリ弄ってEnableVSIPLoggingをオンにして、直接対象ウィンドウのGUIDとCmdIdを取得するほうがいいかと思われます。取得したIDとかの使い方はOpenOnGitHub.vsctに載ってるので興味ある人は見てくださいな。</p>
<p>あと、Gitの解析に<a href="https://libgit2.github.com/">libgit2</a>を使っているんですが、VSIXでネイティブバイナリを同梱するためにcsprojに</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Content Include=&quot;NativeBinaries\amd64\git2-91fa31f.dll&quot;&gt;
  &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
  &lt;IncludeInVSIX&gt;true&lt;/IncludeInVSIX&gt;
&lt;/Content&gt;
</code></pre>
<p>といったようにIncludeInVSIXをつけなきゃいけないとか、VSIX自体の署名を切らないといけない（テンプレートから作ると入ってるのでカットする）とか、細かいのをこなしていけば出来上がり！</p>
<h2>最近のWindowsでGit</h2>
<p><a href="http://www.sourcetreeapp.com/">SourceTree</a>がゴミクズすぎて困る。ので、最近はVSのGit使ってたりします。割といいです。</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/2015/01/wp_vsgit.jpg' alt='' />
</p>
<p>コミットウィンドウが切り離せることに気付いてから、切り離して使ってます。そうするとまぁまぁコミットしやすい。Commit and Syncはなんのかんのいってベンリだし、SourceTreeよりもPushPullも気持ち早い。DiffとかがVS上で行えるのはサイキョーなので、あとはツリー表示さえあれば完璧だなぁ。ともあれ、VSのGit、いいです。見直しましょう。とにかくSourceTreeは使っててストレスで禿げるのでメインVS、サブSourceTreeぐらいの感じが今のとこ一番いい。</p>
<h2>まとめ</h2>
<p>ともあれOpen on GitHubはマジベンリ。うちの会社はGitHubでリポジトリ管理してるんですが、いっつも社内チャットに貼り付けるURLとか探してくるのひぢょーにダルくて、ずっと欲しかったのよね。やっと重い腰を上げて作りました。ほんとベンリ。もっと早くに作っておけば良かった。</p>
</div>
<h1 data-pagefind-sort="date:2014-12-30" data-pagefind-meta="published:2014-12-30"><a href="https://neue.cc/2014/12/30_500.html">2014年を振り返る</a></h1>
<ul class="date"><li>2014-12-30</li></ul>
<div class="entry_body"><p>振り返るシリーズ第三弾。12/30日にやってるのは誕生日なので、まぁ今年もそれで、と。今年は<a href="http://grani.jp/">グラニ</a>設立2年目になったわけですが、去年のまとめでは</p>
<blockquote>
<p>ここ数年は、毎年ジェットコースター状態で目まぐるしく変化していて。けれど、大きな目標からはブレないで、年々近づけている気がします。一番最初に若くない人サイドに入ったとか、新陳代謝とか言いましたが、来年はそういうことが起こる状態を作っていきたいですね。C#が、若い人がこぞって使うような言語になってればいい、と。そのためにできること。人がすぐに思い浮かべられる、メジャーなアプリケーションの創出と、C#による圧倒的な成果、C#だからこその強さ、というのを現実に示していくこと。雇用の創出、の連鎖。</p>
</blockquote>
<p>なるほど。達成度でいうと、今年は残念ながら弱いかなぁ、うむむむ。そこに向けて突き進んでいるというのは変わらないのですが、来年に向けての準備といった感になってしまったかも。あとは、どちらかというと一年目の総まとめみたいな感じ。一番大きなセッションは<a href="http://www.awssummittokyo.com/">AWS Summit Tokyo 2014</a>での発表、<a href="http://www.slideshare.net/neuecc/aws-windowscnet">AWS + Windows(C#)で構築する.NET最先端技術によるハイパフォーマンスウェブアプリケーション開発実践</a>かな？一端の成果を示したうえで、次のステップへ、といったような。</p>
<h2>C#</h2>
<p>今年は大分記事数少なめになってしまってます！過去最小かも。かわりにライブラリは過去最多で作ったかもしれません。</p>
<p>去年に引き続き、前半は<a href="https://github.com/neuecc/LightNode">LightNode</a>の作成続き。OWIN上に作られたMicro RPC/REST  フレームワーク。コンセプトはいいと思うし実装もかなりいいと思うし、既にプロダクションに突っ込んで稼働してるんで、ちゃんと使えるし作って良かったとは思ってます。ASP.NET MVC 6で<a href="http://blog.shibayan.jp/entry/20141123/1416746894">Action FilterがOWIN風デリゲートチェーンになってる</a>のなんかはLightNodeでは最初からそうしてるし、絶対そのほうがいいでしょﾄﾞﾔｧ、言ったとおりでしょ！といった先見の明もある！が、しかし、コミット止まって完全に息切れしてますね（笑）</p>
<p>というのも、うーん、まぁ去年後半から今年前半にかけてはOWINへの傾倒もあったのですけれど、ASP.NET vNextがね……。アレによって完全にOWIN無価値になりましたから。思想的/コードのふいんき的な面では親しいところがあるので、今やるならOWINベースで書くのは良いと思ってます。そうすればvNextへの「移植」が容易になりますから。でも、移植なんですよね、そのまま持ってく（一応互換レイヤーで持ってけますが）わけではないところからして、萎える……かなりOne ASP.NET(笑)感があって、割と嫌な気分ですねー。誰かマジに<a href="http://r.jazug.jp/event/goazure/">来日するScott Hanselman</a>に突っ込んでくださいよ（私は行きません）。とはいえ良くなってる面も理解できるんで、来年は気持ちを切り替えてvNextやりますよ、はい。ちなみにLightNode自体は、vNextベースで、ちょっと違う形で生まれ変わるはずです、という計画があります、やるやる詐欺。</p>
<p><a href="http://neue.cc/2014/03/11_447.html">RespClient</a>というPowerShell向けのRedisクライアント/コマンドレットも今年作りました。これはまぁ、たまに私自身も便利にツカッテマス。メンテは<a href="http://tech.guitarrapc.com/">guitarrapc先生</a>に譲りました。Redisは相変わらずモリモリ使ってまして、素晴らしいKVSだと思います。来年はやはりこれも放置気味な<a href="https://github.com/neuecc/CloudStructures">CloudStructures</a>をStackExchange.Redisに対応させないと、という……。</p>
<p>そして今年最大の気合の入れ方でリリースしたのが<a href="https://github.com/neuecc/UniRx">UniRx - ReactiveExtensions for Unity</a>。絶対に必要になる、と、こそこそ作ってたんですが、実際良いもの、欠かせないものになったと思ってます。そして、成功した！と言ってもいいかなー。uFrameに同梱されるようになったとか、海外でも反響あったうえに、国内でもじわじわ話題になりだしていて、かなりいい感じです。来年もがんがん更新していきたい（ちなみに現在AssetStoreでアップデート申請中！）。また、UnityコミュニティとC#コミュニティには若干の断絶がありますが、そこも埋められたらな、といったところですね。</p>
<p>ちなみにUnity関連では、他に<a href="http://neue.cc/2014/11/11_482.html">LINQ to GameObject</a>という小品もリリースしたりしたり。</p>
<p><a href="http://neue.cc/2014/09/24_479.html">LINQ to BigQuery</a>というGoogle BigQuery用のライブラリも結構な大物でした、と作るの大変だった（というか面倒だった）度合い的に。BigQueryは、正直、凄い。.NETの人もAzureの人も、とりあえず使うべき。うちの会社も基本AWSですが、BigQueryだけはBigQuery。BigQueryに突っ込むためのロギング周りについても一家言できたのですが、その辺は<a href="https://github.com/neuecc/EtwStream/">EtwStream</a>という作りかけの謎プロジェクトがあるので、それが完成した時にでも、お話しましょう（実際作りきりたいとはオモッテマス）</p>
<p>今年はUniRx(Rx), LINQ to BigQuery(Queryable), LINQ to GameObject(LINQ to XML)を通して、改めてLINQとは何ぞやか、というのを掲示できたのも良かったかと思います。口で説明するよりモノで黙らせたほうが早いというアレソレ。</p>
<h2>会社</h2>
<p>いいところは、今年も非常に強力なメンバーが多くJOINしてくれた！人は会社の原動力ですからね、うちを選んでくれたことに大変感謝です。「C#」では本当に、類を見ないほど力のある会社となっているのではないかな、と。より能力を発揮してもらうような環境を作りたいですね。</p>
<p>さて、今年はやけにCTOの役割とは！みたいなテーマが盛り上がったところですが、私の場合どうかしらん。広告塔代わりであったり求人面であったりなんかは、十二分すぎるほど果たせたとは思います。技術選定なんかも適度に先駆的に、的確だった。少なくとも失敗はない。合間合間にガッと作ってるライブラリ郡も（会社でコソッと作る時間も少し持ってますが、基本的には家で仕上げてますよ）、戦略的に根幹をなすようにしたりで、よくやれたんじゃないかなー。</p>
<p>とはいえ反省点は多かったり。割と勢いだけで突っ走れた1年目と違って2年目は中々むつかしく。特に時間が細切れになるのは避けられなくて、どうも集中しきれず成果としてはかなりイマイチ。この辺は受け入れつつ細切れでも効率的に作業できるよう自分を律するしかないですかね、といった感。そんなわけで自社のプログラムにがっつり関われたかというとかなりそうでもないのが、もにょもにょ。かなり良くない。総論するとどーも歯切れ悪い感じ。来年はドヤッ！といえるようにならないとかな。</p>
<h2>ゲーム</h2>
<p>PS4やXbox Oneも買ったのですが、うーん。結局やっぱりあんまプレイしてないのよねー。ただまぁPS4&gt;超えられない壁&gt;Xbox Oneというのは痛感しました、これはキビシイ……。Kinect2も割とガッカリ系。そんなわけで<a href="http://thelettervsixtim.es/">vvvvvv</a>のiOS移植が一番楽しんだのかも。</p>
<h2>音楽</h2>
<p>今年中頃からはずっと<a href="http://oomoriseiko.info/">大森靖子</a>聞いてましたね、ライブにも行ったし……。YouTube動画だと弾き語りの<a href="https://www.youtube.com/watch?v=Ww1H_BIOgGQ">大森靖子 LIVE @ TIF2013</a>とバンド編成の<a href="https://www.youtube.com/watch?v=a6DdaXvtW_0">大森靖子＆THEピンクトカレフ＠ZeppDiverCity</a>あたりがお薦め。エキセントリックな情報とかインターネット時代の戦略とか、うーん、まぁ、パンクですよ、パンク（適当）。</p>
<h2>来年</h2>
<p>テーマは「クライアントサイドとサーバーサイドをC#で統一することのメリットの実証」「さらにリアルタイムネットワークもC#で統一」「のためのヒットアプリケーションの創出」です。指向はあんま変わってないんですが、より具体的に。来年は動く年かな、といったところなので是非期待してください。</p>
</div>
<h1 data-pagefind-sort="date:2014-12-18" data-pagefind-meta="published:2014-12-18"><a href="https://neue.cc/2014/12/18_499.html">Unityのコルーチンの分解、或いはUniRxのMainThreadDispatcherについて</a></h1>
<ul class="date"><li>2014-12-18</li></ul>
<div class="entry_body"><p>この記事は<a href="http://qiita.com/advent-calendar/2014/unity">Unity Advent Calendar 2014</a>のための記事になります。昨日はkomiyakさんの<a href="http://d.hatena.ne.jp/komiyak/20141216/1418760578">Unity を使いはじめたばかりの頃の自分に伝えたい、Unity の基本 【2014年版】</a>でした。いやー、これはまとまってて嬉しい情報です。ところでカレンダー的には穴開けちゃってます（遅刻遅延！）、すみません……。</p>
<p>さて、今回の内容ですが、私の作っている<a href="https://github.com/neuecc/UniRx">UniRx</a>というReactive Programming（バズワード of 2014！)のためのライブラリを、最近ありがたいことに結構使ってみたーという声を聞くので、Rxの世界とUnityの世界を繋ぐ根幹である、MainThreadDispatcherと、その前準備に必要なコルーチンについて書きます。</p>
<h2>Coroutine Revisited</h2>
<p>コルーチンとはなんぞや。なんて今更ですって！はい。とりあえず、Unityは基本的にシングルスレッドで動いています。少なくともスクリプト部分に関しては。Unityのコルーチンは、IEnumeratorでyield returnすると、その次の処理を次フレーム（もしくは一定秒数/完了後などなど）に回します。あくまでシングルスレッド、ということですね。挙動について。簡単な確認用スクリプトを貼っつけて見てみると……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">void Start()
{
    Debug.Log(&quot;begin-start:&quot; + Time.frameCount);
    StartCoroutine(MyCoroutine());
    Debug.Log(&quot;end-start&quot; + Time.frameCount);
}

IEnumerator MyCoroutine()
{
    Debug.Log(&quot;start-coroutine:&quot; + Time.frameCount);

    yield return null;
    Debug.Log(&quot;after-yield-null:&quot; + Time.frameCount);

    yield return new WaitForSeconds(3);
    Debug.Log(&quot;end-coroutine:&quot; + Time.frameCount);
}
</code></pre>
<p>呼ばれる順番とframeCountを考えてみようクイズ！意外と引っかかるかもしれません。答えのほうですが……</p>
<pre data-pagefind-ignore="all"><code class="language-text">begin-start:1
start-coroutine:1
end-start:1
after-yield-null:2
end-coroutine:168
</code></pre>
<p>となります。最後の秒数のフレームカウントはどうでもいいとして、start-coroutineが呼ばれるのはend-startの前ってのがちょっとだけヘーってとこかしら。IEnumerator自体はUnity固有の機能でもなく、むしろC#の標準機能で、通常は戻り値を持ってイテレータを生成するのに使います（Pythonでいうところのジェネレータ）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 偶数のシーケンスを生成
IEnumerable&lt;int&gt; EvenSequence(int from, int to)
{
    for (int i = from; i &lt;= to; i++)
    {
        if (i % 2 == 0)
        {
            yield return i;
        }
    }
}

void Run()
{
    var seq = EvenSequence(1, 10);

    // シーケンスはforeachで消費可能
    foreach (var item in seq)
    {
        Debug.Log(item);
    }

    // あるいはEnumeratorを取得し回す(foreachは↓のコードを生成する)
    // Unityでのコルーチンでの利用され方はこっちのイメージのほうが近い
    using (var e = seq.GetEnumerator())
    {
        while (e.MoveNext())
        {
            Debug.Log(e.Current);
        }
    }
}
</code></pre>
<p>Unityのコルーチンとしてのイテレータの活用法は、戻り値を原則使わず(宣言がIEnumerator)、yield returnとyield returnの間に副作用を起こすために使うということですね。これはこれで中々ナイスアイディアだとは思ってます。</p>
<p>言語システムとしてはC#そのままなので、誰かがIEnumeratorを消費しているということになります。もちろん、それは<a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html">StartCoroutine</a>で、呼んだ瞬間にまずはMoveNext、その後はUpdateに相当するようなタイミングで毎フレームMoveNextを呼び続けているようなイメージ。</p>
<p>擬似的にMonoBehaviourで再現すると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class CoroutineConsumer : MonoBehaviour
{
    public IEnumerator TargetCoroutine; // 何か外からセットしといて

    void Update()
    {
        if (TargetCoroutine.MoveNext())
        {
            var current = TargetCoroutine.Current;
            // 基本的にCurrent自体はそんな意味を持たないで次フレームに回すだけ
            if (current == null)
            {
                // next frame
            }
            // ただしもし固有の何かが返された時はちょっとした別の挙動する
            if (current is WaitForSeconds)
            {
                // なんか適当に秒数待つ（ThreadをSleepするんじゃなく挙動的には次フレームへ）
            }
            else if (current is WWW)
            {
                // isDoneになってるまで適当に待つ（ThreadをSleepするんじゃなく挙動的には次フレームへ）
            }
            // 以下略
        }
    }
}
</code></pre>
<p>こんな感じでしょうか！yield returnで返す値が具体的にUnityのゲームループにおいてどこに差し込まれるかは、Unityのマニュアルの<a href="http://docs.unity3d.com/Manual/ExecutionOrder.html">Script Lifecycle Flowchart</a>の図を見るのが分かりやすい。</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/2014/12/unitylifecycle.jpg' alt='' />
</p>
<p>nullが先頭でWaitForEndOfFrameは末尾なのね、とか。yield returnで返して意味を持つ値は<a href="http://docs.unity3d.com/ScriptReference/YieldInstruction.html">YieldInstruction</a>、ということになっているはずではあるんですが、実際のとこWWWはYieldInstructionじゃないし、YieldInstruction自体はカスタマイズ不能で自分で書けるわけじゃないんで（イマイチすぎる……）なんだかなぁー。Lifecycle Flowchartに書かれていない中でyield可能なのは<a href="http://docs.unity3d.com/ScriptReference/AsyncOperation.html">AsyncOperation</a>かな？</p>
<p>もしイテレータの挙動について更に詳しく知りたい人は、私の以前書いたスライド<a href="http://www.slideshare.net/neuecc/an-internal-of-linq-to-objects-29200657">An Internal of LINQ to Objects</a>の14Pを参照してくださいな。</p>
<h2>UniRx.FromCoroutine</h2>
<p>というわけかで（一旦）コルーチンの話はおしまい。ここからはUniRxの話。UniRxについては<a href="http://neue.cc/2014/08/23_476.html">neue cc - A Beginners Guide to Reactive Extensions with UniRx</a>あたりをどうぞ。UniRxはFromCoroutineメソッドにより、コルーチンをUniRxの基盤インターフェースであるIObservable&lt;T&gt;に変換します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなのがあるとして
IEnumerator CoroutineA()
{
    Debug.Log(&quot;a start&quot;);
    yield return new WaitForSeconds(1);
    Debug.Log(&quot;a end&quot;);
}

// こんなふうに使える
Observable.FromCoroutine(CoroutineA)
    .Subscribe(_ =&gt; Debug.Log(&quot;complete&quot;));
    
// 戻り値のあるバージョンがあるとして
IEnumerator CoroutineB(IObserver&lt;int&gt; observer)
{
    observer.OnNext(100);
    yield return new WaitForSeconds(2);
    observer.OnNext(200);
    observer.OnCompleted();
}

// こんなふうに合成もできる
var coroutineA = Observable.FromCoroutine(CoroutineA);
var coroutineB = Observable.FromCoroutine&lt;int&gt;(observer =&gt; CoroutineB(observer));

// Aが終わった後にBの起動、Subscribeには100, 200が送られてくる
var subscription = coroutineA.SelectMany(coroutineB).Subscribe(x =&gt; Debug.Log(x));

// Subscribeの戻り値からDisposeを呼ぶとキャンセル可能
// subscription.Dispose();
</code></pre>
<p>IObservable&lt;T&gt;になっていると何がいいかというと、合成可能になるところです。Aが終わった後にBを実行する、Bが失敗したらCを実行する、などなど。また、戻り値を返すことができるようになります。そして、コルーチンに限らず、あらゆるイベント、あらゆる非同期がIObservable&lt;T&gt;になるので、全てをシームレスに繋ぎ合わせることができる。そこが他のライブラリや手法と一線を画すRxの強みなんです、が、長くなるのでここでは触れません:)</p>
<p>また、MonoBehaviour.StartCoroutineを呼ばなくてもコルーチンが起動しています。これは結構大きな利点だと思っていて、というのも、コルーチンを使うためだけにMonoBehaviourにする必要がなくなる。やはり普通のC#クラスのほうが取り回しが良いので、MonoBehaviourにする必要がないものはしないほうがいい。けれど、コルーチンは使いたい。そうした欲求に応えてくれます。</p>
<p>更にFromCoroutine経由にするとEditor内部では通常は動かせないコルーチンを動かすことができます！（これについては後で説明します）</p>
<p>といった応用例はそのうちやるということで、とりあえずFromCoroutineの中身を見て行きましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Func&lt;IEnumerator&gt;はメソッド宣言的には「IEnumerator Hoge()」になる
public static IObservable&lt;Unit&gt; FromCoroutine(Func&lt;IEnumerator&gt; coroutine, bool publishEveryYield = false)
{
    return FromCoroutine&lt;Unit&gt;((observer, cancellationToken) =&gt; WrapEnumerator(coroutine(), observer, cancellationToken, publishEveryYield));
}

// ↑のはWrapEnumeratorを介してこれになっている
public static IObservable&lt;T&gt; FromCoroutine&lt;T&gt;(Func&lt;IObserver&lt;T&gt;, CancellationToken, IEnumerator&gt; coroutine)
{
    return Observable.Create&lt;T&gt;(observer =&gt;
    {
        var cancel = new BooleanDisposable();

        MainThreadDispatcher.SendStartCoroutine(coroutine(observer, new CancellationToken(cancel)));

        return cancel;
    });
}

// WrapEnumeratorの中身は(ｵｪｪｪｪ
static IEnumerator WrapEnumerator(IEnumerator enumerator, IObserver&lt;Unit&gt; observer, CancellationToken cancellationToken, bool publishEveryYield)
{
    var hasNext = default(bool);
    var raisedError = false;
    do
    {
        try
        {
            hasNext = enumerator.MoveNext();
        }
        catch (Exception ex)
        {
            try
            {
                raisedError = true;
                observer.OnError(ex);
            }
            finally
            {
                var d = enumerator as IDisposable;
                if (d != null)
                {
                    d.Dispose();
                }
            }
            yield break;
        }
        if (hasNext &amp;&amp; publishEveryYield)
        {
            try
            {
                observer.OnNext(Unit.Default);
            }
            catch
            {
                var d = enumerator as IDisposable;
                if (d != null)
                {
                    d.Dispose();
                }
                throw;
            }
        }
        if (hasNext)
        {
            yield return enumerator.Current; // yield inner YieldInstruction
        }
    } while (hasNext &amp;&amp; !cancellationToken.IsCancellationRequested);

    try
    {
        if (!raisedError &amp;&amp; !cancellationToken.IsCancellationRequested)
        {
            observer.OnNext(Unit.Default); // last one
            observer.OnCompleted();
        }
    }
    finally
    {
        var d = enumerator as IDisposable;
        if (d != null)
        {
            d.Dispose();
        }
    }
}
</code></pre>
<p>WrapEnumeratorの中身が長くてオェェェって感じなんですが何やってるかというと、元のコルーチンを分解して、Rx的に都合のいい形に再構築したコルーチンに変換してます。都合のいい形とは「キャンセル可能」「終了時（もしくは各yield時）にObserver.OnNextを呼ぶ」「全ての完了時にObserver.OnCompletedを呼ぶ」「エラー発生時にObserver.OnErrorを呼ぶ」を満たしているもの。コルーチン自体がC#の標準機能のままで、なにも特別なことをしていないなら、別に自分で回す(enumerator.MoveNextを手で呼ぶ)ことも、何も問題はない、わけです。</p>
<p>そんなラップしたコルーチンを動かしているのがMainThreadDispatcher.SendStartCoroutine。今の<a href="https://github.com/neuecc/UniRx/blob/master/Assets/UniRx/Scripts/UnityEngineBridge/MainThreadDispatcher.cs">MainThreadDispatcher.cs</a>は諸事情あって奇々怪々なんですが、SendStartCoroutineのとこだけ取り出すと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public sealed class MainThreadDispatcher : MonoBehaviour
{
    // 中略
    
    /// &lt;summary&gt;ThreadSafe StartCoroutine.&lt;/summary&gt;
    public static void SendStartCoroutine(IEnumerator routine)
    {
#if UNITY_EDITOR
        if (!Application.isPlaying) { EditorThreadDispatcher.Instance.PseudoStartCoroutine(routine); return; }
#endif

        if (mainThreadToken != null)
        {
            StartCoroutine(routine);
        }
        else
        {
            Instance.queueWorker.Enqueue(() =&gt; Instance.StartCoroutine_Auto(routine));
        }
    }

    new public static Coroutine StartCoroutine(IEnumerator routine)
    {
#if UNITY_EDITOR
        if (!Application.isPlaying) { EditorThreadDispatcher.Instance.PseudoStartCoroutine(routine); return null; }
#endif

        return Instance.StartCoroutine_Auto(routine);
    }
}
</code></pre>
<p>if UNITY_EDITORのところは後で説明するのでスルーしてもらうとして、基本的にはInstance.StartCoroutine_Autoです。ようはMainThreadDispatcherとは、シングルトンのMonoBehaviourであり、FromCoroutineはそいつからコルーチンを起動しているだけなのであった。なんだー、単純。汚れ仕事（コルーチンの起動、MonoBehaviourであること）をMainThreadDispatcherにだけ押し付けることにより、それ以外の部分が平和に浄化される！</p>
<p>コルーチンの起動が一極集中して、それで実行効率とか大丈夫なの？というと存外大丈夫っぽいので大丈夫。実際、私の会社ではこないだ一本iOS向けにゲームをリリースしましたがちゃんと動いてます。しかしそうなるとStartCoroutineはMonoBehaviourのインスタンスメソッドではなく、静的メソッドであって欲しかった……。</p>
<p>その他、SendStartCoroutineはスレッドセーフ（他スレッドから呼ばれた場合はキューに突っ込んでメインスレッドに戻ってから起動する）なのと、UnityEditorからの起動を可能にしています（EditorThreadDispatcher.Instance.PseudoStartCoroutine経由で起動する）。なので、普通にStartCoroutineを呼ぶ以上のメリットを提供できているかな、と。</p>
<h2>UnityEditorでコルーチンを実行する</h2>
<p>Editorでコルーチンを動かせないのは存外不便です。WWWも動かせないし……。UniRxではFromCoroutine経由で実行すると、内部でMainThreadDispatcher.SendStartCoroutine経由になることにより、Editorで実行できます。使い方は本当にFromCoroutineしてSubscribeするだけ、と、通常時のフローとまるっきり一緒です。ここで毎回エディターの時は、通常の時は、と書き分けるのはカッタルイですからね。汚れ仕事はMainThreadDispatcherが一手に引き受けています。そんな汚れ仕事はこんな感じの実装です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class EditorThreadDispatcher
{
    // 中略
    
    ThreadSafeQueueWorker editorQueueWorker= new ThreadSafeQueueWorker();

    EditorThreadDispatcher()
    {
        UnityEditor.EditorApplication.update += Update;
    }
    
    // 中略
    
    void Update()
    {
        editorQueueWorker.ExecuteAll(x =&gt; Debug.LogException(x));
    }

    // 中略

    public void PseudoStartCoroutine(IEnumerator routine)
    {
        editorQueueWorker.Enqueue(() =&gt; ConsumeEnumerator(routine));
    }

    void ConsumeEnumerator(IEnumerator routine)
    {
        if (routine.MoveNext())
        {
            var current = routine.Current;
            if (current == null)
            {
                goto ENQUEUE;
            }

            var type = current.GetType();
            if (type == typeof(WWW))
            {
                var www = (WWW)current;
                editorQueueWorker.Enqueue(() =&gt; ConsumeEnumerator(UnwrapWaitWWW(www, routine)));
                return;
            }
            else if (type == typeof(WaitForSeconds))
            {
                var waitForSeconds = (WaitForSeconds)current;
                var accessor = typeof(WaitForSeconds).GetField(&quot;m_Seconds&quot;, BindingFlags.Instance | BindingFlags.GetField | BindingFlags.NonPublic);
                var second = (float)accessor.GetValue(waitForSeconds);
                editorQueueWorker.Enqueue(() =&gt; ConsumeEnumerator(UnwrapWaitForSeconds(second, routine)));
                return;
            }
            else if (type == typeof(Coroutine))
            {
                Debug.Log(&quot;Can't wait coroutine on UnityEditor&quot;);
                goto ENQUEUE;
            }

        ENQUEUE:
            editorQueueWorker.Enqueue(() =&gt; ConsumeEnumerator(routine)); // next update
        }
    }

    IEnumerator UnwrapWaitWWW(WWW www, IEnumerator continuation)
    {
        while (!www.isDone)
        {
            yield return null;
        }
        ConsumeEnumerator(continuation);
    }

    IEnumerator UnwrapWaitForSeconds(float second, IEnumerator continuation)
    {
        var startTime = DateTimeOffset.UtcNow;
        while (true)
        {
            yield return null;

            var elapsed = (DateTimeOffset.UtcNow - startTime).TotalSeconds;
            if (elapsed &gt;= second)
            {
                break;
            }
        };
        ConsumeEnumerator(continuation);
    }
}
</code></pre>
<p>ようは、UnityEditor.EditorApplication.updateでジョブキューを回しています。コルーチン(Enumerator)を手動で分解して、EditorApplication.updateに都合の良い形に再編しています。yield return nullがあったらキューに突っ込んで次のupdateに回すことで、擬似的にStartCorotineを再現。WaitForSecondsだったらリフレクションで内部の秒数を取ってきて（ひどぅい）ぐるぐるループを展開。などなど。</p>
<p>仕組み的には単純、なんですが結構効果的で便利かな、と。ユーザーは全くそれを意識する必要がないというのが一番いいトコですね。</p>
<p>ちなみにアセットストアからダウンロードできるバージョンでは、まだこの仕組みは入ってません（すびばせん！）。GitHubの最新コードか、あとは、ええと、近いうちにアップデート申請しますので来年には使えるようになっているはずです。。。</p>
<h2>まとめ</h2>
<p>コルーチンをコルーチンたらしめているのは消費者であるStartCoroutineであって、IEnumerator自体はただのイテレータにすぎない。なので、分解も可能だし、他の形式に展開することもできる。</p>
<p><a href="https://github.com/neuecc/UniRx">UniRx</a>経由でコルーチンを実行すると「色々なものと合成できる」「（複数の）戻り値を扱える」「キャンセルが容易」「MonoBehaviourが不要」「スレッドセーフ」「エディターでも実行可能」になる。いいことづくめっぽい！Reactive Programmingの力！そんな感じに、UniRxはなるべくシームレスにRxの世界とUnityの世界を繋げるような仕組みを用意しています。是非ダウンロードして、色々遊んでみてください。</p>
</div>
<a href="https://neue.cc/8">Prev |</a>
<a href="https://neue.cc/10">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
