 < !DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - TypeScript 0.9のジェネリクス対応でlinq.jsの型定義作って苦労した話</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet" />
    <meta property="og:url" content="" />
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <div id="header"></div>
        <div id="content"><h1><a href="https://neue.cc/2013/06/20_408.html">TypeScript 0.9のジェネリクス対応でlinq.jsの型定義作って苦労した話</a></h1>
<ul class="date"><li>2013-06-20</li></ul>
<div class="entry_body"><p>久しぶりの<a href="http://www.typescriptlang.org/">TypeScript</a>。<a href="http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx">Announcing TypeScript 0.9</a>というわけで、ついに待望のジェネリクスが搭載されました。やったね！というわけで、ジェネリクス対応の<a href="https://linqjs.codeplex.com/">linq.js</a>の型定義を早速作りました、と。ver 3.0.4-Beta5です。まだまだBeta、すみませんすみません、色々忙しくて……。NuGetからもしくはサイトからのダウンロードで公開してます。</p>
<p>とりあえず例として使ってみた感じ。</p>
<pre><code class="language-javascript">// booleanしか受け入れないwhereにnumberを突っ込んだらちゃんと怒ってくれるよ！
// Call signatures of types '(x: any) =&gt; number' and '(element: number, index: number) =&gt; boolean' are incompatible.
var seq = Enumerable.from([1, 10, 100, 100]).where(x =&gt; x * 2);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ts_generics_intellisense.jpg">
</p>
<p>やったー。これだよこれ！LINQはジェネリクスがあって本当の本当の真価を発揮するんです！！！</p>
<h2>面白げな型定義</h2>
<p>C#とちょっと違うところとしては、ジェネリクスの型変数のところにもオブジェクトを突っ込めるんですね。だから</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ts_generics_typearg.jpg">
</p>
<pre><code class="language-javascript">// from(obj)の型定義はこんな感じ。
from(obj: any): IEnumerable&lt;{ key: string; value: any }&gt;;

// ちなみにfromのオーバーロードはいっぱいある
// linq.js自体はJScriptのIEnumerableとWinMDのIIterable&lt;T&gt;にも対応してるのですがTSで表現できないので、そこは未定義……。。。
from(): IEnumerable&lt;any&gt;; // empty
from&lt;T&gt;(obj: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
from(obj: number): IEnumerable&lt;number&gt;;
from(obj: boolean): IEnumerable&lt;boolean&gt;;
from(obj: string): IEnumerable&lt;string&gt;;
from&lt;T&gt;(obj: T[]): IEnumerable&lt;T&gt;;
from&lt;T&gt;(obj: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
</code></pre>
<p>このkey,valueはどこから出てきたんだよって感じでわかりづらかったので、こうして見えてくれると嬉しい度高い。</p>
<h2>型消去</h2>
<p>場合によってはIEnumerable&lt;any&gt;となるため、Tの型をつけてあげたかったり、もしくは強引に変換したかったり（例えば↑のIIterable&lt;T&gt;は{key,value}に解釈されてしまうので、明示的に変換してあげる必要がある）する場合のために、castメソッドを用意しました。</p>
<pre><code class="language-javascript">// any[]型で渡ってきたりする場合に
var seq: any[] = [1, 2, 3, 4, 5];

var result = Enumerable.from(seq)
    .cast&lt;number&gt;() // numberに変換
    .select(x =&gt; x * x) // x:number
    .toArray(); // result:number[]
</code></pre>
<p>さて、ところで、TypeScriptのジェネリクスは型消去(Type Erasure)式です。コンパイル結果のJSは以下のような感じで</p>
<pre><code class="language-javascript">var result = Enumerable.from(seq)
    .cast()
    .select(function (x) { return x * x; })
    .toArray();
</code></pre>
<p>一切の型は消えています。なので、TypeScriptでTの型を取って実行時に扱ったりはできません。型が欲しければ型を渡せ方式。</p>
<p>linq.jsにはofTypeという、型でフィルタリングするメソッドがあるのですが</p>
<pre><code class="language-javascript">// 混在した配列から、型でフィルタして取り出す
var mixed: any[] = [1, &quot;hoge&quot;, 100, true, &quot;nano&quot;];

// このままじゃ型が分からないのでresultはany[]
var result1 = Enumerable.from(mixed)
    .ofType(Number) // 数値型のみでフィルタ、つまり[1, 100]
    .toArray();

// ofTypeの後にcastするか、もしくはofTypeで型指定するか
var result2 = Enumerable.from(mixed)
    .ofType&lt;number&gt;(Number)
    .toArray();
</code></pre>
<p>というように、&lt;number&gt;(Number)と連続するのが非常に不恰好……。まあ、この辺はそういうものなのでしょうがないと諦めましょう。</p>
<h2>地雷ふんだり</h2>
<p>さて、そんな素敵なTypeScript 0.9なのですが、残念なお知らせ。現在の、というか、この0.9ですが、完成度はものすごーーーーーーーーく、低いです。はい、超低いです。Visual Studioと組み合わせて使う場合、半端無く動作も補完も遅いです。正直、ベータどころかアルファぐらいのクオリティで、何故に堂々と出してきたのか理解に苦しむ。遅いだけならまだしも、ジェネリクスの解釈が非常に怪しく、地雷を踏むと補完やエラー通知が消え去ります。いや、消え去るだけならまだよくて、Visual Studioと裏で動くTypeScript Compilerが大暴走をはじめてCPUが100%に張り付いたりします。もうヤヴァい。タスクマネージャー開きっぱにして警戒しながらじゃないと書けないです。linq.jsの型定義書くの超絶苦労した……。</p>
<pre><code class="language-javascript">interface IEnumerable&lt;T&gt; {
    // 戻り値の型をIEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;にしたいのですが、
    // interface側で定義しているTをネストした型変数に使うとVSが大暴走して死ぬ
    // ので、今回のバージョンではanyにしてます
    groupBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, any&gt;&gt;;
}
</code></pre>
<p>具体的に踏んだのは↑ですねえ。最初原因が分かってなくてかなり時間食われちゃいました。んもー。最小セットで試してる限りでは、コンパイルエラーにはなるんですが(A generic type may not reference itself with a wrapped form of its own type parameters.)暴走はしない、んですがlinq.d.tsで弄ってると死ぬ。おうふ。もう定義の仕方が悪いのかコンパイラがアレなのか判断つかないのでしんどい。</p>
<p>そんなわけで、0.8の完成度からだいぶ退化して、実用性はゼロになってしまいました。私の環境だけ、じゃあないよねえ…‥？とりあえず0.9.1を待ちましょう。どうやらコンパイラをまるっと書き換えたそうですしねー、初物だからshoganaiと思うことにして。しかし泣きたい。</p>
<h2>linq.d.ts</h2>
<p>とりあえず、こんな感じになってます。</p>
<pre><code class="language-csharp">// Type Definition for linq.js, ver 3.0.4-Beta5

declare module linqjs {
    interface IEnumerator&lt;T&gt; {
        current(): T;
        moveNext(): boolean;
        dispose(): void;
    }

    interface Enumerable {
        Utils: {
            createLambda(expression: any): (...params: any[]) =&gt; any;
            createEnumerable&lt;T&gt;(getEnumerator: () =&gt; IEnumerator&lt;T&gt;): IEnumerable&lt;T&gt;;
            createEnumerator&lt;T&gt;(initialize: () =&gt; void , tryGetNext: () =&gt; boolean, dispose: () =&gt; void ): IEnumerator&lt;T&gt;;
            extendTo(type: any): void;
        };
        choice&lt;T&gt;(...params: T[]): IEnumerable&lt;T&gt;;
        cycle&lt;T&gt;(...params: T[]): IEnumerable&lt;T&gt;;
        empty&lt;T&gt;(): IEnumerable&lt;T&gt;;
        // from&lt;T&gt;, obj as JScript's IEnumerable or WinMD IIterable&lt;T&gt; is IEnumerable&lt;T&gt; but it can't define.
        from(): IEnumerable&lt;any&gt;; // empty
        from&lt;T&gt;(obj: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        from(obj: number): IEnumerable&lt;number&gt;;
        from(obj: boolean): IEnumerable&lt;boolean&gt;;
        from(obj: string): IEnumerable&lt;string&gt;;
        from&lt;T&gt;(obj: T[]): IEnumerable&lt;T&gt;;
        from&lt;T&gt;(obj: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        from(obj: any): IEnumerable&lt;{ key: string; value: any }&gt;;
        make&lt;T&gt;(element: T): IEnumerable&lt;T&gt;;
        matches&lt;T&gt;(input: string, pattern: RegExp): IEnumerable&lt;T&gt;;
        matches&lt;T&gt;(input: string, pattern: string, flags?: string): IEnumerable&lt;T&gt;;
        range(start: number, count: number, step?: number): IEnumerable&lt;number&gt;;
        rangeDown(start: number, count: number, step?: number): IEnumerable&lt;number&gt;;
        rangeTo(start: number, to: number, step?: number): IEnumerable&lt;number&gt;;
        repeat&lt;T&gt;(element: T, count?: number): IEnumerable&lt;T&gt;;
        repeatWithFinalize&lt;T&gt;(initializer: () =&gt; T, finalizer: (element) =&gt; void ): IEnumerable&lt;T&gt;;
        generate&lt;T&gt;(func: () =&gt; T, count?: number): IEnumerable&lt;T&gt;;
        toInfinity(start?: number, step?: number): IEnumerable&lt;number&gt;;
        toNegativeInfinity(start?: number, step?: number): IEnumerable&lt;number&gt;;
        unfold&lt;T&gt;(seed: T, func: (value: T) =&gt; T): IEnumerable&lt;T&gt;;
        defer&lt;T&gt;(enumerableFactory: () =&gt; IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
    }

    interface IEnumerable&lt;T&gt; {
        constructor(getEnumerator: () =&gt; IEnumerator&lt;T&gt;);
        getEnumerator(): IEnumerator&lt;T&gt;;

        // Extension Methods
        traverseBreadthFirst(func: (element: T) =&gt; IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        traverseBreadthFirst&lt;TResult&gt;(func: (element: T) =&gt; IEnumerable&lt;T&gt;, resultSelector: (element: T, nestLevel: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        traverseDepthFirst&lt;TResult&gt;(func: (element: T) =&gt; Enumerable): IEnumerable&lt;T&gt;;
        traverseDepthFirst&lt;TResult&gt;(func: (element: T) =&gt; Enumerable, resultSelector?: (element: T, nestLevel: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        flatten(): IEnumerable&lt;any&gt;;
        pairwise&lt;TResult&gt;(selector: (prev: T, current: T) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        scan(func: (prev: T, current: T) =&gt; T): IEnumerable&lt;T&gt;;
        scan&lt;TAccumulate&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate): IEnumerable&lt;TAccumulate&gt;;
        select&lt;TResult&gt;(selector: (element: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; IEnumerable&lt;TOther&gt;): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; IEnumerable&lt;TCollection&gt;, resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; TOther[]): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; TCollection[], resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; { length: number;[x: number]: TOther; }): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; { length: number;[x: number]: TCollection; }, resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        where(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        choose(selector: (element: T, index: number) =&gt; T): IEnumerable&lt;T&gt;;
        ofType&lt;TResult&gt;(type: any): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: IEnumerable&lt;T&gt;, resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: { length: number;[x: number]: T; }, resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: T[], resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(...params: any[]): IEnumerable&lt;TResult&gt;; // last one is selector
        merge&lt;TResult&gt;(...params: IEnumerable&lt;T&gt;[]): IEnumerable&lt;T&gt;;
        merge&lt;TResult&gt;(...params: { length: number;[x: number]: T; }[]): IEnumerable&lt;T&gt;;
        merge&lt;TResult&gt;(...params: T[][]): IEnumerable&lt;T&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: IEnumerable&lt;TInner&gt;, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: TInner[], outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: IEnumerable&lt;TInner&gt;, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: TInner[], outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        all(predicate: (element: T) =&gt; boolean): boolean;
        any(predicate?: (element: T) =&gt; boolean): boolean;
        isEmpty(): boolean;
        concat(...sequences: IEnumerable&lt;T&gt;[]): IEnumerable&lt;T&gt;;
        concat(...sequences: { length: number;[x: number]: T; }[]): IEnumerable&lt;T&gt;;
        concat(...sequences: T[]): IEnumerable&lt;T&gt;;
        insert(index: number, second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        insert(index: number, second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        alternate(alternateValue: T): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: T[]): IEnumerable&lt;T&gt;;
        contains(value: T): boolean;
        contains&lt;TCompare&gt;(value: T, compareSelector?: (element: T) =&gt; TCompare): boolean;
        defaultIfEmpty(defaultValue?: T): IEnumerable&lt;T&gt;;
        distinct(): IEnumerable&lt;T&gt;;
        distinct&lt;TCompare&gt;(compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        distinctUntilChanged(): IEnumerable&lt;T&gt;;
        distinctUntilChanged&lt;TCompare&gt;(compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: T[]): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: T[]): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: T[]): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        sequenceEqual(second: { length: number;[x: number]: T; }): boolean;
        sequenceEqual&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): boolean;
        sequenceEqual(second: IEnumerable&lt;T&gt;): boolean;
        sequenceEqual&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): boolean;
        sequenceEqual(second: T[]): boolean;
        sequenceEqual&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): boolean;
        orderBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        orderByDescending&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        reverse(): IEnumerable&lt;T&gt;;
        shuffle(): IEnumerable&lt;T&gt;;
        weightedSample(weightSelector: (element: T) =&gt; number): IEnumerable&lt;T&gt;;
        // truly, return type is IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt; but Visual Studio + TypeScript Compiler can't compile.
        groupBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;;
        groupBy&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
        groupBy&lt;TKey, TElement, TResult&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        groupBy&lt;TKey, TElement, TResult, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;TResult&gt;;
        // :IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;
        partitionBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, any&gt;&gt;;
        // :IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;
        partitionBy&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
        partitionBy&lt;TKey, TElement, TResult&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        partitionBy&lt;TKey, TElement, TResult, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;TResult&gt;;
        buffer(count: number): IEnumerable&lt;T&gt;;
        aggregate(func: (prev: T, current: T) =&gt; T): T;
        aggregate&lt;TAccumulate&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate): TAccumulate;
        aggregate&lt;TAccumulate, TResult&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate, resultSelector: (last: TAccumulate) =&gt; TResult): TResult;
        average(selector?: (element: T) =&gt; number): number;
        count(predicate?: (element: T, index: number) =&gt; boolean): number;
        max(selector?: (element: T) =&gt; number): number;
        min(selector?: (element: T) =&gt; number): number;
        maxBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): T;
        minBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): T;
        sum(selector?: (element: T) =&gt; number): number;
        elementAt(index: number): T;
        elementAtOrDefault(index: number, defaultValue?: T): T;
        first(predicate?: (element: T, index: number) =&gt; boolean): T;
        firstOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        last(predicate?: (element: T, index: number) =&gt; boolean): T;
        lastOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        single(predicate?: (element: T, index: number) =&gt; boolean): T;
        singleOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        skip(count: number): IEnumerable&lt;T&gt;;
        skipWhile(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        take(count: number): IEnumerable&lt;T&gt;;
        takeWhile(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        takeExceptLast(count?: number): IEnumerable&lt;T&gt;;
        takeFromLast(count: number): IEnumerable&lt;T&gt;;
        indexOf(item: T): number;
        indexOf(predicate: (element: T, index: number) =&gt; boolean): number;
        lastIndexOf(item: T): number;
        lastIndexOf(predicate: (element: T, index: number) =&gt; boolean): number;
        asEnumerable(): IEnumerable&lt;T&gt;;
        cast&lt;TResult&gt;(): IEnumerable&lt;TResult&gt;;
        toArray(): T[];
        // truly, return type is ILookup&lt;TKey, T&gt; but Visual Studio + TypeScript Compiler can't compile. 
        toLookup&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): ILookup&lt;TKey, any&gt;;
        toLookup&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): ILookup&lt;TKey, TElement&gt;;
        toLookup&lt;TKey, TElement, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, compareSelector: (key: TKey) =&gt; TCompare): ILookup&lt;TKey, TElement&gt;;
        toObject(keySelector: (element: T) =&gt; any, elementSelector?: (element: T) =&gt; any): Object;
        // :IDictionary&lt;TKey, T&gt;
        toDictionary&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IDictionary&lt;TKey, any&gt;;
        toDictionary&lt;TKey, TValue&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TValue): IDictionary&lt;TKey, TValue&gt;;
        toDictionary&lt;TKey, TValue, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TValue, compareSelector: (key: TKey) =&gt; TCompare): IDictionary&lt;TKey, TValue&gt;;
        toJSONString(replacer: (key: string, value: any) =&gt; any): string;
        toJSONString(replacer: any[]): string;
        toJSONString(replacer: (key: string, value: any) =&gt; any, space: any): string;
        toJSONString(replacer: any[], space: any): string;
        toJoinedString(separator?: string): string;
        toJoinedString&lt;TResult&gt;(separator: string, selector: (element: T, index: number) =&gt; TResult): string;
        doAction(action: (element: T, index: number) =&gt; void ): IEnumerable&lt;T&gt;;
        doAction(action: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        forEach(action: (element: T, index: number) =&gt; void ): void;
        forEach(action: (element: T, index: number) =&gt; boolean): void;
        write(separator?: string): void;
        write&lt;TResult&gt;(separator: string, selector: (element: T) =&gt; TResult): void;
        writeLine(): void;
        writeLine&lt;TResult&gt;(selector: (element: T) =&gt; TResult): void;
        force(): void;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; { length: number;[x: number]: TResult; }): IEnumerable&lt;TResult&gt;;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; TResult[]): IEnumerable&lt;TResult&gt;;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; IEnumerable&lt;TResult&gt;): IEnumerable&lt;TResult&gt;;
        share(): IDisposableEnumerable&lt;T&gt;;
        memoize(): IDisposableEnumerable&lt;T&gt;;
        catchError(handler: (exception: any) =&gt; void ): IEnumerable&lt;T&gt;;
        finallyAction(finallyAction: () =&gt; void ): IEnumerable&lt;T&gt;;
        log(): IEnumerable&lt;T&gt;;
        log&lt;TValue&gt;(selector: (element: T) =&gt; TValue ): IEnumerable&lt;T&gt;;
        trace(message?: string): IEnumerable&lt;T&gt;;
        trace&lt;TValue&gt;(message: string, selector: (element: T) =&gt; TValue ): IEnumerable&lt;T&gt;;
    }

    interface IOrderedEnumerable&lt;T&gt; extends IEnumerable&lt;T&gt; {
        createOrderedEnumerable&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey, descending: boolean): IOrderedEnumerable&lt;T&gt;;
        thenBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        thenByDescending&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
    }

    interface IDisposableEnumerable&lt;T&gt; extends IEnumerable&lt;T&gt; {
        dispose(): void;
    }

    interface IDictionary&lt;TKey, TValue&gt; {
        add(key: TKey, value: TValue): void;
        get(key: TKey): TValue;
        set(key: TKey, value: TValue): boolean;
        contains(key: TKey): boolean;
        clear(): void;
        remove(key: TKey): void;
        count(): number;
        toEnumerable(): IEnumerable&lt;{ key: TKey; value: TValue }&gt;;
    }

    interface ILookup&lt;TKey, TElement&gt; {
        count(): number;
        get(key: TKey): IEnumerable&lt;TElement&gt;;
        contains(key: TKey): boolean;
        toEnumerable(): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
    }

    interface IGrouping&lt;TKey, TElement&gt; extends IEnumerable&lt;TElement&gt; {
        key(): TKey;
    }
}

// export definition
declare var Enumerable: linqjs.Enumerable;
</code></pre>
<p>アップデートを全然追ってないので、初期に作った定義の仕方のまんまなので、大丈夫かな、まあ、大丈夫じゃないかな、きっと。</p>
<p>とりあえずとにかく面倒くさかった。しかし定義する人が苦労すれば、利用者はハッピーになれるから！！！なのではやくVS対応がまともになってください。ぶんぶんぶん回したいのだけれどねえ←その前にlinq.js ver.3がいつまでもBetaなのをなんとかしろ</p>
</div></div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href=\"https://neue.cc\">neue.cc</a><li>
<li>Powered by: <a href=\"https://github.com/neuecc/Blog2\">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
