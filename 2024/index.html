<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2024</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2024/03/19_Garnet.html">Redis互換の超高速インメモリデータストア「Garnet」にC# CustomCommandを実装してコマンドを拡張する</a></h1>
<ul class="date"><li>2024-03-19</li></ul>
<div class="entry_body"><p>Microsoftから<a href="https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/">Introducing Garnet – an open-source, next-generation, faster cache-store for accelerating applications and services</a>という記事が今日公開されて、Garnetという新しいインメモリデータストアがOSSとして公開されました。Microsoft Researchで<a href="https://github.com/microsoft/FASTER">FASTER</a>を手掛けていたチームによるもので、FASTERはC#実装の高速なキーバリューストアでした。今回のGarnetはその発展形のようなもので、FASTERベースのストレージと、Redis互換のプロトコルによる、インメモリデータストアになっています。詳しくはGarnetのほうのブログ<a href="https://microsoft.github.io/garnet/blog/brief-history">A Brief History of Garnet</a>で。GarnetもC#で作られています。</p>
<p>ベンチマークによると、Redisはもちろんのこと、DragonflyというRedis互換の世界最速のインメモリデータストア（を公式で謳ってる）<a href="https://www.dragonflydb.io/">Dragonfly</a>よりも高速、だそうで。</p>
<p>そもそもRedisの速度に関していうと、シングルスレッドベースであることなどから、たまによくそこまで速くはないというのは言われてきていて、先述のDragonflyは<a href="https://www.publickey1.jp/blog/22/redis25dragonfly2022.html">Redis互換で25倍高速とする「Dragonfly」が登場。2022年の最新技術でインメモリデータストアを実装</a>などというリリースとともに、現代の技術で作り直せばもっともっと速くなる、とはされてきました。とはいえ、単純なGET/SETだけのメモリキャッシュとは比較にならない豊富なデータ型など利便性がとても高く、いうて別にそこまで遅いというわけでもないので、特に気にすることなく使われ続けているのではないでしょうか。</p>
<p>GarnetはC#で作られていますが、当然ながらC#専用ではなく、汎用的なRedisサーバーとして動作するため、既存のRedisクライアントで直接繋げることができます。Redisはそのプロトコル<a href="https://redis.io/docs/reference/protocol-spec/">Redis serialization protocol(RESP)</a>の仕様を公開しているため、互換サーバーが作りやすいというわけですね、素晴らしい……！</p>
<p>C#から使う場合は<a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>と、Garnet同梱のGarent Clientのどちらかが使えます。パッとGarnet Clientを見た限り、現状現実的に使うならStackExchange.Redisですね。最低限は用意されているけれど、Redisクライアントとして使うには、しんどみがありそうです。ただ、性能面ではGarnet Clientのほうが良さそうです。StackExchange.Redisも、前身のBookSleeveから数えると初期設計が10年以上前のものになっているので、現代の観点から見ると設計は古く、パフォーマンス的にも、この実装は悪そうだな、と思えるところがかなりあります。なのでロマンを追いかけるならGarnet Clientを使うのも面白くはあります……！</p>
<h2>C#でカスタムコマンドを実装する</h2>
<p>普通にRedis互換サーバーとして立てて使うのもいいのですが、C#使いなら面白い点があって、Garnetをライブラリとして参照して、アプリケーションに組み込んでのセルフホストができます。例えばロガーとして<a href="https://github.com/Cysharp/ZLogger/">ZLogger</a>を差し込んでVerboseでログを出してみたりとか、ちょっと使いやすくていい感じです。ローカル開発とかだったらDockerでRedis動かして、などではなく、ソリューションにそのまま組み込んで<a href="https://github.com/dotnet/aspire">.NET Aspire</a>で同時起動させるとかもいい感じでしょう。</p>
<pre><code class="language-csharp">using Garnet;
using Microsoft.Extensions.Logging;
using ZLogger;

try
{
    var loggerFactory = LoggerFactory.Create(x =&gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole(options =&gt;
        {
            options.UsePlainTextFormatter(formatter =&gt;
            {
                formatter.SetPrefixFormatter($&quot;[{0}]&quot;, (in MessageTemplate template, in LogInfo info) =&gt; template.Format(info.Category));
            });
        });
    });

    using var server = new GarnetServer(args, loggerFactory);

    // Optional: register custom extensions
    RegisterExtensions(server);

    // Start the server
    server.Start();
    Thread.Sleep(Timeout.Infinite);
}
catch (Exception ex)
{
    Console.WriteLine($&quot;Unable to initialize server due to exception: {ex.Message}&quot;);
}
</code></pre>
<p>もう一つは、カスタムコマンドを実装できることです……！C#で……！</p>
<p>Redis上でちょっと複雑な実行をしたいことはよくあり、Redisの場合は<a href="https://redis.io/docs/interact/programmability/eval-intro/">Lua Script</a>で処理していましたが、GarnetではC#でカスタムコマンドを実装して組み込むことができます。さらに嬉しい点としては、サーバー側で用意した拡張コマンドは、RESPに従っているので、クライアントはC#専用ではなく、PHPからでもGoからでも呼べます。</p>
<p>というわけで、「SETLCLAMP」というSET時にclampするカスタムコマンドを早速作っていきます……！先に↑のコードで欠けてるRegisterExtensionsの部分を。</p>
<pre><code class="language-csharp">static void RegisterExtensions(GarnetServer server)
{
    // ClampLongCustomCommandというカスタムコマンドをSETLCLAMPというコマンド名で登録する。
    // これはMath.Clampを呼び出すので、パラメーター数は3(long value, long min, long max)
    server.Register.NewCommand(&quot;SETLCLAMP&quot;, 3, CommandType.ReadModifyWrite, new ClampLongCustomCommand());
}
</code></pre>
<p>カスタムコマンドの登録自体は非常に簡単で、<code>CustomRawStringFunctions</code>, <code>CustomTransactionProcedure</code> または <code>CustomObjectFactory</code> を実装したクラスをコマンド名と共に追加するだけです。</p>
<p>カスタムコマンドの実装も簡単……？まぁ、理解すればそれなりぐらいに。</p>
<pre><code class="language-csharp">using Garnet.server;
using System.Buffers;
using System.Buffers.Binary;
using Tsavorite.core;

sealed class ClampLongCustomCommand : CustomRawStringFunctions
{
    // trueの場合はKeyが空の時の動作(GetInitialLength, InitilUpdate)を呼びに行く
    public override bool NeedInitialUpdate(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ref (IMemoryOwner&lt;byte&gt;, int) output) =&gt; true;

    // UpdaterのSpan&lt;byte&gt; value（書き込みたいメモリデータ）の長さを決める
    public override int GetInitialLength(ReadOnlySpan&lt;byte&gt; input)
    {
        // 今回はlongだけなので決め打ち8
        return 8;
    }

    public override bool InitialUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, Span&lt;byte&gt; value, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo)
    {
        // inputに対してGetNextArgを連続して呼ぶとパラメーターの取得。これは定型句。
        int offset = 0;
        var arg1 = GetNextArg(input, ref offset);
        var arg2 = GetNextArg(input, ref offset);
        var arg3 = GetNextArg(input, ref offset);

        // ClientはWriteInt64LittleEndianでシリアライズしてきてるので、Readでデシリアライズ
        var v = BinaryPrimitives.ReadInt64LittleEndian(arg1);
        var min = BinaryPrimitives.ReadInt64LittleEndian(arg2);
        var max = BinaryPrimitives.ReadInt64LittleEndian(arg3);

        var result = Math.Clamp(v, min, max);

        // valueに対して値を書くことで値のセットになる
        BinaryPrimitives.WriteInt64LittleEndian(value, result);

        // 戻り値とかエラーを書きたい場合はoutputを使う(RespWriteUtils.WriteBulkStringを使いますが今回は略)
        // var pool = MemoryPool.Rent(8);
        // output = (pool, 8);

        return true;
    }

    // 同じメモリ領域を再利用する(置換する値の長さが同値なら再利用可能)かどうかを決める
    public override bool NeedCopyUpdate(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; oldValue, ref (IMemoryOwner&lt;byte&gt;, int) output) =&gt; false;

    // 置換時に再利用する場合
    public override bool InPlaceUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, Span&lt;byte&gt; value, ref int valueLength, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo)
    {
        // 置換するvalueの長さが一緒(あるいは小さい)の場合は
        // valueにはoldValueが入ってきてる。
        // 今回は特に考慮しないのでそのまんま書く。

        int offset = 0;
        var v = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var min = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var max = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));

        var result = Math.Clamp(v, min, max);

        BinaryPrimitives.WriteInt64LittleEndian(value, result);

        return true;
    }

    // 置換時に別のメモリ領域を確保する場合

    public override int GetLength(ReadOnlySpan&lt;byte&gt; value, ReadOnlySpan&lt;byte&gt; input) =&gt; 8;

    public override bool CopyUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; oldValue, Span&lt;byte&gt; newValue, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo) =&gt; throw new NotImplementedException();


    // 読み込み処理用
    public override bool Reader(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; value, ref (IMemoryOwner&lt;byte&gt;, int) output, ref ReadInfo readInfo) =&gt; throw new NotImplementedException();
}
</code></pre>
<p>今回はRedisでいうところのStringベースで作るので <code>CustomRawStringFunctions</code> を使います。RedisのStringは文字列型じゃなくて、どちらかというとバイナリ型で、バイナリシリアライズできるものなら、なんでも突っ込めるイメージです。私もゲームサーバーを作っていたときはMessagePackのバイナリを突っ込みまくってましたし、開発時には雑に画像データのバイナリを投げ込んで画像DB代わりに使ったりとかもありました。</p>
<p>オーバーライドするメソッドの数が多いことと、パラメーターが<code>Span&lt;byte&gt;</code>だらけで一瞬圧倒されちゃうんですが、冷静に追ってみるとそこまで難しいことは言ってないことに気づきます。追加時(Add)・置換時(Replace)が、最適化のため同じサイズか違うサイズかで2択、それとRead時用。といった別れ方をしています。</p>
<p>key, input, valueが全て<code>ReadOnlySpan&lt;byte&gt;</code>なのは、まぁそりゃそうでしょう(ここでstringとか出てきたら逆に良くない！)</p>
<p>inputをパラメーターに分解するのは<code>GetNextArg</code>というヘルパーメソッドを使います。当然それも出てくるのは<code>ReadOnlySpan&lt;byte&gt;</code>なので、あとは適当に、もしJSONとかMessagePackとか<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>でシリアライズしたデータだったらシリアライザを使って戻すのもいいし、プリミティブの値だったら<code>BinaryPrimitives</code>が恐らく適役です。MemoryPackでValueTupleにまとめちゃうのがArgumentが分かれないので最速かつ簡単かもしれません。</p>
<p>結果は<code>Span&lt;byte&gt; value</code>に書きます。outputは今のところ気にしないでOK。この出力先のSpanの長さは事前に<code>GetLength</code>または<code>GetInitialLength</code>で求めておく必要があります。</p>
<p>と、いうわけで、バイナリ操作がそこそこ混ざることを除けば、それなりに素直に書けるのではないでしょうか。雰囲気は理解しました！</p>
<p>クライアントから呼び出す場合は、こんなメソッドを用意してみます。</p>
<pre><code class="language-csharp">public static class GarnetClientExtensions
{
    // RESPプロトコルにのっとってOpCodeを用意する
    // RESPのBlukStringの仕様: https://redis.io/docs/reference/protocol-spec/#bulk-strings
    // $&lt;length&gt;\r\n&lt;data&gt;\r\n
    readonly static Memory&lt;byte&gt; OpCode_SETLCLAMP = Encoding.ASCII.GetBytes(&quot;$9\r\nSETLCLAMP\r\n&quot;);

    public static async Task&lt;long&gt; ClampAsync(this GarnetClient client, Memory&lt;byte&gt; key, long value, long min, long max, CancellationToken cancellationToken = default)
    {
        var parameters = new byte[24];

        var valSpan = parameters[0..8];
        var minSpan = parameters[8..16];
        var maxSpan = parameters[16..24];

        BinaryPrimitives.WriteInt64LittleEndian(valSpan, value);
        BinaryPrimitives.WriteInt64LittleEndian(minSpan, min);
        BinaryPrimitives.WriteInt64LittleEndian(maxSpan, max);

        // key + (value, min, max)
        // 戻り値のMemoryResultはArrayPoolから借りてる状態なのでDisposeでReturnする
        using var result = await client.ExecuteForMemoryResultWithCancellationAsync(OpCode_SETLCLAMP, new Memory&lt;byte&gt;[] { key, valSpan, minSpan, maxSpan }, cancellationToken);
        
        // 本当はresult.Spanからlongを取りたいんですが、それはまた後日……！
        // return BinaryPrimitives.ReadInt64LittleEndian(result.Span);
        return;
    }
}
</code></pre>
<p>サーバー側で用意した拡張コマンドは、ちゃんとRESPに従っているので、クライアントはC#専用ではありませんし、Garnet Client専用でもありません。StackExchange.Redisであれば、<code>db.Execute(&quot;SETLCLAMP&quot;, ...)</code> で呼べます。</p>
<p>実際に動かしてみるとこんな感じです。</p>
<pre><code class="language-csharp">static async Task RunClientAsync(ILoggerFactory loggerFactory)
{
    var logger = loggerFactory.CreateLogger(&quot;Client&quot;);

    var client = new GarnetClient(&quot;localhost&quot;, 3278, logger: logger);

    logger.ZLogInformation($&quot;Client Connecting.&quot;);
    await client.ConnectAsync();
    logger.ZLogInformation($&quot;Success Connect.&quot;);

    var key = Encoding.UTF8.GetBytes(&quot;foo&quot;);

    await client.ClampAsync(key, 12345, min: 0, max: 100);

    // String系のGET/SET/DELなどは普通に呼べる
    using var v2 = await client.StringGetAsMemoryAsync(key);
    Console.WriteLine(BinaryPrimitives.ReadInt64LittleEndian(v2.Span)); // 100

    var isDelete = await client.KeyDeleteAsync(key);
    Console.WriteLine(isDelete); // True
}
</code></pre>
<p>いいですね！</p>
<h2>まとめ</h2>
<p>さすがに公開されてまだ10時間経ってないぐらいなのでザックリとした理解なのですが、かなりいいんじゃないかと！</p>
<p>どうしてもMemachedとかRedisとかは、クラウドのマネージドサービスが用意されてないと嫌だー、という思考に陥りがちなのですが、C#でガリガリ拡張できるとなれば、まぁマネージドがなくてもしょうがないな！という気持ちになれ、る、でしょうかね……？</p>
<p>まぁそうじゃなくても、あまりマネージド指向になりすぎるのも良くないかな、とは思っています。私は最近はPubSubに<a href="https://nats.io/">NATS</a>をお薦めしてクライアントも作ったりしてたわけですが、もちろんマネージドサービスはありません。で、だから、諦めます、というのは違うかな、と。もったいないと思うんですよね。</p>
<p>なので、必要あれば、いや、必要じゃなくても（？）気持ちがあるなら、自前に立てるというのも否定しちゃあいけないと思ってます。特にC#アプリケーションを作ったことがある人なら、C#で組み込んでホスティングすること自体は別に難しくもない、なんだったらいつもやってることの延長線上でいけますし。もちろん、そこからインフラ安定させるとかデータどうするなとかリカバリどうするとか、そういうのは別問題の話ではありますが……！</p>
<p>ともあれかなり面白いし使える予感があるので、やっていきましょう！</p>
</div>
<h1><a href="https://neue.cc/2024/03/18_Claudia.html">Claudia - Anthropic ClaudeのC# SDKと現代的なC#によるウェブAPIクライアントの作り方</a></h1>
<ul class="date"><li>2024-03-18</li></ul>
<div class="entry_body"><p>AI関連、競合は現れども、性能的にやはりOpenAI一強なのかなぁというところに現れた<a href="https://www.anthropic.com/">Anthropic Claude 3</a>は、確かに明らかに性能がいい、GPT-4を凌駕している……！というわけで大いに気に入った（ついでに最近のOpenAIのムーブが気に入らない）ので、C#で使い倒していきたい！そこで、まずはSDKがないので非公式SDKを作りました。こないだまでプレビュー版を流していたのですが、今回v1.0.0として出します。ライブラリ名は、Claudeだから、Claudiaです！.NET全般で使えるのと、Unity(Runtime/Editor双方)でも動作確認をしているので、アイディア次第で色々活用できると思います。</p>
<ul>
<li><a href="https://github.com/Cysharp/Claudia">GitHub - Cysharp/Claudia</a></li>
</ul>
<p>今回のSDKを作るにあたっての設計指針の一番目は、公式の<a href="https://github.com/anthropics/anthropic-sdk-python">Python SDK</a>や<a href="https://github.com/anthropics/anthropic-sdk-typescript">TypeScript SDK</a>と限りなく似せること、です。というのもドキュメント類の解説はこれら公式SDKベースになるし、世の中的にもブログなどには公式SDKベースの記事が多く出回るでしょう。公式の充実した<a href="https://docs.anthropic.com/claude/prompt-library">プロンプトライブラリ</a>も、APIリクエストで叩き込みたくなるかもしれない。</p>
<p>そんな時に、APIのスタイルが違うと、変換の認知負荷がかかります。些細なことですが、そういうところがすごく大事で引っ掛かってしまうので、徹底的に取り除きます。そのうえで、無理に動的な要素を入れず、C#らしさを崩さないというバランス取りが設計において重要です。</p>
<p>C#クライアントの見た目はこうです。</p>
<pre><code class="language-csharp">// C#
using Claudia;

var anthropic = new Anthropic();

var message = await anthropic.Messages.CreateAsync(new()
{
    Model = &quot;claude-3-opus-20240229&quot;,
    MaxTokens = 1024,
    Messages = [new() { Role = &quot;user&quot;, Content = &quot;Hello, Claude&quot; }]
});

Console.WriteLine(message);
</code></pre>
<p>比較してTypeScriptの見た目はこうなっています。</p>
<pre><code class="language-typescript">// TypeScript
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic();

const message = await anthropic.messages.create({
    model: 'claude-3-opus-20240229',
    max_tokens: 1024,
    messages: [{ role: 'user', content: 'Hello, Claude' }],
});

console.log(message.content);
</code></pre>
<p>かなり近い！でしょう。そのうえで、C#版は<code>dynamic</code>や<code>Dictionary&lt;string, object&gt;</code>などは使わず、全て型付けされたものが指定されます。上記の例で使用しているC# 9.0で追加された<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-new">Target-typed new expressions</a>や、C# 12で追加された<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions">Collection expressions</a>の存在を前提として、うまくAPIを合わせています。</p>
<p>もともと、動的型付け言語のAPIのほうが（見た目は）簡潔で使いやすそう、という印象を抱くことは多いので、それと同レベルの簡潔さで、しっかりと型付けが効いて書けるというのは、現代のC#の大きな強みです。（そもそもTypeScriptの公式SDKに合わせようと思ったのは、私から見ても公式SDKのAPIスタイルはよくできていると思ったからです、仮にあまりにも酷かった場合は合わせようとはしなかったでしょう）</p>
<p>いかにも古典的なC#やJavaみたいな冗長な設計のAPIクライアントは、反省しましょう。現代のC#はここまでやれるのだから。</p>
<h2>Streaming and Blazor</h2>
<p>StreamingのAPIも用意されていて、Blazorと組み合わせれば簡単にリアルタイムに更新されるChat UIが作れます。コードは本当にたったのこれだけ、メソッド本体なんて10行ちょい！</p>
<pre><code class="language-csharp">[Inject]
public required Anthropic Anthropic { get; init; }

double temperature = 1.0;
string textInput = &quot;&quot;;
string systemInput = SystemPrompts.Claude3;
List&lt;Message&gt; chatMessages = new();

async Task SendClick()
{
    chatMessages.Add(new() { Role = Roles.User, Content = textInput });

    var stream = Anthropic.Messages.CreateStreamAsync(new()
    {
        Model = Models.Claude3Opus,
        MaxTokens = 1024,
        Temperature = temperature,
        System = string.IsNullOrWhiteSpace(systemInput) ? null : systemInput,
        Messages = chatMessages.ToArray()
    });

    var currentMessage = new Message { Role = Roles.Assistant, Content = &quot;&quot; };
    chatMessages.Add(currentMessage);

    textInput = &quot;&quot;;
    StateHasChanged();

    await foreach (var messageStreamEvent in stream)
    {
        if (messageStreamEvent is ContentBlockDelta content)
        {
            currentMessage.Content[0].Text += content.Delta.Text;
            StateHasChanged();
        }
    }
}
</code></pre>
<p><img src="https://github.com/Cysharp/Claudia/assets/46207/dfcad512-4cf1-4af0-ba03-901dc7ce36a6" alt="blazorclauderec" /></p>
<p>全てのリクエスト/レスポンス型はSystem.Text.Json.JsonSerializerでシリアライズ可能なため、この<code>List&lt;Message&gt;</code>をそのままシリアライズすれば保存、デシリアライズすれば読み込みになります。</p>
<h2>Function Calling</h2>
<p>ClaudiaはただのREST APIを叩くだけのSDK、ではありません。Source Generatorを活用して、Function Callingを簡単に定義するための仕組みを用意しました。</p>
<p>Function Callingができると何がいいか、というと、現状のLLMは単体だとできないことが幾つかあります。例えば計算は、それっぽい答えを返してくれる場合も多いし、Step-by-Stepで考えさせるなど、それっぽさの精度を上げることはできるけれど、正確な計算はできないという苦手分野だったりします（複雑な計算を投げると正しそうで間違ってる答えを出しやすい）。それなら計算が必要なら普通に計算機で計算して、その答えをもとに文章を作ればいいじゃん、と。あるいは現在日時を答えることもできません。ウェブページを指定して要約したり翻訳して欲しいとお願いしても、中身を見ることはできませんと言われます。それらを解決するのがFunction Callingです。</p>
<p>まずは一例ということで、指定したURLのウェブページをClaudeに返す関数を定義してみましょう。</p>
<pre><code class="language-csharp">public static partial class FunctionTools
{
    /// &lt;summary&gt;
    /// Retrieves the HTML from the specified URL.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;url&quot;&gt;The URL to retrieve the HTML from.&lt;/param&gt;
    [ClaudiaFunction]
    static async Task&lt;string&gt; GetHtmlFromWeb(string url)
    {
        using var client = new HttpClient();
        return await client.GetStringAsync(url);
    }
}
</code></pre>
<p><code>[ClaudiaFunction]</code>で定義した関数がSource Generatorによって色々生成されます。これを利用する場合、以下のようになります。</p>
<pre><code class="language-csharp">var input = new Message
{
    Role = Roles.User,
    Content = &quot;&quot;&quot;
        Could you summarize this page in three lines?
        https://docs.anthropic.com/claude/docs/intro-to-claude
&quot;&quot;&quot;
};

var message = await anthropic.Messages.CreateAsync(new()
{
    Model = Models.Claude3Haiku,
    MaxTokens = 1024,
    System = FunctionTools.SystemPrompt, // set generated prompt
    StopSequences = [StopSequnces.CloseFunctionCalls], // set &lt;/function_calls&gt; as stop sequence
    Messages = [input],
});

var partialAssistantMessage = await FunctionTools.InvokeAsync(message);

var callResult = await anthropic.Messages.CreateAsync(new()
{
    Model = Models.Claude3Haiku,
    MaxTokens = 1024,
    System = FunctionTools.SystemPrompt,
    Messages = [
        input,
        new() { Role = Roles.Assistant, Content = partialAssistantMessage! } // set as Assistant
    ],
});

// The page can be summarized in three lines:
// 1. Claude is a family of large language models developed by Anthropic designed to revolutionize the way you interact with AI.
// 2. This documentation is designed to help you get the most out of Claude, with clear explanations, examples, best practices, and links to additional resources.
// 3. Claude excels at a wide variety of tasks involving language, reasoning, analysis, coding, and more, and the documentation covers key capabilities, getting started with prompting, and using the API.
Console.WriteLine(callResult);
</code></pre>
<p>Claudeへは二回のリクエストを行っています。まず、最初のClaudeへのリクエストでは、質問と共に利用可能な関数の一覧と説明を送り、関数を実行するのが最適だと判断されると、実行したい関数名とパラメーターが返されます。それを下に、手元で関数を実行し、結果をClaudeに渡すことで最終的に求める結果を得られます。</p>
<p>ではSource Generatorは何をやっているのかというと、まずはClaudeのシステム文に渡している<code>FunctionTools.SystemPrompt</code>を生成しているわけですが、その中身はこれです（一部省略）。</p>
<pre><code class="language-xml">// ...前文は省略

&lt;tools&gt;
    &lt;tool_description&gt;
        &lt;tool_name&gt;GetHtmlFromWeb&lt;/tool_name&gt;
        &lt;description&gt;Retrieves the HTML from the specified URL.&lt;/description&gt;
        &lt;parameters&gt;
            &lt;parameter&gt;
                &lt;name&gt;url&lt;/name&gt;
                &lt;type&gt;string&lt;/type&gt;
                &lt;description&gt;The URL to retrieve the HTML from.&lt;/description&gt;
            &lt;/parameter&gt;
        &lt;/parameters&gt;
    &lt;/tool_description&gt;
&lt;/tools&gt;
</code></pre>
<p>XMLです。Claudeは<a href="https://docs.anthropic.com/claude/docs/use-xml-tags">XMLタグを認識</a>するようになっていて、システム的に明確に情報を与えたい場合はXMLタグを活用することがベストプラクティスとなっています。そこで、C#の関数からClaudeに渡すためのXMLを自動生成しています。これを手書きは、したくないでしょう……？</p>
<p>そしてClaudeはそのリクエストに対して、以下のような結果を返します。</p>
<pre><code class="language-xml">&lt;function_calls&gt;
    &lt;invoke&gt;
        &lt;tool_name&gt;GetHtmlFromWeb&lt;/tool_name&gt;
        &lt;parameters&gt;
            &lt;url&gt;https://docs.anthropic.com/claude/docs/intro-to-claude&lt;/url&gt;
        &lt;/parameters&gt;
    &lt;/invoke&gt;
</code></pre>
<p>やはりXMLです（閉じタグが欠けているのはStopSequencesで止めているため。関数を呼びたい場合はこれ以上の情報は不要なので打ち止めておく)。これをパースして、関数(GetHtmlFromWeb)を実行し、Claudeに渡すためのメソッド <code>FunctionTools.InvokeAsync</code> がSource Generatorによって生成されています。実際生成されているInvokeAsyncメソッドは以下のようなものです。</p>
<pre><code class="language-csharp">#pragma warning disable CS1998
    public static async ValueTask&lt;string?&gt; InvokeAsync(MessageResponse message)
    {
        var content = message.Content.FirstOrDefault(x =&gt; x.Text != null);
        if (content == null) return null;

        var text = content.Text;
        var tagStart = text .IndexOf(&quot;&lt;function_calls&gt;&quot;);
        if (tagStart == -1) return null;

        var functionCalls = text.Substring(tagStart) + &quot;&lt;/function_calls&gt;&quot;;
        var xmlResult = XElement.Parse(functionCalls);

        var sb = new StringBuilder();
        sb.AppendLine(functionCalls);
        sb.AppendLine(&quot;&lt;function_results&gt;&quot;);

        foreach (var item in xmlResult.Elements(&quot;invoke&quot;))
        {
            var name = (string)item.Element(&quot;tool_name&quot;)!;
            switch (name)
            {
                case &quot;GetHtmlFromWeb&quot;:
                    {
                        var parameters = item.Element(&quot;parameters&quot;)!;

                        var _0 = (string)parameters.Element(&quot;url&quot;)!;

                        BuildResult(sb, &quot;GetHtmlFromWeb&quot;, await GetHtmlFromWeb(_0).ConfigureAwait(false));
                        break;
                    }

                default:
                    break;
            }
        }

        sb.Append(&quot;&lt;/function_results&gt;&quot;); // final assistant content cannot end with trailing whitespace

        return sb.ToString();

        static void BuildResult&lt;T&gt;(StringBuilder sb, string toolName, T result)
        {
            sb.AppendLine(@$&quot;    &lt;result&gt;
        &lt;tool_name&gt;{toolName}&lt;/tool_name&gt;
        &lt;stdout&gt;{result}&lt;/stdout&gt;
    &lt;/result&gt;&quot;);
        }
    }
#pragma warning restore CS1998
}
</code></pre>
<p>これを手書きは、あまりしたくはないでしょう。特に呼び出したい関数が増えれば増えるほど大変ですし。</p>
<p>これで呼び出し＆生成したXMLを再度Claudeに、Assistantによる先頭の出力結果だと渡すことによって、望む答えを得ることができます。このテクニックは<a href="https://docs.anthropic.com/claude/docs/prefill-claudes-response">Prefill Claude's response</a>として公式でもベストプラクティスの一つとして案内されているもので、Claudeによる返答を望む方向に導くのに有益です。例えば<code>{</code>をprefill responseとして返すと、Claudeが結果をJSONとして出力する確率が飛躍的に上昇します。</p>
<h2>API vs LangChain, SemanticKernel</h2>
<p>大規模言語モデルを触るなら、生で使うよりも<a href="https://www.langchain.com/">LangChain</a>や、特にC#だと<a href="https://github.com/microsoft/semantic-kernel">Semantic Kernel</a>を使うというのを入り口にするのも定説ではありますが、やや疑問はあります。最近でも<a href="https://tech-blog.abeja.asia/entry/advent-2023-day13">LangChainを使わない</a>や<a href="https://tech-blog.abeja.asia/entry/advent-2023-day13">LangChain は LLM アプリケーションの開発に採用すべきではない</a>といった記事のようにLangChain不要論も出てきています。</p>
<p>そもそも、まぁこの記事はエンジニア向けに書いてるわけですが、一部の機能はあきらかに過剰でいらないんじゃないかと、保存用のプラグインとか。Semantic Kernelの大量にあるコネクターパッケージとかぞっとする感じで、コード書けないデータサイエンティストが継ぎ接ぎでやるならともかく、エンジニアは保存ぐらい自前でやったほうが絶対いいでしょ。TimePluginだのHttpPluginだのFileIOPluginだのも、正直馬鹿らしい、という感じしかないのでは。</p>
<p>どうせ最後に叩くのは生APIなら、真摯にAPIドキュメントを読め、と。<a href="https://docs.anthropic.com/claude/docs/intro-to-claude">ClaudeのAPIドキュメントのUser Guides</a>は分かりやすく素晴らしく、それもまたClaudeを支持したい理由の一つになります。しょうもない抽象化を通すぐらいならClaudeに特化して、特徴的なXMLによる指示の活かしかたを考えろ、と。</p>
<p>特にC#の人はSemantic Kernel至上主義になってると思われるので、いったんまずそっから離れて考えていくといいんじゃないです？</p>
<h2>モダンウェブAPIクライアントの作り方</h2>
<p>ここからはClaudiaの設計から見る現代的なAPIクライアントの設計方法の話をします。</p>
<p>まず、通信の基盤は<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.net.http.httpclient?view=net-8.0">HttpClient</a>を使います。一択です。異論を挟む余地はない。<a href="https://github.com/grpc/grpc-dotnet/tree/master/src/Grpc.Net.Client">Grpc.Net.Client</a>だってHTTP/2 gRPC通信にHttpClientを使っていますし、好むと好まざると全てのHTTP系の通信の基盤はHttpClientです。</p>
<p>ここでは、外からHttpMessageHandlerを受け取れるようにしておくといいでしょう。</p>
<pre><code class="language-csharp">public class Anthropic : IMessages, IDisposable
{
    readonly HttpClient httpClient;

    // DefaultRequestHeadersやBaseAddressを変更させてあげるためにpublicで公開しておく
    public HttpClient HttpClient =&gt; httpClient;

    public Anthropic()
        : this(new HttpClientHandler(), true)
    {
    }

    public Anthropic(HttpMessageHandler handler)
        : this(handler, true)
    {
    }

    public Anthropic(HttpMessageHandler handler, bool disposeHandler)
    {
        this.httpClient = new HttpClient(handler, disposeHandler);
    }

    public void Dispose()
    {
        httpClient.Dispose();
    }
}
</code></pre>
<p>HttpClientというのは実はガワでしかなくて、実体はHttpMessageHandlerです。HttpMessageHandlerにはやれることが色々あって、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.net.http.delegatinghandler?view=net-8.0">DelegatingHandler</a>を実装してリクエストの前後をフックするような機能を仕込んだりも出来るし、<a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a>はHttpMessageHandlerの実装という形で通信処理を丸ごとRust実装に差し替えています。Unityでは.NETランタイムの通信実装じゃなくてUnityWebRequestを使いたいんだよなあ、といったような場合には<a href="https://gist.github.com/neuecc/854192b8d176170caf2c53fa7589dc90">UnityWebRequestHttpMessageHandler.cs</a>を使えば、やはり通信処理が全てUnityによるものに差し替わります。</p>
<p>インターフェイスの切り方も工夫していきましょう。</p>
<p><code>client.Messages.CreateAsync</code> のように、MVCでいったら<code>.Controller.Method</code>のように、2階層に整理された呼び出し方は直感的で使いやすい設計です。特に、入力補完に優しいのが嬉しい。そのためには、まずインターフェイスを切りますが、工夫として、それを<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation">明示的なインターフェイスの実装</a>にして、インターフェイス自体は<code>return this;</code>で返してやりましょう。</p>
<pre><code class="language-csharp">public interface IMessages
{
    Task&lt;MessageResponse&gt; CreateAsync(MessageRequest request, RequestOptions? overrideOptions = null, CancellationToken cancellationToken = default);
    IAsyncEnumerable&lt;IMessageStreamEvent&gt; CreateStreamAsync(MessageRequest request, RequestOptions? overrideOptions = null, CancellationToken cancellationToken = default);
}

public class Anthropic : IMessages, IDisposable
{
    public IMessages Messages =&gt; this;

    async Task&lt;MessageResponse&gt; IMessages.CreateAsync(MessageRequest request, RequestOptions? overrideOptions, CancellationToken cancellationToken)
    {
        // ...
    }

    async IAsyncEnumerable&lt;IMessageStreamEvent&gt; IMessages.CreateStreamAsync(MessageRequest request, RequestOptions? overrideOptions, [EnumeratorCancellation] CancellationToken cancellationToken)    
    {
        // ...
    }
}
</code></pre>
<p>これによって一個階層を下がる際のアロケーションがない(thisを返すため)ですし、明示的な実装になっているのでトップ階層では入力補完には現れないので、使いやすさと性能、ついでにいえば実装のしやすさ（全てのクライアントのフィールドにそのままアクセスできるため）の全てが満たされます。</p>
<h2>ユーザーフレンドリーなリクエスト型生成</h2>
<p><a href="https://docs.anthropic.com/claude/reference/messages_post">Anthropicのリクエスト型</a>はかなり整理されて、型有り言語に優しい仕様になっているのですが、一部、<code>single string or an array of content blocks</code>というものがあります。どっちか、とかそういうの微妙に困るわけですが、しかし、じゃあ<code>Option&lt;Either&lt;List&lt;&gt;&gt;&gt;</code>かなー、とか、そういうことではありません。そんな定義にしたらAPIクライアントの手触りは最悪になるでしょう。よく考えてみると、Anthropic APIのこの場合のstringは、長さ1のstring contentと同一です。</p>
<pre><code class="language-csharp">// こうじゃなくて
Content = [ new() { Type = &quot;text&quot;, Text = &quot;Hello, Claude&quot; }]

// こう書きたい
Content = &quot;Hello, Claude&quot;
</code></pre>
<p>これは、良い仕様だと思います。杓子定規に Type = &quot;text&quot;, Text = &quot;...&quot; と書かせるのはダルいでしょう。利用時の95%ぐらいはsingle string contentでしょうし(Typeはimageの場合もある、その場合はSourceにバイナリのbase64文字列を設定する。arrayなのは、画像とテキストを両方渡したりするため)。</p>
<p>その仕様をC#で実現しましょう。今回の場合、正規化するようなイメージでいいので、暗黙的変換で実装しました。</p>
<pre><code class="language-csharp">public record class Message
{
    /// &lt;summary&gt;
    /// user or assistant.
    /// &lt;/summary&gt;
    [JsonPropertyName(&quot;role&quot;)]
    public required string Role { get; set; }

    /// &lt;summary&gt;
    /// single string or an array of content blocks.
    /// &lt;/summary&gt;
    [JsonPropertyName(&quot;content&quot;)]
    public required Contents Content { get; set; }
}

public class Contents : Collection&lt;Content&gt;
{
    public static implicit operator Contents(string text)
    {
        var content = new Content
        {
            Type = ContentTypes.Text,
            Text = text
        };
        return new Contents { content };
    }
}
</code></pre>
<p><code>Content[]</code>ではなくて独自のコレクションにして、それの文字列からの暗黙的変換でsingle string contentを生成する形にしました。別に最新のC#仕様でもなんでもなく昔からある手法ですし、闇雲な利用は厳禁ですが、こうしたところに利用するのはAPIクライアントの手触り向上に効果的です。</p>
<h2>タイムアウト</h2>
<p>タイムアウトは定番の処理なので、APIクライアントで簡単にユーザーが設定できるようにしておいたほうがいいでしょう。といっても、HttpClientがTimeoutプロパティを持っているので、通常はそれにセットしてあげるだけで十分です。しかし、Claudiaではあえて無効にしています。</p>
<pre><code class="language-csharp">public class Anthropic : IMessages, IDisposable
{
    public TimeSpan Timeout { get; init; } = TimeSpan.FromMinutes(10);

    public Anthropic(HttpMessageHandler handler, bool disposeHandler)
    {
        this.httpClient = new HttpClient(handler, disposeHandler);
        this.httpClient.Timeout = System.Threading.Timeout.InfiniteTimeSpan;
    }
}
</code></pre>
<p>Anthropicの公式クライアントがメソッド呼び出し毎にTimeout設定をオーバーライドできるという仕様を持っているため、それにならってオーバーライド可能に必要があったためです。HttpClientやそれに準ずるもの呼び出しはスレッドセーフであるべき(実際APIクライアントはSingletonで登録されたりする場合がある)なので、SendAsyncでHttpCleintのプロパティの値を弄るのはよくない。ので、HttpClientが持つTimeoutは無効にして、手動で処理するようにしています。</p>
<p>実装方法は、LinkedTokenSourceを生成し、CancelAfterによってタイムアウト時間後にキャンセルされるCancellationTokenを作り、HttpClient.SendAsyncに渡すだけです。なお、これはHttpClient.Timeoutがタイムアウト時間を持つ場合の内部実装と同じです。</p>
<pre><code class="language-csharp">// 実際のコードはリトライ処理と混ざっているため、若干異なります
async Task&lt;TResult&gt; RequestWithAsync&lt;TResult&gt;(HttpRequestMessage message, CancellationToken cancellationToken, RequestOptions? overrideOptions)
{
    var timeout = overrideOptions?.Timeout ?? Timeout;
    using (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
    {
        cts.CancelAfter(timeout);

        try
        {
            var result = await httpClient.SendAsync(message, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(ConfigureAwait);
            return result;
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                throw new OperationCanceledException(ex.Message, ex, cancellationToken);
            }
            else
            {
                throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
            }

            throw;
        }
    }
}
</code></pre>
<p>実際にキャンセルされた場合(OperationCanceledExceptionが投げられる)のエラーハンドリングには注意しましょう。まず、LinkedTokenを剥がす必要があります。素通しだとOperationCanceledExceptionのTokenがLinkedTokenのままですが、これだと上流側でキャンセル原因の判定に使うことができません。キャンセル原因が渡されているCancellationTokenのキャンセルだった場合は、OperationCanceledExceptionを作り直してキャンセル理由のTokenを変更します。</p>
<p>タイムアウトだった場合はOperationCanceledExceptionではなく、<code>TimeoutException</code>を投げてあげるのが良いでしょう。なお、HttpClientのタイムアウト実装を使った場合は歴史的事情で<code>TaskCanceledException</code>を投げてくるようになっています（互換性のため変更したくても、もう変更できない、とのこと。あまり良い設計ではないと言えるので、そこは見習わなくていいでしょう）</p>
<h2>リトライ</h2>
<p>リトライをAPIクライアント自身が持つべきかどうかに関しては、少し議論があるかもしれません。しかし、単純に例外が出たらcatchしてリトライかければいいというものではなく、リトライ可なものと不可のものの判別がまず必要です。例えば認証に失敗しているとか、リクエストに投げるJSONが腐ってるといった場合は何度リトライしても無駄なのでリトライすべきものではないのですが、そうした細かい条件は、APIクライアント自身しか知り得ないので、リトライ処理を内蔵してしまうのは良いと思います。</p>
<p>Claudiaでは公式クライアントに準拠する形で、具体的には408 Request Timeout, 409 Conflict, 429 Rate Limit, and &gt;=500 Internal errorsをリトライ対象にしています。認証失敗のPermissionError(403)やリクエスト内容が不正(InvalidRequestError(400))はリトライされません。たまによくあるOverloadedError(過負荷状態なので結果返せまんでしたエラー)は529で、これは何度か叩き直せば解消されるやつなのでリトライして欲しい、といったものはリトライされます。</p>
<p>リトライロジックも公式クライアントに準拠していて、レスポンスヘッダにretry-after-msやretry-afterがあればそれに従いつつ、ない場合(やretry-afterが規定よりも大きい場合)はジッター付きのExponential Backoffで間隔を制御しています。</p>
<h2>Server Sent Eventsの超高速パース</h2>
<p>Streamingでレスポンスを取得するAPIは、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent events</a>という仕様で、ストリーミングで送信されてきます。具体的には以下のようなテキストメッセージが届きます。</p>
<pre><code>event: message_start
data: {&quot;type&quot;:&quot;message_start&quot;,&quot;message&quot;:...}

event: content_block_start
data: {&quot;type&quot;:&quot;content_block_start&quot;,&quot;index&quot;:...}
</code></pre>
<p>event: イベント名, data: JSON, ...。といったことの繰り返しです。さて、改行区切りのテキストメッセージといったら<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.streamreader">StreamReader</a>でReadLine、というのは正解、ではあるのですがモダンC#的には不正解です。</p>
<p>ReadLineは文字列を生成します。イベント名の判定のために、あるいは最終的にdataのJSONはデシリアライズしてオブジェクトに変換するのですが、UTF8のデータから直接変換できるはずです。というわけで、ここは（ユーザーに渡すオブジェクトの生成以外は）ゼロアロケーションが狙えます。文字列を通しさえしなければ。というわけでStreamReaderの出番はありません。</p>
<p>具体的なコードを見ていきましょう。前半部（下準備）と後半部（パース部分）で分けます。</p>
<pre><code class="language-csharp">internal class StreamMessageReader
{
    readonly PipeReader reader;
    readonly bool configureAwait;
    MessageStreamEventKind currentEvent;

    public StreamMessageReader(Stream stream, bool configureAwait)
    {
        this.reader = PipeReader.Create(stream);
        this.configureAwait = configureAwait;
    }

    public async IAsyncEnumerable&lt;IMessageStreamEvent&gt; ReadMessagesAsync([EnumeratorCancellation] CancellationToken cancellationToken)
    {
    READ_AGAIN:
        var readResult = await reader.ReadAsync(cancellationToken).ConfigureAwait(configureAwait);

        if (!(readResult.IsCompleted | readResult.IsCanceled))
        {
            var buffer = readResult.Buffer;

            while (TryReadData(ref buffer, out var streamEvent))
            {
                yield return streamEvent;
                if (streamEvent.TypeKind == MessageStreamEventKind.MessageStop)
                {
                    yield break;
                }
            }

            reader.AdvanceTo(buffer.Start, buffer.End);
            goto READ_AGAIN;
        }
    }
</code></pre>
<p>まず、Streamは、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.pipelines.pipereader">System.IO.Pipelines.PipeReader</a>に渡しておきます。今回のStreamはネットワークからサーバー側がストリーミングで返してくる不安定なStreamなので、バッファ管理が大変です。PipeReader/PipeWriterは、若干癖がありますが、その辺の管理をよしなにやってくれるもので、現代のC#ではかなり重要なライブラリです。</p>
<p>基本の流れはバッファを読み込み(ReadAsync)、そのバッファでパース可能(行の末尾までないとパースできないので、改行コードが含まれているかどうか)な状態なら、1行毎にパース(TryReadData)してyield returnでオブジェクトを返す。バッファが足りなかったらAdvanceToで読み取った部分までマークしてから、再度ReadAsync、といった流れになります。</p>
<p>利用側はBlazorのサンプルで出していたのですが、await foreachで列挙するのが基本になります。</p>
<pre><code class="language-csharp">await foreach (var messageStreamEvent in Anthropic.Messages.CreateStreamAsync())
{
}
</code></pre>
<p>こういったネットワークの絡む処理のストリーミング処理にはIAsyncEnumerableが非常に向いていますし、データソース側も、非同期シーケンスをyield returnで返せるというのは、とても楽になりました。これがない時代には、もう戻るのは無理でしょう……。</p>
<p>次に後半部、PipeReaderによって分解されたバッファからパースする処理になります。</p>
<pre><code class="language-csharp">[SkipLocalsInit]
bool TryReadData(ref ReadOnlySequence&lt;byte&gt; buffer, [NotNullWhen(true)] out IMessageStreamEvent? streamEvent)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);
    Span&lt;byte&gt; tempBytes = stackalloc byte[64]; // alloc temp
    
    while (reader.TryReadTo(out ReadOnlySequence&lt;byte&gt; line, (byte)'\n', advancePastDelimiter: true))
    {
        if (line.Length == 0)
        {
            continue; // next.
        }
        else if (line.FirstSpan[0] == 'e') // event
        {
            // Parse Event.
            if (!line.IsSingleSegment)
            {
                line.CopyTo(tempBytes);
            }
            var span = line.IsSingleSegment ? line.FirstSpan : tempBytes.Slice(0, (int)line.Length);

            var first = span[7]; // &quot;event: [c|m|p|e]&quot;

            if (first == 'c') // content_block_start/delta/stop
            {
                switch (span[23]) // event: content_block_..[]
                {
                    case (byte)'a': // st[a]rt
                        currentEvent = MessageStreamEventKind.ContentBlockStart;
                        break;
                    case (byte)'o': // st[o]p
                        currentEvent = MessageStreamEventKind.ContentBlockStop;
                        break;
                    case (byte)'l': // de[l]ta
                        currentEvent = MessageStreamEventKind.ContentBlockDelta;
                        break;
                    default:
                        break;
                }
            }
            else if (first == 'm') // message_start/delta/stop
            {
                switch (span[17]) // event: message_..[]
                {
                    case (byte)'a': // st[a]rt
                        currentEvent = MessageStreamEventKind.MessageStart;
                        break;
                    case (byte)'o': // st[o]p
                        currentEvent = MessageStreamEventKind.MessageStop;
                        break;
                    case (byte)'l': // de[l]ta
                        currentEvent = MessageStreamEventKind.MessageDelta;
                        break;
                    default:
                        break;
                }
            }
            else if (first == 'p')
            {
                currentEvent = MessageStreamEventKind.Ping;
            }
            else if (first == 'e')
            {
                currentEvent = (MessageStreamEventKind)(-1);
            }
            else
            {
                // Unknown Event, Skip.
                // throw new InvalidOperationException(&quot;Unknown Event. Line:&quot; + Encoding.UTF8.GetString(line.ToArray()));
                currentEvent = (MessageStreamEventKind)(-2);
            }

            continue;
        }
        else if (line.FirstSpan[0] == 'd') // data
        {
            // Parse Data.
            Utf8JsonReader jsonReader;
            if (line.IsSingleSegment)
            {
                jsonReader = new Utf8JsonReader(line.FirstSpan.Slice(6)); // skip data: 
            }
            else
            {
                jsonReader = new Utf8JsonReader(line.Slice(6)); // ReadOnlySequence.Slice is slightly slow
            }

            switch (currentEvent)
            {
                case MessageStreamEventKind.Ping:
                    streamEvent = JsonSerializer.Deserialize&lt;Ping&gt;(ref jsonReader, AnthropicJsonSerialzierContext.Default.Options)!;
                    break;
                case MessageStreamEventKind.MessageStart:
                    streamEvent = JsonSerializer.Deserialize&lt;MessageStart&gt;(ref jsonReader, AnthropicJsonSerialzierContext.Default.Options)!;
                    break;
                // 中略(MessageDela, MessageStop, ContentBlockStart, ContentBlockDelta, ContentBlockStop, errorに対して同じようなDeserialize&lt;T&gt;
                default:
                    // unknown event, skip
                    goto END;
            }

            buffer = buffer.Slice(reader.Consumed);
            return true;
        }
    }
END:
    streamEvent = default;
    buffer = buffer.Slice(reader.Consumed);
    return false;
}
</code></pre>
<p>event, dataの二行から、dataのJSONをデシリアライズしてオブジェクトを返したい。というのが処理のやりたいことです。bufferには必ずしも都合よくevent, dataの二行が入っているわけでもなくeventだけかもしれない、dataだけかもしれない、あるいはdataも途中で切れてる（そのままだと不完全なJSON）かもしれない。といったことを考慮して、中断・再開できる構造にしておく必要があります。</p>
<p>といっても、基本的には改行コードが存在してれば一行分のバッファは十分あるだろうということで、 <code>while (reader.TryReadTo(out ReadOnlySequence&lt;byte&gt; line, (byte)'\n', advancePastDelimiter: true))</code> といったループを回して、これをStreamReader.ReadLineの代わりにしています。このreaderは<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-8.0">SequenceReader</a>というReadOnlySequenceからの読み取りをサポートするユーティリティで、ref structのため、それ自体のアロケーションはありません。ReadOnlySequenceは性能良く正しく使うには、かなり落とし穴の多いクラスなので、こうしたユーティリティベースに実装したほうがお手軽かつ安全です。</p>
<p>まずeventのパースで、ここからdataがどの種類化を読み取っています。正攻法でやると <code>if (span.SequenceEqual(&quot;content_block_start&quot;))</code> といったように判定していくことになります。<code>Span&lt;byte&gt;</code>へのSequenceEqualは高速な実装になっているので、まぁ悪くないといえば悪くないのですが、とはいえifの連打は如何なものか……。そこで、Claudiaでは実際には以下のような判定に簡略化しています。</p>
<pre><code class="language-csharp">var first = span[7]; // &quot;event: [c|m|p|e]&quot;

if (first == 'c') // content_block_start/delta/stop
{
    switch (span[23]) // event: content_block_..[]
    {
        case (byte)'a': // st[a]rt
            currentEvent = MessageStreamEventKind.ContentBlockStart;
            break;
        case (byte)'o': // st[o]p
            currentEvent = MessageStreamEventKind.ContentBlockStop;
            break;
        case (byte)'l': // de[l]ta
            currentEvent = MessageStreamEventKind.ContentBlockDelta;
            break;
        default:
            break;
    }
}
else if (first == 'm') // message_start/delta/stop
{
    switch (span[17]) // event: message_..[]
    {
        case (byte)'a': // st[a]rt
            currentEvent = MessageStreamEventKind.MessageStart;
            break;
        case (byte)'o': // st[o]p
            currentEvent = MessageStreamEventKind.MessageStop;
            break;
        case (byte)'l': // de[l]ta
            currentEvent = MessageStreamEventKind.MessageDelta;
            break;
        default:
            break;
    }
}
</code></pre>
<p>メッセージの種類はcontent_block_start/delta/stop, message_start/delta/stop, ping, errorの8種類。まず、先頭1文字でcontent系かmessage系かその他か判定できる。start/delta/stopに関しては3文字目を見ると判定できる。というわけで、1byteのチェックを2回行うだけで分類可能です。明らかに高速！なお、今後のメッセージ種類の追加でチェックが壊れる可能性がゼロではない（例えばcontent_block_ffowardとかが来るとcontent_block_stopと誤判定される）、という問題があることは留意する必要があります。Claudiaではいうて大丈夫だろ、という楽観視してますが。</p>
<p>なお、これは以前に発表したモダンハイパフォーマンスC# 2023でのコードのバリエーションと言えるでしょうか。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6?slide=62" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>テキストプロトコルを見るとなんとかして判定をちょろまかしたいという欲求に抗うのは難しい……。なお、もし厳密な判定をしつつもif連打を避けたい場合は、まず長さチェックをいれます。長さで大雑把な分岐をかけてからSequenceEqualで正確なチェックをします。ようするところ、C#のstringへのswtichの最適化（コンパイラがそういう処理に変換している！）と同じことをやろうという話なだけですが。分岐数が多い場合はハッシュコードを取って分岐かけるとか、ようするにインラインDictionaryのようなものを実装するのもアリでしょう。</p>
<p>最後に、data行はJSON Deserializeです。<code>ReadOnlySpan&lt;byte&gt;</code>または<code>ReadOnlySequence&lt;byte&gt;</code>のままデシリアライズするには<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonreader?view=net-8.0">Utf8JsonReader</a>を通す必要があります。なお、<code>Utf8JsonReader</code>もref structなのでアロケーションには含めません。</p>
<p>これで、Stringを一切通さない処理ができました！StreamReaderを使えば超単純になるのに！という気はしなくもないですが、文字列化したら負けだと思っている病に罹患しているのでしょーがない……。</p>
<h2>Source Generator vs Reflection</h2>
<p>Function Callingの実装に、ClaudiaではSource Generatorを採用しました。リフレクションベースで作成することも可能では有りましたが、今回に関してはSource Generatorのほうが望ましい結果が得られました。まず、仮にリフレクションで実装したらどんな関数定義を要求されるだろうか、というところを、Semantic Kernel実装の場合との比較で見てください。</p>
<pre><code class="language-csharp">public static partial class FunctionTools
{
    // Claudia Source Generator

    /// &lt;summary&gt;
    /// Retrieve the current time of day in Hour-Minute-Second format for a specified time zone. Time zones should be written in standard formats such as UTC, US/Pacific, Europe/London.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;timeZone&quot;&gt;The time zone to get the current time for, such as UTC, US/Pacific, Europe/London.&lt;/param&gt;
    [ClaudiaFunction]
    public static string TimeOfDay(string timeZone)
    {
        var time = TimeZoneInfo.ConvertTimeBySystemTimeZoneId(DateTime.UtcNow, timeZone);
        return time.ToString(&quot;HH:mm:ss&quot;);
    }

    // Semantic Kernel

    [KernelFunction]
    [Description(&quot;Retrieve the current time of day in Hour-Minute-Second format for a specified time zone. Time zones should be written in standard formats such as UTC, US/Pacific, Europe/London.&quot;)]
    public static string TimeOfDay([Description(&quot;The time zone to get the current time for, such as UTC, US/Pacific, Europe/London.&quot;)]string timeZone)
    {
        var time = TimeZoneInfo.ConvertTimeBySystemTimeZoneId(DateTime.UtcNow, timeZone);
        return time.ToString(&quot;HH:mm:ss&quot;);
    }
}
</code></pre>
<p>Function Callingでは、Claudeに関数の情報を与えなければならないので、メソッド・パラメーター共に説明が必須です。ClaudiaのSource Generator実装ではそれをドキュメントコメントから取得するようにしました。Semantic KernelではDescription属性から取ってきています。これはドキュメントコメントのほうが自然で書きやすいはずです。特にパラメーターへの属性は、書きやすさだけじゃなく、複数パラメーターがある場合にかなり読みづらくなります。</p>
<p>また、Source Generatorではアナライザーとして不足がある際にはコンパイルエラーにできます。</p>
<p><img src="https://github.com/Cysharp/Claudia/assets/46207/1cfb81d4-9105-423f-867b-408d63e88a59" alt="image" /></p>
<p>全てのパラメーターにドキュメントコメントが書かれていなければならない・対応していない型を利用している、などのチェックが全てコンパイル時どころかエディット時にリアルタイムに分かります。</p>
<p>難点は実装難易度がSource Generatorのほうが高いことと、ドキュメントコメントの利用にはかなり注意が必要です。</p>
<p>Roslyn上でドキュメントコメントを取得するには、<code>ISymbol.GetDocumentationCommtentXml()</code>が最もお手軽なのですが、これが取得できるかどうかは<code>&lt;GenerateDocumentaionFile&gt;</code>に左右されます。<code>false</code>の場合は常にnullを返します。それだと使いにくすぎるので、ClaudiaではSyntaxNodeから取得しようとしたのですが、それも同じく<code>&lt;GenerateDocumentaionFile&gt;</code>の影響を受けていました。</p>
<p>そこでしょうがなく、以下のような拡張メソッドを用意することで全ての状況でドキュメントコメントを取得することに成功しました(Triviaベースなので少し扱いづらいですが、取れないよりも遥かにマシ）</p>
<pre><code class="language-csharp">public static DocumentationCommentTriviaSyntax? GetDocumentationCommentTriviaSyntax(this SyntaxNode node)
{
    if (node.SyntaxTree.Options.DocumentationMode == DocumentationMode.None)
    {
        var withDocumentationComment = node.SyntaxTree.Options.WithDocumentationMode(DocumentationMode.Parse);
        var code = node.ToFullString();
        var newTree = CSharpSyntaxTree.ParseText(code, (CSharpParseOptions)withDocumentationComment);
        node = newTree.GetRoot();
    }

    foreach (var leadingTrivia in node.GetLeadingTrivia())
    {
        if (leadingTrivia.GetStructure() is DocumentationCommentTriviaSyntax structure)
        {
            return structure;
        }
    }

    return null;
}
</code></pre>
<p>DocumentationModeの状態によって<code>DocumentationCommentTriviaSyntax</code>が取れるかどうかが変わる(<code>GenerateDocumentaionFile=false</code>の場合はNoneになる)ので、Noneの場合は<code>DocumentationMode.Parse</code>をつけたうえでパースし直すことで取得できました。SyntaxNodeのままオプションを渡してCSharpSyntaxTreeを生成しても、パースし直してくれないのかDocumentationModeを変更しても無駄だったので、文字列化してからParseTextするようにしています。</p>
<h2>JSON Serializer</h2>
<p>リクエストもレスポンスもJSONです、今の世の中。そして、使うライブラリは<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.jsonserializer?view=net-8.0">System.Text.Json.JsonSerializer</a>一択です。異論を挟む余地は、ありますが、ない。好むと好まざると、もはや使わなければならないわけです。</p>
<p>System.Text.Jsonの特徴としてはUTF8ベースで処理ができることなので、極力文字列を通さないようにしてあげると高い性能が見込めます。<code>ReadOnlySpan&lt;byte&gt;</code>または<code>ReadOnlySequence&lt;byte&gt;</code>をデシリアライズするには <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonreader?view=net-8.0">Utf8JsonReader</a>を通す必要があります。これはref structだからアロケーションがないので、そのままnewして使っていきましょう。ではWriterは？というと、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonwriter?view=net-8.0">Utf8JsonWriter</a>はclassです。どうして……？なので、Writerに関してはアプリケーションの作りによりますが、フィールドに持って使い回せるのならフィールドに持っての使いまわし(Resetがあります）、持てない場合は<code>[ThreadStatic]</code>から引っ張ってくるようにしましょう。</p>
<p>ライブラリで用意する場合は、利用する型が全て決まっているので<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/system-text-json/source-generation?pivots=dotnet-8-0">ソース生成</a>してあげると、パフォーマンスもよく、AOTセーフ度も上がるので望ましいはずです。Claudiaでも生成しています。</p>
<pre><code class="language-csharp">[JsonSourceGenerationOptions(
    GenerationMode = JsonSourceGenerationMode.Default,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
    WriteIndented = false)]
[JsonSerializable(typeof(MessageRequest))]
[JsonSerializable(typeof(Message))]
[JsonSerializable(typeof(Contents))]
[JsonSerializable(typeof(Content))]
[JsonSerializable(typeof(Metadata))]
[JsonSerializable(typeof(Source))]
[JsonSerializable(typeof(MessageResponse))]
[JsonSerializable(typeof(Usage))]
[JsonSerializable(typeof(ErrorResponseShape))]
[JsonSerializable(typeof(ErrorResponse))]
[JsonSerializable(typeof(Ping))]
[JsonSerializable(typeof(MessageStart))]
[JsonSerializable(typeof(MessageDelta))]
[JsonSerializable(typeof(MessageStop))]
[JsonSerializable(typeof(ContentBlockStart))]
[JsonSerializable(typeof(ContentBlockDelta))]
[JsonSerializable(typeof(ContentBlockStop))]
[JsonSerializable(typeof(MessageStartBody))]
[JsonSerializable(typeof(MessageDeltaBody))]
public partial class AnthropicJsonSerialzierContext : JsonSerializerContext
{
}
</code></pre>
<pre><code class="language-csharp">// 内部での利用時は全てこのJsonSerializerContextを指定している
JsonSerializer.SerializeToUtf8Bytes(request, AnthropicJsonSerialzierContext.Default.Options)
</code></pre>
<p>一つ引っ掛かったのが、<code>JsonIgnoreCondition.WhenWritingNull</code>が、通常(リフレクションベース)だと<code>Nullable&lt;T&gt;</code>にも効いていたのですが、Source Generatorだと効かなくなってnullの時に無視してくれなくなったという挙動の差異がありました。しょうがないので、全ての対象の型の<code>Nullable&lt;T&gt;</code>プロパティに直接<code>[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]</code>を付与することで回避しました。</p>
<pre><code class="language-csharp">public record class MessageRequest
{
    // ...

    [JsonPropertyName(&quot;temperature&quot;)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public double? Temperature { get; set; }
}
</code></pre>
<p>正直Source Generator版の実装漏れの気がするんですが、まぁ回避できたので、とりあえずはいっか。。。</p>
<h2>まとめ</h2>
<p>OpenAI APIに対するAzure OpenAI Serviceのように、AWS環境の人は<a href="https://aws.amazon.com/jp/bedrock/">Amazon Bedrock</a>経由のほうが使いやすい、というのがあるかもしれません。というわけで本日の先ほどのリリース(v1.0.1)でBedrock対応もしました！より一層利用しやすくなったはずです。</p>
<p>Anthorpic APIを使うにあたって、このClaudiaが、公式SDKや各言語の非公式SDKも含めて、最も使いやすいSDKになっているんじゃないかと自負します。ということは、C#が最もClaudeをAPI経由で使うのに捗る言語ということです！これはC#やるしかない！あるいはClaudeやるしかない！ということで、やっていきましょう……！</p>
</div>
<h1><a href="https://neue.cc/2024/02/27_R3.html">R3 - C#用のReactive Extensionsの新しい現代的再実装</a></h1>
<ul class="date"><li>2024-02-27</li></ul>
<div class="entry_body"><p>先日、新しいC#用のReactive Extensionsの実装としてR3を正式公開しました！R3は<a href="https://github.com/dotnet/reactive">Rx for .NET</a>を第一世代、<a href="https://github.com/neuecc/UniRx">UniRx</a>を第二世代とした場合の、第三世代のRxという意味で命名しています。Rxとしてのコア部分(ほぼdotnet/reactiveと同様)は.NET共通のライブラリとして提供し、各プラットフォーム特化のカスタムスケジューラーやオペレーターは別ライブラリに分けるという形により、全ての.NETプラットフォーム向けのコアライブラリと、各種フレームワーク Unity, Godot, Avalonia, WPF, WinForms, WinUI3, Stride, LogicLooper, MAUI, MonoGame 向けの拡張ライブラリを提供しています。</p>
<ul>
<li><a href="https://github.com/Cysharp/R3">GitHub - Cysharp/R3</a></li>
</ul>
<p>幾つかの破壊的変更を含むため、ドロップインリプレースメントではないですが、dotnet/reactiveやUniRxからの移行も現実的に可能な範囲に収めてあります。この辺は語彙や操作がLINQ的に共通化されているというRxの良いところで、そこのところは大きく変わりはありません。思ったよりも何も変わっていない、といったような印象すら抱けるかもしれませんが、そう思っていただければ、それはそれでR3の設計としては大成功ということになります。</p>
<p>なので基本的なところはRxですし、使えるところも変わりないです。よって、押さえておくべきことは、なぜ今R3という新たな実装が必要になったかということと、Rx for .NET, UniRxとの違いはどこかということです。（新規の人は何も考えず使ってください……！）</p>
<p>機能とか移行とかの話は、toRisouPさんにより既に優れた記事が上がっているので、今回は概念的なところを中心に紹介します……！</p>
<ul>
<li><a href="https://qiita.com/toRisouP/items/e7be5a5a43058556db8f">次世代Rx「R3」解説</a></li>
<li><a href="https://qiita.com/toRisouP/items/4344fbcba7b7e8d8ce16">【Unity】 R3とUniRxの比較まとめ</a></li>
</ul>
<h2>Rxの歴史と vs async/await</h2>
<p>Rx使ってますか？という問いに、使ってません、と答える人も増えてきました。別にこれは.NETやUnityだけの話ではなく、JavaでもSwiftでもKotlinでも。明らかにプレゼンスが低下しています。なぜか？というと、それはもう簡単です。async/awaitが登場したから。.NETのReactive Extensionsが初登場したのは2009年。C# 3.0, .NET Framework 3.5の頃であり、対応プラットフォームもSilverlightやWindows Phoneといった、今はもう消滅したプラットフォームも並んでくるような時代。もちろん、async/await(初登場はC# 5.0, 2012年)も存在していません。まだTaskすら導入されていなかった頃です。余談ですがReactive Extensionsの&quot;Extensions&quot;は、先行して開発されていた<a href="https://en.wikipedia.org/wiki/Parallel_Extensions">Parallel Extensions</a>(Parallel LINQやTask Parallel Library, .NET Framework 4.0で追加された)から名前が取られたとされています。</p>
<p>Rxは、まず、言語サポートのない場合の非同期処理の決定版として、あらゆる言語に普及し一世を風靡しました。単機能なTaskやPromiseよりも、豊富なオペレーターを備えたRxのほうが使いやすいし遥かに強力！私も当時はTPLいらね、とRxに夢中になったものです。しかしasync/awaitが言語に追加されて以降の結果はご存じの通り。async/awaitこそが非同期処理の決定版として、これまたC#からあらゆる言語に普及し、非同期処理におけるスタンダードとなりました。（ちなみにF#こそが発祥だって言う人もいますが、国内海外問わず当時のF#コミュニティのC# async/awaitへの反発と難癖の数々はよーく覚えているので、あ、そうですか、ぐらいの感じです。awaitないしね）</p>
<p>async/awaitが普及したことにより、とりあえず非同期処理のためにRxを入れるという需要はなくなり、Rxの採用率は下がっていったのであった。UnityにおいてのRxのスタンダードであった<a href="https://github.com/neuecc/UniRx/">UniRx</a>の開発者である私も、別にそれに固執することはなく、むしろゲームエンジン(Unity)に特化したasync/awaitランタイムが必要であると素早く認知し、Unityにおいて必要な条件(C# 7.0)が揃ったタイミングで即座に<a href="https://github.com/Cysharp/UniTask">UniTask</a>を開発し、今ではUniTaskは絶対に入れるけどUniRxは入れない、といった開発者も増えてきました。そしてそれは悪いことではなく、むしろ正しい感覚であると思います。</p>
<h2>Rxの価値の再発見</h2>
<p>そもそもRxって別に非同期処理のためだけのシステムではないですよね？LINQ to Everythingではあったけれど、むしろEverythingというのはノイズで、分離するものは分離したほうがいい、最適なものはそれを使ったほうがいい。Rxを非同期処理のために使うべきではないし、長さ1のObservableはTaskで表現したほうが、分かりやすさにおいてもパフォーマンスにおいても利点がある。そうなるとRxにはasync/awaitと統合されたAPIが必要で、それはObservableはモナドだからSelectManyにTaskを渡せることもできるだとか、そんなどうでもいいことではない。真剣にasync/awaitと共存するRxを考えてみると、手を加えなければならないAPIは多数ある。</p>
<p>単純にawaitできるだけでは現実のアプリケーション開発には少し足りない。そこで非同期/並列処理に関しては様々なライブラリが考案されてきました、Rxだけではなく<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/parallel-programming/dataflow-task-parallel-library">TPL Dataflow</a>など色々ありましたが、それらを好んで今から使おうとする人もいないでしょう。そして今は2024年、勝者は決まりました。言語サポートの<a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/generate-consume-asynchronous-stream">IAsyncEnumerable</a>と<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>がベストです。また、これらはバックプレッシャーの性質も内包しているため、RxJavaなどにあるバックプレッシャーに関するオペレーターは.NETには不要でしょう。もう少し具体的なI/Oに関する処理が必要なら<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/io/pipelines">System.IO.Pipelines</a>を選べば、最大のパフォーマンスを発揮できます。</p>
<p>非同期LINQはあってもいいけれど、実際の非同期ストリームのシナリオからするとLINQ to Objectsと違い利用頻度も少ないので、別に積極的に導入したいというほどの代物ではない(なお、これは私はUniTaskに<a href="https://github.com/Cysharp/UniTask/tree/809d23e/src/UniTask/Assets/Plugins/UniTask/Runtime/Linq">UniTaskAsyncEnumerableとLINQ</a>を自分で実装して提供している上での発言です)。Rxの夢の一つとして分散クエリ(IQbservable)がありましたが、それも、現代での勝者は<a href="https://graphql.org/">GraphQL</a>になるでしょう。分散システムという点では<a href="https://kubernetes.io/">Kubernetes</a>が普及し、RPCとしては<a href="https://grpc.io/">gRPC</a>がスタンダードとして君臨し、<a href="https://learn.microsoft.com/en-us/dotnet/orleans/">Orleans</a>, <a href="https://getakka.net/">Akka.NET</a>, <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction">SignalR</a>, <a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>といったような選択肢のバリエーションもあります。</p>
<p>今は様々なテクノロジーが覇権を争った2009年ではない。現代で<a href="https://azure.microsoft.com/ja-jp/products/service-fabric">Service Fabric</a>を選ぶ人などいないように、今からそこに乗り出して勝ち筋を見出すのは難しい。そうした分散処理に進むことはRxの未来ではない。と、私は考えています。Rxを生み出したのがCloud Programmability Teamであるからといって、Cloudで活用できるようにすることが原点で正しいなどということもないだろう。もちろん、未来は複数あってもいいので、私が示すRxの未来の選択肢の一つがR3だと思ってもらえればよいです。</p>
<p>ではRxの価値はどこにあるのか、というと、原点に立ち返ってインメモリのメッセージングをLINQで処理するLINQ to Eventsにあると考えます。特にクライアントサイド、UIに対する処理は、現代でもRxが評価されているポイントであり、Rx Likeな、しかしより言語に寄り添い最適化されている<a href="https://kotlinlang.org/docs/flow.html">Kotlin Flow</a>や<a href="https://developer.apple.com/documentation/combine">Swift Combine</a>といった選択肢が現役で存在しています。UIだけではなく、複雑で大量のイベントが飛び交うゲームアプリケーションにおいても、ゲームエンジン(Unity)で使われているUniRxの開発者として、非常に有益であることを実感しています。オブザーバーパターンやeventの有意義さは疑う余地のないところですし、そこでRxがbetter event、オブザーパーパターンの決定版として使えることもまた変わらないわけです。</p>
<h2>R3での再構築</h2>
<p>最初に、Rxとしてのインターフェイスを100%維持しながらレガシーAPIの削除や新APIの追加をすべきか、それとも根本から変更すべきかを悩みました。しかし（私が問題だと考えている）すべての問題を解決するには抜本的な変更が必要だし、Kotlin FlowやSwift Combineの成功事例もあるので、旧来のRxとの互換性に囚われず、.NET 8, C# 12という現代のC#環境に合わせて再構築された、完全に新しいRxであるべきという路線に決めました。</p>
<p>といっても、最終的にはインターフェイスにそこまで大きな違いはありません。</p>
<pre><code class="language-csharp">public abstract class Observable&lt;T&gt;
{
    public IDisposable Subscribe(Observer&lt;T&gt; observer);
}

public abstract class Observer&lt;T&gt; : IDisposable
{
    public void OnNext(T value);
    public void OnErrorResume(Exception error);
    public void OnCompleted(Result result); // Result is (Success | Failure)
}
</code></pre>
<p>パッと見だとOnErrorがOnErrorResumeになったことと、interfaceではなくてabstract classになったこと、ぐらいでしょうか。どうしても変更したかった点の一つがOnErrorで、パイプライン上で例外が起きると購読解除されるという挙動はRxにおける<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar mistake</a>だと思っています。R3では例外はOnErrorResumeに流れて、購読解除されません。かわりにOnCompletedに、SuccessまたはFailureを表すResultが渡ってくるようになっていて、こちらでパイプラインの終了が表されています。</p>
<p><code>IObservable&lt;T&gt;/IObserver&lt;T&gt;</code>の定義は<code>IEnumerble&lt;T&gt;/IEnumerator&lt;T&gt;</code>と密接に関わっていて、<a href="https://en.wikipedia.org/wiki/Duality_(mathematics)">数学的双対</a>であると称しているのですが、実用上不便なところがあり、その最たるものがOnErrorで停止することです。なぜ不便かというと、<code>IEnumerable&lt;T&gt;</code>のforeachの例外発生と<code>IObservable&lt;T&gt;</code>の例外発生では、ライフタイムが異なることに起因します。foreachの例外発生はそこでイテレーターの消化が終わり、必要があればtry-catchで処理して、大抵はリトライすることもないですが、ObservableのSubscribeは違います。イベントの購読の寿命は長く、例外発生でも停止しないで欲しいと思うことは不自然ではありません。通常のeventで例外が発生したとて停止することはないですが、Rxの場合はオペレーターチェーンの都合上、パイプライン中に例外が発生する可能性が常にあります(SelectやWhereすればFuncが例外を出す可能性がある)。イベントの代替、あるいは上位互換として考えると、例外で停止するほうが不自然になってしまいます。</p>
<p>そして、必要があればCatchしてRetryすればいい、というものではない！Rxにおいて停止したイベントを再購読するというのは非常に難しい！Observableにはeventと異なり、完了するという概念があります。完了したIObservableを購読すると即座にOnError | OnCompletedが呼ばれる、それにより自動的な再購読は、完了済みのシーケンスを再購読しにかかる危険性があります。もちろんそうなれば無限ループであり、それを判定し正しくハンドリングする術もない。Stack OverflowにはRx/Combine/FlowのUI購読で再購読するにはどうすればいいですか？のような質問が多数あり、そしてその回答は非常に複雑なコードの記述を要求していたりします。現実はRepeat/Retryだけで解決していない！</p>
<p>そこで、そもそも例外で停止しないように変更しました。OnErrorという命名のままでは従来の停止する動作と混同する可能性があるため、かわりにOnErrorResumeという名前に変えています。これで再購読に関する問題は全て解決します。更にこの変更には利点があり、停止する→停止しないの挙動変更は不可能ですが(Disposeチェーンが走ってしまうので状態を復元できないので全体の再購読以外に手段がない)、停止しない→停止するへの挙動変更は非常に簡単でパフォーマンスもよく実装できます。OnErrorResumeが来たらOnCompleted(Result.Failure)に変換するオペレーターを用意するだけですから（標準でOnErrorResumeAsFailureというオペレーターを追加してあります）。</p>
<p>Rx自体が複雑なコントラクトを持つ(OnErrorかOnCompletedはどちらか一つしか発行されない、など)わりに、インターフェースは実装上の保証がないので、従来のRxは正しく実装するのが難しいという問題がありました。SourceのSubscribeが遅延される場合は、先行して返却されるDisposableを正しくハンドリングする必要がある(SingleAssignmentDisposableを使う）などといったことも、正しく理解することは難しいでしょう。SubscribeのonNextで発生した例外はどこに行くのか、onErrorに行ってDisposeされるのか継続されるのか。その動作は特に規定されていないため実装次第で挙動はバラバラの場合もあります。R3ではasbtract class化することにより大部分のコントラクトを保証し、挙動の統一と、独自実装を容易にしました。</p>
<p>そしてabstract classにした最大の理由は、全ての購読を中央管理できるようにしたことです。全てのSubscribeは必ず基底クラスのSubscribe実装を通ります。これにより、購読のトラッキングが可能になりました。例えば以下のような形で表示できます。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/149abca5-6d84-44ea-8373-b0e8cd2dc46a" alt="image" /></p>
<blockquote>
<p>これはUnity向けの拡張Windowですが、Godot用にも存在するほか、APIとして提供しているためログに出したり任意のタイミングで取得したり、独自の可視化を作ることも可能です</p>
</blockquote>
<p>TaskにはParallel Debuggerがありますが（これもTaskが基底クラス側でs_asyncDebuggingEnabledの時に中央管理している）、Rxの購読の可視化は、それよりも遥かに重要でしょう。イベントの購読リークはつきもので、開発終盤に必死に探し回る羽目になりますが、R3ならもう不要です！圧倒的開発効率アップ！</p>
<p>R3ではこうした購読の管理、リーク防止については最重要視していて、Observable Trackerによる全ての購読の追跡の他に、概念として「全てのObservableは完了することができる」ようにしました。</p>
<p>Rxにおける購読の管理の基本はIDisposableをDisposeすることです。が、購読を解除する方法は実はそれだけではなく、OnError | OnCompletedが流れることでも解除されるようになっています（IObservableのコントラクトが保証しているわけではないですが実装上そうなっている、R3では必ずそうなるように基底クラス側で保証するようにした）。つまりシーケンスの上流(OnError | OnCompletedの発行)と下流(Dispose)、両面からハンドリングすることでリークをより確実に防ぐことができます。</p>
<p>対応として過剰に思うかもしれませんが、実際のアプリケーションを開発してきた経験からいうと、購読管理は過剰なぐらいがちょうどいい。そうした思想から、R3では、今までOnCompletedを発行する手段のなかったObservable.FromEventやObservable.Timer、EveryUpdateなども、OnCompletedを発行可能にしました。なお、発行方法はCancellationTokenを渡すことで、これもasync/await以降に多用（あるいは濫用）されるようになったCancellationTokenを活用する現代的なAPI設計です。また、こうした全てのObservableは完了する、という思想があるため、SubjectのDisposeも標準でOnCompletedを発行するように変更しました。</p>
<h2>ISchedulerを再考する</h2>
<p>Rxの時空を移動するマジックを実現する機構がISchedulerです。TimerやObserveOnに渡すことで、任意の場所(ThreadやDispatcher、PlayerLoopなど)・時間に値を移動させることができます。</p>
<pre><code class="language-csharp">public interface IScheduler
{
    DateTimeOffset Now { get; }

    IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
}
</code></pre>
<p>そして、実は破綻しています。Rxのソースコードを見たことがあるなら気づいているかもしれませんが、初期のうちから追加の別の定義が用意されています。例えばThreadPoolSchedulerは以下のようなインターフェイスを実装しています。</p>
<pre><code class="language-csharp">public interface ISchedulerLongRunning
{
    IDisposable ScheduleLongRunning&lt;TState&gt;(TState state, Action&lt;TState, ICancelable&gt; action);
}

public interface ISchedulerPeriodic
{
    IDisposable SchedulePeriodic&lt;TState&gt;(TState state, TimeSpan period, Func&lt;TState, TState&gt; action);
}

public interface IStopwatchProvider
{
    IStopwatch StartStopwatch();
}

public abstract partial class LocalScheduler : IScheduler, IStopwatchProvider, IServiceProvider
{
}

public sealed class ThreadPoolScheduler : LocalScheduler, ISchedulerLongRunning, ISchedulerPeriodic
{
}
</code></pre>
<p>そして、以下のような呼び出しがなされています。</p>
<pre><code class="language-csharp">public static IStopwatch StartStopwatch(this IScheduler scheduler)
{
    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        return swp.StartStopwatch();
    }

    return new EmulatedStopwatch(scheduler);
}

private static IDisposable SchedulePeriodic_&lt;TState&gt;(IScheduler scheduler, TState state, TimeSpan period, Func&lt;TState, TState&gt; action)
{
    var periodic = scheduler.AsPeriodic();
    if (periodic != null)
    {
        return periodic.SchedulePeriodic(state, period, action);
    }

    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        var spr = new SchedulePeriodicStopwatch&lt;TState&gt;(scheduler, state, period, action, swp);
        return spr.Start();
    }
    else
    {
        var spr = new SchedulePeriodicRecursive&lt;TState&gt;(scheduler, state, period, action);
        return spr.Start();
    }
}
</code></pre>
<p>ようは生のISchedulerを使わないケースがそれなりにあります。なぜ使われないのか、というと、パフォーマンス上の問題で、IScheduler.Scheduleは単発の実行しか定義されていなくて、複数回の呼び出しは再帰的にScheduleを呼べばいいじゃんという発想なわけですが、都度IDisposableを生成するなどパフォーマンス的に問題がある。ので、それを回避するためにISchedulerPeriodicなどが用意されたのでした。</p>
<p>それなら、もうISchedulerではなく、実態をまともに反映されたものを使ったほうがいいんじゃないか？と思ったときに出てきたのが.NET 8で追加された<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>で、これならISchedulerが行っていたことをより効率的にできることを発見しました。</p>
<pre><code class="language-csharp">public abstract class TimeProvider
{
    // use these.
    public virtual ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period);
    public virtual long GetTimestamp();
}
</code></pre>
<p>CreateTimerで生成されるITimerはISchedulerPeriodicで行える機能を十分持っているほか、ワンタイムの実行を繰り返す(<code>Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)</code>)のシナリオにおいても、ITimerを使いまわせるため、dotnet/reactiveのThreadPoolSchedulerよりも効率的です(ThreadPoolSchedulerは都度<code>new Timer()</code>している)。</p>
<p>現在時間の取得に関しては、<code>DateTimeOffset IScheduler.Now</code>のようにTimeProviderも<code>DateTimeOffset TimeProvider.GetUtcNow()</code>がありますが、使っているのは<code>long GetTimestamp</code>だけです。というのも、オペレーターの実装に必要なのはTicksだけなので、わざわざDateTimeOffsetに包むようなオーバーヘッドはないほうが良いので、生のTicksを扱って時間を計算します。</p>
<p>DateTimeOffset.UtcNowはOSのシステム時刻の変更の影響を受ける可能性もあるので、そういう点でもDateTimeOffsetを介さないGetTimestamp(標準では<code>Stopwatch.GetTimestamp()</code>からの高解像度タイマーが利用される)経由が良いでしょう。</p>
<p>ISchedulerのもう一つの問題として、同期的な処理を行う<code>ImmediateScheduler</code>や<code>CurrentScheduler</code>がいます。これらにTimerやDelayなど時間系の処理を任せるとThread.Sleepするという、使うべきではない非同期コードのエミュレーションをするので、つまり、同期的なSchedulerは存在が悪なのでないほうがいいでしょう。R3では完全に消し、TimeProviderを指定するということは必ず非同期的な呼び出しであるということを徹底しました。</p>
<p><code>ImmediateScheduler</code>や<code>CurrentScheduler</code>の問題はそれだけじゃなくて、そもそもパフォーマンスが致命的に悪いという問題があります。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/68a12664-a840-4725-a87c-8fdbb03b4a02" alt="image" /></p>
<blockquote>
<p><code>Observable.Range(1, 10000).Subscribe()</code> の結果</p>
</blockquote>
<p><code>CurrentScheduler</code>はともかく、<code>ImmediateScheduler</code>の結果が悪いのは直観に反するかもしれません。dotnet/reactiveの<code>ImmediateScheduler</code>は、Scheduleされるたびに<code>new AsyncLockScheduler()</code>し、<code>AsyncLockScheduler</code>が呼び出す基底クラス<code>LocalScheduler</code>のコンストラクターが<code>SystemClock.Register</code>し、それは<code>lock</code>し<code>new WeakReference&lt;LocalScheduler&gt;(scheduler)</code>し、<code>HashSet.Add</code>します。パフォーマンスが悪いのも当然です(ただし再帰的な呼び出し時には都度<code>SingleAssignmentDisposable</code>を生成するだけに抑えられてはいます、それでも多いですが)</p>
<p>Rangeなんてめったに使わないから大丈夫と思いきや、実は意外なところで<code>ImmediateScheduler</code>はちょくちょく使われています。代表的なのが<code>Merge</code>で、これは<code>IScheduler</code>が無指定の場合は<code>ImmediateScheduler</code>を使うため、頻繁な購読を繰り返す作りになっていると、かなりの呼び出す回数になる可能性があります。実際、dotnet/reactiveをサーバーアプリケーションで使用した際に、MergeとImmediateSchedulerが原因でサーバーのメモリ使用量のかなりを占めたことがありました。その時はカスタムの軽量なスケジューラーを作成し、直接指定することで徹底的に<code>ImmediateScheduler</code>を避けることで何とかしました。Next dotnet/reactiveがあるなら、<code>ImmediateScheduler</code>のパフォーマンスの改善は真っ先に行う必要があります。</p>
<blockquote>
<p><code>SystemClock.Register</code>をしている理由としては、<code>DateTimeOffset.UtcNow</code>とシステム時刻の変更の監視のためのようです。つまり、最初からDateTimeOffsetではなくlongを使えば、このような致命的なパフォーマンス低下も招きませんでした。これもまたISchedulerのインターフェイス定義の失敗理由の一つです。</p>
</blockquote>
<p>ところで、TimeProviderの採用によって、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.time.testing.faketimeprovider?view=dotnet-plat-ext-8.0">Microsoft.Extensions.Time.Testing.FakeTimeProvider</a>を使い、標準的な手法でユニットテストが容易になったことも嬉しいところでしょう。</p>
<h2>FrameProvider</h2>
<p>他のRxでは見かけないがUniRxで絶大な効果を発揮したものとして、フレームベースのオペレーター郡があります。一定フレーム後に実行する<code>DelayFrame</code>や次フレームで実行する<code>NextFrame</code>、毎フレーム発行するファクトリーである<code>EveryUpdate</code>や、毎フレーム値を監視する<code>EveryValueChanged</code>など、ゲームエンジンで利用するにあたって便利なオペレーターが揃っています。</p>
<p>そこで気づいたのが、時間とフレームは概念的には似たものであり、ゲームエンジンだけでなく、UI処理ではメッセージループやレンダリングループという形で、様々なフレームワークに存在している。そこで、R3では新しくTimerProviderと対になるFrameProviderという形でフレームベースの処理を抽象化しました。これによってUnityだけに提供されていたフレームベースのオペレーターが、C#が動作するあらゆるフレームワーク(WinForms, WPF, WinUI3, MAUI, Godot, Avalonia, Stride, etc...)で動作せることができるようになりました。</p>
<pre><code class="language-csharp">public abstract class FrameProvider
{
    public abstract long GetFrameCount();
    public abstract void Register(IFrameRunnerWorkItem callback);
}

public interface IFrameRunnerWorkItem
{
    // true, continue
    bool MoveNext(long frameCount);
}
</code></pre>
<p>R3ではTimeProviderを要求するオペレーターがある場合、全てに対となる***Frameオペレーターを実装しました。</p>
<ul>
<li>Return &lt;-&gt; ReturnFrame</li>
<li>Yield &lt;-&gt; YieldFrame</li>
<li>Interval &lt;-&gt; IntervalFrame</li>
<li>Timer &lt;-&gt; TimerFrame</li>
<li>Chunk &lt;-&gt; ChunkFrame</li>
<li>Debounce &lt;-&gt; DebounceFrame</li>
<li>Delay &lt;-&gt; DelayFrame</li>
<li>DelaySubscription &lt;-&gt; DelaySubscriptionFrame</li>
<li>ObserveOn(TimeProvider) &lt;-&gt; ObserveOn(FrameProvider)</li>
<li>Replay &lt;-&gt; ReplayFrame</li>
<li>Skip &lt;-&gt; SkipFrame</li>
<li>SkipLast &lt;-&gt; SkipLastFrame</li>
<li>SubscribeOn(TimeProvider) &lt;-&gt; SubscribeOn(FrameProvider)</li>
<li>Take &lt;-&gt; TakeFrame</li>
<li>TakeLast &lt;-&gt; TakeLastFrame</li>
<li>ThrottleFirst &lt;-&gt; ThrottleFirstFrame</li>
<li>ThrottleFirstLast &lt;-&gt; ThrottleFirstLastFrame</li>
<li>ThrottleLast &lt;-&gt; ThrottleLastFrame</li>
<li>Timeout &lt;-&gt; TimeoutFrame</li>
</ul>
<h2>async/await Integration</h2>
<p>まず、既存のRxにおいて良くない点である単一の値を返すObservableを徹底的に排除しました。これらはasync/awaitを使うべきで、単一の値を返したり、単一の値を期待して合成するようなオペレーターはバッドプラクティスに誘うノイズです。FirstはFirstAsyncになり、<code>Task&lt;T&gt;</code>を返します。AsyncSubjectはなくなり、TaskCompletionSourceを使ってください。</p>
<p>そのうえで、現在のC#コードは日常的に非同期のコードが返ってきます、が、基本的にはRxは同期コードしか受け取りません。うっかりすればFireAndForget状態になるし、SelectManyに混ぜるだけでは十分とはいえません。そこで、Where/Select/Subscribeに特殊なメソッド群を用意しました。</p>
<ul>
<li><strong>SelectAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;TResult&gt;&gt;</code> selector, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>WhereAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;Boolean&gt;&gt;</code> predicate, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Exception&gt;</code> onErrorResume, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
</ul>
<pre><code class="language-csharp">public enum AwaitOperation
{
    /// &lt;summary&gt;All values are queued, and the next value waits for the completion of the asynchronous method.&lt;/summary&gt;
    Sequential,
    /// &lt;summary&gt;Drop new value when async operation is running.&lt;/summary&gt;
    Drop,
    /// &lt;summary&gt;If the previous asynchronous method is running, it is cancelled and the next asynchronous method is executed.&lt;/summary&gt;
    Switch,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method.&lt;/summary&gt;
    Parallel,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method, but the results are queued and passed to the next operator in order.&lt;/summary&gt;
    SequentialParallel,
    /// &lt;summary&gt;Send the first value and the last value while the asynchronous method is running.&lt;/summary&gt;
    ThrottleFirstLast
}
</code></pre>
<p>SelectAwait, WhereAwait, SubscribeAwaitは非同期メソッドを受け取り、その非同期メソッドが実行されている間に届く値に対する処理のパターンを6パターン用意しました。Sequentialはいったんキューにためて非同期メソッドが完了したら新しい値を送ります。Dropは実行中に届いた値は全て捨てます、これはイベントハンドリングで多重Submit防止などに使えます。Switchは<code>Observable&lt;Observable&gt;.Switch</code>と同様、Parallelは並列実行するもので<code>Observable&lt;Observable&gt;.Merge</code>と同様、ですがわかりやすいでしょう。並列実行数も指定できます。SequentialParallelは並列実行しつつ、後続に流す値は届いた順序で保証します。ThrottleFirstLastは非同期メソッド実行中の最初の値と最後の値を送ります。</p>
<p>更に、以下の時間系のフィルタリングメソッドなども非同期メソッドを受け取るようになっています。</p>
<ul>
<li><strong>Debounce</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> throttleDurationSelector, ...)</li>
<li><strong>ThrottleFirst</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
<li><strong>ThrottleLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
<li><strong>ThrottleFirstLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
</ul>
<p>また、Chunkも同様に非同期メソッドを受け取るほか、SkipUntilには非同期メソッドと、Task, CancellationTokenを受け取れるようになっています。</p>
<ul>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>CancellationToken</code> cancellationToken)</li>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Task</code> task)</li>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> asyncFunc, ...)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>CancellationToken</code> cancellationToken)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Task</code> task)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> asyncFunc, ...)</li>
<li><strong>Chunk</strong>(this Observable<T> source, Func&lt;T, CancellationToken, ValueTask&gt; asyncWindow, ...)</li>
</ul>
<p>例えばChunkの非同期関数版を使えば、固定時間ではなくてランダム時間でチャンクを生成するといった複雑な処理を、自然に簡単に書けるようになります。</p>
<pre><code class="language-csharp">Observable.Interval(TimeSpan.FromSeconds(1))
    .Index()
    .Chunk(async (_, ct) =&gt;
    {
        await Task.Delay(TimeSpan.FromSeconds(Random.Shared.Next(0, 5)), ct);
    })
    .Subscribe(xs =&gt;
    {
        Console.WriteLine(string.Join(&quot;, &quot;, xs));
    });
</code></pre>
<p>async/awaitは現代のC#に欠かせないコードですが、可能な限りスムーズにRxと統合されるように腐心しました。</p>
<p>Retry関連もasync/awaitを活用することで、よりベターなハンドリングができます。まず、以前のRxはパイプライン丸ごとのリトライしか出来ませんでしたが、async/awaitを受け入れられるR3なら、非同期メソッド実行単位でのリトライができます。</p>
<pre><code class="language-csharp">button.OnClickAsObservable()
    .SelectAwait(async (_, ct) =&gt;
    {
        var retry = 0;
    AGAIN:
        try
        {            
            var req = await UnityWebRequest.Get(&quot;https://google.com/&quot;).SendWebRequest().WithCancellation(ct);
            return req.downloadHandler.text;
        }
        catch
        {
            if (retry++ &lt; 3) goto AGAIN;
            throw;
        }
    }, AwaitOperation.Drop)
    .SubscribeToText(text);
</code></pre>
<p>Repeatもasync/awaitと組み合わせることで実装できます。この場合、Repeatの条件に関する複雑なハンドリングがRxだけで完結させるよりも、容易にできるでしょう。</p>
<pre><code class="language-csharp">while (!ct.IsCancellationRequested)
{
    await button.OnClickAsObservable()
        .Take(1)
        .ForEachAsync(_ =&gt;
        {
            // do something
        });
}
</code></pre>
<p>手続き的なコードは決して悪いことではないですし、場合によりRxのオペレーターだけで完結させるよりも可読性が高くなります。コーディングにおいて優先すべきは可読性の高さ（とパフォーマンス）です。より良いコードのためにも、Rxとasync/awaitをうまく連携させていきましょう。</p>
<p>CreateやCreateFromなどで、非同期メソッドからObservableを生成することもできます。ここから生成することで、オペレーターを無理やりこねくり回すよりも簡潔に記述することが可能かもしれません。</p>
<ul>
<li><code>Create(Func&lt;Observer&lt;T&gt;, CancellationToken, ValueTask&gt; subscribe, ...)</code></li>
<li><code>CreateFrom(Func&lt;CancellationToken, IAsyncEnumerable&lt;T&gt;&gt; factory)</code></li>
</ul>
<h2>名前付けのルール</h2>
<p>R3では幾つかのメソッドの名前がdotnet/rectiveやUniRxから変更されています。例えば以下のものです。</p>
<ul>
<li><code>Buffer</code> -&gt; <code>Chunk</code></li>
<li><code>StartWith</code> -&gt; <code>Prepend</code></li>
<li><code>Distinct(selector)</code> -&gt; <code>DistinctBy</code></li>
<li><code>Throttle</code> -&gt; <code>Debounce</code></li>
<li><code>Sample</code> -&gt; <code>ThrottleLast</code></li>
</ul>
<p>この変更の理由について説明しましょう。</p>
<p>まず、.NETにおいてLINQスタイルのライブラリを作成する場合に最優先すべき名前はLINQ to Objects(Enumerable)に実装されているメソッド名です。<code>Buffer</code>がなぜ<code>Chunk</code>に変更されたかというと、.NET 6からEnumerable.Chunkが追加され、その機能がBufferと同じだからです。RxのほうがChunkの登場より遥か前なので、名前が違うのはどうにもならないのですが、何のしがらみもないのなら名称はLINQ to Objectsに合わせなければならない。よって、Chunk一択です。PrependやDistinctByも同様です。</p>
<p><code>Throttle</code>が<code>Debounce</code>に変更されたことには抵抗があるかもしれません。これは、そもそも世の中のスタンダードは<code>Debounce</code>だからです。Rx系で<code>Debounce</code>を<code>Throttle</code>という名前でやってるのはdotnet/reactiveだけです。世の中のRxの始祖はRxNetなのだから変えなきゃいけない謂われはない、と突っぱねることも正義ではあるんですが、もはや多勢に無勢の少数派なので、長いものに巻かれることもまた正しい。</p>
<p><code>Debounce</code>に変えた理由はそれだけではなく、<code>ThrottleFirst</code> / <code>ThrottleLast</code>の存在もあります。これらはサンプリング期間の最初の値を採用する、または最後の値を採用する、というもので対になっています。で、(dotnet/reactiveの)Throttleは全然違う挙動なわけです、なのにThrottleという名前は混乱するでしょう。そももそもdotnet/reactiveにはThrottleFirstが存在せず、ThrottleLastに相当するSampleのみが存在するので大丈夫なのですが、ThrottleFirst/ThrottleLastを採用するなら、必然的に名前は<code>Debounce</code>にせざるを得ません。どちらかというとdotnet/reactiveの機能不足が悪い。</p>
<p><code>Sample</code>に関してはFirst/Lastという名前と機能の対称性から<code>ThrottleLast</code>という名前に変更しました。dotnet/reactiveではFirstが存在しないのでSampleでも良かったのですが、<code>ThrottleFirst</code>を採用するなら、必然的に名前は<code>ThrottleLast</code>になります。</p>
<p><code>Sample</code>の名前は残して<code>ThrottleLast</code>のエイリアスにするという折衷案もあるのですが(RxJavaなどはそうなっています)、同じ機能の別名があるとユーザーは混乱します。世の中には<code>sample</code>と<code>throttleLast</code>の違いってなんですか？みたいな質問がそれなりにあります。ただでさえ複雑なRx、無用な混乱を避けるためにもエイリアスは絶対にやめるべき。SelectをMap、WhereをFilterにマッピングするみたいなエイリアスは愚かの極みです。</p>
<h2>プラットフォーム向けデフォルトスケジューラー</h2>
<p>dotnet/reactiveにおいてデフォルトのスケジューラーはほとんど固定です。正確には<code>IPlatformEnlightenmentProvider</code>や<code>IConcurrencyAbstractionLayer</code>というのものを適切に実装すれば、ある程度挙動を差し替えることも可能なのですが、無駄に複雑なうえに<code>[EditorBrowsable(EditorBrowsableState.Never)]</code>で隠されているしで、まともに使うことはほとんど想定されていないように見えます。</p>
<p>しかし、TimerやDelayなどはWPFであればDispatcherTimerで、UnityではPlayerLoop上のTimerで動くと、自動的にメインスレッドにディスパッチしてくれるので、ほとんどの場合でObserveOnが不要になるので便利ですしパフォーマンス上も有利に働きます。</p>
<p>R3ではシンプルにデフォルトのTimeProvider/FrameProviderを差し替えられるようにしました。</p>
<pre><code class="language-csharp">public static class ObservableSystem
{
    public static TimeProvider DefaultTimeProvider { get; set; } = TimeProvider.System;
    public static FrameProvider DefaultFrameProvider { get; set; } = new NotSupportedFrameProvider();
}
</code></pre>
<p>アプリケーション起動時に差し替えれば、そのアプリケーション上でベストなスケジューラーがデフォルト利用されます。</p>
<pre><code class="language-csharp">// 例えばWPFの場合はDispatcher系がセットされるので自動的にUIスレッドに戻ってくる
public static class WpfProviderInitializer
{
    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new WpfDispatcherTimerProvider();
        ObservableSystem.DefaultFrameProvider = new WpfRenderingFrameProvider();
    }
}

// Unityの場合はPlayerLoopベースのものが使用されるのでThreadPoolを避けれる
public static class UnityProviderInitializer
{
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
    public static void SetDefaultObservableSystem()
    {
        SetDefaultObservableSystem(static ex =&gt; UnityEngine.Debug.LogException(ex));
    }

    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = UnityTimeProvider.Update;
        ObservableSystem.DefaultFrameProvider = UnityFrameProvider.Update;
    }
}
</code></pre>
<p>dotnet/reactiveがデフォルトスケジューラーを変更できないのは、あまり、多種のプラットフォームをサポートしているとは言い難いでしょう。</p>
<pre><code class="language-csharp">internal static class SchedulerDefaults
{
    internal static IScheduler ConstantTimeOperations =&gt; ImmediateScheduler.Instance;
    internal static IScheduler TailRecursion =&gt; ImmediateScheduler.Instance;
    internal static IScheduler Iteration =&gt; CurrentThreadScheduler.Instance;
    internal static IScheduler TimeBasedOperations =&gt; DefaultScheduler.Instance;
    internal static IScheduler AsyncConversions =&gt; DefaultScheduler.Instance;
}
</code></pre>
<p>特にAOTのシナリオやWeb向けパブリッシュ(WASM)では、ThreadPoolが使えなくて絶対に避けたいという状況もあります。そこでSchedulerDefaults.TimeBasedOperationsが実質ThreadPoolSchedulerに固定されているのは厳しいと言わざるを得ません。</p>
<h2>Pull IAsyncEnumerable vs Push Observable</h2>
<p><code>IAsyncEnumerable</code>(またはUniTaskの<code>IUniTaskAsyncEnumerable</code>)は、Pullベースの非同期シーケンス。RxはPushベースの非同期シーケンス。似てます。LINQ的なことができるのも似てます。どちらを使うべきかがケースバイケースなのは当然だとして、じゃあそのケースってのはなんなのか、いつどちらを使えばいいのか。という判断基準は欲しいところです。</p>
<p>基本的には裏にバッファー（キュー）があるものはPullベースが向いていると思うので、ネットワーク系のシナリオなんかは<code>IAsyncEnumerable</code>を使っていくといいんじゃないでしょーか。で、実際、<code>System.IO.Pipelines</code>や<code>System.Threading.Channels</code>によって自然と使う機会が出てきます。</p>
<p>Rxを使うべきところは、やはりイベント関連です。</p>
<p>どちらを使うべきかの判断の決め手は、源流のソースにとって自然な表現を選ぶべき、ということです。生のイベント、OnMoveであったりOnClickであったりなどは、完全にPushで、そこにバッファーはありません。ということは、Rxで扱うほうが自然です。間にキューを挟んで<code>IAsyncEnumerable</code>で扱うこともできますが、不自然ですよね。あるいはキューを介さないことにより意図的に値をDropするという表現をすることもできますが、やはりそれも不自然です。不自然ということはたいていはパフォーマンスも良くないし、分かりやすくもない。つまり、良くない。だから、イベント関連はRxで扱いましょう。R3ならasync/awaitとの統合によって、非同期処理中のバッファリングや値のドロップなどは明示的にオペレーターで指定することができます。それは、分かりやすく、パフォーマンスも良い。R3を使っていきましょう。</p>
<h2>C#パフォーマンス勉強会</h2>
<p>ところで4/27に<a href="https://cs-reading.connpass.com/event/309714/">C#パフォーマンス勉強会</a>という勉強会が大阪で（大阪で！）開催されます。私は「R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例」というタイトルで、R3の！実装の！パフォーマンス上の工夫を！徹底的に解説しようと思っているので、参加できる方はぜひぜひです。関西へは滅多に行かないので貴重な機会ということなのでよろしくお願いします！</p>
<h2>まとめ</h2>
<p>色々言いましたが、オリジナルのRx.NETの作者達には感謝しかありません。改めて、やはりRxのアイディアの素晴らしさや、各種オペレーターの整理された機能には目を見張るものがあります。幾つかの部分の実装は古くなってしまっていますが、実装クオリティも高いと思います。私自身も最初期から使ってきたし、熱狂してきました。そして、現在のメンテナーにも感謝します。常に変わっていく環境の中で、多く使われているライブラリを維持することはとても大変なことです。</p>
<p>しかし、だからこそ、Rxの価値を復活させたかった。そして、再構築するならば、できるのは私しかいないと思った。最初期からのRxの歴史と実装を知っていて、自分でRxそのものの実装(UniRx)を行い、それが世の中に広く使われることで多くのユースケースや問題点を知り、自分自身もゲームタイトルの実装で大規模に使われるRxのアプリケーション側にも関わり、Rxと対となるasync/awaitの独自ランタイム(UniTask)を実装し、それも世の中に広く使われていることで、この領域に関してのあらゆる知見がある。</p>
<p>上のほうでも言いましたが、未来は複数あってもいいので、私が示すRxの未来の一つがR3だと思ってもらえればよいです。dotnet/reactiveにもまた別の進化と未来がある。かもしれません。</p>
<p>そのうえでR3は置き換えられるだけのポテンシャルと、可能性を見せることができたと思っています。実装には自信あり、です。今回UniRxの実績があったからというのもあり、プレビュー公開時から多くのフィードバックがもらえたことは嬉しかったです(UniTask初公開時は、Unityのコンパイラを実験的コンパイラに差し替える必要があるとかいうエクストリーム仕様だったせいか、しばらくの間は誰も使ってくれなかったというか意義を分かってくれなかったので……）。</p>
<p>移行に関するシナリオも最大限配慮したつもりではあるので、是非使ってみてください……！</p>
</div>
<h1><a href="https://neue.cc/2024/01/15_shareprojectinunity.html">.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法</a></h1>
<ul class="date"><li>2024-01-15</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnionのv6</a>が先日リリースされました。</p>
<p>メジャーバージョンアップとして大きな違いは、<a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a>を正式リリースし、これを通信層の標準ライブラリ化しました。インストール手順も複雑で、サポートも切れていたgRPC C-Coreとはさようならです。正式リリースにあたってプレビューに存在していたクラッシュ問題などが解消されています。</p>
<p>もう一つはクライアント生成においてコマンドラインツールが削除され、Source Generatorベースになりました。</p>
<pre><code class="language-csharp">[MagicOnionClientGeneration(typeof(MyApp.Shared.Services.IGreeterService))]
partial class MagicOnionGeneratedClientInitializer {}
</code></pre>
<p>これだけでコンパイル時にジェネレートされます。コマンドラインツールには、インストールしている.NETのバージョンによって動作したりしなかったりや、生成ファイルの管理をどうするかや、ビルドプロセスの複雑化など、問題が多くありましたがSource Generator化によって全て解決しました。</p>
<p>残念ながらまだMessagePack for C#がコマンドラインツールを必要としているため、完全なコマンドラインツール不要化には至っていませんが、そちらの改善も着手中のため、近いうちにはアプリケーション全体の完全なSource Generator化が果たせるのではないかと思います。それに合わせて<a href="https://github.com/Cysharp/MasterMemory/">Cysharp/MasterMemory</a>のSource Generator化も行いたいと思っています。</p>
<h2>.NETプロジェクトとUnityプロジェクト間でのコード共有</h2>
<p>MagicOnionに限らずですが、.NETとUnityとの間でソースコードをどのように共有すればいいのか問題があります。昔のやり方では、Unity側で実態を持っていて.NET側で参照を拾ってくるとか、.NET側のビルド時にUnity側にコピーをばらまく、シンボリックリンクで参照する、などといった方法を提案していたのですが、すべて正直イマイチでした。</p>
<p>というわけで令和最新版の方法を紹介します。先に結論をいうと、.NET側に普通の共有用クラスライブラリプロジェクトを作って、Unity側ではUPMのローカルパッケージ参照でソースコードを引っ張ってくるのが現状のベストだと考えています。ただしそのままやると幾つか面倒なことが発生するので、しっかりした手順をここに書いておきます。</p>
<p>まずは.NET側のプロジェクトとして、.NET Standard 2.0/2.1, LangVersion 9のクラスライブラリプロジェクトを作ります。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/0019a2b0-ec2c-4786-9d1d-0078e8dc0295" alt="image" /></p>
<p>そして<code>Directory.Build.props</code>を配置します。これは複数のcsprojにまたがって共有した設定が行えるやつなのですが、今回は単独のcsprojに適用する場合にも使います。そんな<code>Directory.Build.props</code>の中身はこれです。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- Unity ignores . prefix folder --&gt;
    &lt;ArtifactsPath&gt;$(MSBuildThisFileDirectory).artifacts&lt;/ArtifactsPath&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>最新手法と銘打った理由として.NET 8(以降に同梱されてるコンパイラ)は<a href="https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output">成果物の出力レイアウトを変更する</a>ことができるようになりました。なぜこれが必要かというと、通常、ビルドするとbin, objがcsprojのディレクトリに吐かれるわけですが、Unityでパッケージ参照するとそのbin, objまで取り込んでしまって大問題なんですね。ArtifactsPathを設定することでbin, objの出力場所を変更できます、そして<a href="https://docs.unity3d.com/Manual/SpecialFolders.html">Unityのアセットインポートにおける命名規則</a>のうち<code>.</code>か<code>~</code>で始まってるファイルまたはフォルダは無視されます。というわけで、bin, objの出力場所を<code>.artifacts</code>に変えることで、Unityから参照しても問題ない構成になりました。</p>
<p>もう少し作業が必要で、次にcsprojを開いて、以下の行を追加しておきます。</p>
<pre><code class="language-csharp">&lt;ItemGroup&gt;
  &lt;None Remove=&quot;**\package.json&quot; /&gt;
  &lt;None Remove=&quot;**\*.asmdef&quot; /&gt;
  &lt;None Remove=&quot;**\*.meta&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>これは、Unityからパッケージ参照すると.metaが大量にばらまかれてウザいので、少なくともcsprojの見た目からは消しておきます。package.jsonとasmdefも同様に.NETプロジェクトとしては不要なので管理外へ。</p>
<p>というわけで最後に、package.jsonとasmdefをこのディレクトリに置いておきましょう。これがないとUnity側から正しく参照できないので。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/54c9564d-c6f2-44ec-b86c-bec19ecfb040" alt="image" /></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;displayName&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;description&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;unity&quot;: &quot;2019.1&quot;
}
</code></pre>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;ChatApp.Shared.Unity&quot;,
    &quot;references&quot;: [
        &quot;MessagePack&quot;,
        &quot;MagicOnion.Abstractions&quot;
    ],
    &quot;optionalUnityReferences&quot;: [],
    &quot;includePlatforms&quot;: [],
    &quot;excludePlatforms&quot;: [],
    &quot;allowUnsafeCode&quot;: false,
    &quot;overrideReferences&quot;: false,
    &quot;precompiledReferences&quot;: [],
    &quot;autoReferenced&quot;: true,
    &quot;defineConstraints&quot;: []
}
</code></pre>
<p>referencesとかはお好きな感じで。</p>
<p>これでほぼ準備は完了です！とはもうUnity側ではPackage Managerを開いてAdd package from diskで先ほどの共有プロジェクトのディレクトリを指定すればOK。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/a46813ab-72fb-44b3-ac8e-241451f9128f" alt="image" /></p>
<p>ただし、これで参照すると絶対パスが書かれているので、<code>manifest.json</code>を開いて相対パスに手動で書き換えましょう。</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;: &quot;file:../../ChatApp.Shared&quot;,
  }
}
</code></pre>
<p>これでいい具合に取り扱うことができました！</p>
<p><img src="https://github.com/Cysharp/R3/assets/46207/ed8c1d20-fd8a-4e6c-afe5-2350d3fa2860" alt="image" /></p>
<p>さらに一歩進んで、サーバー側のslnでUnity側のcsprojも一緒に管理したいんだよなあ、とかやりたい場合は<a href="https://github.com/Cysharp/SlnMerge/">Cysharp/SlnMerge</a>を使うとよいでしょう。</p>
<p><img src="https://github.com/Cysharp/SlnMerge/assets/46207/6b70bfda-5f80-42c0-9acc-ca3922f22c52" alt="image" /></p>
<p>単一slnで管理すると、Unity側での作業時に共有プロジェクトのコードを弄りやすくなりますし、サーバー/クライアントを超えたデバッグのステップ実行ができるようになるなど、かなり作りやすくなるので、あわせて是非設定しておくことをお薦めします。</p>
<h2>Unity用ライブラリのNuGet配布のための開発時環境設定</h2>
<p>先日<a href="https://github.com/Cysharp/R3/">R3</a>というUniRxの進化版みたいなのをリリースしましたが、これはコアライブラリはNuGetで配布するようにしました。ちょっと前まで私はNuGet配布に関して否定的で、Unity向けにはソースコードをちゃんと配らないと、みたいに思ってたんですが、今はNuGet配布にたいして超ポジティブです。というか、逆にNuGet配布じゃないとマズいような状況もあるので、今後のものは全てNuGet配布にするほか、既存のものも随時NuGet配布に切り替えると思います。まずはMessagePack for C#が近いうちにそうなります……！</p>
<p>それはいいんですが、Unity用に開発している際に.NETライブラリとして作られているコードを参照したい、んですよね、というか参照できないとUnity向け拡張(R3.Unity)が作れないし。</p>
<p>で、じゃあ上のやり方みたいローカルパッケージ参照でソースコードを持ってきてやろう、と思ったんですが、ダメでした。というのもR3の本体はC# 12で書かれていたのだ……！DLLとして配布するので別に言語バージョンは問題ない(コンパイルしてIL化すると.NETのバージョンは関係ありますが言語バージョンは関係なくなる)ので、Unityで使うことが前提ながら普通にC# 12で書いていたので、ソースコードとしての参照はできない。</p>
<p>ビルド時の成果物をUnity側にコピーするようにしても、まぁいいっちゃあいいんですが、作業中のちょっと書き換える度にコミットされるのでリポジトリが無駄に膨らむから嫌だなー、と。</p>
<p>で、そこで、やはりローカルパッケージ参照です。ただし今回は<code>package.json</code>のみで、asmdefは配りません。そして<code>bin/Debug/netstandard2.0</code>(2.1でもいい)にpackage.jsonを置いて、package.jsonとpackage.json.metaのみgitの管理下に置きます。</p>
<p>実際のリポジトリ: <a href="https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0">https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0</a></p>
<p>手元のフォルダの状況:<br />
<img src="https://github.com/Cysharp/MagicOnion/assets/46207/2c8f7cb4-08ea-459c-abcc-6a251a063cb2" alt="image" /></p>
<p>これを同じようにローカルパッケージ参照すると、開発用のdllだけをUnityに引っ張ってくることができました。別にパッケージの中にソースコードがなくてもいいわけですね……！</p>
<p>なお、普通のゲーム開発でもC# 12で書きたいんだよー、という人は、ソースコード参照じゃなくてこっちのやり方を使っても成立はします。全然、アリです。ただし、.NET側でビルドしないと反映されないとか、デバッグビルドとリリースビルドどっち参照させます？とかいうところを考えなきゃいけないので、まぁお好みで、というところでしょうか。</p>
<h2>まとめ</h2>
<p>というわけで、2024年になってようやく満足いく共有手法にたどり着けました。これはC#大統一理論元年……！</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
