<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2024</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2024-12-16" data-pagefind-meta="published:2024-12-16"><a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html">ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など</a></h1>
<ul class="date"><li>2024-12-16</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a> v5の比較的アップデートをしました！v5自体の詳細は以前に書いた<a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html">ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク</a>を参照ください。v5はかなり面白いコンセプトになっていて、そして支持されたと思っているのですが、幾つか使い勝手を犠牲にした点があったので、今回それらをケアしました。というわけで使い勝手がかなり上がった、と思います……！</p>
<h2>名前の自動変換を無効にする</h2>
<p>コマンドネームとオプションネームは、デフォルトでは自動的にkebab-caseに変換されます。これはコマンドラインツールの標準的な命名規則に従うものですが、内部アプリケーションで使うバッチファイルの作成に使ったりする場合などには、変換されるほうが煩わしく感じるかもしれません。そこで、アセンブリ単位でオフにする機能を今回追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using ConsoleAppFramework;

[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]

var app = ConsoleApp.Create();
app.Add&lt;MyProjectCommand&gt;();
app.Run(args);

public class MyProjectCommand
{
    public void Execute(string fooBarBaz)
    {
        Console.WriteLine(fooBarBaz);
    }
}
</code></pre>
<p><code>[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]</code>によって自動変換が無効になります。この例では <code>ExecuteCommand --fooBarBaz</code> がコマンドとなります。</p>
<p>実装面でいうと、Source Generatorにコンフィグを与えるのはAdditionalFilesにjsonや独自書式のファイル(例えばBannedApiAnalyzersのBannedSymbols.txt)を置くパターンが多いですが、ファイルを使うのは結構手間が多くて面倒なんですよね。boolの1つや2つを設定するぐらいなら、アセンブリ属性を使うのが一番楽だと思います。</p>
<p>実装手法としては<code>CompilationProvider</code>から<code>Assembly.GetAttributes</code>で引っ張ってこれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var generatorOptions = context.CompilationProvider.Select((compilation, token) =&gt;
{
    foreach (var attr in compilation.Assembly.GetAttributes())
    {
        if (attr.AttributeClass?.Name == &quot;ConsoleAppFrameworkGeneratorOptionsAttribute&quot;)
        {
            var args = attr.NamedArguments;
            var disableNamingConversion = args.FirstOrDefault(x =&gt; x.Key == &quot;DisableNamingConversion&quot;).Value.Value as bool? ?? false;
            return new ConsoleAppFrameworkGeneratorOptions(disableNamingConversion);
        }
    }

    return new ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion: false);
});
</code></pre>
<p>これを他のSyntaxProviderからのSourceとCombineしてやれば、生成時に属性の値を参照できるようになります。</p>
<h2>ConfigureServices/ConfigureLogging/ConfigureConfiguration</h2>
<p>ゼロディペンデンシーを掲げている都合上、特定のライブラリに依存したコードを生成することができないという制約がConsoleAppFramework v5にはありました。そのため、DIとの統合時に自分でServiceProviderをビルドしなければならないなの、利用には一手間必要でした。そこで、NuGetでのDLLの参照状況を解析し、<code>Microsoft.Extensions.DependencyInjection</code>が参照されていると、<code>ConfigureServices</code>メソッドが<code>ConsoleAppBuilder</code>から使えるという実装を追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create()
    .ConfigureServices(service =&gt;
    {
        service.AddTransient&lt;MyService&gt;();
    });

app.Add(&quot;&quot;, ([FromServices] MyService service, int x, int y) =&gt; Console.WriteLine(x + y));

app.Run(args);
</code></pre>
<p>これによりフレームワークそのものはゼロディペンデンシーでありながら、ライブラリ依存のコードも生成することができるという、新しい体験を提供します。これは<code>MetadataReferencesProvider</code>から引っ張ってきて生成処理に回すことで実現しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var hasDependencyInjection = context.MetadataReferencesProvider
    .Collect()
    .Select((xs, _) =&gt;
    {
        var hasDependencyInjection = false;

        foreach (var x in xs)
        {
            var name = x.Display;
            if (name == null) continue;

            if (!hasDependencyInjection &amp;&amp; name.EndsWith(&quot;Microsoft.Extensions.DependencyInjection.dll&quot;))
            {
                hasDependencyInjection = true;
                continue;
            }

            // etc...
        }

        return new DllReference(hasDependencyInjection, hasLogging, hasConfiguration, hasJsonConfiguration, hasHost);
    });

context.RegisterSourceOutput(hasDependencyInjection, EmitConsoleAppConfigure);
</code></pre>
<p>参照の解析は複数のものに対して行っていて、他にも<code>Microsoft.Extensions.Logging</code>が参照されていれば<code>ConfigureLogging</code>が使えるようになります。なので<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>と組み合わせれば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: ZLogger
var app = ConsoleApp.Create()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&quot;log.txt&quot;);
    });

app.Add&lt;MyCommand&gt;();
app.Run(args);

// inject logger to constructor
public class MyCommand(ILogger&lt;MyCommand&gt; logger)
{
    public void Echo(string msg)
    {
        logger.ZLogInformation($&quot;Message is {msg}&quot;);
    }
}
</code></pre>
<p>といったように、比較的すっきりと設定が統合できます。</p>
<p><code>appsettings.json</code>から設定ファイルを引っ張ってくるというのも最近では定番パターンですが、これも<code>Microsoft.Extensions.Configuration.Json</code>を参照していると<code>ConfigureDefaultConfiguration</code>が使えるようになり、これは<code>SetBasePath(System.IO.Directory.GetCurrentDirectory())</code>と<code>AddJsonFile(&quot;appsettings.json&quot;, optional: true)</code>を自動的に行います（追加でActionでconfigureすることも可能、また、ConfigureEmptyConfigurationもあります）。</p>
<p>なのでコンフィグを読み込んでクラスにバインドしてコマンドにDIで渡す、などといった処理もシンプルに書けるようになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: Microsoft.Extensions.Configuration.Json
var app = ConsoleApp.Create()
    .ConfigureDefaultConfiguration()
    .ConfigureServices((configuration, services) =&gt;
    {
        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions
        services.Configure&lt;PositionOptions&gt;(configuration.GetSection(&quot;Position&quot;));
    });

app.Add&lt;MyCommand&gt;();
app.Run(args);

// inject options
public class MyCommand(IOptions&lt;PositionOptions&gt; options)
{
    public void Echo(string msg)
    {
        ConsoleApp.Log($&quot;Binded Option: {options.Value.Title} {options.Value.Name}&quot;);
    }
}
</code></pre>
<p><code>Microsoft.Extensions.Hosting</code>でビルドしたい場合は、<code>ToConsoleAppBuilder</code>が、これも<code>Microsoft.Externsions.Hosting</code>を参照すると追加されるようになっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: Microsoft.Extensions.Hosting
var app = Host.CreateApplicationBuilder()
    .ToConsoleAppBuilder();
</code></pre>
<p>また、今回から設定されている<code>IServiceProvider</code>は<code>Run</code>または<code>RunAsync</code>終了後に自動的にDisposeするようになりました。</p>
<h2>RegisterCommands from Attribute</h2>
<p>コマンドの追加は<code>Add</code>または<code>Add&lt;T&gt;</code>が必要でしたが、クラスに属性を付与することで自動的に追加される機能をいれました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[RegisterCommands]
public class Foo
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}

[RegisterCommands(&quot;bar&quot;)]
public class Bar
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}
</code></pre>
<p>これらは自動で追加されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create();

// Commands:
//   baz
//   bar baz
app.Run(args);
</code></pre>
<p>これらとは別に追加で<code>Add</code>, <code>Add&lt;T&gt;</code>することも可能です。</p>
<p>なお、実装の当初予定では任意の属性を使えるようにする予定だったのですが、<code>IncrementalGenerator</code>のAPIの都合上難しくて、固定の<code>RegisterCommands</code>属性のみを対象としています。また、継承することもできません……。なので独自の処理用属性がある場合は、組み合わせてもらう必要があります。例えば以下のように。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[RegisterCommands, Batch(&quot;0 10 * * *&quot;)]
public class MyCommands
{
}
</code></pre>
<p>この辺は<a href="https://qiita.com/omt_teruki/items/dae315c7e86722fe05e6">ConsoleAppFrameworkとAWS CDKで爆速バッチ開発</a>を読んで、うーん、v5を使ってもらいたい！なんとかしたい！と思って色々考えたのですが、この辺が現状の限界でした……。名前変換オフりたいのもわかるー、とか今回の更新内容はこの記事での利用例を参考にさせていただきました、ありがとうございます！</p>
<h2>まとめ</h2>
<p>v5のリリース以降もフィルターを外部アセンブリに定義できるようになったり、Incremental Generatorの実装を見直して高速化するなど、Improvmentは続いています！非常に良いフレームワークに仕上がってきました！</p>
<p>ところで<a href="https://github.com/dotnet/command-line-api/">System.CommandLine</a>、現状うまくいってないから<a href="https://github.com/dotnet/command-line-api/issues/2338">Resettting System.CommandLine</a>だ！と言ったのが今年の3月。例によって想像通り進捗は無です。知ってた。そうなると思ってた。何も期待しないほうがいいし、普通にConsoleAppFramework使っていくで良いでしょう。</p>
</div>
<h1 data-pagefind-sort="date:2024-12-06" data-pagefind-meta="published:2024-12-06"><a href="https://neue.cc/2024/12/06_MessagePack_v3.html">SourceGenerator対応のMessagePack for C# v3リリースと今後について</a></h1>
<ul class="date"><li>2024-12-06</li></ul>
<div class="entry_body"><p>先月<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#プロジェクト</a>は <a href="https://dotnetfoundation.org/">.NET Foundation</a>に参加しました！より安定した視点で利用していただけるという一助になればいいと思っています。</p>
<p>そして、長く開発を続けていたメジャーバージョンアップ、v3がリリースされました。コア部分はv2とはほぼ変わらずですが、Source Generatorを全面的に導入しています。引き続きIL動的生成も存在するため、IL動的生成とSource Generatorのハイブリッドなシリアライザーとなります。v3にはSource GeneratorとAnalyzerがビルトインで同梱されていて、今までのコードはv3でコンパイルするだけで自動的にSource Generator化されます。v2 -&gt; v3アップデートでSource Generator対応するために追加でユーザーがコードを記述する必要はありません！</p>
<p>挙動を詳しく見ていきましょう。例えば、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject]
public class MyTestClass
{
    [Key(0)]
    public int MyProperty { get; set; }
}
</code></pre>
<p>というコードを書くと、自動的に以下のコードがSource Generatorによって内部的に生成されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">partial class GeneratedMessagePackResolver
{
    internal sealed class MyTestClassFormatter : IMessagePackFormatter&lt;MyTestClass&gt;
    {
        public void Serialize(ref MessagePackWriter writer, MyTestClass value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.MyProperty);
        }

        public MyTestClass Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var ____result = new MyTestClass();

            for (int i = 0; i &lt; length; i++)
            {
                switch (i)
                {
                    case 0:
                        ____result.MyProperty = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            reader.Depth--;
            return ____result;
        }
    }
}
</code></pre>
<p>また、このGeneratedMessagePackResolverはデフォルトのオプション(StandardResolverなど)に最初から登録されているため、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static readonly IFormatterResolver[] DefaultResolvers = [
    BuiltinResolver.Instance,
    AttributeFormatterResolver.Instance,
    SourceGeneratedFormatterResolver.Instance, // here
    ImmutableCollection.ImmutableCollectionResolver.Instance,
    CompositeResolver.Create(ExpandoObjectFormatter.Instance),
    DynamicGenericResolver.Instance, // only enable for RuntimeFeature.IsDynamicCodeSupported
    DynamicUnionResolver.Instance];
</code></pre>
<p>ユーザーコードのアセンブリに含まれているシリアライズ対象クラスは、Source Generatorによって生成されたコードが優先的に使われることになります。GeneratedMessagePackResolverは既定の名前空間や名前を変えたり、生成フォーマッターをmapベースに変更するなど、幾つかのカスタマイズポイントも用意されています。より詳しくは新しいドキュメントを見てください。また、v2 -&gt; v3の変更箇所の詳細を知りたい人は<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/develop/doc/migrating_v2-v3.md">Migration Guide v2 -&gt; v3</a>をチェックしてください。</p>
<p>Unityにおいては導入方法が大きく変わりました。コアライブラリは .NET 版と共通になりNuGetからのインストールが必要となります。そのうえでUPMでUnity用の追加コードをダウンロードする必要があります。詳しくは<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/#unity-support">MessagePack-CSharp#unity-support</a>のセクションを確認してください。</p>
<p>.unitypackageの提供は廃止されています。また、IL2CPP対応のために要求していたmpcはなくなりました。完全にSource Generatorに移行されます。そのため、Unityのサポートバージョンは <code>2022.3.12f1</code> からとなります。Source Generatorに関してはNuGetForUnityでのコアライブラリインストール時に自動的に有効化されるため、追加の作業は必要ありません。</p>
<h2>History and Next</h2>
<p>MessagePack for C#のオリジナル(v1)は私(Yoshifumi Kawai/@neuecc)によって、2017年にリリースしました。当時開発していたゲームのパフォーマンス問題を解決するために、2016年時点で存在していた(バイナリ)シリアライザーでは需要を満たせなかったため、パフォーマンスを最重要視したバイナリシリアライザーとして作成しました。合わせて、同じくネットワークシステムとして作成したgRPCベースのRPCフレームワーク<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>もリリースしています。</p>
<p>v1リリース当時は<code>byte[]</code>のみを対象としていましたが、<code>Span&lt;T&gt;</code>や<code>IBufferWriter&lt;T&gt;</code>など、.NETには次々と新しいI/O系のAPIが追加されていったため、v2ではそれらに焦点を当てた新しいデザインが導入されました。この実装はMicrosoftのEngineerである<a href="https://github.com/AArnott">Andrew Arnott / @AArnott</a>氏によって主導され、リリースしています。</p>
<p>以降、共同のメンテナンス体制として、そして私の個人リポジトリ(neuecc/MessagePack-CSharp)からオーガナイゼーション(MessagePack-CSharp/MessagePack-CSharp)して今に至ります。Visual Studio内部での利用や<a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol">SignalRのバイナリープロトコル</a>、Blazor Serverのプロトコルなど大きなMicrosoftのプロダクトでも使用され、GitHubでのスター数は.NETのバイナリーシリアライザーとしては最も大きなスターを集めています。<a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-migration-guide/">.NET 9で廃止されたBinaryFormatter</a>の移行先の一つとしても推奨されています。</p>
<p>v3ではSource Generatorに対応することで、より高いパフォーマンスと柔軟性、AOT対応への第一段階に踏み出すことができました。</p>
<p>MessagePack for C#プロジェクトは大きな成功を収めたと考えていますが、しかし現在、AArnott氏は個人の新しいMessagePackプロジェクトの開発を開始しています。私もその間、<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>という異なるフォーマットのシリアライザーをリリースしています。そのため、MessagePack for C#の今後と、その特性について、ある程度説明する必要があると思います。</p>
<p>引き続きメンテナンス体制は2人だと考えていますが、アクティブな活動に関しては、再び私が担うことになるかもしれません。私はMessagePackとMemoryPackとでは異なる性質を持ったフォーマットであるため、どちらも重要であるという認識で動いています。オリジナルの実装であるMessagePack for C#も気に入ってますし、現在においても決して引けを取ることのないものだと思っています。</p>
<p>AArnott氏の別のMessagePackシリアライザーとは根本的な哲学が若干異なります。その点で、私はそれはより良く改善されたシリアライザーではなく、別の個性のシリアライザーだと認識しています。そこで、違いについて説明させてください。</p>
<h2>Binary spec, default settings and performance</h2>
<p>シリアライザーのパフォーマンスに重要なのは、「仕様と実装」の両方です。例えばテキストフォーマットのJSONよりもバイナリフォーマットのほうが一般的には速いでしょう。しかし、よくできたJSONシリアライザーは、中途半端な実装のバイナリシリアライザーよりも高速です（私はそれを<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>というシリアライザーを作成することで実証したことがあります）。なので、仕様も大事だし、実装も大事です。どちらも兼ねることができれば、それがベストなパフォーマンスのシリアライザーとなります。</p>
<p><a href="https://msgpack.org/">MessagePackのバイナリ仕様</a>は &quot;It's like JSON. but fast and small.&quot; を標語にしている通り、JSONのバイナリ化としてあらわされています。ところが、MessagePack for C#のデフォルトは必ずしもJSON likeを狙っているわけではありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject]
public class MsgPackSchema
{
    [Key(0)]
    public bool Compact { get; set; }
    [Key(1)]
    public int Schema { get; set; }
}
</code></pre>
<p>このクラスをシリアライズした場合は、JSONで表現すると<code>[true, 0]</code>のようになります。これはオブジェクトをarrayベースでシリアライズしているからで、mapベースでシリアライズすると<code>{&quot;Compact&quot;:true,&quot;Schema&quot;:0}</code>のような表現になります。</p>
<p>arrayベースの利点は見た通りに、バイナリ容量として、よりコンパクトになります。容量がコンパクトなことは処理量が少なくなるためシリアライズの速度にも良い影響を与えます。また、デシリアライズにおいては、文字列を比較してデシリアライズするプロパティを探索する必要がなくなるため、より高速なデシリアライズ速度が期待できます。</p>
<p>なお、arrayベースのシリアライズはMessagePackの仕様策定者である Sadayuki Furuhashi 氏によるリファレンス実装であるmsgpack-javaなどでも採用されているため、決して異端のやり方というわけではありません。</p>
<p>MessagePack-CSharpではJSONライクなmapベースでシリアライズしたい場合は<code>[MessagePackObject(true)]</code>と記述することができます。また、Source Generatorの場合はResolver単位でオーバーライドして強制的にmapベースにすることも可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject(keyAsPropertyName: true)]
public class MsgPackSchema
{
    public bool Compact { get; set; }
    public int Schema { get; set; }
}
</code></pre>
<p>mapの利点は、柔軟なスキーマエボリューションの実現と、他言語との疎通する際にコミュニケーションが取りやすいこと、バイナリそのものの自己記述性が高いことです。デメリットは容量とパフォーマンスへの悪影響、特にオブジェクトの配列においては一要素毎にプロパティ名が含まれることになってしまい、かなりの無駄となります。</p>
<p>デフォルトをarrayにしているのは、コンパクトさとパフォーマンスの追求のためです。私はMessagePackをJSON likeの前に、高いパフォーマンスを実現可能なバイナリ仕様として考えました。もちろん、mapも重要なので、その上で比較的簡単にmapモードを実現するために属性に<code>(true)</code>を追加するだけで可能にしました。</p>
<p>arrayモードの場合はKey属性を全てのプロパティに付与する必要があります。これは、例えばProtocol Buffersなどでも数値タグを必要とするように、プロパティ名そのものをキーとするわけではなければ、必須だと考えています。もちろん、連番で自動採番させることも可能ですが、バイナリフォーマットのキーを暗黙的に処理するのはリスクが大きすぎる(順番を弄ったりするだけでバイナリ互換性が壊れることになる)と判断しています。つまり、明示的がデフォルト、ということです。大きなプロジェクト開発ではシニアメンバーからジュニアメンバーまでコードを触ることになるでしょう、全てを理解している人だけがコードを触るわけではありません。なので、暗黙的な挙動は避けるべきで、明示的にすべきだという強い意志で、この設計を選んでいます。</p>
<p>ただしKeyを全てのプロパティに付与する作業はとても苦痛です(私はMessagePack-CSharp開発以前には、DataContractやprotobuf-netで辛い思いをしました)。そこで、Analyzer + Code Fixによって、自動的に付与する機能を用意しました。これにより明示的であることの苦痛は和らげられ、良いとこどりができているのだと考えています。</p>
<p>別のMessagePackシリアライザーのデフォルトはmapのようです。これは<a href="https://github.com/eiriktsarpalis/PolyType">PolyType</a>というSource Generatorベースのライブラリ作成のための抽象化ライブラリがベースとしているためでもあり、また、そちらのほうを好んでいるという明示的な判断でもあるようです。</p>
<p>「デフォルト」はライブラリで一つしか選べません。どちらのモードで処理することができたとしても、「デフォルト」はただ一つです。改めて言うと、私はバイナリフォーマットとしての「コンパクトとパフォーマンス」を好み、優先しています。</p>
<p>皆さんはPolyTypeについて初めて知ったかもしれません。私はPolyTypeはあまり好意的には考えていません。ちょっとしたものを作るには非常に便利だとは思いますが、ベストなパフォーマンスを狙ったり、ベストなアイディアを表現するには、抽象層であることの制限が大きすぎると考えています。なので、MessagePack for C#で採用することはありませんし、他の何かを作る際にも採用することはないでしょう。</p>
<h2>Unity(multiplatform) Support</h2>
<p>MessagePack for C#ではv1の時代からゲームエンジンUnityの1st classのサポートを実行してきました。これは私が<a href="https://en.wikipedia.org/wiki/Cygames">Cygames</a>という日本のゲーム会社の関連会社(<a href="https://cysharp.com/">Cysharp</a>)のCEOを務めていて、ビデオゲームインダストリーと関係性が深いという都合もあります。自分たちで実際にUnityで動くものを作り、使ってきました。もちろん、サーバーサイドやデスクトップアプリケーションでも使っています。</p>
<p>UnityにはIL2CPPという独自のAOTシステムがあり、特にiOSなどモバイルプラットフォームでのリリースには必須なのですが、それもSource Generatorが存在しなかった時代から、mpcというRoslynを使ったコードジェネレートツールを作り、提供してきました。数百のモバイルゲームでMessagePackが使われているのは、これら私の熱心なサポートのお陰といっても過言ではないでしょう。v3ではついにSource Generatorベースになったことにより、ワークフローが大きく簡易化されることとなります！</p>
<p>一般的に、.NETコミュニティにおいてはUnityサポートはかなり軽視されていました。また、外から見ているとMicrosoftやMicrosoftの従業員もそのようで、自社のプラットフォーム以外への関心は薄そうです。こうした態度は、あまり好ましいとは思っていませんし、せっかくの .NET の可能性を狭めていることにもなっています。Xamarinがうまく成長軌道に乗らなかったのも、そのようなMicrosoft自体の冷たい視線のせいだとも思っています。</p>
<p>私は、私の作るライブラリはなるべくUnityにもしっかり対応できるように気を付けて作っています（最新は新しいReactive Extensionsライブラリーである<a href="https://github.com/Cysharp/R3">Cysharp/R3</a>）。別のMessagePackシリアライザーに関しては、あまりしっかりした対応はされなさそうですが……。</p>
<h2>Beyond v3</h2>
<p>v3のNative AOT Supportは完全ではありません。Source Generatorにするだけでは完全なNative AOT対応とはならないのは難しいところです。これはUnityのAOTであるIL2CPPでは完璧に動作しているだけに、正直不可解なことでもあり、また、Microsoftのよくない癖が出ているな、とも思っています。つまり、完璧な対応をするために、複雑なものを提供している。それが現在のNative AOTです。複雑怪奇な属性やフローは、理解できるところもありますが、もう少し簡略化すべきだったと思います。まぁ、もう修正されることもないのでしょうが……。</p>
<p>パフォーマンス面でもv1からv2で退化してしまった点もあるので、最新の知見を元に、実装面での改善を施す必要があります。特にReadOnlySequenceの利用幅が大きいことは、かなりの制約を生み出していて、不満があります。</p>
<p>.NET 9でPipeReader/PipeWriterが標準化されたことによる、より良い非同期APIや、パフォーマンスを両立したストリーミング対応というのも、大きなトピックとなるかもしれません。</p>
<p>MessagePack for C#は広く使われているが故に、破壊的変更はしづらいし、互換性の維持は最重要トピックスです。しかし、世の中が変わっていく以上、進化しないことを選んだら、それは滅びる道でしかありません。やれることはまだまだあると思っていますので、.NETにおける最先端の、最高のバイナリシリアライザーであり続けたいと思っています（<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>もね……！)</p>
<p>まずは、v3のSource Generatorをぜひ試してみてください。皆の力でより良いものを作っていけるというのも、OSSの良さだと思っています。</p>
</div>
<h1 data-pagefind-sort="date:2024-12-03" data-pagefind-meta="published:2024-12-03"><a href="https://neue.cc/2024/12/03_SharpFuzz.html">Fuzzing in .NET: Introducing SharpFuzz</a></h1>
<ul class="date"><li>2024-12-03</li></ul>
<div class="entry_body"><p>この記事は<a href="https://qiita.com/advent-calendar/2024/csharplang">C# Advent Calendar 2024</a>に参加しています。また、先月開催された<a href="https://dotnetnew.connpass.com/event/335955/">dotnet new</a>というイベントでの発表のフォローアップ、のつもりだったのですがコロナ感染につき登壇断念……。というわけで、セッション資料はないので普通にブログ記事とします！</p>
<h2>dotnet/runtime と Fuzzing</h2>
<p>今年に入ってからdotnet/runtimeにFuzzingテストが追加されています。<a href="https://github.com/dotnet/runtime/tree/main/src/libraries/Fuzzing">dotnet/runtime/Fuzzing</a>。というわけで、実はfuzzingは非常に最近のトピックスなのです……！</p>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0">ファジング</a>とはなんなのか、ザックリとはランダムな入力値を大量に投げつけることによって不具合や脆弱性を発見するためのテストツールです。エッジケースのテスト、やはりどうしても抜けちゃいがちだし、ましてや脆弱性になりうる絶妙な不正データを人為的に作るのも難しいので、ここはツール頼みで行きましょう。</p>
<p>Goでは1.18(2022年)から標準でgo fuzzコマンドとして追加されたらしいので、
<a href="https://future-architect.github.io/articles/20220214a/">Go1.18から追加されたFuzzingとは</a>のような解説記事を読むのもイメージを掴みやすいです。</p>
<p>さて、dotnet/runtimeのFuzzingでは現状</p>
<ul>
<li>AssemblyNameInfoFuzzer</li>
<li>Base64Fuzzer</li>
<li>Base64UrlFuzzer</li>
<li>HttpHeadersFuzzer</li>
<li>JsonDocumentFuzzer</li>
<li>NrbfDecoderFuzzer</li>
<li>SearchValuesByteCharFuzzer</li>
<li>SearchValuesStringFuzzer</li>
<li>TextEncodingFuzzer</li>
<li>TypeNameFuzzer</li>
<li>UTF8Fuzzer</li>
</ul>
<p>というのものが用意されてます。わかるようなわからないような。だいたいデータのパース系によく使われるものなので、その通りのところに用意されています。一番わかりやすいJsonDocumentFuzzerを見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal sealed class JsonDocumentFuzzer : IFuzzer
{
    public string[] TargetAssemblies { get; } = [&quot;System.Text.Json&quot;];
    public string[] TargetCoreLibPrefixes =&gt; [];
    public string Dictionary =&gt; &quot;json.dict&quot;;

    // fuzzerからのランダムなバイト列が入力
    public void FuzzTarget(ReadOnlySpan&lt;byte&gt; bytes)
    {
        if (bytes.IsEmpty)
        {
            return;
        }

        // The first byte is used to select various options.
        // The rest of the input is used as the UTF-8 JSON payload.
        byte optionsByte = bytes[0];
        bytes = bytes.Slice(1);

        var options = new JsonDocumentOptions
        {
            AllowTrailingCommas = (optionsByte &amp; 1) != 0,
            CommentHandling = (optionsByte &amp; 2) != 0 ? JsonCommentHandling.Skip : JsonCommentHandling.Disallow,
        };

        using var poisonAfter = PooledBoundedMemory&lt;byte&gt;.Rent(bytes, PoisonPagePlacement.After);

        try
        {
            // それをParseに投げて、もし不正な例外が来たらなんかバグっていたということで
            JsonDocument.Parse(poisonAfter.Memory, options);
        }
        catch (JsonException) { }
    }
}
</code></pre>
<p>ようは想定外のデータ入力で<code>JsonDocument.Parse</code>が失敗しないことを祈る、といったものですね。正常に認識しているinvalidな値なら<code>JsonException</code>をthrowするはずですが、<code>ArgumentException</code>とか<code>StackOverflowException</code>とかが出てきちゃった場合は認識できていない不正パターンなので、ちゃんとしたハンドリングが必要になってきます。</p>
<p>では、これを参考にやっていきましょう、とはなりません。えー。まず、dotnet/runtimeのFuzzingではSharpFuzz, libFuzzer, そしてOneFuzzが使用されていると書いてあるのですが、OneFuzzはMicrosoft内部ツールなので外部では使用できません。正確には<a href="https://www.publickey1.jp/blog/20/project_onefuzzwindowsmicorosoft_edge.html">2020年にオープンソース公開</a>したものの、<a href="https://github.com/microsoft/onefuzz">2023年にはクローズドに戻している</a>状態です。まぁ事情は色々ある。しょーがない。</p>
<p>というわけで、これはMicrosoft内部で動かすためのOneFuzzや、dotnet/runtimeで動かすために調整してある<code>IFuzzer</code>といったフレームワーク部分が含まれているので、小規模な自分たちのコードをfuzzingするにあたっては、不要ですし、ぶっちゃけあまり参考にはなりません！解散！</p>
<h2>Introducing SharpFuzz</h2>
<p>そんなわけでdotnet/runtimeのFuzzingでも使われている<a href="https://github.com/Metalnem/sharpfuzz">Metalnem/sharpfuzz: AFL-based fuzz testing for .NET</a>を直接使っていきます。sharpfuzzは<a href="https://lcamtuf.coredump.cx/afl/">afl-fuzz</a>と連動して動くように作られている .NETライブラリです。3rd Partyライブラリですが作者はMicrosoftの人です（dotnet/runtimeで採用されている理由でもあるでしょう）。ReadMeのTrophiesでは色々なもののバグを見つけてやったぜ、と書いてあります。AngleSharpとかGoogle.ProtobufとかGraphQL-ParserとかMarkdigとかMessagePack for C#とImageSharpとか。まぁ、やはり用途としてはパーサーのバグを見つけるのには適切、という感じです。</p>
<p>AFL(American Fuzzy Lop)ってなに？ということなのですが、そもそもファジングの「ランダムな入力値を大量に投げつける」行為は、完全なランダムデータを投げつけていくわけではありません。完全ランダムだとあまりにも時間がかかりすぎるため、脆弱性発見において実用的とは言えない。そこでAFLはシード値からのミューテーションと、カバレッジをトレースしながら効率よくデータを生成していきます。Wikipediaから引用すると</p>
<blockquote>
<p>テスト対象のプログラム（テスト項目）のソースコードをインストルメント化することにより、afl-fuzzは、ソフトウェアのどのブロックが特定のテスト刺激で実行されたかを後で確認できる。そのため、AFLはグレーボックステストに使用することができる。遺伝的手法による検査データの生成に関連して、ファザーはテストデータをより適切に生成できるため、このメソッドを使用しない他のファザーよりも、処理中に以前は使用されていなかったコードブロックが実行される。その結果、コードカバレッジは比較的短い時間で比較的高い結果が得られる。この方法は、生成されたデータ内の構造を独立して（つまり、事前の情報なしで）生成することができる。このプロパティは、テストカバレッジの高いテストコーパス（テストケースのコレクション）を生成するためにも使用される。</p>
</blockquote>
<p>というわけでdotnet testのようにテストコードを渡したら全自動でやってくれる、というほど甘くはなくて、多少の下準備が必要になってきます。SharpFuzzは一連の処理をある程度やってくれるようにはなっていますが、そもそもに実行までに二段階の処理が必要になっています。</p>
<ul>
<li>sharpfazzコマンド(dotnet tool)でdllにトレースポイントを注入する</li>
<li>その注入されたdll(とexe)をネイティブのfuzzing実行プロセス(afl-fuzzなど)に渡す</li>
</ul>
<p>dllにトレースポイントを注入はお馴染みの<a href="https://github.com/jbevain/cecil">Cecil</a>でビルド済みのDLLのILを弄ってトレースポイントを仕込みます。</p>
<p><img src="https://github.com/user-attachments/assets/c3b43b60-8526-44cd-8482-6f1185206b65" alt="image" /></p>
<p>これは注入済みのdllですが、Trace.SharedMemとかTrace.PrevLocationとか、分岐点に対して明らかに注入している様が見えます。そうしたトレースポイントとの通信や実行データ生成などは外部プロセスが行うので、SharpFuzzというライブラリは、それ自体は実行ツールではなくて、それらとの橋渡しをするためのシステムということです。</p>
<p>ではやっていきましょう！色々なシステムが絡んでくる分、ちょっとややこしく面倒くさいのと、ReadMeの例をそのままやると罠が多いので、少しアレンジしていきます。</p>
<p>まずはRequirementsですが、実行機であるAFLがWindowsでは動きません(Linux, macOSでは動く)。なのでWSL上で動かしましょうという話になってくるのですが、それはあんまりにもやりづらいので、<a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>というLLVMが開発しているAFL互換のFuzzingツールを使っていくことにします。これはWindowsでビルドできます。</p>
<p>自分でビルドする必要はなく、SharpFuzzの作者が連携して使うことを意識して用意してくれている<a href="https://github.com/Metalnem/libfuzzer-dotnet/releases">libfuzzer-dotnetのReleasesページ</a>から、バイナリを直接落としてきましょう。<code>libfuzzer-dotnet-windows.exe</code>です。</p>
<p>次に、IL書き換えを行うツール<code>SharpFuzz.CommandLine</code>を .NET toolで入れていきましょう。これはglobalでいいかな、と思います。</p>
<pre data-pagefind-ignore="all"><code>dotnet tool install --global SharpFuzz.CommandLine
</code></pre>
<p>次に、今回は<a href="https://github.com/kevin-montrose/Jil">Jil</a>という、今はもうあまり使われることもないJsonシリアライザーをターゲットとしてやっていこうということなので、JilとSharpFuzzをインストールします。</p>
<pre data-pagefind-ignore="all"><code>dotnet add package Jil --version 2.15.4
dotnet add package SharpFuzz
</code></pre>
<p>ここで注意が必要なのは、Jilの最新バージョンはSharpFuzzにより発見されたバグが修正されているので、最新版を入れるとチュートリアルにはなりません！というわけでここは必ずバージョン下げて入れましょう。</p>
<p>新規のConsoleApplicationで、コードは以下のようにします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Jil;
using SharpFuzz;

// 実行機としてlibFuzzerを使う(引数はReadOnlySpan&lt;byte&gt;)
Fuzzer.LibFuzzer.Run(span =&gt;
{
    try
    {
        using var stream = new MemoryStream(span.ToArray());
        using var reader = new StreamReader(stream);
        JSON.DeserializeDynamic(reader); // このメソッドが正しく動作してくれるかをテスト
    }
    catch (Jil.DeserializationException)
    {
        // Jil.DeserializationExceptionは既知の例外（正しくハンドリングできてる）なので握り潰し
        // それ以外の例外が発生したらルート側にthrowされて問題が検知される
    }
});
</code></pre>
<p>今度はベースになるテストデータを用意します。名前とかはなんでもいいんですが、<code>Testcases</code>フォルダに<code>Test.json</code>を追加しました。</p>
<p><img src="https://github.com/user-attachments/assets/606cede7-9a20-4efe-8e58-642330ced8d5" alt="image" /></p>
<pre data-pagefind-ignore="all"><code class="language-json">{&quot;menu&quot;:{&quot;id&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;pop&quot;:{&quot;a&quot;:[{&quot;click&quot;:&quot;Open()&quot;},{&quot;click&quot;:&quot;Close()&quot;}]}}}
</code></pre>
<p>このデータを元にしてfuzzerは値を変形させていくことになります。</p>
<p>では実行しましょう！実行するためには、ビルドしてILポストプロセスしてlibFuzzer経由で動かす……。という一連の定型の流れが必要になるため、作者の用意してくれているPowerShellスクリプト<a href="https://raw.githubusercontent.com/Metalnem/sharpfuzz/master/scripts/fuzz-libfuzzer.ps1">fuzz-libfuzzer.ps1</a>をダウンロードしてきて使いましょう。</p>
<p>とりあえず<code>fuzz-libfuzzer.ps1</code>と<code>libfuzzer-dotnet-windows.exe</code>をcsprojと同じディレクトリに配置して、以下のコマンドを実行します。<code>ConsoleApp24.csproj</code>の部分だけ適当に変えてください。</p>
<pre data-pagefind-ignore="all"><code class="language-cmd">PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &quot;./libfuzzer-dotnet-windows.exe&quot; -project &quot;ConsoleApp24.csproj&quot; -corpus &quot;Testcases&quot;
</code></pre>
<p>動かすと、見つかった場合はいい感じに止まってくれます。</p>
<p><img src="https://github.com/user-attachments/assets/1ce45aa1-2d50-46f2-8f86-947db39406d6" alt="image" /></p>
<p>なお、見つからなかった場合は無限に探し続けるので、なんとなくもう見つかりそうにないなあ、と思ったら途中で自分でとめる(Ctrl+C)必要があります。</p>
<p>Testcasesには途中の残骸と、クラッシュした場合は<code>crash-id</code>でクラッシュ時のデータが拾えます。</p>
<p><img src="https://github.com/user-attachments/assets/d90f5bb1-4509-41b6-a139-16789a5a501c" alt="image" /></p>
<p>今回見つかったクラッシュデータは</p>
<pre data-pagefind-ignore="all"><code class="language-json">{&quot;menu&quot;:{&quot;id&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;popid&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;pop&quot;:{&quot;a&quot;:[{&quot;click&quot;:&quot;Open()&quot;},{&quot;c
</code></pre>
<p>でした。実際このデータを使って再現できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Jil;

//  クラッシュファイルのプロパティでデータはCopy to Output Directoryしてしまう
//  &lt;None Update=&quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&quot;&gt;
//    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
//  &lt;/None&gt;
var crash = File.ReadAllBytes(&quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&quot;);
var span = crash.AsSpan();

// Fuzzing時と同じコード
using var stream = new MemoryStream(span.ToArray());
using var reader = new StreamReader(stream);
JSON.DeserializeDynamic(reader);
</code></pre>
<p>以上！完璧！便利！一度手順を理解してしまえば、そこまで難しいことではないので、是非ハンズオンでやってみることをお薦めします。なお、ps1のスクリプトは実行対象自身へのインジェクトは除外されるようになっているので、小規模な自分のコードでfuzzingを試してみたいと思った場合は、対象コードはexeとは異なるプロジェクトに分離しておく必要があります。</p>
<p>ところで、AFLにはdictionaryという仕組みがあり、既知のキーワード集がある場合は生成速度を大幅に上昇させることが可能です。例えば<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/json.dict">json.dict</a>を使う場合は</p>
<pre data-pagefind-ignore="all"><code class="language-cmd">PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &quot;./libfuzzer-dotnet-windows.exe&quot; -project &quot;ConsoleApp24.csproj&quot; -corpus &quot;Testcases&quot; -dict ./json.dict
</code></pre>
<p>のように指定します。JSONとかYAMLとかXMLとかZipとか、一般的な形式は<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries">AFLplusplus/dictionaries</a>などに沢山転がっています。独自に作ることも可能で、例えばdotnet/runtimeのFuzzingではBinaryFormatterのテストが置いてありますが、これは<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/binaryformatter-migration-guide/read-nrbf-payloads">NRBF(.NET Remoting Binary Format)</a>の辞書、<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Fuzzing/DotnetFuzzing/Dictionaries/nrbfdecoder.dict">nrbfdecoder.dict</a>を用意しているようでした。</p>
<p>もちろん、なしでも動かすことはできますが、用意できそうなら用意しておくとよいでしょう。</p>
<h2>まとめ</h2>
<p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>でも実際バグ見つかってたりするので、この手のライブラリを作る人だったら覚えておいて損はないです。シリアライザーに限らずパーサーに関わるものだったらネットワークプロトコルでも、なんでも適用可能です。ただし現状、入力が<code>byte[]</code>に制限されているので、応用性自体はあるようで、なかったりはします。これがintとか受け入れてくれると、様々なメソッドに対してカジュアルに使えて、より便利な気もしますが……(実際go fuzzは<code>byte[]</code>だけじゃなくて基本的なプリミティブの生成に対応している)</p>
<p><code>byte[]</code>列から適当に切り出してintとして使う、といったような処理だと、ミューテーションやカバレッジの関係上、適切な値を取得しにくいので、あまりうまくやれません。libFuzzerでは<a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md">Structure-Aware Fuzzing with libFuzzer</a>といったような手法が考案されていて、protocol buffersの構造を与えるとか、gRPCの構造を与えるとかでうまく活用している事例はあるようです。この辺はSharpFuzzの対応次第となります(いつかやりたい、とは書いてありましたが、現実的にいつ来るかというと、あまり期待しないほうが良いでしょう)</p>
<p>Rustにも<a href="https://github.com/rust-fuzz/cargo-fuzz">cargo fuzz</a>といったcrateがあり、それなりに使われているようです。</p>
<p>Fuzzingは適用範囲が限定的であることと下準備の手間などがあり、一般的なアプリケーション開発者においては、あまりメジャーなテスト手法ではないというのが現状だと思いますが、使えるところはないようで意外とあるとも思うので、ぜひぜひ試してみてください。</p>
</div>
<h1 data-pagefind-sort="date:2024-11-19" data-pagefind-meta="published:2024-11-19"><a href="https://neue.cc/2024/11/19_cysharp_oss.html">CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion</a></h1>
<ul class="date"><li>2024-11-19</li></ul>
<div class="entry_body"><p>「CysharpのOSS群から見るModern C#の現在地」というタイトルでセッションしてきました。</p>
<script defer class="speakerdeck-embed" data-id="73bfd578c3324a6e8ce74457445fe9c0" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"></script>
<p>作りっぱなし、というわけではないですが（比較的メンテナンスしてるとは思います！）、リリースから年月が経ったライブラリをどう思っているかは見えないところありますよね、というわけで、その辺を軽く伝えられたのは良かったのではないかと思います。</p>
<p>この中だと非推奨に近くなっているのが<a href="https://github.com/Cysharp/ZString">ZString</a>と<a href="https://github.com/Cysharp/Ulid">Ulid</a>でしょうか。</p>
<h2>Ulid vs .NET 9 UUID v7</h2>
<p>スライドにも書きましたが、ULIDをそこそこ使ってきての感想としては、「Guidではないこと」が辛いな、と。独自文字列形式とか要らないし。そんなわけで私はむしろUUID v7のほうを薦めたいレベルだったりはします。.NET 9から<code>Guid.CreateVersion7()</code>という形で、標準で生成できるようになりました。</p>
<p>パフォーマンス的なところは些細なことなので問題ないのですが、 .NET 9未満との互換性が取れないのは厳しいところかもしれません。というわけで、自作のV7実装を用意してあげるといいでしょう。以下に置いておきますのでどうぞ（コードのベースはdotnet/runtimeのCCreateVersion7です）</p>
<pre data-pagefind-ignore="all"><code class="language-Csharp">public static class GuidEx
{
    private const byte Variant10xxMask = 0xC0;
    private const byte Variant10xxValue = 0x80;
    private const ushort VersionMask = 0xF000;
    private const ushort Version7Value = 0x7000;

    public static Guid CreateVersion7() =&gt; CreateVersion7(DateTimeOffset.UtcNow);

    public static Guid CreateVersion7(DateTimeOffset timestamp)
    {
        // 普通にGUIDを作る
        Guid result = Guid.NewGuid();

        // 先頭48bitをいい感じに埋める
        var unix_ts_ms = timestamp.ToUnixTimeMilliseconds();

        // GUID layout is int _a; short _b; short _c, byte _d;
        Unsafe.As&lt;Guid, int&gt;(ref Unsafe.AsRef(ref result)) = (int)(unix_ts_ms &gt;&gt; 16); // _a
        Unsafe.Add(ref Unsafe.As&lt;Guid, short&gt;(ref Unsafe.AsRef(ref result)), 2) = (short)(unix_ts_ms); // _b

        ref var c = ref Unsafe.Add(ref Unsafe.As&lt;Guid, short&gt;(ref Unsafe.AsRef(ref result)), 3);
        c = (short)((c &amp; ~VersionMask) | Version7Value);

        ref var d = ref Unsafe.Add(ref Unsafe.As&lt;Guid, byte&gt;(ref Unsafe.AsRef(ref result)), 8);
        d = (byte)((d &amp; ~Variant10xxMask) | Variant10xxValue);

        return result;
    }

    // GuidにはTimestamp部分を取り出すメソッドがないので、これも用意してあげると便利
    public static DateTimeOffset GetTimestamp(in Guid guid)
    {
        // エンディアンについては特に考慮してません
        ref var p = ref Unsafe.As&lt;Guid, byte&gt;(ref Unsafe.AsRef(in guid));
        var lower = Unsafe.ReadUnaligned&lt;uint&gt;(ref p);
        var upper = Unsafe.ReadUnaligned&lt;ushort&gt;(ref Unsafe.Add(ref p, 4));
        var time = (long)upper + (((long)lower) &lt;&lt; 16);
        return DateTimeOffset.FromUnixTimeMilliseconds(time);
    }
}
</code></pre>
<p>UUID v7のよくあるユースケースはDBの主キーにGUID(UUID v4)の代わりに使う、ということです。UUID v4だとランダムに配置されるので断片化して、auto incrementの主キーに比べると色々と遅くなる。それがv7だとランダムの性質を持ちつつも配置場所はタイムスタンプベースなのでauto incrementと同様になるため性能劣化がない。</p>
<p>という理屈を踏まえたうえで、.NETのUUID v7事情を踏まえると単純に置き換えるだけで良い、とはなりません。</p>
<p>GUIDは内部的なバイナリデータとしてはリトルエンディアンで保持していて、出力時に切り分けるというデザインになっています(無指定の場合はlittleEndianでの出力)。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public readonly struct Guid
{
    public byte[] ToByteArray()
    public byte[] ToByteArray(bool bigEndian)
    public bool TryWriteBytes(Span&lt;byte&gt; destination)
    public bool TryWriteBytes(Span&lt;byte&gt; destination, bool bigEndian, out int bytesWritten)
}
</code></pre>
<p>String(char36)として格納するなら気にしなくてもいいのですが、GUID型やバイナリ型としてデータベースに格納する時は、UUID v7に関してはビッグエンディアンで書き出さないと、ソート可能にならない非常に都合が悪い。これのハンドリングは言語のデータベースドライバーライブラリの責務となっています。</p>
<p>代表的なライブラリを見ていくと、MySQLの<a href="https://mysqlconnector.net/connection-options/">mysqlconnector-netはコネクションストリング</a>で <code>GuidFormat=Binary16</code> を指定することでbig-endianでBINARY(16)に書き込む設定となります。</p>
<p>PostgreSQLの場合、<a href="https://github.com/npgsql/npgsql/blob/94de20fed2e7e64a1eb6f26c9fc044131a362958/src/Npgsql/Internal/Converters/Primitive/GuidUuidConverter.cs#L29">npgsqlのGuidUuidConverter</a>が常にbigEndianとして処理するようになっているようです。</p>
<p>ではMicrosoft SQL Serverはどうかというと、ばっちしlittle-endianです。ダメです。というわけで、性能を期待してCreateVersion7を使うと、逆に断片化して遅くなるような憂き目にあいます。</p>
<p>こちらは<a href="https://github.com/dotnet/SqlClient/discussions/2999">dotnet/SqlClientのdiscussions#2999</a>で議論されているようなので、成り行きに注目ということで。今までとの互換性などを考えると一括でbigにしてしまえばいいじゃん、というわけにもいかないしで、中々素直にはいかないかもしれませんね……。</p>
<p>なお、このことは別に.NET 9がリリースされる前にもわかっていたことなのに（私でもダメだという状況は把握していた）、リリースされるまでアクションが全く起きないというところに、今のSQL Serverへのやる気を感じたりなかったり。</p>
<h2>MagicOnion</h2>
<p>イベントではCysharpの @mayuki さんからMagicOnionの入門セッションもありました！</p>
<script defer class="speakerdeck-embed" data-id="d5b4ad47f5cd4e9f984022e64d623d51" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"></script>
<p>MagicOnionも2016年の初リリース、2018年のリブート(v2)、googleのgRPC C Coreからgrpc-dotnetベースへの変更、クライアントのHttpClientベースへの変更など、内部的には色々変わってきたし機能面でも磨かれてきています。まだまだ次のアップデートが控えている、最前線で戦える強力なフレームワークとなっています！</p>
</div>
<h1 data-pagefind-sort="date:2024-08-29" data-pagefind-meta="published:2024-08-29"><a href="https://neue.cc/2024/08/29_AlternateLookup.html">.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照</a></h1>
<ul class="date"><li>2024-08-29</li></ul>
<div class="entry_body"><p>.NET 9 から辞書系のクラス、<code>Dictionary</code>, <code>ConcurrentDictionary</code>, <code>HashSet</code>, <code>FrozenDictionary</code>, <code>FrozenSet</code>に <code>GetAlternateLookup&lt;TKey, TValue, TAlternate&gt;()</code> というメソッドが追加されました。今までDictionaryの操作はTKey経由でしかできませんでした。それは当たり前、なのですが、困るのが文字列キーで、これはstringでも操作したいし、<code>ReadOnlySpan&lt;char&gt;</code>でも操作したくなります。今までは<code>ReadOnlySpan&lt;char&gt;</code>しか手元にない場合はToStringでstring化が必須でした、ただたんにDictionaryの値を参照したいだけなのに！</p>
<p>その問題も、.NET 9から追加された<code>GetAlternateLookup</code>を使うと、辞書に別の検索キーを持たせることが出来るようになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var dict = new Dictionary&lt;string, int&gt;
{
    { &quot;foo&quot;, 10 },
    { &quot;bar&quot;, 20 },
    { &quot;baz&quot;, 30 }
};

var lookup = dict.GetAlternateLookup&lt;ReadOnlySpan&lt;char&gt;&gt;();

var keys = &quot;foo, bar, baz&quot;;

// .NET 9 SpanSplitEnumerator
foreach (Range range in keys.AsSpan().Split(','))
{
    ReadOnlySpan&lt;char&gt; key = keys.AsSpan(range).Trim();

    // ReadOnlySpan&lt;char&gt;でstring keyの辞書のGet/Add/Removeできる
    int value = lookup[key];
    Console.WriteLine(value);
}
</code></pre>
<p>ところでSplitは、通常のstringのSplitは配列とそれぞれ区切られたstringをアロケーションしてしまいますが、.NET 8から、<code>ReadOnlySpan&lt;char&gt;</code>に対して固定個数のSplitができる<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.split">MemoryExtensions.Split</a>が追加されました。.NET 9では、更にSpanSplitEnumeratorを返すSplitが新たに追加されています。これにより一切の追加のアロケーションなく、元の文字列から<code>ReadOnlySpan&lt;char&gt;</code>を切り出すことができます。</p>
<p>そうして取り出した<code>ReadOnlySpan&lt;char&gt;</code>のキーで参照するために、<code>GetAlternateLookup</code>が必要になってくるわけです。</p>
<p>使い道としては、例えばシリアライザーは頻繁にキーと値のルックアップが必要になります。私の開発している<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#</a>では、高速でアロケーションフリーなデシリアライズのために、複数の戦略を採用しています。その一つはUTF8の文字列を8バイトずつの<a href="https://en.wikipedia.org/wiki/Automata_theory">オートマトン</a>として扱う<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs">AutomataDictionary</a>、この部分は更にIL EmitやSource Generatorではインライン化して埋め込まれて辞書検索もなくしています。もう一つは<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/5793c81/src/MessagePack/Internal/AsymmetricKeyHashTable.cs">AsymmetricKeyHashTable</a>という機構で、これは同一の対象を表す2つのキーで検索可能にしようというもので、内部的には <code>byte[]</code> と <code>ArraySegment&lt;byte&gt;</code> で検索できるような辞書を作っていました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// MessagePack for C#のもの
internal interface IAsymmetricEqualityComparer&lt;TKey1, TKey2&gt;
{
    int GetHashCode(TKey1 key1);
    int GetHashCode(TKey2 key2);
    bool Equals(TKey1 x, TKey1 y);
    bool Equals(TKey1 x, TKey2 y); // TKey1とTKey2での比較
}
</code></pre>
<p>つまり、今までは、こうした別の検索キーを持った辞書が必要なシチュエーションでは、辞書そのものの自作が必要だったし、パフォーマンスのためには基礎的なデータ構造すら自作を厭わない必要がありましたが、.NET 9からはついに標準でそれが実現するようになりました。</p>
<p>AlternateLookupでも必要なのは<code>IAlternateEqualityComparer&lt;in TAlternate, T&gt;</code>で、以下のような定義になっています。(<code>IAsymmetricEqualityComparer</code>と似たような定義なので、また時代を10年先取りしてしまったか)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IAlternateEqualityComparer&lt;in TAlternate, T&gt;
    where TAlternate : allows ref struct
    where T : allows ref struct
{
    bool Equals(TAlternate alternate, T other);
    int GetHashCode(TAlternate alternate);
    T Create(TAlternate alternate);
}
</code></pre>
<p>C# 13から追加された言語機能 <a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/ref-struct">allows ref struct</a> によってref struct、つまり<code>Span&lt;T&gt;</code>などをジェネリクスの型引数にすることができるようになりました。</p>
<p>基本的にはこれは<code>IEqualityComparer&lt;T&gt;</code>とセットで実装する必要があります。実際、<code>Dictionary.GetAlternateLookup</code>ではDictionaryの<code>IEqualityComparer</code>が<code>IAlternateEqualityComparer</code>を実装していないと実行時例外が出ます（コンパイル時チェックではありません！）また、EqualityComparerなのに<code>Create</code>があるのが少し奇妙ですが、これはAdd操作のために必要だからです。</p>
<p>現状、標準では<code>IAlternateEqualityComparer</code>は<code>string</code>用しかありません。stringで標準的に使われるEqualityComparerは<code>IAlternateEqualityComparer</code>を実装していて、<code>ReadOnlySpan&lt;char&gt;</code>で操作できますが、それ以外は用意されていません。</p>
<p>しかし、現代において現実的に必要なのはUTF8です、<code>ReadOnlySpan&lt;byte&gt;</code>です。シリアライザーのルックアップで使う、と言いましたが、現代のシリアライザーの入力はUTF8です。<code>ReadOnlySpan&lt;char&gt;</code>の出番なんてありません。というわけで、以下のような<code>IAlternateEqualityComparer</code>を用意しましょう！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public sealed class Utf8StringEqualityComparer : IEqualityComparer&lt;byte[]&gt;, IAlternateEqualityComparer&lt;ReadOnlySpan&lt;byte&gt;, byte[]&gt;
{
    public static IEqualityComparer&lt;byte[]&gt; Default { get; } = new Utf8StringEqualityComparer();

    // IEqualityComparer

    public bool Equals(byte[]? x, byte[]? y)
    {
        if (x == null &amp;&amp; y == null) return true;
        if (x == null || y == null) return false;

        return x.AsSpan().SequenceEqual(y);
    }

    public int GetHashCode([DisallowNull] byte[] obj)
    {
        return GetHashCode(obj.AsSpan());
    }

    // IAlternateEqualityComparer

    public byte[] Create(ReadOnlySpan&lt;byte&gt; alternate)
    {
        return alternate.ToArray();
    }

    public bool Equals(ReadOnlySpan&lt;byte&gt; alternate, byte[] other)
    {
        return other.AsSpan().SequenceEqual(alternate);
    }

    public int GetHashCode(ReadOnlySpan&lt;byte&gt; alternate)
    {
        // System.IO.Hashing package, cast to int is safe for hashing
        return unchecked((int)XxHash3.HashToUInt64(alternate));
    }
}
</code></pre>
<p><code>byte[]</code>は標準では参照比較になってしまいますが、データの一致で比較したいので、<code>ReadOnlySpan&lt;T&gt;.SequenceEqual</code> を使います。これは、特にTが幾つかのプリミティブの場合はSIMDを活用して高速な比較が実現されています。ハッシュコードの算出は、高速なアルゴリズム<a href="https://github.com/Cyan4973/xxHash">xxHash</a>シリーズの最新版であるXXH3の.NET実装である<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3">XxHash3</a>を用いるのがベストでしょう。これはNuGetから<code>System.IO.Hashing</code>をインポートする必要があります。64ビットで算出するため戻り値はulongですが、32ビット値が必要な場合はxxHashの作者より、ただたんに切り落とすだけで問題ないと言明されているため、intにキャストするだけで済まします。</p>
<p>使う場合の例は、こんな感じです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Utf8StringEqualityComparerを設定した辞書を作る

var dict = new Dictionary&lt;byte[], bool&gt;(Utf8StringEqualityComparer.Default)
{
    { &quot;foo&quot;u8.ToArray(), true },
    { &quot;bar&quot;u8.ToArray(), false },
    { &quot;baz&quot;u8.ToArray(), false }
};

var lookup = dict.GetAlternateLookup&lt;ReadOnlySpan&lt;byte&gt;&gt;();

// こんな入力があるとする

ReadOnlySpan&lt;byte&gt; json = &quot;&quot;&quot;    
{
    &quot;foo&quot;: 0,
    &quot;bar&quot;: 0,
    &quot;baz&quot;: 0
}
&quot;&quot;&quot;u8;

// System.Text.Json
var reader = new Utf8JsonReader(json);

while (reader.Read())
{
    if (reader.TokenType == JsonTokenType.PropertyName)
    {
        // 切り出したKeyで検索できる
        ReadOnlySpan&lt;byte&gt; key = reader.ValueSpan;
        var flag = lookup[key];
        
        Console.WriteLine(flag);
    }
}
</code></pre>
<p>一つ注意なのは、<code>string</code>と<code>ReadOnlySpan&lt;byte&gt;</code>でAlternateKeyを作ろうとするのはやめたほうが良いでしょう。それだと、常にエンコードが必要になり、悪いとこどりのようになってしまいます(<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.rune">Rune</a>を使ってアロケーションレスで処理するにしても、どちらにせよバイナリ比較だけで済ませられる<code>byte[]</code>キーとは比較になりません）。どうしても両方の検索が必要なら、辞書を二つ用意するほうがマシです。</p>
<p>ともあれ、これは私にとっては念願の機能です！色々なバリエーションで、Span対応のためにジェネリクスにもできずに決め打ちで辞書を何度も作ってきました、汎用的に使えるようになったのは大歓迎です。<code>allows ref struct</code>はジェネリクス定義での煩わしさもありますが（自動判定での付与でも良かったような？）、言語としては重要な進歩です。.NET 9, C# 13、使っていきましょう。現状はまだプレビューですが、11月に正式版がリリースされるはずです。</p>
</div>
<h1 data-pagefind-sort="date:2024-07-11" data-pagefind-meta="published:2024-07-11"><a href="https://neue.cc/2024/07/11_mvp-renew14.html">Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2024-07-11</li></ul>
<div class="entry_body"><p>Microsoft MVPは一年ごとに再審査されるのですが、今年も更新しました。2011年から初めて14回目ということで、長い！のですが、引き続きC#の最前線に立ち続けられていると思います。以下、審査用書類に出した、審査期間での実績一覧です。</p>
<h2>OSS New</h2>
<ul>
<li><a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a><br />
.NET PhysX 5 binding to all platforms(win, osx, linux) for 3D engine, deep learning, dedicated server of gaming.</li>
<li><a href="https://github.com/Cysharp/PrivateProxy">PrivateProxy</a><br />
Source Generator and .NET 8 UnsafeAccessor based high-performance strongly-typed private accessor for unit testing and runtime.</li>
<li><a href="https://github.com/Cysharp/Utf8StringInterpolation">Utf8StringInterpolation</a><br />
Successor of ZString; UTF8 based zero allocation high-peformance String Interpolation and StringBuilder.</li>
<li><a href="https://github.com/Cysharp/R3">R3</a><br />
The new future of dotnet/reactive and UniRx.</li>
<li><a href="https://github.com/Cysharp/Claudia">Claudia</a><br />
Unofficial Anthropic Claude API client for .NET.</li>
<li><a href="https://github.com/Cysharp/Utf8StreamReader">Utf8StreamReader</a><br />
Utf8 based StreamReader for high performance text processing.</li>
</ul>
<h2>OSS Update</h2>
<ul>
<li><a href="https://github.com/Cysharp/StructureOfArraysGenerator">StructureOfArraysGenerator</a><br />
Structure of arrays source generator to make CPU Cache and SIMD friendly data structure for high-performance code in .NET and Unity.</li>
<li><a href="https://github.com/Cysharp/Ulid">Ulid</a><br />
Fast .NET C# Implementation of ULID for .NET and Unity.</li>
<li><a href="https://github.com/Cysharp/ZLogger">ZLogger</a><br />
Zero Allocation Text/Structured Logger for .NET with StringInterpolation and Source Generator, built on top of a Microsoft.Extensions.Logging.</li>
<li><a href="https://github.com/Cysharp/ZString/">ZString</a><br />
Zero Allocation StringBuilder for .NET and Unity.</li>
<li><a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack-CSharp</a><br />
Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin).</li>
<li><a href="https://github.com/Cysharp/ObservableCollections">ObservableCollections</a><br />
High performance observable collections and synchronized views, for WPF, Blazor, Unity.</li>
<li><a href="https://github.com/Cysharp/UnitGenerator/">UnitGenerator</a><br />
C# Source Generator to create value-object, inspired by units of measure.</li>
<li><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a><br />
Zero encoding extreme performance binary serializer for C# and Unity.</li>
<li><a href="https://github.com/Cysharp/csbindgen">csbindgen</a><br />
Generate C# FFI from Rust for automatically brings native code and C native library to .NET and Unity.</li>
<li><a href="https://github.com/Cysharp/DFrame">DFrame</a><br />
Distributed load testing framework for .NET and Unity.</li>
<li><a href="https://github.com/Cysharp/MessagePipe">MessagePipe</a><br />
High performance in-memory/distributed messaging pipeline for .NET and Unity.</li>
<li><a href="https://github.com/Cysharp/UniTask">UniTask</a><br />
Provides an efficient allocation free async/await integration for Unity.</li>
</ul>
<h2>Speaker</h2>
<ul>
<li><a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition - Speaker Deck</a></li>
<li><a href="https://speakerdeck.com/pulse1923/metabasupuratutohuomu-inspix-world-haphpmoc-plus-plus-momatometec-number-nitong-magiconiongazhi-erubatukuendozui-shi-hua-shou-fa">メタバースプラットフォーム 「INSPIX WORLD」はPHPもC++もまとめてC#に統一！ ～MagicOnionが支えるバックエンド最適化手法～ - Speaker Deck</a></li>
<li><a href="https://speakerdeck.com/neuecc/ta-yan-yu-gameinnochang-he-norustnohuo-yong-fa-csbindgenniyoruc-number-x-rust-ffishi-jian-shi-li">他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例 - Speaker Deck</a></li>
</ul>
<h2>Book</h2>
<ul>
<li><a href="https://www.amazon.co.jp/dp/4862465900">Unityプログラミング・バイブル R6号</a></li>
</ul>
<p>世界中見てもこんだけ叩き出してる人間いないので、これだけやってれば、満場一致で更新でいいでしょう。はい。自分で言うのもあれですが。あれ。</p>
<p>期間中で言うと<a href="https://github.com/Cysharp/R3">R3</a>が大型タイトル（？）です。また、Updateのほうも大型リニューアルとして<a href="https://github.com/Cysharp/ZLogger">ZLogger v2</a>は相当力の入ったものになっています。今年の範囲だと、こないだ出した<a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework v5</a>や、近いうちにリリースされる（はず）の<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C# v3</a>といった計画も控えています。なお、<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>は現在メンテナーじゃないので実績に含めてはいないのですが、引き続きアクティブに開発されています！</p>
<p>ところで、このサイトも地味に更新されていて（自作のC#製静的サイトジェネレーターで作られています、ハンドメイド！）、ついに全文検索が搭載されました！上のほうのインプットボックスがそれになっているので、ぜひ試してみてください。ちょっと引っ掛かり方が変な可能性も高いですが、そこは検索ライブラリの仕様なので、いつか改善されるでしょう。多分きっと。</p>
</div>
<h1 data-pagefind-sort="date:2024-06-13" data-pagefind-meta="published:2024-06-13"><a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html">ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク</a></h1>
<ul class="date"><li>2024-06-13</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a>の完全に新しいバージョンをリリースしました。完全に設計しなおして実装も完全に作り直された、何もかもが新しいフレームワークになっています。設計指針として「Zero Dependency, Zero Overhead, Zero Reflection, Zero Allocation, AOT Safe」を掲げ、もちろん、他を圧倒的に引き離すパフォーマンスを実現しています。</p>
<p><img src="https://github.com/Cysharp/ConsoleAppFramework/assets/46207/db4bf599-9fe0-4ce4-801f-0003f44d5628" alt="image" /></p>
<p>これはコールドスタートアップ・ウォームアップなしでのベンチマークとなっていて、CLIアプリケーションでの実際での利用に最も即したものだと考えています。System.CommandLineと比較すれば280倍！メモリアロケーション量もほかのフレームワークの100~1000倍少なくなっています(表示されている400Bはほぼシステム自体のallocなのでフレームワーク自体は0です)。</p>
<p>このパフォーマンスは、全てをSource Generatorで生成することで実現しました。例えば以下のようなコード。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using ConsoleAppFramework;

// args: ./cmd --foo 10 --bar 20
ConsoleApp.Run(args, (int foo, int bar) =&gt; Console.WriteLine($&quot;Sum: {foo + bar}&quot;));
</code></pre>
<p>ConsoleAppFrameworkはSource GeneratorがRunで与えられているラムダ式の引数を解析して、Runメソッドそのものを生成します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal static partial class ConsoleApp
{
    // Generate the Run method itself with arguments and body to match the lambda expression
    public static void Run(string[] args, Action&lt;int, int&gt; command)
    {
        // code body
    }
}
</code></pre>
<p>通常C#のSource Generatorは属性をクラスかメソッドに与えて、それを元に生成されますが、ConsoleAppFrameworkはメソッドの呼び出しを監視して生成のキーにしています。これはRustのマクロから発想を得ていて、Rustには<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Attribute-like macros and Function-like macros</a>といったような分類がありますが、今回のやりかたはFunction-likeなスタイルと言えるでしょう。</p>
<p>実際の生成されるコード全体は以下のようなものになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal static partial class ConsoleApp
{
    public static void Run(string[] args, Action&lt;int, int&gt; command)
    {
        if (TryShowHelpOrVersion(args, 2, -1)) return;

        var arg0 = default(int);
        var arg0Parsed = false;
        var arg1 = default(int);
        var arg1Parsed = false;

        try
        {
            for (int i = 0; i &lt; args.Length; i++)
            {
                var name = args[i];

                switch (name)
                {
                    case &quot;--foo&quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg0)) { ThrowArgumentParseFailed(&quot;foo&quot;, args[i]); }
                        arg0Parsed = true;
                        break;
                    }
                    case &quot;--bar&quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg1)) { ThrowArgumentParseFailed(&quot;bar&quot;, args[i]); }
                        arg1Parsed = true;
                        break;
                    }
                    default:
                        // omit...(case-insensitive compare codes)
                        ThrowArgumentNameNotFound(name);
                        break;
                }
            }
            if (!arg0Parsed) ThrowRequiredArgumentNotParsed(&quot;foo&quot;);
            if (!arg1Parsed) ThrowRequiredArgumentNotParsed(&quot;bar&quot;);

            command(arg0!, arg1!);
        }
        catch (Exception ex)
        {
            Environment.ExitCode = 1;
            if (ex is ValidationException or ArgumentParseFailedException)
            {
                LogError(ex.Message);
            }
            else
            {
                LogError(ex.ToString());
            }
        }
    }

    static partial void ShowHelp(int helpId)
    {
        Log(&quot;&quot;&quot;
Usage: [options...] [-h|--help] [--version]

Options:
  --foo &lt;int&gt;     (Required)
  --bar &lt;int&gt;     (Required)
&quot;&quot;&quot;);
    }
}
</code></pre>
<p>特にひねりもなさそうなド直球ドシンプルなコードに見えるのではないでしょうか。それが大事です！単純なコードであればあるほど速い！フレームワークなのに単純、だから速い。というのが目指している姿です。余計なコードはいっさいなく、メソッド本体に全ての処理が集約されているので、フレームワークとしてゼロ・オーバーヘッド、最適化した手書きコードと同等の速度を実現しました。</p>
<p>CLIアプリケーションは通常、コールドスタートからの単発の実行になるため、動的コード生成(IL.EmitやExpression.Compile)やキャッシュ(ArrayPoolやDictionary生成による以降のマッチング高速化)が効きにくい分野です。それらを作ったほうがオーバーヘッドが大きいですから。かといってリフレクションなどをそのまま使うのは、それはそれで低速です。ConsoleAppFrameworkは全ての必要な処理をインライン生成することによって、単発実行での速度が圧倒的に高速化されています。</p>
<p>リフレクションもないのでNative AOTとの親和性も圧倒的に高く、コールドスタートアップ速度におけるC#の欠点は一切なくなります。</p>
<p>もう一つ特徴として、<code>ConsoleApp</code>クラスを含めて、全てがSource Generatorによって生成されるために、ConsoleAppFramework自体も含めて依存が全くありません。</p>
<p>コンソールアプリケーションを作るシチュエーションは多用です。多数の依存を持った大きなバッチアプリケーションの場合もあれば、超単機能の小さなコマンドの場合もあります。小さなコマンドを作りたい時には、少しも追加の依存を入れたくはないでしょう。それこそ <code>Microsoft.Extensions.Hosting</code> を参照すると、それだけで数十個の依存DLLが追加されてしまいます！ConsoleAppFrameworkなら、自身も含めて依存ゼロです。</p>
<p>依存ゼロの良いところは明らかにバイナリサイズが小さくなることです。特にNative AOTではバイナリサイズは気になるところですが、ConsoleAppFrameworkなら追加のコストはほぼゼロです。</p>
<p>そしてもちろん、単機能ではフレームワークとしては物足りない、ということで以下のような機能が実現されています。十分に充実した機能群は、他のフレームワークと比べても全く見劣りしないはずです。</p>
<ul>
<li>SIGINT/SIGTERM(Ctrl+C) handling with gracefully shutdown via <code>CancellationToken</code></li>
<li>Filter(middleware) pipeline to intercept before/after execution</li>
<li>Exit code management</li>
<li>Support for async commands</li>
<li>Registration of multiple commands</li>
<li>Registration of nested commands</li>
<li>Setting option aliases and descriptions from code document comment</li>
<li><code>System.ComponentModel.DataAnnotations</code> attribute-based Validation</li>
<li>Dependency Injection for command registration by type and public methods</li>
<li><code>Microsoft.Extensions</code>(Logging, Configuration, etc...) integration</li>
<li>High performance value parsing via <code>ISpanParsable&lt;T&gt;</code></li>
<li>Parsing of params arrays</li>
<li>Parsing of JSON arguments</li>
<li>Help(<code>-h|--help</code>) option builder</li>
<li>Default show version(<code>--version</code>) option</li>
</ul>
<p>生成されるコードはモジュール化されていて、コードが使用する機能によって変化し、常にその機能の実現において最小のコードが生成されるようになっています。それにより多機能と高速さを両立しています。また、どの機能も最速で実行できるよう念入りに調整してあるため、全機能が有効化されてもなお、他とは比較にならないほどに高速です。</p>
<p>余談ですが、デリゲートはデリゲート生成というアロケーションがあります。つまり真のゼロアロケーション・ゼロオーバーヘッドじゃないじゃん、と言うことができます。しかし、ちゃんとConsoleAppFrameworkは真のゼロアロケーションを実現する仕組みもちゃんと用意されています。以下のように静的関数をfunction pointerとして渡してください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">unsafe
{
    ConsoleApp.Run(args, &amp;Sum);
}

static void Sum(int x, int y) =&gt; Console.Write(x + y);
</code></pre>
<p>すると、以下のような <code>delegate* managed&lt;&gt;</code> （あまり見慣れないと思いますが、managed function pointerという言語機能がC#には追加されているのです）の引数を持ったメソッドの実体を生成します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static unsafe void Run(string[] args, delegate* managed&lt;int, int, void&gt; command)
</code></pre>
<p>これならもう完全に文句なくゼロアロケーション・ゼロオーバーヘッドです！</p>
<p>実用的には別にデリゲートでも全く関係ないレベルですが、完全に完璧を目指す執拗な姿勢により、対応を入れました。これでどの角度からも絶対に文句は付けられないでしょう。</p>
<h2>高速な値変換</h2>
<p>文字列からC#の値に変換する最速の手段はなんでしょうか？intだったら <code>int.TryParse</code> ですよね。では、他は？intは決め打ちだからいいとして、string -&gt; T(あるいはobject)を汎用的にするには？というと少し難しい話になってきて、昔は<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.componentmodel.typeconverter?view=net-8.0">TypeConverter</a>というものが使われてきました。もちろん、パフォーマンスは悪いです。</p>
<p>あるいは最近はJsonSerializerが標準搭載されているから、それに丸投げしてみるというのもアリでしょう。もちろん、パフォーマンスは決して良くはありません。特にコールドスタートアップで考えるとJsonSerializerのキャッシュ処理が必要になってきて、単発実行においてはかなりのオーバーヘッドが足されてしまいます。</p>
<p>ConsoleAppFrameworkでは<a href="https://learn.microsoft.com/en-us/dotnet/api/system.iparsable-1?view=net-8.0">IParsable</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1?view=net-8.0">ISpanParsable</a>を採用しています。これは .NET 7から追加され、C# 11で追加されたstatic abstract interfaceが使用されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IParsable&lt;TSelf&gt; where TSelf : IParsable&lt;TSelf&gt;?
{
	static abstract TSelf Parse(string s, IFormatProvider? provider);
	static abstract bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out TSelf result);
}
</code></pre>
<p>C# 11になってようやく汎用的な 「文字列 -&gt; 値」変換処理が実現するようになったのです！ ConsoleAppFrameworkでは .NET 8/C# 12 を最小実行可能環境としているため、問答無用で採用しました。HalfやInt128などの .NET 8で登場した新しい型や、自分で定義する方も<code>IParsable&lt;T&gt;</code>を実装すればそれを使って高速に処理されます！</p>
<p>とはいえ、intなどの基本型はそもそもSource Generatorがintであることを知っているので、直接int.TryParseのように直接実行されるようになっていたりはします。</p>
<p>なお、値のバインディングに関してはparams arrayやデフォルト値にも対応しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">ConsoleApp.Run(args, (
    [Argument]DateTime dateTime,  // Argument
    [Argument]Guid guidvalue,     // 
    int intVar,                   // required
    bool boolFlag,                // flag
    MyEnum enumValue,             // enum
    int[] array,                  // array
    MyClass obj,                  // object
    string optional = &quot;abcde&quot;,    // optional
    double? nullableValue = null, // nullable
    params string[] paramsArray 
    ) =&gt; { });
</code></pre>
<p>ちょうどC# 12から<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression">ラムダ式にデフォルト値やparamsが使用できるようになりました</a>、ということが反映されています。</p>
<h2>ドキュメントコメントによる定義</h2>
<p>DescriptionやAliasの追加は、今までは、あるいは他のフレームワークでは属性を使って記述していました。しかし、それは少しメソッドの各パラメーターに属性、更にかなり長めの文字列を付与するのは、メソッドとしてかなり読みづらくなります。</p>
<p>そこでConsoleAppFrameworkではドキュメントコメントを活用することにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class Commands
{
    /// &lt;summary&gt;
    /// Display Hello.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;message&quot;&gt;-m, Message to show.&lt;/param&gt;
    public static void Hello(string message) =&gt; Console.Write($&quot;Hello, {message}&quot;);
}
</code></pre>
<p>これは</p>
<pre data-pagefind-ignore="all"><code class="language-txt">Usage: [options...] [-h|--help] [--version]

Display Hello.

Options:
  -m|--message &lt;string&gt;    Message to show. (Required)
</code></pre>
<p>というコマンドになります。ドキュメントコメントであれば、多くの引数があっても自然な見た目を保つことが可能です。この手法が取れるのはSource Generatorで生成するため.xmlは不要でコードから直接読み取れることの強みでもありますね。（ただしSource Generatorでドキュメントコメントをあらゆる環境で読み取れるようにするには若干のハックが必要でした）</p>
<h2>複数コマンドの追加</h2>
<p><code>ConsoleApp.Run</code>は単独コマンドのためのショートカットでしたが、複数のコマンドやネストされているサブコマンドの追加も可能です。例えば以下のような設定を行った場合の生成を例を見ていきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create();

app.Add(&quot;foo&quot;, () =&gt; { });
app.Add(&quot;foo bar&quot;, (int x, int y) =&gt; { });
app.Add(&quot;foo bar barbaz&quot;, (DateTime dateTime) =&gt; { });
app.Add(&quot;foo baz&quot;, async (string foo = &quot;test&quot;, CancellationToken cancellationToken = default) =&gt; { });

app.Run(args);
</code></pre>
<p>このコードのAddは、まず以下のように展開されます。Source Generatorが全てのAddされるラムダ式の型を知っているので、それぞれ固有の型を持ったフィールドに割り当てます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">partial struct ConsoleAppBuilder
{
    Action command0 = default!;
    Action&lt;int, int&gt; command1 = default!;
    Action&lt;global::System.DateTime&gt; command2 = default!;
    Func&lt;string, global::System.Threading.CancellationToken, Task&gt; command3 = default!;

    partial void AddCore(string commandName, Delegate command)
    {
        switch (commandName)
        {
            case &quot;foo&quot;:
                this.command0 = Unsafe.As&lt;Action&gt;(command);
                break;
            case &quot;foo bar&quot;:
                this.command1 = Unsafe.As&lt;Action&lt;int, int&gt;&gt;(command);
                break;
            case &quot;foo bar barbaz&quot;:
                this.command2 = Unsafe.As&lt;Action&lt;global::System.DateTime&gt;&gt;(command);
                break;
            case &quot;foo baz&quot;:
                this.command3 = Unsafe.As&lt;Func&lt;string, global::System.Threading.CancellationToken, Task&gt;&gt;(command);
                break;
            default:
                break;
        }
    }
}
</code></pre>
<p>これによりDelegateを保持しておくための配列や、DelegateのままInvokeするリフレクション/ボクシングが防げています。</p>
<p>Runでは、<code>string[] args</code>からコマンドを選択するために定数文字列のswitchが埋め込まれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">partial void RunCore(string[] args)
{
    if (args.Length == 0)
    {
        ShowHelp(-1);
        return;
    }
    switch (args[0])
    {
        case &quot;foo&quot;:
            if (args.Length == 1)
            {
                RunCommand0(args, args.AsSpan(1), command0);
                return;
            }
            switch (args[1])
            {
                case &quot;bar&quot;:
                    if (args.Length == 2)
                    {
                        RunCommand1(args, args.AsSpan(2), command1);
                        return;
                    }
                    switch (args[2])
                    {
                        case &quot;barbaz&quot;:
                            RunCommand2(args, args.AsSpan(3), command2);
                            break;
                        default:
                            RunCommand1(args, args.AsSpan(2), command1);
                            break;
                    }
                    break;
                case &quot;baz&quot;:
                    RunCommand3(args, args.AsSpan(2), command3);
                    break;
                default:
                    RunCommand0(args, args.AsSpan(1), command0);
                    break;
            }
            break;
        default:
            ShowHelp(-1);
            break;
    }
}
</code></pre>
<p>C#で文字列から特定のコードにジャンプする最速の手段は、switchで文字列定数を使うことです。展開されるアルゴリズムは何度か修正されていて、C# 12では<a href="https://github.com/dotnet/roslyn/issues/56374">Performance: faster switch over string objects · Issue #56374 · dotnet/roslyn</a>として、まず長さをチェックした後に、差が存在する1文字だけを絞るといった形でマッチさせます。</p>
<p><code>Dictionary&lt;string, T&gt;</code>からのマッチなどよりも高速で初期化時間もアロケーションもないのが、C#コンパイラの助けを借りれる強みであり、そうした処理ができるのはC#コードそのものを出力するSource Generator方式だけです。なので絶対に最速なわけです。</p>
<h2>DIとCancellationTokenとライフタイム</h2>
<p>引数にはコマンドのパラメーターとして有効になるもの以外に、DI経由で渡したいもの(例えば<code>ILogger&lt;T&gt;</code>や<code>Option&lt;T&gt;</code>など)や、特別扱いする型として<code>ConsoleAppContext</code>と<code>CancellationToken</code>を定義することができます。</p>
<p>DIによる受取は、コンソールアプリケーションがASP.NETのプロジェクトなどと設定ファイルを共有したいようなシチュエーションで有効でしょう。そうした場合のために、 Microsoft.Extensions.Hosting と連動させることが可能です。</p>
<p>また、<code>CancellationToken</code>を渡した場合は、SIGINT/SIGTERM/SIGKILL(Ctrl+C)をフックするコンソールアプリケーションとしてのライフタイム管理が働くようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">await ConsoleApp.RunAsync(args, async (int foo, CancellationToken cancellationToken) =&gt;
{
    await Task.Delay(TimeSpan.FromSeconds(5), cancellationToken);
    Console.WriteLine($&quot;Foo: {foo}&quot;);
});
</code></pre>
<p>上記のコードは以下のように展開されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using var posixSignalHandler = PosixSignalHandler.Register(ConsoleApp.Timeout);
var arg0 = posixSignalHandler.Token;

await Task.Run(() =&gt; command(arg0!)).WaitAsync(posixSignalHandler.TimeoutToken);
</code></pre>
<p>.NET 6から追加された<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration?view=net-8.0">PosixSignalRegistration</a>を使って、SIGINT/SIGTERM/SIGKILLがフックし、CancellationTokenをキャンセルの状態にします。と同時に、即時終了を抑制します(通常Ctrl + Cを押すと即座にAbortされますが、Abortされなくなります)。</p>
<p>それによりアプリケーションがCancellationTokenを正常にハンドリングする余地を残しています。</p>
<p>ただしCancellationTokenをハンドリングしないと終了命令を無視するだけになってしまい、それはそれで困るので、強制的に終了するタイムアウト時間が設けられています。デフォルトでは5秒に設定されていますが、これは <code>ConsoleApp.Timeout</code> プロパティで自由に変更できます。もし強制終了をオフにしたい場合は <code>ConsoleApp.Timeout = Timeout.InfiniteTimeSpan</code> を指定すると良いでしょう。</p>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.waitasync?view=net-8.0">Task.WaitAsync</a>は .NET 6 からです。TimeSpanを渡す以外に、CancellationTokenを渡すことも可能なので、単純な数秒後ではなく、WaitAsyncの発火するタイミングをPosixSignalRegistrationが発火した後にTimeout後、といった条件を作ることができました。</p>
<h2>フィルターパイプライン</h2>
<p>実行の前後をフックする仕組みとしてConsoleAppFrameworkではFilterを採用しています。ミドルウェアパターンとも呼ばれて、特にasync/awaitが使える言語ではよく見かけるパターンだと思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal class NopFilter(ConsoleAppFilter next) : ConsoleAppFilter(next) // ctor needs `ConsoleAppFilter next` and call base(next)
{
    // implement InvokeAsync as filter body
    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        try
        {
            /* on before */
            await Next.InvokeAsync(context, cancellationToken); // invoke next filter or command body
            /* on after */
        }
        catch
        {
            /* on error */
            throw;
        }
        finally
        {
            /* on finally */
        }
    }
}
</code></pre>
<p>この設計パターンは本当に優れていて、実行をフックしたいような仕組みを用意したい場合は、このパターンを採用することを絶対にお薦めします。GoFの時代にasync/awaitがあったら、重要なデザインパターンとして載っていたことでしょう。</p>
<p>ReadMeにはフィルターでできることとして、実行時間のロギング・ExitCodeのカスタマイズ・多重実行禁止・認証処理などを紹介しています。<code>Task InvokeAsync</code>一つで様々な処理を実現できる素晴らしさ。誰がこのパターンを最初に発見したんでしょうね？</p>
<p>フィルターの設計にも色々な手法があるのですが、ConsoleAppFrameworkでは最もパフォーマンスの出る方法を選びました。コンストラクターでNextを受け取ることと、コードジェネレート時に静的に全ての利用するフィルターが決定するので（動的な追加は許可していません）、全てを埋め込んで組み立てています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">app.UseFilter&lt;NopFilter&gt;();
app.UseFilter&lt;NopFilter&gt;();
app.UseFilter&lt;NopFilter&gt;();
app.UseFilter&lt;NopFilter&gt;();
app.UseFilter&lt;NopFilter&gt;();

// The above code will generate the following code:

sealed class Command0Invoker(string[] args, Action command) : ConsoleAppFilter(null!)
{
    public ConsoleAppFilter BuildFilter()
    {
        var filter0 = new NopFilter(this);
        var filter1 = new NopFilter(filter0);
        var filter2 = new NopFilter(filter1);
        var filter3 = new NopFilter(filter2);
        var filter4 = new NopFilter(filter3);
        return filter4;
    }

    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        return RunCommand0Async(context.Arguments, args, command, context, cancellationToken);
    }
}
</code></pre>
<p>これにより、中間の配列のアロケーションや、ラムダ式のキャプチャのアロケーションは発生せず、フィルターの個数 + 1(メソッド本体のラップ)の追加のアロケーションのみが追加のコストとなります。また、戻り値のTaskは、同期的に完了する場合はTask.Completed相当のものが使われることになるため、これをValueTaskにする必要はありません。</p>
<p>コンストラクターでNextを受け取ってbaseに渡すだけのコードも、primary constructorのお陰で簡単に書けるようになりました。</p>
<h2>コマンドライン引数の構文について</h2>
<p>コマンドライン引数はスペース区切りで<code>string[] args</code>に渡されるということ以外は、完全に自由です。なんとなく <code>--</code>や<code>-</code>がパラメーター識別子だと思われていますが、実際はなんでもいいし、なんだったらWindowsは<code>/</code>が使われることも多かった。</p>
<p>とはいえ、ある程度標準的なルールは存在します。代表的なものは<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">POSIX規格</a>と、その拡張である<a href="https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html">GNU Coding Standards</a>でしょうか。ConsoleAppFrameworkでも、POSIX規格にある程度は従いつつ、GNU Coding Stadardsで定義されている <code>--version</code> と <code>--help</code> を組み込みのオプションとしています。名前も <code>--lower-kebab-case</code> がデフォルトです。</p>
<p>「ある程度」というのは、つまり、完全に従っているというわけではありません。規格にせよ伝統的な慣習にせよ、古いルールは現代的な観点から許容すべきでないルールも少なくありません。例えば<code>-x</code>と<code>-X</code>が区別されて異なる挙動をするというのは絶対にナシでしょう。あるいは広く使われているものでもバンドリング、<code>-fdx</code>は<code>-f</code>, <code>-d</code>, <code>-x</code>と解釈されるといったものも、あまり良いとは思えません。バンドリングに関しては、パフォーマンス上でも、パース処理を複雑化させるため問題があります。</p>
<p>ConsoleAppFrameworkで優先しているのはパフォーマンスであるため、パフォーマンス上問題を引き起こす可能性のあるルールに関しては採用していません。大文字小文字の区別はしないようにしていますが、これは小文字のマッチングを先に行った後、フォールバックとしてcase-insensitiveのマッチングを行うため、実用上のパフォーマンスの低下は起こらないと考えています。</p>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/standard/commandline/syntax">System.CommandLine のコマンド ライン構文の概要 - .NET | Microsoft Learn</a>を見ると、System.CommandLineがかなり柔軟な構文解釈を可能にしていることがわかるでしょう。それはとても良いことです！良いことではあるのですが、パフォーマンス劣化を引き起こしているなら問題です。そして実際、System.CommandLineの性能はベンチマーク結果から明らかなとおり、非常に悪い。これはちょっといただけません。</p>
<p>迷走を続けている<a href="https://github.com/dotnet/command-line-api">System.CommandLine</a>は、どうやら再度分解されて実装を変更するようです。<a href="https://github.com/dotnet/command-line-api/issues/2338">Resetting System.CommandLine</a>ということで、POSIX規格のパーサーとしての小さなコアを.NET 9 あるいは .NET 10で標準採用されることを目指している、ようです。</p>
<p>もしそれらが標準採用されたとしても、パフォーマンスの観点からは、ConsoleAppFrameworkを超えることは絶対にないでしょう。</p>
<h2>v4からの互換性について</h2>
<p>破壊的変更！破壊的変更を厭わないことはいいことです、イノベーションを妨げない、常に先端的であり続けるために必要なことです。C#の先端を走り続けるのはCysharpのアイデンティティでもあります。と、同時に、もちろん大迷惑なことです。今回の v4 -&gt; v5 に関しては .NET Frameworkから.NET Coreに変わったような、 ASP.NET から ASP.NET Coreに変わったような、そんな変革なのでしょうがない、どうしても必要な変化だったのだ……。</p>
<p>ただし、実際のところは別にそこまで大きく変わっているわけではなかったりもします。名前変換処理(lower-kebab-case)のロジックは同じものを使っているため、名前がズレてしまうといったこともないので、コンパイルエラー出たメソッド名をマッピングするだけ、ではあります。そのぐらいのことはよくある、よね？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create(args); app.Run(); -&gt; var app = ConsoleApp.Create(); app.Run(args);
app.AddCommand/AddSubCommand -&gt; app.Add(string commandName)
app.AddRootCommand -&gt; app.Add(&quot;&quot;)
app.AddCommands&lt;T&gt; -&gt; app.Add&lt;T&gt;
app.AddSubCommands&lt;T&gt; -&gt; app.Add&lt;T&gt;(string commandPath)
app.AddAllCommandType -&gt; NotSupported(use Add&lt;T&gt; manually)
[Option(int index)] -&gt; [Argument]
[Option(string shortName, string description)] -&gt; Xml Document Comment
ConsoleAppFilter.Order -&gt; NotSupported(global -&gt; class -&gt; method declrative order)
ConsoleAppOptions.GlobalFilters -&gt; app.UseFilter&lt;T&gt;
</code></pre>
<p>全体的には、より単純化された、ようするに「良くなった」と思ってもらえる仕様変更だとは思います。</p>
<p>また、標準で <code>Microsoft.Extensions.Hosting</code> に乗っからなくなったというのは大きな違いですが、これは一行追加するだけで解決します。Hostingの上に乗っかるというのは、つまりはHostingで生成するServiceProviderを使う、それだけのことなのだ、と。実際はLifetime管理もありますが、それはConsoleAppFrameworkが自前でやっているので、DIのためのServiceProviderだけ渡してやれば実用上の違いはありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using var host = Host.CreateDefaultBuilder().Build(); // use using for host lifetime
ConsoleApp.ServiceProvider = host.ServiceProvider;
</code></pre>
<p>v4では<code>ConsoleAppBase</code>を継承させていましたが、v5ではPOCOでよくなりました。代わりに<code>ConsoleAppContext</code>や<code>CancellationToken</code>に関してはコンストラクタインジェクションで受け取ってください。これも、C# 12のprimary constructorのお陰でそんなに手間じゃなくなりました。これもベースクラスを必要とする仕組みをやめた理由の一つになります。</p>
<h2>真のIncremental Generator</h2>
<p>Incremental Generatorって、ただたんに何も考えずに作るとIncrementalにならないのです。というのは知識として知ってはいたのですが、今まで見て見ぬふりをしていました！ありがたいことに指摘が入ったので、重い腰を上げてちゃんと抜本的な対応を取ることにしました。</p>
<p>まず最初にやらなければならないのは、Incrementalであるかどうかを視認できるようにすることです。普通に動かしていても内部状態は全く見えないので、ユニットテストで状態をチェックできるようにすることが大事です。例えばこんなユニットテストが書かれています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">    [Fact]
    public void RunLambda()
    {
        var step1 = &quot;&quot;&quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&gt; 0);
&quot;&quot;&quot;;

        var step2 = &quot;&quot;&quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&gt; 100); // body change

Console.WriteLine(&quot;foo&quot;); // unrelated line
&quot;&quot;&quot;;

        var step3 = &quot;&quot;&quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int (int x, int y) =&gt; 100); // change signature

Console.WriteLine(&quot;foo&quot;);
&quot;&quot;&quot;;

        var reasons = CSharpGeneratorRunner.GetIncrementalGeneratorTrackedStepsReasons(&quot;ConsoleApp.Run.&quot;, step1, step2, step3);

        reasons[0][0].Reasons.Should().Be(&quot;New&quot;);
        reasons[1][0].Reasons.Should().Be(&quot;Unchanged&quot;);
        reasons[2][0].Reasons.Should().Be(&quot;Modified&quot;);

        VerifySourceOutputReasonIsCached(reasons[1]);
        VerifySourceOutputReasonIsNotCached(reasons[2]);
    }
</code></pre>
<p>Incremental Generatorは <code>trackIncrementalGeneratorSteps: true</code> というオプションを渡してDriverを動かすと、各ステップの状態の結果が見えるようになります。<code>IncrementalStepRunReason</code>には<code>New</code>, <code>Unchanged</code>, <code>Modified</code>, <code>Cached</code>, <code>Removed</code> という状態があり、最終出力の手前が<code>Unchanged</code>か<code>Cached</code>なら、出力処理がスキップされます。</p>
<p>上のユニットテストではstep2では出力コードに変更のない箇所に変更が加わっただけなので、Unchangedです。なので最終段ではCachedになっていました。step3は再生成が必要な変更が加わっているのでModifiedとなり、ソースコード生成処理まで走ります。</p>
<p><code>IncrementalStepRunReason</code>は<code>TrackedSteps</code>から取り出すことが出来るのですが、そのままだとちょっと読みづらすぎるので、確認しやすいように整形しています、というのが<code>GetIncrementalGeneratorTrackedStepsReasons</code>というユーティリティメソッドです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static (string Key, string Reasons)[][] GetIncrementalGeneratorTrackedStepsReasons(string keyPrefixFilter, params string[] sources)
{
    var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp12); // 12
    var driver = CSharpGeneratorDriver.Create(
        [new ConsoleAppGenerator().AsSourceGenerator()],
        driverOptions: new GeneratorDriverOptions(IncrementalGeneratorOutputKind.None, trackIncrementalGeneratorSteps: true))
        .WithUpdatedParseOptions(parseOptions);

    var generatorResults = sources
        .Select(source =&gt;
        {
            var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));
            driver = driver.RunGenerators(compilation);
            return driver.GetRunResult().Results[0];
        })
        .ToArray();

    var reasons = generatorResults
        .Select(x =&gt; x.TrackedSteps
            .Where(x =&gt; x.Key.StartsWith(keyPrefixFilter) || x.Key == &quot;SourceOutput&quot;)
            .Select(x =&gt;
            {
                if (x.Key == &quot;SourceOutput&quot;)
                {
                    var values = x.Value.Where(x =&gt; x.Inputs[0].Source.Name?.StartsWith(keyPrefixFilter) ?? false);
                    return (
                        x.Key,
                        Reasons: string.Join(&quot;, &quot;, values.SelectMany(x =&gt; x.Outputs).Select(x =&gt; x.Reason).ToArray())
                    );
                }
                else
                {
                    return (
                        Key: x.Key.Substring(keyPrefixFilter.Length),
                        Reasons: string.Join(&quot;, &quot;, x.Value.SelectMany(x =&gt; x.Outputs).Select(x =&gt; x.Reason).ToArray())
                    );
                }
            })
            .OrderBy(x =&gt; x.Key)
            .ToArray())
        .ToArray();

    return reasons;
}
</code></pre>
<p>ごちゃごちゃしてよくわからないという感じですが、つまりそのままだと本当によくわからない代物ということで。Keyに関しては各ステップで <code>.WithTrackingName(&quot;ConsoleApp.Run.0_CreateSyntaxProvider&quot;)</code> のような命名規則で付与しています。TrackedStepsが<code>ImmutableDictionary</code>のため列挙の順番が順不同でイマイチ確認しづらいので、番号振ってソートするようにしました。また、複数のRegisterSourceOutputが走っていると(ConsoleAppFrameworkではRun系とBuilder系の2種が動いてる)混線してわかりづらくなるため、keyPrefixとしてフィルタリングするようにしています。</p>
<p>注意すべき点とか、いい感じに作る方法とか、色々説明しておかなければならないことが多いのですが、めちゃくちゃ長くなるので、それはまたの機会ということで……！</p>
<h2>まとめ</h2>
<p>もともとConsoleAppFrameworkはCysharpの製品ラインでは珍しく、パフォーマンスを重視していたわけではない、という成り立ちがあります。どちらかというと機能面、当時それなりに珍しかったHostingと融合してCLIフレームワークを作るといったコンセプトの立証を主軸に作り上げ、そして一定の成果を挙げました。何回かの改修でHelpがリッチになったりMinimal APIっぽく書けるようになったりもしましたが、どうしても古くささが目立ってきました。</p>
<p>特に<a href="https://github.com/mayuki/Cocona">Cocona</a>は、ConsoleAppFrameworkの影響を受けつつも、より柔軟で、より強力な機能を備えていてとても素晴らしいライブラリです。このままではConsoleAppFrameworkはただの劣化版ではないか、という意識もありました。自信をもってベストであると薦められないのは心苦しい。というかCoconaを作っているのはCysharpの同僚ですしですの。</p>
<p>なので、今回APIの幾つかは逆にCoconaからの影響を受けつつ(<code>[Argument]</code>など)、全く異なるキャラクターを持ったフレームワークとなるように腐心しました。パースについての項目で説明したように、ConsoleAppFramework v5は柔軟性をある程度犠牲にしているため、豊富な機能が必要ならば、System.CommandLineやCoconaを使用することをお薦めします。</p>
<p>また、パフォーマンスの観点から言うと、本体の実行時間が長ければ長いほどフレームワークのオーバーヘッドなんてどうでもよくはなります。10分、1分、いや、10秒ぐらいかかる処理であるなら、フレームワーク部分が1msだろうと50msだろうと誤差みたいなものでしょう。それはそもそもJITコンパイルにも言えることではありますが。とはいえ、Native AOTだのコールドスタートアップ速度だのがやいやい言われる昨今では、別にそんなもの無視できる程度の話だろう、と一刀両断できるわけでもなく、早いに越したことはないのは間違いないとも言えます。</p>
<p>パフォーマンスや依存性なしといったメリットはもちろんですが、アプローチや設計面でも特異で面白いものになっていると思いますので、是非お試しください！もちろん、実用性もめちゃくちゃ高く、文句なしに必須ライブラリと考えてもらってもいいのではないでしょうか！</p>
</div>
<h1 data-pagefind-sort="date:2024-05-01" data-pagefind-meta="published:2024-05-01"><a href="https://neue.cc/2024/05/01_R3_Presentation.html">R3のコードから見るC#パフォーマンス最適化技法実例とTimeProviderについて</a></h1>
<ul class="date"><li>2024-05-01</li></ul>
<div class="entry_body"><p>4/27に大阪で開催された<a href="https://cs-reading.connpass.com/event/309714/">C#パフォーマンス勉強会</a>で「R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例」という題でセッションしてきました！</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/205627770b434599925567dbfeca229c" title="R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>タイトル的にあまりLINQでもコンカレントでもなかったかな、とは思いますが、<a href="https://github.com/Cysharp/R3">R3</a>を題材に、具体的なコードをもとにした最適化技法の紹介という点では面白みはあったのではないかと思います。</p>
<h2>Rxの定義</h2>
<p>R3は、やや挑発的な内容を掲げていることもあり、R3は「Rxではない」みたいなことを言われることもあります。なるほど！では、そもそも何をもってRxと呼ぶのか、呼べるのか。私は「Push型でLINQ風のオペレーターが適用できればRx」というぐらいの温度感で考えています。もちろん、R3はそれを満たしています。</p>
<p><code>mutable struct</code>の扱いと同じく、あまり教条主義的にならず、時代に合わせて、柔軟により良いシステムを考えていきましょう。コンピュータープログラミングにおいて、伝統や歴史を守ることは別に大して重要なことではないはずです。</p>
<h2>TimeProvider DeepDive</h2>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>について、セッションでも話しましたが、大事なことなのでもう少し詳しくいきましょう。TimeProviderにまず期待するところとしては、ほとんどが<code>SystemClock.Now</code>、つまりオレオレ<code>DateTime.Now</code>生成器の代わりを求めているでしょう。それを期待しているとTimeProviderの定義は無駄に複雑に見えます。しかし<code>TimeProvider</code>を分解してみると、これは4つの時間を司るクラスの抽象層になっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public abstract class TimeProvider
{
    // TimeZoneInfo
    public virtual TimeZoneInfo LocalTimeZone =&gt; TimeZoneInfo.Local;

    // DateTimeOffset
    public virtual DateTimeOffset GetUtcNow() =&gt; DateTimeOffset.UtcNow;
    public DateTimeOffset GetLocalNow() =&gt;

    // Stopwatch
    public virtual long TimestampFrequency =&gt; Stopwatch.Frequency;
    public virtual long GetTimestamp() =&gt; Stopwatch.GetTimestamp();
    public TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp) =&gt; 
    public TimeSpan GetElapsedTime(long startingTimestamp) =&gt; GetElapsedTime(startingTimestamp, GetTimestamp());

    // System.Threading.Timer
    public virtual ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period) =&gt;
}

public interface ITimer : IDisposable, IAsyncDisposable
{
    bool Change(TimeSpan dueTime, TimeSpan period);
}
</code></pre>
<p>4つの時間を司るクラス、すなわち<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timezoneinfo?view=net-8.0">TimeZoneInfo</a>、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.datetimeoffset?view=net-8.0">DateTimeOffset</a>、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch?view=net-8.0">Stopwatch</a>、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.threading.timer?view=net-8.0">System.Threading.Timer</a>。</p>
<p>この造りになっているからこそ、あらゆる時間にまつわる挙動を任意に変更することができるのです。</p>
<p>挙動を任意に変更するというとユニットテストでの時間のモックにばかり意識が向きますが（実際、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.time.testing.faketimeprovider?view=net-8.0">FakeTimeProvider</a>はとても有益です）、別にユニットテストに限らず、優れた時間の抽象化層として使うことができます。ということを実装とともに証明したのがR3で、特にR3では<code>CreateTimer</code>をかなり弄っていて、WPFではDispatcherTimerを使うことで自動的にUIスレッドにディスパッチしたり、UnityではPlayerLoopベースのタイマーとしてScaledとUnsacledでTimescaleの影響を受けるタイマー・受けないタイマーなどといった実行時のカスタマイズ性を実現しました。</p>
<p>セッションではStopwatchについてフォーカスしました。二点の時刻の経過時間を求めるのにDateTimeの引き算、つまり</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">DateTime now = DateTime.UtcNow;
/* do something... */
TimeSpan elapesed = DateTime.UtcNow - now;
</code></pre>
<p>といったコードを書くのはよくあることですが、これはバッドプラクティスです。DateTimeの取得はタダではありません。では、なるほどStopwatchですね？ということで</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Stopwatch sw = Stopwatch.StartNew();
/* do something... */
TimeSpan elapsed = sw.Elapsed;
</code></pre>
<p>これは、Stopwatchがclassなのでアロケーションがあります。うまく使いまわしてあげる必要があります。
使いまわしができないシチュエーションのために、アロケーションを避けるためにstructのStopwatch、ValueStopwatchといったカスタム型を作ることもありますが、待ってください、そもそもStopwatchが不要です。</p>
<p>二点の経過時間を求めるなら、時計による時刻も不要で、その地点の何らかのタイムスタンプが取れればそれで十分なのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// .NET 7以降での手法(GetElapsedTimeが追加された)
long timestamp = Stopwatch.GetTimestamp();
/* do something... */
TimeSpan elapsed = Stopwatch.GetElapsedTime(timestamp);
</code></pre>
<p>このlongは、通常は高解像度タイムスタンプ、Windowsでは<a href="https://learn.microsoft.com/ja-jp/windows/win32/sysinfo/acquiring-high-resolution-time-stamps">QueryPerformanceCounter</a>が使われています。TimeSpanでよく使うTicksではないことに注意してください。</p>
<p>ベンチマークを取ってみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using BenchmarkDotNet.Attributes;
using System.Diagnostics;

BenchmarkDotNet.Running.BenchmarkRunner.Run&lt;TimestampBenchmark&gt;();

public class TimestampBenchmark
{
    [Benchmark]
    public long Stopwatch_GetTimestamp()
    {
        return Stopwatch.GetTimestamp();
    }

    [Benchmark]
    public DateTime DateTime_UtcNow()
    {
        return DateTime.UtcNow;
    }

    [Benchmark]
    public DateTime DateTime_Now()
    {
        return DateTime.Now;
    }
}
</code></pre>
<p><img src="https://github.com/Cysharp/R3/assets/46207/75122cc7-c303-493f-bc78-40388529cf60" alt="image" /></p>
<p>NowではUtcNowに加えてTimeZoneからのオフセット算出が入るために更にもう一段遅くなります。</p>
<p>ちなみに、2点間の時間の算出にDateTimeではなくTimestampを使うもう一つの利点としては、システム時間の変更の影響を受けないという点があります。dotnet/reactiveではISchedulerがDateTimeOffsetベースで作られていたため、ISchedulerインターフェイスそのものがこの問題の影響を避けられないために、内部的にゴチャゴチャしたハックが繰り返され、パフォーマンスの大幅な劣化にも繋がっていました。</p>
<p>なお、マイクロベンチマークを取るときは必ず<a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>を使ってください。(micro)benchmark is hard、です。Stopwatchで測られても、あらゆる要因から誤差が出まくるし、そもそも指標もよくわからないしで、数字を見ても何もわかりません。私はそういう数字の記事とかを見た場合、役に立たないと判断して無視します。</p>
<h2>まとめ</h2>
<p>セッション資料に盛り込めた最適化技法の紹介は極一部ではありますが、R3がどれだけ気合い入れて作られているかが伝わりましたでしょうか？10年の時を経て、私自身の成長とC#の成長が合わさり、UniRxからクオリティが桁違いです。</p>
<p>これからも足を止めずにやっていきますし、みなさんも是非モダンC#やっていきましょう……！（Unityも十分モダンC#の仲間入りで良いです！）</p>
<p>そういえばブログに貼り付けるのを忘れてたのですが3月末にはこんなセッションもしていました。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/c5a8898ac7c4464584068b0ee3180e94" title=".NETの非同期戦略とUnityとの相互運用" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>ええ、ええ。Unityもモダンですよ！大丈夫！</p>
</div>
<h1 data-pagefind-sort="date:2024-03-19" data-pagefind-meta="published:2024-03-19"><a href="https://neue.cc/2024/03/19_Garnet.html">Redis互換の超高速インメモリデータストア「Garnet」にC# CustomCommandを実装してコマンドを拡張する</a></h1>
<ul class="date"><li>2024-03-19</li></ul>
<div class="entry_body"><p>Microsoftから<a href="https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/">Introducing Garnet – an open-source, next-generation, faster cache-store for accelerating applications and services</a>という記事が今日公開されて、Garnetという新しいインメモリデータストアがOSSとして公開されました。Microsoft Researchで<a href="https://github.com/microsoft/FASTER">FASTER</a>を手掛けていたチームによるもので、FASTERはC#実装の高速なキーバリューストアでした。今回のGarnetはその発展形のようなもので、FASTERベースのストレージと、Redis互換のプロトコルによる、インメモリデータストアになっています。詳しくはGarnetのほうのブログ<a href="https://microsoft.github.io/garnet/blog/brief-history">A Brief History of Garnet</a>で。GarnetもC#で作られています。</p>
<p>ベンチマークによると、Redisはもちろんのこと、DragonflyというRedis互換の世界最速のインメモリデータストア（を公式で謳ってる）<a href="https://www.dragonflydb.io/">Dragonfly</a>よりも高速、だそうで。</p>
<p><img src="https://github.com/neuecc/Blog2/assets/46207/f6192d51-f100-403b-a49d-94012b046110" alt="image" /></p>
<p>このグラフ、そこまで大きな差がないように見えますが対数グラフになっていて、Redisが1,000.00 kops/sec に対して、100,000.00 kops/secって言ってます。100倍です！えー。</p>
<p>そもそもRedisの速度に関していうと、シングルスレッドベースであることなどから、たまによくそこまで速くはないというのは言われてきていて、先述のDragonflyは<a href="https://www.publickey1.jp/blog/22/redis25dragonfly2022.html">Redis互換で25倍高速とする「Dragonfly」が登場。2022年の最新技術でインメモリデータストアを実装</a>などというリリースとともに、現代の技術で作り直せばもっともっと速くなる、とはされてきました。とはいえ、単純なGET/SETだけのメモリキャッシュとは比較にならない豊富なデータ型など利便性がとても高く、いうて別にそこまで遅いというわけでもないので、特に気にすることなく使われ続けているのではないでしょうか。</p>
<p>GarnetはC#で作られていますが、当然ながらC#専用ではなく、汎用的なRedisサーバーとして動作するため、既存のRedisクライアントで直接繋げることができます。Redisはそのプロトコル<a href="https://redis.io/docs/reference/protocol-spec/">Redis serialization protocol(RESP)</a>の仕様を公開しているため、互換サーバーが作りやすいというわけですね、素晴らしい……！</p>
<p>C#から使う場合は<a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>と、Garnet同梱のGarent Clientのどちらかが使えます。パッとGarnet Clientを見た限り、現状現実的に使うならStackExchange.Redisですね。最低限は用意されているけれど、Redisクライアントとして使うには、しんどみがありそうです。ただ、性能面ではGarnet Clientのほうが良さそうです。StackExchange.Redisも、前身のBookSleeveから数えると初期設計が10年以上前のものになっているので、現代の観点から見ると設計は古く、パフォーマンス的にも、この実装は悪そうだな、と思えるところがかなりあります。なのでロマンを追いかけるならGarnet Clientを使うのも面白くはあります……！</p>
<h2>C#でカスタムコマンドを実装する</h2>
<p>普通にRedis互換サーバーとして立てて使うのもいいのですが、C#使いなら面白い点があって、Garnetをライブラリとして参照して(NuGet: Microsoft.Garnet)、アプリケーションに組み込んでのセルフホストができます。例えばロガーとして<a href="https://github.com/Cysharp/ZLogger/">ZLogger</a>を差し込んでVerboseでログを出してみたりとか、ちょっと使いやすくていい感じです。ローカル開発とかだったらDockerでRedis動かして、などではなく、ソリューションにGarnetをそのまま組み込んで<a href="https://github.com/dotnet/aspire">.NET Aspire</a>で同時起動させるとかもいい感じでしょう。RedisはWindowsでは動かないので(大昔にMicrosoftがForkして動かせるようにしたプロジェクトがありましたが！)、ちゃんと動く互換サーバーが出てきたこと自体がとても嬉しかったりもします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Garnet;
using Microsoft.Extensions.Logging;
using ZLogger;

try
{
    var loggerFactory = LoggerFactory.Create(x =&gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole(options =&gt;
        {
            options.UsePlainTextFormatter(formatter =&gt;
            {
                formatter.SetPrefixFormatter($&quot;[{0}]&quot;, (in MessageTemplate template, in LogInfo info) =&gt; template.Format(info.Category));
            });
        });
    });

    using var server = new GarnetServer(args, loggerFactory);

    // Optional: register custom extensions
    RegisterExtensions(server);

    // Start the server
    server.Start();
    Thread.Sleep(Timeout.Infinite);
}
catch (Exception ex)
{
    Console.WriteLine($&quot;Unable to initialize server due to exception: {ex.Message}&quot;);
}
</code></pre>
<p>もう一つは、カスタムコマンドを実装できることです……！C#で……！</p>
<p>Redis上でちょっと複雑な実行をしたいことはよくあり、Redisの場合は<a href="https://redis.io/docs/interact/programmability/eval-intro/">Lua Script</a>で処理していましたが、GarnetではC#でカスタムコマンドを実装して組み込むことができます。LUAだとパフォーマンス上どうか、あるいはLUAではできないかなり複雑なことをしたい、といった場合に、パフォーマンス上のデメリットなく使えます。もっとさらに嬉しい点としては、サーバー側で用意した拡張コマンドは、RESPに従っているので、クライアントはC#専用ではなく、PHPからでもGoからでも呼べます。</p>
<p>というわけで、サンプルということで単純な、「SETLCLAMP」というSET時にclampするカスタムコマンドを早速作っていきましょう。作る前に、先に↑のコードで欠けてるRegisterExtensionsの部分を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void RegisterExtensions(GarnetServer server)
{
    // ClampLongCustomCommandというカスタムコマンドをSETLCLAMPというコマンド名で登録する。
    // これはMath.Clampを呼び出すので、パラメーター数は3(long value, long min, long max)
    server.Register.NewCommand(&quot;SETLCLAMP&quot;, 3, CommandType.ReadModifyWrite, new ClampLongCustomCommand());
}
</code></pre>
<p>カスタムコマンドの登録自体は非常に簡単で、<code>CustomRawStringFunctions</code>, <code>CustomTransactionProcedure</code> または <code>CustomObjectFactory</code> を実装したクラスをコマンド名と共に追加するだけです。</p>
<p>カスタムコマンドの実装も簡単……？まぁ、理解すればそれなりぐらいに。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Garnet.server;
using System.Buffers;
using System.Buffers.Binary;
using Tsavorite.core;

sealed class ClampLongCustomCommand : CustomRawStringFunctions
{
    // trueの場合はKeyが空の時の動作(GetInitialLength, InitilUpdate)を呼びに行く
    public override bool NeedInitialUpdate(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ref (IMemoryOwner&lt;byte&gt;, int) output) =&gt; true;

    // UpdaterのSpan&lt;byte&gt; value（書き込みたいメモリデータ）の長さを決める
    public override int GetInitialLength(ReadOnlySpan&lt;byte&gt; input)
    {
        // 今回はlongだけなので決め打ち8
        return 8;
    }

    public override bool InitialUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, Span&lt;byte&gt; value, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo)
    {
        // inputに対してGetNextArgを連続して呼ぶとパラメーターの取得。これは定型句。
        int offset = 0;
        var arg1 = GetNextArg(input, ref offset);
        var arg2 = GetNextArg(input, ref offset);
        var arg3 = GetNextArg(input, ref offset);

        // ClientはWriteInt64LittleEndianでシリアライズしてきてるので、Readでデシリアライズ
        var v = BinaryPrimitives.ReadInt64LittleEndian(arg1);
        var min = BinaryPrimitives.ReadInt64LittleEndian(arg2);
        var max = BinaryPrimitives.ReadInt64LittleEndian(arg3);

        var result = Math.Clamp(v, min, max);

        // valueに対して値を書くことで値のセットになる
        BinaryPrimitives.WriteInt64LittleEndian(value, result);

        // 戻り値とかエラーを書きたい場合はoutputを使う(RespWriteUtilsに色々Utilityが揃ってる)
        // WriteIntegerAsBulkStringなどを使うと&quot;String&quot;としての結果になることに注意
        // 今回はlongをバイナリとして出力する
        unsafe
        {
            var len = 8 + 6; // $8\r\n{value}\r\n
            var pool = MemoryPool.Rent(len);
            using var memory = pool.Memory.Pin();
            var begin = (byte*)memory.Pointer;
            var end = begin + len;
            RespWriteUtils.WriteBulkString(value, ref begin, end);
            output = (pool, len);
        }

        return true;
    }

    // 同じメモリ領域を再利用する(置換する値の長さが同値なら再利用可能)かどうかを決める
    public override bool NeedCopyUpdate(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; oldValue, ref (IMemoryOwner&lt;byte&gt;, int) output) =&gt; false;

    // 置換時に再利用する場合
    public override bool InPlaceUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, Span&lt;byte&gt; value, ref int valueLength, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo)
    {
        // 置換するvalueの長さが一緒(あるいは小さい)の場合は
        // valueにはoldValueが入ってきてる。
        // 今回は特に考慮しないのでそのまんま書く。

        int offset = 0;
        var v = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var min = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var max = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));

        var result = Math.Clamp(v, min, max);

        BinaryPrimitives.WriteInt64LittleEndian(value, result);
        unsafe
        {
            var len = 8 + 6; // $8\r\n{value}\r\n
            var pool = MemoryPool.Rent(len);
            using var memory = pool.Memory.Pin();
            var begin = (byte*)memory.Pointer;
            var end = begin + len;
            RespWriteUtils.WriteBulkString(value, ref begin, end);
            output = (pool, len);
        }

        return true;
    }

    // 置換時に別のメモリ領域を確保する場合

    public override int GetLength(ReadOnlySpan&lt;byte&gt; value, ReadOnlySpan&lt;byte&gt; input) =&gt; 8;

    public override bool CopyUpdater(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; oldValue, Span&lt;byte&gt; newValue, ref (IMemoryOwner&lt;byte&gt;, int) output, ref RMWInfo rmwInfo) =&gt; throw new NotImplementedException();


    // 読み込み処理用
    public override bool Reader(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; input, ReadOnlySpan&lt;byte&gt; value, ref (IMemoryOwner&lt;byte&gt;, int) output, ref ReadInfo readInfo) =&gt; throw new NotImplementedException();
}
</code></pre>
<p>今回はRedisでいうところのStringベースで作るので <code>CustomRawStringFunctions</code> を使います。RedisのStringは文字列型じゃなくて、どちらかというとバイナリ型で、バイナリシリアライズできるものなら、なんでも突っ込めるイメージです。私もゲームサーバーを作っていたときはMessagePackのバイナリを突っ込みまくってましたし、開発時には雑に画像データのバイナリを投げ込んで画像DB代わりに使ったりとかもありました。</p>
<p>オーバーライドするメソッドの数が多いことと、パラメーターが<code>Span&lt;byte&gt;</code>だらけで一瞬圧倒されちゃうんですが、冷静に追ってみるとそこまで難しいことは言ってないことに気づきます。追加時(Add)・置換時(Replace)が、最適化のため同じサイズか違うサイズかで2択、それとRead時用。といった別れ方をしています。</p>
<p>key, input, valueが全て<code>ReadOnlySpan&lt;byte&gt;</code>なのは、まぁそりゃそうでしょう(ここでstringとか出てきたら逆に良くない！)</p>
<p>inputをパラメーターに分解するのは<code>GetNextArg</code>というヘルパーメソッドを使います。当然それも出てくるのは<code>ReadOnlySpan&lt;byte&gt;</code>なので、あとは適当に、もしJSONとかMessagePackとか<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>でシリアライズしたデータだったらシリアライザを使って戻すのもいいし、プリミティブの値だったら<code>BinaryPrimitives</code>が恐らく適役です。MemoryPackでValueTupleにまとめちゃうのがArgumentが分かれないので最速かつ簡単かもしれません。</p>
<p>結果は<code>Span&lt;byte&gt; value</code>に書きます。この出力先のSpanの長さは事前に<code>GetLength</code>または<code>GetInitialLength</code>で求めておく必要があります。outputはクライアント側に戻すときの値で、RESPに則った形式で出力する必要があるので色々注意がいります。まずはRESPの仕様を簡単にでも頭に入れたほうがつまずかないで済むかもしれません、ここを分かってないとイマイチ書きづらいと思います。</p>
<p>と、いうわけで、バイナリ操作がそこそこ混ざることを除けば、それなりに素直に書けるのではないでしょうか。雰囲気は理解しました！ある程度なんでもは出来ますが(<code>CustomTransactionProcedure</code> や <code>CustomObjectFactory</code> でもまた色々出来る)、同期メソッドしかないように、DB呼んだりHTTP通信したりはご法度です。当たり前ですが。当たり前ですが。計算量もGarnetサーバーのCPUにストレートに影響を与えるので、そんなに無茶なことを書くことはないと思いますがお気をつけを。それでも、LUAを走らせるよりもずっと軽いんじゃないかなという予感はさせてくれます。実際これただのC#のメソッドそのものですしね。</p>
<p>クライアントから呼び出す場合は、こんなメソッドを用意してみます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class GarnetClientExtensions
{
    // RESPプロトコルにのっとってOpCodeを用意する
    // RESPのBlukStringの仕様: https://redis.io/docs/reference/protocol-spec/#bulk-strings
    // $&lt;length&gt;\r\n&lt;data&gt;\r\n
    readonly static Memory&lt;byte&gt; OpCode_SETLCLAMP = Encoding.ASCII.GetBytes(&quot;$9\r\nSETLCLAMP\r\n&quot;);

    public static async Task&lt;long&gt; ClampAsync(this GarnetClient client, Memory&lt;byte&gt; key, long value, long min, long max, CancellationToken cancellationToken = default)
    {
        var parameters = new byte[24];

        var valSpan = parameters[0..8];
        var minSpan = parameters[8..16];
        var maxSpan = parameters[16..24];

        BinaryPrimitives.WriteInt64LittleEndian(valSpan, value);
        BinaryPrimitives.WriteInt64LittleEndian(minSpan, min);
        BinaryPrimitives.WriteInt64LittleEndian(maxSpan, max);

        // key + (value, min, max)
        // 戻り値のMemoryResultはArrayPoolから借りてる状態なのでDisposeでReturnする
        using var result = await client.ExecuteForMemoryResultWithCancellationAsync(OpCode_SETLCLAMP, new Memory&lt;byte&gt;[] { key, valSpan, minSpan, maxSpan }, cancellationToken);
        
        return BinaryPrimitives.ReadInt64LittleEndian(result.Span);
    }
}
</code></pre>
<p>サーバー側で用意した拡張コマンドは、ちゃんとRESPに従っているので、クライアントはC#専用ではありませんし、Garnet Client専用でもありません。StackExchange.Redisであれば、<code>db.Execute(&quot;SETLCLAMP&quot;, ...)</code> で呼べます。</p>
<p>実際に動かしてみるとこんな感じです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task RunClientAsync(ILoggerFactory loggerFactory)
{
    var logger = loggerFactory.CreateLogger(&quot;Client&quot;);

    var client = new GarnetClient(&quot;localhost&quot;, 3278, logger: logger);

    logger.ZLogInformation($&quot;Client Connecting.&quot;);
    await client.ConnectAsync();
    logger.ZLogInformation($&quot;Success Connect.&quot;);

    var key = Encoding.UTF8.GetBytes(&quot;foo&quot;);

    var v1 = await client.ClampAsync(key, 12345, min: 0, max: 100);
    Console.WriteLine(v1); // 100

    // String系のGET/SET/DELなどは普通に呼べる
    using var v2 = await client.StringGetAsMemoryAsync(key);
    Console.WriteLine(BinaryPrimitives.ReadInt64LittleEndian(v2.Span)); // 100

    var isDelete = await client.KeyDeleteAsync(key);
    Console.WriteLine(isDelete); // True
}
</code></pre>
<p>いいですね！</p>
<h2>まとめ</h2>
<p>さすがに公開されてまだ10時間経ってないぐらいなのでザックリとした理解なのですが、かなりいいんじゃないかと！</p>
<p>どうしてもMemachedとかRedisとかは、クラウドのマネージドサービスが用意されてないと嫌だー、という思考に陥りがちなのですが、C#でガリガリ拡張できるとなれば、まぁマネージドがなくてもしょうがないな！という気持ちになれ、る、でしょうかね……？</p>
<p>まぁそうじゃなくても、あまりマネージド指向になりすぎるのも良くないかな、とは思っています。私は最近はPubSubに<a href="https://nats.io/">NATS</a>をお薦めしてクライアントも作ったりしてたわけですが、もちろんマネージドサービスはありません。で、だから、諦めます、というのは違うかな、と。もったいないと思うんですよね。</p>
<p>なので、必要あれば、いや、必要じゃなくても（？）気持ちがあるなら、自前に立てるというのも否定しちゃあいけないと思ってます。特にC#アプリケーションを作ったことがある人なら、C#で組み込んでホスティングすること自体は別に難しくもない、なんだったらいつもやってることの延長線上でいけますし。もちろん、そこからインフラ安定させるとかデータどうするなとかリカバリどうするとか、そういうのは別問題の話ではありますが……！</p>
<p>ともあれかなり面白いし使える予感があるので、やっていきましょう！</p>
</div>
<h1 data-pagefind-sort="date:2024-03-18" data-pagefind-meta="published:2024-03-18"><a href="https://neue.cc/2024/03/18_Claudia.html">Claudia - Anthropic ClaudeのC# SDKと現代的なC#によるウェブAPIクライアントの作り方</a></h1>
<ul class="date"><li>2024-03-18</li></ul>
<div class="entry_body"><p>AI関連、競合は現れども、性能的にやはりOpenAI一強なのかなぁというところに現れた<a href="https://www.anthropic.com/">Anthropic Claude 3</a>は、確かに明らかに性能がいい、GPT-4を凌駕している……！というわけで大いに気に入った（ついでに最近のOpenAIのムーブが気に入らない）ので、C#で使い倒していきたい！そこで、まずはSDKがないので非公式SDKを作りました。こないだまでプレビュー版を流していたのですが、今回v1.0.0として出します。ライブラリ名は、Claudeだから、Claudiaです！.NET全般で使えるのと、Unity(Runtime/Editor双方)でも動作確認をしているので、アイディア次第で色々活用できると思います。</p>
<ul>
<li><a href="https://github.com/Cysharp/Claudia">GitHub - Cysharp/Claudia</a></li>
</ul>
<p>今回のSDKを作るにあたっての設計指針の一番目は、公式の<a href="https://github.com/anthropics/anthropic-sdk-python">Python SDK</a>や<a href="https://github.com/anthropics/anthropic-sdk-typescript">TypeScript SDK</a>と限りなく似せること、です。というのもドキュメント類の解説はこれら公式SDKベースになるし、世の中的にもブログなどには公式SDKベースの記事が多く出回るでしょう。公式の充実した<a href="https://docs.anthropic.com/claude/prompt-library">プロンプトライブラリ</a>も、APIリクエストで叩き込みたくなるかもしれない。</p>
<p>そんな時に、APIのスタイルが違うと、変換の認知負荷がかかります。些細なことですが、そういうところがすごく大事で引っ掛かってしまうので、徹底的に取り除きます。そのうえで、無理に動的な要素を入れず、C#らしさを崩さないというバランス取りが設計において重要です。</p>
<p>C#クライアントの見た目はこうです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// C#
using Claudia;

var anthropic = new Anthropic();

var message = await anthropic.Messages.CreateAsync(new()
{
    Model = &quot;claude-3-opus-20240229&quot;,
    MaxTokens = 1024,
    Messages = [new() { Role = &quot;user&quot;, Content = &quot;Hello, Claude&quot; }]
});

Console.WriteLine(message);
</code></pre>
<p>比較してTypeScriptの見た目はこうなっています。</p>
<pre data-pagefind-ignore="all"><code class="language-typescript">// TypeScript
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic();

const message = await anthropic.messages.create({
    model: 'claude-3-opus-20240229',
    max_tokens: 1024,
    messages: [{ role: 'user', content: 'Hello, Claude' }],
});

console.log(message.content);
</code></pre>
<p>かなり近い！でしょう。そのうえで、C#版は<code>dynamic</code>や<code>Dictionary&lt;string, object&gt;</code>などは使わず、全て型付けされたものが指定されます。上記の例で使用しているC# 9.0で追加された<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-new">Target-typed new expressions</a>や、C# 12で追加された<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions">Collection expressions</a>の存在を前提として、うまくAPIを合わせています。</p>
<p>もともと、動的型付け言語のAPIのほうが（見た目は）簡潔で使いやすそう、という印象を抱くことは多いので、それと同レベルの簡潔さで、しっかりと型付けが効いて書けるというのは、現代のC#の大きな強みです。（そもそもTypeScriptの公式SDKに合わせようと思ったのは、私から見ても公式SDKのAPIスタイルはよくできていると思ったからです、仮にあまりにも酷かった場合は合わせようとはしなかったでしょう）</p>
<p>いかにも古典的なC#やJavaみたいな冗長な設計のAPIクライアントは、反省しましょう。現代のC#はここまでやれるのだから。</p>
<h2>Streaming and Blazor</h2>
<p>StreamingのAPIも用意されていて、Blazorと組み合わせれば簡単にリアルタイムに更新されるChat UIが作れます。コードは本当にたったのこれだけ、メソッド本体なんて10行ちょい！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[Inject]
public required Anthropic Anthropic { get; init; }

double temperature = 1.0;
string textInput = &quot;&quot;;
string systemInput = SystemPrompts.Claude3;
List&lt;Message&gt; chatMessages = new();

async Task SendClick()
{
    chatMessages.Add(new() { Role = Roles.User, Content = textInput });

    var stream = Anthropic.Messages.CreateStreamAsync(new()
    {
        Model = Models.Claude3Opus,
        MaxTokens = 1024,
        Temperature = temperature,
        System = string.IsNullOrWhiteSpace(systemInput) ? null : systemInput,
        Messages = chatMessages.ToArray()
    });

    var currentMessage = new Message { Role = Roles.Assistant, Content = &quot;&quot; };
    chatMessages.Add(currentMessage);

    textInput = &quot;&quot;;
    StateHasChanged();

    await foreach (var messageStreamEvent in stream)
    {
        if (messageStreamEvent is ContentBlockDelta content)
        {
            currentMessage.Content[0].Text += content.Delta.Text;
            StateHasChanged();
        }
    }
}
</code></pre>
<p><img src="https://github.com/Cysharp/Claudia/assets/46207/dfcad512-4cf1-4af0-ba03-901dc7ce36a6" alt="blazorclauderec" /></p>
<p>全てのリクエスト/レスポンス型はSystem.Text.Json.JsonSerializerでシリアライズ可能なため、この<code>List&lt;Message&gt;</code>をそのままシリアライズすれば保存、デシリアライズすれば読み込みになります。</p>
<h2>Function Calling</h2>
<p>ClaudiaはただのREST APIを叩くだけのSDK、ではありません。Source Generatorを活用して、Function Callingを簡単に定義するための仕組みを用意しました。</p>
<p>Function Callingができると何がいいか、というと、現状のLLMは単体だとできないことが幾つかあります。例えば計算は、それっぽい答えを返してくれる場合も多いし、Step-by-Stepで考えさせるなど、それっぽさの精度を上げることはできるけれど、正確な計算はできないという苦手分野だったりします（複雑な計算を投げると正しそうで間違ってる答えを出しやすい）。それなら計算が必要なら普通に計算機で計算して、その答えをもとに文章を作ればいいじゃん、と。あるいは現在日時を答えることもできません。ウェブページを指定して要約したり翻訳して欲しいとお願いしても、中身を見ることはできませんと言われます。それらを解決するのがFunction Callingです。</p>
<p>まずは一例ということで、指定したURLのウェブページをClaudeに返す関数を定義してみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static partial class FunctionTools
{
    /// &lt;summary&gt;
    /// Retrieves the HTML from the specified URL.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;url&quot;&gt;The URL to retrieve the HTML from.&lt;/param&gt;
    [ClaudiaFunction]
    static async Task&lt;string&gt; GetHtmlFromWeb(string url)
    {
        using var client = new HttpClient();
        return await client.GetStringAsync(url);
    }
}
</code></pre>
<p><code>[ClaudiaFunction]</code>で定義した関数がSource Generatorによって色々生成されます。これを利用する場合、以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var input = new Message
{
    Role = Roles.User,
    Content = &quot;&quot;&quot;
        Could you summarize this page in three lines?
        https://docs.anthropic.com/claude/docs/intro-to-claude
&quot;&quot;&quot;
};

var message = await anthropic.Messages.CreateAsync(new()
{
    Model = Models.Claude3Haiku,
    MaxTokens = 1024,
    System = FunctionTools.SystemPrompt, // set generated prompt
    StopSequences = [StopSequnces.CloseFunctionCalls], // set &lt;/function_calls&gt; as stop sequence
    Messages = [input],
});

var partialAssistantMessage = await FunctionTools.InvokeAsync(message);

var callResult = await anthropic.Messages.CreateAsync(new()
{
    Model = Models.Claude3Haiku,
    MaxTokens = 1024,
    System = FunctionTools.SystemPrompt,
    Messages = [
        input,
        new() { Role = Roles.Assistant, Content = partialAssistantMessage! } // set as Assistant
    ],
});

// The page can be summarized in three lines:
// 1. Claude is a family of large language models developed by Anthropic designed to revolutionize the way you interact with AI.
// 2. This documentation is designed to help you get the most out of Claude, with clear explanations, examples, best practices, and links to additional resources.
// 3. Claude excels at a wide variety of tasks involving language, reasoning, analysis, coding, and more, and the documentation covers key capabilities, getting started with prompting, and using the API.
Console.WriteLine(callResult);
</code></pre>
<p>Claudeへは二回のリクエストを行っています。まず、最初のClaudeへのリクエストでは、質問と共に利用可能な関数の一覧と説明を送り、関数を実行するのが最適だと判断されると、実行したい関数名とパラメーターが返されます。それを下に、手元で関数を実行し、結果をClaudeに渡すことで最終的に求める結果を得られます。</p>
<p>ではSource Generatorは何をやっているのかというと、まずはClaudeのシステム文に渡している<code>FunctionTools.SystemPrompt</code>を生成しているわけですが、その中身はこれです（一部省略）。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">// ...前文は省略

&lt;tools&gt;
    &lt;tool_description&gt;
        &lt;tool_name&gt;GetHtmlFromWeb&lt;/tool_name&gt;
        &lt;description&gt;Retrieves the HTML from the specified URL.&lt;/description&gt;
        &lt;parameters&gt;
            &lt;parameter&gt;
                &lt;name&gt;url&lt;/name&gt;
                &lt;type&gt;string&lt;/type&gt;
                &lt;description&gt;The URL to retrieve the HTML from.&lt;/description&gt;
            &lt;/parameter&gt;
        &lt;/parameters&gt;
    &lt;/tool_description&gt;
&lt;/tools&gt;
</code></pre>
<p>XMLです。Claudeは<a href="https://docs.anthropic.com/claude/docs/use-xml-tags">XMLタグを認識</a>するようになっていて、システム的に明確に情報を与えたい場合はXMLタグを活用することがベストプラクティスとなっています。そこで、C#の関数からClaudeに渡すためのXMLを自動生成しています。これを手書きは、したくないでしょう……？</p>
<p>そしてClaudeはそのリクエストに対して、以下のような結果を返します。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;function_calls&gt;
    &lt;invoke&gt;
        &lt;tool_name&gt;GetHtmlFromWeb&lt;/tool_name&gt;
        &lt;parameters&gt;
            &lt;url&gt;https://docs.anthropic.com/claude/docs/intro-to-claude&lt;/url&gt;
        &lt;/parameters&gt;
    &lt;/invoke&gt;
</code></pre>
<p>やはりXMLです（閉じタグが欠けているのはStopSequencesで止めているため。関数を呼びたい場合はこれ以上の情報は不要なので打ち止めておく)。これをパースして、関数(GetHtmlFromWeb)を実行し、Claudeに渡すためのメソッド <code>FunctionTools.InvokeAsync</code> がSource Generatorによって生成されています。実際生成されているInvokeAsyncメソッドは以下のようなものです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">#pragma warning disable CS1998
    public static async ValueTask&lt;string?&gt; InvokeAsync(MessageResponse message)
    {
        var content = message.Content.FirstOrDefault(x =&gt; x.Text != null);
        if (content == null) return null;

        var text = content.Text;
        var tagStart = text .IndexOf(&quot;&lt;function_calls&gt;&quot;);
        if (tagStart == -1) return null;

        var functionCalls = text.Substring(tagStart) + &quot;&lt;/function_calls&gt;&quot;;
        var xmlResult = XElement.Parse(functionCalls);

        var sb = new StringBuilder();
        sb.AppendLine(functionCalls);
        sb.AppendLine(&quot;&lt;function_results&gt;&quot;);

        foreach (var item in xmlResult.Elements(&quot;invoke&quot;))
        {
            var name = (string)item.Element(&quot;tool_name&quot;)!;
            switch (name)
            {
                case &quot;GetHtmlFromWeb&quot;:
                    {
                        var parameters = item.Element(&quot;parameters&quot;)!;

                        var _0 = (string)parameters.Element(&quot;url&quot;)!;

                        BuildResult(sb, &quot;GetHtmlFromWeb&quot;, await GetHtmlFromWeb(_0).ConfigureAwait(false));
                        break;
                    }

                default:
                    break;
            }
        }

        sb.Append(&quot;&lt;/function_results&gt;&quot;); // final assistant content cannot end with trailing whitespace

        return sb.ToString();

        static void BuildResult&lt;T&gt;(StringBuilder sb, string toolName, T result)
        {
            sb.AppendLine(@$&quot;    &lt;result&gt;
        &lt;tool_name&gt;{toolName}&lt;/tool_name&gt;
        &lt;stdout&gt;{result}&lt;/stdout&gt;
    &lt;/result&gt;&quot;);
        }
    }
#pragma warning restore CS1998
}
</code></pre>
<p>これを手書きは、あまりしたくはないでしょう。特に呼び出したい関数が増えれば増えるほど大変ですし。</p>
<p>これで呼び出し＆生成したXMLを再度Claudeに、Assistantによる先頭の出力結果だと渡すことによって、望む答えを得ることができます。このテクニックは<a href="https://docs.anthropic.com/claude/docs/prefill-claudes-response">Prefill Claude's response</a>として公式でもベストプラクティスの一つとして案内されているもので、Claudeによる返答を望む方向に導くのに有益です。例えば<code>{</code>をprefill responseとして返すと、Claudeが結果をJSONとして出力する確率が飛躍的に上昇します。</p>
<h2>API vs LangChain, SemanticKernel</h2>
<p>大規模言語モデルを触るなら、生で使うよりも<a href="https://www.langchain.com/">LangChain</a>や、特にC#だと<a href="https://github.com/microsoft/semantic-kernel">Semantic Kernel</a>を使うというのを入り口にするのも定説ではありますが、やや疑問はあります。最近でも<a href="https://tech-blog.abeja.asia/entry/advent-2023-day13">LangChainを使わない</a>や<a href="https://tech-blog.abeja.asia/entry/advent-2023-day13">LangChain は LLM アプリケーションの開発に採用すべきではない</a>といった記事のようにLangChain不要論も出てきています。</p>
<p>そもそも、まぁこの記事はエンジニア向けに書いてるわけですが、一部の機能はあきらかに過剰でいらないんじゃないかと、保存用のプラグインとか。Semantic Kernelの大量にあるコネクターパッケージとかぞっとする感じで、コード書けないデータサイエンティストが継ぎ接ぎでやるならともかく、エンジニアは保存ぐらい自前でやったほうが絶対いいでしょ。TimePluginだのHttpPluginだのFileIOPluginだのも、正直馬鹿らしい、という感じしかないのでは。</p>
<p>どうせ最後に叩くのは生APIなら、真摯にAPIドキュメントを読め、と。<a href="https://docs.anthropic.com/claude/docs/intro-to-claude">ClaudeのAPIドキュメントのUser Guides</a>は分かりやすく素晴らしく、それもまたClaudeを支持したい理由の一つになります。しょうもない抽象化を通すぐらいならClaudeに特化して、特徴的なXMLによる指示の活かしかたを考えろ、と。</p>
<p>特にC#の人はSemantic Kernel至上主義になってると思われるので、いったんまずそっから離れて考えていくといいんじゃないです？</p>
<h2>モダンウェブAPIクライアントの作り方</h2>
<p>ここからはClaudiaの設計から見る現代的なAPIクライアントの設計方法の話をします。</p>
<p>まず、通信の基盤は<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.net.http.httpclient?view=net-8.0">HttpClient</a>を使います。一択です。異論を挟む余地はない。<a href="https://github.com/grpc/grpc-dotnet/tree/master/src/Grpc.Net.Client">Grpc.Net.Client</a>だってHTTP/2 gRPC通信にHttpClientを使っていますし、好むと好まざると全てのHTTP系の通信の基盤はHttpClientです。</p>
<p>ここでは、外からHttpMessageHandlerを受け取れるようにしておくといいでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Anthropic : IMessages, IDisposable
{
    readonly HttpClient httpClient;

    // DefaultRequestHeadersやBaseAddressを変更させてあげるためにpublicで公開しておく
    public HttpClient HttpClient =&gt; httpClient;

    public Anthropic()
        : this(new HttpClientHandler(), true)
    {
    }

    public Anthropic(HttpMessageHandler handler)
        : this(handler, true)
    {
    }

    public Anthropic(HttpMessageHandler handler, bool disposeHandler)
    {
        this.httpClient = new HttpClient(handler, disposeHandler);
    }

    public void Dispose()
    {
        httpClient.Dispose();
    }
}
</code></pre>
<p>HttpClientというのは実はガワでしかなくて、実体はHttpMessageHandlerです。HttpMessageHandlerにはやれることが色々あって、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.net.http.delegatinghandler?view=net-8.0">DelegatingHandler</a>を実装してリクエストの前後をフックするような機能を仕込んだりも出来るし、<a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a>はHttpMessageHandlerの実装という形で通信処理を丸ごとRust実装に差し替えています。Unityでは.NETランタイムの通信実装じゃなくてUnityWebRequestを使いたいんだよなあ、といったような場合には<a href="https://gist.github.com/neuecc/854192b8d176170caf2c53fa7589dc90">UnityWebRequestHttpMessageHandler.cs</a>を使えば、やはり通信処理が全てUnityによるものに差し替わります。</p>
<p>インターフェイスの切り方も工夫していきましょう。</p>
<p><code>client.Messages.CreateAsync</code> のように、MVCでいったら<code>.Controller.Method</code>のように、2階層に整理された呼び出し方は直感的で使いやすい設計です。特に、入力補完に優しいのが嬉しい。そのためには、まずインターフェイスを切りますが、工夫として、それを<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation">明示的なインターフェイスの実装</a>にして、インターフェイス自体は<code>return this;</code>で返してやりましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IMessages
{
    Task&lt;MessageResponse&gt; CreateAsync(MessageRequest request, RequestOptions? overrideOptions = null, CancellationToken cancellationToken = default);
    IAsyncEnumerable&lt;IMessageStreamEvent&gt; CreateStreamAsync(MessageRequest request, RequestOptions? overrideOptions = null, CancellationToken cancellationToken = default);
}

public class Anthropic : IMessages, IDisposable
{
    public IMessages Messages =&gt; this;

    async Task&lt;MessageResponse&gt; IMessages.CreateAsync(MessageRequest request, RequestOptions? overrideOptions, CancellationToken cancellationToken)
    {
        // ...
    }

    async IAsyncEnumerable&lt;IMessageStreamEvent&gt; IMessages.CreateStreamAsync(MessageRequest request, RequestOptions? overrideOptions, [EnumeratorCancellation] CancellationToken cancellationToken)    
    {
        // ...
    }
}
</code></pre>
<p>これによって一個階層を下がる際のアロケーションがない(thisを返すため)ですし、明示的な実装になっているのでトップ階層では入力補完には現れないので、使いやすさと性能、ついでにいえば実装のしやすさ（全てのクライアントのフィールドにそのままアクセスできるため）の全てが満たされます。</p>
<h2>ユーザーフレンドリーなリクエスト型生成</h2>
<p><a href="https://docs.anthropic.com/claude/reference/messages_post">Anthropicのリクエスト型</a>はかなり整理されて、型有り言語に優しい仕様になっているのですが、一部、<code>single string or an array of content blocks</code>というものがあります。どっちか、とかそういうの微妙に困るわけですが、しかし、じゃあ<code>Option&lt;Either&lt;List&lt;&gt;&gt;&gt;</code>かなー、とか、そういうことではありません。そんな定義にしたらAPIクライアントの手触りは最悪になるでしょう。よく考えてみると、Anthropic APIのこの場合のstringは、長さ1のstring contentと同一です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こうじゃなくて
Content = [ new() { Type = &quot;text&quot;, Text = &quot;Hello, Claude&quot; }]

// こう書きたい
Content = &quot;Hello, Claude&quot;
</code></pre>
<p>これは、良い仕様だと思います。杓子定規に Type = &quot;text&quot;, Text = &quot;...&quot; と書かせるのはダルいでしょう。利用時の95%ぐらいはsingle string contentでしょうし(Typeはimageの場合もある、その場合はSourceにバイナリのbase64文字列を設定する。arrayなのは、画像とテキストを両方渡したりするため)。</p>
<p>その仕様をC#で実現しましょう。今回の場合、正規化するようなイメージでいいので、暗黙的変換で実装しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public record class Message
{
    /// &lt;summary&gt;
    /// user or assistant.
    /// &lt;/summary&gt;
    [JsonPropertyName(&quot;role&quot;)]
    public required string Role { get; set; }

    /// &lt;summary&gt;
    /// single string or an array of content blocks.
    /// &lt;/summary&gt;
    [JsonPropertyName(&quot;content&quot;)]
    public required Contents Content { get; set; }
}

public class Contents : Collection&lt;Content&gt;
{
    public static implicit operator Contents(string text)
    {
        var content = new Content
        {
            Type = ContentTypes.Text,
            Text = text
        };
        return new Contents { content };
    }
}
</code></pre>
<p><code>Content[]</code>ではなくて独自のコレクションにして、それの文字列からの暗黙的変換でsingle string contentを生成する形にしました。別に最新のC#仕様でもなんでもなく昔からある手法ですし、闇雲な利用は厳禁ですが、こうしたところに利用するのはAPIクライアントの手触り向上に効果的です。</p>
<h2>タイムアウト</h2>
<p>タイムアウトは定番の処理なので、APIクライアントで簡単にユーザーが設定できるようにしておいたほうがいいでしょう。といっても、HttpClientがTimeoutプロパティを持っているので、通常はそれにセットしてあげるだけで十分です。しかし、Claudiaではあえて無効にしています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Anthropic : IMessages, IDisposable
{
    public TimeSpan Timeout { get; init; } = TimeSpan.FromMinutes(10);

    public Anthropic(HttpMessageHandler handler, bool disposeHandler)
    {
        this.httpClient = new HttpClient(handler, disposeHandler);
        this.httpClient.Timeout = System.Threading.Timeout.InfiniteTimeSpan;
    }
}
</code></pre>
<p>Anthropicの公式クライアントがメソッド呼び出し毎にTimeout設定をオーバーライドできるという仕様を持っているため、それにならってオーバーライド可能に必要があったためです。HttpClientやそれに準ずるもの呼び出しはスレッドセーフであるべき(実際APIクライアントはSingletonで登録されたりする場合がある)なので、SendAsyncでHttpCleintのプロパティの値を弄るのはよくない。ので、HttpClientが持つTimeoutは無効にして、手動で処理するようにしています。</p>
<p>実装方法は、LinkedTokenSourceを生成し、CancelAfterによってタイムアウト時間後にキャンセルされるCancellationTokenを作り、HttpClient.SendAsyncに渡すだけです。なお、これはHttpClient.Timeoutがタイムアウト時間を持つ場合の内部実装と同じです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 実際のコードはリトライ処理と混ざっているため、若干異なります
async Task&lt;TResult&gt; RequestWithAsync&lt;TResult&gt;(HttpRequestMessage message, CancellationToken cancellationToken, RequestOptions? overrideOptions)
{
    var timeout = overrideOptions?.Timeout ?? Timeout;
    using (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
    {
        cts.CancelAfter(timeout);

        try
        {
            var result = await httpClient.SendAsync(message, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(ConfigureAwait);
            return result;
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                throw new OperationCanceledException(ex.Message, ex, cancellationToken);
            }
            else
            {
                throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
            }

            throw;
        }
    }
}
</code></pre>
<p>実際にキャンセルされた場合(OperationCanceledExceptionが投げられる)のエラーハンドリングには注意しましょう。まず、LinkedTokenを剥がす必要があります。素通しだとOperationCanceledExceptionのTokenがLinkedTokenのままですが、これだと上流側でキャンセル原因の判定に使うことができません。キャンセル原因が渡されているCancellationTokenのキャンセルだった場合は、OperationCanceledExceptionを作り直してキャンセル理由のTokenを変更します。</p>
<p>タイムアウトだった場合はOperationCanceledExceptionではなく、<code>TimeoutException</code>を投げてあげるのが良いでしょう。なお、HttpClientのタイムアウト実装を使った場合は歴史的事情で<code>TaskCanceledException</code>を投げてくるようになっています（互換性のため変更したくても、もう変更できない、とのこと。あまり良い設計ではないと言えるので、そこは見習わなくていいでしょう）</p>
<h2>リトライ</h2>
<p>リトライをAPIクライアント自身が持つべきかどうかに関しては、少し議論があるかもしれません。しかし、単純に例外が出たらcatchしてリトライかければいいというものではなく、リトライ可なものと不可のものの判別がまず必要です。例えば認証に失敗しているとか、リクエストに投げるJSONが腐ってるといった場合は何度リトライしても無駄なのでリトライすべきものではないのですが、そうした細かい条件は、APIクライアント自身しか知り得ないので、リトライ処理を内蔵してしまうのは良いと思います。</p>
<p>Claudiaでは公式クライアントに準拠する形で、具体的には408 Request Timeout, 409 Conflict, 429 Rate Limit, and &gt;=500 Internal errorsをリトライ対象にしています。認証失敗のPermissionError(403)やリクエスト内容が不正(InvalidRequestError(400))はリトライされません。たまによくあるOverloadedError(過負荷状態なので結果返せまんでしたエラー)は529で、これは何度か叩き直せば解消されるやつなのでリトライして欲しい、といったものはリトライされます。</p>
<p>リトライロジックも公式クライアントに準拠していて、レスポンスヘッダにretry-after-msやretry-afterがあればそれに従いつつ、ない場合(やretry-afterが規定よりも大きい場合)はジッター付きのExponential Backoffで間隔を制御しています。</p>
<h2>キャンセル</h2>
<p>クライアント側に<code>.Cancel()</code>メソッドなどは持たせません。というのも、HttpClientと準拠させるとクライアントそのものは、ほぼシングルトンで使えて、各呼び出しに対して共有されることになります（場合によってはDIでシングルトンでインジェクトするかもしれませんし)。なので、全てに影響を与える<code>.Cancel()</code>ではなくて、各呼び出しそれぞれにCancellationTokenを渡してね、という形を取ります。</p>
<h2>Server Sent Eventsの超高速パース</h2>
<p>Streamingでレスポンスを取得するAPIは、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent events</a>という仕様で、ストリーミングで送信されてきます。具体的には以下のようなテキストメッセージが届きます。</p>
<pre data-pagefind-ignore="all"><code>event: message_start
data: {&quot;type&quot;:&quot;message_start&quot;,&quot;message&quot;:...}

event: content_block_start
data: {&quot;type&quot;:&quot;content_block_start&quot;,&quot;index&quot;:...}
</code></pre>
<p>event: イベント名, data: JSON, ...。といったことの繰り返しです。さて、改行区切りのテキストメッセージといったら<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.streamreader">StreamReader</a>でReadLine、というのは正解、ではあるのですがモダンC#的には不正解です。</p>
<p>ReadLineは文字列を生成します。イベント名の判定のために、あるいは最終的にdataのJSONはデシリアライズしてオブジェクトに変換するのですが、UTF8のデータから直接変換できるはずです。というわけで、ここは（ユーザーに渡すオブジェクトの生成以外は）ゼロアロケーションが狙えます。文字列を通しさえしなければ。というわけでStreamReaderの出番はありません。</p>
<p>具体的なコードを見ていきましょう。前半部（下準備）と後半部（パース部分）で分けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal class StreamMessageReader
{
    readonly PipeReader reader;
    readonly bool configureAwait;
    MessageStreamEventKind currentEvent;

    public StreamMessageReader(Stream stream, bool configureAwait)
    {
        this.reader = PipeReader.Create(stream);
        this.configureAwait = configureAwait;
    }

    public async IAsyncEnumerable&lt;IMessageStreamEvent&gt; ReadMessagesAsync([EnumeratorCancellation] CancellationToken cancellationToken)
    {
    READ_AGAIN:
        var readResult = await reader.ReadAsync(cancellationToken).ConfigureAwait(configureAwait);

        if (!(readResult.IsCompleted | readResult.IsCanceled))
        {
            var buffer = readResult.Buffer;

            while (TryReadData(ref buffer, out var streamEvent))
            {
                yield return streamEvent;
                if (streamEvent.TypeKind == MessageStreamEventKind.MessageStop)
                {
                    yield break;
                }
            }

            reader.AdvanceTo(buffer.Start, buffer.End);
            goto READ_AGAIN;
        }
    }
</code></pre>
<p>まず、Streamは、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.pipelines.pipereader">System.IO.Pipelines.PipeReader</a>に渡しておきます。今回のStreamはネットワークからサーバー側がストリーミングで返してくる不安定なStreamなので、バッファ管理が大変です。PipeReader/PipeWriterは、若干癖がありますが、その辺の管理をよしなにやってくれるもので、現代のC#ではかなり重要なライブラリです。</p>
<p>基本の流れはバッファを読み込み(ReadAsync)、そのバッファでパース可能(行の末尾までないとパースできないので、改行コードが含まれているかどうか)な状態なら、1行毎にパース(TryReadData)してyield returnでオブジェクトを返す。バッファが足りなかったらAdvanceToで読み取った部分までマークしてから、再度ReadAsync、といった流れになります。</p>
<p>利用側はBlazorのサンプルで出していたのですが、await foreachで列挙するのが基本になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">await foreach (var messageStreamEvent in Anthropic.Messages.CreateStreamAsync())
{
}
</code></pre>
<p>こういったネットワークの絡む処理のストリーミング処理にはIAsyncEnumerableが非常に向いていますし、データソース側も、非同期シーケンスをyield returnで返せるというのは、とても楽になりました。これがない時代には、もう戻るのは無理でしょう……。</p>
<p>次に後半部、PipeReaderによって分解されたバッファからパースする処理になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[SkipLocalsInit]
bool TryReadData(ref ReadOnlySequence&lt;byte&gt; buffer, [NotNullWhen(true)] out IMessageStreamEvent? streamEvent)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);
    Span&lt;byte&gt; tempBytes = stackalloc byte[64]; // alloc temp
    
    while (reader.TryReadTo(out ReadOnlySequence&lt;byte&gt; line, (byte)'\n', advancePastDelimiter: true))
    {
        if (line.Length == 0)
        {
            continue; // next.
        }
        else if (line.FirstSpan[0] == 'e') // event
        {
            // Parse Event.
            if (!line.IsSingleSegment)
            {
                line.CopyTo(tempBytes);
            }
            var span = line.IsSingleSegment ? line.FirstSpan : tempBytes.Slice(0, (int)line.Length);

            var first = span[7]; // &quot;event: [c|m|p|e]&quot;

            if (first == 'c') // content_block_start/delta/stop
            {
                switch (span[23]) // event: content_block_..[]
                {
                    case (byte)'a': // st[a]rt
                        currentEvent = MessageStreamEventKind.ContentBlockStart;
                        break;
                    case (byte)'o': // st[o]p
                        currentEvent = MessageStreamEventKind.ContentBlockStop;
                        break;
                    case (byte)'l': // de[l]ta
                        currentEvent = MessageStreamEventKind.ContentBlockDelta;
                        break;
                    default:
                        break;
                }
            }
            else if (first == 'm') // message_start/delta/stop
            {
                switch (span[17]) // event: message_..[]
                {
                    case (byte)'a': // st[a]rt
                        currentEvent = MessageStreamEventKind.MessageStart;
                        break;
                    case (byte)'o': // st[o]p
                        currentEvent = MessageStreamEventKind.MessageStop;
                        break;
                    case (byte)'l': // de[l]ta
                        currentEvent = MessageStreamEventKind.MessageDelta;
                        break;
                    default:
                        break;
                }
            }
            else if (first == 'p')
            {
                currentEvent = MessageStreamEventKind.Ping;
            }
            else if (first == 'e')
            {
                currentEvent = (MessageStreamEventKind)(-1);
            }
            else
            {
                // Unknown Event, Skip.
                // throw new InvalidOperationException(&quot;Unknown Event. Line:&quot; + Encoding.UTF8.GetString(line.ToArray()));
                currentEvent = (MessageStreamEventKind)(-2);
            }

            continue;
        }
        else if (line.FirstSpan[0] == 'd') // data
        {
            // Parse Data.
            Utf8JsonReader jsonReader;
            if (line.IsSingleSegment)
            {
                jsonReader = new Utf8JsonReader(line.FirstSpan.Slice(6)); // skip data: 
            }
            else
            {
                jsonReader = new Utf8JsonReader(line.Slice(6)); // ReadOnlySequence.Slice is slightly slow
            }

            switch (currentEvent)
            {
                case MessageStreamEventKind.Ping:
                    streamEvent = JsonSerializer.Deserialize&lt;Ping&gt;(ref jsonReader, AnthropicJsonSerialzierContext.Default.Options)!;
                    break;
                case MessageStreamEventKind.MessageStart:
                    streamEvent = JsonSerializer.Deserialize&lt;MessageStart&gt;(ref jsonReader, AnthropicJsonSerialzierContext.Default.Options)!;
                    break;
                // 中略(MessageDela, MessageStop, ContentBlockStart, ContentBlockDelta, ContentBlockStop, errorに対して同じようなDeserialize&lt;T&gt;
                default:
                    // unknown event, skip
                    goto END;
            }

            buffer = buffer.Slice(reader.Consumed);
            return true;
        }
    }
END:
    streamEvent = default;
    buffer = buffer.Slice(reader.Consumed);
    return false;
}
</code></pre>
<p>event, dataの二行から、dataのJSONをデシリアライズしてオブジェクトを返したい。というのが処理のやりたいことです。bufferには必ずしも都合よくevent, dataの二行が入っているわけでもなくeventだけかもしれない、dataだけかもしれない、あるいはdataも途中で切れてる（そのままだと不完全なJSON）かもしれない。といったことを考慮して、中断・再開できる構造にしておく必要があります。</p>
<p>といっても、基本的には改行コードが存在してれば一行分のバッファは十分あるだろうということで、 <code>while (reader.TryReadTo(out ReadOnlySequence&lt;byte&gt; line, (byte)'\n', advancePastDelimiter: true))</code> といったループを回して、これをStreamReader.ReadLineの代わりにしています。このreaderは<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-8.0">SequenceReader</a>というReadOnlySequenceからの読み取りをサポートするユーティリティで、ref structのため、それ自体のアロケーションはありません。ReadOnlySequenceは性能良く正しく使うには、かなり落とし穴の多いクラスなので、こうしたユーティリティベースに実装したほうがお手軽かつ安全です。</p>
<p>まずeventのパースで、ここからdataがどの種類化を読み取っています。正攻法でやると <code>if (span.SequenceEqual(&quot;content_block_start&quot;))</code> といったように判定していくことになります。<code>Span&lt;byte&gt;</code>へのSequenceEqualは高速な実装になっているので、まぁ悪くないといえば悪くないのですが、とはいえifの連打は如何なものか……。そこで、Claudiaでは実際には以下のような判定に簡略化しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var first = span[7]; // &quot;event: [c|m|p|e]&quot;

if (first == 'c') // content_block_start/delta/stop
{
    switch (span[23]) // event: content_block_..[]
    {
        case (byte)'a': // st[a]rt
            currentEvent = MessageStreamEventKind.ContentBlockStart;
            break;
        case (byte)'o': // st[o]p
            currentEvent = MessageStreamEventKind.ContentBlockStop;
            break;
        case (byte)'l': // de[l]ta
            currentEvent = MessageStreamEventKind.ContentBlockDelta;
            break;
        default:
            break;
    }
}
else if (first == 'm') // message_start/delta/stop
{
    switch (span[17]) // event: message_..[]
    {
        case (byte)'a': // st[a]rt
            currentEvent = MessageStreamEventKind.MessageStart;
            break;
        case (byte)'o': // st[o]p
            currentEvent = MessageStreamEventKind.MessageStop;
            break;
        case (byte)'l': // de[l]ta
            currentEvent = MessageStreamEventKind.MessageDelta;
            break;
        default:
            break;
    }
}
</code></pre>
<p>メッセージの種類はcontent_block_start/delta/stop, message_start/delta/stop, ping, errorの8種類。まず、先頭1文字でcontent系かmessage系かその他か判定できる。start/delta/stopに関しては3文字目を見ると判定できる。というわけで、1byteのチェックを2回行うだけで分類可能です。明らかに高速！なお、今後のメッセージ種類の追加でチェックが壊れる可能性がゼロではない（例えばcontent_block_ffowardとかが来るとcontent_block_stopと誤判定される）、という問題があることは留意する必要があります。Claudiaではいうて大丈夫だろ、という楽観視してますが。</p>
<p>なお、これは以前に発表したモダンハイパフォーマンスC# 2023でのコードのバリエーションと言えるでしょうか。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6?slide=62" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>テキストプロトコルを見るとなんとかして判定をちょろまかしたいという欲求に抗うのは難しい……。なお、もし厳密な判定をしつつもif連打を避けたい場合は、まず長さチェックをいれます。長さで大雑把な分岐をかけてからSequenceEqualで正確なチェックをします。ようするところ、C#のstringへのswtichの最適化（コンパイラがそういう処理に変換している！）と同じことをやろうという話なだけですが。分岐数が多い場合はハッシュコードを取って分岐かけるとか、ようするにインラインDictionaryのようなものを実装するのもアリでしょう。</p>
<p>最後に、data行はJSON Deserializeです。<code>ReadOnlySpan&lt;byte&gt;</code>または<code>ReadOnlySequence&lt;byte&gt;</code>のままデシリアライズするには<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonreader?view=net-8.0">Utf8JsonReader</a>を通す必要があります。なお、<code>Utf8JsonReader</code>もref structなのでアロケーションには含めません。</p>
<p>これで、Stringを一切通さない処理ができました！StreamReaderを使えば超単純になるのに！という気はしなくもないですが、文字列化したら負けだと思っている病に罹患しているのでしょーがない……。</p>
<h2>Source Generator vs Reflection</h2>
<p>Function Callingの実装に、ClaudiaではSource Generatorを採用しました。リフレクションベースで作成することも可能では有りましたが、今回に関してはSource Generatorのほうが望ましい結果が得られました。まず、仮にリフレクションで実装したらどんな関数定義を要求されるだろうか、というところを、Semantic Kernel実装の場合との比較で見てください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static partial class FunctionTools
{
    // Claudia Source Generator

    /// &lt;summary&gt;
    /// Retrieve the current time of day in Hour-Minute-Second format for a specified time zone. Time zones should be written in standard formats such as UTC, US/Pacific, Europe/London.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;timeZone&quot;&gt;The time zone to get the current time for, such as UTC, US/Pacific, Europe/London.&lt;/param&gt;
    [ClaudiaFunction]
    public static string TimeOfDay(string timeZone)
    {
        var time = TimeZoneInfo.ConvertTimeBySystemTimeZoneId(DateTime.UtcNow, timeZone);
        return time.ToString(&quot;HH:mm:ss&quot;);
    }

    // Semantic Kernel

    [KernelFunction]
    [Description(&quot;Retrieve the current time of day in Hour-Minute-Second format for a specified time zone. Time zones should be written in standard formats such as UTC, US/Pacific, Europe/London.&quot;)]
    public static string TimeOfDay([Description(&quot;The time zone to get the current time for, such as UTC, US/Pacific, Europe/London.&quot;)]string timeZone)
    {
        var time = TimeZoneInfo.ConvertTimeBySystemTimeZoneId(DateTime.UtcNow, timeZone);
        return time.ToString(&quot;HH:mm:ss&quot;);
    }
}
</code></pre>
<p>Function Callingでは、Claudeに関数の情報を与えなければならないので、メソッド・パラメーター共に説明が必須です。ClaudiaのSource Generator実装ではそれをドキュメントコメントから取得するようにしました。Semantic KernelではDescription属性から取ってきています。これはドキュメントコメントのほうが自然で書きやすいはずです。特にパラメーターへの属性は、書きやすさだけじゃなく、複数パラメーターがある場合にかなり読みづらくなります。</p>
<p>また、Source Generatorではアナライザーとして不足がある際にはコンパイルエラーにできます。</p>
<p><img src="https://github.com/Cysharp/Claudia/assets/46207/1cfb81d4-9105-423f-867b-408d63e88a59" alt="image" /></p>
<p>全てのパラメーターにドキュメントコメントが書かれていなければならない・対応していない型を利用している、などのチェックが全てコンパイル時どころかエディット時にリアルタイムに分かります。</p>
<p>難点は実装難易度がSource Generatorのほうが高いことと、ドキュメントコメントの利用にはかなり注意が必要です。</p>
<p>Roslyn上でドキュメントコメントを取得するには、<code>ISymbol.GetDocumentationCommtentXml()</code>が最もお手軽なのですが、これが取得できるかどうかは<code>&lt;GenerateDocumentaionFile&gt;</code>に左右されます。<code>false</code>の場合は常にnullを返します。それだと使いにくすぎるので、ClaudiaではSyntaxNodeから取得しようとしたのですが、それも同じく<code>&lt;GenerateDocumentaionFile&gt;</code>の影響を受けていました。</p>
<p>そこでしょうがなく、以下のような拡張メソッドを用意することで全ての状況でドキュメントコメントを取得することに成功しました(Triviaベースなので少し扱いづらいですが、取れないよりも遥かにマシ）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static DocumentationCommentTriviaSyntax? GetDocumentationCommentTriviaSyntax(this SyntaxNode node)
{
    if (node.SyntaxTree.Options.DocumentationMode == DocumentationMode.None)
    {
        var withDocumentationComment = node.SyntaxTree.Options.WithDocumentationMode(DocumentationMode.Parse);
        var code = node.ToFullString();
        var newTree = CSharpSyntaxTree.ParseText(code, (CSharpParseOptions)withDocumentationComment);
        node = newTree.GetRoot();
    }

    foreach (var leadingTrivia in node.GetLeadingTrivia())
    {
        if (leadingTrivia.GetStructure() is DocumentationCommentTriviaSyntax structure)
        {
            return structure;
        }
    }

    return null;
}
</code></pre>
<p>DocumentationModeの状態によって<code>DocumentationCommentTriviaSyntax</code>が取れるかどうかが変わる(<code>GenerateDocumentaionFile=false</code>の場合はNoneになる)ので、Noneの場合は<code>DocumentationMode.Parse</code>をつけたうえでパースし直すことで取得できました。SyntaxNodeのままオプションを渡してCSharpSyntaxTreeを生成しても、パースし直してくれないのかDocumentationModeを変更しても無駄だったので、文字列化してからParseTextするようにしています。</p>
<h2>JSON Serializer</h2>
<p>リクエストもレスポンスもJSONです、今の世の中。そして、使うライブラリは<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.jsonserializer?view=net-8.0">System.Text.Json.JsonSerializer</a>一択です。異論を挟む余地は、ありますが、ない。好むと好まざると、もはや使わなければならないわけです。</p>
<p>System.Text.Jsonの特徴としてはUTF8ベースで処理ができることなので、極力文字列を通さないようにしてあげると高い性能が見込めます。<code>ReadOnlySpan&lt;byte&gt;</code>または<code>ReadOnlySequence&lt;byte&gt;</code>をデシリアライズするには <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonreader?view=net-8.0">Utf8JsonReader</a>を通す必要があります。これはref structだからアロケーションがないので、そのままnewして使っていきましょう。ではWriterは？というと、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json.utf8jsonwriter?view=net-8.0">Utf8JsonWriter</a>はclassです。どうして……？なので、Writerに関してはアプリケーションの作りによりますが、フィールドに持って使い回せるのならフィールドに持っての使いまわし(Resetがあります）、持てない場合は<code>[ThreadStatic]</code>から引っ張ってくるようにしましょう。</p>
<p>ライブラリで用意する場合は、利用する型が全て決まっているので<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/system-text-json/source-generation?pivots=dotnet-8-0">ソース生成</a>してあげると、パフォーマンスもよく、AOTセーフ度も上がるので望ましいはずです。Claudiaでも生成しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[JsonSourceGenerationOptions(
    GenerationMode = JsonSourceGenerationMode.Default,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
    WriteIndented = false)]
[JsonSerializable(typeof(MessageRequest))]
[JsonSerializable(typeof(Message))]
[JsonSerializable(typeof(Contents))]
[JsonSerializable(typeof(Content))]
[JsonSerializable(typeof(Metadata))]
[JsonSerializable(typeof(Source))]
[JsonSerializable(typeof(MessageResponse))]
[JsonSerializable(typeof(Usage))]
[JsonSerializable(typeof(ErrorResponseShape))]
[JsonSerializable(typeof(ErrorResponse))]
[JsonSerializable(typeof(Ping))]
[JsonSerializable(typeof(MessageStart))]
[JsonSerializable(typeof(MessageDelta))]
[JsonSerializable(typeof(MessageStop))]
[JsonSerializable(typeof(ContentBlockStart))]
[JsonSerializable(typeof(ContentBlockDelta))]
[JsonSerializable(typeof(ContentBlockStop))]
[JsonSerializable(typeof(MessageStartBody))]
[JsonSerializable(typeof(MessageDeltaBody))]
public partial class AnthropicJsonSerialzierContext : JsonSerializerContext
{
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 内部での利用時は全てこのJsonSerializerContextを指定している
JsonSerializer.SerializeToUtf8Bytes(request, AnthropicJsonSerialzierContext.Default.Options)
</code></pre>
<p>一つ引っ掛かったのが、<code>JsonIgnoreCondition.WhenWritingNull</code>が、通常(リフレクションベース)だと<code>Nullable&lt;T&gt;</code>にも効いていたのですが、Source Generatorだと効かなくなってnullの時に無視してくれなくなったという挙動の差異がありました。しょうがないので、全ての対象の型の<code>Nullable&lt;T&gt;</code>プロパティに直接<code>[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]</code>を付与することで回避しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public record class MessageRequest
{
    // ...

    [JsonPropertyName(&quot;temperature&quot;)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public double? Temperature { get; set; }
}
</code></pre>
<p>正直Source Generator版の実装漏れの気がするんですが、まぁ回避できたので、とりあえずはいっか。。。</p>
<h2>まとめ</h2>
<p>OpenAI APIに対するAzure OpenAI Serviceのように、AWS環境の人は<a href="https://aws.amazon.com/jp/bedrock/">Amazon Bedrock</a>経由のほうが使いやすい、というのがあるかもしれません。というわけで本日の先ほどのリリース(v1.0.1)でBedrock対応もしました！より一層利用しやすくなったはずです。</p>
<p>Anthorpic APIを使うにあたって、このClaudiaが、公式SDKや各言語の非公式SDKも含めて、最も使いやすいSDKになっているんじゃないかと自負します。ということは、C#が最もClaudeをAPI経由で使うのに捗る言語ということです！これはC#やるしかない！あるいはClaudeやるしかない！ということで、やっていきましょう……！</p>
</div>
<h1 data-pagefind-sort="date:2024-02-27" data-pagefind-meta="published:2024-02-27"><a href="https://neue.cc/2024/02/27_R3.html">R3 - C#用のReactive Extensionsの新しい現代的再実装</a></h1>
<ul class="date"><li>2024-02-27</li></ul>
<div class="entry_body"><p>先日、新しいC#用のReactive Extensionsの実装としてR3を正式公開しました！R3は<a href="https://github.com/dotnet/reactive">Rx for .NET</a>を第一世代、<a href="https://github.com/neuecc/UniRx">UniRx</a>を第二世代とした場合の、第三世代のRxという意味で命名しています。Rxとしてのコア部分(ほぼdotnet/reactiveと同様)は.NET共通のライブラリとして提供し、各プラットフォーム特化のカスタムスケジューラーやオペレーターは別ライブラリに分けるという形により、全ての.NETプラットフォーム向けのコアライブラリと、各種フレームワーク Unity, Godot, Avalonia, WPF, WinForms, WinUI3, Stride, LogicLooper, MAUI, MonoGame 向けの拡張ライブラリを提供しています。</p>
<ul>
<li><a href="https://github.com/Cysharp/R3">GitHub - Cysharp/R3</a></li>
</ul>
<p>幾つかの破壊的変更を含むため、ドロップインリプレースメントではないですが、dotnet/reactiveやUniRxからの移行も現実的に可能な範囲に収めてあります。この辺は語彙や操作がLINQ的に共通化されているというRxの良いところで、そこのところは大きく変わりはありません。思ったよりも何も変わっていない、といったような印象すら抱けるかもしれませんが、そう思っていただければ、それはそれでR3の設計としては大成功ということになります。</p>
<p>なので基本的なところはRxですし、使えるところも変わりないです。よって、押さえておくべきことは、なぜ今R3という新たな実装が必要になったかということと、Rx for .NET, UniRxとの違いはどこかということです。（新規の人は何も考えず使ってください……！）</p>
<p>機能とか移行とかの話は、toRisouPさんにより既に優れた記事が上がっているので、今回は概念的なところを中心に紹介します……！</p>
<ul>
<li><a href="https://qiita.com/toRisouP/items/e7be5a5a43058556db8f">次世代Rx「R3」解説</a></li>
<li><a href="https://qiita.com/toRisouP/items/4344fbcba7b7e8d8ce16">【Unity】 R3とUniRxの比較まとめ</a></li>
</ul>
<h2>Rxの歴史と vs async/await</h2>
<p>Rx使ってますか？という問いに、使ってません、と答える人も増えてきました。別にこれは.NETやUnityだけの話ではなく、JavaでもSwiftでもKotlinでも。明らかにプレゼンスが低下しています。なぜか？というと、それはもう簡単です。async/awaitが登場したから。.NETのReactive Extensionsが初登場したのは2009年。C# 3.0, .NET Framework 3.5の頃であり、対応プラットフォームもSilverlightやWindows Phoneといった、今はもう消滅したプラットフォームも並んでくるような時代。もちろん、async/await(初登場はC# 5.0, 2012年)も存在していません。まだTaskすら導入されていなかった頃です。余談ですがReactive Extensionsの&quot;Extensions&quot;は、先行して開発されていた<a href="https://en.wikipedia.org/wiki/Parallel_Extensions">Parallel Extensions</a>(Parallel LINQやTask Parallel Library, .NET Framework 4.0で追加された)から名前が取られたとされています。</p>
<p>Rxは、まず、言語サポートのない場合の非同期処理の決定版として、あらゆる言語に普及し一世を風靡しました。単機能なTaskやPromiseよりも、豊富なオペレーターを備えたRxのほうが使いやすいし遥かに強力！私も当時はTPLいらね、とRxに夢中になったものです。しかしasync/awaitが言語に追加されて以降の結果はご存じの通り。async/awaitこそが非同期処理の決定版として、これまたC#からあらゆる言語に普及し、非同期処理におけるスタンダードとなりました。（ちなみにF#こそが発祥だって言う人もいますが、国内海外問わず当時のF#コミュニティのC# async/awaitへの反発と難癖の数々はよーく覚えているので、あ、そうですか、ぐらいの感じです。awaitないしね）</p>
<p>async/awaitが普及したことにより、とりあえず非同期処理のためにRxを入れるという需要はなくなり、Rxの採用率は下がっていったのであった。UnityにおいてのRxのスタンダードであった<a href="https://github.com/neuecc/UniRx/">UniRx</a>の開発者である私も、別にそれに固執することはなく、むしろゲームエンジン(Unity)に特化したasync/awaitランタイムが必要であると素早く認知し、Unityにおいて必要な条件(C# 7.0)が揃ったタイミングで即座に<a href="https://github.com/Cysharp/UniTask">UniTask</a>を開発し、今ではUniTaskは絶対に入れるけどUniRxは入れない、といった開発者も増えてきました。そしてそれは悪いことではなく、むしろ正しい感覚であると思います。</p>
<h2>Rxの価値の再発見</h2>
<p>そもそもRxって別に非同期処理のためだけのシステムではないですよね？LINQ to Everythingではあったけれど、むしろEverythingというのはノイズで、分離するものは分離したほうがいい、最適なものはそれを使ったほうがいい。Rxを非同期処理のために使うべきではないし、長さ1のObservableはTaskで表現したほうが、分かりやすさにおいてもパフォーマンスにおいても利点がある。そうなるとRxにはasync/awaitと統合されたAPIが必要で、それはObservableはモナドだからSelectManyにTaskを渡せることもできるだとか、そんなどうでもいいことではない。真剣にasync/awaitと共存するRxを考えてみると、手を加えなければならないAPIは多数ある。</p>
<p>単純にawaitできるだけでは現実のアプリケーション開発には少し足りない。そこで非同期/並列処理に関しては様々なライブラリが考案されてきました、Rxだけではなく<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/parallel-programming/dataflow-task-parallel-library">TPL Dataflow</a>など色々ありましたが、それらを好んで今から使おうとする人もいないでしょう。そして今は2024年、勝者は決まりました。言語サポートの<a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/generate-consume-asynchronous-stream">IAsyncEnumerable</a>と<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>がベストです。また、これらはバックプレッシャーの性質も内包しているため、RxJavaなどにあるバックプレッシャーに関するオペレーターは.NETには不要でしょう。もう少し具体的なI/Oに関する処理が必要なら<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/io/pipelines">System.IO.Pipelines</a>を選べば、最大のパフォーマンスを発揮できます。</p>
<p>非同期LINQはあってもいいけれど、実際の非同期ストリームのシナリオからするとLINQ to Objectsと違い利用頻度も少ないので、別に積極的に導入したいというほどの代物ではない(なお、これは私はUniTaskに<a href="https://github.com/Cysharp/UniTask/tree/809d23e/src/UniTask/Assets/Plugins/UniTask/Runtime/Linq">UniTaskAsyncEnumerableとLINQ</a>を自分で実装して提供している上での発言です)。Rxの夢の一つとして分散クエリ(IQbservable)がありましたが、それも、現代での勝者は<a href="https://graphql.org/">GraphQL</a>になるでしょう。分散システムという点では<a href="https://kubernetes.io/">Kubernetes</a>が普及し、RPCとしては<a href="https://grpc.io/">gRPC</a>がスタンダードとして君臨し、<a href="https://learn.microsoft.com/en-us/dotnet/orleans/">Orleans</a>, <a href="https://getakka.net/">Akka.NET</a>, <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction">SignalR</a>, <a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>といったような選択肢のバリエーションもあります。</p>
<p>今は様々なテクノロジーが覇権を争った2009年ではない。現代で<a href="https://azure.microsoft.com/ja-jp/products/service-fabric">Service Fabric</a>を選ぶ人などいないように、今からそこに乗り出して勝ち筋を見出すのは難しい。そうした分散処理に進むことはRxの未来ではない。と、私は考えています。Rxを生み出したのがCloud Programmability Teamであるからといって、Cloudで活用できるようにすることが原点で正しいなどということもないだろう。もちろん、未来は複数あってもいいので、私が示すRxの未来の選択肢の一つがR3だと思ってもらえればよいです。</p>
<p>ではRxの価値はどこにあるのか、というと、原点に立ち返ってインメモリのメッセージングをLINQで処理するLINQ to Eventsにあると考えます。特にクライアントサイド、UIに対する処理は、現代でもRxが評価されているポイントであり、Rx Likeな、しかしより言語に寄り添い最適化されている<a href="https://kotlinlang.org/docs/flow.html">Kotlin Flow</a>や<a href="https://developer.apple.com/documentation/combine">Swift Combine</a>といった選択肢が現役で存在しています。UIだけではなく、複雑で大量のイベントが飛び交うゲームアプリケーションにおいても、ゲームエンジン(Unity)で使われているUniRxの開発者として、非常に有益であることを実感しています。オブザーバーパターンやeventの有意義さは疑う余地のないところですし、そこでRxがbetter event、オブザーパーパターンの決定版として使えることもまた変わらないわけです。</p>
<h2>R3での再構築</h2>
<p>最初に、Rxとしてのインターフェイスを100%維持しながらレガシーAPIの削除や新APIの追加をすべきか、それとも根本から変更すべきかを悩みました。しかし（私が問題だと考えている）すべての問題を解決するには抜本的な変更が必要だし、Kotlin FlowやSwift Combineの成功事例もあるので、旧来のRxとの互換性に囚われず、.NET 8, C# 12という現代のC#環境に合わせて再構築された、完全に新しいRxであるべきという路線に決めました。</p>
<p>といっても、最終的にはインターフェイスにそこまで大きな違いはありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public abstract class Observable&lt;T&gt;
{
    public IDisposable Subscribe(Observer&lt;T&gt; observer);
}

public abstract class Observer&lt;T&gt; : IDisposable
{
    public void OnNext(T value);
    public void OnErrorResume(Exception error);
    public void OnCompleted(Result result); // Result is (Success | Failure)
}
</code></pre>
<p>パッと見だとOnErrorがOnErrorResumeになったことと、interfaceではなくてabstract classになったこと、ぐらいでしょうか。どうしても変更したかった点の一つがOnErrorで、パイプライン上で例外が起きると購読解除されるという挙動はRxにおける<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar mistake</a>だと思っています。R3では例外はOnErrorResumeに流れて、購読解除されません。かわりにOnCompletedに、SuccessまたはFailureを表すResultが渡ってくるようになっていて、こちらでパイプラインの終了が表されています。</p>
<p><code>IObservable&lt;T&gt;/IObserver&lt;T&gt;</code>の定義は<code>IEnumerble&lt;T&gt;/IEnumerator&lt;T&gt;</code>と密接に関わっていて、<a href="https://en.wikipedia.org/wiki/Duality_(mathematics)">数学的双対</a>であると称しているのですが、実用上不便なところがあり、その最たるものがOnErrorで停止することです。なぜ不便かというと、<code>IEnumerable&lt;T&gt;</code>のforeachの例外発生と<code>IObservable&lt;T&gt;</code>の例外発生では、ライフタイムが異なることに起因します。foreachの例外発生はそこでイテレーターの消化が終わり、必要があればtry-catchで処理して、大抵はリトライすることもないですが、ObservableのSubscribeは違います。イベントの購読の寿命は長く、例外発生でも停止しないで欲しいと思うことは不自然ではありません。通常のeventで例外が発生したとて停止することはないですが、Rxの場合はオペレーターチェーンの都合上、パイプライン中に例外が発生する可能性が常にあります(SelectやWhereすればFuncが例外を出す可能性がある)。イベントの代替、あるいは上位互換として考えると、例外で停止するほうが不自然になってしまいます。</p>
<p>そして、必要があればCatchしてRetryすればいい、というものではない！Rxにおいて停止したイベントを再購読するというのは非常に難しい！Observableにはeventと異なり、完了するという概念があります。完了したIObservableを購読すると即座にOnError | OnCompletedが呼ばれる、それにより自動的な再購読は、完了済みのシーケンスを再購読しにかかる危険性があります。もちろんそうなれば無限ループであり、それを判定し正しくハンドリングする術もない。Stack OverflowにはRx/Combine/FlowのUI購読で再購読するにはどうすればいいですか？のような質問が多数あり、そしてその回答は非常に複雑なコードの記述を要求していたりします。現実はRepeat/Retryだけで解決していない！</p>
<p>そこで、そもそも例外で停止しないように変更しました。OnErrorという命名のままでは従来の停止する動作と混同する可能性があるため、かわりにOnErrorResumeという名前に変えています。これで再購読に関する問題は全て解決します。更にこの変更には利点があり、停止する→停止しないの挙動変更は不可能ですが(Disposeチェーンが走ってしまうので状態を復元できないので全体の再購読以外に手段がない)、停止しない→停止するへの挙動変更は非常に簡単でパフォーマンスもよく実装できます。OnErrorResumeが来たらOnCompleted(Result.Failure)に変換するオペレーターを用意するだけですから（標準でOnErrorResumeAsFailureというオペレーターを追加してあります）。</p>
<p>Rx自体が複雑なコントラクトを持つ(OnErrorかOnCompletedはどちらか一つしか発行されない、など)わりに、インターフェースは実装上の保証がないので、従来のRxは正しく実装するのが難しいという問題がありました。SourceのSubscribeが遅延される場合は、先行して返却されるDisposableを正しくハンドリングする必要がある(SingleAssignmentDisposableを使う）などといったことも、正しく理解することは難しいでしょう。SubscribeのonNextで発生した例外はどこに行くのか、onErrorに行ってDisposeされるのか継続されるのか。その動作は特に規定されていないため実装次第で挙動はバラバラの場合もあります。R3ではasbtract class化することにより大部分のコントラクトを保証し、挙動の統一と、独自実装を容易にしました。</p>
<p>そしてabstract classにした最大の理由は、全ての購読を中央管理できるようにしたことです。全てのSubscribeは必ず基底クラスのSubscribe実装を通ります。これにより、購読のトラッキングが可能になりました。例えば以下のような形で表示できます。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/149abca5-6d84-44ea-8373-b0e8cd2dc46a" alt="image" /></p>
<blockquote>
<p>これはUnity向けの拡張Windowですが、Godot用にも存在するほか、APIとして提供しているためログに出したり任意のタイミングで取得したり、独自の可視化を作ることも可能です</p>
</blockquote>
<p>TaskにはParallel Debuggerがありますが（これもTaskが基底クラス側でs_asyncDebuggingEnabledの時に中央管理している）、Rxの購読の可視化は、それよりも遥かに重要でしょう。イベントの購読リークはつきもので、開発終盤に必死に探し回る羽目になりますが、R3ならもう不要です！圧倒的開発効率アップ！</p>
<p>R3ではこうした購読の管理、リーク防止については最重要視していて、Observable Trackerによる全ての購読の追跡の他に、概念として「全てのObservableは完了することができる」ようにしました。</p>
<p>Rxにおける購読の管理の基本はIDisposableをDisposeすることです。が、購読を解除する方法は実はそれだけではなく、OnError | OnCompletedが流れることでも解除されるようになっています（IObservableのコントラクトが保証しているわけではないですが実装上そうなっている、R3では必ずそうなるように基底クラス側で保証するようにした）。つまりシーケンスの上流(OnError | OnCompletedの発行)と下流(Dispose)、両面からハンドリングすることでリークをより確実に防ぐことができます。</p>
<p>対応として過剰に思うかもしれませんが、実際のアプリケーションを開発してきた経験からいうと、購読管理は過剰なぐらいがちょうどいい。そうした思想から、R3では、今までOnCompletedを発行する手段のなかったObservable.FromEventやObservable.Timer、EveryUpdateなども、OnCompletedを発行可能にしました。なお、発行方法はCancellationTokenを渡すことで、これもasync/await以降に多用（あるいは濫用）されるようになったCancellationTokenを活用する現代的なAPI設計です。また、こうした全てのObservableは完了する、という思想があるため、SubjectのDisposeも標準でOnCompletedを発行するように変更しました。</p>
<h2>ISchedulerを再考する</h2>
<p>Rxの時空を移動するマジックを実現する機構がISchedulerです。TimerやObserveOnに渡すことで、任意の場所(ThreadやDispatcher、PlayerLoopなど)・時間に値を移動させることができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IScheduler
{
    DateTimeOffset Now { get; }

    IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
}
</code></pre>
<p>そして、実は破綻しています。Rxのソースコードを見たことがあるなら気づいているかもしれませんが、初期のうちから追加の別の定義が用意されています。例えばThreadPoolSchedulerは以下のようなインターフェイスを実装しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface ISchedulerLongRunning
{
    IDisposable ScheduleLongRunning&lt;TState&gt;(TState state, Action&lt;TState, ICancelable&gt; action);
}

public interface ISchedulerPeriodic
{
    IDisposable SchedulePeriodic&lt;TState&gt;(TState state, TimeSpan period, Func&lt;TState, TState&gt; action);
}

public interface IStopwatchProvider
{
    IStopwatch StartStopwatch();
}

public abstract partial class LocalScheduler : IScheduler, IStopwatchProvider, IServiceProvider
{
}

public sealed class ThreadPoolScheduler : LocalScheduler, ISchedulerLongRunning, ISchedulerPeriodic
{
}
</code></pre>
<p>そして、以下のような呼び出しがなされています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IStopwatch StartStopwatch(this IScheduler scheduler)
{
    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        return swp.StartStopwatch();
    }

    return new EmulatedStopwatch(scheduler);
}

private static IDisposable SchedulePeriodic_&lt;TState&gt;(IScheduler scheduler, TState state, TimeSpan period, Func&lt;TState, TState&gt; action)
{
    var periodic = scheduler.AsPeriodic();
    if (periodic != null)
    {
        return periodic.SchedulePeriodic(state, period, action);
    }

    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        var spr = new SchedulePeriodicStopwatch&lt;TState&gt;(scheduler, state, period, action, swp);
        return spr.Start();
    }
    else
    {
        var spr = new SchedulePeriodicRecursive&lt;TState&gt;(scheduler, state, period, action);
        return spr.Start();
    }
}
</code></pre>
<p>ようは生のISchedulerを使わないケースがそれなりにあります。なぜ使われないのか、というと、パフォーマンス上の問題で、IScheduler.Scheduleは単発の実行しか定義されていなくて、複数回の呼び出しは再帰的にScheduleを呼べばいいじゃんという発想なわけですが、都度IDisposableを生成するなどパフォーマンス的に問題がある。ので、それを回避するためにISchedulerPeriodicなどが用意されたのでした。</p>
<p>それなら、もうISchedulerではなく、実態をまともに反映されたものを使ったほうがいいんじゃないか？と思ったときに出てきたのが.NET 8で追加された<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>で、これならISchedulerが行っていたことをより効率的にできることを発見しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public abstract class TimeProvider
{
    // use these.
    public virtual ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period);
    public virtual long GetTimestamp();
}
</code></pre>
<p>CreateTimerで生成されるITimerはISchedulerPeriodicで行える機能を十分持っているほか、ワンタイムの実行を繰り返す(<code>Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)</code>)のシナリオにおいても、ITimerを使いまわせるため、dotnet/reactiveのThreadPoolSchedulerよりも効率的です(ThreadPoolSchedulerは都度<code>new Timer()</code>している)。</p>
<p>現在時間の取得に関しては、<code>DateTimeOffset IScheduler.Now</code>のようにTimeProviderも<code>DateTimeOffset TimeProvider.GetUtcNow()</code>がありますが、使っているのは<code>long GetTimestamp</code>だけです。というのも、オペレーターの実装に必要なのはTicksだけなので、わざわざDateTimeOffsetに包むようなオーバーヘッドはないほうが良いので、生のTicksを扱って時間を計算します。</p>
<p>DateTimeOffset.UtcNowはOSのシステム時刻の変更の影響を受ける可能性もあるので、そういう点でもDateTimeOffsetを介さないGetTimestamp(標準では<code>Stopwatch.GetTimestamp()</code>からの高解像度タイマーが利用される)経由が良いでしょう。</p>
<p>ISchedulerのもう一つの問題として、同期的な処理を行う<code>ImmediateScheduler</code>や<code>CurrentScheduler</code>がいます。これらにTimerやDelayなど時間系の処理を任せるとThread.Sleepするという、使うべきではない非同期コードのエミュレーションをするので、つまり、同期的なSchedulerは存在が悪なのでないほうがいいでしょう。R3では完全に消し、TimeProviderを指定するということは必ず非同期的な呼び出しであるということを徹底しました。</p>
<p><code>ImmediateScheduler</code>や<code>CurrentScheduler</code>の問題はそれだけじゃなくて、そもそもパフォーマンスが致命的に悪いという問題があります。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/68a12664-a840-4725-a87c-8fdbb03b4a02" alt="image" /></p>
<blockquote>
<p><code>Observable.Range(1, 10000).Subscribe()</code> の結果</p>
</blockquote>
<p><code>CurrentScheduler</code>はともかく、<code>ImmediateScheduler</code>の結果が悪いのは直観に反するかもしれません。dotnet/reactiveの<code>ImmediateScheduler</code>は、Scheduleされるたびに<code>new AsyncLockScheduler()</code>し、<code>AsyncLockScheduler</code>が呼び出す基底クラス<code>LocalScheduler</code>のコンストラクターが<code>SystemClock.Register</code>し、それは<code>lock</code>し<code>new WeakReference&lt;LocalScheduler&gt;(scheduler)</code>し、<code>HashSet.Add</code>します。パフォーマンスが悪いのも当然です(ただし再帰的な呼び出し時には都度<code>SingleAssignmentDisposable</code>を生成するだけに抑えられてはいます、それでも多いですが)</p>
<p>Rangeなんてめったに使わないから大丈夫と思いきや、実は意外なところで<code>ImmediateScheduler</code>はちょくちょく使われています。代表的なのが<code>Merge</code>で、これは<code>IScheduler</code>が無指定の場合は<code>ImmediateScheduler</code>を使うため、頻繁な購読を繰り返す作りになっていると、かなりの呼び出す回数になる可能性があります。実際、dotnet/reactiveをサーバーアプリケーションで使用した際に、MergeとImmediateSchedulerが原因でサーバーのメモリ使用量のかなりを占めたことがありました。その時はカスタムの軽量なスケジューラーを作成し、直接指定することで徹底的に<code>ImmediateScheduler</code>を避けることで何とかしました。Next dotnet/reactiveがあるなら、<code>ImmediateScheduler</code>のパフォーマンスの改善は真っ先に行う必要があります。</p>
<blockquote>
<p><code>SystemClock.Register</code>をしている理由としては、<code>DateTimeOffset.UtcNow</code>とシステム時刻の変更の監視のためのようです。つまり、最初からDateTimeOffsetではなくlongを使えば、このような致命的なパフォーマンス低下も招きませんでした。これもまたISchedulerのインターフェイス定義の失敗理由の一つです。</p>
</blockquote>
<p>ところで、TimeProviderの採用によって、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.time.testing.faketimeprovider?view=dotnet-plat-ext-8.0">Microsoft.Extensions.Time.Testing.FakeTimeProvider</a>を使い、標準的な手法でユニットテストが容易になったことも嬉しいところでしょう。</p>
<h2>FrameProvider</h2>
<p>他のRxでは見かけないがUniRxで絶大な効果を発揮したものとして、フレームベースのオペレーター郡があります。一定フレーム後に実行する<code>DelayFrame</code>や次フレームで実行する<code>NextFrame</code>、毎フレーム発行するファクトリーである<code>EveryUpdate</code>や、毎フレーム値を監視する<code>EveryValueChanged</code>など、ゲームエンジンで利用するにあたって便利なオペレーターが揃っています。</p>
<p>そこで気づいたのが、時間とフレームは概念的には似たものであり、ゲームエンジンだけでなく、UI処理ではメッセージループやレンダリングループという形で、様々なフレームワークに存在している。そこで、R3では新しくTimerProviderと対になるFrameProviderという形でフレームベースの処理を抽象化しました。これによってUnityだけに提供されていたフレームベースのオペレーターが、C#が動作するあらゆるフレームワーク(WinForms, WPF, WinUI3, MAUI, Godot, Avalonia, Stride, etc...)で動作せることができるようになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public abstract class FrameProvider
{
    public abstract long GetFrameCount();
    public abstract void Register(IFrameRunnerWorkItem callback);
}

public interface IFrameRunnerWorkItem
{
    // true, continue
    bool MoveNext(long frameCount);
}
</code></pre>
<p>R3ではTimeProviderを要求するオペレーターがある場合、全てに対となる***Frameオペレーターを実装しました。</p>
<ul>
<li>Return &lt;-&gt; ReturnFrame</li>
<li>Yield &lt;-&gt; YieldFrame</li>
<li>Interval &lt;-&gt; IntervalFrame</li>
<li>Timer &lt;-&gt; TimerFrame</li>
<li>Chunk &lt;-&gt; ChunkFrame</li>
<li>Debounce &lt;-&gt; DebounceFrame</li>
<li>Delay &lt;-&gt; DelayFrame</li>
<li>DelaySubscription &lt;-&gt; DelaySubscriptionFrame</li>
<li>ObserveOn(TimeProvider) &lt;-&gt; ObserveOn(FrameProvider)</li>
<li>Replay &lt;-&gt; ReplayFrame</li>
<li>Skip &lt;-&gt; SkipFrame</li>
<li>SkipLast &lt;-&gt; SkipLastFrame</li>
<li>SubscribeOn(TimeProvider) &lt;-&gt; SubscribeOn(FrameProvider)</li>
<li>Take &lt;-&gt; TakeFrame</li>
<li>TakeLast &lt;-&gt; TakeLastFrame</li>
<li>ThrottleFirst &lt;-&gt; ThrottleFirstFrame</li>
<li>ThrottleFirstLast &lt;-&gt; ThrottleFirstLastFrame</li>
<li>ThrottleLast &lt;-&gt; ThrottleLastFrame</li>
<li>Timeout &lt;-&gt; TimeoutFrame</li>
</ul>
<h2>async/await Integration</h2>
<p>まず、既存のRxにおいて良くない点である単一の値を返すObservableを徹底的に排除しました。これらはasync/awaitを使うべきで、単一の値を返したり、単一の値を期待して合成するようなオペレーターはバッドプラクティスに誘うノイズです。FirstはFirstAsyncになり、<code>Task&lt;T&gt;</code>を返します。AsyncSubjectはなくなり、TaskCompletionSourceを使ってください。</p>
<p>そのうえで、現在のC#コードは日常的に非同期のコードが返ってきます、が、基本的にはRxは同期コードしか受け取りません。うっかりすればFireAndForget状態になるし、SelectManyに混ぜるだけでは十分とはいえません。そこで、Where/Select/Subscribeに特殊なメソッド群を用意しました。</p>
<ul>
<li><strong>SelectAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;TResult&gt;&gt;</code> selector, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>WhereAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;Boolean&gt;&gt;</code> predicate, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
<li><strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Exception&gt;</code> onErrorResume, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperation</code> awaitOperation = Sequential, ...)</li>
</ul>
<pre data-pagefind-ignore="all"><code class="language-csharp">public enum AwaitOperation
{
    /// &lt;summary&gt;All values are queued, and the next value waits for the completion of the asynchronous method.&lt;/summary&gt;
    Sequential,
    /// &lt;summary&gt;Drop new value when async operation is running.&lt;/summary&gt;
    Drop,
    /// &lt;summary&gt;If the previous asynchronous method is running, it is cancelled and the next asynchronous method is executed.&lt;/summary&gt;
    Switch,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method.&lt;/summary&gt;
    Parallel,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method, but the results are queued and passed to the next operator in order.&lt;/summary&gt;
    SequentialParallel,
    /// &lt;summary&gt;Send the first value and the last value while the asynchronous method is running.&lt;/summary&gt;
    ThrottleFirstLast
}
</code></pre>
<p>SelectAwait, WhereAwait, SubscribeAwaitは非同期メソッドを受け取り、その非同期メソッドが実行されている間に届く値に対する処理のパターンを6パターン用意しました。Sequentialはいったんキューにためて非同期メソッドが完了したら新しい値を送ります。Dropは実行中に届いた値は全て捨てます、これはイベントハンドリングで多重Submit防止などに使えます。Switchは<code>Observable&lt;Observable&gt;.Switch</code>と同様、Parallelは並列実行するもので<code>Observable&lt;Observable&gt;.Merge</code>と同様、ですがわかりやすいでしょう。並列実行数も指定できます。SequentialParallelは並列実行しつつ、後続に流す値は届いた順序で保証します。ThrottleFirstLastは非同期メソッド実行中の最初の値と最後の値を送ります。</p>
<p>更に、以下の時間系のフィルタリングメソッドなども非同期メソッドを受け取るようになっています。</p>
<ul>
<li><strong>Debounce</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> throttleDurationSelector, ...)</li>
<li><strong>ThrottleFirst</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
<li><strong>ThrottleLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
<li><strong>ThrottleFirstLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, ...)</li>
</ul>
<p>また、Chunkも同様に非同期メソッドを受け取るほか、SkipUntilには非同期メソッドと、Task, CancellationTokenを受け取れるようになっています。</p>
<ul>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>CancellationToken</code> cancellationToken)</li>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Task</code> task)</li>
<li><strong>SkipUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> asyncFunc, ...)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>CancellationToken</code> cancellationToken)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Task</code> task)</li>
<li><strong>TakeUntil</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> asyncFunc, ...)</li>
<li><strong>Chunk</strong>(this Observable<T> source, Func&lt;T, CancellationToken, ValueTask&gt; asyncWindow, ...)</li>
</ul>
<p>例えばChunkの非同期関数版を使えば、固定時間ではなくてランダム時間でチャンクを生成するといった複雑な処理を、自然に簡単に書けるようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.Interval(TimeSpan.FromSeconds(1))
    .Index()
    .Chunk(async (_, ct) =&gt;
    {
        await Task.Delay(TimeSpan.FromSeconds(Random.Shared.Next(0, 5)), ct);
    })
    .Subscribe(xs =&gt;
    {
        Console.WriteLine(string.Join(&quot;, &quot;, xs));
    });
</code></pre>
<p>async/awaitは現代のC#に欠かせないコードですが、可能な限りスムーズにRxと統合されるように腐心しました。</p>
<p>Retry関連もasync/awaitを活用することで、よりベターなハンドリングができます。まず、以前のRxはパイプライン丸ごとのリトライしか出来ませんでしたが、async/awaitを受け入れられるR3なら、非同期メソッド実行単位でのリトライができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">button.OnClickAsObservable()
    .SelectAwait(async (_, ct) =&gt;
    {
        var retry = 0;
    AGAIN:
        try
        {            
            var req = await UnityWebRequest.Get(&quot;https://google.com/&quot;).SendWebRequest().WithCancellation(ct);
            return req.downloadHandler.text;
        }
        catch
        {
            if (retry++ &lt; 3) goto AGAIN;
            throw;
        }
    }, AwaitOperation.Drop)
    .SubscribeToText(text);
</code></pre>
<p>Repeatもasync/awaitと組み合わせることで実装できます。この場合、Repeatの条件に関する複雑なハンドリングがRxだけで完結させるよりも、容易にできるでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">while (!ct.IsCancellationRequested)
{
    await button.OnClickAsObservable()
        .Take(1)
        .ForEachAsync(_ =&gt;
        {
            // do something
        });
}
</code></pre>
<p>手続き的なコードは決して悪いことではないですし、場合によりRxのオペレーターだけで完結させるよりも可読性が高くなります。コーディングにおいて優先すべきは可読性の高さ（とパフォーマンス）です。より良いコードのためにも、Rxとasync/awaitをうまく連携させていきましょう。</p>
<p>CreateやCreateFromなどで、非同期メソッドからObservableを生成することもできます。ここから生成することで、オペレーターを無理やりこねくり回すよりも簡潔に記述することが可能かもしれません。</p>
<ul>
<li><code>Create(Func&lt;Observer&lt;T&gt;, CancellationToken, ValueTask&gt; subscribe, ...)</code></li>
<li><code>CreateFrom(Func&lt;CancellationToken, IAsyncEnumerable&lt;T&gt;&gt; factory)</code></li>
</ul>
<h2>名前付けのルール</h2>
<p>R3では幾つかのメソッドの名前がdotnet/rectiveやUniRxから変更されています。例えば以下のものです。</p>
<ul>
<li><code>Buffer</code> -&gt; <code>Chunk</code></li>
<li><code>StartWith</code> -&gt; <code>Prepend</code></li>
<li><code>Distinct(selector)</code> -&gt; <code>DistinctBy</code></li>
<li><code>Throttle</code> -&gt; <code>Debounce</code></li>
<li><code>Sample</code> -&gt; <code>ThrottleLast</code></li>
</ul>
<p>この変更の理由について説明しましょう。</p>
<p>まず、.NETにおいてLINQスタイルのライブラリを作成する場合に最優先すべき名前はLINQ to Objects(Enumerable)に実装されているメソッド名です。<code>Buffer</code>がなぜ<code>Chunk</code>に変更されたかというと、.NET 6からEnumerable.Chunkが追加され、その機能がBufferと同じだからです。RxのほうがChunkの登場より遥か前なので、名前が違うのはどうにもならないのですが、何のしがらみもないのなら名称はLINQ to Objectsに合わせなければならない。よって、Chunk一択です。PrependやDistinctByも同様です。</p>
<p><code>Throttle</code>が<code>Debounce</code>に変更されたことには抵抗があるかもしれません。これは、そもそも世の中のスタンダードは<code>Debounce</code>だからです。Rx系で<code>Debounce</code>を<code>Throttle</code>という名前でやってるのはdotnet/reactiveだけです。世の中のRxの始祖はRxNetなのだから変えなきゃいけない謂われはない、と突っぱねることも正義ではあるんですが、もはや多勢に無勢の少数派なので、長いものに巻かれることもまた正しい。</p>
<p><code>Debounce</code>に変えた理由はそれだけではなく、<code>ThrottleFirst</code> / <code>ThrottleLast</code>の存在もあります。これらはサンプリング期間の最初の値を採用する、または最後の値を採用する、というもので対になっています。で、(dotnet/reactiveの)Throttleは全然違う挙動なわけです、なのにThrottleという名前は混乱するでしょう。そももそもdotnet/reactiveにはThrottleFirstが存在せず、ThrottleLastに相当するSampleのみが存在するので大丈夫なのですが、ThrottleFirst/ThrottleLastを採用するなら、必然的に名前は<code>Debounce</code>にせざるを得ません。どちらかというとdotnet/reactiveの機能不足が悪い。</p>
<p><code>Sample</code>に関してはFirst/Lastという名前と機能の対称性から<code>ThrottleLast</code>という名前に変更しました。dotnet/reactiveではFirstが存在しないのでSampleでも良かったのですが、<code>ThrottleFirst</code>を採用するなら、必然的に名前は<code>ThrottleLast</code>になります。</p>
<p><code>Sample</code>の名前は残して<code>ThrottleLast</code>のエイリアスにするという折衷案もあるのですが(RxJavaなどはそうなっています)、同じ機能の別名があるとユーザーは混乱します。世の中には<code>sample</code>と<code>throttleLast</code>の違いってなんですか？みたいな質問がそれなりにあります。ただでさえ複雑なRx、無用な混乱を避けるためにもエイリアスは絶対にやめるべき。SelectをMap、WhereをFilterにマッピングするみたいなエイリアスは愚かの極みです。</p>
<h2>プラットフォーム向けデフォルトスケジューラー</h2>
<p>dotnet/reactiveにおいてデフォルトのスケジューラーはほとんど固定です。正確には<code>IPlatformEnlightenmentProvider</code>や<code>IConcurrencyAbstractionLayer</code>というのものを適切に実装すれば、ある程度挙動を差し替えることも可能なのですが、無駄に複雑なうえに<code>[EditorBrowsable(EditorBrowsableState.Never)]</code>で隠されているしで、まともに使うことはほとんど想定されていないように見えます。</p>
<p>しかし、TimerやDelayなどはWPFであればDispatcherTimerで、UnityではPlayerLoop上のTimerで動くと、自動的にメインスレッドにディスパッチしてくれるので、ほとんどの場合でObserveOnが不要になるので便利ですしパフォーマンス上も有利に働きます。</p>
<p>R3ではシンプルにデフォルトのTimeProvider/FrameProviderを差し替えられるようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ObservableSystem
{
    public static TimeProvider DefaultTimeProvider { get; set; } = TimeProvider.System;
    public static FrameProvider DefaultFrameProvider { get; set; } = new NotSupportedFrameProvider();
}
</code></pre>
<p>アプリケーション起動時に差し替えれば、そのアプリケーション上でベストなスケジューラーがデフォルト利用されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 例えばWPFの場合はDispatcher系がセットされるので自動的にUIスレッドに戻ってくる
public static class WpfProviderInitializer
{
    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new WpfDispatcherTimerProvider();
        ObservableSystem.DefaultFrameProvider = new WpfRenderingFrameProvider();
    }
}

// Unityの場合はPlayerLoopベースのものが使用されるのでThreadPoolを避けれる
public static class UnityProviderInitializer
{
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
    public static void SetDefaultObservableSystem()
    {
        SetDefaultObservableSystem(static ex =&gt; UnityEngine.Debug.LogException(ex));
    }

    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = UnityTimeProvider.Update;
        ObservableSystem.DefaultFrameProvider = UnityFrameProvider.Update;
    }
}
</code></pre>
<p>dotnet/reactiveがデフォルトスケジューラーを変更できないのは、あまり、多種のプラットフォームをサポートしているとは言い難いでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal static class SchedulerDefaults
{
    internal static IScheduler ConstantTimeOperations =&gt; ImmediateScheduler.Instance;
    internal static IScheduler TailRecursion =&gt; ImmediateScheduler.Instance;
    internal static IScheduler Iteration =&gt; CurrentThreadScheduler.Instance;
    internal static IScheduler TimeBasedOperations =&gt; DefaultScheduler.Instance;
    internal static IScheduler AsyncConversions =&gt; DefaultScheduler.Instance;
}
</code></pre>
<p>特にAOTのシナリオやWeb向けパブリッシュ(WASM)では、ThreadPoolが使えなくて絶対に避けたいという状況もあります。そこでSchedulerDefaults.TimeBasedOperationsが実質ThreadPoolSchedulerに固定されているのは厳しいと言わざるを得ません。</p>
<h2>Pull IAsyncEnumerable vs Push Observable</h2>
<p><code>IAsyncEnumerable</code>(またはUniTaskの<code>IUniTaskAsyncEnumerable</code>)は、Pullベースの非同期シーケンス。RxはPushベースの非同期シーケンス。似てます。LINQ的なことができるのも似てます。どちらを使うべきかがケースバイケースなのは当然だとして、じゃあそのケースってのはなんなのか、いつどちらを使えばいいのか。という判断基準は欲しいところです。</p>
<p>基本的には裏にバッファー（キュー）があるものはPullベースが向いていると思うので、ネットワーク系のシナリオなんかは<code>IAsyncEnumerable</code>を使っていくといいんじゃないでしょーか。で、実際、<code>System.IO.Pipelines</code>や<code>System.Threading.Channels</code>によって自然と使う機会が出てきます。</p>
<p>Rxを使うべきところは、やはりイベント関連です。</p>
<p>どちらを使うべきかの判断の決め手は、源流のソースにとって自然な表現を選ぶべき、ということです。生のイベント、OnMoveであったりOnClickであったりなどは、完全にPushで、そこにバッファーはありません。ということは、Rxで扱うほうが自然です。間にキューを挟んで<code>IAsyncEnumerable</code>で扱うこともできますが、不自然ですよね。あるいはキューを介さないことにより意図的に値をDropするという表現をすることもできますが、やはりそれも不自然です。不自然ということはたいていはパフォーマンスも良くないし、分かりやすくもない。つまり、良くない。だから、イベント関連はRxで扱いましょう。R3ならasync/awaitとの統合によって、非同期処理中のバッファリングや値のドロップなどは明示的にオペレーターで指定することができます。それは、分かりやすく、パフォーマンスも良い。R3を使っていきましょう。</p>
<h2>C#パフォーマンス勉強会</h2>
<p>ところで4/27に<a href="https://cs-reading.connpass.com/event/309714/">C#パフォーマンス勉強会</a>という勉強会が大阪で（大阪で！）開催されます。私は「R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例」というタイトルで、R3の！実装の！パフォーマンス上の工夫を！徹底的に解説しようと思っているので、参加できる方はぜひぜひです。関西へは滅多に行かないので貴重な機会ということなのでよろしくお願いします！</p>
<h2>まとめ</h2>
<p>色々言いましたが、オリジナルのRx.NETの作者達には感謝しかありません。改めて、やはりRxのアイディアの素晴らしさや、各種オペレーターの整理された機能には目を見張るものがあります。幾つかの部分の実装は古くなってしまっていますが、実装クオリティも高いと思います。私自身も最初期から使ってきたし、熱狂してきました。そして、現在のメンテナーにも感謝します。常に変わっていく環境の中で、多く使われているライブラリを維持することはとても大変なことです。</p>
<p>しかし、だからこそ、Rxの価値を復活させたかった。そして、再構築するならば、できるのは私しかいないと思った。最初期からのRxの歴史と実装を知っていて、自分でRxそのものの実装(UniRx)を行い、それが世の中に広く使われることで多くのユースケースや問題点を知り、自分自身もゲームタイトルの実装で大規模に使われるRxのアプリケーション側にも関わり、Rxと対となるasync/awaitの独自ランタイム(UniTask)を実装し、それも世の中に広く使われていることで、この領域に関してのあらゆる知見がある。</p>
<p>上のほうでも言いましたが、未来は複数あってもいいので、私が示すRxの未来の一つがR3だと思ってもらえればよいです。dotnet/reactiveにもまた別の進化と未来がある。かもしれません。</p>
<p>そのうえでR3は置き換えられるだけのポテンシャルと、可能性を見せることができたと思っています。実装には自信あり、です。今回UniRxの実績があったからというのもあり、プレビュー公開時から多くのフィードバックがもらえたことは嬉しかったです(UniTask初公開時は、Unityのコンパイラを実験的コンパイラに差し替える必要があるとかいうエクストリーム仕様だったせいか、しばらくの間は誰も使ってくれなかったというか意義を分かってくれなかったので……）。</p>
<p>移行に関するシナリオも最大限配慮したつもりではあるので、是非使ってみてください……！</p>
</div>
<h1 data-pagefind-sort="date:2024-01-15" data-pagefind-meta="published:2024-01-15"><a href="https://neue.cc/2024/01/15_shareprojectinunity.html">.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法</a></h1>
<ul class="date"><li>2024-01-15</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnionのv6</a>が先日リリースされました。</p>
<p>メジャーバージョンアップとして大きな違いは、<a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a>を正式リリースし、これを通信層の標準ライブラリ化しました。インストール手順も複雑で、サポートも切れていたgRPC C-Coreとはさようならです。正式リリースにあたってプレビューに存在していたクラッシュ問題などが解消されています。</p>
<p>もう一つはクライアント生成においてコマンドラインツールが削除され、Source Generatorベースになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MagicOnionClientGeneration(typeof(MyApp.Shared.Services.IGreeterService))]
partial class MagicOnionGeneratedClientInitializer {}
</code></pre>
<p>これだけでコンパイル時にジェネレートされます。コマンドラインツールには、インストールしている.NETのバージョンによって動作したりしなかったりや、生成ファイルの管理をどうするかや、ビルドプロセスの複雑化など、問題が多くありましたがSource Generator化によって全て解決しました。</p>
<p>残念ながらまだMessagePack for C#がコマンドラインツールを必要としているため、完全なコマンドラインツール不要化には至っていませんが、そちらの改善も着手中のため、近いうちにはアプリケーション全体の完全なSource Generator化が果たせるのではないかと思います。それに合わせて<a href="https://github.com/Cysharp/MasterMemory/">Cysharp/MasterMemory</a>のSource Generator化も行いたいと思っています。</p>
<h2>.NETプロジェクトとUnityプロジェクト間でのコード共有</h2>
<p>MagicOnionに限らずですが、.NETとUnityとの間でソースコードをどのように共有すればいいのか問題があります。昔のやり方では、Unity側で実態を持っていて.NET側で参照を拾ってくるとか、.NET側のビルド時にUnity側にコピーをばらまく、シンボリックリンクで参照する、などといった方法を提案していたのですが、すべて正直イマイチでした。</p>
<p>というわけで令和最新版の方法を紹介します。先に結論をいうと、.NET側に普通の共有用クラスライブラリプロジェクトを作って、Unity側ではUPMのローカルパッケージ参照でソースコードを引っ張ってくるのが現状のベストだと考えています。ただしそのままやると幾つか面倒なことが発生するので、しっかりした手順をここに書いておきます。</p>
<p>まずは.NET側のプロジェクトとして、.NET Standard 2.0/2.1, LangVersion 9のクラスライブラリプロジェクトを作ります。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/0019a2b0-ec2c-4786-9d1d-0078e8dc0295" alt="image" /></p>
<p>そして<code>Directory.Build.props</code>を配置します。これは複数のcsprojにまたがって共有した設定が行えるやつなのですが、今回は単独のcsprojに適用する場合にも使います。そんな<code>Directory.Build.props</code>の中身はこれです。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- Unity ignores . prefix folder --&gt;
    &lt;ArtifactsPath&gt;$(MSBuildThisFileDirectory).artifacts&lt;/ArtifactsPath&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>最新手法と銘打った理由として.NET 8(以降に同梱されてるコンパイラ)は<a href="https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output">成果物の出力レイアウトを変更する</a>ことができるようになりました。なぜこれが必要かというと、通常、ビルドするとbin, objがcsprojのディレクトリに吐かれるわけですが、Unityでパッケージ参照するとそのbin, objまで取り込んでしまって大問題なんですね。ArtifactsPathを設定することでbin, objの出力場所を変更できます、そして<a href="https://docs.unity3d.com/Manual/SpecialFolders.html">Unityのアセットインポートにおける命名規則</a>のうち<code>.</code>か<code>~</code>で始まってるファイルまたはフォルダは無視されます。というわけで、bin, objの出力場所を<code>.artifacts</code>に変えることで、Unityから参照しても問題ない構成になりました。</p>
<p>もう少し作業が必要で、次にcsprojを開いて、以下の行を追加しておきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;ItemGroup&gt;
  &lt;None Remove=&quot;**\package.json&quot; /&gt;
  &lt;None Remove=&quot;**\*.asmdef&quot; /&gt;
  &lt;None Remove=&quot;**\*.meta&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>これは、Unityからパッケージ参照すると.metaが大量にばらまかれてウザいので、少なくともcsprojの見た目からは消しておきます。package.jsonとasmdefも同様に.NETプロジェクトとしては不要なので管理外へ。</p>
<p>というわけで最後に、package.jsonとasmdefをこのディレクトリに置いておきましょう。これがないとUnity側から正しく参照できないので。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/54c9564d-c6f2-44ec-b86c-bec19ecfb040" alt="image" /></p>
<pre data-pagefind-ignore="all"><code class="language-json">{
  &quot;name&quot;: &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;displayName&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;description&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;unity&quot;: &quot;2019.1&quot;
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-json">{
    &quot;name&quot;: &quot;ChatApp.Shared.Unity&quot;,
    &quot;references&quot;: [
        &quot;MessagePack&quot;,
        &quot;MagicOnion.Abstractions&quot;
    ],
    &quot;optionalUnityReferences&quot;: [],
    &quot;includePlatforms&quot;: [],
    &quot;excludePlatforms&quot;: [],
    &quot;allowUnsafeCode&quot;: false,
    &quot;overrideReferences&quot;: false,
    &quot;precompiledReferences&quot;: [],
    &quot;autoReferenced&quot;: true,
    &quot;defineConstraints&quot;: []
}
</code></pre>
<p>referencesとかはお好きな感じで。</p>
<p>これでほぼ準備は完了です！とはもうUnity側ではPackage Managerを開いてAdd package from diskで先ほどの共有プロジェクトのディレクトリを指定すればOK。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/a46813ab-72fb-44b3-ac8e-241451f9128f" alt="image" /></p>
<p>ただし、これで参照すると絶対パスが書かれているので、<code>manifest.json</code>を開いて相対パスに手動で書き換えましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;: &quot;file:../../ChatApp.Shared&quot;,
  }
}
</code></pre>
<p>これでいい具合に取り扱うことができました！</p>
<p><img src="https://github.com/Cysharp/R3/assets/46207/ed8c1d20-fd8a-4e6c-afe5-2350d3fa2860" alt="image" /></p>
<p>さらに一歩進んで、サーバー側のslnでUnity側のcsprojも一緒に管理したいんだよなあ、とかやりたい場合は<a href="https://github.com/Cysharp/SlnMerge/">Cysharp/SlnMerge</a>を使うとよいでしょう。</p>
<p><img src="https://github.com/Cysharp/SlnMerge/assets/46207/6b70bfda-5f80-42c0-9acc-ca3922f22c52" alt="image" /></p>
<p>単一slnで管理すると、Unity側での作業時に共有プロジェクトのコードを弄りやすくなりますし、サーバー/クライアントを超えたデバッグのステップ実行ができるようになるなど、かなり作りやすくなるので、あわせて是非設定しておくことをお薦めします。</p>
<h2>Unity用ライブラリのNuGet配布のための開発時環境設定</h2>
<p>先日<a href="https://github.com/Cysharp/R3/">R3</a>というUniRxの進化版みたいなのをリリースしましたが、これはコアライブラリはNuGetで配布するようにしました。ちょっと前まで私はNuGet配布に関して否定的で、Unity向けにはソースコードをちゃんと配らないと、みたいに思ってたんですが、今はNuGet配布にたいして超ポジティブです。というか、逆にNuGet配布じゃないとマズいような状況もあるので、今後のものは全てNuGet配布にするほか、既存のものも随時NuGet配布に切り替えると思います。まずはMessagePack for C#が近いうちにそうなります……！</p>
<p>それはいいんですが、Unity用に開発している際に.NETライブラリとして作られているコードを参照したい、んですよね、というか参照できないとUnity向け拡張(R3.Unity)が作れないし。</p>
<p>で、じゃあ上のやり方みたいローカルパッケージ参照でソースコードを持ってきてやろう、と思ったんですが、ダメでした。というのもR3の本体はC# 12で書かれていたのだ……！DLLとして配布するので別に言語バージョンは問題ない(コンパイルしてIL化すると.NETのバージョンは関係ありますが言語バージョンは関係なくなる)ので、Unityで使うことが前提ながら普通にC# 12で書いていたので、ソースコードとしての参照はできない。</p>
<p>ビルド時の成果物をUnity側にコピーするようにしても、まぁいいっちゃあいいんですが、作業中のちょっと書き換える度にコミットされるのでリポジトリが無駄に膨らむから嫌だなー、と。</p>
<p>で、そこで、やはりローカルパッケージ参照です。ただし今回は<code>package.json</code>のみで、asmdefは配りません。そして<code>bin/Debug/netstandard2.0</code>(2.1でもいい)にpackage.jsonを置いて、package.jsonとpackage.json.metaのみgitの管理下に置きます。</p>
<p>実際のリポジトリ: <a href="https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0">https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0</a></p>
<p>手元のフォルダの状況:<br />
<img src="https://github.com/Cysharp/MagicOnion/assets/46207/2c8f7cb4-08ea-459c-abcc-6a251a063cb2" alt="image" /></p>
<p>これを同じようにローカルパッケージ参照すると、開発用のdllだけをUnityに引っ張ってくることができました。別にパッケージの中にソースコードがなくてもいいわけですね……！</p>
<p>なお、普通のゲーム開発でもC# 12で書きたいんだよー、という人は、ソースコード参照じゃなくてこっちのやり方を使っても成立はします。全然、アリです。ただし、.NET側でビルドしないと反映されないとか、デバッグビルドとリリースビルドどっち参照させます？とかいうところを考えなきゃいけないので、まぁお好みで、というところでしょうか。</p>
<h2>まとめ</h2>
<p>というわけで、2024年になってようやく満足いく共有手法にたどり着けました。これはC#大統一理論元年……！</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
