<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2024-12</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2024-12-20" data-pagefind-meta="published:2024-12-20"><a href="https://neue.cc/2024/12/20_mastermemory_v3.html">MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース</a></h1>
<ul class="date"><li>2024-12-20</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a> v3出しました！ついにSource Generator化されました！</p>
<p><img src="https://github.com/user-attachments/assets/e804fa52-f6a5-4972-a510-0b3b17a31230" alt="image" /></p>
<p>MasterMemoryはC#のインメモリデータベースで、高速で、メモリ消費量が少なく、タイプセーフ。というライブラリです。SQLiteを素朴に使うよりも <em>4700</em>倍高速だぞ、と。</p>
<p><img src="https://user-images.githubusercontent.com/46207/61031896-61890800-a3fb-11e9-86b7-84c821d347a4.png" alt="image" /></p>
<p>もともとMasterMemoryはC#コードからC#コードを生成するという、Source Generatorのなかった時代にSource Generatorのようなことをやる先進的な設計思想を持ったシステムでした。今回移植してみて、あまりにもスムーズに移植できるし、旧来のコードも全く手を付けずにそのまま動いたので我ながら感心しました。やっと時代が追い付いたか……。</p>
<p>というわけで、以下のようなC#定義からデータベース構築のためのコードと、クエリ部分がSource Generatorによって自動生成されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MemoryTable(&quot;person&quot;), MessagePackObject(true)]
public record Person
{
    [PrimaryKey]
    public required int PersonId { get; init; }
    
    [SecondaryKey(0), NonUnique]
    [SecondaryKey(1, keyOrder: 1), NonUnique]
    public required int Age { get; init; }

    [SecondaryKey(2), NonUnique]
    [SecondaryKey(1, keyOrder: 0), NonUnique]
    public required Gender Gender { get; init; }

    public required string Name { get; init; }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/61035808-cb58e000-a402-11e9-9209-d51665d1cd56.png" alt="image" /></p>
<p>C#コードとして生成されるので、クエリが全て入力補完も効くし戻り値も型付けされていてタイプセーフなのはもちろん、パフォーマンスの良さにも寄与しています。</p>
<p>読み取り専用データベースとして使うので、クラス定義はイミュータブルのほうがいいわけですが、最近のC#は <code>record</code>, <code>init</code>, <code>required</code> といった機能が提供されているので、Readonly Databaseとしての使い勝手が更に上がりました。Unityでは<code>required</code>は使えませんが<code>record</code>と<code>init</code>は使えるので、Unityでも問題ありません。</p>
<p>なお、Unity版は今回からNuGetForUnityでの提供となります。また、MessagePack for C#もSource Generator対応のv3を要求します。</p>
<h2>Next</h2>
<p>MasterMemory、実は結構使われています。ゲームでも採用されているものを割と見かけるようになりました。なので、外部ツール由来のコード生成の面倒さにはだいぶ心を痛めていたので、ようやく解消できて本当に嬉しい！</p>
<p>v2からv3へのマイグレーションもそんなに大変ではない、はずです。あえて生成コードの品質や、コアの関数、メソッドシグネチャなどには一切手を加えていないので、今までコマンドラインツールを叩いていた部分を削除するだけで、そのまま動き出すぐらいの代物になっています。名前空間の設定だけ、アセンブリ属性で行ってください。</p>
<p>そのうえでrecord対応（今までしてなかった！）や#nullable enable対応（今までしてなかった！）を追加しているので、生成部分以外の使い勝手も上がっているはずです。</p>
<p>今後は<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>対応や、そもそものAPIの更なるモダン化（現状はnetstandard2.0なので古い）、全体的に改修したいところ(ImmutableBuilderなど生成コードの差し替え部分)、などなどやれること自体はめっちゃありますので、折を見て手を入れていけるといいかなあ、と思っています。</p>
</div>
<h1 data-pagefind-sort="date:2024-12-16" data-pagefind-meta="published:2024-12-16"><a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html">ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など</a></h1>
<ul class="date"><li>2024-12-16</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a> v5の比較的アップデートをしました！v5自体の詳細は以前に書いた<a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html">ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク</a>を参照ください。v5はかなり面白いコンセプトになっていて、そして支持されたと思っているのですが、幾つか使い勝手を犠牲にした点があったので、今回それらをケアしました。というわけで使い勝手がかなり上がった、と思います……！</p>
<h2>名前の自動変換を無効にする</h2>
<p>コマンドネームとオプションネームは、デフォルトでは自動的にkebab-caseに変換されます。これはコマンドラインツールの標準的な命名規則に従うものですが、内部アプリケーションで使うバッチファイルの作成に使ったりする場合などには、変換されるほうが煩わしく感じるかもしれません。そこで、アセンブリ単位でオフにする機能を今回追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using ConsoleAppFramework;

[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]

var app = ConsoleApp.Create();
app.Add&lt;MyProjectCommand&gt;();
app.Run(args);

public class MyProjectCommand
{
    public void Execute(string fooBarBaz)
    {
        Console.WriteLine(fooBarBaz);
    }
}
</code></pre>
<p><code>[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]</code>によって自動変換が無効になります。この例では <code>ExecuteCommand --fooBarBaz</code> がコマンドとなります。</p>
<p>実装面でいうと、Source Generatorにコンフィグを与えるのはAdditionalFilesにjsonや独自書式のファイル(例えばBannedApiAnalyzersのBannedSymbols.txt)を置くパターンが多いですが、ファイルを使うのは結構手間が多くて面倒なんですよね。boolの1つや2つを設定するぐらいなら、アセンブリ属性を使うのが一番楽だと思います。</p>
<p>実装手法としては<code>CompilationProvider</code>から<code>Assembly.GetAttributes</code>で引っ張ってこれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var generatorOptions = context.CompilationProvider.Select((compilation, token) =&gt;
{
    foreach (var attr in compilation.Assembly.GetAttributes())
    {
        if (attr.AttributeClass?.Name == &quot;ConsoleAppFrameworkGeneratorOptionsAttribute&quot;)
        {
            var args = attr.NamedArguments;
            var disableNamingConversion = args.FirstOrDefault(x =&gt; x.Key == &quot;DisableNamingConversion&quot;).Value.Value as bool? ?? false;
            return new ConsoleAppFrameworkGeneratorOptions(disableNamingConversion);
        }
    }

    return new ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion: false);
});
</code></pre>
<p>これを他のSyntaxProviderからのSourceとCombineしてやれば、生成時に属性の値を参照できるようになります。</p>
<h2>ConfigureServices/ConfigureLogging/ConfigureConfiguration</h2>
<p>ゼロディペンデンシーを掲げている都合上、特定のライブラリに依存したコードを生成することができないという制約がConsoleAppFramework v5にはありました。そのため、DIとの統合時に自分でServiceProviderをビルドしなければならないなの、利用には一手間必要でした。そこで、NuGetでのDLLの参照状況を解析し、<code>Microsoft.Extensions.DependencyInjection</code>が参照されていると、<code>ConfigureServices</code>メソッドが<code>ConsoleAppBuilder</code>から使えるという実装を追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create()
    .ConfigureServices(service =&gt;
    {
        service.AddTransient&lt;MyService&gt;();
    });

app.Add(&quot;&quot;, ([FromServices] MyService service, int x, int y) =&gt; Console.WriteLine(x + y));

app.Run(args);
</code></pre>
<p>これによりフレームワークそのものはゼロディペンデンシーでありながら、ライブラリ依存のコードも生成することができるという、新しい体験を提供します。これは<code>MetadataReferencesProvider</code>から引っ張ってきて生成処理に回すことで実現しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var hasDependencyInjection = context.MetadataReferencesProvider
    .Collect()
    .Select((xs, _) =&gt;
    {
        var hasDependencyInjection = false;

        foreach (var x in xs)
        {
            var name = x.Display;
            if (name == null) continue;

            if (!hasDependencyInjection &amp;&amp; name.EndsWith(&quot;Microsoft.Extensions.DependencyInjection.dll&quot;))
            {
                hasDependencyInjection = true;
                continue;
            }

            // etc...
        }

        return new DllReference(hasDependencyInjection, hasLogging, hasConfiguration, hasJsonConfiguration, hasHost);
    });

context.RegisterSourceOutput(hasDependencyInjection, EmitConsoleAppConfigure);
</code></pre>
<p>参照の解析は複数のものに対して行っていて、他にも<code>Microsoft.Extensions.Logging</code>が参照されていれば<code>ConfigureLogging</code>が使えるようになります。なので<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>と組み合わせれば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: ZLogger
var app = ConsoleApp.Create()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&quot;log.txt&quot;);
    });

app.Add&lt;MyCommand&gt;();
app.Run(args);

// inject logger to constructor
public class MyCommand(ILogger&lt;MyCommand&gt; logger)
{
    public void Echo(string msg)
    {
        logger.ZLogInformation($&quot;Message is {msg}&quot;);
    }
}
</code></pre>
<p>といったように、比較的すっきりと設定が統合できます。</p>
<p><code>appsettings.json</code>から設定ファイルを引っ張ってくるというのも最近では定番パターンですが、これも<code>Microsoft.Extensions.Configuration.Json</code>を参照していると<code>ConfigureDefaultConfiguration</code>が使えるようになり、これは<code>SetBasePath(System.IO.Directory.GetCurrentDirectory())</code>と<code>AddJsonFile(&quot;appsettings.json&quot;, optional: true)</code>を自動的に行います（追加でActionでconfigureすることも可能、また、ConfigureEmptyConfigurationもあります）。</p>
<p>なのでコンフィグを読み込んでクラスにバインドしてコマンドにDIで渡す、などといった処理もシンプルに書けるようになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: Microsoft.Extensions.Configuration.Json
var app = ConsoleApp.Create()
    .ConfigureDefaultConfiguration()
    .ConfigureServices((configuration, services) =&gt;
    {
        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions
        services.Configure&lt;PositionOptions&gt;(configuration.GetSection(&quot;Position&quot;));
    });

app.Add&lt;MyCommand&gt;();
app.Run(args);

// inject options
public class MyCommand(IOptions&lt;PositionOptions&gt; options)
{
    public void Echo(string msg)
    {
        ConsoleApp.Log($&quot;Binded Option: {options.Value.Title} {options.Value.Name}&quot;);
    }
}
</code></pre>
<p><code>Microsoft.Extensions.Hosting</code>でビルドしたい場合は、<code>ToConsoleAppBuilder</code>が、これも<code>Microsoft.Externsions.Hosting</code>を参照すると追加されるようになっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Package Import: Microsoft.Extensions.Hosting
var app = Host.CreateApplicationBuilder()
    .ToConsoleAppBuilder();
</code></pre>
<p>また、今回から設定されている<code>IServiceProvider</code>は<code>Run</code>または<code>RunAsync</code>終了後に自動的にDisposeするようになりました。</p>
<h2>RegisterCommands from Attribute</h2>
<p>コマンドの追加は<code>Add</code>または<code>Add&lt;T&gt;</code>が必要でしたが、クラスに属性を付与することで自動的に追加される機能をいれました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[RegisterCommands]
public class Foo
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}

[RegisterCommands(&quot;bar&quot;)]
public class Bar
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}
</code></pre>
<p>これらは自動で追加されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var app = ConsoleApp.Create();

// Commands:
//   baz
//   bar baz
app.Run(args);
</code></pre>
<p>これらとは別に追加で<code>Add</code>, <code>Add&lt;T&gt;</code>することも可能です。</p>
<p>なお、実装の当初予定では任意の属性を使えるようにする予定だったのですが、<code>IncrementalGenerator</code>のAPIの都合上難しくて、固定の<code>RegisterCommands</code>属性のみを対象としています。また、継承することもできません……。なので独自の処理用属性がある場合は、組み合わせてもらう必要があります。例えば以下のように。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[RegisterCommands, Batch(&quot;0 10 * * *&quot;)]
public class MyCommands
{
}
</code></pre>
<p>この辺は<a href="https://qiita.com/omt_teruki/items/dae315c7e86722fe05e6">ConsoleAppFrameworkとAWS CDKで爆速バッチ開発</a>を読んで、うーん、v5を使ってもらいたい！なんとかしたい！と思って色々考えたのですが、この辺が現状の限界でした……。名前変換オフりたいのもわかるー、とか今回の更新内容はこの記事での利用例を参考にさせていただきました、ありがとうございます！</p>
<h2>まとめ</h2>
<p>v5のリリース以降もフィルターを外部アセンブリに定義できるようになったり、Incremental Generatorの実装を見直して高速化するなど、Improvmentは続いています！非常に良いフレームワークに仕上がってきました！</p>
<p>ところで<a href="https://github.com/dotnet/command-line-api/">System.CommandLine</a>、現状うまくいってないから<a href="https://github.com/dotnet/command-line-api/issues/2338">Resettting System.CommandLine</a>だ！と言ったのが今年の3月。例によって想像通り進捗は無です。知ってた。そうなると思ってた。何も期待しないほうがいいし、普通にConsoleAppFramework使っていくで良いでしょう。</p>
</div>
<h1 data-pagefind-sort="date:2024-12-06" data-pagefind-meta="published:2024-12-06"><a href="https://neue.cc/2024/12/06_MessagePack_v3.html">SourceGenerator対応のMessagePack for C# v3リリースと今後について</a></h1>
<ul class="date"><li>2024-12-06</li></ul>
<div class="entry_body"><p>先月<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#プロジェクト</a>は <a href="https://dotnetfoundation.org/">.NET Foundation</a>に参加しました！より安定した視点で利用していただけるという一助になればいいと思っています。</p>
<p>そして、長く開発を続けていたメジャーバージョンアップ、v3がリリースされました。コア部分はv2とはほぼ変わらずですが、Source Generatorを全面的に導入しています。引き続きIL動的生成も存在するため、IL動的生成とSource Generatorのハイブリッドなシリアライザーとなります。v3にはSource GeneratorとAnalyzerがビルトインで同梱されていて、今までのコードはv3でコンパイルするだけで自動的にSource Generator化されます。v2 -&gt; v3アップデートでSource Generator対応するために追加でユーザーがコードを記述する必要はありません！</p>
<p>挙動を詳しく見ていきましょう。例えば、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject]
public class MyTestClass
{
    [Key(0)]
    public int MyProperty { get; set; }
}
</code></pre>
<p>というコードを書くと、自動的に以下のコードがSource Generatorによって内部的に生成されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">partial class GeneratedMessagePackResolver
{
    internal sealed class MyTestClassFormatter : IMessagePackFormatter&lt;MyTestClass&gt;
    {
        public void Serialize(ref MessagePackWriter writer, MyTestClass value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.MyProperty);
        }

        public MyTestClass Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var ____result = new MyTestClass();

            for (int i = 0; i &lt; length; i++)
            {
                switch (i)
                {
                    case 0:
                        ____result.MyProperty = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            reader.Depth--;
            return ____result;
        }
    }
}
</code></pre>
<p>また、このGeneratedMessagePackResolverはデフォルトのオプション(StandardResolverなど)に最初から登録されているため、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static readonly IFormatterResolver[] DefaultResolvers = [
    BuiltinResolver.Instance,
    AttributeFormatterResolver.Instance,
    SourceGeneratedFormatterResolver.Instance, // here
    ImmutableCollection.ImmutableCollectionResolver.Instance,
    CompositeResolver.Create(ExpandoObjectFormatter.Instance),
    DynamicGenericResolver.Instance, // only enable for RuntimeFeature.IsDynamicCodeSupported
    DynamicUnionResolver.Instance];
</code></pre>
<p>ユーザーコードのアセンブリに含まれているシリアライズ対象クラスは、Source Generatorによって生成されたコードが優先的に使われることになります。GeneratedMessagePackResolverは既定の名前空間や名前を変えたり、生成フォーマッターをmapベースに変更するなど、幾つかのカスタマイズポイントも用意されています。より詳しくは新しいドキュメントを見てください。また、v2 -&gt; v3の変更箇所の詳細を知りたい人は<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/develop/doc/migrating_v2-v3.md">Migration Guide v2 -&gt; v3</a>をチェックしてください。</p>
<p>Unityにおいては導入方法が大きく変わりました。コアライブラリは .NET 版と共通になりNuGetからのインストールが必要となります。そのうえでUPMでUnity用の追加コードをダウンロードする必要があります。詳しくは<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/#unity-support">MessagePack-CSharp#unity-support</a>のセクションを確認してください。</p>
<p>.unitypackageの提供は廃止されています。また、IL2CPP対応のために要求していたmpcはなくなりました。完全にSource Generatorに移行されます。そのため、Unityのサポートバージョンは <code>2022.3.12f1</code> からとなります。Source Generatorに関してはNuGetForUnityでのコアライブラリインストール時に自動的に有効化されるため、追加の作業は必要ありません。</p>
<h2>History and Next</h2>
<p>MessagePack for C#のオリジナル(v1)は私(Yoshifumi Kawai/@neuecc)によって、2017年にリリースしました。当時開発していたゲームのパフォーマンス問題を解決するために、2016年時点で存在していた(バイナリ)シリアライザーでは需要を満たせなかったため、パフォーマンスを最重要視したバイナリシリアライザーとして作成しました。合わせて、同じくネットワークシステムとして作成したgRPCベースのRPCフレームワーク<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>もリリースしています。</p>
<p>v1リリース当時は<code>byte[]</code>のみを対象としていましたが、<code>Span&lt;T&gt;</code>や<code>IBufferWriter&lt;T&gt;</code>など、.NETには次々と新しいI/O系のAPIが追加されていったため、v2ではそれらに焦点を当てた新しいデザインが導入されました。この実装はMicrosoftのEngineerである<a href="https://github.com/AArnott">Andrew Arnott / @AArnott</a>氏によって主導され、リリースしています。</p>
<p>以降、共同のメンテナンス体制として、そして私の個人リポジトリ(neuecc/MessagePack-CSharp)からオーガナイゼーション(MessagePack-CSharp/MessagePack-CSharp)して今に至ります。Visual Studio内部での利用や<a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol">SignalRのバイナリープロトコル</a>、Blazor Serverのプロトコルなど大きなMicrosoftのプロダクトでも使用され、GitHubでのスター数は.NETのバイナリーシリアライザーとしては最も大きなスターを集めています。<a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-migration-guide/">.NET 9で廃止されたBinaryFormatter</a>の移行先の一つとしても推奨されています。</p>
<p>v3ではSource Generatorに対応することで、より高いパフォーマンスと柔軟性、AOT対応への第一段階に踏み出すことができました。</p>
<p>MessagePack for C#プロジェクトは大きな成功を収めたと考えていますが、しかし現在、AArnott氏は個人の新しいMessagePackプロジェクトの開発を開始しています。私もその間、<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>という異なるフォーマットのシリアライザーをリリースしています。そのため、MessagePack for C#の今後と、その特性について、ある程度説明する必要があると思います。</p>
<p>引き続きメンテナンス体制は2人だと考えていますが、アクティブな活動に関しては、再び私が担うことになるかもしれません。私はMessagePackとMemoryPackとでは異なる性質を持ったフォーマットであるため、どちらも重要であるという認識で動いています。オリジナルの実装であるMessagePack for C#も気に入ってますし、現在においても決して引けを取ることのないものだと思っています。</p>
<p>AArnott氏の別のMessagePackシリアライザーとは根本的な哲学が若干異なります。その点で、私はそれはより良く改善されたシリアライザーではなく、別の個性のシリアライザーだと認識しています。そこで、違いについて説明させてください。</p>
<h2>Binary spec, default settings and performance</h2>
<p>シリアライザーのパフォーマンスに重要なのは、「仕様と実装」の両方です。例えばテキストフォーマットのJSONよりもバイナリフォーマットのほうが一般的には速いでしょう。しかし、よくできたJSONシリアライザーは、中途半端な実装のバイナリシリアライザーよりも高速です（私はそれを<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>というシリアライザーを作成することで実証したことがあります）。なので、仕様も大事だし、実装も大事です。どちらも兼ねることができれば、それがベストなパフォーマンスのシリアライザーとなります。</p>
<p><a href="https://msgpack.org/">MessagePackのバイナリ仕様</a>は &quot;It's like JSON. but fast and small.&quot; を標語にしている通り、JSONのバイナリ化としてあらわされています。ところが、MessagePack for C#のデフォルトは必ずしもJSON likeを狙っているわけではありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject]
public class MsgPackSchema
{
    [Key(0)]
    public bool Compact { get; set; }
    [Key(1)]
    public int Schema { get; set; }
}
</code></pre>
<p>このクラスをシリアライズした場合は、JSONで表現すると<code>[true, 0]</code>のようになります。これはオブジェクトをarrayベースでシリアライズしているからで、mapベースでシリアライズすると<code>{&quot;Compact&quot;:true,&quot;Schema&quot;:0}</code>のような表現になります。</p>
<p>arrayベースの利点は見た通りに、バイナリ容量として、よりコンパクトになります。容量がコンパクトなことは処理量が少なくなるためシリアライズの速度にも良い影響を与えます。また、デシリアライズにおいては、文字列を比較してデシリアライズするプロパティを探索する必要がなくなるため、より高速なデシリアライズ速度が期待できます。</p>
<p>なお、arrayベースのシリアライズはMessagePackの仕様策定者である Sadayuki Furuhashi 氏によるリファレンス実装であるmsgpack-javaなどでも採用されているため、決して異端のやり方というわけではありません。</p>
<p>MessagePack-CSharpではJSONライクなmapベースでシリアライズしたい場合は<code>[MessagePackObject(true)]</code>と記述することができます。また、Source Generatorの場合はResolver単位でオーバーライドして強制的にmapベースにすることも可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[MessagePackObject(keyAsPropertyName: true)]
public class MsgPackSchema
{
    public bool Compact { get; set; }
    public int Schema { get; set; }
}
</code></pre>
<p>mapの利点は、柔軟なスキーマエボリューションの実現と、他言語との疎通する際にコミュニケーションが取りやすいこと、バイナリそのものの自己記述性が高いことです。デメリットは容量とパフォーマンスへの悪影響、特にオブジェクトの配列においては一要素毎にプロパティ名が含まれることになってしまい、かなりの無駄となります。</p>
<p>デフォルトをarrayにしているのは、コンパクトさとパフォーマンスの追求のためです。私はMessagePackをJSON likeの前に、高いパフォーマンスを実現可能なバイナリ仕様として考えました。もちろん、mapも重要なので、その上で比較的簡単にmapモードを実現するために属性に<code>(true)</code>を追加するだけで可能にしました。</p>
<p>arrayモードの場合はKey属性を全てのプロパティに付与する必要があります。これは、例えばProtocol Buffersなどでも数値タグを必要とするように、プロパティ名そのものをキーとするわけではなければ、必須だと考えています。もちろん、連番で自動採番させることも可能ですが、バイナリフォーマットのキーを暗黙的に処理するのはリスクが大きすぎる(順番を弄ったりするだけでバイナリ互換性が壊れることになる)と判断しています。つまり、明示的がデフォルト、ということです。大きなプロジェクト開発ではシニアメンバーからジュニアメンバーまでコードを触ることになるでしょう、全てを理解している人だけがコードを触るわけではありません。なので、暗黙的な挙動は避けるべきで、明示的にすべきだという強い意志で、この設計を選んでいます。</p>
<p>ただしKeyを全てのプロパティに付与する作業はとても苦痛です(私はMessagePack-CSharp開発以前には、DataContractやprotobuf-netで辛い思いをしました)。そこで、Analyzer + Code Fixによって、自動的に付与する機能を用意しました。これにより明示的であることの苦痛は和らげられ、良いとこどりができているのだと考えています。</p>
<p>別のMessagePackシリアライザーのデフォルトはmapのようです。これは<a href="https://github.com/eiriktsarpalis/PolyType">PolyType</a>というSource Generatorベースのライブラリ作成のための抽象化ライブラリがベースとしているためでもあり、また、そちらのほうを好んでいるという明示的な判断でもあるようです。</p>
<p>「デフォルト」はライブラリで一つしか選べません。どちらのモードで処理することができたとしても、「デフォルト」はただ一つです。改めて言うと、私はバイナリフォーマットとしての「コンパクトとパフォーマンス」を好み、優先しています。</p>
<p>皆さんはPolyTypeについて初めて知ったかもしれません。私はPolyTypeはあまり好意的には考えていません。ちょっとしたものを作るには非常に便利だとは思いますが、ベストなパフォーマンスを狙ったり、ベストなアイディアを表現するには、抽象層であることの制限が大きすぎると考えています。なので、MessagePack for C#で採用することはありませんし、他の何かを作る際にも採用することはないでしょう。</p>
<h2>Unity(multiplatform) Support</h2>
<p>MessagePack for C#ではv1の時代からゲームエンジンUnityの1st classのサポートを実行してきました。これは私が<a href="https://en.wikipedia.org/wiki/Cygames">Cygames</a>という日本のゲーム会社の関連会社(<a href="https://cysharp.com/">Cysharp</a>)のCEOを務めていて、ビデオゲームインダストリーと関係性が深いという都合もあります。自分たちで実際にUnityで動くものを作り、使ってきました。もちろん、サーバーサイドやデスクトップアプリケーションでも使っています。</p>
<p>UnityにはIL2CPPという独自のAOTシステムがあり、特にiOSなどモバイルプラットフォームでのリリースには必須なのですが、それもSource Generatorが存在しなかった時代から、mpcというRoslynを使ったコードジェネレートツールを作り、提供してきました。数百のモバイルゲームでMessagePackが使われているのは、これら私の熱心なサポートのお陰といっても過言ではないでしょう。v3ではついにSource Generatorベースになったことにより、ワークフローが大きく簡易化されることとなります！</p>
<p>一般的に、.NETコミュニティにおいてはUnityサポートはかなり軽視されていました。また、外から見ているとMicrosoftやMicrosoftの従業員もそのようで、自社のプラットフォーム以外への関心は薄そうです。こうした態度は、あまり好ましいとは思っていませんし、せっかくの .NET の可能性を狭めていることにもなっています。Xamarinがうまく成長軌道に乗らなかったのも、そのようなMicrosoft自体の冷たい視線のせいだとも思っています。</p>
<p>私は、私の作るライブラリはなるべくUnityにもしっかり対応できるように気を付けて作っています（最新は新しいReactive Extensionsライブラリーである<a href="https://github.com/Cysharp/R3">Cysharp/R3</a>）。別のMessagePackシリアライザーに関しては、あまりしっかりした対応はされなさそうですが……。</p>
<h2>Beyond v3</h2>
<p>v3のNative AOT Supportは完全ではありません。Source Generatorにするだけでは完全なNative AOT対応とはならないのは難しいところです。これはUnityのAOTであるIL2CPPでは完璧に動作しているだけに、正直不可解なことでもあり、また、Microsoftのよくない癖が出ているな、とも思っています。つまり、完璧な対応をするために、複雑なものを提供している。それが現在のNative AOTです。複雑怪奇な属性やフローは、理解できるところもありますが、もう少し簡略化すべきだったと思います。まぁ、もう修正されることもないのでしょうが……。</p>
<p>パフォーマンス面でもv1からv2で退化してしまった点もあるので、最新の知見を元に、実装面での改善を施す必要があります。特にReadOnlySequenceの利用幅が大きいことは、かなりの制約を生み出していて、不満があります。</p>
<p>.NET 9でPipeReader/PipeWriterが標準化されたことによる、より良い非同期APIや、パフォーマンスを両立したストリーミング対応というのも、大きなトピックとなるかもしれません。</p>
<p>MessagePack for C#は広く使われているが故に、破壊的変更はしづらいし、互換性の維持は最重要トピックスです。しかし、世の中が変わっていく以上、進化しないことを選んだら、それは滅びる道でしかありません。やれることはまだまだあると思っていますので、.NETにおける最先端の、最高のバイナリシリアライザーであり続けたいと思っています（<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>もね……！)</p>
<p>まずは、v3のSource Generatorをぜひ試してみてください。皆の力でより良いものを作っていけるというのも、OSSの良さだと思っています。</p>
</div>
<h1 data-pagefind-sort="date:2024-12-03" data-pagefind-meta="published:2024-12-03"><a href="https://neue.cc/2024/12/03_SharpFuzz.html">Fuzzing in .NET: Introducing SharpFuzz</a></h1>
<ul class="date"><li>2024-12-03</li></ul>
<div class="entry_body"><p>この記事は<a href="https://qiita.com/advent-calendar/2024/csharplang">C# Advent Calendar 2024</a>に参加しています。また、先月開催された<a href="https://dotnetnew.connpass.com/event/335955/">dotnet new</a>というイベントでの発表のフォローアップ、のつもりだったのですがコロナ感染につき登壇断念……。というわけで、セッション資料はないので普通にブログ記事とします！</p>
<h2>dotnet/runtime と Fuzzing</h2>
<p>今年に入ってからdotnet/runtimeにFuzzingテストが追加されています。<a href="https://github.com/dotnet/runtime/tree/main/src/libraries/Fuzzing">dotnet/runtime/Fuzzing</a>。というわけで、実はfuzzingは非常に最近のトピックスなのです……！</p>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0">ファジング</a>とはなんなのか、ザックリとはランダムな入力値を大量に投げつけることによって不具合や脆弱性を発見するためのテストツールです。エッジケースのテスト、やはりどうしても抜けちゃいがちだし、ましてや脆弱性になりうる絶妙な不正データを人為的に作るのも難しいので、ここはツール頼みで行きましょう。</p>
<p>Goでは1.18(2022年)から標準でgo fuzzコマンドとして追加されたらしいので、
<a href="https://future-architect.github.io/articles/20220214a/">Go1.18から追加されたFuzzingとは</a>のような解説記事を読むのもイメージを掴みやすいです。</p>
<p>さて、dotnet/runtimeのFuzzingでは現状</p>
<ul>
<li>AssemblyNameInfoFuzzer</li>
<li>Base64Fuzzer</li>
<li>Base64UrlFuzzer</li>
<li>HttpHeadersFuzzer</li>
<li>JsonDocumentFuzzer</li>
<li>NrbfDecoderFuzzer</li>
<li>SearchValuesByteCharFuzzer</li>
<li>SearchValuesStringFuzzer</li>
<li>TextEncodingFuzzer</li>
<li>TypeNameFuzzer</li>
<li>UTF8Fuzzer</li>
</ul>
<p>というのものが用意されてます。わかるようなわからないような。だいたいデータのパース系によく使われるものなので、その通りのところに用意されています。一番わかりやすいJsonDocumentFuzzerを見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal sealed class JsonDocumentFuzzer : IFuzzer
{
    public string[] TargetAssemblies { get; } = [&quot;System.Text.Json&quot;];
    public string[] TargetCoreLibPrefixes =&gt; [];
    public string Dictionary =&gt; &quot;json.dict&quot;;

    // fuzzerからのランダムなバイト列が入力
    public void FuzzTarget(ReadOnlySpan&lt;byte&gt; bytes)
    {
        if (bytes.IsEmpty)
        {
            return;
        }

        // The first byte is used to select various options.
        // The rest of the input is used as the UTF-8 JSON payload.
        byte optionsByte = bytes[0];
        bytes = bytes.Slice(1);

        var options = new JsonDocumentOptions
        {
            AllowTrailingCommas = (optionsByte &amp; 1) != 0,
            CommentHandling = (optionsByte &amp; 2) != 0 ? JsonCommentHandling.Skip : JsonCommentHandling.Disallow,
        };

        using var poisonAfter = PooledBoundedMemory&lt;byte&gt;.Rent(bytes, PoisonPagePlacement.After);

        try
        {
            // それをParseに投げて、もし不正な例外が来たらなんかバグっていたということで
            JsonDocument.Parse(poisonAfter.Memory, options);
        }
        catch (JsonException) { }
    }
}
</code></pre>
<p>ようは想定外のデータ入力で<code>JsonDocument.Parse</code>が失敗しないことを祈る、といったものですね。正常に認識しているinvalidな値なら<code>JsonException</code>をthrowするはずですが、<code>ArgumentException</code>とか<code>StackOverflowException</code>とかが出てきちゃった場合は認識できていない不正パターンなので、ちゃんとしたハンドリングが必要になってきます。</p>
<p>では、これを参考にやっていきましょう、とはなりません。えー。まず、dotnet/runtimeのFuzzingではSharpFuzz, libFuzzer, そしてOneFuzzが使用されていると書いてあるのですが、OneFuzzはMicrosoft内部ツールなので外部では使用できません。正確には<a href="https://www.publickey1.jp/blog/20/project_onefuzzwindowsmicorosoft_edge.html">2020年にオープンソース公開</a>したものの、<a href="https://github.com/microsoft/onefuzz">2023年にはクローズドに戻している</a>状態です。まぁ事情は色々ある。しょーがない。</p>
<p>というわけで、これはMicrosoft内部で動かすためのOneFuzzや、dotnet/runtimeで動かすために調整してある<code>IFuzzer</code>といったフレームワーク部分が含まれているので、小規模な自分たちのコードをfuzzingするにあたっては、不要ですし、ぶっちゃけあまり参考にはなりません！解散！</p>
<h2>Introducing SharpFuzz</h2>
<p>そんなわけでdotnet/runtimeのFuzzingでも使われている<a href="https://github.com/Metalnem/sharpfuzz">Metalnem/sharpfuzz: AFL-based fuzz testing for .NET</a>を直接使っていきます。sharpfuzzは<a href="https://lcamtuf.coredump.cx/afl/">afl-fuzz</a>と連動して動くように作られている .NETライブラリです。3rd Partyライブラリですが作者はMicrosoftの人です（dotnet/runtimeで採用されている理由でもあるでしょう）。ReadMeのTrophiesでは色々なもののバグを見つけてやったぜ、と書いてあります。AngleSharpとかGoogle.ProtobufとかGraphQL-ParserとかMarkdigとかMessagePack for C#とImageSharpとか。まぁ、やはり用途としてはパーサーのバグを見つけるのには適切、という感じです。</p>
<p>AFL(American Fuzzy Lop)ってなに？ということなのですが、そもそもファジングの「ランダムな入力値を大量に投げつける」行為は、完全なランダムデータを投げつけていくわけではありません。完全ランダムだとあまりにも時間がかかりすぎるため、脆弱性発見において実用的とは言えない。そこでAFLはシード値からのミューテーションと、カバレッジをトレースしながら効率よくデータを生成していきます。Wikipediaから引用すると</p>
<blockquote>
<p>テスト対象のプログラム（テスト項目）のソースコードをインストルメント化することにより、afl-fuzzは、ソフトウェアのどのブロックが特定のテスト刺激で実行されたかを後で確認できる。そのため、AFLはグレーボックステストに使用することができる。遺伝的手法による検査データの生成に関連して、ファザーはテストデータをより適切に生成できるため、このメソッドを使用しない他のファザーよりも、処理中に以前は使用されていなかったコードブロックが実行される。その結果、コードカバレッジは比較的短い時間で比較的高い結果が得られる。この方法は、生成されたデータ内の構造を独立して（つまり、事前の情報なしで）生成することができる。このプロパティは、テストカバレッジの高いテストコーパス（テストケースのコレクション）を生成するためにも使用される。</p>
</blockquote>
<p>というわけでdotnet testのようにテストコードを渡したら全自動でやってくれる、というほど甘くはなくて、多少の下準備が必要になってきます。SharpFuzzは一連の処理をある程度やってくれるようにはなっていますが、そもそもに実行までに二段階の処理が必要になっています。</p>
<ul>
<li>sharpfazzコマンド(dotnet tool)でdllにトレースポイントを注入する</li>
<li>その注入されたdll(とexe)をネイティブのfuzzing実行プロセス(afl-fuzzなど)に渡す</li>
</ul>
<p>dllにトレースポイントを注入はお馴染みの<a href="https://github.com/jbevain/cecil">Cecil</a>でビルド済みのDLLのILを弄ってトレースポイントを仕込みます。</p>
<p><img src="https://github.com/user-attachments/assets/c3b43b60-8526-44cd-8482-6f1185206b65" alt="image" /></p>
<p>これは注入済みのdllですが、Trace.SharedMemとかTrace.PrevLocationとか、分岐点に対して明らかに注入している様が見えます。そうしたトレースポイントとの通信や実行データ生成などは外部プロセスが行うので、SharpFuzzというライブラリは、それ自体は実行ツールではなくて、それらとの橋渡しをするためのシステムということです。</p>
<p>ではやっていきましょう！色々なシステムが絡んでくる分、ちょっとややこしく面倒くさいのと、ReadMeの例をそのままやると罠が多いので、少しアレンジしていきます。</p>
<p>まずはRequirementsですが、実行機であるAFLがWindowsでは動きません(Linux, macOSでは動く)。なのでWSL上で動かしましょうという話になってくるのですが、それはあんまりにもやりづらいので、<a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>というLLVMが開発しているAFL互換のFuzzingツールを使っていくことにします。これはWindowsでビルドできます。</p>
<p>自分でビルドする必要はなく、SharpFuzzの作者が連携して使うことを意識して用意してくれている<a href="https://github.com/Metalnem/libfuzzer-dotnet/releases">libfuzzer-dotnetのReleasesページ</a>から、バイナリを直接落としてきましょう。<code>libfuzzer-dotnet-windows.exe</code>です。</p>
<p>次に、IL書き換えを行うツール<code>SharpFuzz.CommandLine</code>を .NET toolで入れていきましょう。これはglobalでいいかな、と思います。</p>
<pre data-pagefind-ignore="all"><code>dotnet tool install --global SharpFuzz.CommandLine
</code></pre>
<p>次に、今回は<a href="https://github.com/kevin-montrose/Jil">Jil</a>という、今はもうあまり使われることもないJsonシリアライザーをターゲットとしてやっていこうということなので、JilとSharpFuzzをインストールします。</p>
<pre data-pagefind-ignore="all"><code>dotnet add package Jil --version 2.15.4
dotnet add package SharpFuzz
</code></pre>
<p>ここで注意が必要なのは、Jilの最新バージョンはSharpFuzzにより発見されたバグが修正されているので、最新版を入れるとチュートリアルにはなりません！というわけでここは必ずバージョン下げて入れましょう。</p>
<p>新規のConsoleApplicationで、コードは以下のようにします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Jil;
using SharpFuzz;

// 実行機としてlibFuzzerを使う(引数はReadOnlySpan&lt;byte&gt;)
Fuzzer.LibFuzzer.Run(span =&gt;
{
    try
    {
        using var stream = new MemoryStream(span.ToArray());
        using var reader = new StreamReader(stream);
        JSON.DeserializeDynamic(reader); // このメソッドが正しく動作してくれるかをテスト
    }
    catch (Jil.DeserializationException)
    {
        // Jil.DeserializationExceptionは既知の例外（正しくハンドリングできてる）なので握り潰し
        // それ以外の例外が発生したらルート側にthrowされて問題が検知される
    }
});
</code></pre>
<p>今度はベースになるテストデータを用意します。名前とかはなんでもいいんですが、<code>Testcases</code>フォルダに<code>Test.json</code>を追加しました。</p>
<p><img src="https://github.com/user-attachments/assets/606cede7-9a20-4efe-8e58-642330ced8d5" alt="image" /></p>
<pre data-pagefind-ignore="all"><code class="language-json">{&quot;menu&quot;:{&quot;id&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;pop&quot;:{&quot;a&quot;:[{&quot;click&quot;:&quot;Open()&quot;},{&quot;click&quot;:&quot;Close()&quot;}]}}}
</code></pre>
<p>このデータを元にしてfuzzerは値を変形させていくことになります。</p>
<p>では実行しましょう！実行するためには、ビルドしてILポストプロセスしてlibFuzzer経由で動かす……。という一連の定型の流れが必要になるため、作者の用意してくれているPowerShellスクリプト<a href="https://raw.githubusercontent.com/Metalnem/sharpfuzz/master/scripts/fuzz-libfuzzer.ps1">fuzz-libfuzzer.ps1</a>をダウンロードしてきて使いましょう。</p>
<p>とりあえず<code>fuzz-libfuzzer.ps1</code>と<code>libfuzzer-dotnet-windows.exe</code>をcsprojと同じディレクトリに配置して、以下のコマンドを実行します。<code>ConsoleApp24.csproj</code>の部分だけ適当に変えてください。</p>
<pre data-pagefind-ignore="all"><code class="language-cmd">PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &quot;./libfuzzer-dotnet-windows.exe&quot; -project &quot;ConsoleApp24.csproj&quot; -corpus &quot;Testcases&quot;
</code></pre>
<p>動かすと、見つかった場合はいい感じに止まってくれます。</p>
<p><img src="https://github.com/user-attachments/assets/1ce45aa1-2d50-46f2-8f86-947db39406d6" alt="image" /></p>
<p>なお、見つからなかった場合は無限に探し続けるので、なんとなくもう見つかりそうにないなあ、と思ったら途中で自分でとめる(Ctrl+C)必要があります。</p>
<p>Testcasesには途中の残骸と、クラッシュした場合は<code>crash-id</code>でクラッシュ時のデータが拾えます。</p>
<p><img src="https://github.com/user-attachments/assets/d90f5bb1-4509-41b6-a139-16789a5a501c" alt="image" /></p>
<p>今回見つかったクラッシュデータは</p>
<pre data-pagefind-ignore="all"><code class="language-json">{&quot;menu&quot;:{&quot;id&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;popid&quot;:1,&quot;val&quot;:&quot;X&quot;,&quot;pop&quot;:{&quot;a&quot;:[{&quot;click&quot;:&quot;Open()&quot;},{&quot;c
</code></pre>
<p>でした。実際このデータを使って再現できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Jil;

//  クラッシュファイルのプロパティでデータはCopy to Output Directoryしてしまう
//  &lt;None Update=&quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&quot;&gt;
//    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
//  &lt;/None&gt;
var crash = File.ReadAllBytes(&quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&quot;);
var span = crash.AsSpan();

// Fuzzing時と同じコード
using var stream = new MemoryStream(span.ToArray());
using var reader = new StreamReader(stream);
JSON.DeserializeDynamic(reader);
</code></pre>
<p>以上！完璧！便利！一度手順を理解してしまえば、そこまで難しいことではないので、是非ハンズオンでやってみることをお薦めします。なお、ps1のスクリプトは実行対象自身へのインジェクトは除外されるようになっているので、小規模な自分のコードでfuzzingを試してみたいと思った場合は、対象コードはexeとは異なるプロジェクトに分離しておく必要があります。</p>
<p>ところで、AFLにはdictionaryという仕組みがあり、既知のキーワード集がある場合は生成速度を大幅に上昇させることが可能です。例えば<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/json.dict">json.dict</a>を使う場合は</p>
<pre data-pagefind-ignore="all"><code class="language-cmd">PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &quot;./libfuzzer-dotnet-windows.exe&quot; -project &quot;ConsoleApp24.csproj&quot; -corpus &quot;Testcases&quot; -dict ./json.dict
</code></pre>
<p>のように指定します。JSONとかYAMLとかXMLとかZipとか、一般的な形式は<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries">AFLplusplus/dictionaries</a>などに沢山転がっています。独自に作ることも可能で、例えばdotnet/runtimeのFuzzingではBinaryFormatterのテストが置いてありますが、これは<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/binaryformatter-migration-guide/read-nrbf-payloads">NRBF(.NET Remoting Binary Format)</a>の辞書、<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Fuzzing/DotnetFuzzing/Dictionaries/nrbfdecoder.dict">nrbfdecoder.dict</a>を用意しているようでした。</p>
<p>もちろん、なしでも動かすことはできますが、用意できそうなら用意しておくとよいでしょう。</p>
<h2>まとめ</h2>
<p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>でも実際バグ見つかってたりするので、この手のライブラリを作る人だったら覚えておいて損はないです。シリアライザーに限らずパーサーに関わるものだったらネットワークプロトコルでも、なんでも適用可能です。ただし現状、入力が<code>byte[]</code>に制限されているので、応用性自体はあるようで、なかったりはします。これがintとか受け入れてくれると、様々なメソッドに対してカジュアルに使えて、より便利な気もしますが……(実際go fuzzは<code>byte[]</code>だけじゃなくて基本的なプリミティブの生成に対応している)</p>
<p><code>byte[]</code>列から適当に切り出してintとして使う、といったような処理だと、ミューテーションやカバレッジの関係上、適切な値を取得しにくいので、あまりうまくやれません。libFuzzerでは<a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md">Structure-Aware Fuzzing with libFuzzer</a>といったような手法が考案されていて、protocol buffersの構造を与えるとか、gRPCの構造を与えるとかでうまく活用している事例はあるようです。この辺はSharpFuzzの対応次第となります(いつかやりたい、とは書いてありましたが、現実的にいつ来るかというと、あまり期待しないほうが良いでしょう)</p>
<p>Rustにも<a href="https://github.com/rust-fuzz/cargo-fuzz">cargo fuzz</a>といったcrateがあり、それなりに使われているようです。</p>
<p>Fuzzingは適用範囲が限定的であることと下準備の手間などがあり、一般的なアプリケーション開発者においては、あまりメジャーなテスト手法ではないというのが現状だと思いますが、使えるところはないようで意外とあるとも思うので、ぜひぜひ試してみてください。</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
