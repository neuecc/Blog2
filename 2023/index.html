<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2023</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2023-12-30" data-pagefind-meta="published:2023-12-30"><a href="https://neue.cc/2023/12/30_year.html">2023年を振り返る</a></h1>
<ul class="date"><li>2023-12-30</li></ul>
<div class="entry_body"><p>今年も相変わらずC#関連で色々やっていきました……！というわけなんですが、一番大きかったのはcsbindgenでしょうか。</p>
<ul>
<li><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></li>
</ul>
<p>私のスタンスとして、今までとにかくPure C#でなんとかする！という姿勢ではあったんですが、より柔軟にネイティブコードを取り入れていくという変化になりました。そのほうが、より「C#の可能性を切り開いていく」という<a href="https://cysharp.co.jp/">Cysharp</a>のミッションにも近づけているわけで、かなり良い変化をもたらせたと思っています。発展して</p>
<ul>
<li><a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html">Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</a></li>
</ul>
<p>といったような有意義なライブラリを生み出せるキッカケにもなれましたし。とはいえ改めてネイティブはネイティブで大変なのは変わらないので、C#最高、みたいな思いも強くなりましたが……！</p>
<p>私個人のスキルとしても、Rustを取り入れられるようになったのはかなり良かったことですね。Rustから学ぶことも多く、より良いC#のコードを書くことにも役立ちます。</p>
<p>OSSの後半戦ではZLogger v2は傑作だと思っています……！</p>
<ul>
<li><a href="https://neue.cc/2023/12/19_zlogger2.html">ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介</a></li>
</ul>
<p>思っているので、ちょっと普及活動頑張りたいと思っています、NLog、Serilogと同列に並んで検討対象になってくれると嬉しいのですけれどねー。まぁ、まずはReadMeから、ですが。なんとまだ工事中！よくない！</p>
<p>その他小粒の新規OSS郡もありました。</p>
<ul>
<li><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></li>
<li><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></li>
<li><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></li>
<li><a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html">UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</a></li>
</ul>
<p>こう見ると、今年もなんだかんだで色々やってはいましたね！</p>
<p>そして久々にCEDECでの発表もしてきました。</p>
<ul>
<li><a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition</a></li>
</ul>
<p>近年の総決算のつもりであったのですが、ちょっとシリアライザ的なもの(Stream)に偏りすぎではあった、かな？また5年後ぐらいには別の切り口で話せるといいかなーとは思ってます。</p>
<p>さて、ここ数年は「自称革命的なサービス（？）を来年こそはリリースする」と言い続けていたのですが、それは頓挫しました！革命的なサービスは出ない！しょーがない。csbindgenとかはそれの副産物なので、成果は無、というわけではないんですが、頓挫はやはり悲しくはあります。。。</p>
<p>そんなわけで、来年は別のネタを探しつつも、一つだけ、来年初頭というか1月の頭というか、あともう一週間ないぐらいに、大型のOSSを(プレビュー)リリースしたいと思って、ここ一ヶ月ぐらいは延々と集中してコード書いてます。かなり本気でやっているので、それは是非楽しみにしてください……！</p>
</div>
<h1 data-pagefind-sort="date:2023-12-19" data-pagefind-meta="published:2023-12-19"><a href="https://neue.cc/2023/12/19_zlogger2.html">ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介</a></h1>
<ul class="date"><li>2023-12-19</li></ul>
<div class="entry_body"><p>C#用の新しい超高速＆低アロケーションの.NET用ロギングライブラリ、ZLogger v2を公開しました。v1からは何もかもを完全に作り替えた、最新のC#に合わせた新設計になっています。対応プラットフォームは.NET 8が最良ですが .NET Standard 2.0 以上、また Unity 2022.2 以上にも対応しています。.NET / Unityどちらもテキストメッセージと構造化ログの両方に対応しています。</p>
<ul>
<li><a href="https://github.com/Cysharp/ZLogger">Cysharp/ZLogger</a></li>
</ul>
<p>新設計のキーポイントはString Interpolationの全面採用によるクリーンなシンタックスとパフォーマンスの両立です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">logger.ZLogInformation($&quot;Hello my name is {name}, {age} years old.&quot;);
</code></pre>
<p>といったように書いたコードは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">if (logger.IsEnabled(LogLvel.Information))
{
    var handler = new ZLoggerInformationInterpolatedStringHandler(30, 2, logger);
    handler.AppendLiteral(&quot;Hello my name is &quot;);
    handler.AppendFormatted&lt;string&gt;(name, 0, null, &quot;name&quot;);
    handler.AppendLiteral(&quot;, &quot;);
    handler.AppendFormatted&lt;int&gt;(age, 0, null, &quot;age&quot;);
    handler.AppendLiteral(&quot; years old.&quot;);
}
</code></pre>
<p>のようにコンパイル時に分解されます。フォーマット文字列を実行時ではなくコンパイル時に展開すること、パラメーターは<code>AppendFormatted&lt;T&gt;</code>の形でジェネリクスで受け取ることによりボクシングが発生しないなど、コードからも明らかに効率的なことが見てとれます。ちなみにコンストラクターの30は文字列の長さ、2はパラメーターの数を指していて、ここから必要な初期バッファ数を算出していることも効率化の一つに繋がっています。</p>
<p>String Interpolation自体はC# 6.0から搭載されている機能ですが、文法上同じながら<a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">C# 10.0から強化されたString Interpolation</a>が搭載されていて、カスタムのString Interpolationを提供することも可能になりました。</p>
<p>こうして得られた文字列断片とパラメーターは、最終的には<a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a>を通して文字列化せずに、直接UTF8としてStreamに書き込むことによって、高速化と低アロケーションを実現しています。</p>
<p>また、Structured Loggingにおいても、System.Text.JsonのUtf8JsonWriterとタイトに結びつくことにより</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 例えば {&quot;name&quot;:&quot;foo&quot;,age:33} のようにUtf8JsonWriterに書き込む

// Source Generator版、実際どうなってるかのイメージがとても分かりやすい。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    writer.WriteString(_jsonParameter_name, this.name);
    writer.WriteNumber(_jsonParameter_age, this.age);
}

// StringInterpolation版、ちょっと遠回りな感じですがやってることは一緒。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    for (var i = 0; i &lt; ParameterCount; i++)
    {
        ref var p = ref parameters[i];
        writer.WritePropertyName(p.Name.AsSpan());
        // MagicalBoxの説明は後述
        if (!magicalBox.TryReadTo(p.Type, p.BoxOffset, jsonWriter, jsonSerializerOptions))
        {
            // ....
        }
    }
}
</code></pre>
<p>やはり直接UTF8として書き込みます。Structured Loggingは最近のトレンドなので、色々な言語のロガーに実装されていますが、パフォーマンスを両立しつつ、ここまでクリーンなシンタックスで実現できているものは他にない！という感じなのでかなり良いのではないでしょうか。</p>
<p>では実際ベンチマーク結果でどれぐらい？というと、アロケーションは少なくとも圧倒的です。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/ab9c1f8b-a3b4-44fc-86aa-ba8dd6bdbe40" alt="image" /></p>
<p>アロケーションは、という歯切れの悪い言い方をしているのは、念入りに高速になるよう設定したNLogが思ったよりも速かったせいですね、ぐぬぬ……。</p>
<p>さて、ZLoggerの特徴のもう一つは、<a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logging">Microsoft.Extensions.Logging</a>の上に直接構築していることです。通常のロガーは独自のシステムを持っていて、Microsoft.Extensions.Loggingと繋げる場合はブリッジを通します。現実的なアプリケーションでは ASP .NETを使う場合などMicrosoft.Extensions.Loggingを避けることはほぼ不可能です。.NET 8からはOpenTelemetry対応の強化や<a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview">Aspire</a>など、ますますMicrosoft.Extensions.Loggingの重要性は増しています。ZLogger v1と異なり、v2ではScopeなど、Microsoft.Extensions.Loggingの全機能に対応しています。</p>
<p>そして例えばSerilogのブリッジライブラリの品質は（ソースコードも確認しましたが）かなり低く、実際のパフォーマンスの数字にも現れています。ZLoggerはそうしたオーバーヘッドが一切かかりません。</p>
<p>また、デフォルトの設定も非常に重要です。ほとんどのロガーの標準設定は、例えばファイルストリームに書く場合は都度Flushするなど、かなり遅い設定が標準になっています。それを高速化するにはasync, bufferedを適切に調整する必要があり、かつ、取りこぼさないように終了時に確実にFlushさせる必要があるのですが、かなり難しいので、ほとんど標準設定のままの人も多いのではないでしょうか？ZLoggerではデフォルトで最高速になるように調整してあり、かつ、Microsoft.ExtensionsのDIのライフサイクルで最後のFlushも自動でかかるようになっているので、ApplicationBuilderなどでアプリケーションを構築した場合は何も意識しなくても取りこぼしは発生しません。</p>
<p>なお、都度Flushのパフォーマンスはストレージの書き込み性能に強く依存するため、例えば最近のマシンのM.2 SSDは非常に高速なため、ローカルでベンチマークすると意外と遅くない、といったことを確認できるかもしれません。ただし、実際にアプリケーションを配置する、例えばクラウドサーバーのストレージ性能がそこまで高いことはないので、ローカルでの結果を過信しないほうがいいでしょう。</p>
<h2>MagicalBox</h2>
<p>ここからは、パフォーマンスを実現した幾つかのトリックを紹介します。v1から引き継いでいるのは<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>を活用したasyncな非同期書き込みプロセスの作成と、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.ibufferwriter-1"><code>IBufferWriter&lt;byte&gt;</code></a>による効率的なbufferedの利用による、Streamへの書き込み最適化ですが、説明は割愛します。</p>
<p>JSON化のために、パラメーターはInterpolatedStringHandlerで、一時的に値として保持します。その場合に、<code>&lt;T&gt;</code>の値をどのように保持するか、という問題がでてきます。普通に考えると、<code>List&lt;object&gt;</code>といったようなobject型で保持することになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // あらゆる&lt;T&gt;の型を格納するためにobjectを使う、ボクシングが発生するので良くはない。
    List&lt;object&gt; parameters = new ();

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&quot;value&quot;)] string? argumentName = null)
    {
        parameters.Add((object)value);
    }
}
</code></pre>
<p>それを避けるために、ZLoggerではMagicalBoxという仕組みを用意しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // 魔法の箱に無限に詰め込む
    MagicalBox magicalBox;
    List&lt;int&gt; boxOffsets = new (); // 実際はこの辺は入念にキャッシュされています

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&quot;value&quot;)] string? argumentName = null)
    {
        if(magicalBox.TryWrite(value, out var offset)) // boxingが発生しない！
        {
            boxOffsets.Add(offset);
        }
    }
}
</code></pre>
<p>MagicalBoxはどんな型(unmanaged型に限る)でも、ボクシングなしに書き込むことができる。というコンセプトで、その実態は<code>byte[]</code>にUnsafe.Write、offsetを元にUnsafe.Readするというだけの代物です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">internal unsafe partial struct MagicalBox
{
    byte[] storage;
    int written;

    public MagicalBox(byte[] storage)
    {
        this.storage = storage;
    }

    public bool TryWrite&lt;T&gt;(T value, out int offset)
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
        {
            offset = 0;
            return false;
        }

        Unsafe.WriteUnaligned(ref storage[written], value);
        offset = written;
        written += Unsafe.SizeOf&lt;T&gt;();
        return true;
    }

    public bool TryRead&lt;T&gt;(int offset, out T value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
        {
            value = default!;
            return false;
        }

        value = Unsafe.ReadUnaligned&lt;T&gt;(ref storage[offset]);
        return true;
    }
}
</code></pre>
<p>この辺は<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での実装経験が元になっていて、うまく機能しています。</p>
<p>なお、実際のコードでは<code>byte[] storage</code>の効率的な再利用や非ジェネリクスなRead対応、Enumへの特別対応が入ったりなど、もう少し<a href="https://github.com/Cysharp/ZLogger/blob/ccc3b0e6/src/ZLogger/Internal/MagicalBox.cs">複雑なコード</a>になってはいます。さすがに。</p>
<h2>カスタムフォーマット文字列</h2>
<p>ZLoggerのString Interpolationのいいところは、パラメーター値にメソッド呼び出しを含めると、LogLevelのチェックが入った後に呼び出されるので無駄な実行を防げるところです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// これは
logger.ZLogDebug($&quot;Id {obj.GetId()}: Data: {obj.GetData()}.&quot;);

// このようにLogLevelが有効かどうかチェックした後にメソッドが呼ばれる
if (logger.IsEnabled(LogLvel.Debug))
{
    // snip...
    writer.AppendFormatterd(obj.GetId());
    writer.AppendFormatterd(obj.GetData());
}
</code></pre>
<p>しかし、メソッド呼び出しをStructured Loggingに出力した場合、ZLoggerはC# 10.0以降から追加された<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.compilerservices.callerargumentexpressionattribute?view=net-8.0">CallerArgumentExpression</a>でパラメーター名を取得しているため、メソッド呼び出しの場合は &quot;obj.GetId()&quot; という微妙極まりない名前で出力されてしまいます。そこで、特殊なカスタムフォーマット文字列で別名を指定することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// @name で別名を付けられる
logger.ZLogDebug($&quot;Id {obj.GetId():@id}: Data: {obj.GetData():@data}.&quot;);
</code></pre>
<p>ZLoggerでは、String Interpolationの本来の式に従って、&quot;,&quot;でアラインメント、&quot;:&quot;でフォーマット文字列を指定することができます。それに加えて特殊な指定として、フォーマット文字列を@から始めた場合はパラメーター名として出力します。</p>
<p>@によるパラメーター名指定とフォーマット文字列は併用することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Today is 2023-12-19.
// {&quot;date&quot;:&quot;2023-12-19T11:25:34.3642389+09:00&quot;}
logger.ZLogDebug($&quot;Today is {DateTime.Now:@date:yyyy-MM-dd}.&quot;);
</code></pre>
<p>もう一つ、共通の特殊なフォーマット文字列として&quot;json&quot;を指定するとJsonSerializeした形で出力できます（この辺はSerilogの持つ機能からインスパイアされました）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var position = new { Latitude = 25, Longitude = 134 };
var elapsed = 34;

// {&quot;position&quot;:{&quot;Latitude&quot;:25,&quot;Longitude&quot;:134},&quot;elapsed&quot;:34}
// Processed {&quot;Latitude&quot;:25,&quot;Longitude&quot;:134} in 034 ms.
logger.ZLogInformation($&quot;Processed {position:json} in {elapsed:000} ms.&quot;);
</code></pre>
<p>特殊フォーマット文字列は、例えばログレベルやカテゴリー、日付を先頭/末尾に付与するためのPrefixFormatter/SuffixFormatterにも幾つか用意してあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">logging.AddZLoggerConsole(options =&gt;
{
    options.UsePlainTextFormatter(formatter =&gt;
    {
        // 2023-12-19 02:46:14.289 [DBG]......
        formatter.SetPrefixFormatter($&quot;{0:utc-longdate} [{1:short}]&quot;, (template, info) =&gt; template.Format(info.Timestamp, info.LogLevel));
    });
});
</code></pre>
<p>Timestampには<code>longdate</code>, <code>utc-longdate</code>, <code>dateonly</code>など。LogLevelには<code>short</code>で3文字ログレベル表記(先頭の長さが一致するのでエディタで開いた時に読みやすくなる)へと変換されます。これら組み込みの特殊フォーマット文字列は、パフォーマンス最適化という意味合いもあります。例えばLogLevelは以下のようなコードになっているので、手で書式を作るよりも、事前組み込みのUTF8文字列で書き込むことで、絶対的に効率がよくなっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void AppendLogLevel(ref Utf8StringWriter&lt;IBufferWriter&lt;byte&gt;&gt; writer, ref LogLevel value, ref MessageTemplateChunk chunk)
{
    if (!chunk.NoAlignmentAndFormat)
    {
        if (chunk.Format == &quot;short&quot;)
        {
            switch (value)
            {
                case LogLevel.Trace:
                    writer.AppendUtf8(&quot;TRC&quot;u8);
                    return;
                case LogLevel.Debug:
                    writer.AppendUtf8(&quot;DBG&quot;u8);
                    return;
                case LogLevel.Information:
                    writer.AppendUtf8(&quot;INF&quot;u8);
                    return;
                case LogLevel.Warning:
                    writer.AppendUtf8(&quot;WRN&quot;u8);
                    return;
                case LogLevel.Error:
                    writer.AppendUtf8(&quot;ERR&quot;u8);
                    return;
                case LogLevel.Critical:
                    writer.AppendUtf8(&quot;CRI&quot;u8);
                    return;
                case LogLevel.None:
                    writer.AppendUtf8(&quot;NON&quot;u8);
                    return;
                default:
                    break;
            }
        }

        writer.AppendFormatted(value, chunk.Alignment, chunk.Format);
        return;
    }

    switch (value)
    {
        case LogLevel.Trace:
            writer.AppendUtf8(&quot;Trace&quot;u8);
            break;
        case LogLevel.Debug:
            writer.AppendUtf8(&quot;Debug&quot;u8);
            break;
        case LogLevel.Information:
            writer.AppendUtf8(&quot;Information&quot;u8);
            break;
        case LogLevel.Warning:
            writer.AppendUtf8(&quot;Warning&quot;u8);
            break;
        case LogLevel.Error:
            writer.AppendUtf8(&quot;Error&quot;u8);
            break;
        case LogLevel.Critical:
            writer.AppendUtf8(&quot;Critical&quot;u8);
            break;
        case LogLevel.None:
            writer.AppendUtf8(&quot;None&quot;u8);
            break;
        default:
            writer.AppendFormatted(value);
            break;
    }
}
</code></pre>
<h2>.NET 8 XxHash3 + Non-GC Heap</h2>
<p>.NET 8から<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3">XxHash3</a>が追加されました。最速のハッシュアルゴリズムである<a href="https://github.com/Cyan4973/xxHash/">XxHash</a>の最新シリーズで、小さいデータから大きいデータまで、迷ったらほぼこれ一択で問題ないだろうという性能になっています。なお、利用にはNuGetから<code>System.IO.Hashing</code>が必要なので、逆に.NET 8ではなくNET Standard 2.0でも使えます。</p>
<p>ZLoggerでも複数箇所で使っているのですが、その中から一例として、String Interpolationの文字列リテラルからキャッシュを取り出す処理の例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// $&quot;Hello my name is {name}, {age} years old.&quot; が生成する文字列リテラルの並び(LiteralList)
// [&quot;Hello my name is &quot;, &quot;name&quot;, &quot;, &quot;, &quot;age&quot;, &quot; years old.&quot;]
// これからUTF8変換済みのキャッシュ(MessageSequence)を取り出すという処理
static readonly ConcurrentDictionary&lt;LiteralList, MessageSequence&gt; cache = new();

// 非.NET 8版
#if !NET8_0_OR_GREATER

struct LiteralList(List&lt;string?&gt; literals) : IEquatable&lt;LiteralList&gt;
{
    [ThreadStatic]
    static XxHash3? xxhash;

    public override int GetHashCode()
    {
        var h = xxhash;
        if (h == null)
        {
            h = xxhash = new XxHash3();
        }
        else
        {
            h.Reset();
        }

        var span = CollectionsMarshal.AsSpan(literals);
        foreach (var item in span)
        {
            h.Append(MemoryMarshal.AsBytes(item.AsSpan()));
        }

        // https://github.com/Cyan4973/xxHash/issues/453
        // XXH3 64bit -&gt; 32bit, okay to simple cast answered by XXH3 author.
        return unchecked((int)h.GetCurrentHashAsUInt64());
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        if (xs.Length == ys.Length)
        {
            for (int i = 0; i &lt; xs.Length; i++)
            {
                if (xs[i] != ys[i]) return false;
            }
            return true;
        }

        return false;
    }
}

#endif
</code></pre>
<p>XxHash3はclassなので(<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.hashcode?view=net-8.0">System.HashCode</a>みたいにstructが良かったなあ)、ThreadStaticで使いまわしつつ、GetHashCodeを生成しています。XxHash3はulongの出力しかありませんが、作者によると、32bitに落とす場合は特にXORとかかけることもなく直接落として問題ないそうです。</p>
<p>ここまでが普通の使い方ですが、.NET 8版ではエクストリームな最適化を入れました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">#if NET8_0_OR_GREATER

struct LiteralList(List&lt;string?&gt; literals) : IEquatable&lt;LiteralList&gt;
{
    // literals are all const string, in .NET 8 it is allocated in Non-GC Heap so can compare by address.
    // https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#non-gc-heap
    static ReadOnlySpan&lt;byte&gt; AsBytes(ReadOnlySpan&lt;string?&gt; literals)
    {
        return MemoryMarshal.CreateSpan(
            ref Unsafe.As&lt;string?, byte&gt;(ref MemoryMarshal.GetReference(literals)),
            literals.Length * Unsafe.SizeOf&lt;string&gt;());
    }

    public override int GetHashCode()
    {
        return unchecked((int)XxHash3.HashToUInt64(AsBytes(CollectionsMarshal.AsSpan(literals))));
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        return AsBytes(xs).SequenceEqual(AsBytes(ys));
    }
}

#endif
</code></pre>
<p><code>List&lt;string&gt;?</code>を<code>ReadOnlySpan&lt;byte&gt;</code>に変換して、それでXxHash3.HashToUInt64やSeqeunceEqualを一発で呼んでます。見るからにこちらのほうが効率的なわけですが、しかし、そもそも<code>List&lt;string&gt;?</code>を<code>ReadOnlySpan&lt;byte&gt;</code>に変換するのは合法なのか？と。この場合のstringの変換は、<code>ReadOnlySpan&lt;IntPtr&gt;</code>への変換という意味合いで、つまりヒープにあるstringのアドレスのリストへと変換しているという意図になります。</p>
<p>そこまではいいとして、問題はアドレスの比較は危険すぎないか、ということです。まず第一に、stringは文字列として同一であっても実態は別のアドレスにある場合も多い。第二に、ヒープにあるstringのアドレスは固定されていない、移動することがあるということです。辞書のキーとしてGetHashCodeやEqualsを求めるなら、アプリケーション実行中は完全に固定されていなければなりません。</p>
<p>ところが今回の利用例に着目すると、String Inteprolationで呼ばれるAppendLiteralはコンパイル時に <code>handler.AppendLiteral(&quot;Hello my name is &quot;);</code> のように、必ず定数で渡されています。そのため同じ実体を指すことが保証されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    public void AppendLiteral([ConstantExpected] string s)
}
</code></pre>
<p>一応保険として、.NET 8から有効化されている<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.codeanalysis.constantexpectedattribute?view=net-8.0">ConstantExpected</a>によって、定数だけが渡されることを明示しています。</p>
<p>もう一つは、そうした定数の文字列は最初からインターン化されているのですが、そのインターン化された場所が移動しないことは.NET 8まで保証されていませんでした。ところが、.NET 8からはNon-GC Heapが導入されたため、移動しないことが保証されている、といえます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// .NET 8からは定数のGC.GetGenerationの結果がint.MaxValue(Non-GC Heapにいる)
var str = &quot;foo&quot;;
Console.WriteLine(GC.GetGeneration(str)); // 2147483647
</code></pre>
<p>これによって、C#だとどうしても避けられないUTF16 StringからUTF8 Stringへの変換を、限界まで高速化することができました。なお、Source Generator版ではこのルックアップコスト自体を削れているため、ベンチマーク結果が最速であった通り、より高速です。</p>
<h2>.NET 8 IUtf8SpanFormattable</h2>
<p>ZLoggerでは値を文字列を通さずUTF8に直接書き込むことをパフォーマンスの柱にしています。.NET 8から<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0">IUtf8SpanFormattable</a>という、値の汎用的なUTF8への直接変換を可能にしたインターフェイスが追加されました。ZLoggerは.NET 8以前の.NET Standard 2.0にも対応させるために、intやdoubleなど基本的なプリミティブは特殊な対応によって、UTF8への直接書き込みを実現していますが、.NET 8の場合は対応範囲がより広がるため、できれば.NET 8がお薦めです。</p>
<p>なお、IUtf8SpanFormattableはフォーマット文字列のalignmentには関知しないため、分離しているライブラリである<a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a>では.NET Standard 2.0対応と同時に、alignment対応の機能も追加されたライブラリとなっています。</p>
<h2>.NET 8 TimeProvider</h2>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>は.NET 8から追加された時間に関するAPIの抽象化(TimeZone, Timerなども含む)となっていて、ユニットテスト等でも非常に役に立つ、今後の必須クラスです。TimeProviderは.NET 8未満でも<a href="https://www.nuget.org/packages/Microsoft.Bcl.TimeProvider/">Microsoft.Bcl.TimeProvider</a>を通して提供されているため、.NET Standard 2.0やUnityでも利用可能です。</p>
<p>そこでZLoggerではZLoggerOptionsにTimerProviderを指定することで、ログ出力の時間を固定することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Microsoft.Extensions.TimeProvider.TestingのFakeTimeProviderを使うとよりよい
class FakeTime : TimeProvider
{
    public override DateTimeOffset GetUtcNow()
    {
        return new DateTimeOffset(1999, 12, 30, 11, 12, 33, TimeSpan.Zero);
    }

    public override TimeZoneInfo LocalTimeZone =&gt; TimeZoneInfo.Utc;
}

public class TimestampTest
{
    [Fact]
    public void LogInfoTimestamp()
    {
        var result = new List&lt;string&gt;();
        using var factory = LoggerFactory.Create(builder =&gt;
        {
            builder.AddZLoggerInMemory((options, _) =&gt;
            {
                options.TimeProvider = new FakeTime(); // TimeProviderをカスタムのものに設定
                options.UsePlainTextFormatter(formatter =&gt;
                {
                    // Timestampを先頭に付与
                    formatter.SetPrefixFormatter($&quot;{0} | &quot;, (template, info) =&gt; template.Format(info.Timestamp));
                });
            }, x =&gt;
            {
                x.MessageReceived += msg =&gt; result.Add(msg);
            });
        });

        var logger = factory.CreateLogger&lt;TimestampTest&gt;();
        logger.ZLogInformation($&quot;Foo&quot;);

        Assert.Equal(&quot;1999-12-30 11:12:33.000 | Foo&quot;, result[0]);
    }
}
</code></pre>
<p>ログ出力の完全一致でのテストが必要……！などといった場合に有効に使うことができます。</p>
<h2>Source Generator</h2>
<p>Microsoft.Extensions.Loggingではハイパフォーマンスなログ出力のために<a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logger-message-generator">LoggerMessageAttribute</a>とSource Generatorが標準で提供されています。</p>
<p>これは確かにUTF16文字列の生成では非常に優秀ですが、Structured Logging生成部分に関しては疑問符がつきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// このpartial methodは
[LoggerMessage(LogLevel.Information, &quot;My name is {name}, age is {age}.&quot;)]
public static partial void MSLog(this ILogger logger, string name, int age, int other);

// このクラスを生成する
private readonly struct __MSLogStruct : global::System.Collections.Generic.IReadOnlyList&lt;global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;&gt;
{
    private readonly global::System.String _name;
    private readonly global::System.Int32 _age;

    public __MSLogStruct(global::System.String name, global::System.Int32 age)
    {
        this._name = name;
        this._age = age;
    }

    public override string ToString()
    {
        var name = this._name;
        var age = this._age;

        return $&quot;My name is {name}, age is {age}.&quot;; // 文字列生成は高速そう（C# 10.0のString Interpolation Improvementsにベタ乗りなので言うことなし！）
    }

    public static readonly global::System.Func&lt;__MSLogStruct, global::System.Exception?, string&gt; Format = (state, ex) =&gt; state.ToString();

    public int Count =&gt; 4;

    // こちらがStrcuted Loggingのコードですが、ん……？
    public global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt; this[int index]
    {
        get =&gt; index switch
        {
            0 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;name&quot;, this._name),
            1 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;age&quot;, this._age),
            2 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;other&quot;, this._other),
            3 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;{OriginalFormat}&quot;, &quot;My name is {name}, age is {age}.&quot;),

            _ =&gt; throw new global::System.IndexOutOfRangeException(nameof(index)),  // return the same exception LoggerMessage.Define returns in this case
        };
    }

    public global::System.Collections.Generic.IEnumerator&lt;global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;&gt; GetEnumerator()
    {
        for (int i = 0; i &lt; 4; i++)
        {
            yield return this[i];
        }
    }

    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}

[global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Extensions.Logging.Generators&quot;, &quot;8.0.9.3103&quot;)]
public static partial void MSLog(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.String name, global::System.Int32 age)
{
    if (logger.IsEnabled(global::Microsoft.Extensions.Logging.LogLevel.Information))
    {
        logger.Log(
            global::Microsoft.Extensions.Logging.LogLevel.Information,
            new global::Microsoft.Extensions.Logging.EventId(764917357, nameof(MSLog)),
            new __MSLogStruct(name, age),
            null,
            __MSLogStruct.Format);
    }
}
</code></pre>
<p><code>KeyValuePair&lt;string, object?&gt;</code> ということで、基本的に普通に作るとボクシングは避けられません、しょーがない。</p>
<p>そこで、ZLoggerでは似たようなSource Generator属性である<code>ZLoggerMessageAttribute</code>を提供しています。これにより、UTF8最適化、ボクシングレスなJSONロギングを可能にしています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// LoggerMessageをZLoggerMessageに変えるだけ
// なお、ZLoggerMessageのフォーマット文字列部分では、String Interpolation版と同じように@による別名やjsonによるJSON化も可能
[ZLoggerMessage(LogLevel.Information, &quot;My name is {name}, age is {age}.&quot;)]
static partial void ZLoggerLog(this ILogger logger, string name, int age);

// このようなコードが生成される
readonly struct ZLoggerLogState : IZLoggerFormattable
{
    // JSON用にJsonEncodedTextを事前生成
    static readonly JsonEncodedText _jsonParameter_name = JsonEncodedText.Encode(&quot;name&quot;);
    static readonly JsonEncodedText _jsonParameter_age = JsonEncodedText.Encode(&quot;age&quot;);

    readonly string name;
    readonly int age;

    public ZLoggerLogState(string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public IZLoggerEntry CreateEntry(LogInfo info)
    {
        return ZLoggerEntry&lt;ZLoggerLogState&gt;.Create(info, this);
    }
    
    public int ParameterCount =&gt; 2;
    public bool IsSupportUtf8ParameterKey =&gt; true;
    public override string ToString() =&gt; $&quot;My name is {name}, age is {age}.&quot;;

    // テキストメッセージはUTF8への直接書き込み
    public void ToString(IBufferWriter&lt;byte&gt; writer)
    {
        var stringWriter = new Utf8StringWriter&lt;IBufferWriter&lt;byte&gt;&gt;(literalLength: 21, formattedCount: 2, bufferWriter: writer);

        stringWriter.AppendUtf8(&quot;My name is &quot;u8); // u8でリテラルは直接書き込み
        stringWriter.AppendFormatted(name, 0, null);
        stringWriter.AppendUtf8(&quot;, age is &quot;u8);
        stringWriter.AppendFormatted(age, 0, null);
        stringWriter.AppendUtf8(&quot;.&quot;u8);            

        stringWriter.Flush();
    }

    // JSON出力の場合はUtf8JsonWriterに直接書き込むことで完全にボクシング避け
    public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null)
    {
        // 型によって呼び出すメソッドは異なる(WriteString, WriteNumber, etc...)
        writer.WriteString(_jsonParameter_name, this.name);
        writer.WriteNumber(_jsonParameter_age, this.age);
    }

    // 以下にMessagePack対応などの拡張用のメソッドが実際には生成されますが省略
} 

static partial void ZLoggerLog(this global::Microsoft.Extensions.Logging.ILogger logger, string name, int age)
{
    if (!logger.IsEnabled(LogLevel.Information)) return;
    logger.Log(
        LogLevel.Information,
        new EventId(-1, nameof(ZLoggerLog)),
        new ZLoggerLogState(name, age),
        null,
        (state, ex) =&gt; state.ToString()
    );
}
</code></pre>
<p>Utf8JsonWriterに直接書く、また、キー名はJsonEncodedTextを事前に生成して持っておく、という仕様によってJSON化のパフォーマンスを最大化しています。</p>
<p>また、Structured LoggingはJSONに限らず他のフォーマットもありえます。例えばMessagePackを利用することで、より小さく、より高速にすることができるでしょう。ZLoggerでは、そうしたJSON特化のようなビルトインではないプロトコルへの出力においてもボクシングを避けるためのインターフェイスが定義されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IZLoggerFormattable : IZLoggerEntryCreatable
{
    int ParameterCount { get; }

    // メッセージ出力に使う
    void ToString(IBufferWriter&lt;byte&gt; writer);

    // JSON出力に使う
    void WriteJsonParameterKeyValues(Utf8JsonWriter jsonWriter, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null);

    // それ以外の構造化ログ出力に使う
    ReadOnlySpan&lt;byte&gt; GetParameterKey(int index);
    ReadOnlySpan&lt;char&gt; GetParameterKeyAsString(int index);
    object? GetParameterValue(int index);
    T? GetParameterValue&lt;T&gt;(int index);
    Type GetParameterType(int index);
}
</code></pre>
<p>ちょっと変わったインターフェイスになっていますが、以下のようなループを回すことでボクシングの発生をなくせます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">for (var i in ParameterCount)
{
    var key = GetParameterKey(i);
    var value = GetParameterValue&lt;int&gt;();
}
</code></pre>
<p>こうした設計はADO.NETのIDataRecordの使い方と同じ設計です。また、Unityでもネイティブ→マネージドでの配列のアロケーションを避けるために、インデックス経由で取得することがよくあります。</p>
<h2>Unity</h2>
<p>UnityはUnity 2023の時点でも正式な対応C#のバージョンは9.0です。ZLoggerはC# 10.0以上のString Interpolationが大前提となっているので、普通は動きません。普通は。ところが、正式にアナウンスはされていないのですが <code>Unity 2022.2</code> から同梱されているコンパイラのバージョンが上がっていて、内部的にはC# 10.0でコンパイル可能になっていることを発見しました。</p>
<p><code>csc.rsp</code> ファイルによってコンパイラオプションを渡すことができるので、そこで明示的に言語バージョンを指定してあげると、C# 10.0の全ての文法が利用可能になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">-langVersion:10
</code></pre>
<p>このままだと出力されるcsprojには依然として<code>&lt;LangVersion&gt;9.0&lt;/LangVersion&gt;</code>が指定されているため、IDE上ではC# 10.0で書けません。そこで<a href="https://github.com/Cysharp/CsprojModifier">Cysharp/CsprojModifier</a>を用いて、LangVersionを上書きしてしまいましょう。以下のような<code>LangVersion.props</code>というファイルを作成して、CsprojModifierに混ぜてもらえば、IDE上でもC# 10.0として記述できるようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;LangVersion&gt;10&lt;/LangVersion&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>Unity向けには<code>AddZLoggerUnityDebug</code>という拡張を追加してあるので、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなグローバルのユーティリティーを用意してあげて
public static class LogManager
{
    static ILoggerFactory loggerFactory;

    public static ILogger&lt;T&gt; CreateLogger&lt;T&gt;() =&gt; loggerFactory.CreateLogger&lt;T&gt;();
    public static readonly Microsoft.Extensions.Logging.ILogger Global;

    static LogManager()
    {
        loggerFactory = LoggerFactory.Create(logging =&gt;
        {
            logging.SetMinimumLevel(LogLevel.Trace);
            logging.AddZLoggerUnityDebug(); // log to UnityDebug
        });
        Global = loggerFactory.CreateLogger(&quot;Logger&quot;);

        Application.exitCancellationToken.Register(() =&gt;
        {
            loggerFactory.Dispose(); // flush when application exit.
        });
    }
}

// 例えばこんな感じに使ってみる
public class NewBehaviourScript : MonoBehaviour
{
    static readonly ILogger&lt;NewBehaviourScript&gt; logger = LogManager.CreateLogger&lt;NewBehaviourScript&gt;();

    void Start()
    {
        var name = &quot;foo&quot;;
        var hp = 100;
        logger.ZLogInformation($&quot;{name} HP is {hp}.&quot;);
    }
}
</code></pre>
<blockquote>
<p>なお、C# 10.0のString Interpolation性能向上の恩恵を受けれるのはZLogを使った場合のみの話で、通常のString生成にString Interpolationを使っても性能向上はしません。string生成の性能向上にはランタイムにDefaultInterpolatedStringHandlerが必要で、これは .NET 6 以上にのみ同梱されているからです。DefaultInterpolatedStringHandlerが存在しない場合は今まで通りのstring.Formatにフォールバックされるため、普通にボクシングされます。</p>
</blockquote>
<p>JSONによる構造化ログや出力のカスタマイズ、ファイルへの出力などにも全て対応しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var loggerFactory = LoggerFactory.Create(logging =&gt;
{
    logging.AddZLoggerFile(&quot;/path/to/logfile&quot;, options =&gt;
    {
        options.UseJsonFormatter();
    });
});
</code></pre>
<p>そしてもう一つボーナスとして、<code>Unity 2022.3.12f1</code> 以上だとC#のコンパイラバージョンがもう少し上がっていて、<code>-langVersion:preview</code>を指定するとC# 11.0が使えます。また、ZLoggerのSource Generatorが自動で有効になっているので、<code>[ZLoggerMessage]</code>を使って生成することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static partial class LogExtensions
{
    [ZLoggerMessage(LogLevel.Debug, &quot;Hello, {name}&quot;)]
    public static partial void Hello(this ILogger&lt;NewBehaviourScript&gt; logger, string name);
}
</code></pre>
<p>Source Generatorの生成するコードがC# 11.0を要求するので(UTF8 String Literalなどを多用しているため)、<code>[ZLoggerMessage]</code>が使えるのは<code>Unity 2022.3.12f1</code> 以上限定となります。</p>
<p>なお、Unityには同種の標準ロギングライブラリとして<a href="https://docs.unity3d.com/Packages/com.unity.logging@1.2/manual/index.html">com.unity.logging</a>がリリースされています。同じように構造化ロギングやファイル出力が可能なほか、Source Generatorを使ってクラスそのものを自動生成して、メソッドのオーバーロードを引数に応じて生成することで値のボクシング避けをするといった、面白い設計をしていました。Burst云々という話がよく出てきますが、このSource Generatorの大胆な使い方のほうがパフォーマンスの肝だと思います。ZLoggerはC# 10.0のString Interpolationを活用しているわけですが、そういうアプローチでの回避策というのはちょっと考えたことがなかったので、かなり目から鱗です。パフォーマンス的にもかなり練られています。</p>
<p>ZLoggerのほうがString Interpolationによる書き味は上、パフォーマンスは、まぁいい勝負するんじゃないかなとは思いたいんですが、どうでしょうね……？</p>
<h2>NuGetForUnity</h2>
<p>今回Unityへのライブラリの配布は<a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a>を採用しました。これは普通の.NETライブラリへの依存が多いものへの配布に非常に便利で、NuGetForUnityを入れたあとに、GUIでZLoggerをこうして入れると</p>
<p><img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/5ce038b8-85be-4bed-97ec-17aec260fa84" alt="image" /></p>
<p>こんなように依存関係も解決して、Assets/Packagesの下にDLLがばらまかれます。</p>
<p><img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/62a71516-874e-4bc2-bc75-29bf0fac9dd8" alt="image" /></p>
<p>Source Generatorが含まれている場合は、ちゃんと<code>RoslynAnalyzer</code>のラベルも付与してくれるので、そのままSource GeneratorもUnity上で有効化されています。</p>
<p>良い点としては、やはり大量のマネージドDLLの管理を一括でやってくれることと、動作がシンプル（基本的には解決したファイルをAssets/Packagesにばらまくだけ)なのでやっていることがイメージつきやすいところです。同じようなツールとして<a href="https://github.com/xoofx/unitynuget">UnityNuGet</a>というものがあるのですが、そちらは独自レジストリに配布しているファイルを引っ張ってくるという作りなので、NuGetForUnity(MS公式のNuGetのレジストリから引っ張ってくる)のほうが素直な挙動で好ましく思います。</p>
<p>反面、UnityEngine.dllに依存したコードやUnityのバージョンで分岐するコードは配りにくいところがあります。ZLoggerではそのためのファイル(ZLoggerUnityDebugLoggerProvider)は別途git参照で引っ張ってくるハイブリッド方式での配布としました。かなりバランスの良いやり方かなと思うんですがどうでしょう……？特にCysharpのライブラリはコア部分はUnity非依存のものが多いので、問題なければ今後のCysharpのライブラリはこの形式での配布を基本としていきたいところです。</p>
<p>ライブラリ作者側としては、コア部分はDLLで配ることになるのでC# 12のままで良い（今まではUnityのためにC# 9にダウングレードさせて書いたりしてた）のが、とにかくとても楽ですね……！</p>
<h2>まとめ</h2>
<p>この記事は<a href="https://qiita.com/advent-calendar/2023/csharplang">C# Advent Calendar 2023</a>の12月3日分の記事となります。すごい遅刻ですが間に合ったので（？）よし。よくない。</p>
<p>なお、ZLogger v2の作成にあたっては <a href="https://github.com/hadashiA/VContainer">VContainer</a> や <a href="https://github.com/hadashiA/VYaml">VYaml</a> で有名な <a href="https://twitter.com/hadashiA">@hadashiA</a> さんに、アイディア出しから細かい実装、度重なる仕様のちゃぶ台返しに付き合ってもらいました。今回のv2は非常に完成度高くなったと思うのですが、自分一人ではここまで達しなかったので大変感謝です。</p>
<p>ともあれZLoggerは使いやすさでもパフォーマンスでも最強！のロガーに仕上がったと思いますので、是非使ってみてください。</p>
</div>
<h1 data-pagefind-sort="date:2023-10-23" data-pagefind-meta="published:2023-10-23"><a href="https://neue.cc/2023/10/23_rusttokyo.html">他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例</a></h1>
<ul class="date"><li>2023-10-23</li></ul>
<div class="entry_body"><p><a href="https://rust.tokyo/2023">Rust.Tokyo 2023</a>というRustのカンファレンスで、「他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例」と題して<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>周りの話をしてきました。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/fca414aeffb9486ab2f738466df6da02" title="他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>タイトルが若干かなり回りっくどい雰囲気になってしまいましたが、Rustのカンファレンスということで、あまりC#に寄り過ぎないように、という意識があったのですが、どうでしょう……？</p>
<p>会場での質問含めて何点かフォローアップを。</p>
<h2>FFIとパフォーマンス</h2>
<p>Rustは速い！FFIは速い！ということが常に当てはまるわけでもなく、例えばGoのcgoはかなり遅いという話があったりします。<a href="https://speakerdeck.com/filosottile/why-cgo-is-slow-at-capitalgo-2018">Why cgo is slow @ CapitalGo 2018</a>。このことは直近のRustのasyncの話<a href="https://without.boats/blog/why-async-rust/">Why async Rust?</a>でも触れられていて、cgoの遅さはGoroutine(Green Thread)が影響を及ぼしているところもある、とされています。.NET でも<a href="https://github.com/dotnet/runtimelab/blob/bec51070f1071d83f686be347d160ea864828ef8/docs/design/features/greenthreads.md">Green Threadを実験的に実装してみたというレポート</a>がついこないだ出ていたのですが、FFIの問題とか、まぁ諸々あってasync/awaitでいいじゃろ、という結論になっています。技術はなんでもトレードオフなので、過剰にGreen Threadを持ち上げるのもどうかな、とは思いますね。</p>
<p>で、C#のFFI速度ですが、こちらの<a href="https://vancan1ty.com/blog/post/52">Testing FFI Hot Loop Overhead - Java, C#, PHP, and Go</a>という記事での比較ではFFIにおいては圧勝ということになっているので、まぁ、実際C#のFFIは速いほうということでいいんじゃないでしょーか（昔からWin32 APIを何かと叩く必要があったりとかいう事情もありますし）。</p>
<p>とはいえ、原則Pure C#実装のほうがいいなあ、という気持ちはめっちゃあります。パフォーマンスのためのネイティブライブラリ採用というのは、本当に限定的な局面だけではありますね。そんなわけで、その限定的な局面であるところのコンプレッションライブラリを鋭意開発中です、来月に乞うご期待。</p>
<h2>Zig, C++</h2>
<p>FFI目的でunsafeなRust中心になるぐらいなら<a href="https://ziglang.org/ja/">Zig</a>のほうがいいんじゃない？というのは一理ある。というか最初はそう思ってZigを試したんですが、今回は見送らせていただきます、と。一理ある部分に関しては一理あるんですが、それ以外のところではRustのほうが上だという判断で、総合的にはRustを採用すべきだと至りました。</p>
<p>具体的には資料の中のRustの利点、これは資料中ではC++との比較という体にしていますが、Zigとの比較という意味もあります。標準公式のパッケージマネージャーがないし、開発環境の乏しさは、たとえZigが言語的にRustよりイージーだとしても、体感は正直言ってRustよりもハードでした。コンパイルエラーもRustは圧倒的にわかりやすいんですが、Zigはめちゃくちゃ厳しい……。Rustはイージーとは言わないですが、開発環境の助けやcargoコマンドのシンプルさ、技術情報（本・ブログ・FAQ）の多さによって、入り口は意外と大変ではない、むしろ入りやすい部類とすら言える感じです。</p>
<p>また、ZigはZigでありC/C++ではない。これはRustも同じでRustはRustでC/C++ではない、つまりCとZig(Rust)を連動させるには<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>のようなものが必要なのですが、Zigのそれの安定性がかなり低い、パースできない.hが普通にチラホラある。rust-bindgenのIssue見ていると本当に色々なケースに対応させる努力を延々と続けていて、それがbindgenの信頼性（と実用性）に繋がっているわけで、Zigはまだまだその域には達していないな、と。</p>
<p>Cはまだいいとしても、C++のエコシステムを使うという点では、ZigもRustも難しい。セッションの中では<a href="https://github.com/NVIDIA-Omniverse/PhysX">PhysX 5</a>を例に出しましたが、物理エンジンはOSSどころだと<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>も<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>も、SDKそのままそのものはC++だけなんですよね。これをC++以外の言語に持ち込むのは非常に骨の折れる仕事が必要になってきます。Rustに関してはEmbark Studiosが<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>を作ってくれたのである程度現実的ではありますが、何れにせよ大仕事が必要で、そのままでは持ち込めないというのが現実です。</p>
<p>physx-rsではC++のPhysXをRustで動かすために、まずC APIのPhysXを自動生成してそれ経由でRustから呼び出す、という話をしましたが、ZigもC++のものを呼び出すには、概ね同様のアプローチを取る必要があり、例えばZigでJolt Physicsを動かす<a href="https://github.com/michal-z/zig-gamedev">zphysics</a>というプロジェクトでは、C++のJoltに対して、C APIで公開するJoltCという部分を作って、それ経由でZigから呼び出すという手法を取っています。</p>
<p>この辺のことは<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>を作る時にめちゃくちゃ迷走して色々作りかけてたので痛感しています。そう、最初はZigでBullet Physicsを動かしてC#から呼び出すMagicBulletというプロジェクトだったこともあったのだ……。</p>
<p>最後発C++後継系言語であるところの<a href="https://github.com/carbon-language/carbon-lang">Carbon Language</a>は、C++におけるTypeScriptというのを標榜しているので、そうしたC++との連携を最優先に考えた言語になっているんじゃないかなー、と思います（触ってないので知らんですけど！）。C++の後継はRust(やZig)があるからいらんやろー、とはならない、C++の資産を活かしながらもモダンな言語仕様を使えるようにする、という絶妙な立ち位置を狙っているんじゃないかなー、と。どのぐらい盛り上がっていくのかわかりませんが……！</p>
<h2>C++/CLI</h2>
<p><a href="https://ja.wikipedia.org/wiki/C%2B%2B/CLI">C++/CLI</a>は使わないんですか？という質問がありました。.NETとC++ライブラリの連携という点で、C++/CLIはたしかに良いソリューションで、C++のライブラリをC#のために公開するブリッジとしては最高に使いやすい代物でした。.NET Frameworkの時代までは。</p>
<p>C++/CLIの問題は「.NET Core の C++/CLI サポートは Windows のみ」ということで、特にライブラリがLinuxサポートしないというのはありえないので、.NET Core以降にC++/CLIを新規採用するのは基本ありえない、といった状態になっています。こういった問題があるので、 .NET Framework時代に作られていたC++ライブラリをC#で使える系ライブラリはほとんど使えなくなりました。例えばPhysX 4の.NETバインディングである<a href="https://github.com/stilldesign/PhysX.Net">PhysX.NET</a>は、C++/CLIでバインディングが作られているため、.NET 5対応はしていますが、サポートプラットフォームはWindowsのみです。</p>
<p><a href="https://github.com/Cysharp/csbindgen">csbindgen</a>は、そうした.NET / C連携での空白地帯にちょうどうまくはまったライブラリなのではないかと思います。C++連携については頑張るしかないですが、そこはしょうがないね……！ ただ、Rustはエコシステムがうまく動いているので、Pure Rustライブラリであったり、RustでC++バインディングが作られているものを経由してC#バインディングを作る、といった手法でうまく回せる場合も多いんじゃないかなあー、というところがいいところです。それと、近年のライブラリ事情でいうと、物理エンジンみたいな老舗系はC++で作られていますが、例えば暗号通貨系のライブラリなんかは最初からRust実装だったりするものも多いので、RustからC#への持ち込み、のほうが今後の実用性としても高いんじゃないかと踏んでいます。</p>
</div>
<h1 data-pagefind-sort="date:2023-10-13" data-pagefind-meta="published:2023-10-13"><a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html">UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</a></h1>
<ul class="date"><li>2023-10-13</li></ul>
<div class="entry_body"><p>Utf8StringInterpolationという新しいライブラリを公開しました！UTF8文字列の生成と書き込みに特化していて、動作をカスタマイズした文字列補間式によるC#コンパイラの機能を活用した生成と、StringBuilder的な連続的な書き込みの両方をサポートします。</p>
<ul>
<li><a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a></li>
</ul>
<p>基本的な流れはこんな感じで、Stringを生成するのと同じように、UTF8を生成/書き込みできます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Utf8StringInterpolation;

// Create UTF8 encoded string directly(without encoding).
byte[] utf8 = Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);

// write to IBufferWriter&lt;byte&gt;(for example ASP.NET HttpResponse.BodyWriter)
Utf8String.Format(bufferWriter, $&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;); // support format

// like a StringBuilder
var writer = Utf8String.CreateWriter(bufferWriter);
writer.Append(&quot;My Name...&quot;);
writer.AppendFormat($&quot;is...? {name}&quot;);
writer.AppendLine();
writer.Flush();

// Join, Concat methods
var seq = Enumerable.Range(1, 10);
byte[] utf8seq = Utf8String.Join(&quot;, &quot;, seq);
</code></pre>
<p>Cysharpから公開している <a href="https://github.com/Cysharp/ZString/">ZString</a> と非常に近いのですが、ZStringがString(UTF16), UTF8をサポートしていたのに対して、UTF8側のみを取り出して強化したようなイメージになります。何が強化なのかというと、C# 10.0から<a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md">Improved Interpolated Strings</a>として、文字列補間式($&quot;foo{bar}baz&quot;)のパフォーマンスが大きく向上しました。具体的には、コンパイラが文字列補間式の構造を分解して、値が埋め込まれている箇所はGenericsのまま渡すようになりボクシングが消滅しました。つまりZStringでやっていたことではあるのですが、ZStringはC# 10.0以前のものですからね……！逆に言えば、これによってZStringは半分は不要となったわけです。</p>
<p>もう半分、UTF8側に関しては依然として標準のサポートは薄い、というかほぼない状態です。しかし、Improved Interpolated Strings は文字列補間式での挙動を自由にカスタマイズできるという性質も追加されています。というわけで、文字列補間式を利用してUTF8を組み立てられるようにすればいいのではないか、というのがUtf8StringInterpolationのコンセプトであり、正しくZLoggerの後継として位置づけていることでもあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こういう文字列補間式を渡すと:
// Utf8String.Format(ref Utf8StringWriter format)
Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// コンパイラが「コンパイル時」にこのような形に展開します。
var writer = new Utf8StringWriter(literalLength: 20, formattedCount: 2);
writer.AppendLiteral(&quot;Hello, &quot;);
writer.AppendFormatted&lt;string&gt;(name);
writer.AppendLiteral(&quot;, You id is &quot;);
writer.AppendFormatted&lt;int&gt;(id);
writer.AppendLiteral(&quot;!&quot;);
</code></pre>
<p>コンパイル時に展開してくれるというのは性能上非常に重要で、つまり<code>String.Format</code>のように実行時に文字列式のパースをしないで済む、わけです。また、ボクシングなしに全ての値を書き込みに呼んでくれます。</p>
<p><code>[InterpolatedStringHandler]</code>を付与している<code>ref Utf8StringWriter</code> に <code>$&quot;{}&quot;</code>を渡すと、自動的に展開してくれるという仕様になっています。そのUtf8StringWriterは以下のような実装になっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// internal struct writer write value to utf8 directly without boxing.
[InterpolatedStringHandler]
public ref struct Utf8StringWriter&lt;TBufferWriter&gt; where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    TBufferWriter bufferWriter; // when buffer is full, advance and get more buffer
    Span&lt;byte&gt; buffer;          // current write buffer

    public void AppendLiteral(string value)
    {
        // encode string literal to Utf8 buffer directly
        var bytesWritten = Encoding.UTF8.GetBytes(value, buffer);
        buffer = buffer.Slice(bytesWritten);
    }

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null)
        where T : IUtf8SpanFormattable
    {
        // write value to Utf8 buffer directly
        while (!value.TryFormat(buffer, out bytesWritten, format))
        {
            Grow();
        }
        buffer = buffer.Slice(bytesWritten);
    }
}
</code></pre>
<p>.NET 8 の場合は、値が <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0">IUtf8SpanFormattable</a> という.NET 8から追加されたインターフェイスを実装している場合(intなど標準のプリミティブはほぼ実装されています）、直接TryFormatによりUTF8としてSpanに書き込みます。</p>
<p>さすがに .NET 8 にしか対応していません！というのはエクストリームすぎるので、 .NET Standard 2.1, .NET 6(.NET 7)では <a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=net-7.0">Utf8Formatter.TryFormat</a> を使うことで、同様の性能を担保しています。</p>
<h2>Builder vs Writer</h2>
<p>ZStringのときはStringBuilderに引っ張られすぎていて、Builderとして内部でバッファを抱えるようにしていたのですが、ちょっとUTF8的な利用ではイマイチだということが徐々に分かってきました。今の .NET の基本は <code>IBufferWriter&lt;byte&gt;</code> である。というのはついこないだのCEDEC 2023での発表 <a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">モダンハイパフォーマンスC# 2023 Edition</a> でかなり語らせていただいたのですが</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>BuilderというよりもWriterとして構築すべきだな、ということに至りました。そこで <code>Utf8StringWriter</code> は基本的に<code>IBufferWriter&lt;byte&gt;</code>を受け取ってそれに書き込むという仕様となりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public ref partial struct Utf8StringWriter&lt;TBufferWriter&gt;
    where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    Span&lt;byte&gt; destination;
    TBufferWriter bufferWriter;
    int currentWritten;

    public Utf8StringWriter(TBufferWriter bufferWriter)
    {
        this.bufferWriter = bufferWriter;
        this.destination = bufferWriter.GetSpan();
    }

    public void Flush()
    {
        if (currentWritten != 0)
        {
            bufferWriter.Advance(currentWritten);
            currentWritten = 0;
        }
    }
</code></pre>
<p>バッファが足りなくなったときは拡大するのではなくて、Advanceして新たにGetSpanを呼んで新しいバッファを確保しにいくという形を取りました。StringBuilderと違ってFlushの概念が必要になってしまいましたが、パフォーマンス的には大きな向上を果たしています。</p>
<p>Flushが必要ということを除けば、StringBuilderのように扱うことができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var writer = Utf8String.CreateWriter(bufferWriter);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(or Dispose)
writer.Flush();
</code></pre>
<p>また、ちょっとStringBuilder的に使いたいだけの時に <code>IBufferWriter&lt;byte&gt;</code> を用意するのは面倒くさい！という場合のために、内部でプーリングを行っているバッファを使えるオーバーロードも用意しています。戻り値がバッファのコントローラーになっていて、ToArrayや他の<code>IBufferWriter&lt;byte&gt;</code>にコピーしたり<code>ReadOnlySpan&lt;byte&gt;</code>の取得ができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// buffer must Dispose after used(recommend to use using)
using var buffer = Utf8String.CreateWriter(out var writer);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(no need to call Dispose for writer)
writer.Flush();

// copy to written byte[]
var bytes = buffer.ToArray();

// or copy to other IBufferWriter&lt;byte&gt;, get ReadOnlySpan&lt;byte&gt;
buffer.CopyTo(otherBufferWriter);
var writtenData = buffer.WrittenSpan;
</code></pre>
<p>その他、<code>Format</code>, <code>Join</code>, <code>Concat</code> メソッドなども <code>IBufferWriter&lt;byte&gt;</code> を受け取るオーバーロードと <code>byte[]</code>を返すオーバーロードの2種を用意しています。</p>
<h2>.NET 8 と StandardFormat</h2>
<p>値のフォーマット書式は、特にDateTimeでよく使うと思いますが、数値型などでも多くの書式が用意されています。<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/formatting-types">.NET の数値、日付、列挙、その他の型の書式を設定する方法</a> や各種カスタム書式指定文字列は非常に便利です。</p>
<p>しかし、UTF8に値を直接書き込む手段として従来用意されていた<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat">Utf8Formatter.TryFormat</a>では、その標準的な書式指定文字列は使えませんでした！代わりに用意されたのが<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.standardformat">StandardFormat</a>なのですが、恐ろしく限定的なことしかできず(例えば'G', 'D', or 'X'のような一文字charの指定しかできない)、使い物にならないといっても過言ではないぐらいでした。</p>
<p>ところが .NET 8 から追加された IUtf8SpanFormattable.TryFormat では、通常の書式指定文字列が帰ってきました！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Utf8Formatter.TryFormat
static bool TryFormat (int value, Span&lt;byte&gt; destination, out int bytesWritten, System.Buffers.StandardFormat format = default);

// .NET 8 IUtf8SpanFormattable.TryFormat
bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);
</code></pre>
<p>パラメーターは非常に似ていますが、formatを文字列で受け取るようになっています。実際に比較してみるとこんな感じです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Span&lt;byte&gt; dest = stackalloc byte[16];
int written = 0;

// ParseできなくてExceptionがthrowされるので表現できない
Utf8Formatter.TryFormat(123.456789, dest, out written, StandardFormat.Parse(&quot;.###&quot;));

// 123.456
123.456123.TryFormat(dest, out written, &quot;.###&quot;);


// カスタム書式文字列は指定できないので例外！サポートしてるのは `G`, `R`, `l`, `O` だけ！
Utf8Formatter.TryFormat(DateTime.Now, dest, out written, StandardFormat.Parse(&quot;yyyy-MM-dd&quot;));

// もちろんちゃんと動作する
DateTime.Now.TryFormat(dest, out written, &quot;yyyy-MM-dd&quot;);

Console.WriteLine(Encoding.UTF8.GetString(dest.Slice(0, written)));
</code></pre>
<p>良かった、やと普通の世界が到達した……！これは ZString や、それを内部に使っていた <a href="https://github.com/Cysharp/ZLogger">ZLogger</a>で最もフラストレーションを感じていた点です。</p>
<p>Utf8StringInterpolationは .NET 8 では全て IUtf8SpanFormattable で変換するようにしています。しかし、 .NET Standard 2.1, .NET 6, .NET 7では残念ながらUtf8Formatter利用となっているので、書式指定に関しては制限があります。数値に関してはターゲットプラットフォームによって動作したりしなかったりが発生します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// .NET 8 supports all numeric custom format string but .NET Standard 2.1, .NET 6(.NET 7) does not.
Utf8String.Format($&quot;Double value is {123.456789:.###}&quot;);
</code></pre>
<p>ただし、 <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code> に関しては <code>Utf8Formatter</code> を使わない処理をしているため、全てのターゲットプラットフォームでカスタム書式指定が利用可能です！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// DateTime, DateTimeOffset, TimeSpan support custom format string on all target plaftorms.
// https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
Utf8String.Format($&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;);
</code></pre>
<p>とにかくDateTimeの書式指定がまともに出来ないのはZString/ZLoggerで一番辛かったところなので、それを改善できてとても良かった……。ただしこの対応により、DateTimeの変換性能が落ちているため、性能が最大限引き出せるのは .NET 8 となります。</p>
<h2>Unity</h2>
<p>Unity対応はありません！いや、可能な限り私は .NET と Unityの両対応のライブラリを作りたいと思っていて、実際今までもそうしてきているわけですが、今回ばかりはどうにもならないのです。そもそもImproved Interpolated Stringsが C# 10.0 からで、Unityの現在のC#のバージョンは C# 9.0……！さすがにそれはどうにもならない。</p>
<p>C# 9.0で止まってから結構長いんですよね。別にランタイムのバージョンは上げなくてもいいから、コンパイラのバージョンだけ上げて欲しいと切実に思いますが、まぁC# 10.0にしたらDefaultInterpolatedStringHandlerがなくて動作しないじゃんとかなるだろうから、結局はランタイムのバージョンアップもセットでやらなければならない……。</p>
<p>Unityが C# 10.0 に対応したらすぐに対応させるつもりではあります！待ってます！</p>
<h2>Next</h2>
<p>さて、とはいえ、UTF8文字列を直接扱わなければならないケースというのは、別にそんなに多くはないでしょう。実際、私も本命は<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>の大型バージョンアップでの利用を考えています。ZLoggerは今まではZStringベースでしたが、根本からデザインをやり直した新しいものを開発中です。その中の文字列化にUtf8StringInterpolationを使っています。</p>
<p>といったように、アプリケーションの基盤レイヤーに差し込んであげると有効に機能するシチュエーションは色々あると思います。もちろん、直接使ってもらってもいいのですが……！？</p>
</div>
<h1 data-pagefind-sort="date:2023-09-21" data-pagefind-meta="published:2023-09-21"><a href="https://neue.cc/2023/09/21_privateproxy.html">.NET 8 UnsafeAccessor を活用したライブラリ PrivateProxy を公開しました</a></h1>
<ul class="date"><li>2023-09-21</li></ul>
<div class="entry_body"><p>PrivateProxyというライブラリを公開しました。つまるところ、privateフィールド/プロパティ/メソッドにアクセスするライブラリなのですが、.NET 8 のUnsafeAccessorという新機能を活用することでNo Reflection、ハイパフォーマンス、AOTセーフになっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/PrivateProxy">Cysharp/PrivateProxy</a></li>
</ul>
<p>もちろん .NET 8 でしか動きません！ので、.NET 8が正式リリースされた頃に思い出して使ってみてください。エクストリームな人は今すぐ試しましょう。</p>
<p>雰囲気としては、privateメンバーにアクセスしたい型があったとして、<code>[GeneratePrivateProxy(type)]</code>をつけた型を用意します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using PrivateProxy;

public class Sample
{
    int _field1;
    int PrivateAdd(int x, int y) =&gt; x + y;
}

[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p>すると、いい感じにアクセスできるようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// You can access like this.
var sample = new Sample();
sample.AsPrivateProxy()._field1 = 10;
</code></pre>
<p>いいところとしては、 Source Generatorベースの生成なので、型がついていて入力補完も効くし、変数名を変更したらコンパイルエラーで検出可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/269376472-f6dd22e1-e82e-4acc-ba6e-8895c8c8734b.png" alt="" /></p>
<p>ここまではSource Generatorベースで作れば、今まででもやれないことはなかったのですが、UnsafeAccessorのいいところとして、objectが一切出てこないで元のメソッドそのままの型がそのまま使えることです。生成されたコードを見ると、こうなっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Source Generator generate this type
partial struct SampleProxy(Sample target)
{
    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &quot;_field1&quot;)]
    static extern ref int ___field1__(Sample target);

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;PrivateAdd&quot;)]
    static extern int __PrivateAdd__(Sample target, int x, int y);

    public ref int _field1 =&gt; ref ___field1__(target);
    public int PrivateAdd(int x, int y) =&gt; __PrivateAdd__(target, x, y);
}

public static class SamplePrivateProxyExtensions
{
    public static SampleProxy AsPrivateProxy(this Sample target)
    {
        return new SampleProxy(target);
    }
}
</code></pre>
<p>これによって <code>ref</code> や <code>readonly</code> などの言語機能をそのまま反映できたり、mutableなstructの対応が自然にできたり、そして何よりパフォーマンスの低下も一切ありません。</p>
<p>使い道は、主にユニットテスト用になるとは思いますので、なのでパフォーマンスはそこまで重要ではないといえばないのですが、性能的にはアプリケーションの実行時に使っても問題ないものとなっています。</p>
<p>私は昔<a href="https://github.com/neuecc/ChainingAssertion">Chaining Assertion</a>というユニットテスト用のライブラリを作っていたのですが、現在は<a href="https://fluentassertions.com/">Fluent Assertions</a>という別のライブラリを使っています。ほとんどの機能は概ねなんとかなっているのですが、<code>AsDynamic()</code>を呼ぶと、移行はprivateフィールドやメソッドにアクセスし放題という機能は結構便利で、そしてそれがFluent Assertionsにないのは若干不便と思ってたんですね。今回、やっとそれの進化系を作れたのでメデタシメデタシです。</p>
<h2>C# 12</h2>
<p>ところで、冒頭のSampleProxyの書き方、地味にこれはC# 12の記法を使っています。どこだかわかりますか？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p><code>SampleProxy;</code> の部分で、空のクラスを作る際に <code>{ }</code> じゃなくて <code>;</code> だけで済ませられるようになりました。これは地味ですがかなりいい機能で、というのもSource Generatorだと空クラスに割り当てることが多かったんですよね。そして、たった2文字が1文字に変わっただけ、ではあるのですが、 <code>{ }</code> だとコードフォーマットに影響があります。改行して3行で表現するのか、後ろにつけるのか。そうした判断のブレが <code>;</code> だとなくなります。だから2文字が1文字に変わっただけ、以上のインパクトがある、良い機能追加だと思います。</p>
<h2>ref field</h2>
<p>PrivateProxyはstaticメソッドにも対応していますし、そしてmutable structにも対応しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using PrivateProxy;

public struct MutableStructSample
{
    int _counter;
    void Increment() =&gt; _counter++;

    // static and ref sample
    static ref int GetInstanceCounter(ref MutableStructSample sample) =&gt; ref sample._counter;
}

// use ref partial struct
[GeneratePrivateProxy(typeof(MutableStructSample))]
public ref partial struct MutableStructSampleProxy;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var sample = new MutableStructSample();
var proxy = sample.AsPrivateProxy();
proxy.Increment();
proxy.Increment();
proxy.Increment();

// call private static method.
ref var counter = ref MutableStructSampleProxy.GetInstanceCounter(ref sample);

Console.WriteLine(counter); // 3
counter = 9999;
Console.WriteLine(proxy._counter); // 9999
</code></pre>
<p>mutable structの対応って結構難しい話で、というのもフィールドにstructを保持するとコピーが渡されることになるので、普通に書いていると変更が元のstructに反映されないんですね。この問題をPrivateProxyではC# 11 ref fieldで解決しました。</p>
<p>MutableStructSampleProxyはSource Generatorによって以下のようなコードが生成されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">ref partial struct MutableStructSampleProxy
{
    ref MutableStructSample target;

    public MutableStructSampleProxy(ref MutableStructSample target)
    {
        this.target = ref target;
    }

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;Increment&quot;)]
    static extern void __Increment__(ref MutableStructSample target);
    
    public void Increment() =&gt; __Increment__(ref this.target);
}

public static class MutableStructSamplePrivateProxyExtensions
{
    public static MutableStructSampleProxy AsPrivateProxy(this ref MutableStructSample target)
    {
        return new MutableStructSampleProxy(ref target);
    }
}
</code></pre>
<p>AsPrivateProxy(これはthis refですが、拡張メソッドの場合、予備側はrefを書かなくていいので自然に使えます)で渡されたstructは、そのままずっとrefのまま保持されています。これにより、メソッド呼び出しでstructの状態に変更があった場合も問題なく変更が共有されています。</p>
<h2>privateメソッドの単体テスト</h2>
<p><a href="https://t-wada.hatenablog.jp/entry/should-we-test-private-methods">プライベートメソッドのテストは書かない</a>みたいな流儀も世の中にはありますが、私は何言ってんの？と思ってます。パブリックメソッドのテストでprivateメソッドの確認が内包されるから不要というなら、はぁー？だったら全部E2Eテストでいいんじゃないですかー？真の振る舞いがテストされますよー？</p>
<p>もちろんそれは非現実的で、E2Eでパブリックメソッドのロジックを全て通過させるのは手間とコストがかかりすぎる。というのと同じ話で、privateメソッドのエッジケースを全てチェックする時に、public経由だとやりにくいことは往々にある。場合によってはコード通すためにモックを仕込まなければならないかもしれない。そこまでいくとアホらしいですよね、privateメソッドを直接テストすればすむだけの話なのに？メソッドは小さければ小さいほど良いし、テストもしやすい。そしてprivateを内包したpublicよりもprivateそのもののほうが小さく、テストしやすい。</p>
<p>ようするにコスト面を考えて境界をどこに置くかというだけの話で。そして、privateメソッドのテストそのものは、C#の場合reflection呼び出しだと、変更コストがかかるなど、コスパは悪い部類に入ってしまう。でもそれはただの言語からの制約であって、だからプライベートメソッドのテストは不要みたいなしょーもない理屈をこねて絶対視するほどのことでもない。リフレクション使うとコスパ感が合わないから原則publicで済ませること、ぐらいだったらいいけど、変な教義立てるのはおかしいでしょ。</p>
<p>チェックしたいがためにprivateであるべきものをinternalにする（たまによくやる、internalならInternalsVisibleToをテストプロジェクトに指定することで、ユニットテストプロジェクトで参照できるようになる）こともありますが、あまりお行儀の良いことではない。そもそもinternalなので同一アセンブリ内では不要に可視レベル上がっちゃってるし。</p>
<p>と、いうわけで、PrivateProxyは比較的低コストでprivateメソッドをテスト対象にすることができるので、全然使っちゃっていいし、テストも書いちゃって良い、わけです。</p>
<h2>UnsafeAccessor for InternalCall</h2>
<p>UnsafeAccessor の使い道として、corelibの InternalCall を強引に呼べることはかなりいいこと（？）だと思ってます。例えば string の生成には大元に <a href="https://source.dot.net/#System.Private.CoreLib/src/System/String.CoreCLR.cs,12">FastAllocateString</a> というのがあって、通常ユーザーはこれを呼ぶことはできないのですが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = &quot;FastAllocateString&quot;)]
static extern string FastAllocateString(string _, int length);

var rawString = FastAllocateString(null!, 10);
var mutableSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(rawString.AsSpan()), rawString.Length);

&quot;abcde&quot;.CopyTo(mutableSpan);
&quot;fghij&quot;.CopyTo(mutableSpan.Slice(5));

Console.WriteLine(rawString); // abcdefghij
</code></pre>
<p>といったようにUnsafeAccessorを通せばやりたい放題できます。</p>
<p>Stringに関しては、やりたい放題させないために、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.string.create">String.Create</a>というメソッドが用意されていて、Actionのコールバックで変更して、不変のStringを返すというものが用意されてはいるのですが、ActionだとTStateに<code>Span&lt;T&gt;</code>を渡せないとか、使えないケースがそれなりにあります、というか使いたいシチュエーションに限って使えないことが多い……。</p>
<p>なお、こういうFastAllocateStringを呼んでStringに変更をかけるというのは、<a href="https://github.com/dotnet/runtime/issues/36989">dotnet/runtime#36989 Make string.FastAllocateString public</a>で見事に却下されています。つまり、やるな、ということです。</p>
<blockquote>
<p>It is never safe or supported to mutate the contents of a returned string instance.
If you mutate a string instance within your own library or application, you are entering unsupported territory.
A future framework update could break you. Or - more likely - you'll encounter memory corruption that will be very painful for you or your customers to diagnose.</p>
</blockquote>
<p>お怒りはご尤もです。しかしString.CreateでAction渡す口あるんだからそれでいいだろーというのはお粗末すぎだと思うんですよねー、どうせやってること一緒なんだから弄るの許可してよ、というのもそれはそれで理解してもらいたいです（私は弄りたいほうの人間なので！）。というわけで、自己責任で、やっていきましょう、つまりやっていくということです……！</p>
<h2>まとめ</h2>
<p>.NET 8でしか動きません！11月に .NET 8 がリリースされるので、その時まで忘れないでください！</p>
</div>
<h1 data-pagefind-sort="date:2023-07-28" data-pagefind-meta="published:2023-07-28"><a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html">Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</a></h1>
<ul class="date"><li>2023-07-28</li></ul>
<div class="entry_body"><p>Cysharpから(主に)Unity用のHTTP/2, gRPC, MagicOnion用の通信ネットワーククライアントを公開しました。実装者は週刊.NET情報配信<a href="https://weekref.net/">WeekRef.NET</a>を運営している<a href="https://twitter.com/mayuki">@mayuki</a>さんです。</p>
<ul>
<li><a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a></li>
</ul>
<p>何故これが必要なのかの背景情報としては、<a href="https://synamon.hatenablog.com/entry/grpc-dotnet-unity">Synamon’s Engineer blog - Unityでもgrpc-dotnetを使ったgRPCがしたい</a> が詳しいのですが、まず、.NETには2つのgRPC実装があります。googleが提供してきたgRPCのネイティブバインディングのGrpc.Core(C-Core)と、Microsoftが提供しているPure C#実装のgrpc-dotnet。現在.NETのgRPCはサーバーもクライアントも完全にPure C#実装のほうに寄っていて、<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>もサーバーはPure C#実装のものを使っています。</p>
<p>しかしクライアントに関しては、諸事情によりUnityでは動かない（TLS関連の問題など）ため、ずっとC-Coreを推奨してきました。更に、Unity用のビルドは元々experimentalだったうえに、とっくにメンテナンスモードに入り、そしてついに今年5月にサポート期限も切れて完全に宜しくない気配が漂っていました。また、古いx64ビルドなので最近のMac(M1, M2チップ)では動かないためUnity Editorで使うのにも難儀するといった問題も出てきていました。</p>
<p>と、いうわけで、CysharpではUnityで使うgRPCを推奨してきたということもあり、Unityで問題なく使えるgRPC実装としてYetAnotherHttpHandlerを開発・リリースしました。HttpClientの通信レイヤーであるHttpHandlerを差し替えるという形で実装してあるので、ほとんど通常の .NET でのgRPCと同様に扱えます。</p>
<p>内部実装としてはPure Rust実装のHTTP/2ライブラリ<a href="https://hyper.rs/">hyper</a>とPure RustのTLSライブラリ<a href="https://github.com/rustls/rustls">rustls</a>を基盤として作ったネイティブライブラリに対して、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>で生成したC#バインディングを通して通信する形になっています。</p>
<h2>余談</h2>
<p>YetAnotherHttpHandlerはgRPCやMagicOnionに限らず、Unityで自由に使える HTTP/2 Clientなので、アセットダウンロードの高速化にHTTP/2を用いる、といったような使い道も考えられます。既にモバイルゲームでも幾つかのタイトルでHTTP/2でアセットダウンロードしているタイトルは確認できていまして、例えばセガさんは<a href="https://speakerdeck.com/segadevtech/cedec2021-taunrotoshi-jian-woda-fu-jian-da-liang-falseasetutowosahakugao-su-nashi-zhuang-toyun-yong-shi-li-falsegong-you">CEDEC2021 ダウンロード時間を大幅減！～大量のアセットをさばく高速な実装と運用事例の共有～</a>のような発表もされています。ネイティブプラグインを自前でビルドして持ち込むというのはだいぶ敷居が高い話でしたが、YetAnotherHttpHandlerを入れるだけでいいなら、だいぶやれるんじゃないか感も出てくるんじゃないでしょうか……？</p>
</div>
<h1 data-pagefind-sort="date:2023-07-20" data-pagefind-meta="published:2023-07-20"><a href="https://neue.cc/2023/07/20_nats_client_v2.html">AlterNats は 公式の NATS .NET Client v2 に引き継がれました</a></h1>
<ul class="date"><li>2023-07-20</li></ul>
<div class="entry_body"><p><a href="https://nats.io/">NATS</a>のサードパーティー(alternative)クライアントであった<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>は、公式に引き取られて<a href="https://github.com/nats-io/nats.net.v2">NATS.NET V2</a>となりました。v2の詳細に関してはNATS公式からのブログ<a href="https://nats.io/blog/nats-dotnet-v2-alpha-release/">NATS .NET Client v2 Alpha Released with Core NATS Support</a>を参照ください。</p>
<blockquote>
<p>NATS community members started to take note, and develop client libraries for NATS based on modern .NET APIs. One notable client library that emerged was the AlterNats library by Cysharp, which includes a fully asynchronous API, leverages Span<T> , and supports client-side WebSockets from browsers in Blazor . NATS maintainers and AlterNats maintainers agreed that AlterNats would make a great starting point for NATS.Client v2!</p>
</blockquote>
<p>NATSに関してはAlterNatsリリース時の記事 <a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a>に色々書きましたが、<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>配下のPubSubミドルウェアで、RedisなどでのPubSubに比べるとパフォーマンスを始めとして多くのメリットがあります。</p>
<p>ただしこういうものはサーバー実装も重要ですがクライアント実装も重要であり、そして当時のNATSの公式クライアント(v1)は正直酷かった！せっかくの素晴らしいミドルウェアが.NETでは活かされない、また、RedisでのPubSubには不満があり、そもそも.NETでのベストなPubSubのソリューションがないことに危機意識を感じていたので、独自に実装を進めたのがAlterNatsでした。</p>
<p>ただし、枯れたプロトコルならまだしも、進化が早いミドルウェアのクライアントが乱立しているのは決して良いことでもないでしょう。新機能への追随速度やメンテナンスの保証という点でも、サードパーティクライアントとして進んでいくよりも、公式に統合されることのほうが絶対に良いはずです。</p>
<p>というわけで今回の流れは大変ポジティブなことだし、野良実装にとって最高の道を辿れたんじゃないかと思っています。私自身は実装から一歩引きますが、使っていく上で気になるところがあれば積極的にPR上げていくつもりではあります。</p>
<p>なお、NATSに関しては来月CEDEC 2023でのセッション<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>で触れる、かもしれません、多分。というわけでぜひ聞きに来てください……！</p>
<p>メタバース関連では、今年の5月にTGS VRなどを手掛けている<a href="https://ambr.co.jp/">ambr</a>さんのテックブログにて<a href="https://ambr-inc.hatenablog.com/entry/20230512/1683882000">VRメタバースのリアルタイム通信サーバーの技術にMagicOnionとNATSを選んだ話</a>という紹介もしていただいていました。</p>
<h2>OSSとメンテナンスの引き継ぎ</h2>
<p>権限の移管は何度か経験があって</p>
<ul>
<li><a href="https://github.com/mihaifm/linq">linq.js</a>、</li>
<li><a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a></li>
<li><a href="https://github.com/xin9le/CloudStructures">CloudStructures</a></li>
</ul>
<p>は完全に手放しています。ほか、<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>はCysharp名義に移ったうえで、現在の開発リードは私ではありません。また、最近では<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#</a>はMessagePack-CSharp Organizationに移していて共同のOwner権限になっています。</p>
<p>どうしても常に100%の力を一つのOSSに注ぐことはできないので、本来はうまく移管していけるのが良いわけですが、いつもうまくできるわけじゃなくて、<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>なんかはうまく移管できないままarchivedにしてしまっています。</p>
<p>やっぱ出した当時は自分が手綱を握っていたいという気持ちがとても強いわけですが、関心が徐々に薄れていくタイミングと他の人に渡せるタイミングがうまく噛み合わないと、死蔵になってしまうというところがあり、まぁ、難しいです。これだけやっていても上手くできないなあ、と……。</p>
<p>今回のは大変良い経験だったので、作ってメンテナンスを続ける、そしてその先についても考えてやっていきたいところですね。</p>
<p>ともあれ、良い事例を一つ作れた＆素晴らしいライブラリをC#に一つ持ち込むことができたということで、とても気分がよいですです。</p>
</div>
<h1 data-pagefind-sort="date:2023-07-07" data-pagefind-meta="published:2023-07-07"><a href="https://neue.cc/2023/07/07_mvp-renew13.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2023-07-07</li></ul>
<div class="entry_body"><p>13回目です！一年ごとに再審査での更新で、変わらずC#の最前線に立てています。</p>
<p>活動の中心は引き続きOSSですが、<a href="https://github.com/Cysharp">github/Cysharp</a>でのスター数は変わらず他を圧倒していると思いますし、毎年の新規の公開数の勢いも変わらずで新しいアイディアを出し続けています。</p>
<p>今年は<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>を起点にしてRustを活用してC#の活用幅をより広げていくことを狙っています。先日公開した<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>の他にも色々計画がって、かなり面白いインパクトが出せるんじゃないかと思っています。</p>
<p>MessagePack for C#も<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack-CSharp/MessagePack-CSharp</a>と、organization名義に移したことで（変わらず私はOwnerなので権限を手放したわけではありません）より中立的に発展させていきます。直近ではSource Generator対応が予定されています(preview版を公開中）。</p>
<p>というわけで、これはもう満場一致でC#に貢献しているということでいいんじゃないでしょうかね……？</p>
<p>ここ最近は登壇していなかったのですが、去年は<a href="https://speakerdeck.com/neuecc/c-number-11-niyorushi-jie-zui-su-bainarisiriaraiza-memorypack-nozuo-rifang">C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a>というセッションをしました。その流れということで、今年の8月にCEDEC 2023にて<a href="https://cedec.cesa.or.jp/2023/session/detail/s642165615a6b5">モダンハイパフォーマンスC# 2023 Edition</a>、それと共同講演で<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>という2つの登壇予定があるので、ぜひ見に来てください。</p>
</div>
<h1 data-pagefind-sort="date:2023-07-04" data-pagefind-meta="published:2023-07-04"><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></h1>
<ul class="date"><li>2023-07-04</li></ul>
<div class="entry_body"><p>MagicPhysXというライブラリを新しく公開しました！.NETで物理エンジンを動かすというもので、その名の通り、<a href="https://github.com/NVIDIA-Omniverse/PhysX">NVIDIA PhysX
</a>のC#バインディングとなっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/MagicPhysX">Cysharp/MagicPhysX</a></li>
</ul>
<p>使い道としては</p>
<ul>
<li>GUIアプリケーションの3D部分</li>
<li>自作ゲームエンジンへの物理エンジン組み込み</li>
<li>ディープラーニングのためのシミュレーション</li>
<li>リアルタイム通信におけるサーバーサイド物理</li>
</ul>
<p>といったことが考えられます。</p>
<p>.NET用のPhysXバインディングは他にも存在しますが、C++/CLIでバインディングを生成している都合上Windowsでしか動かせなかったり、バージョンが最新ではない4.xベースだったりしますが、MagicPhysXは最新のPhysX 5ベースで、かつ、Windows, MacOS, Linuxの全てで動きます！(win-x64, osx-x64, osx-arm64, linux-x64, linux-arm64)。これはバインディングの作り方としてクロスプラットフォームコンパイルに強いRustと、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>によってC#のバインディングの自動生成をしているからです。</p>
<p>先にアーキテクチャの話をしましょう。MagicPhysXは<a href="https://www.embark-studios.com/">EmbarkStudios</a>による<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>をビルド元に使っています。</p>
<blockquote>
<p>EmbarkStudiosはEA DICEで<a href="https://www.ea.com/frostbite">Frostbite</a>ゲームエンジン(Battlefield)を作っていた人たちが独立して立ち上げたスタジオで、Rustによるゲームエンジンを作成中です。また、その過程で生まれたRustのライブラリをOSSとして積極的に公開しています。一覧は<a href="https://embark.dev/">Embark Studios Open Source</a>にあります。必見！</p>
</blockquote>
<p>PhysXのライブラリはC++で出来ていて、他の言語で使うことは考慮されていません。そのために他の言語に持ち込むためには、C++上で別言語で使うためのブリッジ部分を作った上で、バインディングを用意するという二度手間が必要になってきます。それはRustであっても例外ではありません。また、二度手間というだけではなく、PhysXのソースコードはかなり大きいため、その作業量も膨大です。</p>
<p>以前に<a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a>で紹介しましたが、<a href="https://www.swig.org/">SWIG</a>などのC++からの自動生成、Rustであれば<a href="https://cxx.rs/">cxx</a>、<a href="https://github.com/google/autocxx">autocxx</a>のような自動化プロジェクトも存在しますが、C++そのものの複雑さからいっても、求めるものを全自動で出力するのは難しかったりします。</p>
<p>physx-rsでは<a href="https://www.youtube.com/watch?v=RxtXGeDHu0w">An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)</a>というセッションでPhysXをRustに持ち込むための手段の候補、実際に採用した手段についての解説があります。最終的に採用された手段について端的に言うと、PhysXに特化してコード解析してC APIを生成する独自ジェネレーターを用意した、といったところでしょうか。そしてつまり、physx-rsには他言語でもバインディング手段として使えるPhysXのC APIを作ってくれたということにもなります！</p>
<p>更にcsbindgenには、rsファイル内のextern &quot;C&quot;の関数からC#を自動生成する機能が備わっているので、Rustを経由することでC++のPhysXをC#に持ち込めるというビルドパイプラインとなりました。</p>
<p>そういう成り立ちであるため、MagicPhysXのAPIはPhysXのAPIそのものになっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using MagicPhysX; // for enable Extension Methods.
using static MagicPhysX.NativeMethods; // recommend to use C API.

// create foundation(allocator, logging, etc...)
var foundation = physx_create_foundation();

// create physics system
var physics = physx_create_physics(foundation);

// create physics scene settings
var sceneDesc = PxSceneDesc_new(PxPhysics_getTolerancesScale(physics));

// you can create PhysX primitive(PxVec3, etc...) by C# struct
sceneDesc.gravity = new PxVec3 { x = 0.0f, y = -9.81f, z = 0.0f };

var dispatcher = phys_PxDefaultCpuDispatcherCreate(1, null, PxDefaultCpuDispatcherWaitForWorkMode.WaitForWork, 0);
sceneDesc.cpuDispatcher = (PxCpuDispatcher*)dispatcher;
sceneDesc.filterShader = get_default_simulation_filter_shader();

// create physics scene
var scene = physics-&gt;CreateSceneMut(&amp;sceneDesc);

var material = physics-&gt;CreateMaterialMut(0.5f, 0.5f, 0.6f);

// create plane and add to scene
var plane = PxPlane_new_1(0.0f, 1.0f, 0.0f, 0.0f);
var groundPlane = physics-&gt;PhysPxCreatePlane(&amp;plane, material);
scene-&gt;AddActorMut((PxActor*)groundPlane, null);

// create sphere and add to scene
var sphereGeo = PxSphereGeometry_new(10.0f);
var vec3 = new PxVec3 { x = 0.0f, y = 40.0f, z = 100.0f };
var transform = PxTransform_new_1(&amp;vec3);
var identity = PxTransform_new_2(PxIDENTITY.PxIdentity);
var sphere = physics-&gt;PhysPxCreateDynamic(&amp;transform, (PxGeometry*)&amp;sphereGeo, material, 10.0f, &amp;identity);
PxRigidBody_setAngularDamping_mut((PxRigidBody*)sphere, 0.5f);
scene-&gt;AddActorMut((PxActor*)sphere, null);

// simulate scene
for (int i = 0; i &lt; 200; i++)
{
    // 30fps update
    scene-&gt;SimulateMut(1.0f / 30.0f, null, null, 0, true);
    uint error = 0;
    scene-&gt;FetchResultsMut(true, &amp;error);

    // output to console(frame-count: position-y)
    var pose = PxRigidActor_getGlobalPose((PxRigidActor*)sphere);
    Console.WriteLine($&quot;{i:000}: {pose.p.y}&quot;);
}

// release resources
PxScene_release_mut(scene);
PxDefaultCpuDispatcher_release_mut(dispatcher);
PxPhysics_release_mut(physics);
</code></pre>
<p>つまり、そのままでは決して扱いやすくはないです。部分的に動かすだけではなく、本格的にアプリケーションを作るなら、ある程度C#に沿った高レベルなフレームワークを用意する必要があるでしょう。MagicPhysX内ではそうしたサンプルを用意しています。それによって上のコードはこのぐらいシンプルになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using MagicPhysX.Toolkit;
using System.Numerics;

unsafe
{
    using var physics = new PhysicsSystem(enablePvd: false);
    using var scene = physics.CreateScene();

    var material = physics.CreateMaterial(0.5f, 0.5f, 0.6f);

    var plane = scene.AddStaticPlane(0.0f, 1.0f, 0.0f, 0.0f, new Vector3(0, 0, 0), Quaternion.Identity, material);
    var sphere = scene.AddDynamicSphere(1.0f, new Vector3(0.0f, 10.0f, 0.0f), Quaternion.Identity, 10.0f, material);

    for (var i = 0; i &lt; 200; i++)
    {
        scene.Update(1.0f / 30.0f);

        var position = sphere.transform.position;
        Console.WriteLine($&quot;{i:D2} : x={position.X:F6}, y={position.Y:F6}, z={position.Z:F6}&quot;);
    }
}
</code></pre>
<p>ただしあくまでサンプルなので、参考にしてもらいつつも、必要な部分は自分で作ってもらう必要があります。</p>
<p>Unityのようなエディターがないと可視化されてなくて物理エンジンが正しい挙動になっているのか確認できない、ということがありますが、PhysXにはPhysX Visual Debuggerというツールが用意されていて、MagicPhysXでも設定することでこれと連動させることが可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/250030945-2018e821-41c4-44a2-aac6-f0705993ab9b.png" alt="" /></p>
<h2>Dedicated Server</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>といったサーバーサイドでゲームのロジックを動かすためのライブラリを開発しています。その路線から行って物理エンジンが必要なゲームでさえも通常の .NET サーバーで動かしたいという欲求が出てくるのは至極当然でしょう……（？）</p>
<p>UEやUnityのDedicated Serverの構成だとヘッドレスなUE/Unityアプリケーションをサーバー用ビルドしてホスティングすることになりますが、サーバー用のフレームワークではないので、あまり作りやすいとは言えないんですよね。通常用サーバー向けのライブラリとの互換性、ライフサイクルの違い、ランタイムとしてのパフォーマンスの低さ、などなど。</p>
<p>というわけで、MagicOnionのようなサーバー向けフレームワークを使ったほうがいいのですが、物理エンジンだけはどうにもならない。今までは……？</p>
<p>と、言いたいのですが、まずちゃんとしっかり言っておきたいのですが、現実的には少々（かなり）難しいでしょう！コライダーどう持ってくるの？とかAPIが違う（Unityの物理エンジンはPhysXですが、API的に1:1の写しではないので細かいところに差異がある）のでそもそも挙動を合わせられないし、でもこういう構成ならサーバーだけじゃなくクライアントでも動かしたい、そもそもそうじゃないとデバッガビリティが違いすぎる。</p>
<p>と、ようするに、もしゲーム自体にある程度、物理エンジンに寄せた挙動が必要なら、「物理エンジン大統一」が必須だと。MagicPhysXは残念ながらそうではありません。実のところ当初はそれを目指していました、Unityとほぼ同一挙動でほぼ同一APIになるのでシームレスに持ち込むことができるライブラリなのだ、と。しかし現状はそうではないということは留意してください。また、その当初予定である互換APIを作り込む予定もありません。</p>
<h2>まとめ</h2>
<p>このライブラリ、かなり迷走したプロジェクトでもあって、そもそも最初は<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>を採用する予定でした。ライブラリ名が先に決めてあってMagicBulletってカッコイイじゃん、みたいな。その後に<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>を使おうとして、これもバインディングをある程度作って動く状態にしたのですが、「物理エンジン大統一」のためにPhysXにすべきだろうな、という流れで最終的にPhysXを使って作ることにしました。</p>
<p>形になって良かったというのはありますが（そしてcsbindgenの実用性！）、「物理エンジン大統一」を果たせなかったのは少々残念ではあります。最初の完成予想図ではもっともっと革命的なもののはずだったのですが……！</p>
<p>とはいえ、PhysX 5をクロスプラットフォームで.NETに持ち込んだということだけでも十分に難易度が高く新しいことだと思っているので、試す機会があれば、是非触って見ください。</p>
</div>
<h1 data-pagefind-sort="date:2023-03-09" data-pagefind-meta="published:2023-03-09"><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></h1>
<ul class="date"><li>2023-03-09</li></ul>
<div class="entry_body"><p>ネイティブコードとC#を透過的に接続するために、RustのFFIからC#のDllImportコードを自動生成するライブラリを作成し、公開しました。Cysharp初のRustライブラリです！先週にプレビューを出していましたが、しっかりした機能強化とReadMeの充実をして正式公開、です！</p>
<ul>
<li><a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a></li>
<li><a href="https://crates.io/crates/csbindgen">crates.io/crates/csbindgen</a></li>
</ul>
<p>めちゃくちゃスムーズにネイティブコードがC#から呼べるようになります。すごい簡単に。超便利。こりゃもうばんばんネイティブコード書きたくなりますね……！ただし書くコードはRustのみ対応です。いや、別にRustでいいでしょ、Rustはいいぞ……！</p>
<p>しかしまず前提として言っておくと、ネイティブコードは別に偉くもなければ、必ず速いというわけでもないので、極力書くのはやめましょう。C#で書くべき、です。高速なコードが欲しければ、ネイティブコードに手を出す前にC#で速くすることを試みたほうがずっと良いです。C#は十分高速に書くことのできる言語です！ネイティブコードを書くべきでない理由は山ほどありますが、私的に最大の避けたい理由はクロスプラットフォームビルドで、今の世の中、ターゲットにしなければならないプラットフォーム/アーキテクチャの組み合わせは、普通にやっていても10を超えてしまいます。win/linux/osx/iOS/Android x x86/x64/arm。C#では .NET のランタイムやUnityが面倒見てくれますが、ネイティブコードの場合はこれを自前で面倒みていく必要があります。そこそこ面倒みてくれるはずのUnityだって辛いのに、それにプラスして俺々ビルド生態系を加えるのはかなり厳しいものがある。</p>
<p>とはいえ、C#をメインに据えつつもネイティブコードを利用すべきシチュエーションもあるにはあります。</p>
<ul>
<li>Android NDKや .NET unmanaged hosting APIなど、ネイティブAPIしか提供されていないものを使いたい場合</li>
<li>C で作られているネイティブライブラリを利用したい場合</li>
<li>ランタイムのライブラリの利用を避けたい場合、例えばUnityで .NET のSocket(Unityの場合 .NET のランタイムが古いのでパフォーマンスを出しにくい)を避けてネイティブのネットワークコードを書くのには一定の道理がある</li>
</ul>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/core/deploying/native-aot/">NativeAOT</a>という解決策もなくはないですが、まだそんなに現実的でもなければ、用途的にもこういうシチュエーションでは限定的でもあるので、そこは素直にネイティブコードを書いていくべき、でしょう。</p>
<p>そこでの最初の選択肢は当然C++なわけですが、いやー、C++のクロスプラットフォームビルドは大変だしなあ。となると、最近評判を聞く<a href="https://ziglang.org/ja/">Zig</a>はどうだろうか、と試してみました、が、撤退。目指すコンセプトは大変共感するところがあるのですが(FFIなしのCライブラリとの統合や、安全だけど複雑さを抑えた文法など)、まだ、完成度が、かなり、厳しい……。</p>
<p>で、最後の選択肢が<a href="https://www.rust-lang.org/ja">Rust</a>でした。FFIなしでの呼び出しではないものの<a href="https://crates.io/crates/cc">cc crate</a>や<a href="https://crates.io/crates/cmake">cmake crate</a>といったライブラリを使うと自然に統合されるし、<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>によるバインディングの自動生成はよく使われているだけあってめっちゃ安定して簡単に生成できます。ていうかZigが全然安定感なかった（シームレスなCとの統合とは……）ので雲泥の差でびっくりした。開発環境もまぁまぁ充実してるしコマンド体系も現代的。クロスプラットフォームビルドも容易！そして難しいと評判で避けていた言語面でも、いや、全然いいね。仕組みが理屈で納得できるし、C#とは文法面でもあまり離れていないので、全然すんなりと入れました。もちろん難しいところも多々ありますが、ラーニングカーブはそんなに急ではない、少なくとも最近のモダンC#をやり込んでる人なら全然大丈夫でしょう……！</p>
<p>と、いうわけで、しかし主な用途はC#からの利用で、特にCライブラリの取り込みにRustを使おうと決めたわけですが、C#に対して公開するためのコードが膨大でキツかったので、自動化したかったんですね。DllImportの自動化は<a href="https://www.swig.org/">SWIG</a>や<a href="https://github.com/mono/CppSharp">CppSharp</a>というのもありますが、普通のC++をそのまま持ってこようとする思想は、複雑なコードを吐いてしまったりで正直イマイチだな、と。</p>
<p>csbindgenは、まず、面倒なところをRustのbindgenに丸投げです。複雑なC(C++)のコードを解析対処にするから複雑になるのであって、bindgenによって綺麗なRustに整形してもらって、生成対象にするのはそうしたFFI向けに整理されたRustのみを対象にすることで、精度と生成コードの単純さを担保しました。自分でネイティブコードを書く場合も、RustはFFI不可能な型を公開しようとすると警告も出してくれるので、必然的に生成しやすい綺麗なコードになっています。型もRustは非常に整理されているため、C#とマッピングしやすくなっています。C#もまた近年のnintや<code>delegate*</code>、.NET 6からの<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.clong">CLong</a>などの追加によって自然なやり取りができるようになりました。csbindgenはそれら最新の言語機能を反映することで、自然で、かつパフォーマンスの良いバインディングコードを生成しています。</p>
<h2>Getting Started</h2>
<p>コンフィグにビルド時依存に追加してもらって、<code>build.rs</code>というコンパイル前呼び出し(Rustのコードでpre-build書ける機能やビルド時依存を追加できる機能はとても良い)に設定を入れるだけです、簡単！</p>
<pre data-pagefind-ignore="all"><code class="language-toml">[build-dependencies]
csbindgen = &quot;1.2.0&quot;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-rust">// extern &quot;C&quot; fnが書かれているlib.rsを読み取って DllImport[&quot;nativelib&quot;]なコードを&quot;NativeMethods.g.cs&quot;に出力する
csbindgen::Builder::default()
    .input_extern_file(&quot;lib.rs&quot;)
    .csharp_dll_name(&quot;nativelib&quot;)
    .generate_csharp_file(&quot;../dotnet/NativeMethods.g.cs&quot;)
    .unwrap();
</code></pre>
<p>単純なコードを例に出すと、このx, yを受け取ってintを返す関数は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">#[no_mangle]
pub extern &quot;C&quot; fn my_add(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>こういったC#コードを生成します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// NativeMethods.g.cs
using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;nativelib&quot;;

        [DllImport(__DllName, EntryPoint = &quot;my_add&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int my_add(int x, int y);
    }
}
</code></pre>
<p>直感的で単純な出力です、逆にそれがいい、むしろそれがいい。生成に対応している型はプリミティブ以外にもstructやunion、enum、関数やポインターなどRustのFFIで流せる型のほとんどには対応しています。</p>
<p>また、Rustのbindgenやcc/cmake crateを併用すると、CのライブラリをC#に簡単に持ちこむことができます。例えば圧縮ライブラリの<a href="https://github.com/lz4/lz4">lz4</a>は、csbindgenでの生成の前にbindgenとccの設定も足してあげると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// lz4.h を読み込んで lz4.rs にRust用のbindingコードを出力する
bindgen::Builder::default()
    .header(&quot;c/lz4/lz4.h&quot;)
    .generate().unwrap()
    .write_to_file(&quot;lz4.rs&quot;).unwrap();

// cc(C Compiler)によってlz4.cを読み込んでコンパイルしてリンクする
cc::Build::new().file(&quot;lz4.c&quot;).compile(&quot;lz4&quot;);

// bindgenの吐いたコードを読み込んでcsファイルを出力する
csbindgen::Builder::default()
    .input_bindgen_file(&quot;lz4.rs&quot;)
    .rust_file_header(&quot;use super::lz4::*;&quot;)
    .csharp_entry_point_prefix(&quot;csbindgen_&quot;)
    .csharp_dll_name(&quot;liblz4&quot;)
    .generate_to_file(&quot;lz4_ffi.rs&quot;, &quot;../dotnet/NativeMethods.lz4.g.cs&quot;)
    .unwrap();
</code></pre>
<p>これでC#から呼び出せるコードが簡単に生成できます。ビルドもRustで <code>cargo build</code> するだけでCのコードがリンクされてDLLに含まれています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// NativeMethods.lz4.g.cs

using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;liblz4&quot;;

        [DllImport(__DllName, EntryPoint = &quot;csbindgen_LZ4_compress_default&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int LZ4_compress_default(byte* src, byte* dst, int srcSize, int dstCapacity);

        // snip...
    }
}
</code></pre>
<p>試してもらうと、本当に簡単にCライブラリが持ち込みができて感動します。Rustやbindgenがとにかく偉い。</p>
<p>csbindgenはUnityでの利用も念頭においているので、よくあるiOSでのIL2CPPだけ __Internal にしたいみたいなシチュエーションでも</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">#if UNITY_IOS &amp;&amp; !UNITY_EDITOR
    const string __DllName = &quot;__Internal&quot;;
#else
    const string __DllName = &quot;nativelib&quot;;
#endif
</code></pre>
<p>といったような生成ルールの変更がコンフィグに含めてあります。とても実用的で気が利いてます。</p>
<h2>LibraryImport vs DllImport</h2>
<p>.NET 7から<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke-source-generation">LibraryImport</a>という新しい呼び出しのためのソースジェネレーターが追加されました。これはDllImportのラッパーになっていて、DllImportは、本来ネイティブコードとやり取りできない型(例えば配列や文字列などの参照型はC#のヒープ上に存在するもので、ネイティブ側に渡せない)を裏で自動的にやってくれるという余計なお世話が含まれていて、それがややこしさや性能面、そしてNativeAOTビリティの欠如などの問題を含んでいたので、そういう型が渡された場合はLibraryImportの生成するC#コードで吸収した上で、byte* としてDllImportに渡すようなラッパーが生成されるようになっています。</p>
<p>つまり余計なお世話をする本来ネイティブコードとやり取りできない型を生成しないようにすればDllImportでも何の問題もないので、今回はDllImportでの生成を選んでいます。そのほうがUnityでも使いやすいし。</p>
<p>Win32のAPIをDllImportで簡単に呼び出せるようにするために暗黙的な自動変換を多数用意しておく、というのは時代背景的には理解できます。C#がWindowsのためだけの言語であり、時折Win32 APIの呼び出しが必須なこともあったのは事実であり、便利な側面もあったでしょう。しかし現在はWindowsのためだけの言語でもなく、またWin32 APIの呼び出しに関しては<a href="https://github.com/microsoft/CsWin32">CsWin32</a>というSource Generatorを活用した支援も存在します。</p>
<p>もう現代では、そうしたDllImportの古い設計を引きずって考える必要はない、頼るべきではないでしょう。つまり参照型を渡したり[In]や[Out]は使うべきではないし、変換を考慮した設計を練る必要もありません。実際 .NET 7ではそうしたDllImportの機能を使うとエラーにする<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.disableruntimemarshallingattribute">DisableRuntimeMarshallingAttribute</a>が追加されました。</p>
<p>ポインターに関しても今はあまり忌避するものではないと思っています。そもそもネイティブとの通信はunsafeだし、Spanによって比較的使いやすい型に変換することも容易なので。中途半端に隠蔽するぐらいなら、DllImportするレイヤーではポインターはポインターとして持っておきましょう。C#として使いやすくするのは、その外側できっちりやればいい話です、DllImportで吸収するものではない。というのが今風の設計思想であると考えています。なんだったら私はIntPtrよりvoid*のほうが好きだよ。</p>
<h2>コールバックの相互受け渡し</h2>
<p>C# -&gt; Rust あるいは Rust -&gt; C# でコールバックを渡し合ってみましょう。まずRust側はこんな風に書くとします。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn csharp_to_rust(cb: extern &quot;C&quot; fn(x: i32, y: i32) -&gt; i32) {
    let sum = cb(10, 20); // invoke C# method
    println!(&quot;{sum}&quot;);
}

#[no_mangle]
pub extern &quot;C&quot; fn rust_to_csharp() -&gt; extern fn(x: i32, y: i32) -&gt; i32 {
    sum // return rust method
}

extern &quot;C&quot; fn sum(x:i32, y:i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>C#のメソッドを受け取ったら、それを読んで表示(println)するだけ、あるいは足し算する関数をC#に渡すだけ、のシンプルなメソッドです。生成コードは以下のようなものになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(delegate* unmanaged[Cdecl]&lt;int, int, int&gt; cb);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern delegate* unmanaged[Cdecl]&lt;int, int, int&gt; rust_to_csharp();
</code></pre>
<p><code>delegate* unmanaged[Cdecl]&lt;int, int, int&gt;</code> というのは、あまり見慣れない定義だと思うのですが、C# 9.0から追加された本物の<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers">関数ポインター</a>になります。定義を手書きするのは少しややこしいですが、自動生成されるので特に問題なしでしょう（？）。使い勝手はかなりよく、普通の静的メソッドのように扱えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ネイティブ側に渡したい静的メソッドはUnmanagedCallersOnlyを付ける必要がある
[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
static int Sum(int x, int y) =&gt; x + y;

// &amp;で関数ポインターを取得して渡す
NativeMethods.csharp_to_rust(&amp;Sum);

// Rustからdelegate*を受け取る
var f = NativeMethods.rust_to_csharp();

// 受け取った関数ポインターは普通に呼び出せる
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>インスタンスメソッドを渡せないのか？というと渡せません。Cとの相互運用にそんなものはない。どうでもいい勝手な変換はしなくていい。第一引数にコンテキスト(void*)を受け取るコードを用意しておけばいいでしょう。</p>
<p>ところで、UnityもC# 9.0対応、しているし関数ポインターも使えるには使えるのですが、<a href="https://docs.unity3d.com/ja/2021.3/Manual/CSharpCompiler.html">Extensible calling conventions for unmanaged function pointers is not supported</a>です。UnmanagedCallersOnlyAttributeもないしね。Unity Editor上では普通に動いちゃったりとかしますが、IL2CPPでは動かないのでちゃんと対応しましょう。csbindgenでは <code>csharp_use_function_pointer(false)</code> というオプションを設定すると、従来のデリゲートを使用したコードを出力します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// csharp_use_function_pointer(false) の場合の出力結果、専用のデリゲートを一緒に吐き出すようになる
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int csharp_to_rust_cb_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(csharp_to_rust_cb_delegate cb);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int rust_to_csharp_return_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern rust_to_csharp_return_delegate rust_to_csharp();

// MonoPInvokeCallback属性を静的メソッドにつける(typeofでデリゲートを設定)
[MonoPInvokeCallback(typeof(NativeMethods.csharp_to_rust_cb_delegate))]
static int Sum(int x, int y) =&gt; x + y;

// そのまま渡す
NativeMethods.csharp_to_rust(Method);

// 受け取る関数ポインターに関しては .NET の場合と一緒
var f = NativeMethods.rust_to_csharp();
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>面倒くさい専用のデリゲートも同時に出力してくれるので、定義はそこそこ楽になります（Action/Funcといった汎用デリゲートを使うと場合によりクラッシュしてしまったので、必ずそれぞれのパラメーター専用のデリゲートを出力するようにしています）。概ねcsbindgenがよしなに動くように面倒見てあげるので、属性の違いだけ考えればほぼ問題はありません。</p>
<h2>コンテキスト</h2>
<p>多値返しみたいなのは、普通にStructを作ってくださいという話になって、その場合は、C#側でStructはコピーされて、Rust側のメモリからはすぐ消えるということになります。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn return_tuple() -&gt; MyTuple {
    MyTuple { is_foo: true, bar: 9999 }
}

#[repr(C)]
pub struct MyTuple {
    pub is_foo: bool,
    pub bar: i32,
}
</code></pre>
<p>もう少し寿命を長く、返却するStructをポインターで返して状態を持ちたい、という場合はRust的には少し工夫が必要です。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_context() -&gt; *mut Context {
    let ctx = Box::new(Context { foo: true });
    Box::into_raw(ctx)
}

#[no_mangle]
pub extern &quot;C&quot; fn delete_context(context: *mut Context) {
    unsafe { Box::from_raw(context) };
}

#[repr(C)]
pub struct Context {
    pub foo: bool,
    pub bar: i32,
    pub baz: u64
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// C#側、Context*を受け取って
var context = NativeMethods.create_context();

// なにか色々したりずっと持っていたり

// 最後に明示的にfreeしにいく
NativeMethods.delete_context(context);
</code></pre>
<p><code>Box::new</code> でヒープ上にデータを確保して、<code>Box::into_raw</code>でRust上でのメモリ管理から外します。Rustは通常だとスコープが外れると即座にメモリを返却する、のですが、寿命をRust管理外のC#に飛ばすので、素直に（？）unsafeにRust上の管理から外してしまうのが普通に素直でしょう。Rust側で確保しているメモリを開放する場合は、<code>Box::from_raw</code>でRust上の管理に戻します。そうするとスコープが外れたらメモリ返却という通常の動作をして、返却が完了します。</p>
<p>この辺はRustだから難しい！という話ではなく、C#でもfixedスコープを外れてポインタを管理したい場合には <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して手動でunsafeな管理しなければいけないので、完全に同じ話です。そう考えると、むしろ素直にC#と変わらない話でいいですね。</p>
<p>なお、C#上でこうしたコンテキストの管理をする場合に専用のSafeHandleを作って、それにラップするという流儀がありますが、大仰で、基本的にはそこまでやる必要はないと思ってます。No SafeHandle。そもそも境界越えというunsafeなことをしているのだから、最後まで自己責任でいいでしょう。</p>
<p>csbindgenは戻り値にstructが指定されていると、C#側にも同様のものを生成しに行ってしまいますが、Rust内だけで使うのでC#側には内容公開したくない、というか参照(Box)とかも含まれてるから公開できないし、みたいな場合もあると思います。その場合は <code>c_void</code> を返してください。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_counter_context() -&gt; *mut c_void {
    let ctx = Box::new(CounterContext {
        set: HashSet::new(),
    });
    Box::into_raw(ctx) as *mut c_void // voidで返す
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn insert_counter_context(context: *mut c_void, value: i32) {
    let mut counter = Box::from_raw(context as *mut CounterContext); // as で型を戻す
    counter.set.insert(value);
    Box::into_raw(counter); // contextを使い続ける場合はinto_rawを忘れないように
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn delete_counter_context(context: *mut c_void) {
    let counter = Box::from_raw(context as *mut CounterContext);
    for value in counter.set.iter() {
        println!(&quot;counter value: {}&quot;, value)
    }
}

// C#側には公開しない
pub struct CounterContext {
    pub set: HashSet&lt;i32&gt;,
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// C#側では ctx = void* として受け取る
var ctx = NativeMethods.create_counter_context();
    
NativeMethods.insert_counter_context(ctx, 10);
NativeMethods.insert_counter_context(ctx, 20);

NativeMethods.delete_counter_context(ctx);
</code></pre>
<p>この辺、<code>PhantomData&lt;T&gt;</code>を使って格好良く処理する手法も一応あるんですが、正直複雑になるだけなので、素直に <code>void*</code> ベースでやり取りする、に倒したほうがむしろ健全でいいのではと思っています。どっちにしろunsafeな処理してるんだから素直にunsafeな業を受け入れるべき！</p>
<h2>Stringと配列のマーシャリング</h2>
<p>Stringと配列は、C#とRustでそれぞれ構造が違うので、そのままやり取りはできません。ポインタと長さ、つまりC#でいうところのSpanのみがやり取りできます。Span的な処理をするだけならゼロコピーですが、Stringや配列に変換したくなったら、C#とRust、どちらの側でも新規のアロケーションが発生します。これはネイティブコードを導入することの弱みで、Pure C#で通したほうが融通が効く（或いはパフォーマンスに有利に働く）ポイントですね。まあ、ともあれ、つまり基本はSpanです。DllImport上でStringを受けたり配列を受けたりしてはいけません、その手の自動変換にゆだねてはダメ！アロケーションも自己責任で明示的に。</p>
<p>さて、まずは文字列ですが、こういったケースでやり取りする文字列の種類は3つ、UTF8とUTF16と<a href="https://ja.wikipedia.org/wiki/%E3%83%8C%E3%83%AB%E7%B5%82%E7%AB%AF%E6%96%87%E5%AD%97%E5%88%97">ヌル終端文字列</a>、です。UTF8はRustの文字列(RustのStringは<code>Vec&lt;u8&gt;</code>)、C#の文字列はUTF16、そしてCのライブラリなどはヌル終端文字列を返してくることがあります。</p>
<p>今回は例なので明示的にRust上でヌル終端文字列を返してみます。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_c_string() -&gt; *mut c_char {
    let str = CString::new(&quot;foo bar baz&quot;).unwrap();
    str.into_raw()
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_c_string(str: *mut c_char) {
    unsafe { CString::from_raw(str) };
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// null-terminated `byte*` or sbyte* can materialize by new String()
var cString = NativeMethods.alloc_c_string();
var str = new String((sbyte*)cString);
NativeMethods.free_c_string(cString);
</code></pre>
<p>C#上では new Stringでポインタ(<code>sbyte*</code>)を渡すとヌル終端を探してStringを作ってくれます。明示的にアロケーションしているという雰囲気がいいですね。ポインタはこの場合Rustで確保したメモリなので、C#のヒープ上にコピー（新規String作成）したなら、即返却してやりましょう。</p>
<p>Rustで確保したUTF8、byte[]、あるいはint[]などとにかく配列全般の話はもう少し複雑になってきます。Rustでの配列的なもの(<code>Vec&lt;T&gt;</code>)をC#に渡すにあたっては、ポインタと長さをC#に渡せばOKといえばOKなのですが、解放する時にそれだけだと困ります。<code>Vec&lt;T&gt;</code>の実態はポインタ、長さ、そしてキャパシティの3点セットになっているので、この3つを渡さなきゃいけないのですね。そして、都度3点セットを処理するのも面倒です、Rust的なメモリ管理を外したり戻したりの作業もあるし。</p>
<p>というわけでちょっと長くなりますが以下のようなユーティリティーを用意しましょう。これの元コードは(元)Rustの開発元であるMozillaのコードなので安全安心です……！</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[repr(C)]
pub struct ByteBuffer {
    ptr: *mut u8,
    length: i32,
    capacity: i32,
}

impl ByteBuffer {
    pub fn len(&amp;self) -&gt; usize {
        self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;)
    }

    pub fn from_vec(bytes: Vec&lt;u8&gt;) -&gt; Self {
        let length = i32::try_from(bytes.len()).expect(&quot;buffer length cannot fit into a i32.&quot;);
        let capacity = i32::try_from(bytes.capacity()).expect(&quot;buffer capacity cannot fit into a i32.&quot;);

        // keep memory until call delete
        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr(),
            length,
            capacity,
        }
    }

    pub fn from_vec_struct&lt;T: Sized&gt;(bytes: Vec&lt;T&gt;) -&gt; Self {
        let element_size = std::mem::size_of::&lt;T&gt;() as i32;

        let length = (bytes.len() as i32) * element_size;
        let capacity = (bytes.capacity() as i32) * element_size;

        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr() as *mut u8,
            length,
            capacity,
        }
    }

    pub fn destroy_into_vec(self) -&gt; Vec&lt;u8&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let capacity: usize = self.capacity.try_into().expect(&quot;buffer capacity negative or overflowed&quot;);
            let length: usize = self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;);

            unsafe { Vec::from_raw_parts(self.ptr, length, capacity) }
        }
    }

    pub fn destroy_into_vec_struct&lt;T: Sized&gt;(self) -&gt; Vec&lt;T&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let element_size = std::mem::size_of::&lt;T&gt;() as i32;
            let length = (self.length * element_size) as usize;
            let capacity = (self.capacity * element_size) as usize;

            unsafe { Vec::from_raw_parts(self.ptr as *mut T, length, capacity) }
        }
    }

    pub fn destroy(self) {
        drop(self.destroy_into_vec());
    }
}
</code></pre>
<p>Box::into_raw/from_rawのVec版という感じで、from_vecしたタイミングでメモリ管理から外すのと、destroy_into_vecするとメモリ管理を呼び側に戻す（何もしなければスコープを抜けて破棄される）といったような動作になっています。これはC#側でも(csbindgenによって)定義が生成されているので、メソッドを追加してやります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// C# side span utility
partial struct ByteBuffer
{
    public unsafe Span&lt;byte&gt; AsSpan()
    {
        return new Span&lt;byte&gt;(ptr, length);
    }

    public unsafe Span&lt;T&gt; AsSpan&lt;T&gt;()
    {
        return MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;T&gt;(ptr), length / Unsafe.SizeOf&lt;T&gt;());
    }
}
</code></pre>
<p>これでByteBuffer*で受け取ったものを即Spanに変換できるようになりました！というわけで、Rust上の通常のstring、byte[]、それとint[]の例を見てみると</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_string() -&gt; *mut ByteBuffer {
    let str = format!(&quot;foo bar baz&quot;);
    let buf = ByteBuffer::from_vec(str.into_bytes());
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_string(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need String, use String::from_utf8_unchecked(buf.destroy_into_vec()) instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;u8&gt; = vec![1, 10, 100];
    let buf = ByteBuffer::from_vec(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;u8&gt;, use buf.destroy_into_vec() instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_i32_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;i32&gt; = vec![1, 10, 100, 1000, 10000];
    let buf = ByteBuffer::from_vec_struct(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_i32_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;i32&gt;, use buf.destroy_into_vec_struct::&lt;i32&gt;() instead.
    buf.destroy();
}
</code></pre>
<p>ByteBuffer自体の管理を外す(into_raw)が必要なのと、from_rawで戻したあとの中身のByteBufferもdestoryかinto_vecしなきゃいけないという、入れ子の管理になっているというのが紛らわしくて死にそうになりますが、ソウイウモノということで諦めましょう……。Drop traitを実装しておくことでクリーンナップ側の処理はもう少しいい感じにできる余地がありますが、Drop traitを実装しないことの理由もそれなりにある（と、Mozillaが言っている）ので、トレードオフになっています。</p>
<p>C#側では、とりあえずAsSpanして、あとはよしなにするという感じですね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var u8String = NativeMethods.alloc_u8_string();
var u8Buffer = NativeMethods.alloc_u8_buffer();
var i32Buffer = NativeMethods.alloc_i32_buffer();
try
{
    var str = Encoding.UTF8.GetString(u8String-&gt;AsSpan());
    Console.WriteLine(str);

    Console.WriteLine(&quot;----&quot;);

    var buffer = u8Buffer-&gt;AsSpan();
    foreach (var item in buffer)
    {
        Console.WriteLine(item);
    }

    Console.WriteLine(&quot;----&quot;);

    var i32Span = i32Buffer-&gt;AsSpan&lt;int&gt;();
    foreach (var item in i32Span)
    {
        Console.WriteLine(item);
    }
}
finally
{
    NativeMethods.free_u8_string(u8String);
    NativeMethods.free_u8_buffer(u8Buffer);
    NativeMethods.free_i32_buffer(i32Buffer);
}
</code></pre>
<p>Rust側で確保したメモリはRust側で解放する！という基本に関しては忠実に守っていきましょう。この例だとC#側で処理したら即解放なので、いい感じにしてくれよ、なんだったらDllImportで暗黙的に自動処理最高、みたいな気になるかもしれませんが、もう少し長寿命で持つケースもあるので、やはりマニュアルでちゃんと解放していきましょう。ていうか暗黙的なアロケーションは一番最悪じゃないです？？？</p>
<p>最後に、C#で確保したメモリをRust側で使う場合の例をどうぞ。</p>
<pre data-pagefind-ignore="all"><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_string(utf16_str: *const u16, utf16_len: i32) {
    let slice = std::slice::from_raw_parts(utf16_str, utf16_len as usize);
    let str = String::from_utf16(slice).unwrap();
    println!(&quot;{}&quot;, str);
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_utf8(utf8_str: *const u8, utf8_len: i32) {
    let slice = std::slice::from_raw_parts(utf8_str, utf8_len as usize);
    let str = String::from_utf8_unchecked(slice.to_vec());
    println!(&quot;{}&quot;, str);
}


#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_bytes(bytes: *const u8, len: i32) {
    let slice = std::slice::from_raw_parts(bytes, len as usize);
    let vec = slice.to_vec();
    println!(&quot;{:?}&quot;, vec);
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var str = &quot;foobarbaz:あいうえお&quot;; // JPN(Unicode)
fixed (char* p = str)
{
    NativeMethods.csharp_to_rust_string((ushort*)p, str.Length);
}

var str2 = Encoding.UTF8.GetBytes(&quot;あいうえお:foobarbaz&quot;);
fixed (byte* p = str2)
{
    NativeMethods.csharp_to_rust_utf8(p, str2.Length);
}

var bytes = new byte[] { 1, 10, 100, 255 };
fixed (byte* p = bytes)
{
    NativeMethods.csharp_to_rust_bytes(p, bytes.Length);
}
</code></pre>
<p>std::slice::from_raw_partsでSliceを作って、あとはよしなに処理したいことをします。関数を超えて長い寿命を持たせたいならコピー(String作りなりVec作るなり)は必須になってきます。Rust側で確保したメモリはRust側で解放する、のと同じように、C#側で確保したメモリはC#側で解放する、のが重要です。C#の場合はfixedスコープを抜けて参照を持っていない場合は、そのうちGCが処理してくれるでしょう、といった話ですね。</p>
<p>なお、fixedを超えてC#でもう少し長い寿命で持ち回したいときは <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して持ち回します。</p>
<h2>Rust for C# Developer</h2>
<p>Rustは、正直すごい気に入ってます。C#の次に気に入りました……！まぁ正直、これで全部やる、Webもなにもかも作る、みたいなのはヤバいかな、と思います。RustでWebやりたいって人はあれでしょ、型がついてて開発環境が充実していてエコシステムが回ってる言語がいいんでしょ？ちょうどいい言語があるんですよ、C#という。……。ではあるんですが、ネイティブが必要って局面で、やりたくないーって逃げたり、NativeAOTがなんとかしてくれるだのといった現実逃避したりせず、ちゃんと正面から向き合えるようになったということはいいことです。</p>
<p>で、実際RustはかなりC#erに馴染む道具だと思っていて、そもそもインターフェイスがないかわりにstructとジェネリクスとtrait(インターフェイスみたいなやつ)で処理するってのは、別にそれC#でもやってますよ！C#のパフォーマンス最速パターンってstructにインターフェイス実装してジェネリクスの型制約でインターフェイス指定してボクシング/仮想メソッド呼び出し回避でstruct投げ込むことですからね。ようはC#の最速パターンだけが強制されてるんだと思えば何も違和感がない。</p>
<p>インスタンスメソッドがないかわりに全部拡張メソッドみたいな雰囲気なのも、いやー、C#も、もはやインスタンスメソッドと拡張メソッド、どっちで実装すればいいかなーって切り分けに悩むこともあるし、<a href="https://ufcpp.net/blog/2023/3/extensions/">C# 12候補のExtensions</a>なんてきたら完全にどこで実装すりゃいいのかわからんわ、ってなるので、拡張メソッド一択(impl, trait)ですよ、みたいなのはすっきり整理されていて逆にいい。</p>
<p>シンタックスも自然というかC系の多数派に寄り添った感じで親しみやすいし、ドットでメソッド繋げていくので、馴染み深いオブジェクト指向的な手触りが十分ある。それとミュータブルに寛容なところがいいですね。関数型にありがちなイミュータブル至上主義ではなく、どちらかというとメモリそこにあるんだからミュータブルやろ、みたいな雰囲気なのがとてもいい。無駄もないし。所有権周りが厳密なのでミュータブルであっても固めな手応えなのは、これでいいんだよというかこれで的な何かではある。</p>
<p>マクロはコンパイル時ExpresionTreeみたいなもので、proc-macroはSource Generatorみたいなものなので、何が可能になるかすぐに理解できるし、便利さもよくわかる。ていうかコンパイル時ExpressionTreeはC#にも欲しい（実行時だからコスト重いのであんま使わないのでコンパイル時に解決するならもっとばんばん使えるはずなんだよねえ）。ただ、自由度がとても高いせいでマクロに入ると入力補完が完全に効かなくなる。そして自由度が高いのでマクロでDSL的な流れに高級ライブラリほどなりがちで、完全にマニュアル引きが必要になってくるのが、見た目はキレイにおさまるけど書き味はよくないな、的な体感になるのがもったいない。その点でいうとC#はやっぱ入力補完最優先な言語で、一貫した安定感を提供しているのはとても良いですね。</p>
<p>キツいかなーと思うのは所有権がどうとかっていうよりも、ジェネリクスの見た目がキツい。C#だったらインターフェイスで動的ディスパッチで整理されているものが、ジェネリクスで静的ディスパッチに倒れているのでジェネリクスの出現率がめっちゃ高い。いや、だってC#でもジェネリクスでると読みやすさ的には一段落下がるわけじゃないですか、それが当たり前って感じだと、慣れとかって問題じゃなく見やすさレベルは下がる。更にその上にジェネリクスがネストするのが当たり前。C#だったらジェネリクスがネストしてるのは見やすさレベル最底辺なので極力出現しないようにしたいって感じなのですが、Rustだと日常茶飯事に出てくる。<code>Option&lt;Rc&lt;RefCell&lt;_&gt;&gt;&gt;</code>とかも全然普通に出現するのが、うーむ。理屈では納得いくから特に文句があるようでなにもないんですが。</p>
<p>なんだったらパターンマッチも別に好きじゃないしOptionもResultも好きじゃないしnullの何が悪いんだよぐらいの気持ちにならなくもないんですが、まぁそれはそれ。でも全体的には凄い良いですね、ほんと。</p>
<h2>まとめ</h2>
<p>ところで<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>のReadMeのほうには更にもっといっぱい変換パターンを紹介していますので、是非そちらもチェックしてみてください。</p>
<p>ネイティブ呼び出しは定義の部分でも、二重定義がそもそもダルいうえに、かなり気を使わなきゃいけないことがなにげに多くて割と大変というか知識量と単純作業量を要求してくるのですが、csbindgenはその部分を完全自動化してくれます。自分でも使っててネイティブコードめっちゃ楽……！という気になります。事実楽。すごい。その後のメモリ管理に関しては、そこはまぁ思う存分悩んでくれという話になるのですが、もはや複雑な点がそれだけに落ち着いたという点では、やはり革命的に便利なのでは？という気になります。</p>
<p>Cのライブラリを持ってくるのも圧倒的に楽なので、私の中でもちょっと考え方が変わってきました。今までは割とPure C#実装至上主義、みたいなところがあったんですが、うまい切り分け、使い分けみたいなのを考えられるようになりました。そして、Cライブラリ利用がより自由になると、まさに<a href="https://cysharp.co.jp/">Cysharp</a>の掲げる「C#の可能性を切り開いていく」ことにまた一つ繋がってしまったな、と。</p>
<p>まずはこの後に数個、csbindgenを活用したC#ライブラリを提供する予定があります！のですが、その前に、Rustかー、とは思わずに是非csbindgen、試してみてもらえると嬉しいです。</p>
</div>
<h1 data-pagefind-sort="date:2023-01-30" data-pagefind-meta="published:2023-01-30"><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></h1>
<ul class="date"><li>2023-01-30</li></ul>
<div class="entry_body"><p>ついこないだの<a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a>は、SoAになってるとSIMDを適用しやすいよ、という話だったのですが、そもそもSIMD手書きはカジュアルにやらないし、気合い入れてSIMD書くシチュエーションなら構造も気合い入れて専用に設計するよなぁ。と、なると、カジュアルにSIMD使えるライブラリが必要で、まぁLINQですね、と。</p>
<ul>
<li><a href="https://github.com/Cysharp/SimdLinq">Cysharp/SimdLinq</a></li>
</ul>
<p>これを入れると別にSoA関係なく、SIMDが適用できる状態(例えばint[]にSum)だと、自動的にSIMDが適用されるようになります。そして、実際めちゃくちゃ速い。</p>
<p><img src="https://user-images.githubusercontent.com/46207/215410106-b68d8567-5abf-4aa4-a050-a803b1913187.png" alt="" /></p>
<p>SIMDとLINQの組み合わせが威力を発揮するというのは、別に新しいことではなく、そもそも .NET 7でも<a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#linq">Performance Improvements in .NET 7 LINQ</a>で、幾つかのメソッドが内部でSIMD化されて高速化されていることが発表されています。しかし、 .NET 7のSIMD対応は非常に限定的なもので、具体的には<code>int[]</code>の<code>Average</code>,<code>Min</code>,<code>Max</code>、それと<code>long[]</code>の<code>Min</code>,<code>Max</code>だけです。これには理由はなくはないのですが、本来SIMD対応できる範囲はもっと広いため、これでは非常にもったいない。</p>
<p>SimdLinqを適用できるメソッドは <code>Sum</code>, <code>Average</code>, <code>Min</code>, <code>Max</code>, <code>MinMax</code>, <code>Contains</code>, <code>SequenceEqual</code>、要素の型は <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code> int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code>、コレクションの型は <code>T[]</code>, <code>List&lt;T&gt;</code>, <code>Span&lt;T&gt;</code>, <code>ReadOnlySpan&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, <code>ReadOnlyMemory&lt;T&gt;</code> と理屈上SIMD化できるものを全て詰め込みました。特に<code>Span&lt;T&gt;</code>/<code>ReadOnlySpan&lt;T&gt;</code>は通常のLINQでは使えない（メソッドが定義されていない）ので、有益です。また、Min, Maxを同時に取得する<code>MinMax</code>というメソッドを独自に追加しています。</p>
<p>専用メソッドを呼ばせる（例えば<code>SumSimd()</code>とか)ようでは使いにくいと思ったので、現在のコードを何も弄らずとも、ライブラリ参照してglobal usingを設定すれば、全ての適用可能なメソッドに自動適用される仕組みにしました。これは同名メソッドを定義して、具象型のほうにオーバーロード解決が優先採用されることを利用しています。</p>
<h2>使い方</h2>
<p>なので、使い方もなにもなく、usingすれば勝手にSimdLinqになって高速化されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using SimdLinq; // enable SimdLinq extension methods

var array = Enumerable.Range(1, 100000).ToArray();

var sum = array.Sum(); // used SimdLinqExtensions.Sum
</code></pre>
<p>using忘れちゃうというのはあるので、そこでglobal usingです。csprojに</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Using Include=&quot;SimdLinq&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>というのを仕込んでやれば、SimdLinqが使える場合はSimdLinqに、そうじゃないものは普通のLinqでオーバーロードが解決されるようになります。便利。</p>
<p>具体的にSimdLinqが適用されるメソッドは以下のものになります。</p>
<ul>
<li><code>Sum</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>LongSum</code> for <code>int</code>, <code>uint</code></li>
<li><code>Average</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Min</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Max</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>MinMax</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Contains</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>SequenceEqual</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
</ul>
<h2>互換性と安全性</h2>
<p>.NET 7の標準に、このSimdLinqのようなアグレッシブなSIMD化が入らなかった理由は、互換性と安全性になります。え、安全じゃないの？というと怖くなるので、何が違うのかはしっかり把握しておきましょう。別に危険、というわけではないですが。</p>
<p>まずSumとAverage(Averageの中身はSumしたのをLengthで割るだけなので中身は実質Sum)ですが、LINQのSumはcheckedで、オーバーフローすると例外を吐きます。SimdLinqはuncheckedです、つまりオーバーフローするとそのままオーバーフローしたまま結果を返します。checkedのほうが挙動としてはいいんですが、SIMD演算がオーバーフローのチェックできないので、SimdLinqではuncheckedとして提供しています。オーバーフローに関しては自己責任で。さすがにbyteのSumとかだとすぐオーバーフローしちゃうので、SimdLinqのSumは32 bit以上の要素にだけ提供しています、つまり<code>int</code>, <code>long</code>, <code>uint</code>, <code>ulong</code>, <code>double</code>, <code>float</code> です。そもそも元々のLINQのSum(引数なし)も<code>int</code>からなので、その辺は一緒ということで。</p>
<p>そうしたオーバーフローの危険性を避けたい場合、独自拡張として <code>LongSum</code> というlongを戻り値にするSumメソッドを追加しています。内部的にlongで処理するため、(若干性能は落ちますが)オーバーフローしなくなります。</p>
<p>float/doubleの扱いは挙動の違いが若干あります。まず、通常のLINQのMin, Maxは<code>NaN</code>をチェックしますがSimdLinqは<code>NaN</code>をチェックしません。<code>NaN</code>チェックがあったほうが丁寧ですが、SIMDでそれは入れずらい＆NaNが入ってくるケースってあまりないので現実的にすごい問題か、というとそうではないかな、と。</p>
<p>それとSumの場合に足し算の順序が変わって(LINQは前から順番に足しますが、SIMDだと並列に足すので)、浮動小数点演算だと足す順序が変わると微妙に誤差が出て同じ結果になりません。例えばLINQだと<code>1.5710588F</code>だけどSimdLinqだと<code>1.5710589F</code>になる、といったような違いが出てきます。結果としては別にどっちでも良い（ある意味で別にどっちも厳密にはあってない）と思いますが、結果の互換性がないですよ、ということは留意してください。</p>
<h2>まとめ</h2>
<p>高速なLINQのAlternativeって、結構あります。<a href="https://github.com/kevin-montrose/LinqAF">LinqAF</a>、<a href="https://github.com/jackmott/LinqFaster">LinqFaster</a>、<a href="https://github.com/NetFabric/NetFabric.Hyperlinq">NetFabric.Hyperlinq</a>など。ただ、どれも大仰なんですよね、StructのIteratorを作ってー、とか。専用メソッドを呼ぶためにラップするのも手間だし、その割に凄い効果的というほどでもないから、依存を増やす割にはメリットも薄くなので、私自身は使おうとはあまり思ってませんでした。</p>
<p>そこでSimdLinqではLINQ全体を高速化させることを狙っているわけではなくて、SIMDが適用できるものだけピンポイントに、そしてソースコードには一切手を入れる必要のない&quot;Drop-in replacement&quot;になるようにデザインしました。また、SIMDのみに絞ったことで性能面に明らかに圧倒的な差をだして、あえて使う理由を作る、といったところですね。</p>
<p>ついでにそうなると欲張ってどんどん適用できる箇所を増やしたい、つまりは<a href="https://github.com/Cysharp/StructureOfArraysGenerator">StructureOfArraysGenerator</a>だ、みたいなコンボも狙っています。エコシステム囲い込み！囲い込みはEvil！</p>
<p>そんなわけでSIMDシリーズ第一弾でした。今年はSIMD関連も幾つか出していくかもしれませんし、Source Generatorネタがめちゃくちゃ溜まってるので時間が無限大に必要です。まぁ、ともかくまずはSimdLinqを使って見てください！</p>
</div>
<h1 data-pagefind-sort="date:2023-01-27" data-pagefind-meta="published:2023-01-27"><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></h1>
<ul class="date"><li>2023-01-27</li></ul>
<div class="entry_body"><p>最近はSource Generatorブームが続いていて、去年末に<a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a>という記事を出しましたが、まずは今年第一弾のSource Generatorライブラリです。</p>
<ul>
<li><a href="https://github.com/Cysharp/StructureOfArraysGenerator/">github.com/Cysharp/StructureOfArraysGenerator</a></li>
</ul>
<p>これは何かというと、structure of arrays(SoA)を使いやすくするためのコードを生成するというものです。まずそもそもSoAですが、Wikipediaの<a href="https://en.wikipedia.org/wiki/AoS_and_SoA">AoS and SoA</a>という記事によるところ（日本語版はない）、CPUキャッシュを有効活用したりSIMDを適用させやすくなる構造だよ、と。通常C#の配列はarray of structures(AoS)になります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png" alt="" /></p>
<p>上の通常の配列がAoSでXYZXYZXYZXYZといったように並んでいる構造ですが、下のStructureOfArraysGeneratorで生成したSoAの配列はXXXXYYYYZZZZという並び順になります。実際にシンプルなパフォーマンステスト（Vector3[10000]に対してYの最大値を求める）によるところ</p>
<p><img src="https://user-images.githubusercontent.com/46207/215027253-6f94739f-b827-46ba-a395-690d1df89d46.png" alt="" /></p>
<p>そのまま書いても2倍、SIMDで書きやすい状態なのでSIMDで処理してしまえば10倍高速化されます。というわけで、パフォーマンスが求められるシチュエーションで非常に有用です。</p>
<p>このライブラリはZigという最近、日本でも注目されている言語（Node.jsの高速な代替として注目されている<a href="https://bun.sh/">Bun</a>の実装言語）のMultiArrayListにインスパイアされました。Zigの作者 Andrew Kelley氏が講演した <a href="https://vimeo.com/649009599">A Practical Guide to Applying Data-Oriented Design</a> という素晴らしい講演があるので是非見て欲しいのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/215052372-1ab33bd2-a578-4c26-8e99-7615a49707ea.png" alt="image" /></p>
<p>データ指向設計(Data-Oriented Design)はパフォーマンスを飛躍的に改善する魔法なのです。ん、それはどこかで聞いたような……？そう、<a href="https://unity.com/ja/dots">UnityのDOTS</a>です。Data-Oriented Technology Stackです。ECSです。……。まぁ、そんなわけで全体に導入するにはそうとうガラッと設計を変える必要があるので大変厳しくはあるのですが、講演での実例としてZig自身のコンパイラの事例が出てますが、まぁつまりは徹底的にやれば成果は出ます。</p>
<p>しかしまぁ徹底的にやらず部分的に使っても効果があるのはUnityで Job System + Burst ぐらいでいいじゃん、という気持ちになっていることからも明らかです。というわけで部分的なSoA構造の導入にお使いください、かつ、導入や利用の敷居は全然高くないように設計しました。</p>
<h2>MultiArray</h2>
<p>NuGetからインストール（Unityの場合はgit参照か.unitypackageで）するとAnalyzerとして参照されます。StructureOfArraysGeneratorは属性も含めて依存はなく全てのコードが生成コードに含まれる（属性はinternal attributeとして吐かれる）ので、不要なライブラリ依存が増えることはありません。</p>
<p><code>[MultiArray(Type)]</code>を配列的に使いたい<code>readonly partial struct</code>につけます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using StructureOfArraysGenerator;

[MultiArray(typeof(Vector3))]
public readonly partial struct Vector3MultiArray
{
}
</code></pre>
<p>するとSource Generatorは内部的にはこういうコードを生成します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">partial struct Vector3MultiArray
{
    // constructor
    public Vector3MultiArray(int length)

    // Span&lt;T&gt; properties for Vector3 each fields
    public Span&lt;float&gt; X =&gt; ...;
    public Span&lt;float&gt; Y =&gt; ...;
    public Span&lt;float&gt; Z =&gt; ...;

    // indexer
    public Vector3 this[int index] { get{} set{} }

    // foreach
    public Enumerator GetEnumerator()
}
</code></pre>
<p>Structure of <strong>Arrays</strong> と言ってますが、StructureOfArraysGeneratorは Arrays は生成しません。内部的には単一の <code>byte[]</code> と各開始地点のオフセットのみを持っていて、生成されるプロパティによって<code>Span&lt;T&gt;</code>のビューを返すという設計になっています。</p>
<p>使い方的には配列のように使えますが、<code>Span&lt;T&gt;</code>の操作、例えばref var item inによるforeachを使うと、より効率的に扱えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var array = new Vector3MultiArray(4);

array.X[0] = 10;
array[1] = new Vector3(1.1f, 2.2f, 3.3f);

// multiply Y
foreach (ref var item in v.Y)
{
    item *= 2;
}

// iterate Vector3
foreach (var item in array)
{
    Console.WriteLine($&quot;{item.X}, {item.Y}, {item.Z}&quot;);
}
</code></pre>
<p>Yに2倍を掛ける処理などは、メモリ領域が連続していることにより、<code>Vector3[]</code>を <code>item.Y *= 2</code> などとして書くよりも高速に処理されます．</p>
<p>他に<code>List&lt;T&gt;</code>のようにAddできる<code>MultiArrayList</code>や、内部的には<code>byte[]</code>を持っているだけであることを生かした<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での超高速なシリアライズなどにも対応しています。気になったら是非ReadMeのほうを見てください。</p>
<h2>.NET 7 時代のSIMD</h2>
<p>.NETはSIMD対応が進んでいて、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.x86">System.Runtime.Intrinsics.X86</a>によって、直接ハードウェア命令を書くことが出来ます。</p>
<p>しかし、しかしですね、最近は .NET を Arm で動かすことが現実的になってきました。iOSやAndroidでけはなくMacのArm化、そしてAWS GravitonのようなArmサーバーはコスト面でも有利で、選択肢に十分入ります。そこでAvx.Addなんて書いていたらArmで動きません。勿論 <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.arm">System.Runtime.Intrinsics.Arm</a> というクラスも公開されていて、Arm版のSIMDを手書きすることもできるんですが、分岐して似たようなものを二個書けというのか！という話です。</p>
<p>そこで、 <a href="https://zenn.dev/pcysl5edgo/articles/d3e787599c5c8b">.NET 7こそがC# SIMDプログラミングを始めるのに最適である理由</a> という記事があるのですが、確かに .NET 7 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256.loadunsafe">Vector256.LoadUnsafe</a> がまずめちゃくくちゃイイ！馴染みが深い（？）Unsafeによる ref var T で書けます！そして<a href="https://github.com/dotnet/runtime/issues/49397">Expose cross-platform helpers for Vector64, Vector128, and Vector256</a>により、<code>Vector64/128/256&lt;T&gt;</code>にプラットフォーム抽象化されたSIMD処理が書けるようになりました、やはり .NET 7から。</p>
<p>例えば .NET 7 でint[]のSumのSIMD化を書いてみます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var array = Enumerable.Range(1, 100).ToArray();

ref var begin = ref MemoryMarshal.GetArrayDataReference(array);
ref var last = ref Unsafe.Add(ref begin, array.Length);

var vectorSum = Vector256&lt;int&gt;.Zero;
ref var current = ref begin;

// Vector256で処理できるだけ処理
ref var to = ref Unsafe.Add(ref begin, array.Length - Vector256&lt;int&gt;.Count);
while (Unsafe.IsAddressLessThan(ref current, ref to))
{
    // 直接足し算できて便利
    vectorSum += Vector256.LoadUnsafe(ref current);
    current = ref Unsafe.Add(ref current, Vector256&lt;int&gt;.Count);
}

// Vector256をintに戻す
 var sum = Vector256.Sum(vectorSum);

// 残りの分は単純処理
while (Unsafe.IsAddressLessThan(ref current, ref last))
{
    sum += current;
    current = ref Unsafe.Add(ref current, 1);
}

Console.WriteLine(sum); // 5050
</code></pre>
<p>まぁforがwhileのアドレス処理になっていたり、最後にはみ出た分を処理する必要がありますが、かなり自然にSIMDを扱えているといってもいいんじゃないでしょうか。(Unsafeに慣れていれば)かなり書きやすいです。いいね。</p>
<p>ところで .NET 7からLINQがSIMD対応してるからこんなの書く必要ないでしょ？というと、対応してません。LINQのSIMDはint[]のAverage, int[]のMin, Max, long[]のMin, Maxのみと、かなり限定的です。これは互換性の問題などなどがあり、まぁオマケみたいなものだと思っておきましょう。必要な局面があるなら自分で用意する方が無難です。</p>
<p>ともあれ、.NET 7 からは手書きX86 SIMDはArm対応が漏れやすいので、極力Vectorによって抽象化されたコードで書きましょう、ということになります。どうしてもVectorじゃ書けないところだけ、仕方なく書くという感じですね。</p>
<h2>まとめ</h2>
<p>反響全然ないだろうなあと想定していましたが、やはり反響全然ないです！まぁでも結構面白いライブラリになったと思うので、是非使ってください。それと、Incremental Source Generatorの作り方がMemoryPackの頃よりも習熟していて、コードがかなり洗練されたものになっているので、Source Generatorの作り方として参照するならMemoryPackのコードよりもこちらのコードのほうがお薦めです。</p>
<p>というわけで、まだまだSource Generatorネタはいっぱいあるので、今年は大量に量産します！</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2025/05/">2025-05</a>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
