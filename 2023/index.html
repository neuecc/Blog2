<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2023</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html">UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</a></h1>
<ul class="date"><li>2023-10-13</li></ul>
<div class="entry_body"><p>Utf8StringInterpolationという新しいライブラリを公開しました！UTF8文字列の生成と書き込みに特化していて、動作をカスタマイズした文字列補間式によるC#コンパイラの機能を活用した生成と、StringBuilder的な連続的な書き込みの両方をサポートします。</p>
<ul>
<li><a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a></li>
</ul>
<p>基本的な流れはこんな感じで、Stringを生成するのと同じように、UTF8を生成/書き込みできます。</p>
<pre><code class="language-csharp">using Utf8StringInterpolation;

// Create UTF8 encoded string directly(without encoding).
byte[] utf8 = Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);

// write to IBufferWriter&lt;byte&gt;(for example ASP.NET HttpResponse.BodyWriter)
Utf8String.Format(bufferWriter, $&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;); // support format

// like a StringBuilder
var writer = Utf8String.CreateWriter(bufferWriter);
writer.Append(&quot;My Name...&quot;);
writer.AppendFormat($&quot;is...? {name}&quot;);
writer.AppendLine();
writer.Flush();

// Join, Concat methods
var seq = Enumerable.Range(1, 10);
byte[] utf8seq = Utf8String.Join(&quot;, &quot;, seq);
</code></pre>
<p>Cysharpから公開している <a href="https://github.com/Cysharp/ZString/">ZString</a> と非常に近いのですが、ZStringがString(UTF16), UTF8をサポートしていたのに対して、UTF8側のみを取り出して強化したようなイメージになります。何が強化なのかというと、C# 10.0から<a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md">Improved Interpolated Strings</a>として、文字列補間式($&quot;foo{bar}baz&quot;)のパフォーマンスが大きく向上しました。具体的には、コンパイラが文字列補間式の構造を分解して、値が埋め込まれている箇所はGenericsのまま渡すようになりボクシングが消滅しました。つまりZStringでやっていたことではあるのですが、ZStringはC# 10.0以前のものですからね……！逆に言えば、これによってZStringは半分は不要となったわけです。</p>
<p>もう半分、UTF8側に関しては依然として標準のサポートは薄い、というかほぼない状態です。しかし、Improved Interpolated Strings は文字列補間式での挙動を自由にカスタマイズできるという性質も追加されています。というわけで、文字列補間式を利用してUTF8を組み立てられるようにすればいいのではないか、というのがUtf8StringInterpolationのコンセプトであり、正しくZLoggerの後継として位置づけていることでもあります。</p>
<pre><code class="language-csharp">// こういう文字列補間式を渡すと:
// Utf8String.Format(ref Utf8StringWriter format)
Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);
</code></pre>
<pre><code class="language-csharp">// コンパイラが「コンパイル時」にこのような形に展開します。
var writer = new Utf8StringWriter(literalLength: 20, formattedCount: 2);
writer.AppendLiteral(&quot;Hello, &quot;);
writer.AppendFormatted&lt;string&gt;(name);
writer.AppendLiteral(&quot;, You id is &quot;);
writer.AppendFormatted&lt;int&gt;(id);
writer.AppendLiteral(&quot;!&quot;);
</code></pre>
<p>コンパイル時に展開してくれるというのは性能上非常に重要で、つまり<code>String.Format</code>のように実行時に文字列式のパースをしないで済む、わけです。また、ボクシングなしに全ての値を書き込みに呼んでくれます。</p>
<p><code>[InterpolatedStringHandler]</code>を付与している<code>ref Utf8StringWriter</code> に <code>$&quot;{}&quot;</code>を渡すと、自動的に展開してくれるという仕様になっています。そのUtf8StringWriterは以下のような実装になっています。</p>
<pre><code class="language-csharp">// internal struct writer write value to utf8 directly without boxing.
[InterpolatedStringHandler]
public ref struct Utf8StringWriter&lt;TBufferWriter&gt; where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    TBufferWriter bufferWriter; // when buffer is full, advance and get more buffer
    Span&lt;byte&gt; buffer;          // current write buffer

    public void AppendLiteral(string value)
    {
        // encode string literal to Utf8 buffer directly
        var bytesWritten = Encoding.UTF8.GetBytes(value, buffer);
        buffer = buffer.Slice(bytesWritten);
    }

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null)
        where T : IUtf8SpanFormattable
    {
        // write value to Utf8 buffer directly
        while (!value.TryFormat(buffer, out bytesWritten, format))
        {
            Grow();
        }
        buffer = buffer.Slice(bytesWritten);
    }
}
</code></pre>
<p>.NET 8 の場合は、値が <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0">IUtf8SpanFormattable</a> という.NET 8から追加されたインターフェイスを実装している場合(intなど標準のプリミティブはほぼ実装されています）、直接TryFormatによりUTF8としてSpanに書き込みます。</p>
<p>さすがに .NET 8 にしか対応していません！というのはエクストリームすぎるので、 .NET Standard 2.1, .NET 6(.NET 7)では <a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=net-7.0">Utf8Formatter.TryFormat</a> を使うことで、同様の性能を担保しています。</p>
<h2>Builder vs Writer</h2>
<p>ZStringのときはStringBuilderに引っ張られすぎていて、Builderとして内部でバッファを抱えるようにしていたのですが、ちょっとUTF8的な利用ではイマイチだということが徐々に分かってきました。今の .NET の基本は <code>IBufferWriter&lt;byte&gt;</code> である。というのはついこないだのCEDEC 2023での発表 <a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">モダンハイパフォーマンスC# 2023 Edition</a> でかなり語らせていただいたのですが</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>BuilderというよりもWriterとして構築すべきだな、ということに至りました。そこで <code>Utf8StringWriter</code> は基本的に<code>IBufferWriter&lt;byte&gt;</code>を受け取ってそれに書き込むという仕様となりました。</p>
<pre><code class="language-csharp">public ref partial struct Utf8StringWriter&lt;TBufferWriter&gt;
    where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    Span&lt;byte&gt; destination;
    TBufferWriter bufferWriter;
    int currentWritten;

    public Utf8StringWriter(TBufferWriter bufferWriter)
    {
        this.bufferWriter = bufferWriter;
        this.destination = bufferWriter.GetSpan();
    }

    public void Flush()
    {
        if (currentWritten != 0)
        {
            bufferWriter.Advance(currentWritten);
            currentWritten = 0;
        }
    }
</code></pre>
<p>バッファが足りなくなったときは拡大するのではなくて、Advanceして新たにGetSpanを呼んで新しいバッファを確保しにいくという形を取りました。StringBuilderと違ってFlushの概念が必要になってしまいましたが、パフォーマンス的には大きな向上を果たしています。</p>
<p>Flushが必要ということを除けば、StringBuilderのように扱うことができます。</p>
<pre><code class="language-csharp">var writer = Utf8String.CreateWriter(bufferWriter);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(or Dispose)
writer.Flush();
</code></pre>
<p>また、ちょっとStringBuilder的に使いたいだけの時に <code>IBufferWriter&lt;byte&gt;</code> を用意するのは面倒くさい！という場合のために、内部でプーリングを行っているバッファを使えるオーバーロードも用意しています。戻り値がバッファのコントローラーになっていて、ToArrayや他の<code>IBufferWriter&lt;byte&gt;</code>にコピーしたり<code>ReadOnlySpan&lt;byte&gt;</code>の取得ができます。</p>
<pre><code class="language-csharp">// buffer must Dispose after used(recommend to use using)
using var buffer = Utf8String.CreateWriter(out var writer);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(no need to call Dispose for writer)
writer.Flush();

// copy to written byte[]
var bytes = buffer.ToArray();

// or copy to other IBufferWriter&lt;byte&gt;, get ReadOnlySpan&lt;byte&gt;
buffer.CopyTo(otherBufferWriter);
var writtenData = buffer.WrittenSpan;
</code></pre>
<p>その他、<code>Format</code>, <code>Join</code>, <code>Concat</code> メソッドなども <code>IBufferWriter&lt;byte&gt;</code> を受け取るオーバーロードと <code>byte[]</code>を返すオーバーロードの2種を用意しています。</p>
<h2>.NET 8 と StandardFormat</h2>
<p>値のフォーマット書式は、特にDateTimeでよく使うと思いますが、数値型などでも多くの書式が用意されています。<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/formatting-types">.NET の数値、日付、列挙、その他の型の書式を設定する方法</a> や各種カスタム書式指定文字列は非常に便利です。</p>
<p>しかし、UTF8に値を直接書き込む手段として従来用意されていた<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat">Utf8Formatter.TryFormat</a>では、その標準的な書式指定文字列は使えませんでした！代わりに用意されたのが<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.standardformat">StandardFormat</a>なのですが、恐ろしく限定的なことしかできず(例えば'G', 'D', or 'X'のような一文字charの指定しかできない)、使い物にならないといっても過言ではないぐらいでした。</p>
<p>ところが .NET 8 から追加された IUtf8SpanFormattable.TryFormat では、通常の書式指定文字列が帰ってきました！</p>
<pre><code class="language-csharp">// Utf8Formatter.TryFormat
static bool TryFormat (int value, Span&lt;byte&gt; destination, out int bytesWritten, System.Buffers.StandardFormat format = default);

// .NET 8 IUtf8SpanFormattable.TryFormat
bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);
</code></pre>
<p>パラメーターは非常に似ていますが、formatを文字列で受け取るようになっています。実際に比較してみるとこんな感じです。</p>
<pre><code class="language-csharp">Span&lt;byte&gt; dest = stackalloc byte[16];
int written = 0;

// ParseできなくてExceptionがthrowされるので表現できない
Utf8Formatter.TryFormat(123.456789, dest, out written, StandardFormat.Parse(&quot;.###&quot;));

// 123.456
123.456123.TryFormat(dest, out written, &quot;.###&quot;);


// カスタム書式文字列は指定できないので例外！サポートしてるのは `G`, `R`, `l`, `O` だけ！
Utf8Formatter.TryFormat(DateTime.Now, dest, out written, StandardFormat.Parse(&quot;yyyy-MM-dd&quot;));

// もちろんちゃんと動作する
DateTime.Now.TryFormat(dest, out written, &quot;yyyy-MM-dd&quot;);

Console.WriteLine(Encoding.UTF8.GetString(dest.Slice(0, written)));
</code></pre>
<p>良かった、やと普通の世界が到達した……！これは ZString や、それを内部に使っていた <a href="https://github.com/Cysharp/ZLogger">ZLogger</a>で最もフラストレーションを感じていた点です。</p>
<p>Utf8StringInterpolationは .NET 8 では全て IUtf8SpanFormattable で変換するようにしています。しかし、 .NET Standard 2.1, .NET 6, .NET 7では残念ながらUtf8Formatter利用となっているので、書式指定に関しては制限があります。数値に関してはターゲットプラットフォームによって動作したりしなかったりが発生します。</p>
<pre><code class="language-csharp">// .NET 8 supports all numeric custom format string but .NET Standard 2.1, .NET 6(.NET 7) does not.
Utf8String.Format($&quot;Double value is {123.456789:.###}&quot;);
</code></pre>
<p>ただし、 <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code> に関しては <code>Utf8Formatter</code> を使わない処理をしているため、全てのターゲットプラットフォームでカスタム書式指定が利用可能です！</p>
<pre><code class="language-csharp">// DateTime, DateTimeOffset, TimeSpan support custom format string on all target plaftorms.
// https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
Utf8String.Format($&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;);
</code></pre>
<p>とにかくDateTimeの書式指定がまともに出来ないのはZString/ZLoggerで一番辛かったところなので、それを改善できてとても良かった……。ただしこの対応により、DateTimeの変換性能が落ちているため、性能が最大限引き出せるのは .NET 8 となります。</p>
<h2>Unity</h2>
<p>Unity対応はありません！いや、可能な限り私は .NET と Unityの両対応のライブラリを作りたいと思っていて、実際今までもそうしてきているわけですが、今回ばかりはどうにもならないのです。そもそもImproved Interpolated Stringsが C# 10.0 からで、Unityの現在のC#のバージョンは C# 9.0……！さすがにそれはどうにもならない。</p>
<p>C# 9.0で止まってから結構長いんですよね。別にランタイムのバージョンは上げなくてもいいから、コンパイラのバージョンだけ上げて欲しいと切実に思いますが、まぁC# 10.0にしたらDefaultInterpolatedStringHandlerがなくて動作しないじゃんとかなるだろうから、結局はランタイムのバージョンアップもセットでやらなければならない……。</p>
<p>Unityが C# 10.0 に対応したらすぐに対応させるつもりではあります！待ってます！</p>
<h2>Next</h2>
<p>さて、とはいえ、UTF8文字列を直接扱わなければならないケースというのは、別にそんなに多くはないでしょう。実際、私も本命は<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>の大型バージョンアップでの利用を考えています。ZLoggerは今まではZStringベースでしたが、根本からデザインをやり直した新しいものを開発中です。その中の文字列化にUtf8StringInterpolationを使っています。</p>
<p>といったように、アプリケーションの基盤レイヤーに差し込んであげると有効に機能するシチュエーションは色々あると思います。もちろん、直接使ってもらってもいいのですが……！？</p>
</div>
<h1><a href="https://neue.cc/2023/09/21_privateproxy.html">.NET 8 UnsafeAccessor を活用したライブラリ PrivateProxy を公開しました</a></h1>
<ul class="date"><li>2023-09-21</li></ul>
<div class="entry_body"><p>PrivateProxyというライブラリを公開しました。つまるところ、privateフィールド/プロパティ/メソッドにアクセスするライブラリなのですが、.NET 8 のUnsafeAccessorという新機能を活用することでNo Reflection、ハイパフォーマンス、AOTセーフになっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/PrivateProxy">Cysharp/PrivateProxy</a></li>
</ul>
<p>もちろん .NET 8 でしか動きません！ので、.NET 8が正式リリースされた頃に思い出して使ってみてください。エクストリームな人は今すぐ試しましょう。</p>
<p>雰囲気としては、privateメンバーにアクセスしたい型があったとして、<code>[GeneratePrivateProxy(type)]</code>をつけた型を用意します。</p>
<pre><code class="language-csharp">using PrivateProxy;

public class Sample
{
    int _field1;
    int PrivateAdd(int x, int y) =&gt; x + y;
}

[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p>すると、いい感じにアクセスできるようになります。</p>
<pre><code class="language-csharp">// You can access like this.
var sample = new Sample();
sample.AsPrivateProxy()._field1 = 10;
</code></pre>
<p>いいところとしては、 Source Generatorベースの生成なので、型がついていて入力補完も効くし、変数名を変更したらコンパイルエラーで検出可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/269376472-f6dd22e1-e82e-4acc-ba6e-8895c8c8734b.png" alt="" /></p>
<p>ここまではSource Generatorベースで作れば、今まででもやれないことはなかったのですが、UnsafeAccessorのいいところとして、objectが一切出てこないで元のメソッドそのままの型がそのまま使えることです。生成されたコードを見ると、こうなっています。</p>
<pre><code class="language-csharp">// Source Generator generate this type
partial struct SampleProxy(Sample target)
{
    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &quot;_field1&quot;)]
    static extern ref int ___field1__(Sample target);

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;PrivateAdd&quot;)]
    static extern int __PrivateAdd__(Sample target, int x, int y);

    public ref int _field1 =&gt; ref ___field1__(target);
    public int PrivateAdd(int x, int y) =&gt; __PrivateAdd__(target, x, y);
}

public static class SamplePrivateProxyExtensions
{
    public static SampleProxy AsPrivateProxy(this Sample target)
    {
        return new SampleProxy(target);
    }
}
</code></pre>
<p>これによって <code>ref</code> や <code>readonly</code> などの言語機能をそのまま反映できたり、mutableなstructの対応が自然にできたり、そして何よりパフォーマンスの低下も一切ありません。</p>
<p>使い道は、主にユニットテスト用になるとは思いますので、なのでパフォーマンスはそこまで重要ではないといえばないのですが、性能的にはアプリケーションの実行時に使っても問題ないものとなっています。</p>
<p>私は昔<a href="https://github.com/neuecc/ChainingAssertion">Chaining Assertion</a>というユニットテスト用のライブラリを作っていたのですが、現在は<a href="https://fluentassertions.com/">Fluent Assertions</a>という別のライブラリを使っています。ほとんどの機能は概ねなんとかなっているのですが、<code>AsDynamic()</code>を呼ぶと、移行はprivateフィールドやメソッドにアクセスし放題という機能は結構便利で、そしてそれがFluent Assertionsにないのは若干不便と思ってたんですね。今回、やっとそれの進化系を作れたのでメデタシメデタシです。</p>
<h2>C# 12</h2>
<p>ところで、冒頭のSampleProxyの書き方、地味にこれはC# 12の記法を使っています。どこだかわかりますか？</p>
<pre><code class="language-csharp">[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p><code>SampleProxy;</code> の部分で、空のクラスを作る際に <code>{ }</code> じゃなくて <code>;</code> だけで済ませられるようになりました。これは地味ですがかなりいい機能で、というのもSource Generatorだと空クラスに割り当てることが多かったんですよね。そして、たった2文字が1文字に変わっただけ、ではあるのですが、 <code>{ }</code> だとコードフォーマットに影響があります。改行して3行で表現するのか、後ろにつけるのか。そうした判断のブレが <code>;</code> だとなくなります。だから2文字が1文字に変わっただけ、以上のインパクトがある、良い機能追加だと思います。</p>
<h2>ref field</h2>
<p>PrivateProxyはstaticメソッドにも対応していますし、そしてmutable structにも対応しています。</p>
<pre><code class="language-csharp">using PrivateProxy;

public struct MutableStructSample
{
    int _counter;
    void Increment() =&gt; _counter++;

    // static and ref sample
    static ref int GetInstanceCounter(ref MutableStructSample sample) =&gt; ref sample._counter;
}

// use ref partial struct
[GeneratePrivateProxy(typeof(MutableStructSample))]
public ref partial struct MutableStructSampleProxy;
</code></pre>
<pre><code class="language-csharp">var sample = new MutableStructSample();
var proxy = sample.AsPrivateProxy();
proxy.Increment();
proxy.Increment();
proxy.Increment();

// call private static method.
ref var counter = ref MutableStructSampleProxy.GetInstanceCounter(ref sample);

Console.WriteLine(counter); // 3
counter = 9999;
Console.WriteLine(proxy._counter); // 9999
</code></pre>
<p>mutable structの対応って結構難しい話で、というのもフィールドにstructを保持するとコピーが渡されることになるので、普通に書いていると変更が元のstructに反映されないんですね。この問題をPrivateProxyではC# 11 ref fieldで解決しました。</p>
<p>MutableStructSampleProxyはSource Generatorによって以下のようなコードが生成されます。</p>
<pre><code class="language-csharp">ref partial struct MutableStructSampleProxy
{
    ref MutableStructSample target;

    public MutableStructSampleProxy(ref MutableStructSample target)
    {
        this.target = ref target;
    }

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;Increment&quot;)]
    static extern void __Increment__(ref MutableStructSample target);
    
    public void Increment() =&gt; __Increment__(ref this.target);
}

public static class MutableStructSamplePrivateProxyExtensions
{
    public static MutableStructSampleProxy AsPrivateProxy(this ref MutableStructSample target)
    {
        return new MutableStructSampleProxy(ref target);
    }
}
</code></pre>
<p>AsPrivateProxy(これはthis refですが、拡張メソッドの場合、予備側はrefを書かなくていいので自然に使えます)で渡されたstructは、そのままずっとrefのまま保持されています。これにより、メソッド呼び出しでstructの状態に変更があった場合も問題なく変更が共有されています。</p>
<h2>privateメソッドの単体テスト</h2>
<p><a href="https://t-wada.hatenablog.jp/entry/should-we-test-private-methods">プライベートメソッドのテストは書かない</a>みたいな流儀も世の中にはありますが、私は何言ってんの？と思ってます。パブリックメソッドのテストでprivateメソッドの確認が内包されるから不要というなら、はぁー？だったら全部E2Eテストでいいんじゃないですかー？真の振る舞いがテストされますよー？</p>
<p>もちろんそれは非現実的で、E2Eでパブリックメソッドのロジックを全て通過させるのは手間とコストがかかりすぎる。というのと同じ話で、privateメソッドのエッジケースを全てチェックする時に、public経由だとやりにくいことは往々にある。場合によってはコード通すためにモックを仕込まなければならないかもしれない。そこまでいくとアホらしいですよね、privateメソッドを直接テストすればすむだけの話なのに？メソッドは小さければ小さいほど良いし、テストもしやすい。そしてprivateを内包したpublicよりもprivateそのもののほうが小さく、テストしやすい。</p>
<p>ようするにコスト面を考えて境界をどこに置くかというだけの話で。そして、privateメソッドのテストそのものは、C#の場合reflection呼び出しだと、変更コストがかかるなど、コスパは悪い部類に入ってしまう。でもそれはただの言語からの制約であって、だからプライベートメソッドのテストは不要みたいなしょーもない理屈をこねて絶対視するほどのことでもない。リフレクション使うとコスパ感が合わないから原則publicで済ませること、ぐらいだったらいいけど、変な教義立てるのはおかしいでしょ。</p>
<p>チェックしたいがためにprivateであるべきものをinternalにする（たまによくやる、internalならInternalsVisibleToをテストプロジェクトに指定することで、ユニットテストプロジェクトで参照できるようになる）こともありますが、あまりお行儀の良いことではない。そもそもinternalなので同一アセンブリ内では不要に可視レベル上がっちゃってるし。</p>
<p>と、いうわけで、PrivateProxyは比較的低コストでprivateメソッドをテスト対象にすることができるので、全然使っちゃっていいし、テストも書いちゃって良い、わけです。</p>
<h2>UnsafeAccessor for InternalCall</h2>
<p>UnsafeAccessor の使い道として、corelibの InternalCall を強引に呼べることはかなりいいこと（？）だと思ってます。例えば string の生成には大元に <a href="https://source.dot.net/#System.Private.CoreLib/src/System/String.CoreCLR.cs,12">FastAllocateString</a> というのがあって、通常ユーザーはこれを呼ぶことはできないのですが</p>
<pre><code class="language-csharp">[UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = &quot;FastAllocateString&quot;)]
static extern string FastAllocateString(string _, int length);

var rawString = FastAllocateString(null!, 10);
var mutableSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(rawString.AsSpan()), rawString.Length);

&quot;abcde&quot;.CopyTo(mutableSpan);
&quot;fghij&quot;.CopyTo(mutableSpan.Slice(5));

Console.WriteLine(rawString); // abcdefghij
</code></pre>
<p>といったようにUnsafeAccessorを通せばやりたい放題できます。</p>
<p>Stringに関しては、やりたい放題させないために、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.string.create">String.Create</a>というメソッドが用意されていて、Actionのコールバックで変更して、不変のStringを返すというものが用意されてはいるのですが、ActionだとTStateに<code>Span&lt;T&gt;</code>を渡せないとか、使えないケースがそれなりにあります、というか使いたいシチュエーションに限って使えないことが多い……。</p>
<p>なお、こういうFastAllocateStringを呼んでStringに変更をかけるというのは、<a href="https://github.com/dotnet/runtime/issues/36989">dotnet/runtime#36989 Make string.FastAllocateString public</a>で見事に却下されています。つまり、やるな、ということです。</p>
<blockquote>
<p>It is never safe or supported to mutate the contents of a returned string instance.
If you mutate a string instance within your own library or application, you are entering unsupported territory.
A future framework update could break you. Or - more likely - you'll encounter memory corruption that will be very painful for you or your customers to diagnose.</p>
</blockquote>
<p>お怒りはご尤もです。しかしString.CreateでAction渡す口あるんだからそれでいいだろーというのはお粗末すぎだと思うんですよねー、どうせやってること一緒なんだから弄るの許可してよ、というのもそれはそれで理解してもらいたいです（私は弄りたいほうの人間なので！）。というわけで、自己責任で、やっていきましょう、つまりやっていくということです……！</p>
<h2>まとめ</h2>
<p>.NET 8でしか動きません！11月に .NET 8 がリリースされるので、その時まで忘れないでください！</p>
</div>
<h1><a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html">Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</a></h1>
<ul class="date"><li>2023-07-28</li></ul>
<div class="entry_body"><p>Cysharpから(主に)Unity用のHTTP/2, gRPC, MagicOnion用の通信ネットワーククライアントを公開しました。実装者は週刊.NET情報配信<a href="https://weekref.net/">WeekRef.NET</a>を運営している<a href="https://twitter.com/mayuki">@mayuki</a>さんです。</p>
<ul>
<li><a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a></li>
</ul>
<p>何故これが必要なのかの背景情報としては、<a href="https://synamon.hatenablog.com/entry/grpc-dotnet-unity">Synamon’s Engineer blog - Unityでもgrpc-dotnetを使ったgRPCがしたい</a> が詳しいのですが、まず、.NETには2つのgRPC実装があります。googleが提供してきたgRPCのネイティブバインディングのGrpc.Core(C-Core)と、Microsoftが提供しているPure C#実装のgrpc-dotnet。現在.NETのgRPCはサーバーもクライアントも完全にPure C#実装のほうに寄っていて、<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>もサーバーはPure C#実装のものを使っています。</p>
<p>しかしクライアントに関しては、諸事情によりUnityでは動かない（TLS関連の問題など）ため、ずっとC-Coreを推奨してきました。更に、Unity用のビルドは元々experimentalだったうえに、とっくにメンテナンスモードに入り、そしてついに今年5月にサポート期限も切れて完全に宜しくない気配が漂っていました。また、古いx64ビルドなので最近のMac(M1, M2チップ)では動かないためUnity Editorで使うのにも難儀するといった問題も出てきていました。</p>
<p>と、いうわけで、CysharpではUnityで使うgRPCを推奨してきたということもあり、Unityで問題なく使えるgRPC実装としてYetAnotherHttpHandlerを開発・リリースしました。HttpClientの通信レイヤーであるHttpHandlerを差し替えるという形で実装してあるので、ほとんど通常の .NET でのgRPCと同様に扱えます。</p>
<p>内部実装としてはPure Rust実装のHTTP/2ライブラリ<a href="https://hyper.rs/">hyper</a>とPure RustのTLSライブラリ<a href="https://github.com/rustls/rustls">rustls</a>を基盤として作ったネイティブライブラリに対して、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>で生成したC#バインディングを通して通信する形になっています。</p>
<h2>余談</h2>
<p>YetAnotherHttpHandlerはgRPCやMagicOnionに限らず、Unityで自由に使える HTTP/2 Clientなので、アセットダウンロードの高速化にHTTP/2を用いる、といったような使い道も考えられます。既にモバイルゲームでも幾つかのタイトルでHTTP/2でアセットダウンロードしているタイトルは確認できていまして、例えばセガさんは<a href="https://speakerdeck.com/segadevtech/cedec2021-taunrotoshi-jian-woda-fu-jian-da-liang-falseasetutowosahakugao-su-nashi-zhuang-toyun-yong-shi-li-falsegong-you">CEDEC2021 ダウンロード時間を大幅減！～大量のアセットをさばく高速な実装と運用事例の共有～</a>のような発表もされています。ネイティブプラグインを自前でビルドして持ち込むというのはだいぶ敷居が高い話でしたが、YetAnotherHttpHandlerを入れるだけでいいなら、だいぶやれるんじゃないか感も出てくるんじゃないでしょうか……？</p>
</div>
<h1><a href="https://neue.cc/2023/07/20_nats_client_v2.html">AlterNats は 公式の NATS .NET Client v2 に引き継がれました</a></h1>
<ul class="date"><li>2023-07-20</li></ul>
<div class="entry_body"><p><a href="https://nats.io/">NATS</a>のサードパーティー(alternative)クライアントであった<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>は、公式に引き取られて<a href="https://github.com/nats-io/nats.net.v2">NATS.NET V2</a>となりました。v2の詳細に関してはNATS公式からのブログ<a href="https://nats.io/blog/nats-dotnet-v2-alpha-release/">NATS .NET Client v2 Alpha Released with Core NATS Support</a>を参照ください。</p>
<blockquote>
<p>NATS community members started to take note, and develop client libraries for NATS based on modern .NET APIs. One notable client library that emerged was the AlterNats library by Cysharp, which includes a fully asynchronous API, leverages Span<T> , and supports client-side WebSockets from browsers in Blazor . NATS maintainers and AlterNats maintainers agreed that AlterNats would make a great starting point for NATS.Client v2!</p>
</blockquote>
<p>NATSに関してはAlterNatsリリース時の記事 <a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a>に色々書きましたが、<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>配下のPubSubミドルウェアで、RedisなどでのPubSubに比べるとパフォーマンスを始めとして多くのメリットがあります。</p>
<p>ただしこういうものはサーバー実装も重要ですがクライアント実装も重要であり、そして当時のNATSの公式クライアント(v1)は正直酷かった！せっかくの素晴らしいミドルウェアが.NETでは活かされない、また、RedisでのPubSubには不満があり、そもそも.NETでのベストなPubSubのソリューションがないことに危機意識を感じていたので、独自に実装を進めたのがAlterNatsでした。</p>
<p>ただし、枯れたプロトコルならまだしも、進化が早いミドルウェアのクライアントが乱立しているのは決して良いことでもないでしょう。新機能への追随速度やメンテナンスの保証という点でも、サードパーティクライアントとして進んでいくよりも、公式に統合されることのほうが絶対に良いはずです。</p>
<p>というわけで今回の流れは大変ポジティブなことだし、野良実装にとって最高の道を辿れたんじゃないかと思っています。私自身は実装から一歩引きますが、使っていく上で気になるところがあれば積極的にPR上げていくつもりではあります。</p>
<p>なお、NATSに関しては来月CEDEC 2023でのセッション<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>で触れる、かもしれません、多分。というわけでぜひ聞きに来てください……！</p>
<p>メタバース関連では、今年の5月にTGS VRなどを手掛けている<a href="https://ambr.co.jp/">ambr</a>さんのテックブログにて<a href="https://ambr-inc.hatenablog.com/entry/20230512/1683882000">VRメタバースのリアルタイム通信サーバーの技術にMagicOnionとNATSを選んだ話</a>という紹介もしていただいていました。</p>
<h2>OSSとメンテナンスの引き継ぎ</h2>
<p>権限の移管は何度か経験があって</p>
<ul>
<li><a href="https://github.com/mihaifm/linq">linq.js</a>、</li>
<li><a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a></li>
<li><a href="https://github.com/xin9le/CloudStructures">CloudStructures</a></li>
</ul>
<p>は完全に手放しています。ほか、<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>はCysharp名義に移ったうえで、現在の開発リードは私ではありません。また、最近では<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#</a>はMessagePack-CSharp Organizationに移していて共同のOwner権限になっています。</p>
<p>どうしても常に100%の力を一つのOSSに注ぐことはできないので、本来はうまく移管していけるのが良いわけですが、いつもうまくできるわけじゃなくて、<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>なんかはうまく移管できないままarchivedにしてしまっています。</p>
<p>やっぱ出した当時は自分が手綱を握っていたいという気持ちがとても強いわけですが、関心が徐々に薄れていくタイミングと他の人に渡せるタイミングがうまく噛み合わないと、死蔵になってしまうというところがあり、まぁ、難しいです。これだけやっていても上手くできないなあ、と……。</p>
<p>今回のは大変良い経験だったので、作ってメンテナンスを続ける、そしてその先についても考えてやっていきたいところですね。</p>
<p>ともあれ、良い事例を一つ作れた＆素晴らしいライブラリをC#に一つ持ち込むことができたということで、とても気分がよいですです。</p>
</div>
<h1><a href="https://neue.cc/2023/07/07_mvp-renew13.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2023-07-07</li></ul>
<div class="entry_body"><p>13回目です！一年ごとに再審査での更新で、変わらずC#の最前線に立てています。</p>
<p>活動の中心は引き続きOSSですが、<a href="https://github.com/Cysharp">github/Cysharp</a>でのスター数は変わらず他を圧倒していると思いますし、毎年の新規の公開数の勢いも変わらずで新しいアイディアを出し続けています。</p>
<p>今年は<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>を起点にしてRustを活用してC#の活用幅をより広げていくことを狙っています。先日公開した<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>の他にも色々計画がって、かなり面白いインパクトが出せるんじゃないかと思っています。</p>
<p>MessagePack for C#も<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack-CSharp/MessagePack-CSharp</a>と、organization名義に移したことで（変わらず私はOwnerなので権限を手放したわけではありません）より中立的に発展させていきます。直近ではSource Generator対応が予定されています(preview版を公開中）。</p>
<p>というわけで、これはもう満場一致でC#に貢献しているということでいいんじゃないでしょうかね……？</p>
<p>ここ最近は登壇していなかったのですが、去年は<a href="https://speakerdeck.com/neuecc/c-number-11-niyorushi-jie-zui-su-bainarisiriaraiza-memorypack-nozuo-rifang">C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a>というセッションをしました。その流れということで、今年の8月にCEDEC 2023にて<a href="https://cedec.cesa.or.jp/2023/session/detail/s642165615a6b5">モダンハイパフォーマンスC# 2023 Edition</a>、それと共同講演で<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>という2つの登壇予定があるので、ぜひ見に来てください。</p>
</div>
<h1><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></h1>
<ul class="date"><li>2023-07-04</li></ul>
<div class="entry_body"><p>MagicPhysXというライブラリを新しく公開しました！.NETで物理エンジンを動かすというもので、その名の通り、<a href="https://github.com/NVIDIA-Omniverse/PhysX">NVIDIA PhysX
</a>のC#バインディングとなっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/MagicPhysX">Cysharp/MagicPhysX</a></li>
</ul>
<p>使い道としては</p>
<ul>
<li>GUIアプリケーションの3D部分</li>
<li>自作ゲームエンジンへの物理エンジン組み込み</li>
<li>ディープラーニングのためのシミュレーション</li>
<li>リアルタイム通信におけるサーバーサイド物理</li>
</ul>
<p>といったことが考えられます。</p>
<p>.NET用のPhysXバインディングは他にも存在しますが、C++/CLIでバインディングを生成している都合上Windowsでしか動かせなかったり、バージョンが最新ではない4.xベースだったりしますが、MagicPhysXは最新のPhysX 5ベースで、かつ、Windows, MacOS, Linuxの全てで動きます！(win-x64, osx-x64, osx-arm64, linux-x64, linux-arm64)。これはバインディングの作り方としてクロスプラットフォームコンパイルに強いRustと、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>によってC#のバインディングの自動生成をしているからです。</p>
<p>先にアーキテクチャの話をしましょう。MagicPhysXは<a href="https://www.embark-studios.com/">EmbarkStudios</a>による<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>をビルド元に使っています。</p>
<blockquote>
<p>EmbarkStudiosはEA DICEで<a href="https://www.ea.com/frostbite">Frostbite</a>ゲームエンジン(Battlefield)を作っていた人たちが独立して立ち上げたスタジオで、Rustによるゲームエンジンを作成中です。また、その過程で生まれたRustのライブラリをOSSとして積極的に公開しています。一覧は<a href="https://embark.dev/">Embark Studios Open Source</a>にあります。必見！</p>
</blockquote>
<p>PhysXのライブラリはC++で出来ていて、他の言語で使うことは考慮されていません。そのために他の言語に持ち込むためには、C++上で別言語で使うためのブリッジ部分を作った上で、バインディングを用意するという二度手間が必要になってきます。それはRustであっても例外ではありません。また、二度手間というだけではなく、PhysXのソースコードはかなり大きいため、その作業量も膨大です。</p>
<p>以前に<a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a>で紹介しましたが、<a href="https://www.swig.org/">SWIG</a>などのC++からの自動生成、Rustであれば<a href="https://cxx.rs/">cxx</a>、<a href="https://github.com/google/autocxx">autocxx</a>のような自動化プロジェクトも存在しますが、C++そのものの複雑さからいっても、求めるものを全自動で出力するのは難しかったりします。</p>
<p>physx-rsでは<a href="https://www.youtube.com/watch?v=RxtXGeDHu0w">An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)</a>というセッションでPhysXをRustに持ち込むための手段の候補、実際に採用した手段についての解説があります。最終的に採用された手段について端的に言うと、PhysXに特化してコード解析してC APIを生成する独自ジェネレーターを用意した、といったところでしょうか。そしてつまり、physx-rsには他言語でもバインディング手段として使えるPhysXのC APIを作ってくれたということにもなります！</p>
<p>更にcsbindgenには、rsファイル内のextern &quot;C&quot;の関数からC#を自動生成する機能が備わっているので、Rustを経由することでC++のPhysXをC#に持ち込めるというビルドパイプラインとなりました。</p>
<p>そういう成り立ちであるため、MagicPhysXのAPIはPhysXのAPIそのものになっています。</p>
<pre><code class="language-csharp">using MagicPhysX; // for enable Extension Methods.
using static MagicPhysX.NativeMethods; // recommend to use C API.

// create foundation(allocator, logging, etc...)
var foundation = physx_create_foundation();

// create physics system
var physics = physx_create_physics(foundation);

// create physics scene settings
var sceneDesc = PxSceneDesc_new(PxPhysics_getTolerancesScale(physics));

// you can create PhysX primitive(PxVec3, etc...) by C# struct
sceneDesc.gravity = new PxVec3 { x = 0.0f, y = -9.81f, z = 0.0f };

var dispatcher = phys_PxDefaultCpuDispatcherCreate(1, null, PxDefaultCpuDispatcherWaitForWorkMode.WaitForWork, 0);
sceneDesc.cpuDispatcher = (PxCpuDispatcher*)dispatcher;
sceneDesc.filterShader = get_default_simulation_filter_shader();

// create physics scene
var scene = physics-&gt;CreateSceneMut(&amp;sceneDesc);

var material = physics-&gt;CreateMaterialMut(0.5f, 0.5f, 0.6f);

// create plane and add to scene
var plane = PxPlane_new_1(0.0f, 1.0f, 0.0f, 0.0f);
var groundPlane = physics-&gt;PhysPxCreatePlane(&amp;plane, material);
scene-&gt;AddActorMut((PxActor*)groundPlane, null);

// create sphere and add to scene
var sphereGeo = PxSphereGeometry_new(10.0f);
var vec3 = new PxVec3 { x = 0.0f, y = 40.0f, z = 100.0f };
var transform = PxTransform_new_1(&amp;vec3);
var identity = PxTransform_new_2(PxIDENTITY.PxIdentity);
var sphere = physics-&gt;PhysPxCreateDynamic(&amp;transform, (PxGeometry*)&amp;sphereGeo, material, 10.0f, &amp;identity);
PxRigidBody_setAngularDamping_mut((PxRigidBody*)sphere, 0.5f);
scene-&gt;AddActorMut((PxActor*)sphere, null);

// simulate scene
for (int i = 0; i &lt; 200; i++)
{
    // 30fps update
    scene-&gt;SimulateMut(1.0f / 30.0f, null, null, 0, true);
    uint error = 0;
    scene-&gt;FetchResultsMut(true, &amp;error);

    // output to console(frame-count: position-y)
    var pose = PxRigidActor_getGlobalPose((PxRigidActor*)sphere);
    Console.WriteLine($&quot;{i:000}: {pose.p.y}&quot;);
}

// release resources
PxScene_release_mut(scene);
PxDefaultCpuDispatcher_release_mut(dispatcher);
PxPhysics_release_mut(physics);
</code></pre>
<p>つまり、そのままでは決して扱いやすくはないです。部分的に動かすだけではなく、本格的にアプリケーションを作るなら、ある程度C#に沿った高レベルなフレームワークを用意する必要があるでしょう。MagicPhysX内ではそうしたサンプルを用意しています。それによって上のコードはこのぐらいシンプルになります。</p>
<pre><code class="language-csharp">using MagicPhysX.Toolkit;
using System.Numerics;

unsafe
{
    using var physics = new PhysicsSystem(enablePvd: false);
    using var scene = physics.CreateScene();

    var material = physics.CreateMaterial(0.5f, 0.5f, 0.6f);

    var plane = scene.AddStaticPlane(0.0f, 1.0f, 0.0f, 0.0f, new Vector3(0, 0, 0), Quaternion.Identity, material);
    var sphere = scene.AddDynamicSphere(1.0f, new Vector3(0.0f, 10.0f, 0.0f), Quaternion.Identity, 10.0f, material);

    for (var i = 0; i &lt; 200; i++)
    {
        scene.Update(1.0f / 30.0f);

        var position = sphere.transform.position;
        Console.WriteLine($&quot;{i:D2} : x={position.X:F6}, y={position.Y:F6}, z={position.Z:F6}&quot;);
    }
}
</code></pre>
<p>ただしあくまでサンプルなので、参考にしてもらいつつも、必要な部分は自分で作ってもらう必要があります。</p>
<p>Unityのようなエディターがないと可視化されてなくて物理エンジンが正しい挙動になっているのか確認できない、ということがありますが、PhysXにはPhysX Visual Debuggerというツールが用意されていて、MagicPhysXでも設定することでこれと連動させることが可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/250030945-2018e821-41c4-44a2-aac6-f0705993ab9b.png" alt="" /></p>
<h2>Dedicated Server</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>といったサーバーサイドでゲームのロジックを動かすためのライブラリを開発しています。その路線から行って物理エンジンが必要なゲームでさえも通常の .NET サーバーで動かしたいという欲求が出てくるのは至極当然でしょう……（？）</p>
<p>UEやUnityのDedicated Serverの構成だとヘッドレスなUE/Unityアプリケーションをサーバー用ビルドしてホスティングすることになりますが、サーバー用のフレームワークではないので、あまり作りやすいとは言えないんですよね。通常用サーバー向けのライブラリとの互換性、ライフサイクルの違い、ランタイムとしてのパフォーマンスの低さ、などなど。</p>
<p>というわけで、MagicOnionのようなサーバー向けフレームワークを使ったほうがいいのですが、物理エンジンだけはどうにもならない。今までは……？</p>
<p>と、言いたいのですが、まずちゃんとしっかり言っておきたいのですが、現実的には少々（かなり）難しいでしょう！コライダーどう持ってくるの？とかAPIが違う（Unityの物理エンジンはPhysXですが、API的に1:1の写しではないので細かいところに差異がある）のでそもそも挙動を合わせられないし、でもこういう構成ならサーバーだけじゃなくクライアントでも動かしたい、そもそもそうじゃないとデバッガビリティが違いすぎる。</p>
<p>と、ようするに、もしゲーム自体にある程度、物理エンジンに寄せた挙動が必要なら、「物理エンジン大統一」が必須だと。MagicPhysXは残念ながらそうではありません。実のところ当初はそれを目指していました、Unityとほぼ同一挙動でほぼ同一APIになるのでシームレスに持ち込むことができるライブラリなのだ、と。しかし現状はそうではないということは留意してください。また、その当初予定である互換APIを作り込む予定もありません。</p>
<h2>まとめ</h2>
<p>このライブラリ、かなり迷走したプロジェクトでもあって、そもそも最初は<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>を採用する予定でした。ライブラリ名が先に決めてあってMagicBulletってカッコイイじゃん、みたいな。その後に<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>を使おうとして、これもバインディングをある程度作って動く状態にしたのですが、「物理エンジン大統一」のためにPhysXにすべきだろうな、という流れで最終的にPhysXを使って作ることにしました。</p>
<p>形になって良かったというのはありますが（そしてcsbindgenの実用性！）、「物理エンジン大統一」を果たせなかったのは少々残念ではあります。最初の完成予想図ではもっともっと革命的なもののはずだったのですが……！</p>
<p>とはいえ、PhysX 5をクロスプラットフォームで.NETに持ち込んだということだけでも十分に難易度が高く新しいことだと思っているので、試す機会があれば、是非触って見ください。</p>
</div>
<h1><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></h1>
<ul class="date"><li>2023-03-09</li></ul>
<div class="entry_body"><p>ネイティブコードとC#を透過的に接続するために、RustのFFIからC#のDllImportコードを自動生成するライブラリを作成し、公開しました。Cysharp初のRustライブラリです！先週にプレビューを出していましたが、しっかりした機能強化とReadMeの充実をして正式公開、です！</p>
<ul>
<li><a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a></li>
<li><a href="https://crates.io/crates/csbindgen">crates.io/crates/csbindgen</a></li>
</ul>
<p>めちゃくちゃスムーズにネイティブコードがC#から呼べるようになります。すごい簡単に。超便利。こりゃもうばんばんネイティブコード書きたくなりますね……！ただし書くコードはRustのみ対応です。いや、別にRustでいいでしょ、Rustはいいぞ……！</p>
<p>しかしまず前提として言っておくと、ネイティブコードは別に偉くもなければ、必ず速いというわけでもないので、極力書くのはやめましょう。C#で書くべき、です。高速なコードが欲しければ、ネイティブコードに手を出す前にC#で速くすることを試みたほうがずっと良いです。C#は十分高速に書くことのできる言語です！ネイティブコードを書くべきでない理由は山ほどありますが、私的に最大の避けたい理由はクロスプラットフォームビルドで、今の世の中、ターゲットにしなければならないプラットフォーム/アーキテクチャの組み合わせは、普通にやっていても10を超えてしまいます。win/linux/osx/iOS/Android x x86/x64/arm。C#では .NET のランタイムやUnityが面倒見てくれますが、ネイティブコードの場合はこれを自前で面倒みていく必要があります。そこそこ面倒みてくれるはずのUnityだって辛いのに、それにプラスして俺々ビルド生態系を加えるのはかなり厳しいものがある。</p>
<p>とはいえ、C#をメインに据えつつもネイティブコードを利用すべきシチュエーションもあるにはあります。</p>
<ul>
<li>Android NDKや .NET unmanaged hosting APIなど、ネイティブAPIしか提供されていないものを使いたい場合</li>
<li>C で作られているネイティブライブラリを利用したい場合</li>
<li>ランタイムのライブラリの利用を避けたい場合、例えばUnityで .NET のSocket(Unityの場合 .NET のランタイムが古いのでパフォーマンスを出しにくい)を避けてネイティブのネットワークコードを書くのには一定の道理がある</li>
</ul>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/core/deploying/native-aot/">NativeAOT</a>という解決策もなくはないですが、まだそんなに現実的でもなければ、用途的にもこういうシチュエーションでは限定的でもあるので、そこは素直にネイティブコードを書いていくべき、でしょう。</p>
<p>そこでの最初の選択肢は当然C++なわけですが、いやー、C++のクロスプラットフォームビルドは大変だしなあ。となると、最近評判を聞く<a href="https://ziglang.org/ja/">Zig</a>はどうだろうか、と試してみました、が、撤退。目指すコンセプトは大変共感するところがあるのですが(FFIなしのCライブラリとの統合や、安全だけど複雑さを抑えた文法など)、まだ、完成度が、かなり、厳しい……。</p>
<p>で、最後の選択肢が<a href="https://www.rust-lang.org/ja">Rust</a>でした。FFIなしでの呼び出しではないものの<a href="https://crates.io/crates/cc">cc crate</a>や<a href="https://crates.io/crates/cmake">cmake crate</a>といったライブラリを使うと自然に統合されるし、<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>によるバインディングの自動生成はよく使われているだけあってめっちゃ安定して簡単に生成できます。ていうかZigが全然安定感なかった（シームレスなCとの統合とは……）ので雲泥の差でびっくりした。開発環境もまぁまぁ充実してるしコマンド体系も現代的。クロスプラットフォームビルドも容易！そして難しいと評判で避けていた言語面でも、いや、全然いいね。仕組みが理屈で納得できるし、C#とは文法面でもあまり離れていないので、全然すんなりと入れました。もちろん難しいところも多々ありますが、ラーニングカーブはそんなに急ではない、少なくとも最近のモダンC#をやり込んでる人なら全然大丈夫でしょう……！</p>
<p>と、いうわけで、しかし主な用途はC#からの利用で、特にCライブラリの取り込みにRustを使おうと決めたわけですが、C#に対して公開するためのコードが膨大でキツかったので、自動化したかったんですね。DllImportの自動化は<a href="https://www.swig.org/">SWIG</a>や<a href="https://github.com/mono/CppSharp">CppSharp</a>というのもありますが、普通のC++をそのまま持ってこようとする思想は、複雑なコードを吐いてしまったりで正直イマイチだな、と。</p>
<p>csbindgenは、まず、面倒なところをRustのbindgenに丸投げです。複雑なC(C++)のコードを解析対処にするから複雑になるのであって、bindgenによって綺麗なRustに整形してもらって、生成対象にするのはそうしたFFI向けに整理されたRustのみを対象にすることで、精度と生成コードの単純さを担保しました。自分でネイティブコードを書く場合も、RustはFFI不可能な型を公開しようとすると警告も出してくれるので、必然的に生成しやすい綺麗なコードになっています。型もRustは非常に整理されているため、C#とマッピングしやすくなっています。C#もまた近年のnintや<code>delegate*</code>、.NET 6からの<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.clong">CLong</a>などの追加によって自然なやり取りができるようになりました。csbindgenはそれら最新の言語機能を反映することで、自然で、かつパフォーマンスの良いバインディングコードを生成しています。</p>
<h2>Getting Started</h2>
<p>コンフィグにビルド時依存に追加してもらって、<code>build.rs</code>というコンパイル前呼び出し(Rustのコードでpre-build書ける機能やビルド時依存を追加できる機能はとても良い)に設定を入れるだけです、簡単！</p>
<pre><code class="language-toml">[build-dependencies]
csbindgen = &quot;1.2.0&quot;
</code></pre>
<pre><code class="language-rust">// extern &quot;C&quot; fnが書かれているlib.rsを読み取って DllImport[&quot;nativelib&quot;]なコードを&quot;NativeMethods.g.cs&quot;に出力する
csbindgen::Builder::default()
    .input_extern_file(&quot;lib.rs&quot;)
    .csharp_dll_name(&quot;nativelib&quot;)
    .generate_csharp_file(&quot;../dotnet/NativeMethods.g.cs&quot;)
    .unwrap();
</code></pre>
<p>単純なコードを例に出すと、このx, yを受け取ってintを返す関数は</p>
<pre><code class="language-csharp">#[no_mangle]
pub extern &quot;C&quot; fn my_add(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>こういったC#コードを生成します。</p>
<pre><code class="language-csharp">// NativeMethods.g.cs
using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;nativelib&quot;;

        [DllImport(__DllName, EntryPoint = &quot;my_add&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int my_add(int x, int y);
    }
}
</code></pre>
<p>直感的で単純な出力です、逆にそれがいい、むしろそれがいい。生成に対応している型はプリミティブ以外にもstructやunion、enum、関数やポインターなどRustのFFIで流せる型のほとんどには対応しています。</p>
<p>また、Rustのbindgenやcc/cmake crateを併用すると、CのライブラリをC#に簡単に持ちこむことができます。例えば圧縮ライブラリの<a href="https://github.com/lz4/lz4">lz4</a>は、csbindgenでの生成の前にbindgenとccの設定も足してあげると</p>
<pre><code class="language-csharp">// lz4.h を読み込んで lz4.rs にRust用のbindingコードを出力する
bindgen::Builder::default()
    .header(&quot;c/lz4/lz4.h&quot;)
    .generate().unwrap()
    .write_to_file(&quot;lz4.rs&quot;).unwrap();

// cc(C Compiler)によってlz4.cを読み込んでコンパイルしてリンクする
cc::Build::new().file(&quot;lz4.c&quot;).compile(&quot;lz4&quot;);

// bindgenの吐いたコードを読み込んでcsファイルを出力する
csbindgen::Builder::default()
    .input_bindgen_file(&quot;lz4.rs&quot;)
    .rust_file_header(&quot;use super::lz4::*;&quot;)
    .csharp_entry_point_prefix(&quot;csbindgen_&quot;)
    .csharp_dll_name(&quot;liblz4&quot;)
    .generate_to_file(&quot;lz4_ffi.rs&quot;, &quot;../dotnet/NativeMethods.lz4.g.cs&quot;)
    .unwrap();
</code></pre>
<p>これでC#から呼び出せるコードが簡単に生成できます。ビルドもRustで <code>cargo build</code> するだけでCのコードがリンクされてDLLに含まれています。</p>
<pre><code class="language-csharp">// NativeMethods.lz4.g.cs

using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;liblz4&quot;;

        [DllImport(__DllName, EntryPoint = &quot;csbindgen_LZ4_compress_default&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int LZ4_compress_default(byte* src, byte* dst, int srcSize, int dstCapacity);

        // snip...
    }
}
</code></pre>
<p>試してもらうと、本当に簡単にCライブラリが持ち込みができて感動します。Rustやbindgenがとにかく偉い。</p>
<p>csbindgenはUnityでの利用も念頭においているので、よくあるiOSでのIL2CPPだけ __Internal にしたいみたいなシチュエーションでも</p>
<pre><code class="language-csharp">#if UNITY_IOS &amp;&amp; !UNITY_EDITOR
    const string __DllName = &quot;__Internal&quot;;
#else
    const string __DllName = &quot;nativelib&quot;;
#endif
</code></pre>
<p>といったような生成ルールの変更がコンフィグに含めてあります。とても実用的で気が利いてます。</p>
<h2>LibraryImport vs DllImport</h2>
<p>.NET 7から<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke-source-generation">LibraryImport</a>という新しい呼び出しのためのソースジェネレーターが追加されました。これはDllImportのラッパーになっていて、DllImportは、本来ネイティブコードとやり取りできない型(例えば配列や文字列などの参照型はC#のヒープ上に存在するもので、ネイティブ側に渡せない)を裏で自動的にやってくれるという余計なお世話が含まれていて、それがややこしさや性能面、そしてNativeAOTビリティの欠如などの問題を含んでいたので、そういう型が渡された場合はLibraryImportの生成するC#コードで吸収した上で、byte* としてDllImportに渡すようなラッパーが生成されるようになっています。</p>
<p>つまり余計なお世話をする本来ネイティブコードとやり取りできない型を生成しないようにすればDllImportでも何の問題もないので、今回はDllImportでの生成を選んでいます。そのほうがUnityでも使いやすいし。</p>
<p>Win32のAPIをDllImportで簡単に呼び出せるようにするために暗黙的な自動変換を多数用意しておく、というのは時代背景的には理解できます。C#がWindowsのためだけの言語であり、時折Win32 APIの呼び出しが必須なこともあったのは事実であり、便利な側面もあったでしょう。しかし現在はWindowsのためだけの言語でもなく、またWin32 APIの呼び出しに関しては<a href="https://github.com/microsoft/CsWin32">CsWin32</a>というSource Generatorを活用した支援も存在します。</p>
<p>もう現代では、そうしたDllImportの古い設計を引きずって考える必要はない、頼るべきではないでしょう。つまり参照型を渡したり[In]や[Out]は使うべきではないし、変換を考慮した設計を練る必要もありません。実際 .NET 7ではそうしたDllImportの機能を使うとエラーにする<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.disableruntimemarshallingattribute">DisableRuntimeMarshallingAttribute</a>が追加されました。</p>
<p>ポインターに関しても今はあまり忌避するものではないと思っています。そもそもネイティブとの通信はunsafeだし、Spanによって比較的使いやすい型に変換することも容易なので。中途半端に隠蔽するぐらいなら、DllImportするレイヤーではポインターはポインターとして持っておきましょう。C#として使いやすくするのは、その外側できっちりやればいい話です、DllImportで吸収するものではない。というのが今風の設計思想であると考えています。なんだったら私はIntPtrよりvoid*のほうが好きだよ。</p>
<h2>コールバックの相互受け渡し</h2>
<p>C# -&gt; Rust あるいは Rust -&gt; C# でコールバックを渡し合ってみましょう。まずRust側はこんな風に書くとします。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn csharp_to_rust(cb: extern &quot;C&quot; fn(x: i32, y: i32) -&gt; i32) {
    let sum = cb(10, 20); // invoke C# method
    println!(&quot;{sum}&quot;);
}

#[no_mangle]
pub extern &quot;C&quot; fn rust_to_csharp() -&gt; extern fn(x: i32, y: i32) -&gt; i32 {
    sum // return rust method
}

extern &quot;C&quot; fn sum(x:i32, y:i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>C#のメソッドを受け取ったら、それを読んで表示(println)するだけ、あるいは足し算する関数をC#に渡すだけ、のシンプルなメソッドです。生成コードは以下のようなものになります。</p>
<pre><code class="language-csharp">[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(delegate* unmanaged[Cdecl]&lt;int, int, int&gt; cb);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern delegate* unmanaged[Cdecl]&lt;int, int, int&gt; rust_to_csharp();
</code></pre>
<p><code>delegate* unmanaged[Cdecl]&lt;int, int, int&gt;</code> というのは、あまり見慣れない定義だと思うのですが、C# 9.0から追加された本物の<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers">関数ポインター</a>になります。定義を手書きするのは少しややこしいですが、自動生成されるので特に問題なしでしょう（？）。使い勝手はかなりよく、普通の静的メソッドのように扱えます。</p>
<pre><code class="language-csharp">// ネイティブ側に渡したい静的メソッドはUnmanagedCallersOnlyを付ける必要がある
[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
static int Sum(int x, int y) =&gt; x + y;

// &amp;で関数ポインターを取得して渡す
NativeMethods.csharp_to_rust(&amp;Sum);

// Rustからdelegate*を受け取る
var f = NativeMethods.rust_to_csharp();

// 受け取った関数ポインターは普通に呼び出せる
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>インスタンスメソッドを渡せないのか？というと渡せません。Cとの相互運用にそんなものはない。どうでもいい勝手な変換はしなくていい。第一引数にコンテキスト(void*)を受け取るコードを用意しておけばいいでしょう。</p>
<p>ところで、UnityもC# 9.0対応、しているし関数ポインターも使えるには使えるのですが、<a href="https://docs.unity3d.com/ja/2021.3/Manual/CSharpCompiler.html">Extensible calling conventions for unmanaged function pointers is not supported</a>です。UnmanagedCallersOnlyAttributeもないしね。Unity Editor上では普通に動いちゃったりとかしますが、IL2CPPでは動かないのでちゃんと対応しましょう。csbindgenでは <code>csharp_use_function_pointer(false)</code> というオプションを設定すると、従来のデリゲートを使用したコードを出力します。</p>
<pre><code class="language-csharp">// csharp_use_function_pointer(false) の場合の出力結果、専用のデリゲートを一緒に吐き出すようになる
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int csharp_to_rust_cb_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(csharp_to_rust_cb_delegate cb);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int rust_to_csharp_return_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern rust_to_csharp_return_delegate rust_to_csharp();

// MonoPInvokeCallback属性を静的メソッドにつける(typeofでデリゲートを設定)
[MonoPInvokeCallback(typeof(NativeMethods.csharp_to_rust_cb_delegate))]
static int Sum(int x, int y) =&gt; x + y;

// そのまま渡す
NativeMethods.csharp_to_rust(Method);

// 受け取る関数ポインターに関しては .NET の場合と一緒
var f = NativeMethods.rust_to_csharp();
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>面倒くさい専用のデリゲートも同時に出力してくれるので、定義はそこそこ楽になります（Action/Funcといった汎用デリゲートを使うと場合によりクラッシュしてしまったので、必ずそれぞれのパラメーター専用のデリゲートを出力するようにしています）。概ねcsbindgenがよしなに動くように面倒見てあげるので、属性の違いだけ考えればほぼ問題はありません。</p>
<h2>コンテキスト</h2>
<p>多値返しみたいなのは、普通にStructを作ってくださいという話になって、その場合は、C#側でStructはコピーされて、Rust側のメモリからはすぐ消えるということになります。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn return_tuple() -&gt; MyTuple {
    MyTuple { is_foo: true, bar: 9999 }
}

#[repr(C)]
pub struct MyTuple {
    pub is_foo: bool,
    pub bar: i32,
}
</code></pre>
<p>もう少し寿命を長く、返却するStructをポインターで返して状態を持ちたい、という場合はRust的には少し工夫が必要です。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_context() -&gt; *mut Context {
    let ctx = Box::new(Context { foo: true });
    Box::into_raw(ctx)
}

#[no_mangle]
pub extern &quot;C&quot; fn delete_context(context: *mut Context) {
    unsafe { Box::from_raw(context) };
}

#[repr(C)]
pub struct Context {
    pub foo: bool,
    pub bar: i32,
    pub baz: u64
}
</code></pre>
<pre><code class="language-csharp">// C#側、Context*を受け取って
var context = NativeMethods.create_context();

// なにか色々したりずっと持っていたり

// 最後に明示的にfreeしにいく
NativeMethods.delete_context(context);
</code></pre>
<p><code>Box::new</code> でヒープ上にデータを確保して、<code>Box::into_raw</code>でRust上でのメモリ管理から外します。Rustは通常だとスコープが外れると即座にメモリを返却する、のですが、寿命をRust管理外のC#に飛ばすので、素直に（？）unsafeにRust上の管理から外してしまうのが普通に素直でしょう。Rust側で確保しているメモリを開放する場合は、<code>Box::from_raw</code>でRust上の管理に戻します。そうするとスコープが外れたらメモリ返却という通常の動作をして、返却が完了します。</p>
<p>この辺はRustだから難しい！という話ではなく、C#でもfixedスコープを外れてポインタを管理したい場合には <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して手動でunsafeな管理しなければいけないので、完全に同じ話です。そう考えると、むしろ素直にC#と変わらない話でいいですね。</p>
<p>なお、C#上でこうしたコンテキストの管理をする場合に専用のSafeHandleを作って、それにラップするという流儀がありますが、大仰で、基本的にはそこまでやる必要はないと思ってます。No SafeHandle。そもそも境界越えというunsafeなことをしているのだから、最後まで自己責任でいいでしょう。</p>
<p>csbindgenは戻り値にstructが指定されていると、C#側にも同様のものを生成しに行ってしまいますが、Rust内だけで使うのでC#側には内容公開したくない、というか参照(Box)とかも含まれてるから公開できないし、みたいな場合もあると思います。その場合は <code>c_void</code> を返してください。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_counter_context() -&gt; *mut c_void {
    let ctx = Box::new(CounterContext {
        set: HashSet::new(),
    });
    Box::into_raw(ctx) as *mut c_void // voidで返す
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn insert_counter_context(context: *mut c_void, value: i32) {
    let mut counter = Box::from_raw(context as *mut CounterContext); // as で型を戻す
    counter.set.insert(value);
    Box::into_raw(counter); // contextを使い続ける場合はinto_rawを忘れないように
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn delete_counter_context(context: *mut c_void) {
    let counter = Box::from_raw(context as *mut CounterContext);
    for value in counter.set.iter() {
        println!(&quot;counter value: {}&quot;, value)
    }
}

// C#側には公開しない
pub struct CounterContext {
    pub set: HashSet&lt;i32&gt;,
}
</code></pre>
<pre><code class="language-csharp">// C#側では ctx = void* として受け取る
var ctx = NativeMethods.create_counter_context();
    
NativeMethods.insert_counter_context(ctx, 10);
NativeMethods.insert_counter_context(ctx, 20);

NativeMethods.delete_counter_context(ctx);
</code></pre>
<p>この辺、<code>PhantomData&lt;T&gt;</code>を使って格好良く処理する手法も一応あるんですが、正直複雑になるだけなので、素直に <code>void*</code> ベースでやり取りする、に倒したほうがむしろ健全でいいのではと思っています。どっちにしろunsafeな処理してるんだから素直にunsafeな業を受け入れるべき！</p>
<h2>Stringと配列のマーシャリング</h2>
<p>Stringと配列は、C#とRustでそれぞれ構造が違うので、そのままやり取りはできません。ポインタと長さ、つまりC#でいうところのSpanのみがやり取りできます。Span的な処理をするだけならゼロコピーですが、Stringや配列に変換したくなったら、C#とRust、どちらの側でも新規のアロケーションが発生します。これはネイティブコードを導入することの弱みで、Pure C#で通したほうが融通が効く（或いはパフォーマンスに有利に働く）ポイントですね。まあ、ともあれ、つまり基本はSpanです。DllImport上でStringを受けたり配列を受けたりしてはいけません、その手の自動変換にゆだねてはダメ！アロケーションも自己責任で明示的に。</p>
<p>さて、まずは文字列ですが、こういったケースでやり取りする文字列の種類は3つ、UTF8とUTF16と<a href="https://ja.wikipedia.org/wiki/%E3%83%8C%E3%83%AB%E7%B5%82%E7%AB%AF%E6%96%87%E5%AD%97%E5%88%97">ヌル終端文字列</a>、です。UTF8はRustの文字列(RustのStringは<code>Vec&lt;u8&gt;</code>)、C#の文字列はUTF16、そしてCのライブラリなどはヌル終端文字列を返してくることがあります。</p>
<p>今回は例なので明示的にRust上でヌル終端文字列を返してみます。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_c_string() -&gt; *mut c_char {
    let str = CString::new(&quot;foo bar baz&quot;).unwrap();
    str.into_raw()
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_c_string(str: *mut c_char) {
    unsafe { CString::from_raw(str) };
}
</code></pre>
<pre><code class="language-csharp">// null-terminated `byte*` or sbyte* can materialize by new String()
var cString = NativeMethods.alloc_c_string();
var str = new String((sbyte*)cString);
NativeMethods.free_c_string(cString);
</code></pre>
<p>C#上では new Stringでポインタ(<code>sbyte*</code>)を渡すとヌル終端を探してStringを作ってくれます。明示的にアロケーションしているという雰囲気がいいですね。ポインタはこの場合Rustで確保したメモリなので、C#のヒープ上にコピー（新規String作成）したなら、即返却してやりましょう。</p>
<p>Rustで確保したUTF8、byte[]、あるいはint[]などとにかく配列全般の話はもう少し複雑になってきます。Rustでの配列的なもの(<code>Vec&lt;T&gt;</code>)をC#に渡すにあたっては、ポインタと長さをC#に渡せばOKといえばOKなのですが、解放する時にそれだけだと困ります。<code>Vec&lt;T&gt;</code>の実態はポインタ、長さ、そしてキャパシティの3点セットになっているので、この3つを渡さなきゃいけないのですね。そして、都度3点セットを処理するのも面倒です、Rust的なメモリ管理を外したり戻したりの作業もあるし。</p>
<p>というわけでちょっと長くなりますが以下のようなユーティリティーを用意しましょう。これの元コードは(元)Rustの開発元であるMozillaのコードなので安全安心です……！</p>
<pre><code class="language-rust">#[repr(C)]
pub struct ByteBuffer {
    ptr: *mut u8,
    length: i32,
    capacity: i32,
}

impl ByteBuffer {
    pub fn len(&amp;self) -&gt; usize {
        self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;)
    }

    pub fn from_vec(bytes: Vec&lt;u8&gt;) -&gt; Self {
        let length = i32::try_from(bytes.len()).expect(&quot;buffer length cannot fit into a i32.&quot;);
        let capacity = i32::try_from(bytes.capacity()).expect(&quot;buffer capacity cannot fit into a i32.&quot;);

        // keep memory until call delete
        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr(),
            length,
            capacity,
        }
    }

    pub fn from_vec_struct&lt;T: Sized&gt;(bytes: Vec&lt;T&gt;) -&gt; Self {
        let element_size = std::mem::size_of::&lt;T&gt;() as i32;

        let length = (bytes.len() as i32) * element_size;
        let capacity = (bytes.capacity() as i32) * element_size;

        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr() as *mut u8,
            length,
            capacity,
        }
    }

    pub fn destroy_into_vec(self) -&gt; Vec&lt;u8&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let capacity: usize = self.capacity.try_into().expect(&quot;buffer capacity negative or overflowed&quot;);
            let length: usize = self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;);

            unsafe { Vec::from_raw_parts(self.ptr, length, capacity) }
        }
    }

    pub fn destroy_into_vec_struct&lt;T: Sized&gt;(self) -&gt; Vec&lt;T&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let element_size = std::mem::size_of::&lt;T&gt;() as i32;
            let length = (self.length * element_size) as usize;
            let capacity = (self.capacity * element_size) as usize;

            unsafe { Vec::from_raw_parts(self.ptr as *mut T, length, capacity) }
        }
    }

    pub fn destroy(self) {
        drop(self.destroy_into_vec());
    }
}
</code></pre>
<p>Box::into_raw/from_rawのVec版という感じで、from_vecしたタイミングでメモリ管理から外すのと、destroy_into_vecするとメモリ管理を呼び側に戻す（何もしなければスコープを抜けて破棄される）といったような動作になっています。これはC#側でも(csbindgenによって)定義が生成されているので、メソッドを追加してやります。</p>
<pre><code class="language-csharp">// C# side span utility
partial struct ByteBuffer
{
    public unsafe Span&lt;byte&gt; AsSpan()
    {
        return new Span&lt;byte&gt;(ptr, length);
    }

    public unsafe Span&lt;T&gt; AsSpan&lt;T&gt;()
    {
        return MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;T&gt;(ptr), length / Unsafe.SizeOf&lt;T&gt;());
    }
}
</code></pre>
<p>これでByteBuffer*で受け取ったものを即Spanに変換できるようになりました！というわけで、Rust上の通常のstring、byte[]、それとint[]の例を見てみると</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_string() -&gt; *mut ByteBuffer {
    let str = format!(&quot;foo bar baz&quot;);
    let buf = ByteBuffer::from_vec(str.into_bytes());
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_string(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need String, use String::from_utf8_unchecked(buf.destroy_into_vec()) instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;u8&gt; = vec![1, 10, 100];
    let buf = ByteBuffer::from_vec(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;u8&gt;, use buf.destroy_into_vec() instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_i32_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;i32&gt; = vec![1, 10, 100, 1000, 10000];
    let buf = ByteBuffer::from_vec_struct(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_i32_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;i32&gt;, use buf.destroy_into_vec_struct::&lt;i32&gt;() instead.
    buf.destroy();
}
</code></pre>
<p>ByteBuffer自体の管理を外す(into_raw)が必要なのと、from_rawで戻したあとの中身のByteBufferもdestoryかinto_vecしなきゃいけないという、入れ子の管理になっているというのが紛らわしくて死にそうになりますが、ソウイウモノということで諦めましょう……。Drop traitを実装しておくことでクリーンナップ側の処理はもう少しいい感じにできる余地がありますが、Drop traitを実装しないことの理由もそれなりにある（と、Mozillaが言っている）ので、トレードオフになっています。</p>
<p>C#側では、とりあえずAsSpanして、あとはよしなにするという感じですね。</p>
<pre><code class="language-csharp">var u8String = NativeMethods.alloc_u8_string();
var u8Buffer = NativeMethods.alloc_u8_buffer();
var i32Buffer = NativeMethods.alloc_i32_buffer();
try
{
    var str = Encoding.UTF8.GetString(u8String-&gt;AsSpan());
    Console.WriteLine(str);

    Console.WriteLine(&quot;----&quot;);

    var buffer = u8Buffer-&gt;AsSpan();
    foreach (var item in buffer)
    {
        Console.WriteLine(item);
    }

    Console.WriteLine(&quot;----&quot;);

    var i32Span = i32Buffer-&gt;AsSpan&lt;int&gt;();
    foreach (var item in i32Span)
    {
        Console.WriteLine(item);
    }
}
finally
{
    NativeMethods.free_u8_string(u8String);
    NativeMethods.free_u8_buffer(u8Buffer);
    NativeMethods.free_i32_buffer(i32Buffer);
}
</code></pre>
<p>Rust側で確保したメモリはRust側で解放する！という基本に関しては忠実に守っていきましょう。この例だとC#側で処理したら即解放なので、いい感じにしてくれよ、なんだったらDllImportで暗黙的に自動処理最高、みたいな気になるかもしれませんが、もう少し長寿命で持つケースもあるので、やはりマニュアルでちゃんと解放していきましょう。ていうか暗黙的なアロケーションは一番最悪じゃないです？？？</p>
<p>最後に、C#で確保したメモリをRust側で使う場合の例をどうぞ。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_string(utf16_str: *const u16, utf16_len: i32) {
    let slice = std::slice::from_raw_parts(utf16_str, utf16_len as usize);
    let str = String::from_utf16(slice).unwrap();
    println!(&quot;{}&quot;, str);
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_utf8(utf8_str: *const u8, utf8_len: i32) {
    let slice = std::slice::from_raw_parts(utf8_str, utf8_len as usize);
    let str = String::from_utf8_unchecked(slice.to_vec());
    println!(&quot;{}&quot;, str);
}


#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_bytes(bytes: *const u8, len: i32) {
    let slice = std::slice::from_raw_parts(bytes, len as usize);
    let vec = slice.to_vec();
    println!(&quot;{:?}&quot;, vec);
}
</code></pre>
<pre><code class="language-csharp">var str = &quot;foobarbaz:あいうえお&quot;; // JPN(Unicode)
fixed (char* p = str)
{
    NativeMethods.csharp_to_rust_string((ushort*)p, str.Length);
}

var str2 = Encoding.UTF8.GetBytes(&quot;あいうえお:foobarbaz&quot;);
fixed (byte* p = str2)
{
    NativeMethods.csharp_to_rust_utf8(p, str2.Length);
}

var bytes = new byte[] { 1, 10, 100, 255 };
fixed (byte* p = bytes)
{
    NativeMethods.csharp_to_rust_bytes(p, bytes.Length);
}
</code></pre>
<p>std::slice::from_raw_partsでSliceを作って、あとはよしなに処理したいことをします。関数を超えて長い寿命を持たせたいならコピー(String作りなりVec作るなり)は必須になってきます。Rust側で確保したメモリはRust側で解放する、のと同じように、C#側で確保したメモリはC#側で解放する、のが重要です。C#の場合はfixedスコープを抜けて参照を持っていない場合は、そのうちGCが処理してくれるでしょう、といった話ですね。</p>
<p>なお、fixedを超えてC#でもう少し長い寿命で持ち回したいときは <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して持ち回します。</p>
<h2>Rust for C# Developer</h2>
<p>Rustは、正直すごい気に入ってます。C#の次に気に入りました……！まぁ正直、これで全部やる、Webもなにもかも作る、みたいなのはヤバいかな、と思います。RustでWebやりたいって人はあれでしょ、型がついてて開発環境が充実していてエコシステムが回ってる言語がいいんでしょ？ちょうどいい言語があるんですよ、C#という。……。ではあるんですが、ネイティブが必要って局面で、やりたくないーって逃げたり、NativeAOTがなんとかしてくれるだのといった現実逃避したりせず、ちゃんと正面から向き合えるようになったということはいいことです。</p>
<p>で、実際RustはかなりC#erに馴染む道具だと思っていて、そもそもインターフェイスがないかわりにstructとジェネリクスとtrait(インターフェイスみたいなやつ)で処理するってのは、別にそれC#でもやってますよ！C#のパフォーマンス最速パターンってstructにインターフェイス実装してジェネリクスの型制約でインターフェイス指定してボクシング/仮想メソッド呼び出し回避でstruct投げ込むことですからね。ようはC#の最速パターンだけが強制されてるんだと思えば何も違和感がない。</p>
<p>インスタンスメソッドがないかわりに全部拡張メソッドみたいな雰囲気なのも、いやー、C#も、もはやインスタンスメソッドと拡張メソッド、どっちで実装すればいいかなーって切り分けに悩むこともあるし、<a href="https://ufcpp.net/blog/2023/3/extensions/">C# 12候補のExtensions</a>なんてきたら完全にどこで実装すりゃいいのかわからんわ、ってなるので、拡張メソッド一択(impl, trait)ですよ、みたいなのはすっきり整理されていて逆にいい。</p>
<p>シンタックスも自然というかC系の多数派に寄り添った感じで親しみやすいし、ドットでメソッド繋げていくので、馴染み深いオブジェクト指向的な手触りが十分ある。それとミュータブルに寛容なところがいいですね。関数型にありがちなイミュータブル至上主義ではなく、どちらかというとメモリそこにあるんだからミュータブルやろ、みたいな雰囲気なのがとてもいい。無駄もないし。所有権周りが厳密なのでミュータブルであっても固めな手応えなのは、これでいいんだよというかこれで的な何かではある。</p>
<p>マクロはコンパイル時ExpresionTreeみたいなもので、proc-macroはSource Generatorみたいなものなので、何が可能になるかすぐに理解できるし、便利さもよくわかる。ていうかコンパイル時ExpressionTreeはC#にも欲しい（実行時だからコスト重いのであんま使わないのでコンパイル時に解決するならもっとばんばん使えるはずなんだよねえ）。ただ、自由度がとても高いせいでマクロに入ると入力補完が完全に効かなくなる。そして自由度が高いのでマクロでDSL的な流れに高級ライブラリほどなりがちで、完全にマニュアル引きが必要になってくるのが、見た目はキレイにおさまるけど書き味はよくないな、的な体感になるのがもったいない。その点でいうとC#はやっぱ入力補完最優先な言語で、一貫した安定感を提供しているのはとても良いですね。</p>
<p>キツいかなーと思うのは所有権がどうとかっていうよりも、ジェネリクスの見た目がキツい。C#だったらインターフェイスで動的ディスパッチで整理されているものが、ジェネリクスで静的ディスパッチに倒れているのでジェネリクスの出現率がめっちゃ高い。いや、だってC#でもジェネリクスでると読みやすさ的には一段落下がるわけじゃないですか、それが当たり前って感じだと、慣れとかって問題じゃなく見やすさレベルは下がる。更にその上にジェネリクスがネストするのが当たり前。C#だったらジェネリクスがネストしてるのは見やすさレベル最底辺なので極力出現しないようにしたいって感じなのですが、Rustだと日常茶飯事に出てくる。<code>Option&lt;Rc&lt;RefCell&lt;_&gt;&gt;&gt;</code>とかも全然普通に出現するのが、うーむ。理屈では納得いくから特に文句があるようでなにもないんですが。</p>
<p>なんだったらパターンマッチも別に好きじゃないしOptionもResultも好きじゃないしnullの何が悪いんだよぐらいの気持ちにならなくもないんですが、まぁそれはそれ。でも全体的には凄い良いですね、ほんと。</p>
<h2>まとめ</h2>
<p>ところで<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>のReadMeのほうには更にもっといっぱい変換パターンを紹介していますので、是非そちらもチェックしてみてください。</p>
<p>ネイティブ呼び出しは定義の部分でも、二重定義がそもそもダルいうえに、かなり気を使わなきゃいけないことがなにげに多くて割と大変というか知識量と単純作業量を要求してくるのですが、csbindgenはその部分を完全自動化してくれます。自分でも使っててネイティブコードめっちゃ楽……！という気になります。事実楽。すごい。その後のメモリ管理に関しては、そこはまぁ思う存分悩んでくれという話になるのですが、もはや複雑な点がそれだけに落ち着いたという点では、やはり革命的に便利なのでは？という気になります。</p>
<p>Cのライブラリを持ってくるのも圧倒的に楽なので、私の中でもちょっと考え方が変わってきました。今までは割とPure C#実装至上主義、みたいなところがあったんですが、うまい切り分け、使い分けみたいなのを考えられるようになりました。そして、Cライブラリ利用がより自由になると、まさに<a href="https://cysharp.co.jp/">Cysharp</a>の掲げる「C#の可能性を切り開いていく」ことにまた一つ繋がってしまったな、と。</p>
<p>まずはこの後に数個、csbindgenを活用したC#ライブラリを提供する予定があります！のですが、その前に、Rustかー、とは思わずに是非csbindgen、試してみてもらえると嬉しいです。</p>
</div>
<h1><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></h1>
<ul class="date"><li>2023-01-30</li></ul>
<div class="entry_body"><p>ついこないだの<a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a>は、SoAになってるとSIMDを適用しやすいよ、という話だったのですが、そもそもSIMD手書きはカジュアルにやらないし、気合い入れてSIMD書くシチュエーションなら構造も気合い入れて専用に設計するよなぁ。と、なると、カジュアルにSIMD使えるライブラリが必要で、まぁLINQですね、と。</p>
<ul>
<li><a href="https://github.com/Cysharp/SimdLinq">Cysharp/SimdLinq</a></li>
</ul>
<p>これを入れると別にSoA関係なく、SIMDが適用できる状態(例えばint[]にSum)だと、自動的にSIMDが適用されるようになります。そして、実際めちゃくちゃ速い。</p>
<p><img src="https://user-images.githubusercontent.com/46207/215410106-b68d8567-5abf-4aa4-a050-a803b1913187.png" alt="" /></p>
<p>SIMDとLINQの組み合わせが威力を発揮するというのは、別に新しいことではなく、そもそも .NET 7でも<a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#linq">Performance Improvements in .NET 7 LINQ</a>で、幾つかのメソッドが内部でSIMD化されて高速化されていることが発表されています。しかし、 .NET 7のSIMD対応は非常に限定的なもので、具体的には<code>int[]</code>の<code>Average</code>,<code>Min</code>,<code>Max</code>、それと<code>long[]</code>の<code>Min</code>,<code>Max</code>だけです。これには理由はなくはないのですが、本来SIMD対応できる範囲はもっと広いため、これでは非常にもったいない。</p>
<p>SimdLinqを適用できるメソッドは <code>Sum</code>, <code>Average</code>, <code>Min</code>, <code>Max</code>, <code>MinMax</code>, <code>Contains</code>, <code>SequenceEqual</code>、要素の型は <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code> int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code>、コレクションの型は <code>T[]</code>, <code>List&lt;T&gt;</code>, <code>Span&lt;T&gt;</code>, <code>ReadOnlySpan&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, <code>ReadOnlyMemory&lt;T&gt;</code> と理屈上SIMD化できるものを全て詰め込みました。特に<code>Span&lt;T&gt;</code>/<code>ReadOnlySpan&lt;T&gt;</code>は通常のLINQでは使えない（メソッドが定義されていない）ので、有益です。また、Min, Maxを同時に取得する<code>MinMax</code>というメソッドを独自に追加しています。</p>
<p>専用メソッドを呼ばせる（例えば<code>SumSimd()</code>とか)ようでは使いにくいと思ったので、現在のコードを何も弄らずとも、ライブラリ参照してglobal usingを設定すれば、全ての適用可能なメソッドに自動適用される仕組みにしました。これは同名メソッドを定義して、具象型のほうにオーバーロード解決が優先採用されることを利用しています。</p>
<h2>使い方</h2>
<p>なので、使い方もなにもなく、usingすれば勝手にSimdLinqになって高速化されます。</p>
<pre><code class="language-csharp">using SimdLinq; // enable SimdLinq extension methods

var array = Enumerable.Range(1, 100000).ToArray();

var sum = array.Sum(); // used SimdLinqExtensions.Sum
</code></pre>
<p>using忘れちゃうというのはあるので、そこでglobal usingです。csprojに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Using Include=&quot;SimdLinq&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>というのを仕込んでやれば、SimdLinqが使える場合はSimdLinqに、そうじゃないものは普通のLinqでオーバーロードが解決されるようになります。便利。</p>
<p>具体的にSimdLinqが適用されるメソッドは以下のものになります。</p>
<ul>
<li><code>Sum</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>LongSum</code> for <code>int</code>, <code>uint</code></li>
<li><code>Average</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Min</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Max</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>MinMax</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Contains</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>SequenceEqual</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
</ul>
<h2>互換性と安全性</h2>
<p>.NET 7の標準に、このSimdLinqのようなアグレッシブなSIMD化が入らなかった理由は、互換性と安全性になります。え、安全じゃないの？というと怖くなるので、何が違うのかはしっかり把握しておきましょう。別に危険、というわけではないですが。</p>
<p>まずSumとAverage(Averageの中身はSumしたのをLengthで割るだけなので中身は実質Sum)ですが、LINQのSumはcheckedで、オーバーフローすると例外を吐きます。SimdLinqはuncheckedです、つまりオーバーフローするとそのままオーバーフローしたまま結果を返します。checkedのほうが挙動としてはいいんですが、SIMD演算がオーバーフローのチェックできないので、SimdLinqではuncheckedとして提供しています。オーバーフローに関しては自己責任で。さすがにbyteのSumとかだとすぐオーバーフローしちゃうので、SimdLinqのSumは32 bit以上の要素にだけ提供しています、つまり<code>int</code>, <code>long</code>, <code>uint</code>, <code>ulong</code>, <code>double</code>, <code>float</code> です。そもそも元々のLINQのSum(引数なし)も<code>int</code>からなので、その辺は一緒ということで。</p>
<p>そうしたオーバーフローの危険性を避けたい場合、独自拡張として <code>LongSum</code> というlongを戻り値にするSumメソッドを追加しています。内部的にlongで処理するため、(若干性能は落ちますが)オーバーフローしなくなります。</p>
<p>float/doubleの扱いは挙動の違いが若干あります。まず、通常のLINQのMin, Maxは<code>NaN</code>をチェックしますがSimdLinqは<code>NaN</code>をチェックしません。<code>NaN</code>チェックがあったほうが丁寧ですが、SIMDでそれは入れずらい＆NaNが入ってくるケースってあまりないので現実的にすごい問題か、というとそうではないかな、と。</p>
<p>それとSumの場合に足し算の順序が変わって(LINQは前から順番に足しますが、SIMDだと並列に足すので)、浮動小数点演算だと足す順序が変わると微妙に誤差が出て同じ結果になりません。例えばLINQだと<code>1.5710588F</code>だけどSimdLinqだと<code>1.5710589F</code>になる、といったような違いが出てきます。結果としては別にどっちでも良い（ある意味で別にどっちも厳密にはあってない）と思いますが、結果の互換性がないですよ、ということは留意してください。</p>
<h2>まとめ</h2>
<p>高速なLINQのAlternativeって、結構あります。<a href="https://github.com/kevin-montrose/LinqAF">LinqAF</a>、<a href="https://github.com/jackmott/LinqFaster">LinqFaster</a>、<a href="https://github.com/NetFabric/NetFabric.Hyperlinq">NetFabric.Hyperlinq</a>など。ただ、どれも大仰なんですよね、StructのIteratorを作ってー、とか。専用メソッドを呼ぶためにラップするのも手間だし、その割に凄い効果的というほどでもないから、依存を増やす割にはメリットも薄くなので、私自身は使おうとはあまり思ってませんでした。</p>
<p>そこでSimdLinqではLINQ全体を高速化させることを狙っているわけではなくて、SIMDが適用できるものだけピンポイントに、そしてソースコードには一切手を入れる必要のない&quot;Drop-in replacement&quot;になるようにデザインしました。また、SIMDのみに絞ったことで性能面に明らかに圧倒的な差をだして、あえて使う理由を作る、といったところですね。</p>
<p>ついでにそうなると欲張ってどんどん適用できる箇所を増やしたい、つまりは<a href="https://github.com/Cysharp/StructureOfArraysGenerator">StructureOfArraysGenerator</a>だ、みたいなコンボも狙っています。エコシステム囲い込み！囲い込みはEvil！</p>
<p>そんなわけでSIMDシリーズ第一弾でした。今年はSIMD関連も幾つか出していくかもしれませんし、Source Generatorネタがめちゃくちゃ溜まってるので時間が無限大に必要です。まぁ、ともかくまずはSimdLinqを使って見てください！</p>
</div>
<h1><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></h1>
<ul class="date"><li>2023-01-27</li></ul>
<div class="entry_body"><p>最近はSource Generatorブームが続いていて、去年末に<a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a>という記事を出しましたが、まずは今年第一弾のSource Generatorライブラリです。</p>
<ul>
<li><a href="https://github.com/Cysharp/StructureOfArraysGenerator/">github.com/Cysharp/StructureOfArraysGenerator</a></li>
</ul>
<p>これは何かというと、structure of arrays(SoA)を使いやすくするためのコードを生成するというものです。まずそもそもSoAですが、Wikipediaの<a href="https://en.wikipedia.org/wiki/AoS_and_SoA">AoS and SoA</a>という記事によるところ（日本語版はない）、CPUキャッシュを有効活用したりSIMDを適用させやすくなる構造だよ、と。通常C#の配列はarray of structures(AoS)になります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png" alt="" /></p>
<p>上の通常の配列がAoSでXYZXYZXYZXYZといったように並んでいる構造ですが、下のStructureOfArraysGeneratorで生成したSoAの配列はXXXXYYYYZZZZという並び順になります。実際にシンプルなパフォーマンステスト（Vector3[10000]に対してYの最大値を求める）によるところ</p>
<p><img src="https://user-images.githubusercontent.com/46207/215027253-6f94739f-b827-46ba-a395-690d1df89d46.png" alt="" /></p>
<p>そのまま書いても2倍、SIMDで書きやすい状態なのでSIMDで処理してしまえば10倍高速化されます。というわけで、パフォーマンスが求められるシチュエーションで非常に有用です。</p>
<p>このライブラリはZigという最近、日本でも注目されている言語（Node.jsの高速な代替として注目されている<a href="https://bun.sh/">Bun</a>の実装言語）のMultiArrayListにインスパイアされました。Zigの作者 Andrew Kelley氏が講演した <a href="https://vimeo.com/649009599">A Practical Guide to Applying Data-Oriented Design</a> という素晴らしい講演があるので是非見て欲しいのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/215052372-1ab33bd2-a578-4c26-8e99-7615a49707ea.png" alt="image" /></p>
<p>データ指向設計(Data-Oriented Design)はパフォーマンスを飛躍的に改善する魔法なのです。ん、それはどこかで聞いたような……？そう、<a href="https://unity.com/ja/dots">UnityのDOTS</a>です。Data-Oriented Technology Stackです。ECSです。……。まぁ、そんなわけで全体に導入するにはそうとうガラッと設計を変える必要があるので大変厳しくはあるのですが、講演での実例としてZig自身のコンパイラの事例が出てますが、まぁつまりは徹底的にやれば成果は出ます。</p>
<p>しかしまぁ徹底的にやらず部分的に使っても効果があるのはUnityで Job System + Burst ぐらいでいいじゃん、という気持ちになっていることからも明らかです。というわけで部分的なSoA構造の導入にお使いください、かつ、導入や利用の敷居は全然高くないように設計しました。</p>
<h2>MultiArray</h2>
<p>NuGetからインストール（Unityの場合はgit参照か.unitypackageで）するとAnalyzerとして参照されます。StructureOfArraysGeneratorは属性も含めて依存はなく全てのコードが生成コードに含まれる（属性はinternal attributeとして吐かれる）ので、不要なライブラリ依存が増えることはありません。</p>
<p><code>[MultiArray(Type)]</code>を配列的に使いたい<code>readonly partial struct</code>につけます。</p>
<pre><code class="language-csharp">using StructureOfArraysGenerator;

[MultiArray(typeof(Vector3))]
public readonly partial struct Vector3MultiArray
{
}
</code></pre>
<p>するとSource Generatorは内部的にはこういうコードを生成します。</p>
<pre><code class="language-csharp">partial struct Vector3MultiArray
{
    // constructor
    public Vector3MultiArray(int length)

    // Span&lt;T&gt; properties for Vector3 each fields
    public Span&lt;float&gt; X =&gt; ...;
    public Span&lt;float&gt; Y =&gt; ...;
    public Span&lt;float&gt; Z =&gt; ...;

    // indexer
    public Vector3 this[int index] { get{} set{} }

    // foreach
    public Enumerator GetEnumerator()
}
</code></pre>
<p>Structure of <strong>Arrays</strong> と言ってますが、StructureOfArraysGeneratorは Arrays は生成しません。内部的には単一の <code>byte[]</code> と各開始地点のオフセットのみを持っていて、生成されるプロパティによって<code>Span&lt;T&gt;</code>のビューを返すという設計になっています。</p>
<p>使い方的には配列のように使えますが、<code>Span&lt;T&gt;</code>の操作、例えばref var item inによるforeachを使うと、より効率的に扱えます。</p>
<pre><code class="language-csharp">var array = new Vector3MultiArray(4);

array.X[0] = 10;
array[1] = new Vector3(1.1f, 2.2f, 3.3f);

// multiply Y
foreach (ref var item in v.Y)
{
    item *= 2;
}

// iterate Vector3
foreach (var item in array)
{
    Console.WriteLine($&quot;{item.X}, {item.Y}, {item.Z}&quot;);
}
</code></pre>
<p>Yに2倍を掛ける処理などは、メモリ領域が連続していることにより、<code>Vector3[]</code>を <code>item.Y *= 2</code> などとして書くよりも高速に処理されます．</p>
<p>他に<code>List&lt;T&gt;</code>のようにAddできる<code>MultiArrayList</code>や、内部的には<code>byte[]</code>を持っているだけであることを生かした<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での超高速なシリアライズなどにも対応しています。気になったら是非ReadMeのほうを見てください。</p>
<h2>.NET 7 時代のSIMD</h2>
<p>.NETはSIMD対応が進んでいて、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.x86">System.Runtime.Intrinsics.X86</a>によって、直接ハードウェア命令を書くことが出来ます。</p>
<p>しかし、しかしですね、最近は .NET を Arm で動かすことが現実的になってきました。iOSやAndroidでけはなくMacのArm化、そしてAWS GravitonのようなArmサーバーはコスト面でも有利で、選択肢に十分入ります。そこでAvx.Addなんて書いていたらArmで動きません。勿論 <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.arm">System.Runtime.Intrinsics.Arm</a> というクラスも公開されていて、Arm版のSIMDを手書きすることもできるんですが、分岐して似たようなものを二個書けというのか！という話です。</p>
<p>そこで、 <a href="https://zenn.dev/pcysl5edgo/articles/d3e787599c5c8b">.NET 7こそがC# SIMDプログラミングを始めるのに最適である理由</a> という記事があるのですが、確かに .NET 7 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256.loadunsafe">Vector256.LoadUnsafe</a> がまずめちゃくくちゃイイ！馴染みが深い（？）Unsafeによる ref var T で書けます！そして<a href="https://github.com/dotnet/runtime/issues/49397">Expose cross-platform helpers for Vector64, Vector128, and Vector256</a>により、<code>Vector64/128/256&lt;T&gt;</code>にプラットフォーム抽象化されたSIMD処理が書けるようになりました、やはり .NET 7から。</p>
<p>例えば .NET 7 でint[]のSumのSIMD化を書いてみます。</p>
<pre><code class="language-csharp">var array = Enumerable.Range(1, 100).ToArray();

ref var begin = ref MemoryMarshal.GetArrayDataReference(array);
ref var last = ref Unsafe.Add(ref begin, array.Length);

var vectorSum = Vector256&lt;int&gt;.Zero;
ref var current = ref begin;

// Vector256で処理できるだけ処理
ref var to = ref Unsafe.Add(ref begin, array.Length - Vector256&lt;int&gt;.Count);
while (Unsafe.IsAddressLessThan(ref current, ref to))
{
    // 直接足し算できて便利
    vectorSum += Vector256.LoadUnsafe(ref current);
    current = ref Unsafe.Add(ref current, Vector256&lt;int&gt;.Count);
}

// Vector256をintに戻す
 var sum = Vector256.Sum(vectorSum);

// 残りの分は単純処理
while (Unsafe.IsAddressLessThan(ref current, ref last))
{
    sum += current;
    current = ref Unsafe.Add(ref current, 1);
}

Console.WriteLine(sum); // 5050
</code></pre>
<p>まぁforがwhileのアドレス処理になっていたり、最後にはみ出た分を処理する必要がありますが、かなり自然にSIMDを扱えているといってもいいんじゃないでしょうか。(Unsafeに慣れていれば)かなり書きやすいです。いいね。</p>
<p>ところで .NET 7からLINQがSIMD対応してるからこんなの書く必要ないでしょ？というと、対応してません。LINQのSIMDはint[]のAverage, int[]のMin, Max, long[]のMin, Maxのみと、かなり限定的です。これは互換性の問題などなどがあり、まぁオマケみたいなものだと思っておきましょう。必要な局面があるなら自分で用意する方が無難です。</p>
<p>ともあれ、.NET 7 からは手書きX86 SIMDはArm対応が漏れやすいので、極力Vectorによって抽象化されたコードで書きましょう、ということになります。どうしてもVectorじゃ書けないところだけ、仕方なく書くという感じですね。</p>
<h2>まとめ</h2>
<p>反響全然ないだろうなあと想定していましたが、やはり反響全然ないです！まぁでも結構面白いライブラリになったと思うので、是非使ってください。それと、Incremental Source Generatorの作り方がMemoryPackの頃よりも習熟していて、コードがかなり洗練されたものになっているので、Source Generatorの作り方として参照するならMemoryPackのコードよりもこちらのコードのほうがお薦めです。</p>
<p>というわけで、まだまだSource Generatorネタはいっぱいあるので、今年は大量に量産します！</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
