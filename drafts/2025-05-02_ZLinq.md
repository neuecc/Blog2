# ZLinq

[ZLinq](https://github.com/Cysharp/ZLinq) v1を先月リリースしました！structとgenericsベースで構築することによりゼロアロケーションを達成しています。またLINQ to Span, LINQ to SIMD, LINQ to Tree(FileSystem, JSON, GameObject, etc.)といった拡張要素と、任意の型のDrop-in replacement Source Generator。そして.NET Standard 2.0, Unity, Godotなどの多くのプラットフォームサポートまで含めた大型のライブラリとなっています！現在GitHub Starsも2000を超えました。

https://github.com/Cysharp/ZLinq

structベースのLINQそのものは珍しいものではなく、昔から多くの実装が挑戦してきました。しかし、真に実用的と言えるものはこれまでありませんでした。極度なアセンブリサイズの肥大化、オペレーターの網羅の不足、最適化不足で性能が劣るなど、実験的な代物を抜け切れていないものばかりでした。ZLinqでは実用的に使えるものを目指し、.NET 10(Shuffle, RightJoin, LeftJoinなど新しいものも含む)に含まれる全てのメソッドとオーバーロードの100%のカバーと、99%の挙動の互換性の確保、そしてアロケーションだけではなく、SIMD化も含めた、ほぼ全てのケースにおける性能面で勝てるように実装しました。

それが出来るのは、そもそも私のLINQ実装の経験はものすごく長くて、2009年4月に[linq.js](https://github.com/neuecc/linq.js/)というJavaScript用のLINQ to Objectsライブラリを公開しています(linq.jsは現在もForkした人が今もメンテナンスされているようです、素晴らしい！)。他にもUnityで広く使われているReactive Extensionsライブラリ[UniRx](https://github.com/neuecc/UniRx)を実装し、直近ではそれの進化版である[R3](https://github.com/Cysharp/R3)を公開したばかりです。バリエーションとしても[LINQ to GameObject](https://assetstore.unity.com/packages/tools/integration/linq-to-gameobject-24256)、[LINQ to BigQuery](https://github.com/neuecc/LINQ-to-BigQuery)、[SimdLinq](https://github.com/Cysharp/SimdLinq/)といったものを作っていました。これらに、ゼロアロケーション関連ライブラリ([ZString](https://github.com/Cysharp/ZString), [ZLogger](https://github.com/Cysharp/ZLogger))やハイパフォーマンスシリアライザー([MessagePack-CSharp](https://github.com/MessagePack-CSharp/MessagePack-CSharp/), [MemoryPack](https://github.com/Cysharp/MemoryPack))の知見を掛け合わせることで、標準ライブラリの上位互換という野心的目標を達成できました。

![](https://github.com/Cysharp/ZLinq/raw/main/img/benchmarkhead.jpg)

これはシンプルなベンチマークで、Where, Where.Take, Where.Take.Selectとメソッドチェーンを重ねれば重ねるほど、通常はアロケーションが増えていきますがZLinqはずっとゼロです。

性能は元のソース、個数、値の型、そしてメソッドの繋げ方によって変わってきます。多くのケースで性能面で有利なことを確認するために、ZLinqでは様々なケースのベンチマークを用意し、GitHub Actions上で走らせています。[ZLinq/actions/Benchmark](https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yml)。

ベンチマーク上極端に差が出るものでいえば、シンプルにSelectを複数回繰り返したものは、SystemLinqもZLinqも特殊な最適化が入っていないケースになりますが、大きな性能差が出ています。

| Method       | Mean       | Allocated |
|------------- |-----------:|----------:|
| LinqSelect1  | 1,114.4 μs |      49 B |
| LinqSelect2  | 1,831.7 μs |     193 B |
| LinqSelect3  | 5,639.8 μs |     342 B |
| LinqSelect4  | 8,896.9 μs |     492 B |
|              |            |           |
| ZLinqSelect1 |   624.4 μs |       1 B |
| ZLinqSelect2 |   780.4 μs |       1 B |
| ZLinqSelect3 | 1,247.6 μs |       1 B |
| ZLinqSelect4 | 1,248.8 μs |       1 B |

シンプルなケースでは、DistinctやOrderByなど中間バッファを必要とするものは、積極的なプーリングによりアロケーションを大きく抑えているため、差が大きくなります(ZLinqは原則`ref strcut`であり短寿命が期待できるため、プーリング利用はややアグレッシブにしています)。例えばこのベンチマークはDistinctです。

| Method      | Mean     | Gen0   | Gen1   | Allocated |
|------------ |---------:|-------:|-------:|----------:|
| SystemLinq  | 67.52 μs | 3.4180 | 0.3662 |   58656 B |
|             |          |        |        |           |
| ZLinq       | 33.02 μs |      - |      - |      56 B |

LINQはメソッド呼び出しのパターンにより特殊な最適化がかかるなど、アロケーションを抑えるだけでは性能面で常に勝てるわけではありません。そうしてオペレーターの繋がりによる最適化に関しても、これは.NET 9で最適化されたパターンとして[Performance Improvements in .NET 9](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/)で紹介されている例ですが、ZLinqではそれらの最適化を全て実装し、より高いパフォーマンスを引き出しています。

| Method                                   | Mean         | Gen0   | Allocated |
|----------------------------------------- |-------------:|-------:|----------:|
| DistinctFirst_SystemLinq                 |    22.638 ns | 0.0038 |      64 B |
| AppendSelectLast_SystemLinq              |    33.865 ns | 0.0067 |     112 B |
| RangeReverseCount_SystemLinq             |    22.420 ns | 0.0029 |      48 B |
| DefaultIfEmptySelectElementAt_SystemLinq |    19.283 ns | 0.0029 |      48 B |
| ListSkipTakeElementAt_SystemLinq         |    38.704 ns | 0.0057 |      96 B |
| RangeUnionFirst_SystemLinq               |    38.567 ns | 0.0067 |     112 B |
| SelectWhereSelectSum_SystemLinq          | 3,605.709 ns | 0.0076 |     168 B |
|                                          |              |        |           |
| DistinctFirst_ZLinq                      |    23.085 ns |      - |         - |
| AppendSelectLast_ZLinq                   |    21.665 ns |      - |         - |
| RangeReverseCount_ZLinq                  |     7.429 ns |      - |         - |
| DefaultIfEmptySelectElementAt_ZLinq      |    19.056 ns |      - |         - |
| ListSkipTakeElementAt_ZLinq              |    29.341 ns |      - |         - |
| RangeUnionFirst_ZLinq                    |    31.048 ns |      - |         - |
| SelectWhereSelectSum_ZLinq               | 1,260.455 ns |      - |         - |

ZLinqの良いところとして、これらLINQの進化による最適化の恩恵を、最新の.NETだけではなく、全ての世代の.NET(.NET Frameworkも含む)が得られることでもあります。

利用法はシンプルに、`AsValueEnumerable()`呼び出しを追加するだけです。オペレーターに関しては100%網羅しているので、既存コードからの置き換えも全て問題なくコンパイルが通り、動作します。

```csharp
using ZLinq;

var seq = source
    .AsValueEnumerable() // only add this line
    .Where(x => x % 2 == 0)
    .Select(x => x * 3);

foreach (var item in seq) { }
```

ZLinqでは挙動の互換性を保証するために、dotnet/runtimeのSystem.Linq.Testsを移植して [ZLinq/System.Linq.Tests](https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests) 常に走らせています。

![](https://github.com/Cysharp/ZLinq/blob/main/img/testrun.png)

9000件のテストケースのカバーにより、動作を保証しています（Skipしているケースはref structであるため、同一テストコードを動かせない場合によるものなど）

また、 `AsValueEnumerable()` すら省略したDrop-In Replacementを任意で有効化するSource Generatorも提供しています。

```
[assembly: ZLinq.ZLinqDropInAttribute("", ZLinq.DropInGenerateTypes.Everything)]
```

![](https://github.com/Cysharp/ZLinq/blob/main/img/dropin.jpg)

この仕組みにより、Drop-In Replacementの範囲を自由にコントロールすることができます。`ZLinq/System.Linq.Tests`自体がDrop-In Replacementにより、既存テストコードを変えずにZLinqで動作するようになっています。

ValueEnumerableのアーキテクチャと最適化
---
使い方などはReadMeを参照してもらえればいいので、ここでは最適化の話を深堀します。ただたんなるシーケンスを遅延実行するだけ、ではないところが、アーキテクチャ上の特色であり、他の言語のコレクション処理ライブラリと比べても、多くの工夫が詰まっています。

連鎖のベースとなる`ValueEnumerable<T>`の定義はこうなっています。

```csharp
public readonly ref struct ValueEnumerable<TEnumerator, T>(TEnumerator enumerator)
    where TEnumerator : struct, IValueEnumerator<T>, allows ref struct // allows ref structは.NET 9以上の場合のみ
{
    public readonly TEnumerator Enumerator = enumerator;
}

public interface IValueEnumerator<T> : IDisposable
{
    bool TryGetNext(out T current); // as MoveNext + Current

    // Optimization helper
    bool TryGetNonEnumeratedCount(out int count);
    bool TryGetSpan(out ReadOnlySpan<T> span);
    bool TryCopyTo(scoped Span<T> destination, Index offset);
}
```

これを基にして、例えばWhereなどのオペレーターはこうした連鎖が続きます。

```csharp
public static ValueEnumerable<Where<TEnumerator, TSource>, TSource> Where<TEnumerator, TSource>(this ValueEnumerable<TEnumerator, TSource> source, Func<TSource, Boolean> predicate)
    where TEnumerator : struct, IValueEnumerator<TSource>, allows ref struct
```

`IValueEnumerable<T>`ではなくてこのようなアプローチを取ったのは、`(this TEnumerable source) where TEnumerable : struct, IValueEnumerable<TSource>`のような定義にすると、`TSource`への型推論が効かなくなります。これはC#が型引数の制約からは型推論をしないという言語仕様上の制限([dotnet/csharplang#6930](https://github.com/dotnet/csharplang/discussions/6930))があるためで、もしそのような定義のまま実装をすると、インスタンスメソッドとして大量の組み合わせを定義することになります。それをやったのが[LinqAf](https://github.com/kevin-montrose/LinqAF)であり、その結果[100,000+ methods and massive assembly sizes](https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/)ということで、あまり良い結果をもたらしていません。

LINQにおいては実装は全て`IValueEnumerator<T>`側にあり、また、全てのEnumeratorはstructのため、`GetEnumerator()`ではなくて、共通で`Enumerator`のコピー渡しするだけで、それぞれのEnumeratorが独立したステートで処理できることに気付いたので、`IValueEnumerator<T>`を`ValueEnumerable<TEnumerator, T>`でラップするだけ、という構成に最終的になりました。これにより型が制約側ではなくて型宣言側に現れるので、型推論での問題もありません。

### TryGetNext

次にイテレートの本体であるMoveNextについて詳しく見ていきましょう。

```csharp
// Traditional interface
public interface IEnumerator<out T> : IDisposable
{
    bool MoveNext();
    T Current { get; }
}

// iterate example
while (e.MoveNext())
{
    var item = e.Current; // invoke get_Current()
}

// ZLinq interface
public interface IValueEnumerator<T> : IDisposable
{
    bool TryGetNext(out T current);
}

// iterate example
while (e.TryGetNext(out var item))
{
}
```

C#の `foreach` は `MoveNext() + Current` に展開されるわけですが、問題が二点あります。一つはメソッド呼び出し回数で、イテレート毎にMoveNextとget_Currentの2回必要です。もう一つはCurrentのために、変数を保持する必要があること。そこで、それらを`bool TryGetNext(out T current)`にまとめました。これによりメソッド呼び出し回数が一度で済みパフォーマンス上有利です。

なお、この `bool TryGetNext(out T current)` 方式は、例えば[Rustのイテレーター](https://doc.rust-lang.org/std/iter/trait.Iterator.html)で採用されています。

```Rust
pub trait Iterator {
    type Item;
    // Required method
    fn next(&mut self) -> Option<Self::Item>;
}
```

変数の保持に関してはピンとこないと思うので、例としてSelectの実装を見てください。

```csharp
public sealed class LinqSelect<TSource, TResult>(IEnumerator<TSource> source, Func<TSource, TResult> selector) : IEnumerator<TResult>
{
    // フィールドが3つ
    IEnumerator<TSource> source = source;
    Func<TSource, TResult> selector = selector;
    TResult current = default!;

    public TResult Current => current;

    public bool MoveNext()
    {
        if (source.MoveNext())
        {
            current = selector(source.Current);
            return true;
        }

        return false;
    }
}

public ref struct ZLinqSelect<TEnumerator, TSource, TResult>(TEnumerator source, Func<TSource, TResult> selector) : IValueEnumerator<TResult>
    where TEnumerator : struct, IValueEnumerator<TSource>, allows ref struct
{
    // フィールドが2つ
    TEnumerator source = source;
    Func<TSource, TResult> selector = selector;

    public bool TryGetNext(out TResult current)
    {
        if (source.TryGetNext(out var value))
        {
            current = selector(value);
            return true;
        }

        current = default!;
        return false;
    }
}
```

`IEnumerator<T>`は`MoveNext()`で進めて`Current`で返す、という都合上、`Current`のフィールドが必要です。ところがZLinqでは進めると同時に値を返すため、フィールドに保持する必要がありません。これは、全体が`struct`ベースで構築されているZLinqではかなり大きな違いがあります。ZLinqではメソッドチェーンの度に、以前のstructを丸ごと抱える(`TEnumerator`がstruct)構造になるため、メソッドチェーンを重ねる度に構造体のサイズが肥大化していきます。常識的な範囲内でメソッドチェーンを重ねる限りは、パフォーマンス上も問題にはなっていなかったのですが、それでも小さければ小さいほどコピーコストが小さくなり性能面で有利にはなります。1バイトでも構造体を小さくする、ためにも`TryGetNext`の採用は必然でした。

TryGetNextの欠点は、共変・反変をサポートできないことです。ただし私は、そもそもイテレーターや配列から共変・反変のサポートは撤廃すべきだと思っています。`Span<T>`との相性が悪いため、メリット・デメリットを天秤にかけると、時代遅れの概念だと言えます。具体例を出すと、配列のSpan化は失敗する可能性があり、それはコンパイル時には検出できず実行時エラーとなります。

```csharp
// ジェネリクスの変性によりDerived[]をBase[]で受け取る。
Base[] array = new Derived[] { new Derived(), new Derived() };

// その場合、Span<T>へのキャストやAsSpan()は実行時エラーになる！
// System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.
Span<Base> foo = array;

class Base;
class Derived : Base;
```

`Span<T>`以前に追加された機能のため、もうどうにもならないとは思いますが、現代の.NETはあらゆるところでSpanが活用されるようになっているので、それが実行時エラーになる可能性をはらんでいる時点で、使い物にならないと考えてもいいはずです。

### TryGetNonEnumeratedCount / TryGetSpan / TryCopyTo

全てを愚直に列挙するだけだと、パフォーマンスは最大化されません。例えばToArrayするときに、もしサイズの変動がないなら(`array.Select().ToArray()`)、`new T[count]`のように固定長配列を作ることができます。SystemLinqでも、そうした最適化を実現するために、内部的には`Iterator<T>`型が使われているのですが、引数は`IEnumerable<T>`のため、必ず `if (source is Iterator<TSource> iterator)` のようなコードが必要になっています。

ZLinqでは最初からLINQのための定義を前提にできるため、すべて織り込み済みで用意しています。ただし、むやみやたらに増やすのはアセンブリサイズの肥大化を招くため、必要最小限の定義で、最大限の効果を生み出すように調整したのが、この3つのメソッドとなっています。

`TryGetNonEnumeratedCount(out int count)`は、元のソースが有限の個数であり、途中にフィルタリング系メソッド(WhereやDistinctなど。TakeやSkipは算出可能なため含まない)が挟まらない場合は成功します。ToArrayなどのほか、OrderByやShuffleなど中間バッファが必要な時に効果が出るケースもあります。

`TryGetSpan(out ReadOnlySpan<T> span)`は、元ソースが連続的なメモリとして取得できる場合には、オペレーターによってはSIMDが適用されて劇的なパフォーマンス向上に繋がったり、Spanによるループ処理によって集計パフォーマンスが高まるなど、性能面で大きな違いをもたらす可能性があります。

`TryCopyTo(scoped Span<T> destination, Index offset)`は内部イテレーターによってパフォーマンスを向上させる仕組みです。外部イテレーターと内部イテレーターについて説明すると、例えば`List<T>`は`foreach`と`ForEach`の両方が選べます。

```csharp
// external iterator
foreach (var item in list) { Do(item); }

// internal iterator
list.ForEach(Do);
```

見た目は似ていますが、性能面で違いがあります。foreachは素直な構文で書けている。ForEachはデリゲート渡し。処理の実体まで分解すると


```csharp
// external iterator
List<T>.Enumerator e = list.GetEnumerator();
while (e.MoveNext())
{
    var item = e.Current;
    Do(item);
}

// internal iterator
for (int i = 0; i < _size; i++)
{
    action(_items[i]);
}
```

これはデリゲート呼び出し(+デリゲート生成アロケーション)のオーバーヘッド vs イテレーターのMoveNext + Current呼び出しの対決になっていて、イテレート速度自体は内部イテレーターのほうが速い。この場合デリゲート呼び出しのほうが軽量な場合があり、ベンチマーク的に内部イテレーターのほうが有利な可能性があります。

もちろん、ケースバイケースであることと、ラムダ式にキャプチャが発生したり、普通の制御構文が使えない(continueなど)ことから、私としては`ForEach`は使うべきではないし、拡張メソッドで`ForEach`のようなものを独自定義すべきではない、とも思っていますが、原理的にはこのような違いが存在します。

`TryCopyTo(scoped Span<T> destination, Index offset)`は、デリゲートではなく`Span`を受け取ることで限定的に内部イテレーター化しました。

これもSelectを例に出すと、ToArrayの場合にCountが取れているとSpanを渡して内部イテレーターで処理します。

```csharp
public ref struct Select
{
    public bool TryCopyTo(Span<TResult> destination, Index offset)
    {
        if (source.TryGetSpan(out var span))
        {
            if (EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))
            {
                // loop inlining
                for (var i = 0; i < slice.Length; i++)
                {
                    destination[i] = selector(slice[i]);
                }
                return true;
            }
        }
        return false;
    }
}

// ToArray
if (enumerator.TryGetNonEnumeratedCount(out var count))
{
    var array = GC.AllocateUninitializedArray<TSource>(count);

    // try internal iterator
    if (enumerator.TryCopyTo(array.AsSpan(), 0))
    {
        return array;
    }

    // otherwise, use external iterator
    var i = 0;
    while (enumerator.TryGetNext(out var item))
    {
        array[i] = item;
        i++;
    }

    return array;
}
```

のように、SelectはSpanは作れませんが、元ソースがSpanを作れるなら、内部イテレーターとして処理することでループ処理を高速化することが可能です。

`TryCopyTo`の定義は普通の`CopyTo`と違って、`Index offset`を持っています。また、destinationはソースサイズよりも小さいことを許しています（通常の.NETのCopyToはdestinationが小さいと失敗する)。これによって、destinationのサイズが1の場合、IndexによってElementAtが表現できます。そして0ならFirstだし^1の場合はLastになります。`IValueEnumerator<T>`自体に`First`, `Last`, `ElementAt`を持たせると、クラス定義として無駄が多くなってしまいますが（アセンブリサイズにも影響が出る）、小さいdestinationとIndexを持たせることにより、一つのメソッドでより多くの最適化ケースをカバーできるようになりました。

ところで、このTryGetNextや内部イテレーターに関しては、2007年の時点で [https://nyaruru.hatenablog.com/entry/20070818/p1](https://nyaruru.hatenablog.com/entry/20070818/p1) で紹介されていました。この記事はずっと頭に残っていて、ようやくこうして20年経って理屈通りの実現ができました。という点でも少し感慨深いです。2008年前後はLINQ登場前後ということで、このあたりの話がアツかった時代なんですよねー。


LINQ to Span
--
ZLinqは .NET 9 以上であれば、`Span<T>`や`ReadOnlySpan<T>`に対しても、全てのLINQオペレーターを繋げることができます。

```csharp
using ZLinq;

// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)
Span<int> span = stackalloc int[5] { 1, 2, 3, 4, 5 };
var seq1 = span.AsValueEnumerable().Select(x => x * x);

// If enables Drop-in replacement, you can call LINQ operator directly.
var seq2 = span.Select(x => x);
```

Span対応のLINQを謳ったライブラリも、世の中には多少ありますが、それらは`Span<T>`にだけ拡張メソッドを定義する、といったようなものであり、汎用的な仕組みではありませんでした。網羅されるオペレーターも制約があり、一部のものに限られていました。それは言語的にも`Span<T>`をジェネリクス引数として受け取ることができなかったためで、汎用的に処理できるようになったのは .NET 9で`allows ref struct`が登場してくれたおかげです。

ZLinqでは`IEnumerable<T>`と`Span<T>`に何の区別もありません、全て平等に取り扱われます。

ただし、`allows ref struct`の言語/ランタイムサポートが必要なため、`ZLinq自体は`.NET Standard 2.0以上の全ての.NETをサポートしていますが、`Span<T>`対応に関してのみ.NET 9以上限定の機能となっています。また、これにより.NET 9以上の場合は、全てのオペレーターが`ref struct`になっている、という違いがあります。

LINQ to SIMD
---



LINQ to Tree
---


OSS
---





まとめ
---
謝辞: `ValueEnumerable<TEnumerator, T>`という定義は 





ValueDelegateのようなアプローチはあえて取っていません。そうした手間は実用的ではないでしょう、そこまでやるなら普通にインラインで書いたほうがマシなので、意味がありません。

