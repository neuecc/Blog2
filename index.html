<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
<meta property="og:url" content="https://neue.cc" />
<meta property="og:type" content="website" />
<meta property="og:title" content="neue cc" />
<meta property="og:description" content="..." />

 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズのサーバー開発をCysharpが担当しました</a></h1>
<ul class="date"><li>2022-04-08</li></ul>
<div class="entry_body"><p>Cygamesから4/1にリリースされた<a href="https://priconne-grandmasters.jp/">プリコネ！グランドマスターズ</a>のサーバーサイドとインフラ開発をCysharpが担当しました。リアルタイム通信を含むオートバトラー系のゲームです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/162343388-734840a1-4b7d-467b-902c-1e06e527d208.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/162401207-d9e2bceb-6b94-435c-8e63-d96ce62cf97b.png" alt="image" /></p>
<p>リアルタイム通信部分だけではなくてAPIサーバーからマッチメイキング、インフラまで、構成されるあらゆる要素がC#で作られています！</p>
<ul>
<li>クライアント (Unity)</li>
<li>API サーバー(MagicOnion)</li>
<li>バトルエンジンサーバー (リアルタイム通信; MagicOnion)</li>
<li>マッチメイキングサーバー (リアルタイム通信; MagicOnion)</li>
<li>バッチ(ConsoleAppFramework)</li>
<li>デバッグ機能サーバー (Web; Blazor)</li>
<li>管理画面サーバー (Web; Blazor)</li>
<li>インフラ (Infrastructure as Code; Pulumi)</li>
</ul>
<p>サーバー側アプリケーションは.NET 6をKubernetes上で動かしています。Unityクライアント側でも<a href="https://github.com/Cysharp/">CysharpのOSS</a>は7つクレジットされていますが、表記のないサーバー側専用のものを合わせたら10個以上使用しています。ここまで徹頭徹尾C#でやっているプロジェクトは世界的にも珍しいんじゃないでしょうか。中心的に活躍しているのは<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>ですが、サーバーサイドゲームループのための<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>、負荷テストのための<a href="https://github.com/Cysharp/DFrame/">DFrame</a>なども実戦投入されて、成果を出しました。サーバートラブルも特になく、しっかり安定稼働しました。という事後報告です。そして今日、もとより期間限定公開ということで一週間の配信期間が終了しました。</p>
<p>アーキテクチャ含めの詳しい話は後日どこかでできるといいですねー。</p>
<p>こういった構成を、Cysharpだから出来る、のではなくて、誰もが実現できる環境にしていきたいと思っています。重要なパーツは積極的にOSS化していますし、実績も着実に積み重ねられています。が、しかしまだまだ難しい面も数多くあるということは認識しています。かといってmBaaSの方向でやっていくべき、とは思わないんですね。ロジックはゲームの差別化のための重要な要素であり、サーバーサイドでも書くべきで。だから注力しているのは書きやすくするための環境で、そのために足りないものを提供していっています。</p>
<p>サーバーとクライアントの繋ぎ、あるいはサーバーとサーバーの繋ぎが、MagicOnionだけだと複雑で難しいと思っていて、ちょうど先月-今月はメッセージングライブラリの開発に注力しています。<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>という名前でPreview公開していますが、これを挟むと色々改善されるんじゃないかなあ、と思っているので、少々お待ち下さい。</p>
</div>
<h1><a href="https://neue.cc/2022/02/28_DFrame.html">DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</a></h1>
<ul class="date"><li>2022-02-28</li></ul>
<div class="entry_body"><p>と、いうものをリリースしました。Web UIとなるDFrame.Controllerと、負荷テストシナリオをC#で書くDFrame.Workerの組み合わせで成り立っていて、DFrame.Workerをウェブ上のクラスターに配置することで(Controllerと接続するただの常駐アプリなので、配置先はオンプレでもVMでもコンテナでもKuberenetesでもなんでもいい)、1から数千のワーカーが連動して、大量のリクエストを発生させます。また、テストシナリオをプレーンなC#で記述できるということは、HTTP/1だけではなく、あらゆる種類の通信をカバーできます。WebSocket、HTTP/2、gRPC、MagicOnion、あるいはPhotonや自作のTCPトランスポート、更にはRedisやデータベースなどが対象になります。</p>
<p>DFrame.Workerは通常の.NETの他に、Unityにも対応しています！つまり、大量のHeadless Unity、あるいはデバイスファームに配置することで、Unityでしか動かないような独自通信フレームワークであっても負荷テストをかけることが可能です。</p>
<p>また、あまり注目されていませんが負荷テストツールにもパフォーマンスの違いは「かなり」あり、性能の良さは重要で、そこのところにもかなりチューニングしました。</p>
<ul>
<li><a href="https://github.com/Cysharp/DFrame/">github - Cysharp/DFrame</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/46207/155904375-084a199b-a473-4bc6-8362-009d214bd009.png" alt="image" /></p>
<p>Web UI(DFrame.Controller)はBlazor Serverで作られていて、分散ワーカーとの通信はMagicOnionで行っています。自動化のためのWeb APIの口もあるため、Blazor Server, ASP.NET Minimum API, MagicOnionのキメラ同居なアーキテクチャでC#でフル活用なのが設計的にも面白いポイントです。</p>
<h2>C#で負荷テストシナリオを書く意義</h2>
<p>負荷テストフレームワークは世の中に山のようにあります。代表的なものでも<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">ab</a>, <a href="https://jmeter.apache.org/">jMeter</a>, <a href="https://k6.io/">k6</a>, <a href="https://www.artillery.io/">Artillery</a>, <a href="https://gatling.io/">Gatling</a>, <a href="https://github.com/wg/wrk">wrk</a>, <a href="https://github.com/codesenberg/bombardier">bombardier</a>, <a href="https://locust.io/">Locust</a>、k6やArtillery、GatlingなどはSaaSとしても提供していますし、クラウドサービス側も、<a href="https://azure.microsoft.com/ja-jp/services/load-testing/">Azure Load Testing(Managed jMeter)</a>のようなマネージドサービスを出していますし、.NETでも<a href="https://github.com/dotnet/crank">dotnet/crank</a>というものが存在していたりします。</p>
<p>DFrameはこの中でいうとアーキテクチャ含めLocustに近い(Controller-Worker構成やWebUIなど)のですが、その特徴の中で重要な点として挙げられているのが、シナリオをコードで書けること、です。よくわからんUIで設定させたり、複雑怪奇なXMLやYAMLやJSON書かせたりせず、プレーンなコードで書ける。これが大事。LocustはPythonですが、他にk6はJavaScriptで書けるようになっています。</p>
<p>じゃあLocustでいいじゃん、k6でいいじゃん、という話になるのですが、C#で書きたいんですね、シナリオを。これは別にただ単に自分の好きな言語で書きたいからというわけではなくて、サーバーあるいはクライアント言語と負荷試験シナリオ作成言語は同一のものであるべきだからです。例えばUnityのゲームを開発している場合（サーバーサイドの言語は何でもいい）、UnityのゲームはC#で記述されていますが、その場合C#でテストシナリオが書けるのなら</p>
<ul>
<li>最初からクライアントSDK(エンドポイントと型付きのRequest/Response)に相当するものがある</li>
<li>クライアントの実装と完全に等しいのでゲームのドメインロジックが最初からある</li>
</ul>
<p>となります。それによりテストシナリオの記述の手間を大幅に削減できます。もちろん、Unity依存の部分を引き剥がすなどの追加の作業は必要ですが、完全に書き起こすなどといった無駄は発生しません。もしPythonでもJavaScriptでもLuaでも、とにかく異なる言語である場合は、比較にならないほどに作業量が膨大になってきます。</p>
<p>そして実際のクライアントコードとある程度共通になることで、サーバー/クライアント側の変化への追随が用意になります。それにより一回のリリースのための負荷テストではなく、継続的な負荷テスト環境を作っていけます。</p>
<p>また、プレーンなC#で記述できることで、冒頭にも書きましたがあらゆる通信の種類をカバーできるのは、通信プロトコルが多様化している昨今、大きな利点となります。</p>
<h2>DFrameApp.Run</h2>
<p>NuGetからDFrameをパッケージ参照したうえで、一行で起動します。テストシナリオ(Workload)の記述の行数もありますが、それでもこれだけで。</p>
<pre><code class="language-csharp">using DFrame;

DFrameApp.Run(7312, 7313); // WebUI:7312, WorkerListen:7313

public class SampleWorkload : Workload
{
    public override async Task ExecuteAsync(WorkloadContext context)
    {
        Console.WriteLine($&quot;Hello {context.WorkloadId}&quot;);
    }
}
</code></pre>
<p>これで <code>http://localhost:7312</code> をブラウザで開けば、<code>SampleWorkload</code>がいます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155892546-c00f1554-0e2c-4e11-acdd-f0d9be9c40c9.png" alt="image" /></p>
<p>と、いうわけで、WorkloadのExecuteAsyncにコードを書くのが基本です。ExecuteAsync前の準備用としてSetupAsync、後始末としてTeardownAsyncもあります。単純なgRPCのテストを書くとこなります。</p>
<pre><code class="language-csharp">public class GrpcTest : Workload
{
    GrpcChannel? channel;
    Greeter.GreeterClient? client;

    public override async Task SetupAsync(WorkloadContext context)
    {
        channel = GrpcChannel.ForAddress(&quot;http://localhost:5027&quot;);
        client = new Greeter.GreeterClient(channel);
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await client!.SayHelloAsync(new HelloRequest(), cancellationToken: context.CancellationToken);
    }

    public override async Task TeardownAsync(WorkloadContext context)
    {
        if (channel != null)
        {
            await channel.ShutdownAsync();
            channel.Dispose();
        }
    }
}
</code></pre>
<p>Concurrencyの数だけWorkloadが生成されて、Total Request / Workers / Concurrencyの数だけExecuteAsyncが実行されます。コードで書くと言っても別にそう複雑なこともなく、よくわからんDSLで書くわけでもないので、むしろ(C#が書けるなら)とても書きやすいでしょう。中身も見てのとおり単純なので、gRPCでもMagicOnionでも何でも実行できます。</p>
<p>引数を受け取ることも可能なので、任意のURLを渡すようなものも作れます。コンストラクタでは、パラメーター、あるいはDIでインジェクトしたインスタンスを受け取れます。</p>
<pre><code class="language-csharp">using DFrame;
using Microsoft.Extensions.DependencyInjection;

// use builder can configure services, logging, configuration, etc.
var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureServices(services =&gt;
{
    services.AddSingleton&lt;HttpClient&gt;();
});
await builder.RunAsync();

public class HttpGetString : Workload
{
    readonly HttpClient httpClient;
    readonly string url;

    // HttpClient is from DI, URL is passed from Web UI
    public HttpGetString(HttpClient httpClient, string url)
    {
        this.httpClient = httpClient;
        this.url = url;
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await httpClient.GetStringAsync(url, context.CancellationToken);
    }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/155893829-fc9f5e9d-fb05-4bcc-b8ee-6067be674b51.png" alt="image" /></p>
<p>WebUI画面にString urlの入力箇所が現れて、好きなURLを叩き込むことができるようになりました。</p>
<p>なお、単純なHTTPのGET/POST/PUT/DELETEをテストしたいという場合は、IncludesDefaultHttpWorkloadを有効にしてもらうと、内蔵のパラメーターを受け取るWorkloadが追加されます。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureWorker(x =&gt;
{
    x.IncludesDefaultHttpWorkload = true;
});
builder.Run();
</code></pre>
<h2>分散テスト</h2>
<p>Workerは起動時に指定したControllerのアドレスにHTTP/2(MagicOnion/gRPC)で繋ぎに行って、常駐します。という普通の（？）アプリケーションなので、ウェブサーバーを分散させるのと同様に複数のWorkerを立ち上げてもらえれば、自動的に繋がります。</p>
<p>構成としては、以下の画像のようにControllerとWorkerのプロジェクトを分けるのが正当派（？）ですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/154921606-b9955331-1d15-4c4f-a769-faeb61b13872.png" alt="" /></p>
<p>同居させてしまって、起動時のコマンドライン引数でどちらかのモード（あるいは両方）が起動するようにすることも、ローカルでの開発がしやすくなるのでお薦めです。 <code>DFrameApp.CreateBuilder</code> にはそのための補助的な機構が用意されています。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(5555, 5556); // portWeb, portListenWorker

if (args.Length == 0)
{
    // local, run both(host WebUI on http://localhost:portWeb)
    await builder.RunAsync();
}
else if (args[0] == &quot;controller&quot;)
{
    // listen http://*:portWeb as WebUI and http://*:portListenWorker as Worker listen gRPC
    await builder.RunControllerAsync();
}
else if (args[0] == &quot;worker&quot;)
{
    // worker connect to (controller) address.
    // You can also configure from appsettings.json via builder.ConfigureWorker((ctx, options) =&gt; { options.ControllerAddress = &quot;&quot; });
    await builder.RunWorkerAsync(&quot;http://foobar:5556&quot;);
}
</code></pre>
<p>ローカルでWorkerの.exeを複数実行する、とかでも手元でとりあえずのWorker connectionsが増える様は確認できます。</p>
<p>Workerを増やすと表がにぎやかになって楽しい。実行するWorkerの数はスライダーで調整できるので、各種パラメーターを台数1で調整したあとに、徐々に実行Workerを増やしていく、といった使い方も可能です。また、その辺を自動でやってくれるRepeatモード(TotalRequestとWorkerを完了後に指定数増やして繰り返す)も用意しました。jMeterでいうところのRamp-Upの代わりに使えればいいかな、という想定でもあります。</p>
<p>アーキテクチャ的に最初から分散前提で作られているというのもあり、増やしても性能が劣化しない、リニアに性能が向上していくように作りました。Controllerは単一なのでスケールしないのですが、なるべく多くのWorkerをぶら下げられるように工夫しています。Controller &lt;-&gt; WorkerはMagicOnionで通信しているので、DFrame自身がMagicOnionの負荷テストになっているのです。</p>
<h2>パフォーマンス</h2>
<p>多数ある負荷テストフレームワークですが、パフォーマンスはそれぞれかなり異なります。詳しくはk6のブログ<a href="https://k6.io/blog/comparing-best-open-source-load-testing-tools/">Open source load testing tool review 2020</a>に非常に詳細に書かれていますが、例えばとにかくwrkがぶっちぎって他の数十倍~数百倍速かったりする、と。パフォーマンスは当然ながらとても重要で、ワーガーの非力さでターゲットに負荷をかけきれなかったりします。それに対応するためクラスターを組んでいくにしても、多くの台数やより高いスペックのマシンが必要になって、色々と辛い。</p>
<p>というわけでパフォーマンスは高ければ高いほうがいいのですが、先のブログに書かれている通り、拡張性の口やレポート取り出しの口などは必要です。その点でWrkは機能を満たさないということで、ブログではなんか結果から取り除かれてますね（その対応がいいのかどうかはなんとも言えませんが、まぁk6自身のアピールのためでもあるのでしょうがないね）。ちなみにフレームワークのパフォーマンスの指標として使われている<a href="https://www.techempower.com/benchmarks/">TechEmpower Web Framework Benchmarks</a>の負荷クライアントはwrkのようです。</p>
<p>さて、で、DFrameはどうかというと、かなり良好です。というのも、DFrameはライブラリとして提供されて、実行時は全てがC#の実行ファイルとしてコンパイル済みの状態になるのですね。スクリプトを動的に読んで実行するから遅くなってしまう、みたいなことがない。比較的高速な言語であるC#をそのまま利用するので、その時点である程度はいける。理論上。理屈上。</p>
<p>と、いう甘い見込みのもと実際作っていくと、さすがにそこまでさっくりとはいかず、相応にチューニングが必要だったのですが、最終的にはかなりの数字が出るようになりました。比較としてabとk6で測ってみると</p>
<p><img src="https://user-images.githubusercontent.com/46207/155854372-6cd3976c-fb08-4ddb-b4a8-75235421cfc8.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854390-a2360f29-956f-4ace-a848-ecc03c79cb21.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854413-969e59c2-a914-4131-b3d7-f1f50591413b.png" alt="image" /></p>
<p>本来はターゲットとワーカーは別マシンにしないといけないのですが(ワーカーの負荷でCPUが跳ね上がる影響をサーバー側がモロに影響受けてしまうので)、それでもそれなりに数字は変動しますし動きはするしマシンパワーも結構強め(Ryzen 9 5950x)なので、ちょっと手抜きでlocalhost上の無を返すHTTP/1サーバーをターゲットに、32並列(-c 32, -32VUs, Concurrency=32)で実行。</p>
<p>abが、6287 req/sec、k6が125619 req/sec、DFrameが207634 req/secです。abは、厳しい、厳しい……。もっと出るはずと思っているんですが、私の環境(Windows)だと昔からこんな感じなので、性能的には信用できないかなぁ。Windowsだとダメだったりするのかもしないのかもしれませんね。DFrameの場合Concurrencyにまだ余裕があって、増やすとまだまだ伸びたのですが、k6は割と頭打ちでした。</p>
<p>また、画像は出してませんがLocustは残念ながらかなり遅い上にCPUを食いまくるという感じで(Pythonだしね……）、いくらクラスタ化が容易とはいえ、ここまで1ワーカーあたりの性能が低いと、ないかなあ、という感想です。JMeterはそこまで悪くはないですが、パフォーマンスに影響を与える地雷コンフィグを必死にかいくぐってなおそこそこ程度なのはしんどみ。</p>
<p>ちなみになんで圧倒的性能番長であるwrkと比較しないのかというと、Windowsで動かすのが大変だからです。すみません……。</p>
<h2>自動化のためのREST API</h2>
<p>最初はいいけど、毎回GUIでポチポチやるの面倒で、それはそれで嫌だよね。CIで定期的に回したりもできないし。というわけで、バッチ起動モード、はついていないのですが、代わりにREST APIが自動で有効になっています。例えば <code>/api/connections</code> で現在接続中のワーカーコネクション数が取れます。実行パラメーターなどはPostでJSONを投げる形になっています。</p>
<p>REST APIでJSONをやり取りするだけなので、どの言語から叩くことも可能ですが、C#の場合は <code>DFrame.RestSdk</code> パッケージにて型付けされたクライアントが用意されているので、手間なくはじめられます。</p>
<pre><code class="language-csharp">using DFrame.RestSdk;

var client = new DFrameClient(&quot;http://localhost:7312/&quot;);

// start request
await client.ExecuteRequestAsync(new()
{
    Workload = &quot;SampleWorkload&quot;,
    Concurrency = 10,
    TotalRequest = 100000
});

// loadtest is running, wait complete.
await client.WaitUntilCanExecute();

// get summary and results[]
var result = await client.GetLatestResultAsync();
</code></pre>
<p>実行状況は全て連動しているので、REST APIから実行した進捗もWeb UI側でリアルタイムに状況確認できます。</p>
<h2>Unityでも動く</h2>
<p>Unityで動かしやすいかといったら全然そんなことないので、動かせるようにするのはもはや執念という感じではあるのですが、Unity対応しました。冒頭で書いたようにヘッドレスUnityを並べてコントロールする、みたいな用途は考えられます。まぁ、あと普通の負荷テストでも、通信部分のC#を普通の .NET に切り出すのが面倒だという場合に、ヘッドレスUnityでとりあえずビルドすることで何もしなくてもOK（そうか？）という策もあります。</p>
<p>Unityで動かす場合は、依存の解決(MagicOnion、gRPC、MessagePack for C#)が大変です！まぁ、それは置いておいて。それが出来ているなら、以下のようなMonoBehaviourに寿命をくっつけたインスタンスで起動させると良い感じです（MagicOnionというかネイティブgRPCは適切にコネクションをCloseしないとUnity Editorがフリーズするという酷い問題があるのですが、このコードは問題なくちゃんとクリーンアップしてくれるようになっています）。</p>
<pre><code class="language-csharp">public class DFrameWorker : MonoBehaviour
{
    DFrameWorkerApp app;

    [RuntimeInitializeOnLoadMethod]
    static void Init()
    {
        new GameObject(&quot;DFrame Worker&quot;, typeof(SampleOne));
    }

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }

    async void Start()
    {
        // setup your controller address
        app = new DFrameWorkerApp(&quot;localhost:7313&quot;);
        await app.RunAsync();
    }

    private void OnDestroy()
    {
        app.Dispose();
    }
}

[Preserve]
public class SampleWorkload : Workload
{
    public override Task ExecuteAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Exec&quot;);
        return Task.CompletedTask;
    }

    public override Task TeardownAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Teardown&quot;);
        return Task.CompletedTask;
    }
}

// Preserve for Unity IL2CPP

internal class PreserveAttribute : System.Attribute
{
}
</code></pre>
<p>Editor上の確認だとこんな具合です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155901725-4ce8a36f-46e9-4437-aba7-639425f4b93f.png" alt="image" /></p>
<h2>ライブラリかツールか</h2>
<p>DFrame.Controller、他の設定を入れなければただのウェブアプリなので、ビルド済みのexeとしての提供も可能です。Locustなど他のツールも入れたら、とりあえず実行できる、のに比べると、必ず自分で組み込んでビルドしなきゃいけない。のは欠点に見える。</p>
<p>なのでビルド済みコンテナをDocker Hubかなんかで提供するという案もあったのですが、Workerはどうしても自分で組み込んでビルドする必要があるので、そこだけ省けても利点あるのかな？と考えて、最終的に却下しました。かわりに <code>DFrameApp.Run</code> の一行だけでController+Workerの同居が起動できるようにして、最初の一歩の面倒臭さをライブラリデザインの工夫で乗り切ることにしました。Controller自体も、<code>Microsoft.NET.Sdk.Web</code>ではなく、コンソールアプリケーションのテンプレートの<code>Microsoft.NET.Sdk</code>から起動できるようにしました。</p>
<p>DFrame.Controllerがライブラリとして提供されていることのメリットは、コンフィグが通常のコードやASP.NETの仕組みに乗っかったほうが圧倒的にシンプルになります。DIで好きなロガーを設定して、URLの指定やSSLなどもappsettings.jsonで行うのは、大量の複雑怪奇なコマンドラインオプションよりもずっと良いでしょう。</p>
<p>ログの永続化処理も、プラグイン的に用意するのではなく、普通にDIでインジェクトしてもらう(<code>IExecutionResultHistoryProvider</code>というものが用意されていて、これを実装したものをDIに登録してもらえば、結果をデータベースに入れたり時系列DBに入れたりして統計的な参照ができるようになります)ほうが、使いやすいはずです。</p>
<h2>Blazor Server + MagicOnion</h2>
<p>DFrame.ControllerはBlazor ServerとMagicOnion(grpc-dotnet)が同居した構成になっています。これは中々面白い構成で、Web UIとMagicOnion(Server側)が同じメモリを共有しているので、末端のMagicOnion(Client側)の変更をダイレクトにC#だけを通してブラウザにまで届けているんですね。逆もしかりで、APIからのアクセス含めて、全てがリアルタイムに伝搬して画面も同期しているのですが、普通にやるとかなり複雑怪奇になるはずが、かなりシンプルに実装できています。</p>
<p>と、いうわけで、Cysharpではこの組み合わせに可能性を感じていて、別のサービスも同種のアーキテクチャで絶賛制作中なので興味ありましたら以下略。</p>
<h2>紆余曲折</h2>
<p>最初のバージョンは2年ぐらい前に作っていました。コンセプトは「自己分裂する分散バッチフレームワーク」ということで、自分自身のコピーを動的に作って無限大に分散して実行していくというもので。分散のための基盤としてKubernetesを使って。クラウドネイティブ！かっこいい！そして、一応動くものはできていました。あとは仕上げていくだけ、といったところで、放置していました。完成させなきゃ、と思いつつ、内心薄々あんまいい感じではないな、と思っていたため手が進まず無限放置モードへ。そして時が流れ、社内でもがっつり使うことになり引っ張り出されてきたそれは、やはりあまりいい感じではなく。で、最終的に言われたんですね、そもそも分裂機能いらなくね？と。</p>
<p>それでようやく気づくわけです、コンセプトから完全に間違っているからうまくいくわけがない！</p>
<p>反省として良くなかった理由としては、まず、現代のクラウドコンピューターを過大に評価していた。「自己分裂する」のは、一瞬で無限大にスケールして即起動、そして終わったら即終了、ならば、まぁそれでいいんですが、現実のスケールする時間はそんなに立派じゃない。サーバーレスといいつつ、別に1リクエスト毎にコンテナが起動して処理するわけはなく、常駐してリクエストを待つ。そりゃそうだ、と。自己分裂のコンセプトだと、分裂コストが重たいのは否めない。</p>
<p>もう一つは分裂するためのコードがDFrame内に記述されている。Kuberentesをコントロールするコードがたっぷり入ってしまって。そのせいでコードサイズが膨らんでしまったし、使う方も複雑なコンフィグをDFrame側に埋めなきゃいけなくなってしまった。これは二重にイケてない。作るのも複雑で、使うのも複雑ですからね、いいところがない……。</p>
<p>と、いうわけで、最初のかっこいいコンセプトを否定して、自己分裂しない。単純に繋ぎに行くだけ。としたことで、頭を抱えてうまくいかないと感じていた行き詰まりは解消したのでした。</p>
<h2>まとめ</h2>
<p>もう少し早くに作って提供したかった、という後悔がめっちゃあるのですが、同時に .NET 6だから出来たという要素もめっちゃあるので(パラメーター渡しの仕組みなどは<a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4</a>の設計の経験からスムーズに実装できた)、しょーがない。という気もする。Blazor Serverなどの進化も必要だったし。</p>
<p>しかし↑で書いたとおり最初に立てたコンセプトが間違っていて、長いこと軌道修正できず放置してしまっていたというのは個人的には割と手痛い経験です……。まぁ、間違ったコンセプトのまま進行してしまうというのは別によくあるので、それはしょーがないものとして別にいいんですが、自力で気づいてパーッと作り上げられてたらなあ、みたいな、みたいな。。。</p>
<p>ともあれ、完成したものとしてはかなり良い感じで（私の出すものとしては珍しくUIもちゃんとついているし！←UI作業は他の人に助力を請うてます）、ちょっとニッチ感もありますがC#アプリケーション開発の必需品として成り得る出来だと思っていますので、ぜひぜひお試しください。</p>
</div>
<h1><a href="https://neue.cc/2022/01/09_WebSerializer.html">WebSerializer - オブジェクトからクエリストリングに変換するHttpClientリクエスト用シリアライザ</a></h1>
<ul class="date"><li>2022-01-09</li></ul>
<div class="entry_body"><p><code>T value</code>から URLエンコードされたクエリストリング、または<code>x-www-form-urlencoded</code>なHttpContentを生成する、つまりはウェブ(HTTP/1)リクエスト用のシリアライザを作りました。</p>
<ul>
<li><a href="https://github.com/Cysharp/WebSerializer/">github.com/Cysharp/WebSerializer</a></li>
</ul>
<p>クエリストリングの生成、意外と面倒くさいな！と。(C#用の)専用のSDKが存在しないWeb APIの場合は、自分でURL組み立てたり<code>FormUrlEncodedContent</code>を組み立てたりしますが、数が多いとまぁ面倒くさい。リクエストのパラメーター数が多いと、null抜いたりも面倒くさい。</p>
<p>レスポンス側は<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.http.json.httpcontentjsonextensions.readfromjsonasync?view=net-6.0">ReadFromJsonAsync</a>などでダイレクトに変換できるようになって特に問題はないのですが、リクエスト側は、かなりの手作業が要求されます。そのへんを全部やってくれる<a href="https://github.com/reactiveui/refit">refit</a>というライブラリもありますが(Androidの<a href="https://github.com/square/retrofit">retrofit</a>にインスパイアされたもの)、導入するにはちょっと大仰だな、と思うときも多々あります、というか私は今まで一度も使ってません。</p>
<p>HttpClient用にURLを組み立てるのを簡略化してくれるぐらいでいいな、と思って考えていたら、そういえばそもそもそれってT valueから何かに変換する、つまりシリアライザじゃん、ということに気づきました。T -&gt; msgpack byte[]に変換すればMessagePackシリアライザだし、T -&gt; Json stringに変換すればJSONシリアライザだし、これはT -&gt; UrlEncoded stringに変換するということなのだと。シリアライザ脳なので、そう理解すれば話が早い。</p>
<pre><code class="language-csharp">using Cysharp.Web;

var req = new Request(sortBy: &quot;id&quot;, direction: SortDirection.Desc, currentPage: 3)

// sortBy=id&amp;direction=Desc&amp;currentPage=3
var q = WebSerializer.ToQueryString(req);

await httpClient.GetAsync(&quot;/sort?&quot;+ q);

// data...
public record Request(string? sortBy, SortDirection direction, int currentPage);

public enum SortDirection
{
    Default,
    Asc,
    Desc
}
</code></pre>
<p>基本的に使うメソッドは <code>WebSerializer.ToQueryString</code> か <code>WebSerializer.ToHttpContent</code> だけです。URLエンコードされてname=valueで&amp;連結された文字列が取り出せます。メソッドとして叩いたりする場合は、そのまま匿名型で渡してあげればちょうど良い。urlも一緒に渡してあげれば全て同時に組み立ててくれます。値が<code>null</code>のものは文字列化対象から自動で外されます。</p>
<pre><code class="language-csharp">const string UrlBase = &quot;https://foo.com/search&quot;;

// null, SortDirection.Asc, 0
async Task SearchAsync(string? sortBy, SortDirection direction, int currentPage)
{
    // &quot;https://foo.com/search?direction=Asc&amp;currentPage=0&quot;
    var url = WebSerializer.ToQueryString(UrlBase, new { sortBy, direction, currentPage });
    await httpClient.GetAsync(url);
}
</code></pre>
<p>動的に組み立てる場合は、<code>Dictionary&lt;string, object&gt;</code> も渡せます。(<code>FormUrlEncodedContent</code>は<code>Dictionary&lt;string, string&gt;</code>で、Value側のToString()が必須なのが地味に面倒くさいので、<code>object</code>で良いというのは何気に楽だったりします)。</p>
<pre><code class="language-csharp">var req = new Dictionary&lt;string, object&gt;
{
    { &quot;sortBy&quot;, &quot;id&quot; },
    { &quot;direction&quot;, SortDirection.Desc },
    { &quot;currentPage&quot;, 10 }
};
var q = WebSerializer.ToQueryString(req);
</code></pre>
<p>POST用には、<code>ToHttpContent</code>を使います。</p>
<pre><code class="language-csharp">async Task PostMessage(string name, string email, string message)
{
    var content = WebSerializer.ToHttpContent(new { name, email, message });
    await httpClient.PostAsync(&quot;/postmsg&quot;, content);
}
</code></pre>
<p>内部的には<code>FormUrlEncodedContent</code>は使わずに、専用のHttpContentを通しているため、<code>byte[]</code>変換のオーバーヘッドがありません。</p>
<h2>シリアライザ設計</h2>
<p>ただたんにクエリストリング組み立てるだけっしょ！というと軽く見られてしまうかもしれないのですが、中身はかなりガチめに作ってあって、構成としては<a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C#</a>と同様です。パフォーマンスに関しても超ギチギチに詰めているわけではないですが、かなり気を配って作られているので、手で組み立てるよりもむしろ高速になるケースも多いはずです。拡張性もかなり高く作れているはずです。</p>
<p>シリアライザのデザインに関してはMessagePack for C#の次期バージョン(v3)をどうしていこうかなあ、と考えているタイミングでもあるので、そのプロトタイプ的な意識もありますね。なので設計としてはむしろ最新型で、かなり洗練されています。.NET 5/6のみにしているので、レガシーも徹底的に切り捨てていますし。最初は .NET 6のみだったのですが、さすがにそれはやりすぎかと思い .NET 5は足しました。（が、2022-01-21のv1.3.0にて、.NET Standard 2.0/2.1対応もしました）</p>
<p>例えばコンフィグ(<code>WebSerializerOptions</code>)はイミュータブルなのですが、これ自体はrecordで作ってあってwith式でカスタムのコンフィグを作れます。</p>
<pre><code class="language-csharp">// CultureInfo: 数値型やDateTimeの文字列化変換に渡すCultureInfo、デフォルトはnull
// CollectionSeparator: 配列などを変換する場合のセパレーター、デフォルトはnullでname=value&amp;name=value...
// Provider: 対象の型をどのように変換するか(`IWebSerialzier&lt;T&gt;`)の変更
var newConfig = WebSerializerOptions.Default with
{
    CultureInfo = CultureInfo.InvariantCulture,
    CollectionSeparator = &quot;,&quot;,
    Provider = WebSerializerProvider.Create(
        new[] { new BoolZeroOneSerializer() },
        new[] { WebSerializerProvider.Default })
};

// Bool値を0, 1に変換する（こういうの求めてくるWeb APIあるんですよねー！）
public class BoolZeroOneSerializer : IWebSerializer&lt;bool&gt;
{
    public void Serialize(ref WebSerializerWriter writer, bool value, WebSerializerOptions options)
    {
        // true =&gt; 0, false =&gt; 1
        writer.AppendPrimitive(value ? 0 : 1);
    }
}
</code></pre>
<p><code>IWebSerializer&lt;T&gt;</code>のインターフェイスについて、<code>ref T value</code>にしようか検討したのですが、最終的にやめました。</p>
<pre><code class="language-csharp">public interface IWebSerializer&lt;T&gt; : IWebSerializer
{
    void Serialize(ref WebSerializerWriter writer, T value, WebSerializerOptions options);
}
</code></pre>
<p><code>ref T value</code>にすると、プロパティをそのまま渡せなくて、かなり面倒くさくなってね。理屈的にはlarge structに対するコピーコスト削減、ではあるけれど、まぁこのままだと99%効力ないかなあ、という感じがあり。入り口だけinにして一回分コピーを消すぐらいを落とし所にしました、とりあえず今回は。</p>
<pre><code class="language-csharp">public static string ToQueryString&lt;T&gt;(in T value, WebSerializerOptions? options = default)
</code></pre>
<p>それとSource Generator対応についても考えましたが、まぁ一旦今回は見送って、後でやるかもという感じでしょうか。アイディアは色々ありますが、まずは作ってみないとうまくハマるか見えないところがあるし、MessagePack for C#のような大きなものでドカンとやるよりは、最初は小さなものでテストしていくのが良いものを作る正攻法でもありますね。</p>
<h2>Deserializeがない問題</h2>
<p>ASP.NET CoreのAddControllerなら、Model Bindingでデシリアライズできるので、不要でしょう。.NET 6時点でのMinimal APIだとなんと自動モデルバインディングがなくて手動でQueryStringから組み立てるという手間が必要になってて、まぁそこでは必要かなあ？と思ったんですが、いや、それしたいならMinimal APIではなくてAddControllerしろや、と思ったので、機能入れるのやめました。実際、そのうちバインディング自体はいれるそうです（さすがに不便なので）。</p>
<h2>まとめ</h2>
<p>手で組み立てている人は結構多いと思うので、使えるシチュエーションはかなりあると思ってます。ただまあ、こんぐらいなら手でやるよ！と思う人は多いと思うので、その点ではニッチかなあ、というところですね。Web APIの仕様によってはリクエストパラメーターが微妙にデカくてイライラすることがあったり、まぁあとは数を作るときにはやっぱダルいので、ハマるシチュエーションも少なくはないかな、と。</p>
<p>とりあえずは試してみてもらえればと思います。</p>
</div>
<h1><a href="https://neue.cc/2021/12/31.html">2021年を振り返る</a></h1>
<ul class="date"><li>2021-12-31</li></ul>
<div class="entry_body"><p>例年、30日に投稿しているはずなのですが、今年は、どうしても今年中に作りきりたいという思いで<a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4</a>のリリースをしてしまったので31日で。今年の後半から道具をガラーッと変えて、それがいい感じに作用していったので、なんか満足した気でいます。</p>
<h2>Heyをとにかく薦めたい</h2>
<p>今年良かったもの第一位は<a href="https://hey.com/">Hey</a>です。Ruby on Rails作者のDHHがやってる会社(Basecamp)のメールサービスなのですが、これが抜群によく出来てる！今までメール一ヶ月放置は当たり前、未読1万件、みたいな状態だったのですが、After Heyでは未読0。すごい。メーラー変えただけでこんな変わるとは。よく出来たツールは人を変えるね。</p>
<p>どうしてもたまりがちな、スパムではないけど自分にとってはスパムに等しいもの（なんだかんだで送られてくる広告メールとかね）を、実質スパム扱いして、一生このメールは見ないという設定をワンポチでできるのが小気味よい。ワンポチどころか、最初のメール受信時に強制的に決めさせることで（決めないとメールが受信ボックスに入らないので、決めるしかない）、最初に使うときの罪悪感というか、とはいえ見るかもしれないしー、役に立つときもあるかもしれないしー、みたいななんとなくある抵抗感みたいなのを、その手で実行させ続けることにより薄れさせていく手腕は見事というほかない。</p>
<p>メールを3分類、読むものとフィード的に見るもの（メルマガとかGitHubのWatchとか）と、領収書系で分けたというのもセンスを感じる。領収書は、例えばKindleで購入するたびに買いましたメールは、捨てるのもアレだけど別に自明すぎて見たくはない、ものが溜まっていくとメールボックスがウザいことになる、を専用の置き場を用意しました、で解決しているのはなるほどなー、と。フィード的なのは全部連結されているので、スクロールさせてバッと流し見で終わらせられるのも良い。</p>
<p>細かいフィルターはできないけど、そもそも細かいフィルターなんて作るの面倒だしメンテ不能になるだけだから作るんじゃねえ、俺達の考えた最高のRailに乗ってりゃあいいんだよ、という押し付けがましさ全開の思想性溢れるのが、いいですね。そういうの、嫌いじゃないです。DHHの語るプログラミング的な思想も好きですしね、私は。Rubyは使いませんが、DHHの思想には納得できるものがめちゃくちゃ多くて割と好きなので。</p>
<p>メールアドレスという、なんだかんだで変えられない、変えにくいものなのに、 <code>hey.com</code> を使え！というのは中々ハードル高いのですが(基本的に汎用メーラーとしては使えず、専用メールアドレスが必要。GMailのクライアントにもPOP3クライアントにもならない)、今回私は10年以上使ってきたプロバイダのメールアドレスが不慮の事故により完全消滅したので、思い切って乗り換えることができました。結果、良かった。怪我の功名ということで。</p>
<h2>iPad miniがとにかく良い</h2>
<p>タブレットは、というかiPadはなんだかんだで今まで色々なサイズのものを買ってきました。普通のもAirもPro 13インチも。そしてほとんど全く使わなかったのですが……！なんか面倒くさくてねー、重いしー、と。で、iPhoneがPro Maxで大きいから、そこまでサイズ変わらないしねえと思ってminiだけは手を出さなかったのですが、世間でiPad mini 6があまりにも評判がいいので、じゃあまぁ試してみるかと買ったら、なるほど納得！これは超いい！最高……！</p>
<p>やっぱ重さとサイズ感ですかね。これなら手軽に持ち運べる（今の時期コートとかだったらポケットにすら入る）し、片手で持てるというのが読みやすさにもめっちゃ寄与してる。デカいと手も疲れるし、ちゃっと手にとってソファで読もうとかいう気になれなかったわけですが、このサイズ感は絶妙、でした。大きさ的にも全然iPhone Pro Maxよりは明らかに大きくて、雑誌も十分読めるレベルで、漫画は快適。</p>
<p>iPad miniのサイズのままで高級路線（有機EL積んでもらうとか）して欲しいですね。</p>
<p>で、とても気に入ったので、いい感じのスタンドないかなあと思って選んだのが<a href="https://www.moftjapan.com/products/moft-x-tablet-stand">MOFT X</a>。ちょうどiPad mini 6用のサイズのものが出たのでこれがまた快適。どこでもいつでもさっくりスタンドになるのがこんなに良いとは。厚すぎない/重すぎないので、背中に常時貼り付けている状態でも苦にならないし。なんだったらカメラの出っ張り（うざい！）が相殺されて、平らなところにおいてもガタつかなくなったのが最高。</p>
<h2>5K2Kは捗る</h2>
<p>家の作業環境に割と不満があって、特にモニタ環境が良くなかった（32インチ4K + WQXGAの組合わせ、別に悪くはないんですけどね）ので、5K2K(5120x2160)モニタに変更。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147818725-e1529666-172f-40fe-aa69-0491a27091d9.png" alt="image" /></p>
<p>現状だとこの解像度は<a href="https://www.dell.com/ja-jp/shop/dell-u4021qw-40%E3%82%A4%E3%83%B3%E3%83%81%E3%83%AF%E3%82%A4%E3%83%89%E6%9B%B2%E9%9D%A2usb-c-hub-%E3%83%A2%E3%83%8B%E3%82%BF-5k2k-21-9-ips%E9%9D%9E%E5%85%89%E6%B2%A2-tbhdmix2dprj45-%E9%AB%98%E3%81%95%E8%AA%BF%E6%95%B4/apd/210-aypy/%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC-%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B5%E3%83%AA%E3%83%BC">Dell U4021QW</a>一択。40インチは大きいかなーと思ったんですが、横に長いから高さ的には今まで使ってた32インチとそう変わらず、ですかね。デカいっちゃあデカですが、こんなもんかな、という感じでもある。この机も横1200の机でそんあ大きい机じゃないんですが、ジャストサイズぐらいで収まりますし。</p>
<p>人によっては100%サイズで使うのは小さい、と思ってしまいそうなところですが、私的には人体改造済み(<a href="https://www.sannoclc.or.jp/hospital/icl/">ICL</a>というレンズを眼球に埋める手術をしたので)なので問題なし、ということで100%サイズで使っています。</p>
<p>このサイズ、いい感じに視野に全部収まるので、デュアルやトリプルよりも快適さあります。今まで、最大で5画面ぐらいまでモニタ増やしてきたのですが、結局メイン以外のものは首をふるのもダルくてそんなに使える感じではないし、音楽プレイヤーのプレイリストを並べるとかだったら、置いてるiPadで聞いて表示しとけばいいじゃん、ということで、全然問題なし。</p>
<p>ツール補助がないとウィンドウがとっちらかってしまうので、Microsoft PowerToysの<a href="https://docs.microsoft.com/ja-jp/windows/powertoys/fancyzones">FancyZones</a>を使って割り振ってます。これのグリッド吸着がまた使いやすくて(Shift押しながら移動すると、事前定義したグリッドに張り付く)いいですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147815474-6deb6990-da99-44e0-9d29-c2c39917395e.png" alt="image" /></p>
<p>中央を広めに取りつつ(主にVisual Studioか、ブラウザがっつし見たりするときはブラウザを置く)、右にブラウザ、左は半分に割って下にGitKraken、上にExplorerみたいなパターンが多めでしょうか。Visual Studio + Unityとか、作業域的に大きく取りたいものを並べる場合は2分割のグリッドパターンも用意して、切り替えるようにしています。</p>
<p>3分割みたいなのは、5K2Kぐらいの解像度がないと出来ないので、この解像度のモニタ増えてくれーって感じですね。選択肢がDELLしかないのは寂しい。液晶自体の画質もそんな良いわけでもないので、もう少し良いのが欲しい。しっかりしたHDR対応のが欲しい。120Hz出るのが欲しい。とか、思うところはそれなりにあります。とはいえ、それでも大満足です。もうこれ以外の解像度のモニタには戻りたくないなあ。</p>
<p>と、いうわけで、モニタ変更のためにゴミ溜めだった机をキレイにした記念で、来年はずっとすっきりした机をキープするぞ、という強い気持ちがあります！単純に机がキレイになってたほうが作業やりやすいですしねー、やっぱゴミ溜めはダメですよ。</p>
<p>キーボードをREALFORCE R3にしたのですが（前はR2でした）、今回からデフォ無線なんですね。キーボードなんて置きっぱなしだから別に有線でいいだろ、と思ってたんですが、これはこれでアリというか、めっちゃいいじゃん？と。サッとキーボードどかしたりがやりやすくなったのがいいですね、デスクで他の作業がやりやすくて。Bluetoothだから、そのままiPadやiPhoneに繋げてもいいし。いやあ、時代は無線。ケーブルがなくなってすっきりするし。</p>
<p>と、いうわけで、無線環境が気に入ったので、デカい有線ヘッドフォン＋ヘッドフォンアンプを使っていたのですが(MDR-Z1R + TA-ZH1ES、合計40万もした)、撤去して、写真には写ってませんがAirPods Max買いました。これも満足。いやー、正直あんま有線ヘッドフォン使ってなかったんですよね、面倒くさくて。電源入れるだけ、ではありんですがやっぱ面倒くさくて。ケーブル太くて邪魔くさいし（無駄にケーブル換装して太いケーブルにしてしまったのも良くなかった）。PC専用になっちゃってiPhoneの音も聞けないし。</p>
<p>AirPods MaxだとiPhone/iPad/PCの切り替えが自由なのが想像の100億倍良いなあ、と。音質面でも悪くないし、Apple Musicの空間オーディオとの相性は抜群でこれはめちゃくちゃいいし、さすがのヘッドフォン型なのでAirPods Proよりも音がいい。デジタルクラウンによる音量調整は最高に便利。ゲーム用に<a href="https://www.dolby.com/jp/ja/apps/access.html">Dolby Access</a>入れてDolby Atmos for Headphonesを有効化してますが、これもなかなか良い。</p>
<p>スピーカーも置いてたんですが、撤去しました。簡単なものはモニタ内蔵のしょぼいスピーカーで済ませる。ちゃんと聴きたい場合はAirPods Max。それでいいや、と。割り切ったら、全然それでいいじゃん、という気になりました。そもそもあまりデスクトップのスピーカーを稼働させてないしなあ、というのもありますが。</p>
<h2>時代は無線</h2>
<p>スピーカー撤去の代わりに、じゃないのですが、今年はホームシアターシステムとして<a href="https://www.sony.jp/home-theater/products/HT-A9/">HT-A9</a>を導入したのですが、これも満足度高い。何がいいって、設置が無線で自由度高い。なんか今年は無線化の年ですね、時代は無線。</p>
<p>昔は9.1chにしてたり5.1chだったりでスピーカー並べてたのですが、諸事情あってここ数年はサウンドバーを使ってたんですが、とにかくその音質には不満だったんですね。かといってリアスピーカー並べる気力も起きずというか、そのスペースも確保できない状態なのでどうしたものか、と思っていたところに出たのが、フル無線4.1chシステムのHT-A9。360 Spatial Sound MappingでDolby Atomos時代なサラウンドにするという謳い文句もいいし、設置レイアウトが自由というのがいい。オフィシャルサイトのこの画像を見て購入を決めました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147816734-1c61b5b5-3150-47e0-b4f1-23aa0973f436.png" alt="image" /></p>
<p>HT-A9の画像、どれもフロントスピーカーの置き方が「わざとらしく」でたらめなんですよね、高さを絶対揃えない。これは、メーカーが別に高さ揃えなくていいんですよ、と推奨してるということなんですが、実際うちでの設置環境もフロントの高さは揃ってないです。揃えられないので。リアも位置も高さもグチャグチャで、適当における棚に置いてるだけって感じです。フロントもリアも無線スピーカーなので、そういう適当配置がめっちゃやりやすい。</p>
<p>それでもちゃんとサウランドするし、360 Spatialな音は心地良い。ただたんに音楽鳴らすだけにも使ってますね、起動も早いのでSpotify Connectでよく流してます。</p>
<p>アンプのサイズが小さい(Apple TVが一回り大きくなった程度)というのも設置が楽になった要因で、いやほんとよく出来てますね。確かに、全部無線なのでスピーカーを駆動するアンプは各スピーカー内蔵状態だから、本体をAVアンプあるあるなクソデカサイズにしなくてもいいんですね。そういうところにも無線の良さが出てますね。</p>
<h2>来年に向けてのC#</h2>
<p>こうしてダラダラと文章書いたり、そもそもこの12月はやたら記事量産しているなあ、というのは、ブログ書く環境が変わったからです！10年前のWordPressから<a href="https://neue.cc/2021/11/21.html">自家製サイトジェネレーターへの変更</a>によって快適度上がったからですね。いやあ、書きやすいと書く気になります。環境大事。</p>
<p>そんなわけでCysharpはC#はの環境を良くすることに今年一年もちゃんと務められたんじゃないでしょーか。Cysharpからの新規リリース/大型更新は</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">ProcessX Zx</a></li>
<li><a href="https://github.com/Cysharp/MessagePipe">MessagePipe</a></li>
<li><a href="https://github.com/Cysharp/Kokuban">Kokuban</a></li>
<li><a href="https://github.com/Cysharp/CsprojModifier">CsprojModifier</a></li>
<li><a href="https://github.com/Cysharp/NativeMemoryArray">NativeMemoryArray</a></li>
<li><a href="https://github.com/Cysharp/ConsoleAppFramework/">ConsoleAppFramework v4</a></li>
<li><a href="https://github.com/Cysharp/ObservableCollections">ObservableCollections</a> ←ReadMe/解説がまだな仕掛品</li>
</ul>
<p>MessagePipeが大きめかな？</p>
<p>こうした公開していく姿勢、足を少しでも止めてはダメだという思いがあるので、作ろうと思ったらできるだけ勢い持って作りきるようにしています（もちろん途中で止まってしまったものも幾つかありはしますが）。毎年継続的に、Cysharp全体としても既に20個以上公開していて、ヒット作もそれなりの量を出し続けていられる状態は中々のことだと思います。</p>
<p>と、いうわけで、OSSを通じてCysharpをアピールしていくという方向では、良い点をあげてもいいかな、と思うのですが、反面、他の仕事に集中しきれていないのではないかというのが散見していたのは個人的にはマイナスです。今年は「世の中の開発生産性を革命的に改善するプロダクト」の作成に着手し（構想は前からあったのですがようやく始動）、徐々に人も集めだしてCysharpが割とまともな（？）会社っぽく動き出した頃合いでもあるんですが、私がボトルネックになりがち、な状況になりがちなのが、まぁいくないですねえ、と。これはグラニの頃もそうだったので、なんかもうそういうもの感もあるんですが、今回は私が主導してやってるので尻拭いしてくれる人もいないので純粋に良くない！</p>
<p>というわけで、来年の中旬までにその「世の中の開発生産性を革命的に改善するプロダクト」をリリースするために全力でやっていくぞ、というのが目標です。実際出来上がってきて、かなりいいものになりそうな手応えはあるので、早く世の中に出して評価されたいものです。</p>
<p>まぁ、そんなわけで大きな何かがあったわけではないですが、確実に前進した年だと思うので、来年は爆発させる年にしましょう。</p>
</div>
<h1><a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4 - Minimal API for CommandLine tool</a></h1>
<ul class="date"><li>2021-12-30</li></ul>
<div class="entry_body"><p>皆さん .NET 6で追加された<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/minimal-apis">Minimal API</a>使ってみました？最初は別にいらんやろ、とか思ってたんですが、いや、これ正直めっちゃ凄い、いい。まぁDelegateベースで書くかどうかは別として（書かないかなー）、謎Startupを葬り去ってBuilder/Runが素直に繋がった形が美しい。Top level statementとの相性も良いので、もうこっちのAPI以外で作る気しないなあ。</p>
<p>さて、ところでConsoleAppFrameworkです。今までクラスが必要だったんですよね、たった一個のメソッドを実装するにも。それがTop level statementとの相性が悪い。Top level statementだけで完結できるとき、クラスって作りたくないんですよね。と、いうわけで、そろそろ大改修が必要かなーと思っていたところにMinimal APIですよ。特にその場でラムダ式でばしばしAPI作っていくスタイルは、むしろコマンドラインツールのほうがマッチするじゃんどう考えても？</p>
<p>と、いうわけで大改修して、Minimal APIベースになったv4、作りました。何が凄いって、一行でコマンドライン引数をパースしてハンドラー定義できちゃうんですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147662718-f7756523-67a9-4295-b090-3cfc94203017.png" alt="" /></p>
<pre><code class="language-csharp">ConsoleApp.Run(args, (string name) =&gt; Console.WriteLine($&quot;Hello {name}&quot;));
</code></pre>
<p>これは嘘偽りなくNuGetからダウンロードしたら、そのままでこう書けます。C# 10.0のglobal using(をNuGetのライブラリ側に埋め込むというEvilな手法を使ってます)と、ラムダ式の推論の向上によって実現しました。内側では、Minimal APIの実現のために Microsoft.Extensions.* 側にもかなり改修が入っていたので、それをそっくりそのまま利用できました。そういう意味で、 .NET 6になった今だからようやく作れた形になりますね。もちろんv1~v3までの蓄積のお陰というところもあります。集大成……！</p>
<ul>
<li><a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a></li>
</ul>
<p>さて、Runはちょっとウケ狙いなところもあるんですが、それ以外のAPIもBuilderベースになったので、だいぶ様変わりしています。ただし特徴としてGeneric Hostの上に乗っているというのは変わらないので、DbContext埋めたりappconfig.jsonから取ったりというのは、変わらずスムーズにできます。</p>
<pre><code class="language-csharp">// You can use full feature of Generic Host(same as ASP.NET Core).

var builder = ConsoleApp.CreateBuilder(args);
builder.ConfigureServices((ctx,services) =&gt;
{
    // Register EntityFramework database context
    services.AddDbContext&lt;MyDbContext&gt;();

    // Register appconfig.json to IOption&lt;MyConfig&gt;
    services.Configure&lt;MyConfig&gt;(ctx.Configuration);

    // Using Cysharp/ZLogger for logging to file
    services.AddLogging(logging =&gt;
    {
        logging.AddZLoggerFile(&quot;log.txt&quot;);
    });
});

var app = builder.Build();

// setup many command, async, short-name/description option, subcommand, DI
app.AddCommand(&quot;calc-sum&quot;, (int x, int y) =&gt; Console.WriteLine(x + y));
app.AddCommand(&quot;sleep&quot;, async ([Option(&quot;t&quot;, &quot;seconds of sleep time.&quot;)] int time) =&gt;
{
    await Task.Delay(TimeSpan.FromSeconds(time));
});
app.AddSubCommand(&quot;verb&quot;, &quot;childverb&quot;, () =&gt; Console.WriteLine(&quot;called via 'verb childverb'&quot;));

// You can insert all public methods as sub command =&gt; db select / db insert
// or AddCommand&lt;T&gt;() all public methods as command =&gt; select / insert
app.AddSubCommands&lt;DatabaseApp&gt;();

app.Run();
</code></pre>
<p>単独のコマンドラインツール用に使ってもいいのですが、ASP.NETのウェブアプリが他にあって、それのバッチを作りたいみたいなときに、こうしたコンフィグの共通化はめっちゃ便利に使えるはずです。ConfigureServicesのコードはまんま一緒にできて、そのままDIできますからね。</p>
<p>また、引き続き <code>AddCommands&lt;T&gt;</code> や <code>AddAllCommandType</code> によって、メソッド定義するだけで大量のコマンドを一括追加も可能になっています。</p>
<h2>v3 -&gt; v4の破壊的変更</h2>
<p>破壊的変更、は沢山あるのですが、基本的に今までの使い方をしている場合は互換オプションで動くようにしたので、アップデートしたから壊れるということはない、はずです。v4からは<code>ConsoleApp.Create/CreateBuilder</code> 経由で作るのが基本なのですが、v3は <code>Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&lt;T&gt;()</code> 経由なので、ちょうど互換性オプションを突っ込むのに都合が良かったんですね。なお、<code>RunConsoleAppFrameworkAsync</code>はエディタから見えないようにしてます。今後は非推奨で、本当に互換のためだけに残してます。</p>
<p>まず変わったところは、デフォルトで長いオプション名が<code>--</code>、短いオプション名が<code>-</code>になりました。v3では<code>-</code>が幾つついていてもいいというゆるふわマッチングだったのですが、(dotonet toolsと同じように)厳格化しています。</p>
<p>また、デフォルトのコマンド/オプション名の変換ルールが単純なlower化から、hoge-hugaというlowerなkebab-caseになりました。これもdotnet tools合わせですね。</p>
<p>また、<code>AddCommands&lt;T&gt;</code>した場合の挙動(v3では<code>RunConsoleAppFrameworkAsync&lt;T&gt;</code>した場合)が、全てのpublicメソッドをコマンドとして追加するようになりました。デフォルト(ルート)コマンドにしたい場合は<code>[RootCommand]</code>属性を付与してくださいということで。これは<code>AddSubCommand&lt;T&gt;</code>した時と挙動を合わせたかったからです、違うと一貫性がなくて戸惑うので。</p>
<p>と、いうわけで、互換性モードで動かした場合は<code>ConsoleAppOptions</code>は以下のような変更で動くようになっています。よきかなよきかな。（それとargsのコマンド名でHoge.Hugaが来てたらHoge Hugaに分解するのも、この互換性モードだけの挙動です）</p>
<pre><code class="language-csharp">options.StrictOption = false;
options.NoAttributeCommandAsImplicitlyDefault = true;
options.NameConverter = x =&gt; x.ToLower();
options.ReplaceToUseSimpleConsoleLogger = false;
</code></pre>
<p>そうだ、それとCtrl+Cした場合に、正しくCancellationTokenをハンドリングしていない場合でも、タイムアウトをハンドリングしてabortするようになりました。これは、なんか強制終了できなくてウゼーってなりがちというか、私自身よく引っかかってヤバかったので。むしろこれは今までがバグに近くて、正しく<code>HostOptions.ShutdownTimeout</code>を処理していないせいでした。</p>
<p>ちなみにこのタイムアウト時間はデフォルトは5秒で、ConfigureHostOptions(地味にこれは.NET 6(というかMicrosoft.Extensionsのv6)からの新API)で変更できます。</p>
<pre><code class="language-csharp">var app = ConsoleApp.CreateBuilder(args)
    .ConfigureHostOptions(options =&gt;
    {
        // change timeout.
        options.ShutdownTimeout = TimeSpan.FromMinutes(30);
    })
    .Build();
</code></pre>
<h2>まとめ</h2>
<p>無計画にアドホックに作っていったせいで、どうにもクソコードすぎて、改修にめっちゃ手間取ったというか内部的にはほぼ作り直した……。弄るのだるくて嫌だなあと内心実際今まで思ってたんですが、やはりとても嫌なコードであった。v1の時の最初の発想が Class.Method にパラメータ分解してバッチを大量に作りたい(そもそもライブラリ名もMicroBatchFrameworkだったし)というものだけだったのが、徐々に汎用コマンドラインツールに進化していって、都度、適当に追加していった結果ではある。</p>
<p>今回がっつし仕切り直したので、しばらくはメンテが楽になれるかなあ、という感じで、よきかなよきかな。</p>
<p>まぁしかしC# 10.0は地味にヤバいですよ！使えば使うほど味が出てくるというか、最近ようやく手に馴染んで、よくわかってきた感じです。なんというか、とにかく、めっちゃいい。それとC# 10.0 + ConsoleAppFrameworkは全言語見渡しても最強のコマンドラインツール作成ライブラリじゃないです？いや、API自体のできの良さはほとんど ASP .NET CoreのMinimal APIのコピーにすぎないんですが、まぁしかしそれでもやっぱ、これはかなり良い感じじゃないかという手応えがあります。</p>
</div>
<h1><a href="https://neue.cc/2021/12/22.html">NativeMemoryArray - .NET 6 APIをフル活用した2GB超えの巨大データを扱うライブラリ</a></h1>
<ul class="date"><li>2021-12-22</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/microsoft">.NET 6 Advent Calendar 2021</a>の12日の代理投稿となります。プレゼント付きですと！？<a href="https://www.balmuda.com/jp/brew/special-model">BALMUDA The Brew STARBUCKS RESERVE LIMITED EDITION</a>が欲しいです！</p>
<p>さて、先程NativeMemoryArrayという新しいライブラリを作成し、公開しました。.NET Standard 2.0でも動作しますが、全体的に .NET 6 の新API群(NativeMemory, Scatter/Gather I/O)を活かすための作りになっていますので、今回のAdvent Calendarにもピッタリ。実用性も、ある……！あります……！もちろんUnity版も用意してあります（NativeArrayと何が違うって？まぁ違うと言えば違います）。</p>
<ul>
<li><a href="https://github.com/Cysharp/NativeMemoryArray">GitHub - Cysharp/NativeMemoryArray</a></li>
</ul>
<p>C#には配列、特にbyte[]を扱う上で大きな制約が一つあります。それは、一次元配列の上限値が0x7FFFFFC7(2,147,483,591)ということ。int.MaxValueよりちょっと小さめに設定されていて、ようするにざっくり2GBちょいが限界値になっています。</p>
<blockquote>
<p>この限界値は、正確には .NET 6 でひっそり破壊的変更が行われましたので、.NET 6とそれ以外で少し異なります。詳しくは後で述べます。</p>
</blockquote>
<p>この2GBという値は、int Lengthの都合上しょうがない(intの限界値に引っ張られている)のですが、昨今は4K/8Kビデオや、ディープラーニングの大容量データセットや、3Dスキャンの巨大点群データなどで、大きな値を扱うことも決して少ないわけではないため、2GB制約は正直厳しいです。そして、この制約は<code>Span&lt;T&gt;</code>や<code>Memory&lt;T&gt;</code>であっても変わりません(Lengthがintのため)。</p>
<p>ちなみに<code>LongLength</code>は多次元配列における全次元の総数を返すためのAPIのため、一次元配列においては特に意味をなしません。.NET Frameworkの設定である<a href="https://docs.microsoft.com/ja-jp/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element">gcAllowVeryLargeObjects</a>も、構造体などを入れた場合の大きなサイズを許容するものであり(例えば4バイト構造体の配列ならば、2GB*4のサイズになる)、要素数の限界は超えられないため、byte[]としては2GBが限界であることに変わりはありません。</p>
<p>こうした限界に突き当たった場合は、ストリーミング処理に切り替えるか、またはポインタを使って扱うかになりますが、どちらもあまり処理しやすいとは言えませんし、必ずしもインメモリで行っていた操作が代替できるわけではありません（ポインタなら頑張れば最終的にはなんとでもなりますが）。</p>
<p>そこで、2GB制約を超えつつも、新しいAPI群(<code>Span&lt;T&gt;</code>, <code>IBufferWriter&lt;T&gt;</code>, <code>ReadOnlySequence&lt;T&gt;</code>, <code>RandomAccess.Write/Read</code>, <code>System.IO.Pipelines</code>など)と親和性の高いネイティブメモリを裏側に持つ配列（みたいな何か）を作りました。</p>
<p>これによって、例えば巨大データの読み込み/書き込みも、 .NET 6の新Scatter/Gather APIの<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>を用いると、簡単に処理できます。</p>
<pre><code class="language-csharp">// for example, load large file.
using var handle = File.OpenHandle(&quot;4GBfile.bin&quot;, FileMode.Open, FileAccess.Read, options: FileOptions.Asynchronous);
var size = RandomAccess.GetLength(handle);

// via .NET 6 Scatter/Gather API
using var array = new NativeMemoryArray&lt;byte&gt;(size);
await RandomAccess.ReadAsync(handle, array.AsMemoryList(), 0);

// iterate Span&lt;byte&gt; as chunk
foreach (var chunk in array)
{
    Console.WriteLine(chunk.Length);
}
</code></pre>
<p>Scatter/Gather APIに馴染みがなくても、<code>IBufferWriter&lt;T&gt;</code>や <code>IEnumerable&lt;Memory&lt;T&gt;&gt;</code> を経由してStreamで処理する手法も選べます。</p>
<pre><code class="language-csharp">public static async Task ReadFromAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    var writer = buffer.CreateBufferWriter();

    int read;
    while ((read = await stream.ReadAsync(writer.GetMemory(), cancellationToken).ConfigureAwait(false)) != 0)
    {
        writer.Advance(read);
    }
}

public static async Task WriteToAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    foreach (var item in buffer.AsMemorySequence())
    {
        await stream.WriteAsync(item, cancellationToken);
    }
}
</code></pre>
<p>あるいは<code>Span&lt;T&gt;</code>のSliceを取り出して処理してもいいし、<code>ref T this[long index]</code>によるインデクサアクセスやポインタの取り出しもできます。 .NET 6時代に完全にマッチしたAPIを揃えることで、標準の配列と同等、もしくはそれ以上の使い心地に仕上げることによって、C#の限界をまた一つ超える提供できたと思っています。</p>
<p>とはいえもちろん、 .NET Standard 2.0/2.1 にも対応しているので、非 .NET 6なAPIでも大丈夫です、というかScatter/Gather API以外は別に今までもありますし普通に使えますので。</p>
<p>普通の配列的にも使えます。GC避けには、こうした普通のAPIを使っていくのでも便利でしょう、</p>
<pre><code class="language-csharp">// call ctor with length, when Dispose free memory.
using var buffer = new NativeMemoryArray&lt;byte&gt;(10);

buffer[0] = 100;
buffer[1] = 100;

// T allows all unmanaged(struct that not includes reference type) type.
using var mesh = new NativeMemoryArray&lt;Vector3&gt;(100);

// AsSpan() can create Span view so you can use all Span APIs(CopyTo/From, Write/Read etc.).
var otherMeshArray = new Vector3[100];
otherMeshArray.CopyTo(mesh.AsSpan());
</code></pre>
<h2><code>NativeMemoryArray&lt;T&gt;</code></h2>
<p><code>NativeMemoryArray&lt;T&gt;</code>はwhere T : unmanagedです。つまり、参照型を含まない構造体にしか使えません。まぁ巨大配列なんて使う場合には参照型含めたものなんて含めてんじゃねーよなので、いいでしょうきっと。巨大配列で使えることを念頭においてはいますが、別に普通のサイズの配列として使っても構いません。ネイティブメモリに確保するので、ヒープを汚さないため、適切な管理が行える箇所では便利に使えるはずです。</p>
<p><code>Span&lt;T&gt;</code>との違いですが、<code>NativeMemoryArray&lt;T&gt;</code>そのものはクラスなので、フィールドに置けます。<code>Span&lt;T&gt;</code>と違って、ある程度の長寿命の確保が可能ということです。<code>Memory&lt;T&gt;</code>のSliceが作れるため、Async系のメソッドに投げ込むこともできます。また、もちろん、<code>Span&lt;T&gt;</code>の長さの限界はint.MaxValueまで(ざっくり2GB)なので、それ以上の大きさも確保できます。</p>
<p>Unityにおける<code>NativeArray&lt;T&gt;</code>との違いですが、<code>NativeArray&lt;T&gt;</code>はUnity Engine側との効率的なやりとりのための入れ物なので、あくまでC#側で使うための<code>NativeMemoryArray&lt;T&gt;</code>とは全然役割が異なります。まぁ、必要に思えない状況ならば、おそらく必要ではありません。</p>
<p>主な長所は、以下になります。</p>
<ul>
<li>ネイティブメモリから確保するためヒープを汚さない</li>
<li>2GBの制限がなく、メモリの許す限り無限大の長さを確保できる</li>
<li><code>IBufferWriter&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonWriter, System.IO.Pipelinesなどから直接読み込み可能</li>
<li><code>ReadOnlySequence&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonReaderなどへ直接データを渡すことが可能</li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt;</code>, <code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt;</code> 経由で <code>RandomAccess</code>(Scatter/Gather API)に巨大データを直接渡すことが可能</li>
</ul>
<p>あまりピンと来ない、かもしれませんが、使ってみてもらえれば分かる、かも。</p>
<p><code>NativeMemoryArray&lt;T&gt;</code>の全APIは以下のようになっています。</p>
<ul>
<li><code>NativeMemoryArray(long length, bool skipZeroClear = false, bool addMemoryPressure = false)</code></li>
<li><code>long Length</code></li>
<li><code>ref T this[long index]</code></li>
<li><code>ref T GetPinnableReference()</code></li>
<li><code>Span&lt;T&gt; AsSpan()</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start)</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start, int length)</code></li>
<li><code>Memory&lt;T&gt; AsMemory()</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start)</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start, int length)</code></li>
<li><code>bool TryGetFullSpan(out Span&lt;T&gt; span)</code></li>
<li><code>IBufferWriter&lt;T&gt; CreateBufferWriter()</code></li>
<li><code>SpanSequence AsSpanSequence(int chunkSize = int.MaxValue)</code></li>
<li><code>MemorySequence AsMemorySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt; AsMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt; AsReadOnlyMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>ReadOnlySequence&lt;T&gt; AsReadOnlySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>SpanSequence GetEnumerator()</code></li>
<li><code>void Dispose()</code></li>
</ul>
<p><code>AsSpan()</code>, <code>AsMemory()</code>はスライスのためのAPIです。取得したSpanやMemoryは書き込みも可能なため、 .NET 5以降に急増したSpan系のAPIに渡せます。SpanやMemoryには最大値(int.MaxValue)の限界があるため、lengthの指定がない場合は、例外が発生する可能性もあります。そこで<code>TryGetFullSpan()</code>を使うと、単一Spanでフル取得が可能かどうか判定できます。また、<code>AsSpanSequence()</code>, <code>AsMemorySequence()</code>でチャンク毎のforeachで全要素を列挙することが可能です。直接foreachした場合は、<code>AsSpanSequence()</code>と同様の結果となります。</p>
<pre><code class="language-csharp">long written = 0;
foreach (var chunk in array)
{
    // do anything
    written += chunk.Length;
}
</code></pre>
<p>ポインタの取得は、配列とほぼ同様に、そのまま渡せば0から(これは<code>GetPinnableReference()</code>の実装によって実現できます)、インデクサ付きで渡せばそこから取れます。</p>
<pre><code class="language-csharp">fixed (byte* p = buffer)
{
}

fixed (byte* p = &amp;buffer[42])
{
}
</code></pre>
<p><code>CreateBufferWriter()</code> によって <code>IBufferWriter&lt;T&gt;</code>を取得できます。これは<code>MessagePackSerializer.Serialize</code>などに直接渡すこともできるほかに、先の例でも出しましたがStreamからの読み込みのように、先頭からチャンク毎に取得して書き込んでいくようなケースで便利に使えるAPIとなっています。</p>
<p><code>AsReadOnlySequence()</code> で取得できる<code>ReadOnlySequence&lt;T&gt;</code>は、<code>MessagePackSerializer.Deserialize</code>などに直接渡すこともできるほかに .NET 5から登場した <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-6.0">SequenceReader</a>に通すことで、長大なデータのストリーミング処理をいい具合に行える余地があります。</p>
<p><code>AsMemoryList()</code>, <code>AsReadOnlySequence()</code>は .NET 6から登場した<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>の<code>Read/Write</code>に渡すのに都合の良いデータ構造です。プリミティブな処理なので使いにくいと思いきや、意外とすっきりと処理できるので、File経由の処理だったらStreamよりもいっそもうこちらのほうがいいかもしれません。</p>
<h2>NativeMemory</h2>
<p>.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.nativememory?view=net-6.0">NativeMemory</a>というクラスが新たに追加されました。その名の通り、ネイティブメモリを扱いやすくするものです。今までも<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=net-6.0">Marshal.AllocHGlobal</a>といったメソッド経由でネイティブメモリを確保することは可能であったので、何が違うのか、というと、何も違いません。実際NativeMemoryArrayの .NET 6以前版はMarshalを使ってますし。そして .NET 6 では Marshal.AllocHGlobal は NativeMemory.Alloc を呼ぶので、完全に同一です。</p>
<p>ただしもちろん .NET 6 実装時にいい感じに整理された、ということではあるので、NativeMemory、いいですよ。NativeMemory.Allocがmalloc、NativeMemory.AllocZeroedがcalloc、NativeMemory.Freeがfreeと対応。わかりやすいですし。</p>
<p>ちなみにゼロ初期化する NativeMemory.AllocZeroed に相当するものはMarshalにはないので、その点でも良くなったところです。<code>NativeMemoryArray&lt;T&gt;</code>では、コンストラクタのskipZeroClear(<code>public NativeMemoryArray(long length, bool skipZeroClear = false)</code>)によってゼロ初期化する/しないを選べます。デフォルトは（危ないので）初期化しています。非.NET 6版では、メモリ確保後に<code>Span&lt;T&gt;.Clear()</code>経由で初期化処理を入れています。</p>
<h2>真のArray.MaxValue</h2>
<p>.NET 6以前では、配列の要素数はバイト配列(1バイト構造体の配列)と、それ以外の配列で異なる値がリミットに設定されていました。例えば<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array?view=net-6.0">System.Arrayのドキュメント</a>を引いてくると</p>
<blockquote>
<p>配列のサイズは、合計で40億の要素に制限され、任意の次元の0X7FEFFFFF の最大インデックス (バイト配列の場合は0X7FFFFFC7、1バイト構造体の配列の場合) に制限されます。</p>
</blockquote>
<p>つまり、0X7FFFFFC7の場合と、0X7FEFFFFFの場合がある、と。</p>
<p>と、いうはずだったのですが、.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.maxlength">Array.MaxLength</a>というプロパティが新規に追加されて、これは単一の定数を返します。その値は、0X7FFFFFC7です。よって、いつのまにかひっそりと配列の限界値は(ちょびっと大きい方に)大統一されました。</p>
<p>この変更は意外とカジュアルに行われ、まず最大値を取得する、ただし単一じゃないため型によって結果の変わる <code>Array.GetMaxLength&lt;T&gt;()</code> を入れよう、<a href="https://github.com/dotnet/runtime/pull/43301">という実装があがってきました</a>。そうしたら、そのPR上での議論で、そもそも当初は最適化を期待したけど別にそんなことなかったし、統一しちゃってよくね？という話になり、そのまま限界値は統一されました。そして新規APIも無事、Array.MaxLengthという定数返しプロパティになりました。</p>
<p>まぁ、シンプルになって良いですけどね。大きい方で統一されたので実害も特にないでしょうし。前述のSystem.Arrayのドキュメントは更新されてないということで、正しくは、.NET 6からは0x7FFFFFC7が限界で、その値はArray.MaxLengthで取れる。ということになります。</p>
<p><code>Span&lt;T&gt;</code>の限界値はint.MaxValueなので、限界に詰め込んだ<code>Span&lt;T&gt;</code>をそのままToArray()すると死ぬ、という微妙な問題が発生することがあるんですが、まぁそこはしょうがないね。</p>
<h2>まとめ</h2>
<p>NativeArrayという名前にしたかったのですがUnityと被ってしまうので避けました。しょーがない。</p>
<p>着手当時はマネージド配列のチャンクベースで作っていたのですが(<a href="https://gist.github.com/neuecc/e6293b1d88244cf942753d6408b3e966">LargeArray.cs</a>)、Sliceが作りづらいし、ネイティブメモリでやったほうが出来ること多くて何もかもが圧倒的にいいじゃん、ということに作業進めている最中に気づいて、破棄しました。参照型の配列が作れるという点で利点はありますが、まぁ参照型で巨大配列なんて作らねーだろ、思うと、わざわざ実装増やして提供するメリットもないかな、とは。</p>
<p>配列はもう昔からあるのでint Lengthなのはしょうがないのですが、<code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>のLengthはlongであって欲しかったかなー、とは少し思っています。<a href="https://github.com/dotnet/apireviews/tree/main/2016/11-04-SpanOfT#spant-and-64-bit">2016年の段階でのSpanのAPIどうするかドキュメント</a>によると、候補は幾つかあったけど、結果的に配列踏襲のint Lengthになったそうで。2GBでも別に十分だろ、みたいなことも書いてありますが、いや、そうかなー？年にそこそこの回数でたまによく引っかかるんだけどねー？</p>
<p>そして2016年の議論時点ではなかった、C# 9.0で<a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/nint-nuint">nuint, nuint</a>が追加されたので、<code>nuint Span&lt;T&gt;/Memory&lt;T&gt;.Length</code>はありなんじゃないかな、と。</p>
<p>ただNativeMemoryArrayの開発当初は<code>nuint Length</code>で作っていたのですが、<code>AsSpan(nuint start, nuint length)</code>みたいなAPIは、カジュアルにintやlongを突っ込めなくて死ぬほど使いづらかったので、最終的にlongで統一することにしました。ので、<code>nuint Length</code>は、なしかな。つまり一周回って現状維持。そんなものかー、そんなもんですねー。</p>
</div>
<h1><a href="https://neue.cc/2021/12/04.html">.NET 6とAngleSharpによるC#でのスクレイピング技法</a></h1>
<ul class="date"><li>2021-12-04</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/csharplang">C# Advent Calendar 2021</a>の参加記事となっています。去年は2個エントリーしたあげく、1個すっぽかした（！）という有様だったので、今年は反省してちゃんと書きます。</p>
<p>スクレイピングに関しては10年前に<a href="https://neue.cc/2010/03/02_244.html">C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法</a>という記事でSGMLReaderを使ったやり方を紹介していたのですが、10年前ですよ、10年前！さすがにもう古臭くて、現在ではもっとずっと効率的に簡単にできるようになってます。</p>
<p>今回メインで使うのは<a href="https://anglesharp.github.io/">AngleSharp</a>というライブラリです。AngleSharp自体は2015年ぐらいからもう既に定番ライブラリとして、日本でも紹介記事が幾つかあります。が、いまいち踏み込んで書かれているものがない気がするので、今回はもう少しがっつりと紹介していきたいと思っています。それと直近Visual StudioのWatchウィンドウの使い方を知らん、みたいな話を聞いたりしたので、デバッグ方法の手順みたいなものを厚めに紹介したいなあ、という気持ちがあります！</p>
<p>AngleSharpの良いところは、まずはHTMLをパースしてCSSセレクターで抽出できるところです。以前はLINQ(to DOM)があればCSSセレクターじゃなくてもいいっす、WhereとSelectManyとDescendantsでやってきますよ、とか言ってましたが、そんなにきちんと構造化されてるわけじゃないHTMLを相手にするのにあたっては、CSSセレクターのほうが100億倍楽！CSSセレクターの文法なんて大したことないので、普通に覚えて使えってやつですね。SQLと正規表現とCSSセレクターは三大言語関係なく覚えておく教養、と。</p>
<p>もう一つは、それ自体でネットワークリクエストが可能なこと。FormへのSubmitなどもサポートして、Cookieも保持し続けるとかが出来るので、ログインして会員ページを弄る、といったようなクローラーが簡単に書けるんですね。この辺非常に良く出来ていて、もう自前クローラーなんて投げ捨てるしかないです。また、<a href="https://github.com/sebastienros/jint">Jint</a>というPure C#なJavaScriptインタプリタと統合したプラグインも用意されているので、JavaScriptがDOMをガリガリっと弄ってくる今風のサイトにも、すんなり対応できます。</p>
<p>AngleSharpの紹介記事では、よくHttpClientなどで別途HTMLを取ってきたから、それをAngleSharpのHtmlParserに読み込ませる、というやり方が書かれていることが多いのですが、取得も含めて全てAngleSharp上で行ったほうが基本的には良いでしょう。</p>
<p>ここまで来るとPure C#の軽量なヘッドレスブラウザとしても動作する、ということになるので、カジュアルなE2Eテストの実装基盤にもなり得ます。普通のユニットテストと並べて <code>dotnet test</code> だけでその辺もある程度まかなえたら、とても素敵なことですよね？がっつりとしたE2Eテストを書きたい場合は<a href="https://github.com/microsoft/playwright">Playwright</a>などを使わなければ、ということになってしまいますが、まずは軽い感じから始めたい、という時にうってつけです。C#で書けるし。いいことです。</p>
<h2>BrowingContextとQuerySelectorの基本</h2>
<p>まずはシンプルなHTMLのダウンロードと解析を。基本は <code>BrowsingContext</code> を作って、それをひたすら操作していくことになります。</p>
<pre><code class="language-csharp">// この辺で色々設定する
var config = Configuration.Default
    .WithDefaultLoader(); // LoaderはデフォではいないのでOpenAsyncする場合につける

// Headless Browser的なものを作る
using var context = BrowsingContext.New(config);

// とりあえずこのサイトの、右のArchivesのリンクを全部取ってみる
var doc = await context.OpenAsync(&quot;https://neue.cc&quot;);
</code></pre>
<p>OpenAsyncで取得できた <code>IDocument</code> をよしなにCSSセレクターで解析していくわけですが、ここで絞り込みクエリー作成に使うのがVisual StudioのWatchウィンドウ。（Chromeのデベロッパーツールなどで機械的に取得したい要素のCSSセレクターを取得できたりしますが、手セレクターのほうがブレなくルールは作りやすいかな、と）。</p>
<p>デバッガーを起動して、とりあえずウォッチウィンドウを開いておもむろに、Nameのところでコードを書きます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144583627-0c7982e4-4933-41f7-ba04-81836f10da8c.png" alt="image" /></p>
<p>ウォッチウィンドウは見たい変数を並べておく、お気に入り的な機能、と思いきや本質的にはそうじゃなくて、式を自由に書いて、結果を保持する、ついでに式自体も保持できるという、実質REPLなのです。代入もラムダ式もLINQも自由に書けるし、入力補完も普通に出てくる。Immediate Windowよりも結果が遥かに見やすいので、Immediate Windowは正直不要です。</p>
<p>デバッガー上で動いているので実データを自由に扱えるというところがいいですね。というわけで、ToHtml()でHTMLを見て、QuerySelectorAllをゆっくり評価しながら書いていきましょう。まずはサイドバーにあるので <code>.side_body</code> を出してみると、あれ、二個あるの？と。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144582934-371930f2-dbff-4341-9f92-87e27c56d477.png" alt="image" /></p>
<p>中開けてInnerHtml見ると、なるほどProfile部分とArchive部分、と。とりあえず後ろのほうで固定のはずなのでlast-childね、というところで一旦評価して大丈夫なのを確認した後に、あとはa、と。でここまでで期待通りの結果が取れていれば、コピペる。よし。</p>
<pre><code class="language-csharp">// 基本、QuerySelectorかQuerySelectorAllでDOMを絞り込む
var anchors = doc.QuerySelectorAll(&quot;.side_body:last-child a&quot;)
    .Cast&lt;IHtmlAnchorElement&gt;() // AngleSharp.Html.Dom
    .Select(x =&gt; x.Href)
    .ToArray();
</code></pre>
<p>単一の要素に絞り込んだ場合は、 <code>IHtml***</code> にキャストしてあげると扱いやすくなります(attributeのhrefのtextを取得、みたいにしなくていい)。頻出パターンなので、<code>QuerySelectorAll&lt;T&gt;</code>でCastもセットになってすっきり。</p>
<pre><code class="language-csharp">doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;)
</code></pre>
<p>せっかくなので、年に何本記事を書いていたかの集計を出してみたいと思います！URLから正規表現で年と月を取り出すので、とりあえずここでもウォッチウィンドウです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144590970-34c3bff4-0f0b-4db3-a259-f37a6f1e5f40.png" alt="image" /></p>
<p>anchrosの[0]を確認して、これをデータソースとしてRegex.Matchを書いて、どのGroupに収まったのかを見ます。この程度だったら特にミスらないでしょー、と思いきや普通に割とミスったりするのが正規表現なので、こういうので確認しながらやっていけるのはいいですね。</p>
<p>後は普通の（？）LINQコード。グルーピングした後に、ひたすら全ページをOpenAsyncしていきます。記事の本数を数えるのはh1の数をチェックするだけなので、特に複雑なCSSセレクターは必要なし。本来はページングの考慮は必要ですが、一月単位だとページングが出てくるほどの記事量がないので、そこも考慮なしで。</p>
<pre><code class="language-csharp">var yearGrouped = anchors
    .Select(x =&gt;
    {
        var match = Regex.Match(x, @&quot;(\d+)/(\d+)&quot;);
        return new
        {
            Url = x,
            Year = int.Parse(match.Groups[1].Value),
            Month = int.Parse(match.Groups[2].Value)
        };
    })
    .GroupBy(x =&gt; x.Year);

foreach (var year in yearGrouped.OrderBy(x =&gt; x.Key))
{
    var postCount = 0;
    foreach (var month in year)
    {
        var html = await context.OpenAsync(month.Url);
        postCount += html.QuerySelectorAll(&quot;h1&quot;).Count(); // h1 == 記事ヘッダー
    }
    Console.WriteLine($&quot;{year.Key}年記事更新数: {postCount}&quot;);
}
</code></pre>
<p>結果は</p>
<pre><code>2009年記事更新数: 92
2010年記事更新数: 61
2011年記事更新数: 66
2012年記事更新数: 30
2013年記事更新数: 33
2014年記事更新数: 22
2015年記事更新数: 19
2016年記事更新数: 24
2017年記事更新数: 13
2018年記事更新数: 11
2019年記事更新数: 14
2020年記事更新数: 11
2021年記事更新数: 5
</code></pre>
<p>ということで右肩下がりでした、メデタシメデタシ。今年は特に書いてないなあ、せめて2ヶ月に1本は書きたいところ……。</p>
<p>なお、<a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a>
で紹介しているのですが、このサイトは完全に<a href="https://github.com/neuecc/Blog2/tree/master/articles">GitHub上に.mdがフラットに並んで.mdが管理されている</a>ので、こういうの出すなら別にスクレイピングは不要です。</p>
<h2>UserAgentを変更する</h2>
<p>スクレイピングといったらログインしてごにょごにょする。というわけで、そうしたログイン処理をさくっとやってくれるのがAngleSharpの良いところです。ので紹介していきたいのですが、まずはやましいことをするので（？）、UserAgentを偽装しましょう。</p>
<p>AngleSharpが現在何を送っているのかを確認するために、とりあえずダミーのサーバーを立てます。その際には .NET 6 のASP .NET から搭載されたMinimal APIが非常に便利です！そしてそれを<a href="https://www.linqpad.net/">LINQPad</a>で動かすと、テスト用サーバーを立てるのにめっちゃ便利です！やってみましょう。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586706-aa067b51-d8d3-44ac-91b3-552c62e7ce6d.png" alt="image" /></p>
<p>たった三行でサーバーが立ちます。便利。</p>
<pre><code class="language-csharp">await context.OpenAsync(&quot;http://localhost:5000/headers&quot;);
</code></pre>
<p>でアクセスして、 <code>AngleSharp/1.0.0.0</code> で送られていることが確認できました。</p>
<p>なお、LINQPadでASP.NETのライブラリを使うには、Referene ASP.NET Core assembliesのチェックを入れておく必要があります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586956-fddb4821-59a3-4f37-9086-1624d471ed36.png" alt="image" /></p>
<p>他、よく使うNuGetライブラリや名前空間なども設定したうえで、<code>Set as default for new queries</code>しておくと非常に捗ります。</p>
<p>さて、で、このUser-Agentのカスタマイズの方法ですが、AngleSharpはServicesに機能が詰まっているようなDI、というかService Locatorパターンの設計になっているので、ロードされてるServicesを(Watch Windowで)一通り見ます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144601687-3ee78e1d-2f95-404f-b2f9-162deb8eeda0.png" alt="image" /></p>
<p>型に限らず全Serviceを取得するメソッドが用意されていない場合でも、<code>&lt;object&gt;</code>で取ってやると全部出てくるような実装は割と多い（ほんと）ので、とりあえずやってみるのはオススメです。今回も無事それで取れました。</p>
<p>で、型名を眺めてそれっぽそうなのを見ると <code>DefaultHttpRequester</code> というのがかなりそれっぽく、その中身を見るとHeadersという輩がいるので、これを書き換えればいいんじゃないだろうかと当たりがつきます。</p>
<p>ここはやましい気持ちがあるので（？）Chromeに偽装しておきましょう。</p>
<pre><code class="language-csharp">var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;;
</code></pre>
<p>再びOpenAsyncしてLINQPadの表示を見て、変更されてること確認できました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144602382-aba63413-2065-46ed-bd52-f4adf65bd30f.png" alt="image" /></p>
<p>ちなみに、DefaultじゃないHttpRequesterをConfigurationに登録しておく、ということも出来ますが、よほどカスタムでやりたいことがなければ、デフォルトのものをちょっと弄るぐらいの方向性でやっていったほうが楽です。</p>
<h2>FormにSubmitする</h2>
<p>クローラーと言ったらFormにSubmit、つまりログイン！そしてクッキーをいただく！認証！</p>
<p>さて、が、まぁ認証付きの何かを例にするのはアレなので、googleの検索フォームを例にさせていただきたいと思います。先にまずはコード全体像と結果を。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom; // 拡張メソッドとかで有効化されたりするのでusing大事
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies(); // login form的なものの場合これでクッキーを持ち歩く

using var context = BrowsingContext.New(config);

// お行儀悪いので（？）前述のこれやっておく
var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://google.com/&quot;);
var form = doc.Forms[0];
var result = await form.SubmitAsync(new { q = &quot;AngleSharp&quot; }); // name = valueは匿名型が使える

// とりあえず結果を表示しておく
var titles = result.QuerySelectorAll&lt;IHtmlHeadingElement&gt;(&quot;h3&quot;).Select(x =&gt; x.TextContent);
var i = 1;
foreach (var item in titles)
{
    Console.WriteLine($&quot;{i++:00}: {item}&quot;);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/144704506-b0d7038f-ad26-42e4-b8dd-b63b250759c5.png" alt="image" /></p>
<p><code>WithDefaultLoader</code> と、そして認証クッキー持ち歩きのために <code>WithDefaultCookies</code> をコンフィギュレーションに足しておくことが事前準備として必須です。User-Agentの書き換えはご自由に、ただやましいこと、ではなくてUA判定をもとにして処理する、みたいなサイトも少なからずあるので、余計ないこと考えなくて済む対策としてはUAをChromeに偽装しておくのはアリです。</p>
<p>FormへのSubmit自体は3行というか2行です。ページをOpenしてFormに対してSubmitするだけ。超簡単。 <code>.Forms</code> で <code>IHtmlElementForms</code>がすっと取れるので、あとは単純にSubmitするだけです。渡す値は <code>{ name = value }</code>の匿名型で投げ込めばOK。</p>
<p>度々出てくるウォッチウィンドウの宣伝ですが、この何の値を投げればいいのか、を調べるのにHTMLとニラメッコではなく、ウォッチウィンドウで調査していきます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/146650708-d2f1beb1-c21b-4a0a-851b-d0e78628bc00.png" alt="image" /></p>
<p>まず(&quot;input&quot;)を拾うのですが、9個ある。多いね、で、まぁこれはほとんどtype = &quot;hidden&quot;なので無視して良い（AngleSharpがSubmitAsync時にちゃんと自動でつけて送信してくれる）。値を入れる必要があるのはhiddden以外のものなので、それをウォッチで普通にLINQで書けば、3件に絞れました。で、中身見ると必要っぽいのはqだけなので、 new { q = &quot;hogemoge&quot; } を投下、と。</p>
<p>認証が必要なサイトでは、これでBrowingContextに認証クッキーがセットされた状態になるので、以降のこのContextでのOpenや画像、動画リクエストは認証付きになります。</p>
<h2>画像や動画を拾う</h2>
<p>スクレイピングといったら画像集めマンです（？）。AngleSharpでのそうしたリソース取得のやり方には幾つかあるのですが、私が最も良いかな、と思っているのはIDocumentLoader経由でのフェッチです。</p>
<pre><code class="language-csharp">// BrowsingContextから引っ張る。Contextが認証クッキー取得済みなら認証が必要なものもダウンロードできる。
var loader = context.GetService&lt;IDocumentLoader&gt;();

// とりあえず適当にこのブログの画像を引っ張る
var response = await loader.FetchAsync(new DocumentRequest(new Url(&quot;https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png&quot;))).Task;

using var ms = new MemoryStream();
await response.Content.CopyToAsync(ms);

var bytes = ms.ToArray(); // あとは適当にFile.WriteAllBytesでもなんでもどうぞ
</code></pre>
<p>内部用なので少し引数やAPIが冗長なところもありますが、それは後述しますが別になんとでもなるところなので、どちらかというと生のStreamが取れたりといった柔軟性のところがプラスだと思っています。普通にHttpClientで自前で取るのと比べると、認証周りやってくれた状態で始められるのが楽ですね。</p>
<p>並列ダウンロードもいけます、例えば、このブログの全画像を引っ張るコードを、↑に書いた全ページ取得コードを発展させてやってみましょう。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://neue.cc/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

foreach (var arvhives in doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;))
{
    var page = await context.OpenAsync(arvhives.Href);

    // content(ページ本体)下のimgを全部。
    // 今回はページ単位で5並列ダウンロードすることにする(粒度の考え方は色々ある)
    var imgs = page.QuerySelectorAll&lt;IHtmlImageElement&gt;(&quot;#content img&quot;);
    await Parallel.ForEachAsync(imgs, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (img, ct) =&gt;
     {
         var url = new Url(img.Source);
         var response = await loader.FetchAsync(new DocumentRequest(url)).Task;

         // とりあえず雑にFile書き出し。
         Console.WriteLine($&quot;Downloading {url.Path}&quot;);
         using (var fs = new FileStream(@$&quot;C:\temp\neuecc\{url.Path.Replace('/', '_')}&quot;, FileMode.Create))
         {
             await response.Content.CopyToAsync(fs, ct);
         }
     });
}
</code></pre>
<p>.NET 6から <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.parallel.foreachasync">Parallel.ForEachAsync</a> が追加されたので、asyncコードを並列数(MaxDegreeOfParallelism)で制御した並列実行が容易に書けるようになりました。async/await以降、Parallel系の出番は圧倒的に減ったのは確かなのですが、Task.WhenAllだけだと並列に走りすぎてしまって逆に非効率となってしまって、そこを制御するコードを自前で用意する必要が出てきていたりと面倒なものも残っていました。それが、このParallel.ForEachAsyncで解消されたと思います。</p>
<h2>Kurukuru Progress</h2>
<p>数GBの動画をダウンロードする時などは、プログレスがないとちゃんと動いているのか確認できなくて不便です。しかし、ただ単にConsole.WriteLineするだけだとログが凄い勢いで流れていってしまって見辛くて困りものです。そこを解決するC#ライブラリが<a href="https://github.com/mayuki/Kurukuru">Kurukuru</a>で、見ればどんなものかすぐわかるので、まずは実行結果を見てもらいましょう（素の回線だと一瞬でダウンロード終わってしまったので回線の低速シミュレーションしてます）</p>
<p><img src="https://user-images.githubusercontent.com/46207/144711389-7fa99e14-3f77-4fef-a7e7-5d12724aacd1.gif" alt="guruguru" /></p>
<p>一行だけを随時書き換えていってくれるので、見た目も非常に分かりやすくて良い感じです。これはとても良い。Kurukuru、今すぐ使いましょう。ちなみに今回の記事で一番時間がかかったのは、Kurukuruの並列リクエスト対応だったりして（対応していなかったのでコード書いてPR上げて、今日リリースしてもらいましたできたてほやほやコード）。</p>
<p>AngleSharp側のコードですが、この例は<a href="https://file-examples.com/index.php/sample-video-files/sample-mp4-files/">File Examples
</a>のMP4を並列で全部取るというものです。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;
using Kurukuru;
using System.Text;

// Kurukuruを使う上で大事なおまじない
// え、デフォルトのEncodingがUTF8じゃないシェルがあるんです！？←Windows
Console.OutputEncoding = Encoding.UTF8;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://file-examples.com/index.php/sample-video-files/sample-mp4-files/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

// ここから本体
var mp4s = doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;a&quot;).Where(x =&gt; x.Href.EndsWith(&quot;.mp4&quot;));
Console.WriteLine(&quot;Download sample-mp4-files&quot;);
await Parallel.ForEachAsync(mp4s, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (mp4, ct) =&gt;
{
    var bin = await loader.FetchBytesAsync(mp4.Href);
    // あとはFile.WriteAllBytesするとか好きにして
});
</code></pre>
<p>ポイントは <code>var bin = await loader.FetchBytesAsync(mp4.Href);</code> で、これは拡張メソッドです。loaderにProgress付きでbyte[]返すメソッドを生やしたことで、随分シンプルに書けるようになりました。StreamのままFileStreamに書いたほうがメモリ節約的にはいいんですが、中途半端なところでコケたりした場合のケアが面倒くさいので、ガチガチなパフォーマンスが重視される場合ではないならbyte[]のまま受けちゃってもいいでしょう。1つ4GBの動画を5並列なんですが？という場合でも、たかがメモリ20GB程度なので普通にメモリ積んで処理すればいいっしょ。</p>
<p>FetchBytesAsyncの中身は以下のようなコードになります。</p>
<pre><code class="language-csharp">public static class DocumentLoaderExtensions
{
    public static async Task&lt;byte[]&gt; FetchBytesAsync(this IDocumentLoader loader, string address, CancellationToken cancellationToken = default)
    {
        var url = new AngleSharp.Url(address);
        var response = await loader.FetchAsync(new DocumentRequest(url)).Task;
        if (response.StatusCode != System.Net.HttpStatusCode.OK)
        {
            return Array.Empty&lt;byte&gt;(); // return empty instead of throws error(ここをどういう挙動させるかは好みで……。)
        }

        // Content-Lengthが取れない場合は死でいいということにする
        var contentLength = int.Parse(response.Headers[&quot;Content-Length&quot;]);

        using var progress = new ProgressSpinner(url.Path.Split('/').Last(), contentLength);
        try
        {
            return await ReadAllDataAsync(response.Content, contentLength, progress, cancellationToken);
        }
        catch
        {
            progress.Cancel();
            throw;
        }
    }

    static async Task&lt;byte[]&gt; ReadAllDataAsync(Stream stream, int contentLength, IProgress&lt;int&gt; progress, CancellationToken cancellationToken)
    {
        var buffer = new byte[contentLength];
        var readBuffer = buffer.AsMemory();
        var len = 0;
        while ((len = await stream.ReadAsync(readBuffer, cancellationToken)) &gt; 0)
        {
            progress.Report(len);
            readBuffer = readBuffer.Slice(len);
        }
        return buffer;
    }
}

public class ProgressSpinner : IProgress&lt;int&gt;, IDisposable
{
    readonly Spinner spinner;
    readonly string fileName;
    readonly int? totalBytes;
    int received = 0;

    public ProgressSpinner(string fileName, int? totalBytes)
    {
        this.totalBytes = totalBytes;
        this.fileName = fileName;
        this.spinner = new Spinner($&quot;Downloading {fileName}&quot;);
        this.spinner.Start();
    }

    public void Report(int value)
    {
        received += value;
        if (totalBytes != null)
        {
            var percent = (received / (double)totalBytes) * 100;
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)} / {ToHumanReadableBytes(totalBytes.Value)} ( {Math.Floor(percent)}% )&quot;;
        }
        else
        {
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)}&quot;;
        }
    }

    public void Cancel()
    {
        spinner.Fail($&quot;Canceled {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    public void Dispose()
    {
        spinner.Succeed($&quot;Downloaded {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    static string ToHumanReadableBytes(int bytes)
    {
        var b = (double)bytes;
        if (b &lt; 1024) return $&quot;{b:0.00} B&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} KB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} MB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} GB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} TB&quot;;
        b /= 1024;

        return $&quot;{0:0.00} PB&quot;;
    }
}
</code></pre>
<p>KurukuruのSpinnerを内包した <code>IProgress&lt;T&gt;</code> を作ってあげて、その中でよしなにやってあげるということにしました。まぁちょっと長いですが、一回用意すれば後はコピペするだけなので全然いいでしょう。みなさんもこのProgressSpinner、使ってやってください。</p>
<h2>コマンド引数やロギング処理やオプション取得</h2>
<p>クローラーとしてガッツシやりたいなら、モードの切り替えとかロギングとか入れたいです、というか入れます。そこで私が定形として使っているのは<a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a>と<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>。Cysharpの提供です。ワシが作った。それと今回のようなケースだと<a href="https://github.com/Cysharp/Kokuban">Kokuban</a>も便利なので入れます。やはりCysharpの提供です。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;AngleSharp&quot; Version=&quot;1.0.0-alpha-844&quot; /&gt;
    &lt;PackageReference Include=&quot;Kurukuru&quot; Version=&quot;1.4.0&quot; /&gt;
    &lt;PackageReference Include=&quot;ConsoleAppFramework&quot; Version=&quot;3.3.2&quot; /&gt;
    &lt;PackageReference Include=&quot;ZLogger&quot; Version=&quot;1.6.1&quot; /&gt;
    &lt;PackageReference Include=&quot;Kokuban&quot; Version=&quot;0.2.0&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>この場合Program.csは以下のような感じになります。割と短いですよ！</p>
<pre><code class="language-csharp">using ConsoleAppFramework;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Text;
using ZLogger;

Console.OutputEncoding = Encoding.UTF8;

await Host.CreateDefaultBuilder()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.AddZLoggerConsole();
        x.AddZLoggerFile($&quot;logs/{args[0]}-{DateTime.Now.ToString(&quot;yyyMMddHHmmss&quot;)}.log&quot;);
    })
    .ConfigureServices((hostContext, services) =&gt;
    {
        services.Configure&lt;NanikaOptions&gt;(hostContext.Configuration.GetSection(&quot;Nanika&quot;));
    })
    .RunConsoleAppFrameworkAsync(args);

public class NanikaOptions
{
    public string UserId { get; set; } = default!;
    public string Password { get; set; } = default!;
    public string SaveDirectory { get; set; } = default!;
}
</code></pre>
<p>コンソールログだけだとウィンドウ閉じちゃったときにチッとかなったりするので（？）、ファイルログあると安心します。ZLoggerは秘伝のxmlコンフィグなどを用意する必要なく、これだけで有効化されるのが楽でいいところです。それでいてパフォーマンスも抜群に良いので。</p>
<p>ConsoleAppFrameworkはGenericHostと統合されているので、コンフィグの読み込みもOptionsで行います。appsettings.jsonを用意して</p>
<pre><code class="language-json">{
  &quot;Nanika&quot;: {
    &quot;UserId&quot;: &quot;hugahuga&quot;,
    &quot;Password&quot;: &quot;takotako&quot;,
    &quot;SaveDirectory&quot;: &quot;C:\\temp\\dir&quot;,
  }
}
</code></pre>
<p>.csprojのほうに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;None Update=&quot;appsettings.json&quot;&gt;
    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>と書いてあげれば、自動で読み込まれるようになるという仕様です。そして本体のコードは</p>
<pre><code class="language-csharp">public class NanikaDownloader : ConsoleAppBase
{
    readonly ILogger&lt;NanikaDownloader&gt; logger;
    readonly NanikaOptions options;

    // コンストラクタインジェクションでOptionsを受け取る
    public NanikaDownloader(ILogger&lt;NanikaDownloader&gt; logger, IOptions&lt;NanikaOptions&gt; options)
    {
        this.logger = logger;
        this.options = options.Value;
    }

    public async Task DownloadAre()
    {
        // Context.CancellationTokenを渡すのを忘れないように！(Ctrl+Cのキャンセル対応に必須)
        await loader.FecthAsyncBytes(&quot;...&quot;, Context.CancellationToken)
    }

    public async Task DownloadSore(int initialPage)
    {
        // Kokubanを使うとConsoleに出す文字列の色分けが簡単にできる！( `Chalk.Color +` だけで色が付く)
        logger.LogInformation(Chalk.Green + $&quot;Download sore {initialPage} start&quot;);
    }
}
</code></pre>
<p>のように書きます。これの場合は、引数で <code>NanikaDownloader.DownloadAre</code>, <code>NanikaDownloader.DownloadSore -initialPage *</code> の実行切り替えができるようになるわけですね……！</p>
<p>また、文字色が一色だけだとコンソール上のログはかなり見づらいわけですが、Kokubanを使うことで色の出し分けが可能になります。これは、地味にめちゃくちゃ便利なのでおすすめ。別にバッチ系に限らず、コンソールログの色を調整するのってめっちゃ大事だと、最近実感しているところです。</p>
<p>ASP .NET Core(とかMagicOnionとか)で、ZLoggerでエラーを赤くしたい！とか、フレームワークが吐いてくる重要でない情報はグレーにして目立たなくしたい！とかの場合は、ZLoggerのPrefix/SuffixFormatterを使うのをオススメしてます(Kokubanのようにさっくり書けはしないのですが、まぁConfigurationのところで一回やるだけなので)</p>
<pre><code class="language-csharp">logging.AddZLoggerConsole(options =&gt;
{
#if DEBUG
    // \u001b[31m =&gt; Red(ANSI Escape Code)
    // \u001b[0m =&gt; Reset
    // \u001b[38;5;***m =&gt; 256 Colors(08 is Gray)
    options.PrefixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error)
        {
            ZString.Utf8Format(writer, &quot;\u001b[31m[{0}]&quot;, info.LogLevel);
        }
        else
        {
            if (!info.CategoryName.StartsWith(&quot;MyApp&quot;)) // your application namespace.
            {
                ZString.Utf8Format(writer, &quot;\u001b[38;5;08m[{0}]&quot;, info.LogLevel);
            }
            else
            {
                ZString.Utf8Format(writer, &quot;[{0}]&quot;, info.LogLevel);
            }
        }
    };
    options.SuffixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error || !info.CategoryName.StartsWith(&quot;MyApp&quot;))
        {
            ZString.Utf8Format(writer, &quot;\u001b[0m&quot;, &quot;&quot;);
        }
    };
#endif

}, configureEnableAnsiEscapeCode: true); // configureEnableAnsiEscapeCode
</code></pre>
<p>こういうの、地味に開発効率に響くので超大事です。やっていきましょう。</p>
<h2>まとめ</h2>
<p>AngleSharpにかこつけてウォッチウィンドウをとにかく紹介したかったのです！ウォッチウィンドウ最強！値の変化があると赤くなってくれたりするのも便利ですね、使いこなしていきましょう。別にUnityとかでもクソ便利ですからね？</p>
<p>あ、で、AngleSharpはめっちゃいいと思います。他の言語のスクレピングライブラリ(Beautiful Soupとか)と比べても、全然張り合えるんじゃないかな。冒頭に書きましたがE2Eテストへの応用なども考えられるので、使いこなし覚えるのとてもいいんじゃないかと思います。ドキュメントが色々書いてあるようで実は別にほとんど大したこと書いてなくて役に立たないというのは若干問題アリなんですが、まぁ触って覚えるでもなんとかなるので、大丈夫大丈夫。</p>
</div>
<h1><a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a></h1>
<ul class="date"><li>2021-11-21</li></ul>
<div class="entry_body"><p>見た目はほとんど変わっていませんが(とはいえ横幅広くしたので印象は結構変わったかも)、このサイト、フルリニューアルしました。内部構造が。完全に。別物に。元々はWordPressだったのですが、今回から自作の静的サイトジェネレーターでhtmlを生成し、GitHub Pagesでホストするようにしました。元になるソース(<code>.md</code>)もGitHub上に置き、GitHub ActionsでビルドしてGitHub Pagesでホスティングされるという、完全GitHub完結ソリューション。また、記事を書くエディタも<a href="https://docs.github.com/ja/codespaces/the-githubdev-web-based-editor">GitHub web-based editor</a>(リポジトリのトップで<code>.</code>を打つと、VS Codeそのものが起動するやつ)を利用することで、非常に快適で、というかMarkdownエディタとしては最高品質のものが乗っかっていて、たかがブログ書くにしては面倒くさいPush/Pullもなくダイレクトコミットで反映出来てしまうというのがとても良い体験になっています。</p>
<ul>
<li><a href="https://github.com/neuecc/Blog2/">neuecc/Blog2</a></li>
</ul>
<p><code>.</code>でエディタを起動して、<a href="https://github.com/neuecc/Blog2/tree/master/articles">articles</a>配下に<code>YYYY-MM-DD.md</code>ファイルを新規作成。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737666-ec09db39-d517-4fb9-aa9f-b61bfb2cbfe7.png" alt="image" /></p>
<p>完全にVS Codeそのものでデスクトップアプリのものと全く区別が付かないレベルで、これを超える品質のエディタを普通のサイトに乗せることは不可能でしょう。当然もちろん画像のプレビューもできますし、なんだったら拡張すら入る。</p>
<p>GitHub管理だと画像置き場（アップロード）が面倒くさい問題があるのですが、これはIssueを画像アップローダーとして使うことで回避しています。Issueの入力フォームは、画像をCtrl+Vでそのままアップロードが可能です。そして嬉しいことに、マークダウンに変換してくれているのでコピペするだけでOK。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736683-d2b2acac-8523-4f54-a325-c1dbb12aa959.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/142736700-18928390-e53b-4014-a931-9cd974afcf56.png" alt="image" /></p>
<p>上がった先の<code>user-images.githubusercontent</code>は別にIssueそのものと紐付いているわけではないので、 アップローダ用に使ったIssueはSubmitすることなくポイ、です。そうしてどこにも紐付いていない<code>user-images.githubusercontent</code>ですが、別にだからといって削除されることもなく永続的に上がり続けているので、遠慮なく使わせてもらうことにします。まぁちゃんとGitHub上に上げてるコンテンツ用に使っているので、許されるでしょう、きっと。多分。</p>
<p>そうして出来上がった記事は、そのままエディタ上のgit UIからコミットすると、自身が作業している領域は直接サーバー上のmaster(main)なので、プッシュ不要で反映されます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png" alt="image" /></p>
<p>こうなると、もうWordPressで投稿をポスト、するのと変わらないわけです。ブログ記事程度でcloneしてpullしてstagingしてpushしてというのは地味に重たいので、このぐらい身軽で行きたいですね。（実際、投稿後に編集ラッシュとかよくあるので、ちょっと手数が増えるだけで猛烈に嫌気がさす）</p>
<p>ジェネレートは<a href="https://github.com/neuecc/Blog2/blob/master/.github/workflows/build.yml">workflows/buildy.yml</a>で、このリポジトリ内に配置されてるC#プロジェクトを直接ビルド/実行することで生成処理をしています。<code>dotnet run</code>便利。</p>
<pre><code class="language-yaml">build-blog:
runs-on: ubuntu-latest
steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.x
    - run: dotnet run --project ./src/Blog2/Blog2.csproj -c Release -- ./articles ./publish
    - uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./publish
        keep_files: true
</code></pre>
<p>生成されたファイルは<a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a>を使って<code>gh-pages</code>ブランチと同期します。その際、デフォルトでは既に上がってるファイルを全削除してしまうので、今回はstyleやassetを、同期とは別に置いてあるので削除されると困るので、<code>keep_files: true</code>も指定しています。そうすると記事の削除がしづらくなるんですが、記事の削除はしない or どうしても削除しなかったら二重に(articlesとgh-pages)削除すればいいだけ、という運用で回避。</p>
<p>と、いうわけでシステム的には満足です。</p>
<p>C#でも<a href="https://www.statiq.dev/">Statiq</a>などといった静的サイトジェネレーターは存在するのですが、あえて自作した理由は、サイトのシステムをそっくり移行するという都合上、URLを前のものと完璧に合わせたかったというのがあります。<a href="https://github.com/neuecc/Blog2/tree/gh-pages">生成結果のファイル一覧</a>が若干変というかクドいというか、といったところがあるのですが、これは前のWordPressでやっていたルーティングをそのまんま再現するためということで。WordPressからのエクスポートも、DB直接見てC#でそのままテーブルダンプから作ったので、まぁ別に大したコードが必要なわけでもないので一気に作っちゃえという気になったというのもあります。</p>
<p>外部ライブラリとしてはMarkdownのHTML化に<a href="https://github.com/xoofx/markdig">Markdig</a>を採用しました。色々高機能ではあるのですが、今回は <code>Markdown.ToHtml(input)</code> しか使っていませんけれど、感触的にはとても良かったです。</p>
<p>シンタックスハイライトには<a href="https://prismjs.com/">Prism.js</a>を用いました。Markdigの出力する```csharpの変換を、特に何も意識せずとも対象にしてくれるのが良かったですね。プラグインはautoloaderとnormalize-whitespaceを合わせて投下しています。</p>
<pre><code class="language-html">&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js&quot;&quot;&gt;&lt;/script&gt;
</code></pre>
<h2>まとめ</h2>
<p>最近ブログ投稿がだいぶ減ってしまっていたのですが、システムも一新したことでやる気が出てきたのでいいことです。まぁ見た目は本当にあんま全然変わってないんですが……！</p>
<p>なお、反映に必要な所要時間は30秒弱。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737556-eac40d7a-46c8-4534-96de-38895104d4cb.png" alt="image" /></p>
<p>遅いっちゃあ遅いですが、許容できるといえば許容できますね。サイトジェネレートプログラムの実行時間自体は1秒以下で、別に全然時間かかってないんで、CIセットアップとか、それ以外の時間が何かとかかっちゃってます。GitHub Actionsの仕組み的にしょうがないといえばしょうがないんですが、もう少しなんとかなってほしいかなあ。あとGitHub Pages自体が反映が若干遅い。遅い上に進捗が分からないのが地味にストレスフル。とはいえとはいえ、良いんじゃあないでしょうか。良さの殆どはGitHub web-based editorから来てますね、これは本当に革命的に良い。というわけで、このweb-based editorを活かすシステムを作っていくという手段と目的を逆転させた思考が最終的に実際良いんじゃないかと思ってます！</p>
</div>
<h1><a href="https://neue.cc/2021/08/23_602.html">C#でgoogle/zx風にシェルスクリプトを書く</a></h1>
<ul class="date"><li>2021-08-23</li></ul>
<div class="entry_body"><p>あまりシェルスクリプトを書かない私なのですが（小物でもなんでも書き捨てC#で書くスタイル）、CI だの .NET Core だのなんなので、全く書かないというわけにもいかない昨今です。まぁしかしcmdは嫌だし今更(？)PowerShellもなぁという感じもあり、bashねぇ、とかブツブツ言いながらしょっぱいスクリプトを書く羽目になるわけです。</p>
<p>そこに颯爽と現れたのが <a href="https://github.com/google/zx">google/zx</a>。素敵そうだなーと思いつつJavaScriptを日常的に書くわけでもないのでスルーしてたのですが、こないだも<a href="https://scrapbox.io/lacolaco-engineering/%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E8%A4%87%E9%9B%91%E3%81%AA%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92JavaScript%E3%81%A7%E6%9B%B8%E3%81%8F">ちょっと複雑なシェルスクリプトをJavaScriptで書く</a>で紹介されていて、なるほど色物じゃなくて便利なのか、そうだよね便利だよね！と思い、私は日常的にC#を書くので、C#だったら便利だな、同じ感じで書けるなら、と、思い至ったのでした。</p>
<p>というかまぁzx見て思ったのが、これぐらいの内部DSL、C#でもいけるよ、ということであり……。そして以下のようなものが誕生しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/130373766-0f16e9ad-57ba-446b-81ee-c255c7149035.png" alt="image" /></p>
<p>もともと<a href="http://neue.cc/2020/01/30_590.html">ProcessX - C#でProcessを C# 8.0非同期ストリームで簡単に扱うライブラリ</a>というものを公開していたので、更にそれをDSL風味に、zxっぽくシンタックスを弄りました。C# 5.0 async/awaitの拡張性、C# 6.0 using static、C# 6.0 String Interpolation、そしてC# 9.0のTop level statementsと、C#も内部DSLを容易にする構文がどんどん足されています。現在previewのC# 10.0でも、Improvement Interpolated Stringsとして、InterpolatedStringHandlerによって$&quot;&quot;の生成時の挙動そのものを生で弄ることが可能になり、よりますます表現のハックが可能になり、色々と期待が持てます。</p>
<p>さて、で、これが使いやすいかというと、見た通りで、使いやすい、です……！stringをawaitしていることに一瞬違和感はめちゃくちゃあるでしょうが、DSLだと思って慣れれば全然自然です（そうか？）。なんか言われてもgoogle/zxなもんです、で逃げれば説得力マシマシになった（そうか？）のが最高ですね。cmd/PowerShell/bashに対する利点は、google/zxの利点と同じように</p>
<ul>
<li>型が効いてる(C#なので)</li>
<li>async/awaitが便利(C#なので)</li>
<li>フォーマッタもある(C#なので)</li>
<li>エディタ支援が最高(C#なので)</li>
</ul>
<p>ということで、ぜひぜひお試しください。</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">https://github.com/Cysharp/ProcessX</a></li>
<li>PM&gt; Install-Package ProcessX</li>
</ul>
<h2>csx vs new csproj vs ConsoleAppFramework</h2>
<p>C#には.csxという失われしC#スクリプティングな構文が用意されていて、まさに1ファイルでC#の実行が完結するのでこうしたシェルスクリプト風味に最適、と思いきや、実行もエディッティング環境も貧弱で、まさに失われしテクノロジーになっているので、見なかったことにしておきましょう。実際、より良いC#スクリプティング的なシンプルC#の提案が <a href="https://github.com/dotnet/designs/pull/213">Add Simple C# Programs</a> として出ています(つまりcsxは完全に産廃、NO FUTURE……)。提案(<a href="https://github.com/dotnet/designs/blob/a27fd42a68370f315bc2293dc748145f4075697f/proposed/simple-csharp-programs.md">proposed/simple-csharp-pgorams.md</a>)読むと面白いですが、ちょっと少し時間かかりそうですね。</p>
<p>というわけで、csprojとProgram.csの2ファイル構成が良いんじゃないかと思います。ちょっと冗長ではあるけれど、しょーがないね。実行に関しては dotnet run でビルドと実行がその場でできるので、ビルドなしの直接スクリプト実行みたいな雰囲気にはできます。これは普通に便利で、CIとかでもgit pullしている状態のリポジトリ内のスクリプトに対して一行でdotnet run書くだけで動かせるので、非常に良い。こうした .NET Core以降のシンプルになったcsprojとdotnetコマンドの充実から、csxの価値がどんどん消えていったんですねえ。</p>
<p>さて、実際のプロジェクトなどでは、そもそもシェルスクリプト（に限らずバッチなんかも）は一つどころか大量にあったりすることもあるでしょう。そこでCysharpの提供している<a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a>を使うと、クラスを定義するだけで簡単に実行対象を増やしていけるので、大量のスクリプトの管理を1csprojでまかなうことが可能になります。実行は dotnet run -- foo/bar のようにすればいいだけです。非常におすすめ。シェルスクリプト的なものは、ConsoleAppFramework + ProcessX/zx で書いて回るのは、悪くない選択になると思います。</p>
</div>
<h1><a href="https://neue.cc/2021/07/02_601.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2021-07-02</li></ul>
<div class="entry_body"><p>11回目。一年ごとに再審査があって7月に一斉更新されるシステムになっていて、今年も継続しました。</p>
<p><a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C#</a>はprotobuf-netを抜いて、 .NET で最もGitHubのスター数の多いバイナリシリアライザになりそうな感じです（今はまだちょっと負けてるので、勢い的に8月か9月ぐらいには）。まぁ、たった3000ちょいがMost StarsというC#の狭さみたいなところがなきにしもあらずではありますが(JavaScriptだと桁が違うからなあ）、.NET の存在感というのは決して劣ってはいないと思います。</p>
<p>MessagePack for C#は<a href="https://github.com/neuecc/MessagePack-CSharp/pull/1272">v3を計画</a>しています。パフォーマンスの大幅な向上（特にUnityで！）や、より良い使い勝手、ゼロアロケーションを超えたゼロコピー、SourceGenerator対応によるAOT対応の強化などなどを、破壊的変更も含めた上で考えてます。改めて、 .NET 6時代の最高のシリアライザを目指しています。</p>
<p><a href="https://github.com/Cysharp">GitHub/Cysharp</a>で公開しているものも、新規には <a href="https://github.com/Cysharp/MessagePipe">MessagePipe</a>は結構良いと思いますし、引き続き <a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/UniTask">UniTask</a>は開発進めています。</p>
<p>つまり全体的にとてもC#に貢献している。なるほどえらい。そりゃ更新も当然ですね（</p>
<p>今年は会社として、今ひとつ大きなプロダクトを仕込んでいる最中でして、それで大きなインパクトを Unity と .NET 、双方で引き起こせるはず、です……！乞うご期待。</p>
<p>というわけかで引き続きC#の最前線で戦っていきますので、今年もよろしくおねがいします。</p>
</div>
<h1><a href="https://neue.cc/2021/05/08_600.html">2021年のC# Roslyn Analyzerの開発手法、或いはUnityでの利用法</a></h1>
<ul class="date"><li>2021-05-08</li></ul>
<div class="entry_body"><p>C#のAnalyzer、.NET 5時代の現在では標準でも幾つか入ってきたり、<a href="https://github.com/dotnet/roslyn-analyzers">dotnet/roslyn-analyzers</a>として準標準なものも整備されてきたり（非同期関連だと他に<a href="https://github.com/microsoft/vs-threading/blob/main/doc/analyzers/index.md">microsoft/vs-threading</a>のAnalyzerも便利)、<a href="https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html">Unity 2020.2からはUnityもAnalyzer対応したり</a>、MicrosoftもUnity向けの<a href="https://github.com/microsoft/Microsoft.Unity.Analyzers">microsoft/Microsoft.Unity.Analyzers</a>という便利Analyzerが登場してきたりと、特に意識せずとも自然に使い始めている感じになってきました。</p>
<p>Analyzerって何？というと、まぁlintです。lintなのですが、Roslyn(C#で書かれたC# Compiler)から抽象構文木を取り出せるので、それによってユーザーが自由にルールを作って、警告にしたりエラーにしたりできる、というのがミソです。更に高度な機能として、CodeFix(コードを任意に修正)もついているのですが、それはそれとして。</p>
<p>このサイトでも幾つか書いてきましたが、初出の2014年-2015年辺りに固まってますね。もう6年前！</p>
<ul>
<li><a href="http://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a></li>
<li><a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a></li>
<li><a href="http://neue.cc/2015/05/11_512.html">UniRxでの空呼び出し検出、或いはRoslynによるCode Aware Libraries時代の到来について</a></li>
<li><a href="http://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a></li>
</ul>
<p>実用的という点では、<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>に同梱しているMessagePackAnalyzerは今も現役でしっかり便利に使える代物になっています。</p>
<p>と、いうわけで使う分にはいい感じになってきた、のですが、作る側はそうでもありません。初出の2015年辺りからテンプレートは変わってなくて、NuGetからすんなり入れれる時代になっても、VSIXがついてくるようなヘヴィなテンプレート。このクロスプラットフォームの時代に.NET Frameworkべったり、Visual Studioベッタリって……。Analyzerと似たようなシステムを使うSource Generator(<a href="http://neue.cc/2020/12/15_597.html">UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips
</a>)は、まぁまぁ今風のそこそこ作りやすい環境になってきたのに、Analyzerは取り残されている雰囲気があります。</p>
<p>AnalyzerはCodeFixまで作ると非常に面倒なのですが、Analyzer単体でも非常に有益なんですよね。そしてプロジェクト固有の柔軟なエラー処理というのは、あって然りであり、もっとカジュアルに作れるべきなのです。が、もはや私でも腰が重くなってしまうぐらいに、2021年に作りたくないVisual Studio 2019のAnalyzerテンプレート……。</p>
<p>どうしたものかなー、と思っていたのですが、非常に良い記事を見つけました、2つ！</p>
<ul>
<li><a href="https://qiita.com/ryuix/items/36dabbf3c7e4e395e49e">SourceGeneratorのデバッグ</a></li>
<li><a href="https://zenn.dev/naminodarie/articles/32973a36fcbe99">【C#】アナライザー・ソースジェネレーター開発のポイント</a></li>
</ul>
<p>前者の記事ではVS2019 16.10 preview2で ソースジェネレーターのデバッガーサポートが追加された、 <code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code> とすればいい。という話。なるほどめっちゃ便利そう、でもソースジェネレーターばっか便利になってくのはいいんですがAnalyzer置いてきぼりですかぁ？と思ったんですが、 <code>IsRoslynComponent</code> だし、なんか挙動的にも別にAnalyzerで動いても良さそうな雰囲気を醸し出してる。と、いうわけで試してみたら無事動いた！最高！VS2019 16.10はまだpreviewですが(現時点では16.9が安定版の最新)、これはもうこれだけでpreview入れる価値ありますよ（あと少し待てば普通に正式版になると思うので待っても別にいいですが）</p>
<p>後者の記事は .NET 5 時代のすっきりしたAnalyzerのcsprojの書き方を解説されています。つまり、この2つを合体させればシンプルにAnalyzerを開発できますね……？</p>
<p>というわけでやっていきましょう。中身は本当に上記2つの記事そのものなので、そちらのほうも参照してください。</p>
<h2>SuperSimpleAnalyzerをシンプル構成で作る</h2>
<p>まずは Visual Studio 2019 16.10 をインストールします。16.10はついこないだ正式版になったばかりなので、バージョンを確認して16.10未満の場合はアップデートしておきましょう。</p>
<p>Analyzerはnetstarndard2.0、Analyzerを参照するテスト用のConsoleAppプロジェクトをnet5.0で作成します。最終的には以下のようなソリューション構造にします。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117477060-7c494b00-af98-11eb-8b45-b52734713821.png" alt="image" /></p>
<p>さて、ではSuperSimpleAnalyzerのほうのcsprojをコピペ的に以下のものにしましょう。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;library&lt;/OutputType&gt;
        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
        &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
        &lt;TargetsForTfmSpecificContentInPackage&gt;$(TargetsForTfmSpecificContentInPackage);PackBuildOutputs&lt;/TargetsForTfmSpecificContentInPackage&gt;
        &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
        &lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;
        &lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
        &lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.2&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; /&gt;
    &lt;/ItemGroup&gt;

    &lt;Target Name=&quot;PackBuildOutputs&quot; DependsOnTargets=&quot;SatelliteDllsProjectOutputGroup;DebugSymbolsProjectOutputGroup&quot;&gt;
        &lt;ItemGroup&gt;
            &lt;TfmSpecificPackageFile Include=&quot;$(TargetDir)\*.dll&quot; PackagePath=&quot;analyzers\dotnet\cs&quot; /&gt;
            &lt;TfmSpecificPackageFile Include=&quot;@(SatelliteDllsProjectOutputGroupOutput-&gt;'%(FinalOutputPath)')&quot; PackagePath=&quot;analyzers\dotnet\cs\%(SatelliteDllsProjectOutputGroupOutput.Culture)\&quot; /&gt;
        &lt;/ItemGroup&gt;
    &lt;/Target&gt;
&lt;/Project&gt;
</code></pre>
<p>基本的に<a href="https://zenn.dev/naminodarie/articles/32973a36fcbe99">【C#】アナライザー・ソースジェネレーター開発のポイント</a>から丸コピペさせてもらっちゃっているので、それぞれの詳しい説明は参照先記事に譲ります……！幾つか重要な点を出すと、<code>Microsoft.CodeAnalysis.CSharp</code>のバージョンは新しすぎると詰みます。現在の最新は3.9.0ですが、3.9.0だと、今の正式版VS2019(16.9)だと動かない(動かなかったです、私の環境では、どうなんですかね？)ので、ちょっと古めの3.8.0にしておきます。</p>
<p>もう一つは、件の <code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code> の追加です。</p>
<p>では、次にConsoleApp.csprojのほうに行きましょう。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;ProjectReference Include=&quot;..\AnalyzerDemo\SuperSimpleAnalyzer.csproj&quot;&gt;
            &lt;ReferenceOutputAssembly&gt;false&lt;/ReferenceOutputAssembly&gt;
            &lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
        &lt;/ProjectReference&gt;
    &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>こちらは別に特段変わったことなく、Analyzerのcsprojを参照するだけです。その際に <code>&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;</code>を欠かさずに。</p>
<p>では再び SuperSimpleAnalyzer に戻って、プロパティ→デバッグから、「起動」をRoslyn Componentに変更すると以下のような形にできます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478072-ab13f100-af99-11eb-9904-f7fae1b899a7.png" alt="image" /></p>
<p>（この時、Target Projectが真っ白で何も選択できなかったら、ConsoleAppのほうでAnalyzer参照をしてるか確認の後、とりあえずVisual Studioを再起動しましょう）</p>
<p>これで、SuperSimpleAnalyzerをF5するとAnalyzerがConsoleAppで動いてる状態でデバッガがアタッチされます！</p>
<p>のですが、最後にじゃあそのAnalyzerの実体をコピペできるように置いておきます。</p>
<pre><code class="language-csharp">#pragma warning disable RS2008

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Linq;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class SuperSimpleAnalyzer : DiagnosticAnalyzer
{
    // どうせローカライズなんてしないのでString直書きしてやりましょう
    private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(
        id: &quot;SuperSimpleAnalyzer&quot;,
        title: &quot;SuperSimpleAnalyzer&quot;,
        messageFormat: &quot;MyMessageFormat&quot;,
        category: &quot;Naming&quot;,
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: &quot;Nanika suru.&quot;);

    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }
    
    public override void Initialize(AnalysisContext context)
    {
        // お約束。
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // 解析起動させたい部分を選ぶ。あとRegisterなんとかかんとかの種類は他にもいっぱいある。
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
    }

    private static void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        // ここを適当に書き換える（これはサンプル通りの全部Lowerじゃないクラス名があった場合に警告を出す）
        var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

        if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
        {
            // Diagnosticを作ってReportDiagnosticに詰める。
            var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
</code></pre>
<p>Resourcesとか別に使う必要ないと思うので、ハイパーベタ書きの.csファイル一個に収めてあります。これでF5をすると……</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478737-7d7b7780-af9a-11eb-95cd-f1d970d2c22d.png" alt="image" /></p>
<p>もちろんConsoleAppのほうでは、実際に動いて警告出している様が確認できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478595-558c1400-af9a-11eb-9516-47295823423c.png" alt="image" /></p>
<p>昔のVSIXの時は、別のVisual Studioを起動させていたりしたので重たくて面倒くさかったのですが、今回の IsRoslynComponent では、普通のデバッグの感覚で実行できるので、めちゃくちゃ楽です。最高に書きやすい、これが2021年……！</p>
<h2>ユニットテストもする</h2>
<p>ユニットテストのいいところは、テストをデバッグ実行すればコードの中身をダイレクトにステップ実行できるところにもあります。ある程度、上のように実コードでデバッグ実行して雰囲気を作れた後は、ユニットテスト上で再現コードを作っていくと、より捗るでしょう。</p>
<p>基本的にはxUnitのテンプレートでプロジェクトを作って、 <code>Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit</code> を参照に追加するだけ。ではあるのですが、net5でシンプルに作ったら連なってる依存関係のせいなのか .NET Frameworkのものの参照が入って警告されたりで鬱陶しいことになったので、とりあえず以下のが警告の出ないパターン（？）で作ったものになります。netcoreapp3.1で。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
        &lt;IsPackable&gt;false&lt;/IsPackable&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.2&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; /&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;3.8.0&quot; /&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit&quot; Version=&quot;1.1.0&quot; /&gt;

        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;16.9.4&quot; /&gt;
        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.1&quot; /&gt;
        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.3&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>このプロジェクトに作ったAnalyzerの参照を足して、以下のようなテストコードを書きます。</p>
<pre><code class="language-csharp">        [Fact]
        public async Task SimpleTest2()
        {
            var testCode = @&quot;
class Program
{
    static void Main()
    {
    }
}&quot;;

            await Microsoft.CodeAnalysis.CSharp.Testing.XUnit.AnalyzerVerifier&lt;SuperSimpleAnalyzer&gt;
                .VerifyAnalyzerAsync(testCode, new DiagnosticResult(&quot;SuperSimpleAnalyzer&quot;, DiagnosticSeverity.Warning).WithSpan(0, 0, 0, 0));
        }
</code></pre>
<p>やることはVerifyAnalyzerAsyncに、それによって発生するエラー部分をDianogsticResultで指定する、という感じです。</p>
<p>シンプルなケースはそれでいいのですが、テストコードにNuGetで外部ライブラリ参照があったり、プロジェクト参照があったりすると、これだけだとテストできません。そこで、そうしたケースが必要な場合は CSharpAnalyzerTest に追加の参照関係を指定してあげる必要があります( XUnit.AnalyzerVerifier は CSharpAnalyzerTest をxUnitのシンプルなケースに特化してラップしただけのものです）。</p>
<p>例えば<a href="https://github.com/Cysharp/MessagePipe/">MessagePipe</a>では以下のようなユーティリティを用意してテストしました。</p>
<pre><code class="language-csharp">static async Task VerifyAsync(string testCode, int startLine, int startColumn, int endLine, int endColumn)
{

    await new CSharpAnalyzerTest&lt;MessagePipeAnalyzer, XUnitVerifier&gt;
    {
        ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity(&quot;MessagePipe&quot;, &quot;1.4.0&quot;))),
        ExpectedDiagnostics = { new DiagnosticResult(&quot;MPA001&quot;, DiagnosticSeverity.Error).WithSpan(startLine, startColumn, endLine, endColumn) },
        TestCode = testCode
    }.RunAsync();
}

static async Task VerifyNoErrorAsync(string testCode)
{

    await new CSharpAnalyzerTest&lt;MessagePipeAnalyzer, XUnitVerifier&gt;
    {
        ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity(&quot;MessagePipe&quot;, &quot;1.4.0&quot;))),
        ExpectedDiagnostics = { },
        TestCode = testCode
    }.RunAsync();
}
</code></pre>
<p>これで</p>
<pre><code class="language-csharp">        [Fact]
        public async Task SimpleTest()
        {
            var testCode = @&quot;using MessagePipe;

class C
{
    public void M(ISubscriber&lt;int&gt; subscriber)
    {
        subscriber.Subscribe(x =&gt; { });
    }
}&quot;;

            await VerifyAsync(testCode, 7, 9, 7, 39);
        }

        [Fact]
        public async Task NoErrorReport()
        {
            var testCode = @&quot;using MessagePipe;

class C
{
    public void M(ISubscriber&lt;int&gt; subscriber)
    {
        var d = subscriber.Subscribe(x =&gt; { });
    }
}&quot;;

            await VerifyNoErrorAsync(testCode);
        }
</code></pre>
<p>のようにテストが書けました。</p>
<h2>まとめ</h2>
<p>というわけでAnalyzer書いていきましょう。今現在は結局Visual Studioだけかよ！みたいな気もしなくもないですが、そのうちVS CodeとかRiderでも出来るようになるんじゃないでしょうか、どうだろうね、そのへんはわかりません。</p>
<p>ところでUnity 2020.2からAnalyzerが使えると言いましたが、そのサポート状況はなんだかヘンテコで、ぶっちゃけあんま使えないんじゃ疑惑があります。特に問題は、Unity Editor側では有効になっているけどIDE側で有効にならない場合が割とあります。これはUnityの生成したcsprojに、カスタムで追加したAnalyzerの参照が適切に入ってなかったりするせいなのですが、それだと使いづらいですよね、というかAnalyzerってコード書いてる最中にリアルタイムに警告あるのがイケてるポイントなので。</p>
<p>そこでCysharpで<a href="https://github.com/Cysharp/CsprojModifier">CsprojModifier</a>というUnity用の拡張をオープンソースで公開しました。ついさっき。6時間ぐらい前に。</p>
<p><img src="https://github.com/Cysharp/CsprojModifier/raw/master/docs/images/Screen-01.png" alt="" /></p>
<p>これがあるとUnityでも正しくAnalyzerの参照の入ったcsprojを使える他に、例えば<a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">BannedApiAnalyzers</a>という、任意のクラスやメソッド、プロパティの呼び出しを禁止するという、かなり使えるAnalyzerがあるんですが（例えばUnityだとGameObject.Find絶対禁止マンとかが作れます）、これはどのメソッドの呼び出しを禁止するかをBannedSymbols.txtというファイルに書く必要があり、Unityのcsproj生成まんまだとこのBannedSymbols.txtへの参照が作れないんですね。で、CsprojModifierなら、参照を入れたcsprojが作れるので、問題なくUnityでBannedApiAnalyzersが使えるようになるというわけです。</p>
<p>というわけで改めて、Analyzer、書いていきましょう……！</p>
<p>実際こないだリリースした<a href="https://github.com/Cysharp/MessagePipe/">MessagePipe</a>用に、Subscribe放置を絶対に許さない（エラー化する）Analyzerを公開しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png" alt="" /></p>
<p>こういうの、必要だし、そしてちゃんと導入するととても強力なんですよね。せっかくのC#の強力な機能なので、やっていきましょう。</p>
</div>
<h1><a href="https://neue.cc/2021/02/26_599.html">C#のasync/await再考, タイムアウト処理のベストプラクティス, UniTask v2.2.0</a></h1>
<ul class="date"><li>2021-02-26</li></ul>
<div class="entry_body"><p>お題を3つ並べましたが、記事は逆順で書いていきます！というわけで、<a href="https://github.com/Cysharp/UniTask">UniTask v2.2.0</a>を出しました。改めてUniTask v2とは<a href="https://tech.cygames.co.jp/archives/3417/">Unityのためのゼロアロケーションasync/awaitと非同期LINQ</a>を実現するライブラリで、とv2リリース時の解説記事を貼っつけましたが、ちょいちょい細かい改善を続けてまして、今回v2.2.0になります。</p>
<h2>PlayerLoopへのループ挿入のカスタマイズ対応</h2>
<p>現状のUnityはPlayerLoop上で動いていて、<a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">Unity 2020.1のリストをここに置いておきました</a>が、デフォルトでは120個ぐらいのループがエンジンから駆動されています。Updateループだけでも<code>ScriptRunBehaviourUpdate</code>, <code>ScriptRunDelayedDynamicFrameRate</code>, <code>ScriptRunDelayedTasks</code>, <code>DirectorUpdate</code>と色々あります。UniTaskも基本的にはPlayerLoop上で動かしているのですが、自由に任意の実行箇所を選べるように、28個のループを挿入しています。これにより <code>UniTask.Yield(PlayerLoopTiming.PreLateUpdate)</code> などといったような指定を可能にしているわけですが、28個ってちょっと多いんじゃないか？という。デフォで120個あるうちのプラス28個、多いっちゃあ多いけど、ループの中身も空っぽに近いし、空UpdateのMonoBehaviourを10000個並べるみたいなのとは比較にならないほど小さい話だから許容範囲内ぢゃん、と思ってはいるんですが、例えばAndroidでDeep Profilingなんかすると、ちょとプロファイラのデータに出てきちゃったりなんかは指摘されたことがあります（Deep Profilingの影響があるので、実際のビルドではそうでもないんですが）。</p>
<p>何れにせよ、99.99%はUpdateしか使わねえよ、みたいなのはあると思います。というわけで、UniTaskのPlayerLoopの挿入量を任意に調整できるようにしました。</p>
<pre><code class="language-csharp">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
public static void InitUniTaskLoop()
{
    var loop = PlayerLoop.GetCurrentPlayerLoop();
    PlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum);
}
</code></pre>
<p>これで、<code>Update | FixedUpdate | LastPostLateUpdate</code> の3つしか挿入されなくなります。<code>InjectPlayerLoopTimings</code>は任意のLoopTimingの選択、例えば <code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code> のような指定と、3つのプリセット、 <code>All</code>(デフォルトです), <code>Standard</code>(Lastを抜いたもの、挿入量が半分になる(ただし一番最後のLastPostLateUpdateは挿入する))、<code>Minimum</code>(Update, FixedUpate, LastPostLateUpdate)が選べます。正直なところ9割の人はMinimumで十分だと思ってますが、まぁ状況に応じて任意に足したり引いたりしてもらえればいいんじゃないかと。</p>
<p>ところで、そうすると、挿入していないループタイミングを指定するとどうなるんですか？というと、実行時例外です。えー、それじゃー困るよーと思うので、そこで使えるのが<a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>というやつで、(<a href="https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html">Unity 2020.2からAnalyzerが何のハックもなくそのまま使えるようになった</a>のでAnalyzerは普通に使えますよ！)、例えばInjectPlayerLoopTimings.Minimum用に、このBannedApiAnalyzersの設定、BannedSymbols.txtを書くとこうなります。</p>
<pre><code class="language-txt">F:Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn't injected this PlayerLoop in this project.d
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastTimeUpdate; Isn't injected this PlayerLoop in this project.
</code></pre>
<p>こうすると、例えば PlayerLoopTiming.LastUpdate をコード上に書くと RS0030 のWarningとなります。WarningじゃなくてErrorでいいので、そこはUnityのドキュメントの通りにwarn-&gt;errorに設定を入れてやれば、以下の画像のようになります。</p>
<img src="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png" width=600 />
<p>このぐらい出来ていれば、十分でしょう。ところでBannedApiAnalyzersはめっちゃ使えるやつなので、これの対応以外にも普通に入れておくと捗ります。どうしてもこのメソッドはプロジェクトでは使用禁止！といったようなものはあると思います、それを規約じゃなくてコンパイルエラー（警告）に変換できるわけです。例えばGameObject.Find(&quot;name&quot;) 絶対殺すマンとかがさくっと設定できるわけです。</p>
<p>（と思ったのですが、現状のUnity 2020.2のAnalyzer標準対応はかなりヘッポコのようで、そのままだとBannedApiAnalyzersはうまく使えなさそうです(BannedSymbols.txtの適用ができないとか、その他色々。csproj生成をフックして差し込むことはできるので、それによって差し込んでIDE側で利用する、ぐらいが妥協点になりそう)</p>
<h2>タイムアウト処理について</h2>
<p>タイムアウトはキャンセルのバリエーションと見なせます。つまり、CancellationTokenを渡すところに、時限発火のCancellationTokenを渡せばいいのです。そうすれば、タイムアウトの時間が来るとキャンセルが発動する。それがタイムアウト処理です。UniTaskでは <code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code> というのがあるので、それを使います。</p>
<pre><code class="language-csharp">var cts = new CancellationTokenSource();
cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.

try
{
    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(cts.Token);
}
catch (OperationCanceledException ex)
{
    if (ex.CancellationToken == cts.Token) // Tokenの比較をすることで厳密に発火元を調べることができますが、この場合100%タイムアウトなので比較しなくてもそれはそれでいい
    {
        UnityEngine.Debug.Log(&quot;Timeout&quot;);
    }
}
</code></pre>
<blockquote>
<p>CancellationTokenSource は.NET標準のクラスであり、CancelAfterというメソッドが標準にありますが、これは（例によって）使わないでください。標準で備え付けられているものは当然のようにスレッドタイマーを用いますが、これはUnityにおいては不都合な場合が多いでしょう。CancelAfterSlimはUniTaskが用意している拡張メソッドで、PlayerLoopベースでタイマー処理を行います。パフォーマンス上でも軽量です。</p>
</blockquote>
<p>タイムアウトによるキャンセル処理と、別のキャンセル処理を組み合わせたい場合も少なくないでしょう。その場合は <code>CancellationTokenSource.CreateLinkedTokenSource</code> を使ってCancellationTokenを合成します。</p>
<pre><code class="language-csharp">var cancelToken = new CancellationTokenSource();
cancelButton.onClick.AddListener(()=&gt;
{
    cancelToken.Cancel(); // cancel from button click.
});

var timeoutToken = new CancellationTokenSource();
timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.

try
{
    // combine token
    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);

    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(linkedTokenSource.Token);
}
catch (OperationCanceledException ex)
{
    if (timeoutToken.IsCancellationRequested)
    {
        UnityEngine.Debug.Log(&quot;Timeout.&quot;);
    }
    else if (cancelToken.IsCancellationRequested)
    {
        UnityEngine.Debug.Log(&quot;Cancel clicked.&quot;);
    }
}
</code></pre>
<p>これによってキャンセルボタンのクリックによるキャンセル発火と、タイムアウトによるキャンセル発火を合成することが出来ました。</p>
<h2>TimeoutController</h2>
<p>ここまでが王道パターンのキャンセル処理だったのですが、今回UniTask v2.2.0では新しくTimeoutControllerというクラスを追加しました。これはタイムアウトが発火しない場合はアロケーションがなく再利用可能なCancellationTokenSourceです。タイムアウトは例外的状況なはずなので、これによってほとんどの状況で、タイムアウト処理のためのアロケーションをゼロにすることができます。</p>
<pre><code class="language-csharp">TimeoutController timeoutController = new TimeoutController(); // setup to field for reuse.

async UniTask FooAsync()
{
    try
    {
        // you can pass timeoutController.Timeout(TimeSpan) to cancellationToken.
        await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest()
            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));
        timeoutController.Reset(); // call Reset(Stop timeout timer and ready for reuse) when succeed.
    }
    catch (OperationCanceledException ex)
    {
        if (timeoutController.IsTimeout())
        {
            UnityEngine.Debug.Log(&quot;timeout&quot;);
        }
    }
}
</code></pre>
<p>再利用（と、内部のタイマーの停止）のために、awaitが正常終了したらResetを手動で呼んでください、という一点だけ気をつけてください。</p>
<p>CreateLinkedTokenSource的な使い方をする場合は、コンストラクタの引数に別のCancellationTokenを渡せます。これによってTimeout(TimeSpan)で得られるCancellationTokenがリンクされたものとなります。</p>
<pre><code class="language-csharp">TimeoutController timeoutController;
CancellationTokenSource clickCancelSource;

void Start()
{
    this.clickCancelSource = new CancellationTokenSource();
    this.timeoutController = new TimeoutController(clickCancelSource);
}
</code></pre>
<p>ところでここで告知が幾つか有りまして、まず、UniTaskには標準で <code>.Timeout</code>, <code>.TimeoutWithoutException</code> というメソッドが生えているのですが、これらは可能であれば使わないでください。というのも、 <code>.Timeout</code>は外部からタイムアウト処理を行うもので、その場合に動いているタスク本体を停止することができないのです。タイムアウトが発火してもTask自体は動いていて、やってることは結果を無視するということです（世の中、AbortできないAPIも少なくなくて、そういうもののキャンセル処理ってこういうことなので、別にこれ自体は悪いわけではない）。かたやCancellationTokenをメソッドに渡す場合は、内部からのタイムアウト処理となるので、その場合TaskがAbort可能なものであれば、正しく処理がAbortされます。まとめると、CancellationTokenを渡すことができないメソッドに対して外付けでタイムアウト処理を行いたいときだけ、<code>.Timeout</code>を使いましょう、ということになります。正直名前ももう少し、あんま使わないで感を醸し出す名前に変更したいぐらいなのですが、まぁとりあえずは、ということで……。</p>
<p>もう一つ、UniTaskには <code>AsyncOperation.WithCancellation</code> とは別に <code>UniTask.WithCancellation</code> というメソッドが生えていたのですが、<code>UniTask.WithCancellation</code>のほうの名前を<code>AttachExternalCancellation</code>に変更しました。これもTimeoutの話と同じで、 <code>AsyncOperation.WithCancellation</code> が内部からのキャンセル処理で、 <code>UniTask.WithCancellation</code> は外部からのキャンセル処理となっていて、挙動は似ていても内部動作が全く違うからです。内部キャンセルのほうが望ましいんですが、コードを見ただけだと内部キャンセルなのか外部キャンセルなのか分からないのは非常に良くない。つーかマズい。ダメ。ので変えました。名前的にも、使いたくない雰囲気を漂わせてる名前であるとおり、あんま使わないでねという意図が込められています。</p>
<p>最後に微妙に細かいところなのですが、<code>AsyncOperation.WithCancellation</code>の挙動を<code>.ToUniTask(cancellationToken)</code>のただのショートカットにしました。Timeout処理で使うのに微妙に都合が悪かったからです。挙動はあんま変わらないんですが、細かく厳密なことを言うと少し違うんですが、まぁ、そういうことということで。</p>
<p>この手の初期のデザインミスの修正は、あんま破壊的変更祭り死ね、とはならない程度に、ちょいちょいやらなきゃなあとは思ってるので、すみませんが宜しくおねがいします。</p>
<h2>async/awaitは何故無限に分からないのか</h2>
<p>async/await自体は非同期処理を容易にするための仕組みであり、雰囲気としては誰でも同期処理と同じように書けることをゴールにしています。そして、実際のところそれは、達成できてます。同期と同じことしかしなければ。asyncと宣言してawaitと書けば、同期処理と同じです。それは全く嘘偽りなく正しい。別にラムダ式も出てこないし特殊なコールバックも実行順序もない。ちゃんとループも書けるしtry-catchもできる。そういうように作られてる。</p>
<p>じゃあなぜ難しいのかというと、同期処理よりも出来ることが増えているからです。</p>
<ul>
<li>直列にすべきか並行にすべきか</li>
<li>キャンセルにどう対応すべきか</li>
<li>伝搬の終点をどう扱うべきか</li>
<li>Task(UniTask)が伝搬するのをよしとすべきか</li>
<li>投げっぱなし処理にすべきか</li>
</ul>
<p>で、これらってそもそも同期処理だと出来ないことなんですよね、キャンセルって同期だと原則できないわけで。だからキャンセルなんて考えず黙ってawait、以上。とすればいいのです。別に並行(WhenAll)なんてしなくても直列で回してもいいのです、だって同期だったら黙って直列でやってた話じゃないですか。以上。</p>
<p>が、まぁ人間出来るとなると欲が出るし、そもそも実際そういうわけにはいかないので、同期処理と比べて、よりベターな処理にするために、考えることが増える。やるべきことが増える。そこが難しさのポイントです。でも出来ることが多いってのは良いアプリケーション作りのためには悪いことではない。ブロッキング処理がなくなればUIの体験は非常に良くなるし、並行処理で高速に読み込まれれば嬉しいし、きちんとキャンセル処理されたほうがいいに決まってる。だから、非同期は重要なのです。</p>
<p>というわけで、とりあえず一個一個考えていきましょうか。</p>
<h2>直列にすべきか並行にすべきか</h2>
<p>これ、JavaScriptの記事とかで、 Promise.all 使わないのは素人、バーカバーカ。みたいな記事がめちゃくちゃ良くありますが、んなこたーなくて使うかどうかはものによる。もちろん簡単に並行に束ねられるのは素晴らしいことなので、それはいいです。大いにやるべきだ。じゃあ直列処理は間違ってるかというと、別に間違っちゃあいないし、そうすべき局面だってそれなりにある。あと、allを使う必要があるからasync/awaitよりPromiseだ、みたいなのは意味不明なので無視していい。そもそも、そういう人たちってロクにコード書いたことないからなのか、thenとallぐらいしか用例を知らない説すらある。awaitはただのthenの糖衣構文「ではない」し、thenだけだと無理があるみたいなパターンもいっぱいあります。例えば非同期のミドルウェアパターンを<a href="http://neue.cc/2020/08/20_594.html">async decoratorパターンによるUnityWebRequestの拡張とUniTaskによる応用的設計例</a>で紹介しましたが、これなんかはasync/awaitだからこそ成立させられる、そして非常に強力な用例です。</p>
<p>と、脱線しましたが、とはいえこうした並行処理を簡単に書けるようになったのがasync/await（つまりはPromise/Future/Task/UniTask）のいいところです。同期処理の場合では書けないのは勿論、コールバックベースでも難しくて無理がある、のでやらないものだったのが、async/awaitの登場によって頻繁に出てくるパターン、そして誰でも比較的安全に処理できるパターンとなりました。ちなみにこれ、Promiseだけでも誰でも使えるパターンとはなり得なくて、async/awaitがあるからこそ、Promiseのコード上での出現頻度が上がり、それによって適用可能になるシチュエーションが増えるという側面があると思っています。</p>
<h2>Task(UniTask)が伝搬するのをよしとすべきか</h2>
<p>前の話から続けると、asyncのための型(Promise/Task/UniTask)が頻出するのは、いいことだと思ってます。そのお陰で、効果的に適用できるシチュエーションが増えるんですから。とはいえ面倒くせーしグチャグチャするし嫌だ、という気持ちは大いにわかる。はい。</p>
<p>と、ここで最新型のasync/await実装であるSwift 6から幾つか例を見てみましょう。日本語でわかりやすくまとまってる <a href="https://zenn.dev/koher/articles/swift6-concurrency">Swift 6で来たる並行処理の大型アップデート近況</a> と <a href="https://speakerdeck.com/koher/await">先取り！ Swift 6 の async/await</a> から引かせてもらいますが、まずメソッドの宣言。</p>
<pre><code class="language-csharp">func download(from url: URL) async -&gt; Data
</code></pre>
<p>Dataが戻り値なわけですが UniTask[Data] みたいになっていない、Promiseが出てこないやったー、かというと、別にそんなこたぁないかなあ、と思います。Swiftの場合、asyncで宣言したメソッドにはawaitが必須であり、awaitを使うにはasyncである必要がある、と、伝搬していっているわけなので、 <code>async -&gt; Data</code> の一塊で見れば、制約や機能は UniTask[Data] のようなものと大きな違いはありません（型として明示されない分だけ、より強い制約がかかってるのですが、そのへんは後述）。</p>
<p>そういうわけでasyncが伝搬している（悪いような言い方をすればコードを汚染している）わけですが、それに関してはどうでしょう。Swiftがいい対称性を持っているのは<a href="https://qiita.com/koher/items/e4c1d88981291c35d571">Swiftの検査例外</a>と似たような雰囲気で捉えられるところで、エラーの発生しうるメソッド(throws)の呼び出しにはawaitのようにtryが必要で、tryにはthrowかcatchが必要、と。</p>
<p>なので、最下層でエラーなしメソッドからエラーありメソッドに変えたら、呼び出し側はどんどんさかのぼってエラー処理を書く必要がある。別にこれはGoも一緒ですよね、戻り値が(value)から(value, error)に変わり、対応していく必要がある。そういう対応が面倒くさいので、そうしたエラーに関しては検査しない勢もいる（C#や非検査例外のJavaなんかはそうですよね、どちらかというとむしろそのほうが多数派）わけで、良し悪し、とは言いませんが、現代的にエラー処理を強制的に伝搬させることは絶対に忌避するもの、というほどの価値観ではなくなってるのではないかと思います。</p>
<p>で、async/awaitの話しに戻りますが、非同期もまた同様に最下層で同期から非同期に処理を変更したら伝搬していく。で、エラー処理をやったほうがいいのと同じように、同期から非同期へと性質が異なるものになったので、そしてそのことが型で明示されるのは当然いいことなので、伝搬していくのは当たり前じゃないですか？性質が変化したことを型(UniTask)なり宣言(async)なりで示し、上層側に性質が変化したことにより増えた出来ることの選択(並行処理/キャンセル/etc...)を与える。悪いことじゃないので受け入れるべきだし、async汚染とか言って喜んでるのはやめるべきですね。</p>
<p>全部非同期というか、そういうことを全く意識させないような言語としてデザインする、というアイディアも当然あって、Goは実際それに近くて、しかも圧倒的に少数派で独特なデザインなのに大成功を収めているのが凄い。まぁじゃあそれが理想的で全ての言語がそうなっていくべきかというとそうではないとは思います（例えばキャンセルやタイムアウト処理などは結局意識させなきゃいけないので、Contextを伝搬させる必要があるため、完全に透過的にできているかというとそうではない。また全体のシンプル化の結果WaitGroupのような他ではあまり出てこないプリミティブな処理や、Channelが頻出する、もちろんそれはトレードオフなのでデザインとしてナシではないですが）。みんな違ってみんないい、とは思いませんが、目の前のプロダクトのために現在の現実の時間で何を選ぶべきか、という話ですね。</p>
<p>伝搬はしょーがないとしても、書き味を良くするやり方はありますよね。Swiftの場合は、非同期で宣言している関数に同期関数を突っ込める。雑多なところでいうと、Task.FromResult()書いて回らなくていい、的な良さがありますね。ただまあ呼び出し側のawait, asyncの伝搬のほうが面倒くさ度というか、書くことはずっと多いので、あったほうがいいけど、なくても許容できるぐらいの感じかしら。</p>
<p>それと async -&gt; Data には UniTask[Data] のようなTask型が出てこない。これも一々ジェネリクスで書くの面倒くさいので、asyncって言ってるんだからイチイチ、そっちの型でまで書きたくない、と。めっちゃいいですね。はい、いいです。また、文法とタイトにくっついてるのでUniTaskのawait二度漬け禁止とか、フィールドには持たないで欲しいなぁみたいなのが文法レベルで制限かけられる。これもいいところです。</p>
<p>じゃあそれと比べたC#の良いところというか現状こうなってるという点では、asyncで宣言した戻り値の型によって実行する非同期ランタイム(AsyncMethodBuilder)が切り替えられます。asyncで宣言したメソッドを非同期ステートマシンに変換するのはコンパイラの仕事ですが、そのステートマシンの各ポイントでどう処理するかの実行機は型に紐付いています。Taskで宣言しているメソッドはTaskの非同期ランタイム、ValueTaskで宣言してるメソッドはValueTaskの非同期ランタイム、そしてUniTaskで宣言してるメソッドはUniTaskの非同期ランタイムで動きます。UniTaskがやっているように、この非同期ランタイムはユーザーがC#で実装できます。</p>
<p>世の中の99%は別に既定の非同期ランタイムで不自由しない、と思いきや、そうではなくて、完全にデフォルトの実装を無視して100%実行環境(Unity)に特化して最適化することの効果、意味みたいなことを実証したのがUniTaskで、ちゃんと成功しています。非同期実行ランタイムを切り替えられる言語は他にもありますが(Rustもそうですね)、C#のそれは私が自分で書いてそこそこうまく普及させたというのもありますが、現状よくできた仕組みになっているんじゃないかとは思います。</p>
<h2>伝搬の終点</h2>
<p>asyncは伝搬していきますが、一番根っこで何か処理しなきゃいけないのはC#もそうですし、別にSwiftも同様です。Swift 6の仕様を見る限り@asyncHandlerでマークされたメソッドは伝搬を打ち切った根っこのメソッドになるようですが、つまりようするにこれってC#でいうところの <code>async void</code> です。</p>
<p>伝搬をどういう風に打ち切ればいいのかというのは、実際初心者殺しなところがありますが、フレームワークがasync/await前提で作られている場合は意識させないことが可能です。例えばMVCウェブフレームワークのControllerで言ったら</p>
<pre><code class="language-csharp">public class FooController : Controller
{
    // Foo/Helloでアクセスできる
    public async Task Hello()
    {
        // Usercode...
    }
}
</code></pre>
<p>というようにすると、ユーザーのコード記述のエントリポイントは async Task Hello であり、非同期伝搬の最上位の処理(async void)はMVCフレームワークの中で隠蔽されています。</p>
<p>コンソールアプリケーションのMainもそうです</p>
<pre><code class="language-csharp">static async Task Main()
{
    // Usercode...
}
</code></pre>
<p>最上位がMainなので、伝搬の終点なんて考えなくていい。</p>
<p>じゃあUnityは、とかWinFormsやWPFは？というと、async/awaitなんて存在しない時代からのフレームワークであり、別にそれを前提としていないので、最上位を自分で作る必要があります。これが悩ましさを増させてしまうんですね。まぁ大抵はユーザーの入力が起点なので、Buttonのイベントハンドラーに対して UniTaskVoid(async void) を突っ込む、みたいな運用になってきますが……。あとはStartCoroutineと同じような雰囲気で、MonoBehaviourのどこかでFireAndForgetですね。何れにせよ、自分で最上位となるポイントを判断しなきゃいけないというのが、ひと手間感じるところで、難しいと言われてもしょうがない話です。async voidは使うんじゃねえ（正しくはある）、みたいな話もあるから余計分からなくなるという。使っても良いんですよ、最上位では……。</p>
<p>UniTaskの場合はUniTaskVoidという存在がまた面倒くささを増量しているのですが、上の方でC#は戻り値の型で非同期ランタイムを切り替えられると書きましたが、つまりvoidに対するC#既定のランタイムがあり、voidで宣言する以上、それは変えられないのです。そのためasync UniTaskVoid と書かせるのですが、voidは特殊な存在でありUniTaskVoidは普通の戻り値の型なので、C#コンパイラの都合上、最上位として使うためにはなんらかのハンドリング(空の警告を抑制するためだけの.Forget()呼び出し)が強いられるという……。</p>
<p>C# 10.0 だから C# 11.0 だかに向けての提案に<a href="https://github.com/dotnet/csharplang/blob/master/proposals/async-method-builders.md">AsyncMethodBuilder override</a>という仕様があって、メソッド単位で非同期ランタイムを選択できるようになる、可能性があります。そうしたら</p>
<pre><code class="language-csharp">[AsyncMethodBuilderOverride(typeof(UniTaskVoidMethodBuilder))]
async void FooAsync() { }
</code></pre>
<p>みたいに書けるようになるかもしれません。うーん、でも別にこれ全然書き味悪いですねぇ。</p>
<pre><code class="language-csharp">[UniTaskVoid]
async void FooAsync() { }
</code></pre>
<p>ぐらいまで縮められるようになって欲しい、まぁまだProposalなので今後に期待、あとどっか適当なタイミングで提案しておこう（そもそも C# で現実的に稼働してる 非同期ランタイム を実装してるのはMicrosoftのTask/ValueTask実装者(Stephen Toub)と私ぐらいしかいないのだ）</p>
<h2>キャンセルにどう対応すべきか</h2>
<p>C#において、asyncメソッドは引数の最後にCancellationTokenを受け入れるべきだというふんわりした規約があります。これが、ダセーしウゼーし面倒くせーと大不評で。なるほどね、そうだね！私もそう思う！</p>
<p>なんでこうなってるかというと、asyncに使うTask型って別にasyncで宣言したメソッドからしか作れないわけじゃなくて、手動で作れるんですよね。new Taskみたいな。Task.FromResultみたいな。それどころか別にawaitできる型もGetAwaiterという決め打ちな名前のメソッドを後付けで（拡張メソッドで）実装すればawaitできるようになりますからね。ゆるふわー。</p>
<p>それはそれで非常に拡張性があって、そもそもasync/awaitに全然対応していないもの(Unity)に対してもユーザー側(UniTask)が対応させることが出来たりして、とても良かったのです、が、awaitする型全体を通してコンパイラがChildTask的な、便利Contextを裏側で自動で伝搬してあげるみたいな仕組みを作りづらいわけです。</p>
<p>Swiftの場合は言語とタイトにくっついたasyncが用意されているので、<code>let handle = Task.runDetached { await ...}  handle.cancel()</code> みたいに書ける、つまりObservableをSubscribeしたのをDisposeすればCancelでこれがUniRxで良かったのにUniTaskは面倒くせえなおい、みたいなことが出来てハッピーっぽそうです。独立したCancellationTokenを持っているのは、それはそれで柔軟な取り回しができて悪くない場合もあるんですが、まぁ99.99%の状況で上位から伝搬するCancellationTokenだけで済むのは間違いないでしょう。</p>
<p>ともあれ現状のC#的にはどうにもなんないししょーがないかなぁ、と思ってます。（GoだってContext手動で取り回すわけだし、ね）。はい。実際にはExecutionContextというスロットをawaitの伝搬で共有していて、SynchronizationContext.Currentはそれ経由で格納されてるので、そこにCancellationToken.Currentみたいなものを仕込むこと自体はランタイム的には出来るんですけどね。でも、ExecutionContextのスロットを使うというオーバーヘッドも避けれるなら避けたほうがいいというのもあります（などもあって、Taskで自動的に行われているExecutionContextの伝搬をUniTaskでは切っています）。</p>
<p>一応、文化として「引数の最後にCancellationTokenを受け入れる」というルールが普及していること自体は良かったと思います。JavaScriptだとAbortControllerがCancellationTokenのような機能を果たしますが、これを使っていくのが一般的という雰囲気でもないので、キャンセルに対する統一的なやり方が作れてない感じがあるので。</p>
<h2>CPU資源の有効活用とスケジューラー</h2>
<p>まず、非同期とCPU使って並列処理だー、みたいなのは被るけど被らないんですね。そして、CPUをぶん回さない非同期に価値はないかというと、んなわきゃぁないんですね。まずI/Oの非同期について考えるのが大事で、JavaScriptがシングルスレッドだから全然使えないかと言ったらんなわきゃあねえだろ、であり(Node.jsで見事実証されてます)、Redisがアーキテクチャとしてシングルスレッドを選択しても価値ある性能を出せることを証明してます。</p>
<p>その上で使える資源は色々使えたほうがいいよーということであり、C#のasync/awaitの場合はTaskが、というかawaitからawaitの間が実行単位になってきます。Unityの場合はawaitの最中にゲームエンジン(C++)に処理を渡して、エンジンが処理結果をメインスレッドに戻してきたのをC#がawaitで受け取る流れになってます。エンジン側に処理をぶん投げまくってC#側のメインスレッドを空けるのが現状のUnityにおける非同期というかasync/awaitというわけですね（この辺はJavaScriptに非常に似ています）。</p>
<p>.NET の場合はasyncメソッドは最終的にどこかの非同期I/Oに叩き込まれて、awaitで戻ってくるときにスレッドプールを使います。async/awaitが言語に実装されて以降、C#はスレッドプールをめちゃくちゃ使うようになりました、というかawaitするとスレッドプールに行くので、本質的にもはやプログラムは全てスレッドプール上で動いているといっても過言ではない。のです。全てがGoルーチンみたいな世界観と同じです（言い過ぎ）。というわけで、スレッドプールのスケジューラーへの改善の投資は続いて、もちろんワークスティーリングもしますし、ただのスレッドのプール、ではない賢い動作をする、.NETの非同期処理の心臓部となっています。</p>
<p>.NET 6ではこのスレッドプールはPure C#実装になります。というのもC#が動くランタイムも複数あって（.NET Coreであったりmonoであったり）、それぞれが個別のネイティブ実装だと、一つのランタイムがアルゴリズム改善しても、他のランタイムに反映されなくなってしまうなどなど。.NET Core以降、C#上で低レベルなコードが書けるようになったこととランタイムの実行速度の改善が続いていることもあり、.NET 6においてはネイティブ実装→Pure C#実装への切り替えはパフォーマンス的な向上にも繋がったそうです。</p>
<h2>まとめ</h2>
<p>C#のasync/awaitが登場したのは2012年、preview辺りの頃から考えるともう10年前！実用言語での大規模投入は間違いなく初めてで、最初の実装(C# 5.0)が現在から見て良かったかというと、まずかった部分も少なからずあります。しかしまぁ、6.0, 7.0, 8.0と改良を進めて来た現在のC#のasync/awaitは別に他と比べて劣っているとは思えません。8.0 のasync streamsやAsync LINQは<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md">Swiftのasync seqeunceのproposal(つまりまだ先)</a>みたいなところもありますし。</p>
<p>Unity上でUniTaskみたいな独自非同期ランタイムを作るのも、別にC#で無理してやってるというわけでもなく、自分の中では自然なことです。現実にモバイルゲームを開発していこうというところで、まず動かせない要素を決める、つまりUnityというのは不動な要素。そしてそこに乗ってるC#も外れない言語。その中で、現在可能な技術(C# 8.0)の範囲で、最高の結果を引き出すための手法を選んで、手を動かす。</p>
<p>こないだ私の会社で出してるOSSの紹介をしたのですが、非現実的な理想ではなくて、今表現できる最高のものを生み出していく。というのをモットーにしてます。エンジニアなら評論家にならず手を動かして結果で示せ、ということですね。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/abifk9UuCO8pDc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/a-quick-tour-of-the-cysharp-oss" title="A quick tour of the Cysharp OSS" target="_blank">A quick tour of the Cysharp OSS</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>というわけでまぁUniTask v2.2.0もいい感じになっていると思うので、ぜひぜひ使っていただければです！</p>
</div>
<h1><a href="https://neue.cc/2020/12/30_598.html">2020年を振り返る</a></h1>
<ul class="date"><li>2020-12-30</li></ul>
<div class="entry_body"><p>今年は前半が絶好調で、<a href="http://neue.cc/2020/01/09_588.html">ConsoleAppFramework</a>、<a href="http://neue.cc/2020/01/30_590.html">ProcessX</a>、<a href="https://tech.cygames.co.jp/archives/3383/">ZString</a>、<a href="https://tech.cygames.co.jp/archives/3401/">ZLogger</a>、そして<a href="https://tech.cygames.co.jp/archives/3417/">UniTask v2</a>と、凄い勢いでプログラミング的なクリエイティビティを発揮できていました。なので今年トータルとしてみれば良かったと言えます。</p>
<p>が、後半が絶不調で無。とにかく無。なんでこんな無になったのか分からないほどに無。コロナか、コロナが悪いんか。それも実際あるんですが、いや、というかそれが全てかなー。リモートワーク向いてないんすよー、みたいな。リモート前半で魂の貯金を使い切った。無が加速してからヤバいと思って自主リモート返納（自分だけオフィスワーク）に戻したんですが、それでもなんか違うんですよねえ。まぁ、言い訳なんですけどね！新環境に適応できない旧世代民には死あるのみ、って感じなので、来年は脳みそ入れ替えてやってきたいと思います。</p>
<p>この12月は、書く予定だったアドベントカレンダーも書けずにフィニッシュと最悪な感じですからねえ、終わりが全くしまらなかった結果、今年の印象としてはあんま良くない。でも客観的に一年通しで見たら、中々の成果を上げたとは言えます。</p>
<p>OSSがかなり出揃ったことで、<a href="https://cysharp.co.jp/">Cysharp</a>という会社の輪郭をはっきりさせられた年になりました。対外的には何やってる会社か分からない、まぁ実際そこは今もよくわからないと思うんですが、それでもC#の最先端を突っ走っている会社だというイメージは確固たるものになったのではないでしょうか。去年ではまだまだ足りてないと考えていたのですが、今年追加したOSS群によって、一つポジションを引き上げられたと思っています。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>もv4になって .NET 5/Pure C# gRPC 対応を果たしましたし、今年は実際に採用しているアプリケーションがリリースされていったことで、よりCysharpの目指しているヴィジョンの現実感が出てきました。来年はそのヴィジョンをより鮮明にしていくことと、もうプラスαに仕込んでいるものがあるので、その辺の露出がうまくできるといいかなーと思ってます。</p>
<p>私個人の能力の成長という点でも、UniTask v2を始めとしてパワーある実装をやりきったことと、そこから深く学んだこともいっぱいあるので、まだまだ行けるぞという感じです。ちゃんとね、毎年成長してますよ。はい。人間、停滞＝衰退ですから。</p>
<p>私は出したもののウケ度に割と拘るところがあるんですが、これは自分の感覚と市場の感覚が乖離していないかを測っているという面もあります。今日が誕生日でもうN回この振り返りも書いてるわけですが、そろそろ油断すると感性が腐る頃合いなんですよね。なんかピンとのズレたことを言い始めてしまうという。端的に言えばそれが老害というわけなんですが、自分も油断するとなりかねない。という危機感がそぞろ出てくるような頃合いでして。しかもね、そういうのは自覚がないわけですよ、本人は自覚がない！本人はイケてると思っているのが余計辛い！自覚がないからこそ老害なのだ。みたいなところがある。</p>
<p>と、いうわけで、客観的な指標が必要で、とりあえず今年はOKじゃないですかね。はい。</p>
<h2>その他文化</h2>
<p>今年のGame of the Yearは<a href="https://bethesda.net/ja/game/doom">DOOM Eternal</a>ですよね……！震えるほど面白いゲームって本当に数年単位で久々で、腐った感性を復活させてくれた神の救いですよ。というわけでマストバイ。（しかし超期待したDLCは微妙だった……）</p>
<p>今年のベストアルバムは中村佳穂のAINOUです。<a href="https://mikiki.tokyo.jp/articles/-/19940">中村佳穂『AINOU』はなぜ2018年を代表する名盤なのか?</a>とかって記事出てるように全然今年のアルバムじゃないんですが、聴いたのは今年だからshoganai。名盤。</p>
<p>読み物としては、ちょくちょく<a href="https://www.shibatashoten.co.jp/magazine.php?cid=3">月刊専門料理</a>を買ってて、これが面白いんですよね。料理とエンジニアリングは共通するものがあると<a href="https://www.oreilly.co.jp/books/9784873117874/">Cooking for Geeks</a>をはじめとしてよく言われるやつですが、それプラス経営的な話とかも中々身に沁みるものがあって良いわけです。あと、料理業界はまだまだ多分アナログなんですよね、だから紙の雑誌にも相応の密度がある。その点エンジニアの場合はウェブ媒体のほうが紙より良い状態なので、雑誌が面白くないんですよね（Web+DBとかもはやつまらんでしょ）。良くも悪くもですが、まぁもう進んでしまった業界は紙の媒体が面白くなることはないのでしょう。</p>
<h2>来年</h2>
<p>アドベントカレンダーネタは書いてないしGitHub Issuesもかなり手を付けてないのが残っちゃったしで、あんまりスッキリして来年を迎えられないんですが……！そのへんはなるはやですっきりさせたいとして、今年はCysharpの仕込みフェーズがとてもうまくいった。実際うまくいった。そして仕込みフェーズは終了。つまり来年はどーんといきましょう。というわけで、ぜひぜひ大躍進にご期待くださいな。</p>
</div>
<h1><a href="https://neue.cc/2020/12/15_597.html">UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips</a></h1>
<ul class="date"><li>2020-12-15</li></ul>
<div class="entry_body"><p>ValueObjectは好きですか？私は大嫌いです。いじょ。</p>
<p>ざっくり言えばプリミティブ型に専用の型を付ける教義です。例えばUserIdをintとして扱っているとTeamIdと取り違えるかもしれないし、Hpに突っ込んでしまうかもしれない。StrengthとIntelligenceとAgilityとSpeedは別物なのだから全部intじゃなくて区別して欲しい、そうじゃないと間違った演算しちゃうぞ、と。まぁそういう自体を避けるために、それぞれラップした個別型を作るのです。int strengthじゃなくてStrength strengthだぞ、と。</p>
<p>これは一見正しく実際正しいのですが、問題もあります。一つに面倒くさい。ラップしたctorを作るのだけでも定形でウザ、と思いますが、更に等値とか実装するのは面倒くさい。また、そのままだと計算できなくなるので、算術演算のために生の値を<code>.Value</code>で取り出す、が頻出すると安全度も下がるし見た目もめっちゃ汚くなる、当然ながらものすごく書きづらい。そしてシリアライゼーションの問題。Serialize(userId)としたときに「{ &quot;Value&quot; = 100 }」なんて形にシリアライズされたら最低で、全く許容できない。また、データベースで扱うときにもORMはそのままだとプリミティブしか扱えないので、マッピングできなくて不便なことになります。</p>
<p>といった問題があるため、基本的には大嫌いなのでそういうのやらない、プリミティブで何が悪いんだボケ。ぐらいの勢いでした。実際、社内でそうしたい、という話があった場合にはトップダウン権限で却下してたぐらいです（横暴！）。のですが、上記の問題が解決するのならば、全然許せます。むしろ良い。むしろすべき。かもしれません。</p>
<p>そこで C# 9.0 から新搭載されたSourceGeneratorの出番です。SourceGeneratorを活用したUnitGeneratorというライブラリを新しく作りました。今回はその内容の解説と、SourceGeneratorを実装する上でのTipsを紹介します。また、この記事は <a href="https://qiita.com/advent-calendar/2020/csharplang2">C# その2 Advent Calendar 2020</a> 15日用です。19日にも<a href="https://qiita.com/advent-calendar/2020/csharplang">C# Advent Calendar 2020</a>でSourceGeneratorネタを書く予定なので、まずはPart 1ということで合わせてお楽しみください。</p>
<p>ちなみにC# Advent Calendar 2020の初日の記事 <a href="https://qiita.com/RyotaMurohoshi/items/83775cf4ed1ce4f6378d">C# 9.0で加わったC# Source Generatorと、それで作ったValueObjectGeneratorの紹介</a> と内容的には非常に似通ってるんですが、そこはshoganai。また<a href="https://qiita.com/pierusan2010/items/d66b835240af30955da6">C#9.0 SourceGeneratorでReadonly構造体を生成するGeneratorを作ってみました。</a>とも被ってますね、しょーがしょーがない。</p>
<h2>SourceGeneratorの特性</h2>
<p>GitHubとNuGetに<code>UnitGenerator</code>として公開しました（この記事でも後で触れますが、ReadMe末尾にはUnityでの使い方も載せてあります）。</p>
<ul>
<li><a href="https://github.com/Cysharp/UnitGenerator">Cysharp/UnitGenerator</a></li>
</ul>
<p>使い方は、<code>public readonly partial struct</code>に対して、<code>[UnitOf(typeof(T))]</code>を書くだけです。</p>
<pre><code class="language-csharp">using UnitGenerator;

[UnitOf(typeof(int))]
public readonly partial struct UserId { }
</code></pre>
<p>これを書くと、SourceGeneratorが裏側で以下のpartial classをコンパイル時（ビルド前）に生成します。</p>
<pre><code class="language-csharp">[System.ComponentModel.TypeConverter(typeof(UserIdTypeConverter))]
public readonly partial struct UserId : IEquatable&lt;UserId&gt; 
{
    readonly int value;
    
    public UserId(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(UserId value) =&gt; value.value;
    public static explicit operator UserId(int value) =&gt; new UserId(value);
    public bool Equals(UserId other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;UserId(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in UserId x, in UserId y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in UserId x, in UserId y) =&gt; !x.value.Equals(y.value);

    private class UserIdTypeConverter : System.ComponentModel.TypeConverter
    {
        // snip...
    }
}
</code></pre>
<p>SourceGeneratorのいいところは、生成コードがC#コンパイラのメモリ内で完結していることです。つまり、ファイルが出てきません。ファイルが出てこないのは非常にいいことで、自動生成ファイルが減った時の管理をしなくてすみます。ディレクトリごと毎回Cleanするのもイマイチですし、かといって古いファイルが残り続けるのはマズいので、そこの管理をどうするか問題は毎度面倒くさいことです。</p>
<p>欠点はメモリ内で完結していることです。ソースが見えないとデバッガビリティも下がりますし、コンパイルしないと追加されたコードが使えないというのもコード書いてる最中の手触り的に面倒。というのが一般的な話なのですが、そこを言語組み込みの機能として用意したことでカバーしているのがSourceGeneratorの良いところです。まず、デバッガビリティに関してはIDE(Visual Studioなど)でコードジャンプできるようになっているし、デバッガのステップ実行もフルサポート。また、IDEのインクリメンタルコンパイルとフルに連動しているため、属性を書いた瞬間から、裏ではそこの部分だけコンパイルが走ってコードが生成されて、生成コードが利用可能になっています。これは今までのビルド時プリプロセッサー/ポストプロセッサーではできなかった体験で、中々小気味良いものです。</p>
<p>唯一の欠点は既存コードをEditできないので、partialであることが必須になることと、編集を要求する内容は作れないことでしょうか。まぁ、それは従来あったAnalyzer(CodeFixProvider)でやればいいということで、それなりに棲み分けもできてますし、ソースコードの追加しかできないという仕様のお陰で、作成に関してはかなりシンプルになったこともいいことです。</p>
<h2>UnitGenerateOptions</h2>
<p>値の等値性だけを実装するのはままあるのですが、それだけだと不便なんですよね。例えばHpは + 100 とかそのまま演算したいじゃん、と。その辺のサポートがないとすぐに.Valueで生の値を取り出すことになって
よくないし、MinやMaxなんかもそのまんま使いたい、例えばHpを現在値の2倍で回復する、みたいなのは <code>target.Hp = Hp.Min(target.Hp * 2, target.MaxHp)</code> と書けたるとかなり自然でいいよね、と。</p>
<p>その辺の生成をサポートするのが UnitGenerateOptions で、これを組み合わせることによって、算術演算子など好きなメソッドが追加されます。UserIdのようなものは算術演算子が生成されては困るので抑制したいし、Hpはフルで生成したい、みたいな使い分けができます。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Hp { }

// -- generates

[System.ComponentModel.TypeConverter(typeof(HpTypeConverter))]
public readonly partial struct Hp : IEquatable&lt;Hp&gt; , IComparable&lt;Hp&gt;
{
    readonly int value;

    public Hp(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(Hp value) =&gt; value.value;
    public static explicit operator Hp(int value) =&gt; new Hp(value);
    public bool Equals(Hp other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;Hp(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in Hp x, in Hp y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in Hp x, in Hp y) =&gt; !x.value.Equals(y.value);
    private class HpTypeConverter : System.ComponentModel.TypeConverter { /* snip... */ }

    // UnitGenerateOptions.ArithmeticOperator
    public static Hp operator +(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value + y.value)));
    public static Hp operator -(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value - y.value)));
    public static Hp operator *(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value * y.value)));
    public static Hp operator /(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value / y.value)));

    // UnitGenerateOptions.ValueArithmeticOperator
    public static Hp operator ++(in Hp x) =&gt; new Hp(checked((int)(x.value + 1)));
    public static Hp operator --(in Hp x) =&gt; new Hp(checked((int)(x.value - 1)));
    public static Hp operator +(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value + y)));
    public static Hp operator -(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value - y)));
    public static Hp operator *(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value * y)));
    public static Hp operator /(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value / y)));

    // UnitGenerateOptions.Comparable
    public int CompareTo(Hp other) =&gt; value.CompareTo(other);
    public static bool operator &gt;(in Hp x, in Hp y) =&gt; x.value &gt; y.value;
    public static bool operator &lt;(in Hp x, in Hp y) =&gt; x.value &lt; y.value;
    public static bool operator &gt;=(in Hp x, in Hp y) =&gt; x.value &gt;= y.value;
    public static bool operator &lt;=(in Hp x, in Hp y) =&gt; x.value &lt;= y.value;

    // UnitGenerateOptions.MinMaxMethod
    public static Hp Min(Hp x, Hp y) =&gt; new Hp(Math.Min(x.value, y.value));
    public static Hp Max(Hp x, Hp y) =&gt; new Hp(Math.Max(x.value, y.value));
}
</code></pre>
<p>この辺のメソッドがしっかり生成されることによって、プリミティブ型をそのまま使うのと遜色のない使用感が担保できるわけです。</p>
<pre><code class="language-csharp">if (character.Hp &lt;= 0) // Hp.GetType == typeof(Hp)
{
    // is dead.
}
</code></pre>
<p>みたいに書けるようになってとても嬉しい。</p>
<p>また、演算子のオーバーロードはしっかり考慮して作るのが地味に大変な代物なので、そこをちゃんとやってくれるのも助かりです。例えばboolの場合はtrue演算子を自動実装します。</p>
<pre><code class="language-csharp">public static bool operator true(Foo x) =&gt; x.value;
public static bool operator false(Foo x) =&gt; !x.value;
public static bool operator !(Foo x) =&gt; !x.value;
</code></pre>
<p>こんなの自分で実装する機会なんてほとんどないと思いますが、これによってifに直接突っ込めるようになります。</p>
<pre><code class="language-csharp">if (foo) // foo.GetType() == typeof(Foo)
{
}
</code></pre>
<p>UnitGenerateOptionsは現在のところ以下のオプションを提供しています。</p>
<pre><code class="language-csharp">[Flags]
internal enum UnitGenerateOptions
{
    None = 0,
    ImplicitOperator = 1,
    ParseMethod = 2,
    MinMaxMethod = 4,
    ArithmeticOperator = 8,
    ValueArithmeticOperator = 16,
    Comparable = 32,
    Validate = 64,
    JsonConverter = 128,
    MessagePackFormatter = 256,
    DapperTypeHandler = 512,
    EntityFrameworkValueConverter = 1024,
}
</code></pre>
<p>例えば以下のように指定できます。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Strength { }

[UnitOf(typeof(DateTime), UnitGenerateOptions.ParseMethod | UnitGenerateOptions.Comparable)]
public readonly partial struct EndDate { }

[UnitOf(typeof(string), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct Message { }

[UnitOf(typeof(byte[]))]
public readonly partial struct Image { }

[UnitOf(typeof((string street, string city)), UnitGenerateOptions.Validate)]
public readonly partial struct StreetAddress
{
    private partial void Validate()
    {
        if (!DataMaster.Contains(value.street)) throw new Exception(&quot;Invalid Street: &quot; + value.street);
        if (!DataMaster.Contains(value.city)) throw new Exception(&quot;Invalid City: &quot; + value.city);
    }   
}
</code></pre>
<p>Validateだけ少し特殊で、自動生成側のコードが<code>partial void Validate()</code>メソッドを生成して、自動生成されるコンストラクタでそれを呼ぶようになっています。Validateの実体をユーザー側が書けばOKということですね。プリミティブ型と違って、値が検証済みであることが保証されている、というのも一般的なプラクティスとしては重要な話です。（ただしstructのため、default(T)は防げないので、そういう意味では完全なValidationではありません）</p>
<h2>シリアライザの自動実装</h2>
<p>繰り返しますが 「{ &quot;Value&quot; = 100 }」みたいにシリアライズされるのは最低です。「100」とシリアライズされなければならない。と、いうわけで、そういう場合は専用のシリアライザを実装すれば回避できます。現状はSystem.Text.JsonのJsonConverterとMessagePack用のMessagePackFormatterを自動実装するオプションが用意されています。こういうのをちまちま用意するのは、私がシリアライザについて人一倍拘りがあるからで、普通はあんまないでしょうね。でもシリアライザはシステムにおいて本当に大事なことだから！</p>
<p>例えば <code>UnitGenerateOptions.MessagePackFormatter</code> は以下のようなコードを自動実装します。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct UserId { }

// -- generates

[MessagePackFormatter(typeof(UserIdMessagePackFormatter))]
public readonly partial struct UserId 
{
    class UserIdMessagePackFormatter : IMessagePackFormatter&lt;UserId&gt;
    {
        public void Serialize(ref MessagePackWriter writer, UserId value, MessagePackSerializerOptions options)
        {
            options.Resolver.GetFormatterWithVerify&lt;int&gt;().Serialize(ref writer, value.value, options);
        }

        public UserId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new UserId(options.Resolver.GetFormatterWithVerify&lt;int&gt;().Deserialize(ref reader, options));
        }
    }
}
</code></pre>
<p>private classでFormatterが実装されるのがポイントで、Attributeからそのフォーマッターを取り出すことで、外部のResolverへの登録をせずに専用の対応をしています。Serialize/DeserializeはResolver経由じゃなくて直接Writer/Readerのプリミティブ型を呼ぶことで高速化できますが、まぁそれは次の機会に。このコードを発展化させた、MessagePack for C#におけるSourceGenerator対応については12/19の記事で詳しく触れる予定です。</p>
<p>データベースに関しても UnitGenerateOptions.DapperTypeHandler, UnitGenerateOptions.EntityFrameworkValueConverter でDapperとEF Coreの対応コードを生成します。ただしこちらは自動利用のシステムがないので、手動で取り出して登録する必要があります。</p>
<h2>.Value is dead</h2>
<p>UnitGeneratorはpublicプロパティを一つも生成しません。つまり、.Valueはありません。私は.Valueによる値の取り出しが悪いプラクティスだと思っていて、カジュアルに使おうという気持ちを起こさないようにしています。演算子の生成なども用意してあるし、あとは専用のメソッドを自前で書いたりしていくなどで解決できるといいよね、と。</p>
<p>とはいえさすがに取り出せないのは不便というか実用的ではないので、<code>.AsPrimitive()</code> で取れます。プロパティではなくメソッドというだけで、心理的に少し抵抗感出るんじゃないでしょうか？制約なんてそのぐらいでいいでしょう。あんまりキツくやるのも好きではないので。</p>
<h2>Unityで使う</h2>
<p>Source Generatorは C# 9.0 の機能です。というわけで、2020年現在のUnityはどのバージョンもそれをサポートしていません。じゃあ使えないじゃんって話なのですが、幸いファイルとして生成する機能も用意されているので、外部コマンドを実行したら自動生成する、ぐらいの雰囲気でならUnityでも使うことができます。</p>
<p>まずはコンフィグとなるcsprojを用意します。例えばUnitSourceGen.csprojとして、以下のような内容のものを作ります。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;

        &lt;!-- add this two lines and configure output path --&gt;
        &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
        &lt;CompilerGeneratedFilesOutputPath&gt;$(ProjectDir)..\Generated&lt;/CompilerGeneratedFilesOutputPath&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;!-- reference UnitGenerator --&gt;
        &lt;PackageReference Include=&quot;UnitGenerator&quot; Version=&quot;1.0.0&quot; /&gt;

        &lt;!-- add target sources path from Unity --&gt;
        &lt;Compile Include=&quot;..\MyUnity\Assets\Scripts\Models\**\*.cs&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとは <a href="https://dotnet.microsoft.com/download">.NET SDK</a>を入れて、コマンドを叩きましょう。</p>
<pre><code>dotnet build UnitSourceGen.csproj
</code></pre>
<p>これで UnitGenerator\UnitGenerator.SourceGenerator*.Generated.cs がOutputPathに指定したところに生成されています。UnitGeneratorは、UnitOfAttributeやUnitGenerateOptionsも自動生成コードの中に含まれる仕様（ランタイムレス）なので、一回空の状態で実行すれば、それらのコードが生成されて利用可能になります。</p>
<h2>SourceGenerator実装の方法</h2>
<p>netstandard2.0のライブラリプロジェクトとして（いまのところnet5.0だとうまくいかない、これはVisual Studioが .NET Frameworkで動いているせいだから、らしい）Microsoft.CodeAnalysis.CSharpを参照します。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; PrivateAssets=&quot;all&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>また、合わせてテスト用のプロジェクトを用意して、ライブラリプロジェクトを参照するようにしておくといいでしょう。プロジェクト参照を、OutputItemType=&quot;Analyzer&quot;にしておきます。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;ProjectReference Include=&quot;..\..\src\UnitGenerator\UnitGenerator.csproj&quot;
                          OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとはISourceGeneratorを実装するだけ。</p>
<pre><code class="language-csharp">[Generator]
public class SourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            // System.Diagnostics.Debugger.Launch();
        }
#endif 

        context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
    }

    // 実装しなくてもいいけど、この段階で対象になるファイルを引っ掛けておくとワンパスで処理できる
    class SyntaxReceiver : ISyntaxReceiver
    {
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
        }
    }
}
</code></pre>
<p>System.Diagnostics.Debugger.Launch() を入れておくと、デバッガでアタッチできて実装が捗ります。ただしVisual Studioがインクリメンタルコンパイル的にかなりの頻度でキックしてくるので、不要なときはコメントアウトしておくのが吉。また、SourceGeneratorの実装コードの変更にたいしてVisual Studioのキャッシュがうまく追随してくれなくて、実装中は挙動が腐ることがよくあるので、困ったときの再起動でやり過ごしましょう。</p>
<p>RegisterForSyntaxNotificationsは使っても使わなくてもどちらでもいいのですが(ExecuteのところでSyntaxTreeの全てが手に入るので探索し放題)、ここで大雑把でも引っ掛けておいたほうが、その後の処理が軽量になるので、使ったほうが基本的にはヨシ。</p>
<p>SourceGeneratorでユーザーが使う属性は、参照DLL内に含めておいてそれを使う場合と、参照DLLは完全に空にして、ソースジェネレーター自身が生成するパターンがあります。後者のパターンを使うと、ソースジェネレーターのためだけに参照DLLが増えることを避けれるので、今回のUnitGeneratorのような、生成コードが全ての処理を行うタイプのものは、そちらのパターンを使ったほうが良いでしょう。</p>
<p>やりかたは単純に最初に必要な属性を突っ込んでしまうという、ただそれだけなのですが一点注意なのは、この生成は絶対死守しましょう。Execute内で例外が発生したりすると、ここでAddSourceした属性の追加はキャンセルされます。</p>
<pre><code class="language-csharp">public void Execute(GeneratorExecutionContext context)
{
    context.AddSource(&quot;UnitOfAttribute.cs&quot;, &quot;internal class UnitOfAttribute...);

    try
    {
        // manipulate syntax...
    }
    catch (Exception ex)
    {
        System.Diagnostics.Trace.WriteLine(ex.ToString());
    }
}
</code></pre>
<p>特にIDEのインクリメンタルコンパイルが稼働している状態だと、入力途中の「不完全なコード」が頻繁に飛んできます。こうした不完全なコードによる不正な構文木を正しくハンドリングするのはかなり難しく、例外を飛ばしてしまうのは正直避けられません。しかし、何があっても最初に生成する属性のAddSourceだけは維持しないと、「入力途中の不完全コード→例外発生で属性が吹っ飛ぶ→属性が吹っ飛ぶので入力補完が効かないどころか書いてるものが全てエラーになる」という負のループが発生します。なので、これに関してはtry-catchで握り潰しOKです。</p>
<p>コード生成のためのテンプレートですが、サンプルだとみんなstring interpolationでさっくり処理してますが、やめときましょう。複雑なコードを生成しようとすると破綻するので、よほど単純な生成じゃないならちゃんとテンプレートエンジン使いましょう。</p>
<p>じゃあ何を使えばいいのか、というとT4 Templateです。以前に<a href="http://neue.cc/2019/12/06_585.html">.NET Core時代のT4によるC#のテキストテンプレート術</a>という記事を書いたので、それを読んでくださいな。これの「実行時テキスト生成(TextTemplatingFilePreprocessor)」を使います。具体的なUnitGeneratorのテンプレートは<a href="https://github.com/Cysharp/UnitGenerator/blob/939e6d54d68dbb102d2986de5fe442b8780d4216/src/UnitGenerator/CodeTemplate.tt">UnitGenerator/CodeTemplate.tt</a>にあるので参考にどうぞ。ただたんにOptionによってifがちょろちょろある程度ですが、それでもこれをstring interpolationとStringBuilderで処理するのは無理があります。</p>
<p>ユニットテストに関しては <code>CSharpGeneratorDriver</code> というものが用意されているので、それで小さいCompilationを作って渡せばOK。ってどういうこっちゃという感じですが、<a href="https://gist.github.com/chsienki/2955ed9336d7eb22bcb246840bfeb05c">chsienki/GeneratorTests.cs</a>のコードをまんま使えばOKですね。中身は単純です。</p>
<pre><code class="language-csharp">var comp = CreateCompilation(/* ソースジェネレーターの対象コード */);
var newComp = RunGenerators(comp, out var generatorDiags, new SimpleGenerator());

// あとはnewCompから生成コードを引っ張ってきて、それが意図通りの正しさかどうか見たり
Assert.Empty(newComp.GetDiagnostics()); // エラーなくちゃんと生成できてるかどうか
</code></pre>
<p>ただし、参照DLLを増やすと面倒くさい挙動したり、そもそも生成されたコードの挙動が正しいかどうかを見たい(UnitGeneratorでいうと算術演算子が正しいかとか、シリアライザの実装が正しいかとか）ほうが多いんじゃないかなーと思うので、普通にユニットテストプロジェクトにSourceGenerator参照して、それが生成されたコードを動かして普通にAssert書く、みたいなのでいいかな。私は実際そんなわけで、CSharpGeneratorDriver経由のテストはやめました。（というかそもそも普通のユニットテストもたいして書いてない説はある）</p>
<p>最後にNuGetへのパブリッシュについて。SourceGeneratorはAnalyerとして登録したいので、ひと手間いります。具体的には以下のように処理します。</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
    &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
    &lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
&lt;/PropertyGroup&gt;

&lt;ItemGroup&gt;
    &lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>IncludeBuildOutputで、自身のDLLを参照用として含めないようにします、これは前述の「参照DLLは完全に空にして、ソースジェネレーター自身が必要な属性を生成するパターン」を使う場合には自身の参照は不要だからですね。SuppressDependenciesWhenPackingは、これ設定しとかないとpack時に空なんだけど、という警告が出てくるので黙らせます。空なのは知っとるがな。</p>
<p>Analyzerとしてpackするにはanalyzers/dotnet/cs以下に配置すればいいだけ、ということで、そういう設定をしておきます。</p>
<p>一手間と言ってもこれだけです。昔はAnalyzerはPowerShell動かして小細工しなきゃいけないとか色々あって超絶面倒くさかったんですが、.NET 5時代の今は、だいぶ簡単になりました。</p>
<h2>まとめ</h2>
<p>ずっとF#の<a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure">Units of Measure</a>のようなものが欲しいと思っていたのですよね。プリミティブなのだけど型がついてる。コンパイル時には型が消えてプリミティブそのものになるのでオーバーヘッドがない。そのままでも色々な演算ができる。</p>
<p>UnitGeneratorはお洒落なsuffixで生成とかはできないし組み込みの単位の変換関係（グラムとキログラムとかインチとフィーととか）があるわけじゃないので、同じものかといったら全然別物ではありますが、しかしValue Objectパターンの実装としては必要十分で、雰囲気も近づけられたのではないかと思います。</p>
<p>C#において、1要素のstructはメモリレイアウト的にはプリミティブ型と同一なので、完全に消せるわけではないですが、オーバーヘッドも減らしていける余地があります(演算のたびにnewで包み直していたりするのも、Unsafe.Asを活用していけばなくせるので、だいぶ近づけはするかな、と）。</p>
<p>実際ちゃんと型がついているのは良い状態で最終的に捗るのは間違いないので、このUnitGeneratorのアプローチが役に立てば何よりですね、是非試してみてください。あと、SourceGeneratorも是非作っていきましょう！</p>
</div>
<h1><a href="https://neue.cc/2020/11/16_596.html">MagicOnion v4 - .NET 5 と ASP .NET Core gRPC対応への進化</a></h1>
<ul class="date"><li>2020-11-16</li></ul>
<div class="entry_body"><p>Cysharpから<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion v4</a>を先週リリースしました。今回のリリースの実装はほぼ全て<a href="https://github.com/mayuki">@mayuki</a>さんにやってもらったので、詳細はそちらに丸投げドンとして(ReadMeもかなり書き換えてあるので、詳しいところはそちらも読んでください)、改めて .NET 5とgRPC、そしてMagicOnionの位置付けとロードマップなどを説明したいかな、と思います。</p>
<p>MagicOnion v4ではサーバーサイド側は完全に ASP.NET Core KestrelベースのPure C#実装になりました。今まではGoogleの提供していたgRPC C Coreを利用していたのですが、今回よりMicrosoft実装に切り替えています。これによりASP.NET Core MVCなどと基盤が共通化されたので、gRPCを提供しつつHTTP/1 REST APIの口やHTML出力を行うような同居がとてもやりやすくなりました。</p>
<p>そして何より、パフォーマンスが向上しています。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/99238325-ed574380-283c-11eb-91cb-5c6982dc6be8.png" width=640>
</p>
<p>.NET 5における性能向上に関しては<a href="https://devblogs.microsoft.com/aspnet/grpc-performance-improvements-in-net-5/">gRPC performance improvements in .NET 5</a>にて紹介されていますが、まず、gRPCと一口で言っても性能は言語によって千差万別です。HTTP/2だから速いとか、gRPCだから速いとか、そういうことはありません。大事なのは実装です。</p>
<p>gRPCの場合は、各言語での独自実装組(Java, Go, Rust)と、Cで作られているCoreのバインディング組(Ruby, Python, Node.js, etc...)に分かれます。バインディングだから低速だということはないのですが（そもそも高速なC++実装はC Coreの上に作られている）、どうしてもマーシャリング部分の実装の甘さや、各言語の部分に乗っかった箇所の実装の弱さに引っ張られて、性能が落ちやすい傾向にあります。</p>
<p>実際のところ、どれだけパフォーマンスに本気になって実装しているか、というところが性能に現れるので、わざわざ各言語で独自実装しているものは本気度が高く、バインディングで済ませているのは本気度が低い（動けば御の字）といったような見方でも良いでしょう。</p>
<p>C#も今まではC Coreのバインディングでしたが、.NET Core 3.1からPure C#実装が提供され、そして今回の.NET 5よりHTTP/2の性能向上に注力したことで、C++, Rust, Goと並ぶTier1の位置までパフォーマンス向上を果たしました。</p>
<p>もともとHTTP/1においても執念深く延々と性能改善施策を続けていて、ついに<a href="https://www.techempower.com/benchmarks/#section=data-r19&amp;hw=ph&amp;test=plaintext">TechEmpower Web Framework Benchmarks</a>では1位(Plaintextのみですが)を奪取しています。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/99238486-2099d280-283d-11eb-87b6-322730902eee.png" width=640>
</p>
<p>それ以外にも .NET 5では<a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/">Performance Improvements in .NET 5</a>として細かい対応を延々としてきたのがついに実ったという感じですね。<a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0/">Announcing .NET 5.0</a>で表明されていますが、.NET 5 は Unified Platformsを標榜してランタイムコンポーネント・コンパイラ・言語を統一するという話があります。そうした大きなバージョンアップに相応しい一歩なのではないでしょうか。</p>
<p>ちなみに、.NET 5、実質的に機能しだすのは.NET 6からで、5に関しては基礎固めと.NET Core 3のリブランディング的な感じなので、実際のインパクトは今の所あんまありません。</p>
<h2>gRPCとトランスポート中立、或いはQUIC</h2>
<p>色々な構成要素の塊がgRPCなのですが、それぞれの要素はプラガブルで分解可能だったりします。シリアライザはProtocol Buffersでなくてもいいし(C++実装は<a href="https://google.github.io/flatbuffers/">FlatBuffers</a>に置き換えられるものも用意されていたりするし、MagicOnionはMessagePackを使っています)、トランスポート層もHTTP/2的な決まりごとにさえ従えるのなら、ある程度は自由に変更できます、実際TCPではなくUNIX domain socketへの置き換えはプロセス間通信としてgRPCを使う場合にはままあります。</p>
<p>C Coreにべったりの場合は、換装の自由度が低かったりしたのですが、Pure C#に置き換わり、その辺の仕組みが全て ASP.NET Core の上に乗っかったことにより、比較的自由に弄れるようになっています。</p>
<p>既にASP.NET CoreにはQuic実装が<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Transport.Experimental.Quic/">Microsoft.AspNetCore.Server.Kestrel.Transport.Experimental.Quic</a>として(Experimentalですが)提供されています。<a href="https://github.com/microsoft/msquic">MsQuic</a>を基盤として利用するため、Quicの実装準拠度としても比較的信用が置けるでしょう。MsQuicはWindows Serverで使うため、当然ながら相当固い実装である必要があるからです。なお、MsQuic自体はクロスプラットフォームのためLinuxで動きます。</p>
<p>サーバーはそうして自由に対応できるとして、現状クライアント側がイマイチなのですが、そこは追々という感じでしょうか。</p>
<p>特にゲームでのリアルタイム通信での利用時に、TCPであることがボトルネックとなることは避けたいので、RUDPや、中国のネットワークゲームでよく使われる<a href="https://github.com/skywind3000/kcp/blob/master/README.en.md">KCP</a>による通信の口は用意しておきたいと思っています。QUICが大安定して全てそれで解決、みたいな時代が来ればいいんですけれどね。そう遠くはなさそうな感じがあるので、期待しています。</p>
<h2>gRPCとMagicOnion、StreamingHubとBidirectional Streaming</h2>
<p>gRPCの色々な構成要素の中でも最重要なのがprotoによる言語中立のスキーマとコードジェネレートにあるでしょう。MagicOnionは、そのprotoを投げ捨ててC# to C#に限定されるため、デメリットを超えるだけのメリットが必要です。</p>
<p>一つはprotoが言語中立であることによる表現力の乏しさを、C#そのものスキーマとすることで解決しています。protoの場合は少しのプリミティブとEnum、コレクションとマップのみですが（また、nullもない)、MagicOnionの場合は、C#そのものスキーマとして見立て、メッセージ形式にMessagePack for C#を利用することで、（ほぼ）全てのC#型が転送可能になっています。</p>
<p>例えば.NET 5ではWCFの置き換えにgRPCが推奨されていますが <a href="https://docs.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/migrate-request-reply">Migrate a WCF request-reply service to a gRPC unary RPC</a> 、protoへの書き換えが必要なことと、表現力のギャップに苦しむことがあります。MagicOnionならDataContractで表現された型は全てMessagePack for C#でシリアライズ可能ですし、OperationContractのメソッドの複数引数のような表現も可能なため、移行におけるギャップはほとんどありません。</p>
<p>また、gRPCは双方向のリアルタイム通信用にBidirectional streaming RPCが利用できますが、これは双方が投げっぱなしのAPIしか存在しないため、戻り値の取得や処理の完了の待機などが実装できません。更にエンドポイントとなる型も一つしか使えないため、大量のoneofで呼び出しの切り分け処理をするしかありません。</p>
<p>MagicOnion StreamingHubはBidirectional streaming RPCの上に、双方向にC#としての型やメソッドのルーティング処理をつけ、client -&gt; server -&gt; client の呼び出しでは戻り値の取得やエラー送信、完了待機のシステムを入れました。この基盤処理の実装によって、初めてgRPCで実用的なリアルタイム通信が可能になっています。なお、APIは <a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction">ASP.NET Core SignalR</a>に寄せたため、そちらの経験があれば比較的スムーズに移行できるはずです。</p>
<h2>UnityとgRPC</h2>
<p>MagicOnion v4ではサーバーサイド側は完全に ASP.NET Core KestrelベースのPure C#実装になりました。クライアント側も.NET Coreの場合はHttpClientベースのPure C#実装になりました。Unityは……？というと、引き続きC Coreベースの提供になります。Unity側の改善はMagicOnionにおいてはv5でなんとかする予定ですので少々お待ち下さい。</p>
<p>Unity側の実装がC Coreで提供されている状態は、初期セットアップが相当面倒くさくなっています。というのもGoogleがAndroid, iOS向けのビルドを雑にとりあえずといった感じで提供しているだけなので、そのまんまだと動かないという……。MagicOnionのReadMeの<a href="https://github.com/Cysharp/MagicOnion/#support-for-unity-client">Support for Unity Client</a>セクションで、その辺は手厚めに解説してはいます。例えばそのまんまだとiOS用のgRPC libが100MBを超えていてGitHubで扱えないという問題が発生するのですが、ReadMeに説明してあるストリッピングの手順に従ってもらえればlibのサイズを縮めることができます。</p>
<p>ほか、C Coreの持つネイティブコネクションのライフサイクルと、Unity上での頻繁なPlay/StopによるC#側のライフサイクルが自動では一致しないため、ネイティブコネクションがリークするとエディタごと巻き込んでフリーズする（この場合、コネクション管理を徹底してライフサイクルを一致させれば大丈夫）、といった面倒くさい問題が発生したりします。</p>
<p>また、Taskベースで作られているためアロケーションが多めという問題もあったり。</p>
<p>これらネイティブライブラリであることの問題は、Pure C#実装を提供することで解決すると考えています。Task部分に関しては<a href="https://github.com/Cysharp/UniTask/">UniTask</a>を活用するように書き換えれば、アロケーションも減らせるでしょう。実際、Unity用のメジャーなOSSネットワークフレームワークであるMirror、の作者陣が内部分裂してForkされた<a href="https://github.com/MirrorNG/MirrorNG">MirrorNG</a>はUniTaskベースで構築されています。</p>
<p>Pure C#実装の場合は、UnityのC#ランタイムであるmonoがあまり性能が良いとは言えないため、問題になる可能性があるのですが、サーバーとして使わなければ大丈夫なのではないかと踏んでいます。フルUnity実装でサーバーを提供する場合は気になるところなのでネイティブ実装を混ぜるなどの方向性もあるとは思いますが、現状のMagicOnionの構成はUnityはクライアントにしかならないので。</p>
<h2>gRPCであること</h2>
<p>gRPCを推しているのは、HTTP/2に乗っかっていることでインフラ側のミドルウェアが豊富なことがあります。Nginx, Envoyなど、今ではほとんどのソフトウェアがHTTP/2対応していますし、AWS ALBに至っては<a href="https://aws.amazon.com/jp/blogs/news/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/">gRPC専用のサポート</a>を追加してきました。これらを活用することで、独自の通信形式などに比べると、サーバー構築の柔軟性が飛躍的に向上しています。独自っぽい雰囲気の漂っているMagicOnionも、変更しているのはメッセージの中身だけなので、gRPCのミドルウェアのエコシステムにはフルに乗っかれています（というか、ちゃんと乗れるように作っているのです）</p>
<p>また、自社で何もかもをすべて作らない、というのもあります。ASP.NET Coreに乗っかることで、Microsoftによる通信ライブラリの性能改善にタダ乗りしています。</p>
<p>gRPCそのもののメリットとしては、API通信とリアルタイム通信の二系統を一つのフレームワークに一本化できること、これは私が4年前にgRPCを採用した（当時は1.0が出たばかりでUnityの利用事例はゼロだし、一般の事例はマイクロサービスのサーバー間通信用としてが多くクライアント-サーバー通信を置き換えようとする例もあまりなかった）理由でもあります。</p>
<h2>ロードマップ</h2>
<p>v5におけるUnityクライアントの作成、ユーティリティとして負荷テストツールの提供、などがとりあえず並んでいます。特に負荷テストツールはあと少しなので、近日中にお届けできるかと。</p>
<p>MagicOnion自体のプロダクト採用の実績は増えてきていて、直近では<a href="https://d4dj.bushimo.jp/">D4DJ Groovy Mix</a>がAPI(Unary)もリアルタイムマルチ(StreamingHub)も活用しています。また、<a href="https://virtualcast.jp/">バーチャルキャスト</a> 2.0では、ルームというVR SNSの実装に活用されているそうです。</p>
<p>ゲームーサーバーとしてC#が活用できるのか？といったことは、クラスメソッドさん向けにお話したゲームサーバー用の発表でも話しましたので、レポ記事 - <a href="https://dev.classmethod.jp/articles/game-server-development-seminar-by-cysharp/">Cysharpの河合様をゲスト講師にお招きしてゲームサーバーに関する社内勉強会を開催しました！</a>と、発表資料もどうぞ。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/Gfd2wf6fsBsj3y" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/building-the-game-server-both-api-and-realtime-via-c" title="Building the Game Server both API and Realtime via c#" target="_blank">Building the Game Server both API and Realtime via c#</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>世の中、適材適所なのは間違いありません。だからこそ、「C#がその適材である」と言えるだけの環境を提供していく、というのがCysharpのミッションでもあります。Microsoftも.NET Coreにおいて、当初はWindowsべったりなC#が今更Linuxとか言ったって、みたいな白い目で見られていました。しかし、最初のバージョンから4年が経ち、文句を言わせないだけのパフォーマンスでもって証明してきました。</p>
<p>.NET 5はスタート地点だと考えています。C#も大変面白い環境になってきたと思うので、是非みんなと追求していけたら嬉しいですね。</p>
</div>
<a href="https://neue.cc/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
