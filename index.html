<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
<meta property="og:url" content="https://neue.cc" />
<meta property="og:type" content="website" />
<meta property="og:title" content="neue cc" />
<meta property="og:description" content="..." />

 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2024/02/27_R3.html">R3 - C#用のReactive Extensionsの新しい現代的再実装</a></h1>
<ul class="date"><li>2024-02-27</li></ul>
<div class="entry_body"><p>先日、新しいC#用のReactive Extensionsの実装としてR3を正式公開しました！R3は<a href="https://github.com/dotnet/reactive">Rx for .NET</a>を第一世代、<a href="https://github.com/neuecc/UniRx">UniRx</a>を第二世代とした場合の、第三世代のRxという意味で命名しています。Rxとしてのコア部分(ほぼdotnet/reactiveと同様)は.NET共通のライブラリとして提供し、各プラットフォーム特化のカスタムスケジューラーやオペレーターは別ライブラリに分けるという形により、全ての.NETプラットフォーム向けのコアライブラリと、各種フレームワーク Unity, Godot, Avalonia, WPF, WinForms, WinUI3, Stride, LogicLooper, MAUI, MonoGame 向けの拡張ライブラリを提供しています。</p>
<ul>
<li><a href="https://github.com/Cysharp/R3">GitHub - Cysharp/R3</a></li>
</ul>
<p>幾つかの破壊的変更を含むため、ドロップインリプレースメントではないですが、dotnet/reactiveやUniRxからの移行も現実的に可能な範囲に収めてあります。この辺は語彙や操作がLINQ的に共通化されているというRxの良いところで、そこのところは大きく変わりはありません。思ったよりも何も変わっていない、といったような印象すら抱けるかもしれませんが、そう思っていただければ、それはそれでR3の設計としては大成功ということになります。</p>
<p>なので基本的なところはRxですし、使えるところも変わりないです。よって、押さえておくべきことは、なぜ今R3という新たな実装が必要になったかということと、Rx for .NET, UniRxとの違いはどこかということです。（新規の人は何も考えず使ってください……！）</p>
<h2>Rxの歴史と vs async/await</h2>
<p>Rx使ってますか？という問いに、使ってません、と答える人も増えてきました。別にこれは.NETやUnityだけの話ではなく、JavaでもSwiftでもKotlinでも。明らかにプレゼンスが低下しています。なぜか？というと、それはもう簡単です。async/awaitが登場したから。.NETのReactive Extensionsが初登場したのは2009年。C# 3.0, .NET Framework 3.5の頃であり、対応プラットフォームもSilverlightやWindows Phoneといった、今はもう消滅したプラットフォームも並んでくるような時代。もちろん、async/await(初登場はC# 5.0, 2012年)も存在していません。まだTaskすら導入されていなかった頃です。余談ですがReactive Extensionsの&quot;Extensions&quot;は、先行して開発されていた<a href="https://en.wikipedia.org/wiki/Parallel_Extensions">Parallel Extensions</a>(Parallel LINQやTask Parallel Library, .NET Framework 4.0で追加された)から名前が取られたとされています。</p>
<p>Rxは、まず、言語サポートのない場合の非同期処理の決定版として、あらゆる言語に普及し一世を風靡しました。単機能なTaskやPromiseよりも、豊富なオペレーターを備えたRxのほうが使いやすいし遥かに強力！私も当時はTPLいらね、とRxに夢中になったものです。しかしasync/awaitが言語に追加されて以降の結果はご存じの通り。async/awaitこそが非同期処理の決定版として、これまたC#からあらゆる言語に普及し、非同期処理におけるスタンダードとなりました。（ちなみにF#こそが発祥だって言う人もいますが、国内海外問わず当時のF#コミュニティのC# async/awaitへの反発と難癖の数々はよーく覚えているので、あ、そうですか、ぐらいの感じです。awaitないしね）</p>
<p>async/awaitが普及したことにより、とりあえず非同期処理のためにRxを入れるという需要はなくなり、Rxの採用率は下がっていったのであった。UnityにおいてのRxのスタンダードであった<a href="https://github.com/neuecc/UniRx/">UniRx</a>の開発者である私も、別にそれに固執することはなく、むしろゲームエンジン(Unity)に特化したasync/awaitランタイムが必要であると素早く認知し、Unityにおいて必要な条件(C# 7.0)が揃ったタイミングで即座に<a href="https://github.com/Cysharp/UniTask">UniTask</a>を開発し、今ではUniTaskは絶対に入れるけどUniRxは入れない、といった開発者も増えてきました。</p>
<h2>Rxの価値の再発見</h2>
<p>そもそもRxって別に非同期処理のためだけのシステムではないですよね？LINQ to Everythingではあったけれど、むしろEverythingというのはノイズで、分離するものは分離したほうがいい、最適なものはそれを使ったほうがいい。Rxを非同期処理のために使うべきではないし、長さ1のObservableはTaskで表現したほうが、分かりやすさにおいてもパフォーマンスにおいても利点がある。そうなるとRxにはasync/awaitと統合されたAPIが必要で、それはObservableはモナドだからSelectManyにTaskを渡せることもできるだとか、そんなどうでもいいことではない。真剣にasync/awaitと共存するRxを考えてみると、手を加えなければならないAPIは多数ある。</p>
<p>単純にawaitできるだけでは現実のアプリケーション開発には少し足りない。そこで非同期/並列処理に関しては様々なライブラリが考案されてきました、Rxだけではなく<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/parallel-programming/dataflow-task-parallel-library">TPL Dataflow</a>など色々ありましたが、それらを好んで今から使おうとする人もいないでしょう。そして今は2024年、勝者は決まりました。言語サポートの<a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/generate-consume-asynchronous-stream">IAsyncEnumerable</a>と<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>がベストです。また、これらはバックプレッシャーの性質も内包しているため、RxJavaなどにあるバックプレッシャーに関するオペレーターは.NETには不要でしょう。もう少し具体的なI/Oに関する処理が必要なら<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/io/pipelines">System.IO.Pipelines</a>を選べば、最大のパフォーマンスを発揮できます。</p>
<p>非同期LINQはあってもいいけれど、実際の非同期ストリームのシナリオからするとLINQ to Objectsと違い利用頻度も少ないので、別に積極的に導入したいというほどの代物ではない(なお、これは私はUniTaskに<a href="https://github.com/Cysharp/UniTask/tree/809d23e/src/UniTask/Assets/Plugins/UniTask/Runtime/Linq">UniTaskAsyncEnumerableとLINQ</a>を自分で実装して提供している上での発言です)。Rxの夢の一つとして分散クエリ(IQbservable)がありましたが、それも、現代での勝者は<a href="https://graphql.org/">GraphQL</a>になるでしょう。分散システムという点では<a href="https://kubernetes.io/">Kubernetes</a>が普及し、RPCとしては<a href="https://grpc.io/">gRPC</a>がスタンダードとして君臨し、<a href="https://learn.microsoft.com/en-us/dotnet/orleans/">Orleans</a>, <a href="https://getakka.net/">Akka.NET</a>, <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction">SignalR</a>, <a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>といったような選択肢のバリエーションもあります。</p>
<p>今は様々なテクノロジーが覇権を争った2009年ではない。現代で<a href="https://azure.microsoft.com/ja-jp/products/service-fabric">Service Fabric</a>を選ぶ人などいないように、今からそこに乗り出して勝ち筋を見出すのは難しい。そうした分散処理に進むことはRxの未来ではない。と、私は考えています。Rxを生み出したのがCloud Programmability Teamであるからといって、Cloudで活用できるようにすることが原点で正しいなどということもないだろう。もちろん、未来は複数あってもいいので、私が示すRxの未来の選択肢の一つがR3だと思ってもらえればよいです。</p>
<p>ではRxの価値はどこにあるのか、というと、原点に立ち返ってインメモリのメッセージングをLINQで処理するLINQ to Eventsにあると考えます。特にクライアントサイド、UIに対する処理は、現代でもRxが評価されているポイントであり、Rx Likeな、しかしより言語に寄り添い最適化されている<a href="https://kotlinlang.org/docs/flow.html">Kotlin Flow</a>や<a href="https://developer.apple.com/documentation/combine">Swift Combine</a>といった選択肢が現役で存在しています。UIだけではなく、複雑で大量のイベントが飛び交うゲームアプリケーションにおいても、ゲームエンジン(Unity)で使われているUniRxの開発者として、非常に有益であることを実感しています。オブザーバーパターンやeventの有意義さは疑う余地のないところですし、そこでRxがbetter event、オブザーパーパターンの決定版として使えることもまた変わらないわけです。</p>
<h2>R3での再構築</h2>
<p>最初に、Rxとしてのインターフェイスを100%維持しながらレガシーAPIの削除や新APIの追加をすべきか、それとも根本から変更すべきかを悩みました。しかし（私が問題だと考えている）すべての問題を解決するには抜本的な変更が必要だし、Kotlin FlowやSwift Combineの成功事例もあるので、旧来のRxとの互換性に囚われず、.NET 8, C# 12という現代のC#環境に合わせて再構築された、完全に新しいRxであるべきという路線に決めました。</p>
<p>といっても、最終的にはインターフェイスにそこまで大きな違いはありません。</p>
<pre><code class="language-csharp">public abstract class Observable&lt;T&gt;
{
    public IDisposable Subscribe(Observer&lt;T&gt; observer);
}

public abstract class Observer&lt;T&gt; : IDisposable
{
    public void OnNext(T value);
    public void OnErrorResume(Exception error);
    public void OnCompleted(Result result); // Result is (Success | Failure)
}
</code></pre>
<p>パッと見だとOnErrorがOnErrorResumeになったことと、interfaceではなくてabstract classになったこと、ぐらいでしょうか。どうしても変更したかった点の一つがOnErrorで、パイプライン上で例外が起きると購読解除されるという挙動はRxにおける<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar mistake</a>だと思っていました。R3では例外はOnErrorResumeに流れて、購読解除されません。かわりにOnCompletedに、SuccessまたはFailureを表すResultが渡ってくるようになっていて、こちらでパイプラインの終了が表されています。</p>
<p><code>IObservable&lt;T&gt;/IObserver&lt;T&gt;</code>の定義は<code>IEnumerble&lt;T&gt;/IEnumerator&lt;T&gt;</code>と密接に関わっていて、数学的双対であると称しているのですが、実用上不便なところがあり、その最たるものがOnErrorで停止することです。なぜ不便かというと、<code>IEnumerable&lt;T&gt;</code>のforeachの例外発生と<code>IObservable&lt;T&gt;</code>の例外発生では、ライフタイムが異なることに起因します。foreachの例外発生はそこでイテレーターの消化が終わり、必要があればtry-catchで処理して、リトライが必要なら再度Enumeratorを取得し直せばいいわけですが、ObservableのSubscribeは違う。必要があればCatchしてRetryすればいい、というものではない。イベントの購読の寿命は長く、例外発生でも停止しないで欲しいと思うことは不自然ではない。通常のeventで例外が発生したとて停止することはないうえに、Rxの場合はオペレーターチェーンの都合上、パイプライン中に例外が発生する可能性が常にある(SelectやWhereすればFuncが例外を出す可能性がある)。イベントの代替、あるいは上位互換として考えると、例外で停止するほうが不自然になってしまいます。</p>
<p>そして、Rxにおいて停止したイベントを再購読するというのは非常に難しい！Observableにはeventと異なり、完了するという概念がある。完了したIObservableを購読すると即座にOnError | OnCompletedが呼ばれる。それにより自動的な再購読は、完了済みのシーケンスを再購読しにかかる危険性がある。もちろんそうなれば無限ループであり、それを判定し正しくハンドリングする術もない。Stack OverflowにはRx/Combine/FlowのUI購読で再購読するにはどうすればいいですか？のような質問が多数あり、そしてその回答は非常に複雑なコードの記述を要求していたりします。現実はRepeat/Retryだけで解決していない！</p>
<p>そこで、そもそも例外で停止しないように変更しました。OnErrorという命名のままでは従来の停止する動作と混同する可能性があるため、かわりにOnErrorResumeという名前に変えています。これで再購読に関する問題は全て解決します。更にこの変更には利点があり、停止する→停止しないの挙動変更は不可能ですが(Disposeチェーンが走ってしまうので状態を復元できないので全体の再購読以外に手段がない)、停止しない→停止するへの挙動変更は非常に簡単でパフォーマンスもよく実装できます。OnErrorResumeが来たらOnCompleted(Result.Failure)に変換するオペレーターを用意するだけですから（標準でOnErrorResumeAsFailureというオペレーターを追加してあります）。</p>
<p>Rx自体が複雑なコントラクトを持つ(OnErrorかOnCompletedはどちらか一つしか発行されない、など)わりに、インターフェースは実装上の保証がないので、従来のRxは正しく実装するのが難しいという問題がありました。SourceのSubscribeが遅延される場合は、先行して返却されるDisposableを正しくハンドリングする必要がある(SingleAssignmentDisposableを使う）などといったことも、正しく理解することは難しいでしょう。asbtract class化することにより大部分のコントラクトを保証し、独自実装が容易になっています。</p>
<p>そして最大の理由は、全ての購読が中央管理されることです。全てのSubscribeは必ず基底クラスのSubscribe実装を通ります。これにより、購読のトラッキングが可能になりました。例えば以下のような形で表示できます。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/149abca5-6d84-44ea-8373-b0e8cd2dc46a" alt="image" /></p>
<blockquote>
<p>これはUnity向けの拡張Windowですが、Godot用にも存在するほか、APIとして提供しているためログに出したり任意のタイミングで取得したり、独自の可視化を作ることも可能です</p>
</blockquote>
<p>TaskにはParallel Debuggerがありますが（これもTaskが基底クラス側でs_asyncDebuggingEnabledの時に中央管理している）、Rxの購読の可視化は、それよりも遥かに重要でしょう。イベントの購読リークはつきもので、開発終盤に必死に探し回る羽目になりますが、R3ならもう不要です！圧倒的開発効率アップ！</p>
<p>R3ではこうした購読の管理、リーク防止については最重要視していて、Observable Trackerによる全ての購読の追跡の他に、概念として「全てのObservableは完了することができる」ようにしました。</p>
<p>Rxにおける購読の管理の基本はIDisposableをDisposeすることです。が、購読を解除する方法は実はそれだけではなく、OnError | OnCompletedが流れることでも解除されるようになっています（IObservableのコントラクトが保証しているわけではないですが実装上そうなっている、R3では必ずそうなるように基底クラス側で保証するようにした）。つまりシーケンスの上流(OnError | OnCompletedの発行)と下流(Dispose)、両面からハンドリングすることでリークをより確実に防ぐことができます。</p>
<p>対応として過剰に思うかもしれませんが、実際のアプリケーションを開発してきた経験からいうと、購読管理は過剰なぐらいがちょうどいい。そうした思想から、R3では、今までOnCompletedを発行する手段のなかったObservable.FromEventやObservable.Timer、EveryUpdateなども、OnCompletedを発行可能にしました。なお、発行方法はCancellationTokenを渡すことで、これもasync/await以降に多用（あるいは濫用）されるようになったCancellationTokenを活用する現代的なAPI設計です。また、こうした全てのObservableは完了する、という思想があるため、SubjectのDisposeも標準でOnCompletedを発行するように変更しました。</p>
<h2>ISchedulerを再考する</h2>
<p>Rxの時空を移動するマジックを実現する機構がISchedulerです。TimerやObserveOnに渡すことで、任意の場所(ThreadやDispatcher、PlayerLoopなど)・時間に値を移動させることができます。</p>
<pre><code class="language-csharp">public interface IScheduler
{
    DateTimeOffset Now { get; }

    IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
    IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action);
}
</code></pre>
<p>そして、実は破綻しています。Rxのソースコードを見たことがあるなら気づいているかもしれませんが、初期のうちから追加の別の定義が用意されています。例えばThreadPoolSchedulerは以下のようなインターフェイスを実装しています。</p>
<pre><code class="language-csharp">public interface ISchedulerLongRunning
{
    IDisposable ScheduleLongRunning&lt;TState&gt;(TState state, Action&lt;TState, ICancelable&gt; action);
}

public interface ISchedulerPeriodic
{
    IDisposable SchedulePeriodic&lt;TState&gt;(TState state, TimeSpan period, Func&lt;TState, TState&gt; action);
}

public interface IStopwatchProvider
{
    IStopwatch StartStopwatch();
}

public abstract partial class LocalScheduler : IScheduler, IStopwatchProvider, IServiceProvider
{
}

public sealed class ThreadPoolScheduler : LocalScheduler, ISchedulerLongRunning, ISchedulerPeriodic
{
}
</code></pre>
<p>そして、以下のような呼び出しがなされています。</p>
<pre><code class="language-csharp">public static IStopwatch StartStopwatch(this IScheduler scheduler)
{
    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        return swp.StartStopwatch();
    }

    return new EmulatedStopwatch(scheduler);
}

private static IDisposable SchedulePeriodic_&lt;TState&gt;(IScheduler scheduler, TState state, TimeSpan period, Func&lt;TState, TState&gt; action)
{
    var periodic = scheduler.AsPeriodic();
    if (periodic != null)
    {
        return periodic.SchedulePeriodic(state, period, action);
    }

    var swp = scheduler.AsStopwatchProvider();
    if (swp != null)
    {
        var spr = new SchedulePeriodicStopwatch&lt;TState&gt;(scheduler, state, period, action, swp);
        return spr.Start();
    }
    else
    {
        var spr = new SchedulePeriodicRecursive&lt;TState&gt;(scheduler, state, period, action);
        return spr.Start();
    }
}
</code></pre>
<p>ようは生のISchedulerを使わないケースがそれなりにあります。なぜ使われないのか、というと、パフォーマンス上の問題で、IScheduler.Scheduleは単発の実行しか定義されていなくて、複数回の呼び出しは再帰的にScheduleを呼べばいいじゃんという発想なわけですが、都度IDisposableを生成するなどパフォーマンス的に問題がある。ので、それを回避するためにISchedulerPeriodicなどが用意されたのでした。</p>
<p>それなら、もうISchedulerではなく、実態をまともに反映されたものを使ったほうがいいんじゃないか？と思ったときに出てきたのが.NET 8で追加された<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>で、これならISchedulerが行っていたことをより効率的にできることを発見しました。</p>
<pre><code class="language-csharp">public abstract class TimeProvider
{
    // use these.
    public virtual ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period);
    public virtual long GetTimestamp();
}
</code></pre>
<p>CreateTimerで生成されるITimerはISchedulerPeriodicで行える機能を十分持っているほか、ワンタイムの実行を繰り返す(<code>Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)</code>)のシナリオにおいても、ITimerを使いまわせるため、dotnet/reactiveのThreadPoolSchedulerよりも効率的です(ThreadPoolSchedulerは都度<code>new Timer()</code>している)。</p>
<p>現在時間の取得に関しては、<code>DateTimeOffset IScheduler.Now</code>のようにTimeProviderも<code>DateTimeOffset TimeProvider.GetUtcNow()</code>がありますが、使っているのは<code>long GetTimestamp</code>だけです。というのも、オペレーターの実装に必要なのはTicksだけなので、わざわざDateTimeOffsetに包むようなオーバーヘッドはないほうが良いので、生のTicksを扱って時間を計算します。</p>
<p>DateTimeOffset.NowはOSのシステム時刻の変更の影響を受ける可能性もあるので、そういう点でもDateTimeOffsetを介さないGetTimestamp(標準では<code>Stopwatch.GetTimestamp()</code>からの高解像度タイマーが利用される)経由が良いでしょう。</p>
<p>ISchedulerのもう一つの問題として、同期的な処理を行う<code>ImmediateScheduler</code>や<code>CurrentScheduler</code>がいます。これらにTimerやDelayなど時間系の処理を任せるとThread.Sleepするという、使うべきではない非同期コードのエミュレーションをするので、つまり、同期的なSchedulerは存在が悪なのでないほうがいいでしょう。R3では完全に消し、TimeProviderを指定するということは必ず非同期的な呼び出しであるということを徹底しました。</p>
<p><code>ImmediateScheduler</code>や<code>CurrentScheduler</code>の問題はそれだけじゃなくて、そもそもパフォーマンスが致命的に悪いという問題があります。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/68a12664-a840-4725-a87c-8fdbb03b4a02" alt="image" /></p>
<blockquote>
<p><code>Observable.Range(1, 10000).Subscribe()</code> の結果</p>
</blockquote>
<p><code>CurrentScheduler</code>はともかく、<code>ImmediateScheduler</code>の結果が悪いのは直観に反するかもしれません。dotnet/reactiveの<code>ImmediateScheduler</code>は、Scheduleされるたびに<code>new AsyncLockScheduler()</code>し、<code>AsyncLockScheduler</code>が呼び出す基底クラス<code>LocalScheduler</code>のコンストラクターが<code>SystemClock.Register</code>し、それは<code>lock</code>し<code>new WeakReference&lt;LocalScheduler&gt;(scheduler)</code>し、<code>HashSet.Add</code>します。毎回。パフォーマンスが悪いのも当然です。</p>
<p>Rangeなんてめったに使わないから大丈夫と思いきや、実は意外なところで<code>ImmediateScheduler</code>はちょくちょく使われています。代表的なのが<code>Merge</code>で、これは<code>IScheduler</code>が無指定の場合は<code>ImmediateScheduler</code>を使うため、場合によってはかなりの呼び出す回数になる可能性があります。実際、dotnet/reactiveをサーバーアプリケーションで使用した際に、MergeとImmediateSchedulerが原因でサーバーのメモリ使用量のかなりを占めたことがありました。その時はカスタムの軽量なスケジューラーを作成し、直接指定することで徹底的に<code>ImmediateScheduler</code>を避けることで何とかしました。Next dotnet/reactiveがあるなら、<code>ImmediateScheduler</code>のパフォーマンスの改善は真っ先に行う必要があります。</p>
<p>ところで、TimeProviderの採用によって、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.time.testing.faketimeprovider?view=dotnet-plat-ext-8.0">Microsoft.Extensions.Time.Testing.FakeTimeProvider</a>を使い、標準的な手法でユニットテストが容易になったことも嬉しいところでしょう。</p>
<h2>FrameProvider</h2>
<p>他のRxでは見かけないがUniRxで絶大な効果を発揮したものとして、フレームベースのオペレーター郡があります。一定フレーム後に実行する<code>DelayFrame</code>や次フレームで実行する<code>NextFrame</code>、毎フレーム発行するファクトリーである<code>EveryUpdate</code>や、毎フレーム値を監視する<code>EveryValueChanged</code>など、ゲームエンジンで利用するにあたって便利なオペレーターが揃っています。</p>
<p>そこで気づいたのが、時間とフレームは概念的には似たものであり、ゲームエンジンだけでなく、UI処理ではメッセージループやレンダリングループという形で、様々なフレームワークに存在している。そこで、R3では新しくTimerProviderと対になるFrameProviderという形でフレームベースの処理を抽象化しました。これによってUnityだけに提供されていたフレームベースのオペレーターが、C#が動作するあらゆるフレームワーク(WinForms, WPF, WinUI3, MAUI, Godot, Avalonia, Stride, etc...)で動作せることができるようになりました。</p>
<pre><code class="language-csharp">public abstract class FrameProvider
{
    public abstract long GetFrameCount();
    public abstract void Register(IFrameRunnerWorkItem callback);
}

public interface IFrameRunnerWorkItem
{
    // true, continue
    bool MoveNext(long frameCount);
}
</code></pre>
<p>R3ではTimeProviderを要求するオペレーターがある場合、全てに対となる***Frameオペレーターを実装しました。</p>
<ul>
<li>Return &lt;-&gt; ReturnFrame</li>
<li>Yield &lt;-&gt; YieldFrame</li>
<li>Interval &lt;-&gt; IntervalFrame</li>
<li>Timer &lt;-&gt; IntervalFrame</li>
<li>Interval &lt;-&gt; IntervalFrame</li>
<li>Chunk &lt;-&gt; ChunkFrame</li>
<li>Debounce &lt;-&gt; DebounceFrame</li>
<li>Delay &lt;-&gt; DelayFrame</li>
<li>DelaySubscription &lt;-&gt; DelaySubscriptionFrame</li>
<li>ObserveOn(TimeProvider) &lt;-&gt; ObserveOn(FrameProvider)</li>
<li>Replay &lt;-&gt; ReplayFrame</li>
<li>Skip &lt;-&gt; SkipFrame</li>
<li>SkipLast &lt;-&gt; SkipLastFrame</li>
<li>SubscribeOn(TimeProvider) &lt;-&gt; SubscribeOn(FrameProvider)</li>
<li>Take &lt;-&gt; TakeFrame</li>
<li>TakeLast &lt;-&gt; TakeLastFrame</li>
<li>ThrottleFirst &lt;-&gt; ThrottleFirstFrame</li>
<li>ThrottleFirstLast &lt;-&gt; ThrottleFirstLastFrame</li>
<li>ThrottleLast &lt;-&gt; ThrottleLastFrame</li>
<li>Timeout &lt;-&gt; TimeoutFrame</li>
</ul>
<h2>async/await Integration</h2>
<p>まず、既存のRxにおいて良くない点である単一の値を返すObservableを徹底的に排除しました。FirstはFirstAsyncになり、<code>Task&lt;T&gt;</code>を返します。AsyncSubjectはなくなり、TaskCompletionSourceを使ってくださいというスタイルです。</p>
<p>そのうえで、現在のC#コードは日常的に非同期のコードが返ってきます、が、基本的にはRxは同期コードしか受け取りません。うっかりすればFireAndForget状態になるし、SelectManyに混ぜるだけでは十分とはいえません。そこで、Where/Select/Subscribeに特殊なメソッド群を用意しました。</p>
<p>| Name | ReturnType |
| --- | --- |
| <strong>SelectAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;TResult&gt;&gt;</code> selector, <code>AwaitOperations</code> awaitOperations = AwaitOperation.Sequential, <code>bool</code> configureAwait = true, <code>bool</code> cancelOnCompleted = true, <code>int</code> maxConcurrent = -1) | <code>Observable&lt;TResult&gt;</code> |
| <strong>WhereAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&lt;Boolean&gt;&gt;</code> predicate, <code>AwaitOperations</code> awaitOperations = AwaitOperation.Sequential, <code>bool</code> configureAwait = true, <code>bool</code> cancelOnCompleted = true, <code>int</code> maxConcurrent = -1) | <code>Observable&lt;T&gt;</code> |
| <strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>AwaitOperations</code> awaitOperations = AwaitOperation.Sequential, <code>bool</code> configureAwait = true, <code>bool</code> cancelOnCompleted = true, <code>int</code> maxConcurrent = -1) | <code>IDisposable</code> |
| <strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperations</code> awaitOperations = AwaitOperation.Sequential, <code>bool</code> configureAwait = true, <code>bool</code> cancelOnCompleted = true, <code>int</code> maxConcurrent = -1) | <code>IDisposable</code> |
| <strong>SubscribeAwait</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> onNextAsync, <code>Action&lt;Exception&gt;</code> onErrorResume, <code>Action&lt;Result&gt;</code> onCompleted, <code>AwaitOperations</code> awaitOperations = AwaitOperation.Sequential, <code>bool</code> configureAwait = true, <code>bool</code> cancelOnCompleted = true, <code>int</code> maxConcurrent = -1) | <code>IDisposable</code> |</p>
<pre><code class="language-csharp">public enum AwaitOperation
{
    /// &lt;summary&gt;All values are queued, and the next value waits for the completion of the asynchronous method.&lt;/summary&gt;
    Sequential,
    /// &lt;summary&gt;Drop new value when async operation is running.&lt;/summary&gt;
    Drop,
    /// &lt;summary&gt;If the previous asynchronous method is running, it is cancelled and the next asynchronous method is executed.&lt;/summary&gt;
    Switch,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method.&lt;/summary&gt;
    Parallel,
    /// &lt;summary&gt;All values are sent immediately to the asynchronous method, but the results are queued and passed to the next operator in order.&lt;/summary&gt;
    SequentialParallel,
    /// &lt;summary&gt;Send the first value and the last value while the asynchronous method is running.&lt;/summary&gt;
    ThrottleFirstLast
}
</code></pre>
<p>SelectAwait, WhereAwait, SubscribeAwaitは非同期メソッドを受け取り、その非同期メソッドが実行されている間に届く値に対する処理のパターンを6パターン用意しました。Sequentialはいったんキューにためて非同期メソッドが完了したら新しい値を送ります。Dropは実行中に届いた値は全て捨てます、これはイベントハンドリングで多重Submit防止などに使えます。Switchは<code>Observable&lt;Observable&gt;.Switch</code>と同様、Parallelは並列実行するもので<code>Observable&lt;Observable&gt;.Merge</code>と同様、ですがわかりやすいでしょう。並列実行数も指定できます。SequentialParallelは並列実行しつつ、後続に流す値は届いた順序で保証します。ThrottleFirstLastは非同期メソッド実行中の最初の値と最後の値を送ります。</p>
<p>更に、以下の時間系のフィルタリングメソッドも非同期メソッドを受け取るようになっています。</p>
<p>| Name | ReturnType |
| --- | --- |
| <strong>Debounce</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> throttleDurationSelector, <code>Boolean</code> configureAwait = true) | <code>Observable&lt;T&gt;</code> |
| <strong>ThrottleFirst</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, <code>Boolean</code> configureAwait = true) | <code>Observable&lt;T&gt;</code> |
| <strong>ThrottleLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, <code>Boolean</code> configureAwait = true) | <code>Observable&lt;T&gt;</code> |
| <strong>ThrottleFirstLast</strong>(this <code>Observable&lt;T&gt;</code> source, <code>Func&lt;T, CancellationToken, ValueTask&gt;</code> sampler, <code>Boolean</code> configureAwait = true) | <code>Observable&lt;T&gt;</code> |</p>
<p>async/awaitは現代のC#に欠かせないコードですが、可能な限りスムーズにRxと統合されるように腐心しました。</p>
<h2>名前付けのルール</h2>
<p>R3では幾つかのメソッドの名前がdotnet/rectiveやUniRxから変更されています。例えば以下のものです。</p>
<ul>
<li><code>Buffer</code> -&gt; <code>Chunk</code></li>
<li><code>StartWith</code> -&gt; <code>Prepend</code></li>
<li><code>DistinctUntilChanged(selector)</code> -&gt; <code>DistinctUntilChangedBy</code></li>
<li><code>Throttle</code> -&gt; <code>Debounce</code></li>
<li><code>Sample</code> -&gt; <code>ThrottleLast</code></li>
</ul>
<p>この変更の理由について説明しましょう。</p>
<p>まず、.NETにおいてLINQスタイルのライブラリを作成する場合に最優先すべき名前はLINQ to Objects(Enumerable)に実装されているメソッド名です。<code>Buffer</code>がなぜ<code>Chunk</code>に変更されたかというと、.NET 6からEnumerable.Chunkが追加され、その機能がBufferと同じだからです。RxのほうがChunkの登場より遥か前なので、名前が違うのはどうにもならないのですが、何のしがらみもないのなら名称はLINQ to Objectsに合わせなければならない。よって、Chunk一択です。PrependやDistinctUntilChangedByも同様です。</p>
<p><code>Throttle</code>が<code>Debounce</code>に変更されたことには抵抗があるかもしれません。これは、そもそも世の中のスタンダードは<code>Debounce</code>だからです。Rx系で<code>Debounce</code>を<code>Throttle</code>という名前でやってるのはdotnet/reactiveだけです。世の中のRxの始祖はRxNetなのだから変えなきゃいけない謂われはない、と突っぱねることも正義ではあるんですが、もはや多勢に無勢の少数派なので、長いものに巻かれることもまた正しい。</p>
<p><code>Debounce</code>に変えた理由はそれだけではなく、<code>ThrottleFirst</code> / <code>ThrottleLast</code>の存在もあります。これらはサンプリング期間の最初の値を採用する、または最後の値を採用する、というもので対になっています。で、(dotnet/reactiveの)Throttleは全然違う挙動なわけです、なのにThrottleという名前は混乱するでしょう。そももそもdotnet/reactiveにはThrottleFirstが存在せず、ThrottleLastに相当するSampleのみが存在するので大丈夫なのですが、ThrottleFirst/ThrottleLastを採用するなら、必然的に名前は<code>Debounce</code>にせざるを得ません。どちらかというとdotnet/reactiveの機能不足が悪い。</p>
<p><code>Sample</code>に関してはFirst/Lastという名前と機能の対称性から<code>ThrottleLast</code>という名前に変更しました。dotnet/reactiveではFirstが存在しないのでSampleでも良かったのですが、<code>ThrottleFirst</code>を採用するなら、必然的に名前は<code>ThrottleLast</code>になります。</p>
<p><code>Sample</code>の名前は残して<code>ThrottleLast</code>のエイリアスにするという折衷案もあるのですが(RxJavaなどはそうなっています)、同じ機能の別名があるとユーザーは混乱します。世の中には<code>sample</code>と<code>throttleLast</code>の違いってなんですか？みたいな質問がそれなりにあります。ただでさえ複雑なRx、無用な混乱を避けるためにもエイリアスは絶対にやめるべき。SelectをMap、WhereをFilterにマッピングするみたいなエイリアスは愚かの極みです。</p>
<h2>プラットフォーム向けデフォルトスケジューラー</h2>
<p>dotnet/reactiveにおいてデフォルトのスケジューラーはほとんど固定です。正確には<code>IPlatformEnlightenmentProvider</code>や<code>IConcurrencyAbstractionLayer</code>というのものを適切に実装すれば、ある程度挙動を差し替えることも可能なのですが、無駄に複雑なうえに<code>[EditorBrowsable(EditorBrowsableState.Never)]</code>で隠されているしで、まともに使うことはほとんど想定されていないように見えます。</p>
<p>しかし、TimerやDelayなどはWPFであればDispatcherTimerで、UnityではPlayerLoop上のTimerで動くと、自動的にメインスレッドにディスパッチしてくれるので、ほとんどの場合でObserveOnが不要になるので便利ですしパフォーマンス上も有利に働きます。</p>
<p>R3ではシンプルにデフォルトのTimeProvider/FrameProviderを差し替えられるようにしました。</p>
<pre><code class="language-csharp">public static class ObservableSystem
{
    public static TimeProvider DefaultTimeProvider { get; set; } = TimeProvider.System;
    public static FrameProvider DefaultFrameProvider { get; set; } = new NotSupportedFrameProvider();
}
</code></pre>
<p>アプリケーション起動時に差し替えれば、そのアプリケーション上でベストなスケジューラーがデフォルト利用されます。</p>
<pre><code class="language-csharp">// 例えばWPFの場合はDispatcher系がセットされるので自動的にUIスレッドに戻ってくる
public static class WpfProviderInitializer
{
    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new WpfDispatcherTimerProvider();
        ObservableSystem.DefaultFrameProvider = new WpfRenderingFrameProvider();
    }
}

// Unityの場合はPlayerLoopベースのものが使用されるのでThreadPoolを避けれる
public static class UnityProviderInitializer
{
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
    public static void SetDefaultObservableSystem()
    {
        SetDefaultObservableSystem(static ex =&gt; UnityEngine.Debug.LogException(ex));
    }

    public static void SetDefaultObservableSystem(Action&lt;Exception&gt; unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = UnityTimeProvider.Update;
        ObservableSystem.DefaultFrameProvider = UnityFrameProvider.Update;
    }
}
</code></pre>
<p>dotnet/reactiveがデフォルトスケジューラーを変更できないのは、あまり、多種のプラットフォームをサポートしているとは言い難いでしょう。</p>
<pre><code class="language-csharp">internal static class SchedulerDefaults
{
    internal static IScheduler ConstantTimeOperations =&gt; ImmediateScheduler.Instance;
    internal static IScheduler TailRecursion =&gt; ImmediateScheduler.Instance;
    internal static IScheduler Iteration =&gt; CurrentThreadScheduler.Instance;
    internal static IScheduler TimeBasedOperations =&gt; DefaultScheduler.Instance;
    internal static IScheduler AsyncConversions =&gt; DefaultScheduler.Instance;
}
</code></pre>
<p>特にAOTのシナリオやWeb向けパブリッシュ(WASM)では、ThreadPoolが使えなくて絶対に避けたいという状況もあります。そこでSchedulerDefaults.TimeBasedOperationsが実質ThreadPoolSchedulerに固定されているのは厳しいと言わざるを得ません。</p>
<h2>Pull IAsyncEnumerable vs Push Observable</h2>
<p><code>IAsyncEnumerable</code>(またはUniTaskの<code>IUniTaskAsyncEnumerable</code>)は、Pullベースの非同期シーケンス。RxはPushベースの非同期シーケンス。似てます。LINQ的なことができるのも似てます。どちらを使うべきかがケースバイケースなのは当然だとして、じゃあそのケースってのはなんなのか、いつどちらを使えばいいのか。という判断基準は欲しいところです。</p>
<p>基本的には裏にバッファー（キュー）があるものはPullベースが向いていると思うので、ネットワーク系のシナリオなんかは<code>IAsyncEnumerable</code>を使っていくといいんじゃないでしょーか。で、実際、<code>System.IO.Pipelines</code>や<code>System.Threading.Channels</code>によって自然と使う機会が出てきます。</p>
<p>Rxは、やはりイベント関連ですね。ようするに、源流のソースにとって自然な表現を選ぶべき、ということです。生のイベント、OnMoveであったりOnClickであったりなどは、完全にPushで、そこにバッファーはないわけです。ということは、Rxで扱うほうが自然です。間にキューを挟んで<code>IAsyncEnumerable</code>で扱うこともできますが、不自然ですよね。あるいはキューを介さないことにより意図的に値をDropするという表現をすることもできますが、やはりそれも不自然です。不自然ということはたいていはパフォーマンスも良くないし、分かりやすくもない。つまり、良くない。だから、イベント関連はRxで扱いましょう。R3ならasync/awaitとの統合によって、非同期処理中のバッファリングや値のドロップなどは明示的にオペレーターで指定することができます。それは、分かりやすく、パフォーマンスも良い。R3を使っていきましょう。</p>
<h2>C#パフォーマンス勉強会</h2>
<p>4/27に<a href="https://cs-reading.connpass.com/event/309714/">C#パフォーマンス勉強会</a>という勉強会が大阪で（大阪で！）開催されます。私は「R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例」というタイトルで、R3の！実装の！パフォーマンス上の工夫を！徹底的に解説しようと思っているので、参加できる方はぜひぜひです。関西へは滅多に行かないので貴重な機会ということなのでよろしくお願いします！</p>
<h2>まとめ</h2>
<p>色々言いましたが、オリジナルのRx.NETの作者達には感謝しかありません。改めて、やはりRxのアイディアの素晴らしさや、各種オペレーターの整理された機能には目を見張るものがあります。幾つかの部分の実装は古くなってしまっていますが、実装クオリティも高いと思います。私自身も最初期から使ってきたし、熱狂してきました。そして、現在のメンテナーにも感謝します。常に変わっていく環境の中で、多く使われているライブラリを維持することはとても大変なことです。</p>
<p>しかし、だからこそ、Rxの価値を復活させたかった。そして、再構築するならば、できるのは私しかいないと思った。最初期からのRxの歴史と実装を知っていて、自分でRxそのものの実装(UniRx)を行い、それが世の中に広く使われることで多くのユースケースや問題点を知り、自分自身もゲームタイトルの実装で大規模に使われるRxのアプリケーション側にも関わり、Rxと対となるasync/awaitの独自ランタイム(UniTask)を実装し、それも世の中に広く使われていることで、この領域に関してのあらゆる知見がある。</p>
<p>上のほうでも言いましたが、未来は複数あってもいいので、私が示すRxの未来の一つがR3だと思ってもらえればよいです。dotnet/reactiveにもまた別の進化と未来がある。かもしれません。</p>
<p>そのうえでR3は置き換えられるだけのポテンシャルと、可能性を見せることができたと思っています。実装には自信あり、です。今回UniRxの実績があったからというのもあり、プレビュー公開時から多くのフィードバックがもらえたことは嬉しかったです(UniTask初公開時は、Unityのコンパイラを実験的コンパイラに差し替える必要があるとかいうエクストリーム仕様だったせいか、しばらくの間は誰も使ってくれなかったというか意義を分かってくれなかったので……）。</p>
<p>移行に関するシナリオも最大限配慮したつもりではあるので、是非使ってみてください……！</p>
</div>
<h1><a href="https://neue.cc/2024/01/15_shareprojectinunity.html">.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法</a></h1>
<ul class="date"><li>2024-01-15</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnionのv6</a>が先日リリースされました。</p>
<p>メジャーバージョンアップとして大きな違いは、<a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a>を正式リリースし、これを通信層の標準ライブラリ化しました。インストール手順も複雑で、サポートも切れていたgRPC C-Coreとはさようならです。正式リリースにあたってプレビューに存在していたクラッシュ問題などが解消されています。</p>
<p>もう一つはクライアント生成においてコマンドラインツールが削除され、Source Generatorベースになりました。</p>
<pre><code class="language-csharp">[MagicOnionClientGeneration(typeof(MyApp.Shared.Services.IGreeterService))]
partial class MagicOnionGeneratedClientInitializer {}
</code></pre>
<p>これだけでコンパイル時にジェネレートされます。コマンドラインツールには、インストールしている.NETのバージョンによって動作したりしなかったりや、生成ファイルの管理をどうするかや、ビルドプロセスの複雑化など、問題が多くありましたがSource Generator化によって全て解決しました。</p>
<p>残念ながらまだMessagePack for C#がコマンドラインツールを必要としているため、完全なコマンドラインツール不要化には至っていませんが、そちらの改善も着手中のため、近いうちにはアプリケーション全体の完全なSource Generator化が果たせるのではないかと思います。それに合わせて<a href="https://github.com/Cysharp/MasterMemory/">Cysharp/MasterMemory</a>のSource Generator化も行いたいと思っています。</p>
<h2>.NETプロジェクトとUnityプロジェクト間でのコード共有</h2>
<p>MagicOnionに限らずですが、.NETとUnityとの間でソースコードをどのように共有すればいいのか問題があります。昔のやり方では、Unity側で実態を持っていて.NET側で参照を拾ってくるとか、.NET側のビルド時にUnity側にコピーをばらまく、シンボリックリンクで参照する、などといった方法を提案していたのですが、すべて正直イマイチでした。</p>
<p>というわけで令和最新版の方法を紹介します。先に結論をいうと、.NET側に普通の共有用クラスライブラリプロジェクトを作って、Unity側ではUPMのローカルパッケージ参照でソースコードを引っ張ってくるのが現状のベストだと考えています。ただしそのままやると幾つか面倒なことが発生するので、しっかりした手順をここに書いておきます。</p>
<p>まずは.NET側のプロジェクトとして、.NET Standard 2.0/2.1, LangVersion 9のクラスライブラリプロジェクトを作ります。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/0019a2b0-ec2c-4786-9d1d-0078e8dc0295" alt="image" /></p>
<p>そして<code>Directory.Build.props</code>を配置します。これは複数のcsprojにまたがって共有した設定が行えるやつなのですが、今回は単独のcsprojに適用する場合にも使います。そんな<code>Directory.Build.props</code>の中身はこれです。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Project ToolsVersion=&quot;15.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- Unity ignores . prefix folder --&gt;
    &lt;ArtifactsPath&gt;$(MSBuildThisFileDirectory).artifacts&lt;/ArtifactsPath&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>最新手法と銘打った理由として.NET 8(以降に同梱されてるコンパイラ)は<a href="https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output">成果物の出力レイアウトを変更する</a>ことができるようになりました。なぜこれが必要かというと、通常、ビルドするとbin, objがcsprojのディレクトリに吐かれるわけですが、Unityでパッケージ参照するとそのbin, objまで取り込んでしまって大問題なんですね。ArtifactsPathを設定することでbin, objの出力場所を変更できます、そして<a href="https://docs.unity3d.com/Manual/SpecialFolders.html">Unityのアセットインポートにおける命名規則</a>のうち<code>.</code>か<code>~</code>で始まってるファイルまたはフォルダは無視されます。というわけで、bin, objの出力場所を<code>.artifacts</code>に変えることで、Unityから参照しても問題ない構成になりました。</p>
<p>もう少し作業が必要で、次にcsprojを開いて、以下の行を追加しておきます。</p>
<pre><code class="language-csharp">&lt;ItemGroup&gt;
  &lt;None Remove=&quot;**\package.json&quot; /&gt;
  &lt;None Remove=&quot;**\*.asmdef&quot; /&gt;
  &lt;None Remove=&quot;**\*.meta&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>これは、Unityからパッケージ参照すると.metaが大量にばらまかれてウザいので、少なくともcsprojの見た目からは消しておきます。package.jsonとasmdefも同様に.NETプロジェクトとしては不要なので管理外へ。</p>
<p>というわけで最後に、package.jsonとasmdefをこのディレクトリに置いておきましょう。これがないとUnity側から正しく参照できないので。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/54c9564d-c6f2-44ec-b86c-bec19ecfb040" alt="image" /></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;displayName&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;description&quot;: &quot;ChatApp.Shared.Unity&quot;,
  &quot;unity&quot;: &quot;2019.1&quot;
}
</code></pre>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;ChatApp.Shared.Unity&quot;,
    &quot;references&quot;: [
        &quot;MessagePack&quot;,
        &quot;MagicOnion.Abstractions&quot;
    ],
    &quot;optionalUnityReferences&quot;: [],
    &quot;includePlatforms&quot;: [],
    &quot;excludePlatforms&quot;: [],
    &quot;allowUnsafeCode&quot;: false,
    &quot;overrideReferences&quot;: false,
    &quot;precompiledReferences&quot;: [],
    &quot;autoReferenced&quot;: true,
    &quot;defineConstraints&quot;: []
}
</code></pre>
<p>referencesとかはお好きな感じで。</p>
<p>これでほぼ準備は完了です！とはもうUnity側ではPackage Managerを開いてAdd package from diskで先ほどの共有プロジェクトのディレクトリを指定すればOK。</p>
<p><img src="https://github.com/Cysharp/MagicOnion/assets/46207/a46813ab-72fb-44b3-ac8e-241451f9128f" alt="image" /></p>
<p>ただし、これで参照すると絶対パスが書かれているので、<code>manifest.json</code>を開いて相対パスに手動で書き換えましょう。</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;com.cysharp.magiconion.samples.chatapp.shared.unity&quot;: &quot;file:../../ChatApp.Shared&quot;,
  }
}
</code></pre>
<p>これでいい具合に取り扱うことができました！</p>
<p><img src="https://github.com/Cysharp/R3/assets/46207/ed8c1d20-fd8a-4e6c-afe5-2350d3fa2860" alt="image" /></p>
<p>さらに一歩進んで、サーバー側のslnでUnity側のcsprojも一緒に管理したいんだよなあ、とかやりたい場合は<a href="https://github.com/Cysharp/SlnMerge/">Cysharp/SlnMerge</a>を使うとよいでしょう。</p>
<p><img src="https://github.com/Cysharp/SlnMerge/assets/46207/6b70bfda-5f80-42c0-9acc-ca3922f22c52" alt="image" /></p>
<p>単一slnで管理すると、Unity側での作業時に共有プロジェクトのコードを弄りやすくなりますし、サーバー/クライアントを超えたデバッグのステップ実行ができるようになるなど、かなり作りやすくなるので、あわせて是非設定しておくことをお薦めします。</p>
<h2>Unity用ライブラリのNuGet配布のための開発時環境設定</h2>
<p>先日<a href="https://github.com/Cysharp/R3/">R3</a>というUniRxの進化版みたいなのをリリースしましたが、これはコアライブラリはNuGetで配布するようにしました。ちょっと前まで私はNuGet配布に関して否定的で、Unity向けにはソースコードをちゃんと配らないと、みたいに思ってたんですが、今はNuGet配布にたいして超ポジティブです。というか、逆にNuGet配布じゃないとマズいような状況もあるので、今後のものは全てNuGet配布にするほか、既存のものも随時NuGet配布に切り替えると思います。まずはMessagePack for C#が近いうちにそうなります……！</p>
<p>それはいいんですが、Unity用に開発している際に.NETライブラリとして作られているコードを参照したい、んですよね、というか参照できないとUnity向け拡張(R3.Unity)が作れないし。</p>
<p>で、じゃあ上のやり方みたいローカルパッケージ参照でソースコードを持ってきてやろう、と思ったんですが、ダメでした。というのもR3の本体はC# 12で書かれていたのだ……！DLLとして配布するので別に言語バージョンは問題ない(コンパイルしてIL化すると.NETのバージョンは関係ありますが言語バージョンは関係なくなる)ので、Unityで使うことが前提ながら普通にC# 12で書いていたので、ソースコードとしての参照はできない。</p>
<p>ビルド時の成果物をUnity側にコピーするようにしても、まぁいいっちゃあいいんですが、作業中のちょっと書き換える度にコミットされるのでリポジトリが無駄に膨らむから嫌だなー、と。</p>
<p>で、そこで、やはりローカルパッケージ参照です。ただし今回は<code>package.json</code>のみで、asmdefは配りません。そして<code>bin/Debug/netstandard2.0</code>(2.1でもいい)にpackage.jsonを置いて、package.jsonとpackage.json.metaのみgitの管理下に置きます。</p>
<p>実際のリポジトリ: <a href="https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0">https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0</a></p>
<p>手元のフォルダの状況:<br />
<img src="https://github.com/Cysharp/MagicOnion/assets/46207/2c8f7cb4-08ea-459c-abcc-6a251a063cb2" alt="image" /></p>
<p>これを同じようにローカルパッケージ参照すると、開発用のdllだけをUnityに引っ張ってくることができました。別にパッケージの中にソースコードがなくてもいいわけですね……！</p>
<p>なお、普通のゲーム開発でもC# 12で書きたいんだよー、という人は、ソースコード参照じゃなくてこっちのやり方を使っても成立はします。全然、アリです。ただし、.NET側でビルドしないと反映されないとか、デバッグビルドとリリースビルドどっち参照させます？とかいうところを考えなきゃいけないので、まぁお好みで、というところでしょうか。</p>
<h2>まとめ</h2>
<p>というわけで、2024年になってようやく満足いく共有手法にたどり着けました。これはC#大統一理論元年……！</p>
</div>
<h1><a href="https://neue.cc/2023/12/30_year.html">2023年を振り返る</a></h1>
<ul class="date"><li>2023-12-30</li></ul>
<div class="entry_body"><p>今年も相変わらずC#関連で色々やっていきました……！というわけなんですが、一番大きかったのはcsbindgenでしょうか。</p>
<ul>
<li><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></li>
</ul>
<p>私のスタンスとして、今までとにかくPure C#でなんとかする！という姿勢ではあったんですが、より柔軟にネイティブコードを取り入れていくという変化になりました。そのほうが、より「C#の可能性を切り開いていく」という<a href="https://cysharp.co.jp/">Cysharp</a>のミッションにも近づけているわけで、かなり良い変化をもたらせたと思っています。発展して</p>
<ul>
<li><a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html">Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</a></li>
</ul>
<p>といったような有意義なライブラリを生み出せるキッカケにもなれましたし。とはいえ改めてネイティブはネイティブで大変なのは変わらないので、C#最高、みたいな思いも強くなりましたが……！</p>
<p>私個人のスキルとしても、Rustを取り入れられるようになったのはかなり良かったことですね。Rustから学ぶことも多く、より良いC#のコードを書くことにも役立ちます。</p>
<p>OSSの後半戦ではZLogger v2は傑作だと思っています……！</p>
<ul>
<li><a href="https://neue.cc/2023/12/19_zlogger2.html">ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介</a></li>
</ul>
<p>思っているので、ちょっと普及活動頑張りたいと思っています、NLog、Serilogと同列に並んで検討対象になってくれると嬉しいのですけれどねー。まぁ、まずはReadMeから、ですが。なんとまだ工事中！よくない！</p>
<p>その他小粒の新規OSS郡もありました。</p>
<ul>
<li><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></li>
<li><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></li>
<li><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></li>
<li><a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html">UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</a></li>
</ul>
<p>こう見ると、今年もなんだかんだで色々やってはいましたね！</p>
<p>そして久々にCEDECでの発表もしてきました。</p>
<ul>
<li><a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition</a></li>
</ul>
<p>近年の総決算のつもりであったのですが、ちょっとシリアライザ的なもの(Stream)に偏りすぎではあった、かな？また5年後ぐらいには別の切り口で話せるといいかなーとは思ってます。</p>
<p>さて、ここ数年は「自称革命的なサービス（？）を来年こそはリリースする」と言い続けていたのですが、それは頓挫しました！革命的なサービスは出ない！しょーがない。csbindgenとかはそれの副産物なので、成果は無、というわけではないんですが、頓挫はやはり悲しくはあります。。。</p>
<p>そんなわけで、来年は別のネタを探しつつも、一つだけ、来年初頭というか1月の頭というか、あともう一週間ないぐらいに、大型のOSSを(プレビュー)リリースしたいと思って、ここ一ヶ月ぐらいは延々と集中してコード書いてます。かなり本気でやっているので、それは是非楽しみにしてください……！</p>
</div>
<h1><a href="https://neue.cc/2023/12/19_zlogger2.html">ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介</a></h1>
<ul class="date"><li>2023-12-19</li></ul>
<div class="entry_body"><p>C#用の新しい超高速＆低アロケーションの.NET用ロギングライブラリ、ZLogger v2を公開しました。v1からは何もかもを完全に作り替えた、最新のC#に合わせた新設計になっています。対応プラットフォームは.NET 8が最良ですが .NET Standard 2.0 以上、また Unity 2022.2 以上にも対応しています。.NET / Unityどちらもテキストメッセージと構造化ログの両方に対応しています。</p>
<ul>
<li><a href="https://github.com/Cysharp/ZLogger">Cysharp/ZLogger</a></li>
</ul>
<p>新設計のキーポイントはString Interpolationの全面採用によるクリーンなシンタックスとパフォーマンスの両立です。</p>
<pre><code class="language-csharp">logger.ZLogInformation($&quot;Hello my name is {name}, {age} years old.&quot;);
</code></pre>
<p>といったように書いたコードは</p>
<pre><code class="language-csharp">if (logger.IsEnabled(LogLvel.Information))
{
    var handler = new ZLoggerInformationInterpolatedStringHandler(30, 2, logger);
    handler.AppendLiteral(&quot;Hello my name is &quot;);
    handler.AppendFormatted&lt;string&gt;(name, 0, null, &quot;name&quot;);
    handler.AppendLiteral(&quot;, &quot;);
    handler.AppendFormatted&lt;int&gt;(age, 0, null, &quot;age&quot;);
    handler.AppendLiteral(&quot; years old.&quot;);
}
</code></pre>
<p>のようにコンパイル時に分解されます。フォーマット文字列を実行時ではなくコンパイル時に展開すること、パラメーターは<code>AppendFormatted&lt;T&gt;</code>の形でジェネリクスで受け取ることによりボクシングが発生しないなど、コードからも明らかに効率的なことが見てとれます。ちなみにコンストラクターの30は文字列の長さ、2はパラメーターの数を指していて、ここから必要な初期バッファ数を算出していることも効率化の一つに繋がっています。</p>
<p>String Interpolation自体はC# 6.0から搭載されている機能ですが、文法上同じながら<a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">C# 10.0から強化されたString Interpolation</a>が搭載されていて、カスタムのString Interpolationを提供することも可能になりました。</p>
<p>こうして得られた文字列断片とパラメーターは、最終的には<a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a>を通して文字列化せずに、直接UTF8としてStreamに書き込むことによって、高速化と低アロケーションを実現しています。</p>
<p>また、Structured Loggingにおいても、System.Text.JsonのUtf8JsonWriterとタイトに結びつくことにより</p>
<pre><code class="language-csharp">// 例えば {&quot;name&quot;:&quot;foo&quot;,age:33} のようにUtf8JsonWriterに書き込む

// Source Generator版、実際どうなってるかのイメージがとても分かりやすい。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    writer.WriteString(_jsonParameter_name, this.name);
    writer.WriteNumber(_jsonParameter_age, this.age);
}

// StringInterpolation版、ちょっと遠回りな感じですがやってることは一緒。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    for (var i = 0; i &lt; ParameterCount; i++)
    {
        ref var p = ref parameters[i];
        writer.WritePropertyName(p.Name.AsSpan());
        // MagicalBoxの説明は後述
        if (!magicalBox.TryReadTo(p.Type, p.BoxOffset, jsonWriter, jsonSerializerOptions))
        {
            // ....
        }
    }
}
</code></pre>
<p>やはり直接UTF8として書き込みます。Structured Loggingは最近のトレンドなので、色々な言語のロガーに実装されていますが、パフォーマンスを両立しつつ、ここまでクリーンなシンタックスで実現できているものは他にない！という感じなのでかなり良いのではないでしょうか。</p>
<p>では実際ベンチマーク結果でどれぐらい？というと、アロケーションは少なくとも圧倒的です。</p>
<p><img src="https://github.com/Cysharp/ZLogger/assets/46207/ab9c1f8b-a3b4-44fc-86aa-ba8dd6bdbe40" alt="image" /></p>
<p>アロケーションは、という歯切れの悪い言い方をしているのは、念入りに高速になるよう設定したNLogが思ったよりも速かったせいですね、ぐぬぬ……。</p>
<p>さて、ZLoggerの特徴のもう一つは、<a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logging">Microsoft.Extensions.Logging</a>の上に直接構築していることです。通常のロガーは独自のシステムを持っていて、Microsoft.Extensions.Loggingと繋げる場合はブリッジを通します。現実的なアプリケーションでは ASP .NETを使う場合などMicrosoft.Extensions.Loggingを避けることはほぼ不可能です。.NET 8からはOpenTelemetry対応の強化や<a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview">Aspire</a>など、ますますMicrosoft.Extensions.Loggingの重要性は増しています。ZLogger v1と異なり、v2ではScopeなど、Microsoft.Extensions.Loggingの全機能に対応しています。</p>
<p>そして例えばSerilogのブリッジライブラリの品質は（ソースコードも確認しましたが）かなり低く、実際のパフォーマンスの数字にも現れています。ZLoggerはそうしたオーバーヘッドが一切かかりません。</p>
<p>また、デフォルトの設定も非常に重要です。ほとんどのロガーの標準設定は、例えばファイルストリームに書く場合は都度Flushするなど、かなり遅い設定が標準になっています。それを高速化するにはasync, bufferedを適切に調整する必要があり、かつ、取りこぼさないように終了時に確実にFlushさせる必要があるのですが、かなり難しいので、ほとんど標準設定のままの人も多いのではないでしょうか？ZLoggerではデフォルトで最高速になるように調整してあり、かつ、Microsoft.ExtensionsのDIのライフサイクルで最後のFlushも自動でかかるようになっているので、ApplicationBuilderなどでアプリケーションを構築した場合は何も意識しなくても取りこぼしは発生しません。</p>
<p>なお、都度Flushのパフォーマンスはストレージの書き込み性能に強く依存するため、例えば最近のマシンのM.2 SSDは非常に高速なため、ローカルでベンチマークすると意外と遅くない、といったことを確認できるかもしれません。ただし、実際にアプリケーションを配置する、例えばクラウドサーバーのストレージ性能がそこまで高いことはないので、ローカルでの結果を過信しないほうがいいでしょう。</p>
<h2>MagicalBox</h2>
<p>ここからは、パフォーマンスを実現した幾つかのトリックを紹介します。v1から引き継いでいるのは<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>を活用したasyncな非同期書き込みプロセスの作成と、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.ibufferwriter-1"><code>IBufferWriter&lt;byte&gt;</code></a>による効率的なbufferedの利用による、Streamへの書き込み最適化ですが、説明は割愛します。</p>
<p>JSON化のために、パラメーターはInterpolatedStringHandlerで、一時的に値として保持します。その場合に、<code>&lt;T&gt;</code>の値をどのように保持するか、という問題がでてきます。普通に考えると、<code>List&lt;object&gt;</code>といったようなobject型で保持することになります。</p>
<pre><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // あらゆる&lt;T&gt;の型を格納するためにobjectを使う、ボクシングが発生するので良くはない。
    List&lt;object&gt; parameters = new ();

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&quot;value&quot;)] string? argumentName = null)
    {
        parameters.Add((object)value);
    }
}
</code></pre>
<p>それを避けるために、ZLoggerではMagicalBoxという仕組みを用意しました。</p>
<pre><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // 魔法の箱に無限に詰め込む
    MagicalBox magicalBox;
    List&lt;int&gt; boxOffsets = new (); // 実際はこの辺は入念にキャッシュされています

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&quot;value&quot;)] string? argumentName = null)
    {
        if(magicalBox.TryWrite(value, out var offset)) // boxingが発生しない！
        {
            boxOffsets.Add(offset);
        }
    }
}
</code></pre>
<p>MagicalBoxはどんな型(unmanaged型に限る)でも、ボクシングなしに書き込むことができる。というコンセプトで、その実態は<code>byte[]</code>にUnsafe.Write、offsetを元にUnsafe.Readするというだけの代物です。</p>
<pre><code class="language-csharp">internal unsafe partial struct MagicalBox
{
    byte[] storage;
    int written;

    public MagicalBox(byte[] storage)
    {
        this.storage = storage;
    }

    public bool TryWrite&lt;T&gt;(T value, out int offset)
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
        {
            offset = 0;
            return false;
        }

        Unsafe.WriteUnaligned(ref storage[written], value);
        offset = written;
        written += Unsafe.SizeOf&lt;T&gt;();
        return true;
    }

    public bool TryRead&lt;T&gt;(int offset, out T value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
        {
            value = default!;
            return false;
        }

        value = Unsafe.ReadUnaligned&lt;T&gt;(ref storage[offset]);
        return true;
    }
}
</code></pre>
<p>この辺は<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での実装経験が元になっていて、うまく機能しています。</p>
<p>なお、実際のコードでは<code>byte[] storage</code>の効率的な再利用や非ジェネリクスなRead対応、Enumへの特別対応が入ったりなど、もう少し<a href="https://github.com/Cysharp/ZLogger/blob/ccc3b0e6/src/ZLogger/Internal/MagicalBox.cs">複雑なコード</a>になってはいます。さすがに。</p>
<h2>カスタムフォーマット文字列</h2>
<p>ZLoggerのString Interpolationのいいところは、パラメーター値にメソッド呼び出しを含めると、LogLevelのチェックが入った後に呼び出されるので無駄な実行を防げるところです。</p>
<pre><code class="language-csharp">// これは
logger.ZLogDebug($&quot;Id {obj.GetId()}: Data: {obj.GetData()}.&quot;);

// このようにLogLevelが有効かどうかチェックした後にメソッドが呼ばれる
if (logger.IsEnabled(LogLvel.Debug))
{
    // snip...
    writer.AppendFormatterd(obj.GetId());
    writer.AppendFormatterd(obj.GetData());
}
</code></pre>
<p>しかし、メソッド呼び出しをStructured Loggingに出力した場合、ZLoggerはC# 10.0以降から追加された<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.compilerservices.callerargumentexpressionattribute?view=net-8.0">CallerArgumentExpression</a>でパラメーター名を取得しているため、メソッド呼び出しの場合は &quot;obj.GetId()&quot; という微妙極まりない名前で出力されてしまいます。そこで、特殊なカスタムフォーマット文字列で別名を指定することができます。</p>
<pre><code class="language-csharp">// @name で別名を付けられる
logger.ZLogDebug($&quot;Id {obj.GetId():@id}: Data: {obj.GetData():@data}.&quot;);
</code></pre>
<p>ZLoggerでは、String Interpolationの本来の式に従って、&quot;,&quot;でアラインメント、&quot;:&quot;でフォーマット文字列を指定することができます。それに加えて特殊な指定として、フォーマット文字列を@から始めた場合はパラメーター名として出力します。</p>
<p>@によるパラメーター名指定とフォーマット文字列は併用することができます。</p>
<pre><code class="language-csharp">// Today is 2023-12-19.
// {&quot;date&quot;:&quot;2023-12-19T11:25:34.3642389+09:00&quot;}
logger.ZLogDebug($&quot;Today is {DateTime.Now:@date:yyyy-MM-dd}.&quot;);
</code></pre>
<p>もう一つ、共通の特殊なフォーマット文字列として&quot;json&quot;を指定するとJsonSerializeした形で出力できます（この辺はSerilogの持つ機能からインスパイアされました）</p>
<pre><code class="language-csharp">var position = new { Latitude = 25, Longitude = 134 };
var elapsed = 34;

// {&quot;position&quot;:{&quot;Latitude&quot;:25,&quot;Longitude&quot;:134},&quot;elapsed&quot;:34}
// Processed {&quot;Latitude&quot;:25,&quot;Longitude&quot;:134} in 034 ms.
logger.ZLogInformation($&quot;Processed {position:json} in {elapsed:000} ms.&quot;);
</code></pre>
<p>特殊フォーマット文字列は、例えばログレベルやカテゴリー、日付を先頭/末尾に付与するためのPrefixFormatter/SuffixFormatterにも幾つか用意してあります。</p>
<pre><code class="language-csharp">logging.AddZLoggerConsole(options =&gt;
{
    options.UsePlainTextFormatter(formatter =&gt;
    {
        // 2023-12-19 02:46:14.289 [DBG]......
        formatter.SetPrefixFormatter($&quot;{0:utc-longdate} [{1:short}]&quot;, (template, info) =&gt; template.Format(info.Timestamp, info.LogLevel));
    });
});
</code></pre>
<p>Timestampには<code>longdate</code>, <code>utc-longdate</code>, <code>dateonly</code>など。LogLevelには<code>short</code>で3文字ログレベル表記(先頭の長さが一致するのでエディタで開いた時に読みやすくなる)へと変換されます。これら組み込みの特殊フォーマット文字列は、パフォーマンス最適化という意味合いもあります。例えばLogLevelは以下のようなコードになっているので、手で書式を作るよりも、事前組み込みのUTF8文字列で書き込むことで、絶対的に効率がよくなっています。</p>
<pre><code class="language-csharp">static void AppendLogLevel(ref Utf8StringWriter&lt;IBufferWriter&lt;byte&gt;&gt; writer, ref LogLevel value, ref MessageTemplateChunk chunk)
{
    if (!chunk.NoAlignmentAndFormat)
    {
        if (chunk.Format == &quot;short&quot;)
        {
            switch (value)
            {
                case LogLevel.Trace:
                    writer.AppendUtf8(&quot;TRC&quot;u8);
                    return;
                case LogLevel.Debug:
                    writer.AppendUtf8(&quot;DBG&quot;u8);
                    return;
                case LogLevel.Information:
                    writer.AppendUtf8(&quot;INF&quot;u8);
                    return;
                case LogLevel.Warning:
                    writer.AppendUtf8(&quot;WRN&quot;u8);
                    return;
                case LogLevel.Error:
                    writer.AppendUtf8(&quot;ERR&quot;u8);
                    return;
                case LogLevel.Critical:
                    writer.AppendUtf8(&quot;CRI&quot;u8);
                    return;
                case LogLevel.None:
                    writer.AppendUtf8(&quot;NON&quot;u8);
                    return;
                default:
                    break;
            }
        }

        writer.AppendFormatted(value, chunk.Alignment, chunk.Format);
        return;
    }

    switch (value)
    {
        case LogLevel.Trace:
            writer.AppendUtf8(&quot;Trace&quot;u8);
            break;
        case LogLevel.Debug:
            writer.AppendUtf8(&quot;Debug&quot;u8);
            break;
        case LogLevel.Information:
            writer.AppendUtf8(&quot;Information&quot;u8);
            break;
        case LogLevel.Warning:
            writer.AppendUtf8(&quot;Warning&quot;u8);
            break;
        case LogLevel.Error:
            writer.AppendUtf8(&quot;Error&quot;u8);
            break;
        case LogLevel.Critical:
            writer.AppendUtf8(&quot;Critical&quot;u8);
            break;
        case LogLevel.None:
            writer.AppendUtf8(&quot;None&quot;u8);
            break;
        default:
            writer.AppendFormatted(value);
            break;
    }
}
</code></pre>
<h2>.NET 8 XxHash3 + Non-GC Heap</h2>
<p>.NET 8から<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3">XxHash3</a>が追加されました。最速のハッシュアルゴリズムである<a href="https://github.com/Cyan4973/xxHash/">XxHash</a>の最新シリーズで、小さいデータから大きいデータまで、迷ったらほぼこれ一択で問題ないだろうという性能になっています。なお、利用にはNuGetから<code>System.IO.Hashing</code>が必要なので、逆に.NET 8ではなくNET Standard 2.0でも使えます。</p>
<p>ZLoggerでも複数箇所で使っているのですが、その中から一例として、String Interpolationの文字列リテラルからキャッシュを取り出す処理の例を。</p>
<pre><code class="language-csharp">// $&quot;Hello my name is {name}, {age} years old.&quot; が生成する文字列リテラルの並び(LiteralList)
// [&quot;Hello my name is &quot;, &quot;name&quot;, &quot;, &quot;, &quot;age&quot;, &quot; years old.&quot;]
// これからUTF8変換済みのキャッシュ(MessageSequence)を取り出すという処理
static readonly ConcurrentDictionary&lt;LiteralList, MessageSequence&gt; cache = new();

// 非.NET 8版
#if !NET8_0_OR_GREATER

struct LiteralList(List&lt;string?&gt; literals) : IEquatable&lt;LiteralList&gt;
{
    [ThreadStatic]
    static XxHash3? xxhash;

    public override int GetHashCode()
    {
        var h = xxhash;
        if (h == null)
        {
            h = xxhash = new XxHash3();
        }
        else
        {
            h.Reset();
        }

        var span = CollectionsMarshal.AsSpan(literals);
        foreach (var item in span)
        {
            h.Append(MemoryMarshal.AsBytes(item.AsSpan()));
        }

        // https://github.com/Cyan4973/xxHash/issues/453
        // XXH3 64bit -&gt; 32bit, okay to simple cast answered by XXH3 author.
        return unchecked((int)h.GetCurrentHashAsUInt64());
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        if (xs.Length == ys.Length)
        {
            for (int i = 0; i &lt; xs.Length; i++)
            {
                if (xs[i] != ys[i]) return false;
            }
            return true;
        }

        return false;
    }
}

#endif
</code></pre>
<p>XxHash3はclassなので(<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.hashcode?view=net-8.0">System.HashCode</a>みたいにstructが良かったなあ)、ThreadStaticで使いまわしつつ、GetHashCodeを生成しています。XxHash3はulongの出力しかありませんが、作者によると、32bitに落とす場合は特にXORとかかけることもなく直接落として問題ないそうです。</p>
<p>ここまでが普通の使い方ですが、.NET 8版ではエクストリームな最適化を入れました。</p>
<pre><code class="language-csharp">#if NET8_0_OR_GREATER

struct LiteralList(List&lt;string?&gt; literals) : IEquatable&lt;LiteralList&gt;
{
    // literals are all const string, in .NET 8 it is allocated in Non-GC Heap so can compare by address.
    // https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#non-gc-heap
    static ReadOnlySpan&lt;byte&gt; AsBytes(ReadOnlySpan&lt;string?&gt; literals)
    {
        return MemoryMarshal.CreateSpan(
            ref Unsafe.As&lt;string?, byte&gt;(ref MemoryMarshal.GetReference(literals)),
            literals.Length * Unsafe.SizeOf&lt;string&gt;());
    }

    public override int GetHashCode()
    {
        return unchecked((int)XxHash3.HashToUInt64(AsBytes(CollectionsMarshal.AsSpan(literals))));
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        return AsBytes(xs).SequenceEqual(AsBytes(ys));
    }
}

#endif
</code></pre>
<p><code>List&lt;string&gt;?</code>を<code>ReadOnlySpan&lt;byte&gt;</code>に変換して、それでXxHash3.HashToUInt64やSeqeunceEqualを一発で呼んでます。見るからにこちらのほうが効率的なわけですが、しかし、そもそも<code>List&lt;string&gt;?</code>を<code>ReadOnlySpan&lt;byte&gt;</code>に変換するのは合法なのか？と。この場合のstringの変換は、<code>ReadOnlySpan&lt;IntPtr&gt;</code>への変換という意味合いで、つまりヒープにあるstringのアドレスのリストへと変換しているという意図になります。</p>
<p>そこまではいいとして、問題はアドレスの比較は危険すぎないか、ということです。まず第一に、stringは文字列として同一であっても実態は別のアドレスにある場合も多い。第二に、ヒープにあるstringのアドレスは固定されていない、移動することがあるということです。辞書のキーとしてGetHashCodeやEqualsを求めるなら、アプリケーション実行中は完全に固定されていなければなりません。</p>
<p>ところが今回の利用例に着目すると、String Inteprolationで呼ばれるAppendLiteralはコンパイル時に <code>handler.AppendLiteral(&quot;Hello my name is &quot;);</code> のように、必ず定数で渡されています。そのため同じ実体を指すことが保証されています。</p>
<pre><code class="language-csharp">[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    public void AppendLiteral([ConstantExpected] string s)
}
</code></pre>
<p>一応保険として、.NET 8から有効化されている<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.codeanalysis.constantexpectedattribute?view=net-8.0">ConstantExpected</a>によって、定数だけが渡されることを明示しています。</p>
<p>もう一つは、そうした定数の文字列は最初からインターン化されているのですが、そのインターン化された場所が移動しないことは.NET 8まで保証されていませんでした。ところが、.NET 8からはNon-GC Heapが導入されたため、移動しないことが保証されている、といえます。</p>
<pre><code class="language-csharp">// .NET 8からは定数のGC.GetGenerationの結果がint.MaxValue(Non-GC Heapにいる)
var str = &quot;foo&quot;;
Console.WriteLine(GC.GetGeneration(str)); // 2147483647
</code></pre>
<p>これによって、C#だとどうしても避けられないUTF16 StringからUTF8 Stringへの変換を、限界まで高速化することができました。なお、Source Generator版ではこのルックアップコスト自体を削れているため、ベンチマーク結果が最速であった通り、より高速です。</p>
<h2>.NET 8 IUtf8SpanFormattable</h2>
<p>ZLoggerでは値を文字列を通さずUTF8に直接書き込むことをパフォーマンスの柱にしています。.NET 8から<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0">IUtf8SpanFormattable</a>という、値の汎用的なUTF8への直接変換を可能にしたインターフェイスが追加されました。ZLoggerは.NET 8以前の.NET Standard 2.0にも対応させるために、intやdoubleなど基本的なプリミティブは特殊な対応によって、UTF8への直接書き込みを実現していますが、.NET 8の場合は対応範囲がより広がるため、できれば.NET 8がお薦めです。</p>
<p>なお、IUtf8SpanFormattableはフォーマット文字列のalignmentには関知しないため、分離しているライブラリである<a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a>では.NET Standard 2.0対応と同時に、alignment対応の機能も追加されたライブラリとなっています。</p>
<h2>.NET 8 TimeProvider</h2>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0">TimeProvider</a>は.NET 8から追加された時間に関するAPIの抽象化(TimeZone, Timerなども含む)となっていて、ユニットテスト等でも非常に役に立つ、今後の必須クラスです。TimeProviderは.NET 8未満でも<a href="https://www.nuget.org/packages/Microsoft.Bcl.TimeProvider/">Microsoft.Bcl.TimeProvider</a>を通して提供されているため、.NET Standard 2.0やUnityでも利用可能です。</p>
<p>そこでZLoggerではZLoggerOptionsにTimerProviderを指定することで、ログ出力の時間を固定することができます。</p>
<pre><code class="language-csharp">// Microsoft.Extensions.TimeProvider.TestingのFakeTimeProviderを使うとよりよい
class FakeTime : TimeProvider
{
    public override DateTimeOffset GetUtcNow()
    {
        return new DateTimeOffset(1999, 12, 30, 11, 12, 33, TimeSpan.Zero);
    }

    public override TimeZoneInfo LocalTimeZone =&gt; TimeZoneInfo.Utc;
}

public class TimestampTest
{
    [Fact]
    public void LogInfoTimestamp()
    {
        var result = new List&lt;string&gt;();
        using var factory = LoggerFactory.Create(builder =&gt;
        {
            builder.AddZLoggerInMemory((options, _) =&gt;
            {
                options.TimeProvider = new FakeTime(); // TimeProviderをカスタムのものに設定
                options.UsePlainTextFormatter(formatter =&gt;
                {
                    // Timestampを先頭に付与
                    formatter.SetPrefixFormatter($&quot;{0} | &quot;, (template, info) =&gt; template.Format(info.Timestamp));
                });
            }, x =&gt;
            {
                x.MessageReceived += msg =&gt; result.Add(msg);
            });
        });

        var logger = factory.CreateLogger&lt;TimestampTest&gt;();
        logger.ZLogInformation($&quot;Foo&quot;);

        Assert.Equal(&quot;1999-12-30 11:12:33.000 | Foo&quot;, result[0]);
    }
}
</code></pre>
<p>ログ出力の完全一致でのテストが必要……！などといった場合に有効に使うことができます。</p>
<h2>Source Generator</h2>
<p>Microsoft.Extensions.Loggingではハイパフォーマンスなログ出力のために<a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logger-message-generator">LoggerMessageAttribute</a>とSource Generatorが標準で提供されています。</p>
<p>これは確かにUTF16文字列の生成では非常に優秀ですが、Structured Logging生成部分に関しては疑問符がつきます。</p>
<pre><code class="language-csharp">// このpartial methodは
[LoggerMessage(LogLevel.Information, &quot;My name is {name}, age is {age}.&quot;)]
public static partial void MSLog(this ILogger logger, string name, int age, int other);

// このクラスを生成する
private readonly struct __MSLogStruct : global::System.Collections.Generic.IReadOnlyList&lt;global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;&gt;
{
    private readonly global::System.String _name;
    private readonly global::System.Int32 _age;

    public __MSLogStruct(global::System.String name, global::System.Int32 age)
    {
        this._name = name;
        this._age = age;
    }

    public override string ToString()
    {
        var name = this._name;
        var age = this._age;

        return $&quot;My name is {name}, age is {age}.&quot;; // 文字列生成は高速そう（C# 10.0のString Interpolation Improvementsにベタ乗りなので言うことなし！）
    }

    public static readonly global::System.Func&lt;__MSLogStruct, global::System.Exception?, string&gt; Format = (state, ex) =&gt; state.ToString();

    public int Count =&gt; 4;

    // こちらがStrcuted Loggingのコードですが、ん……？
    public global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt; this[int index]
    {
        get =&gt; index switch
        {
            0 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;name&quot;, this._name),
            1 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;age&quot;, this._age),
            2 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;other&quot;, this._other),
            3 =&gt; new global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;(&quot;{OriginalFormat}&quot;, &quot;My name is {name}, age is {age}.&quot;),

            _ =&gt; throw new global::System.IndexOutOfRangeException(nameof(index)),  // return the same exception LoggerMessage.Define returns in this case
        };
    }

    public global::System.Collections.Generic.IEnumerator&lt;global::System.Collections.Generic.KeyValuePair&lt;string, object?&gt;&gt; GetEnumerator()
    {
        for (int i = 0; i &lt; 4; i++)
        {
            yield return this[i];
        }
    }

    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}

[global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Extensions.Logging.Generators&quot;, &quot;8.0.9.3103&quot;)]
public static partial void MSLog(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.String name, global::System.Int32 age)
{
    if (logger.IsEnabled(global::Microsoft.Extensions.Logging.LogLevel.Information))
    {
        logger.Log(
            global::Microsoft.Extensions.Logging.LogLevel.Information,
            new global::Microsoft.Extensions.Logging.EventId(764917357, nameof(MSLog)),
            new __MSLogStruct(name, age),
            null,
            __MSLogStruct.Format);
    }
}
</code></pre>
<p><code>KeyValuePair&lt;string, object?&gt;</code> ということで、基本的に普通に作るとボクシングは避けられません、しょーがない。</p>
<p>そこで、ZLoggerでは似たようなSource Generator属性である<code>ZLoggerMessageAttribute</code>を提供しています。これにより、UTF8最適化、ボクシングレスなJSONロギングを可能にしています。</p>
<pre><code class="language-csharp">// LoggerMessageをZLoggerMessageに変えるだけ
// なお、ZLoggerMessageのフォーマット文字列部分では、String Interpolation版と同じように@による別名やjsonによるJSON化も可能
[ZLoggerMessage(LogLevel.Information, &quot;My name is {name}, age is {age}.&quot;)]
static partial void ZLoggerLog(this ILogger logger, string name, int age);

// このようなコードが生成される
readonly struct ZLoggerLogState : IZLoggerFormattable
{
    // JSON用にJsonEncodedTextを事前生成
    static readonly JsonEncodedText _jsonParameter_name = JsonEncodedText.Encode(&quot;name&quot;);
    static readonly JsonEncodedText _jsonParameter_age = JsonEncodedText.Encode(&quot;age&quot;);

    readonly string name;
    readonly int age;

    public ZLoggerLogState(string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public IZLoggerEntry CreateEntry(LogInfo info)
    {
        return ZLoggerEntry&lt;ZLoggerLogState&gt;.Create(info, this);
    }
    
    public int ParameterCount =&gt; 2;
    public bool IsSupportUtf8ParameterKey =&gt; true;
    public override string ToString() =&gt; $&quot;My name is {name}, age is {age}.&quot;;

    // テキストメッセージはUTF8への直接書き込み
    public void ToString(IBufferWriter&lt;byte&gt; writer)
    {
        var stringWriter = new Utf8StringWriter&lt;IBufferWriter&lt;byte&gt;&gt;(literalLength: 21, formattedCount: 2, bufferWriter: writer);

        stringWriter.AppendUtf8(&quot;My name is &quot;u8); // u8でリテラルは直接書き込み
        stringWriter.AppendFormatted(name, 0, null);
        stringWriter.AppendUtf8(&quot;, age is &quot;u8);
        stringWriter.AppendFormatted(age, 0, null);
        stringWriter.AppendUtf8(&quot;.&quot;u8);            

        stringWriter.Flush();
    }

    // JSON出力の場合はUtf8JsonWriterに直接書き込むことで完全にボクシング避け
    public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null)
    {
        // 型によって呼び出すメソッドは異なる(WriteString, WriteNumber, etc...)
        writer.WriteString(_jsonParameter_name, this.name);
        writer.WriteNumber(_jsonParameter_age, this.age);
    }

    // 以下にMessagePack対応などの拡張用のメソッドが実際には生成されますが省略
} 

static partial void ZLoggerLog(this global::Microsoft.Extensions.Logging.ILogger logger, string name, int age)
{
    if (!logger.IsEnabled(LogLevel.Information)) return;
    logger.Log(
        LogLevel.Information,
        new EventId(-1, nameof(ZLoggerLog)),
        new ZLoggerLogState(name, age),
        null,
        (state, ex) =&gt; state.ToString()
    );
}
</code></pre>
<p>Utf8JsonWriterに直接書く、また、キー名はJsonEncodedTextを事前に生成して持っておく、という仕様によってJSON化のパフォーマンスを最大化しています。</p>
<p>また、Structured LoggingはJSONに限らず他のフォーマットもありえます。例えばMessagePackを利用することで、より小さく、より高速にすることができるでしょう。ZLoggerでは、そうしたJSON特化のようなビルトインではないプロトコルへの出力においてもボクシングを避けるためのインターフェイスが定義されています。</p>
<pre><code class="language-csharp">public interface IZLoggerFormattable : IZLoggerEntryCreatable
{
    int ParameterCount { get; }

    // メッセージ出力に使う
    void ToString(IBufferWriter&lt;byte&gt; writer);

    // JSON出力に使う
    void WriteJsonParameterKeyValues(Utf8JsonWriter jsonWriter, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null);

    // それ以外の構造化ログ出力に使う
    ReadOnlySpan&lt;byte&gt; GetParameterKey(int index);
    ReadOnlySpan&lt;char&gt; GetParameterKeyAsString(int index);
    object? GetParameterValue(int index);
    T? GetParameterValue&lt;T&gt;(int index);
    Type GetParameterType(int index);
}
</code></pre>
<p>ちょっと変わったインターフェイスになっていますが、以下のようなループを回すことでボクシングの発生をなくせます。</p>
<pre><code class="language-csharp">for (var i in ParameterCount)
{
    var key = GetParameterKey(i);
    var value = GetParameterValue&lt;int&gt;();
}
</code></pre>
<p>こうした設計はADO.NETのIDataRecordの使い方と同じ設計です。また、Unityでもネイティブ→マネージドでの配列のアロケーションを避けるために、インデックス経由で取得することがよくあります。</p>
<h2>Unity</h2>
<p>UnityはUnity 2023の時点でも正式な対応C#のバージョンは9.0です。ZLoggerはC# 10.0以上のString Interpolationが大前提となっているので、普通は動きません。普通は。ところが、正式にアナウンスはされていないのですが <code>Unity 2022.2</code> から同梱されているコンパイラのバージョンが上がっていて、内部的にはC# 10.0でコンパイル可能になっていることを発見しました。</p>
<p><code>csc.rsp</code> ファイルによってコンパイラオプションを渡すことができるので、そこで明示的に言語バージョンを指定してあげると、C# 10.0の全ての文法が利用可能になります。</p>
<pre><code class="language-csharp">-langVersion:10
</code></pre>
<p>このままだと出力されるcsprojには依然として<code>&lt;LangVersion&gt;9.0&lt;/LangVersion&gt;</code>が指定されているため、IDE上ではC# 10.0で書けません。そこで<a href="https://github.com/Cysharp/CsprojModifier">Cysharp/CsprojModifier</a>を用いて、LangVersionを上書きしてしまいましょう。以下のような<code>LangVersion.props</code>というファイルを作成して、CsprojModifierに混ぜてもらえば、IDE上でもC# 10.0として記述できるようになります。</p>
<pre><code class="language-xml">&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;LangVersion&gt;10&lt;/LangVersion&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>Unity向けには<code>AddZLoggerUnityDebug</code>という拡張を追加してあるので、</p>
<pre><code class="language-csharp">// こんなグローバルのユーティリティーを用意してあげて
public static class LogManager
{
    static ILoggerFactory loggerFactory;

    public static ILogger&lt;T&gt; CreateLogger&lt;T&gt;() =&gt; loggerFactory.CreateLogger&lt;T&gt;();
    public static readonly Microsoft.Extensions.Logging.ILogger Global;

    static LogManager()
    {
        loggerFactory = LoggerFactory.Create(logging =&gt;
        {
            logging.SetMinimumLevel(LogLevel.Trace);
            logging.AddZLoggerUnityDebug(); // log to UnityDebug
        });
        Global = loggerFactory.CreateLogger(&quot;Logger&quot;);

        Application.exitCancellationToken.Register(() =&gt;
        {
            loggerFactory.Dispose(); // flush when application exit.
        });
    }
}

// 例えばこんな感じに使ってみる
public class NewBehaviourScript : MonoBehaviour
{
    static readonly ILogger&lt;NewBehaviourScript&gt; logger = LogManager.CreateLogger&lt;NewBehaviourScript&gt;();

    void Start()
    {
        var name = &quot;foo&quot;;
        var hp = 100;
        logger.ZLogInformation($&quot;{name} HP is {hp}.&quot;);
    }
}
</code></pre>
<blockquote>
<p>なお、C# 10.0のString Interpolation性能向上の恩恵を受けれるのはZLogを使った場合のみの話で、通常のString生成にString Interpolationを使っても性能向上はしません。string生成の性能向上にはランタイムにDefaultInterpolatedStringHandlerが必要で、これは .NET 6 以上にのみ同梱されているからです。DefaultInterpolatedStringHandlerが存在しない場合は今まで通りのstring.Formatにフォールバックされるため、普通にボクシングされます。</p>
</blockquote>
<p>JSONによる構造化ログや出力のカスタマイズ、ファイルへの出力などにも全て対応しています。</p>
<pre><code class="language-csharp">var loggerFactory = LoggerFactory.Create(logging =&gt;
{
    logging.AddZLoggerFile(&quot;/path/to/logfile&quot;, options =&gt;
    {
        options.UseJsonFormatter();
    });
});
</code></pre>
<p>そしてもう一つボーナスとして、<code>Unity 2022.3.12f1</code> 以上だとC#のコンパイラバージョンがもう少し上がっていて、<code>-langVersion:preview</code>を指定するとC# 11.0が使えます。また、ZLoggerのSource Generatorが自動で有効になっているので、<code>[ZLoggerMessage]</code>を使って生成することができます。</p>
<pre><code class="language-csharp">public static partial class LogExtensions
{
    [ZLoggerMessage(LogLevel.Debug, &quot;Hello, {name}&quot;)]
    public static partial void Hello(this ILogger&lt;NewBehaviourScript&gt; logger, string name);
}
</code></pre>
<p>Source Generatorの生成するコードがC# 11.0を要求するので(UTF8 String Literalなどを多用しているため)、<code>[ZLoggerMessage]</code>が使えるのは<code>Unity 2022.3.12f1</code> 以上限定となります。</p>
<p>なお、Unityには同種の標準ロギングライブラリとして<a href="https://docs.unity3d.com/Packages/com.unity.logging@1.2/manual/index.html">com.unity.logging</a>がリリースされています。同じように構造化ロギングやファイル出力が可能なほか、Source Generatorを使ってクラスそのものを自動生成して、メソッドのオーバーロードを引数に応じて生成することで値のボクシング避けをするといった、面白い設計をしていました。Burst云々という話がよく出てきますが、このSource Generatorの大胆な使い方のほうがパフォーマンスの肝だと思います。ZLoggerはC# 10.0のString Interpolationを活用しているわけですが、そういうアプローチでの回避策というのはちょっと考えたことがなかったので、かなり目から鱗です。パフォーマンス的にもかなり練られています。</p>
<p>ZLoggerのほうがString Interpolationによる書き味は上、パフォーマンスは、まぁいい勝負するんじゃないかなとは思いたいんですが、どうでしょうね……？</p>
<h2>NuGetForUnity</h2>
<p>今回Unityへのライブラリの配布は<a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a>を採用しました。これは普通の.NETライブラリへの依存が多いものへの配布に非常に便利で、NuGetForUnityを入れたあとに、GUIでZLoggerをこうして入れると</p>
<p><img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/5ce038b8-85be-4bed-97ec-17aec260fa84" alt="image" /></p>
<p>こんなように依存関係も解決して、Assets/Packagesの下にDLLがばらまかれます。</p>
<p><img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/62a71516-874e-4bc2-bc75-29bf0fac9dd8" alt="image" /></p>
<p>Source Generatorが含まれている場合は、ちゃんと<code>RoslynAnalyzer</code>のラベルも付与してくれるので、そのままSource GeneratorもUnity上で有効化されています。</p>
<p>良い点としては、やはり大量のマネージドDLLの管理を一括でやってくれることと、動作がシンプル（基本的には解決したファイルをAssets/Packagesにばらまくだけ)なのでやっていることがイメージつきやすいところです。同じようなツールとして<a href="https://github.com/xoofx/unitynuget">UnityNuGet</a>というものがあるのですが、そちらは独自レジストリに配布しているファイルを引っ張ってくるという作りなので、NuGetForUnity(MS公式のNuGetのレジストリから引っ張ってくる)のほうが素直な挙動で好ましく思います。</p>
<p>反面、UnityEngine.dllに依存したコードやUnityのバージョンで分岐するコードは配りにくいところがあります。ZLoggerではそのためのファイル(ZLoggerUnityDebugLoggerProvider)は別途git参照で引っ張ってくるハイブリッド方式での配布としました。かなりバランスの良いやり方かなと思うんですがどうでしょう……？特にCysharpのライブラリはコア部分はUnity非依存のものが多いので、問題なければ今後のCysharpのライブラリはこの形式での配布を基本としていきたいところです。</p>
<p>ライブラリ作者側としては、コア部分はDLLで配ることになるのでC# 12のままで良い（今まではUnityのためにC# 9にダウングレードさせて書いたりしてた）のが、とにかくとても楽ですね……！</p>
<h2>まとめ</h2>
<p>この記事は<a href="https://qiita.com/advent-calendar/2023/csharplang">C# Advent Calendar 2023</a>の12月3日分の記事となります。すごい遅刻ですが間に合ったので（？）よし。よくない。</p>
<p>なお、ZLogger v2の作成にあたっては <a href="https://github.com/hadashiA/VContainer">VContainer</a> や <a href="https://github.com/hadashiA/VYaml">VYaml</a> で有名な <a href="https://twitter.com/hadashiA">@hadashiA</a> さんに、アイディア出しから細かい実装、度重なる仕様のちゃぶ台返しに付き合ってもらいました。今回のv2は非常に完成度高くなったと思うのですが、自分一人ではここまで達しなかったので大変感謝です。</p>
<p>ともあれZLoggerは使いやすさでもパフォーマンスでも最強！のロガーに仕上がったと思いますので、是非使ってみてください。</p>
</div>
<h1><a href="https://neue.cc/2023/10/23_rusttokyo.html">他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例</a></h1>
<ul class="date"><li>2023-10-23</li></ul>
<div class="entry_body"><p><a href="https://rust.tokyo/2023">Rust.Tokyo 2023</a>というRustのカンファレンスで、「他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例」と題して<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>周りの話をしてきました。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/fca414aeffb9486ab2f738466df6da02" title="他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>タイトルが若干かなり回りっくどい雰囲気になってしまいましたが、Rustのカンファレンスということで、あまりC#に寄り過ぎないように、という意識があったのですが、どうでしょう……？</p>
<p>会場での質問含めて何点かフォローアップを。</p>
<h2>FFIとパフォーマンス</h2>
<p>Rustは速い！FFIは速い！ということが常に当てはまるわけでもなく、例えばGoのcgoはかなり遅いという話があったりします。<a href="https://speakerdeck.com/filosottile/why-cgo-is-slow-at-capitalgo-2018">Why cgo is slow @ CapitalGo 2018</a>。このことは直近のRustのasyncの話<a href="https://without.boats/blog/why-async-rust/">Why async Rust?</a>でも触れられていて、cgoの遅さはGoroutine(Green Thread)が影響を及ぼしているところもある、とされています。.NET でも<a href="https://github.com/dotnet/runtimelab/blob/bec51070f1071d83f686be347d160ea864828ef8/docs/design/features/greenthreads.md">Green Threadを実験的に実装してみたというレポート</a>がついこないだ出ていたのですが、FFIの問題とか、まぁ諸々あってasync/awaitでいいじゃろ、という結論になっています。技術はなんでもトレードオフなので、過剰にGreen Threadを持ち上げるのもどうかな、とは思いますね。</p>
<p>で、C#のFFI速度ですが、こちらの<a href="https://vancan1ty.com/blog/post/52">Testing FFI Hot Loop Overhead - Java, C#, PHP, and Go</a>という記事での比較ではFFIにおいては圧勝ということになっているので、まぁ、実際C#のFFIは速いほうということでいいんじゃないでしょーか（昔からWin32 APIを何かと叩く必要があったりとかいう事情もありますし）。</p>
<p>とはいえ、原則Pure C#実装のほうがいいなあ、という気持ちはめっちゃあります。パフォーマンスのためのネイティブライブラリ採用というのは、本当に限定的な局面だけではありますね。そんなわけで、その限定的な局面であるところのコンプレッションライブラリを鋭意開発中です、来月に乞うご期待。</p>
<h2>Zig, C++</h2>
<p>FFI目的でunsafeなRust中心になるぐらいなら<a href="https://ziglang.org/ja/">Zig</a>のほうがいいんじゃない？というのは一理ある。というか最初はそう思ってZigを試したんですが、今回は見送らせていただきます、と。一理ある部分に関しては一理あるんですが、それ以外のところではRustのほうが上だという判断で、総合的にはRustを採用すべきだと至りました。</p>
<p>具体的には資料の中のRustの利点、これは資料中ではC++との比較という体にしていますが、Zigとの比較という意味もあります。標準公式のパッケージマネージャーがないし、開発環境の乏しさは、たとえZigが言語的にRustよりイージーだとしても、体感は正直言ってRustよりもハードでした。コンパイルエラーもRustは圧倒的にわかりやすいんですが、Zigはめちゃくちゃ厳しい……。Rustはイージーとは言わないですが、開発環境の助けやcargoコマンドのシンプルさ、技術情報（本・ブログ・FAQ）の多さによって、入り口は意外と大変ではない、むしろ入りやすい部類とすら言える感じです。</p>
<p>また、ZigはZigでありC/C++ではない。これはRustも同じでRustはRustでC/C++ではない、つまりCとZig(Rust)を連動させるには<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>のようなものが必要なのですが、Zigのそれの安定性がかなり低い、パースできない.hが普通にチラホラある。rust-bindgenのIssue見ていると本当に色々なケースに対応させる努力を延々と続けていて、それがbindgenの信頼性（と実用性）に繋がっているわけで、Zigはまだまだその域には達していないな、と。</p>
<p>Cはまだいいとしても、C++のエコシステムを使うという点では、ZigもRustも難しい。セッションの中では<a href="https://github.com/NVIDIA-Omniverse/PhysX">PhysX 5</a>を例に出しましたが、物理エンジンはOSSどころだと<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>も<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>も、SDKそのままそのものはC++だけなんですよね。これをC++以外の言語に持ち込むのは非常に骨の折れる仕事が必要になってきます。Rustに関してはEmbark Studiosが<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>を作ってくれたのである程度現実的ではありますが、何れにせよ大仕事が必要で、そのままでは持ち込めないというのが現実です。</p>
<p>physx-rsではC++のPhysXをRustで動かすために、まずC APIのPhysXを自動生成してそれ経由でRustから呼び出す、という話をしましたが、ZigもC++のものを呼び出すには、概ね同様のアプローチを取る必要があり、例えばZigでJolt Physicsを動かす<a href="https://github.com/michal-z/zig-gamedev">zphysics</a>というプロジェクトでは、C++のJoltに対して、C APIで公開するJoltCという部分を作って、それ経由でZigから呼び出すという手法を取っています。</p>
<p>この辺のことは<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>を作る時にめちゃくちゃ迷走して色々作りかけてたので痛感しています。そう、最初はZigでBullet Physicsを動かしてC#から呼び出すMagicBulletというプロジェクトだったこともあったのだ……。</p>
<p>最後発C++後継系言語であるところの<a href="https://github.com/carbon-language/carbon-lang">Carbon Language</a>は、C++におけるTypeScriptというのを標榜しているので、そうしたC++との連携を最優先に考えた言語になっているんじゃないかなー、と思います（触ってないので知らんですけど！）。C++の後継はRust(やZig)があるからいらんやろー、とはならない、C++の資産を活かしながらもモダンな言語仕様を使えるようにする、という絶妙な立ち位置を狙っているんじゃないかなー、と。どのぐらい盛り上がっていくのかわかりませんが……！</p>
<h2>C++/CLI</h2>
<p><a href="https://ja.wikipedia.org/wiki/C%2B%2B/CLI">C++/CLI</a>は使わないんですか？という質問がありました。.NETとC++ライブラリの連携という点で、C++/CLIはたしかに良いソリューションで、C++のライブラリをC#のために公開するブリッジとしては最高に使いやすい代物でした。.NET Frameworkの時代までは。</p>
<p>C++/CLIの問題は「.NET Core の C++/CLI サポートは Windows のみ」ということで、特にライブラリがLinuxサポートしないというのはありえないので、.NET Core以降にC++/CLIを新規採用するのは基本ありえない、といった状態になっています。こういった問題があるので、 .NET Framework時代に作られていたC++ライブラリをC#で使える系ライブラリはほとんど使えなくなりました。例えばPhysX 4の.NETバインディングである<a href="https://github.com/stilldesign/PhysX.Net">PhysX.NET</a>は、C++/CLIでバインディングが作られているため、.NET 5対応はしていますが、サポートプラットフォームはWindowsのみです。</p>
<p><a href="https://github.com/Cysharp/csbindgen">csbindgen</a>は、そうした.NET / C連携での空白地帯にちょうどうまくはまったライブラリなのではないかと思います。C++連携については頑張るしかないですが、そこはしょうがないね……！ ただ、Rustはエコシステムがうまく動いているので、Pure Rustライブラリであったり、RustでC++バインディングが作られているものを経由してC#バインディングを作る、といった手法でうまく回せる場合も多いんじゃないかなあー、というところがいいところです。それと、近年のライブラリ事情でいうと、物理エンジンみたいな老舗系はC++で作られていますが、例えば暗号通貨系のライブラリなんかは最初からRust実装だったりするものも多いので、RustからC#への持ち込み、のほうが今後の実用性としても高いんじゃないかと踏んでいます。</p>
</div>
<h1><a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html">UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</a></h1>
<ul class="date"><li>2023-10-13</li></ul>
<div class="entry_body"><p>Utf8StringInterpolationという新しいライブラリを公開しました！UTF8文字列の生成と書き込みに特化していて、動作をカスタマイズした文字列補間式によるC#コンパイラの機能を活用した生成と、StringBuilder的な連続的な書き込みの両方をサポートします。</p>
<ul>
<li><a href="https://github.com/Cysharp/Utf8StringInterpolation">Cysharp/Utf8StringInterpolation</a></li>
</ul>
<p>基本的な流れはこんな感じで、Stringを生成するのと同じように、UTF8を生成/書き込みできます。</p>
<pre><code class="language-csharp">using Utf8StringInterpolation;

// Create UTF8 encoded string directly(without encoding).
byte[] utf8 = Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);

// write to IBufferWriter&lt;byte&gt;(for example ASP.NET HttpResponse.BodyWriter)
Utf8String.Format(bufferWriter, $&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;); // support format

// like a StringBuilder
var writer = Utf8String.CreateWriter(bufferWriter);
writer.Append(&quot;My Name...&quot;);
writer.AppendFormat($&quot;is...? {name}&quot;);
writer.AppendLine();
writer.Flush();

// Join, Concat methods
var seq = Enumerable.Range(1, 10);
byte[] utf8seq = Utf8String.Join(&quot;, &quot;, seq);
</code></pre>
<p>Cysharpから公開している <a href="https://github.com/Cysharp/ZString/">ZString</a> と非常に近いのですが、ZStringがString(UTF16), UTF8をサポートしていたのに対して、UTF8側のみを取り出して強化したようなイメージになります。何が強化なのかというと、C# 10.0から<a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md">Improved Interpolated Strings</a>として、文字列補間式($&quot;foo{bar}baz&quot;)のパフォーマンスが大きく向上しました。具体的には、コンパイラが文字列補間式の構造を分解して、値が埋め込まれている箇所はGenericsのまま渡すようになりボクシングが消滅しました。つまりZStringでやっていたことではあるのですが、ZStringはC# 10.0以前のものですからね……！逆に言えば、これによってZStringは半分は不要となったわけです。</p>
<p>もう半分、UTF8側に関しては依然として標準のサポートは薄い、というかほぼない状態です。しかし、Improved Interpolated Strings は文字列補間式での挙動を自由にカスタマイズできるという性質も追加されています。というわけで、文字列補間式を利用してUTF8を組み立てられるようにすればいいのではないか、というのがUtf8StringInterpolationのコンセプトであり、正しくZLoggerの後継として位置づけていることでもあります。</p>
<pre><code class="language-csharp">// こういう文字列補間式を渡すと:
// Utf8String.Format(ref Utf8StringWriter format)
Utf8String.Format($&quot;Hello, {name}, Your id is {id}!&quot;);
</code></pre>
<pre><code class="language-csharp">// コンパイラが「コンパイル時」にこのような形に展開します。
var writer = new Utf8StringWriter(literalLength: 20, formattedCount: 2);
writer.AppendLiteral(&quot;Hello, &quot;);
writer.AppendFormatted&lt;string&gt;(name);
writer.AppendLiteral(&quot;, You id is &quot;);
writer.AppendFormatted&lt;int&gt;(id);
writer.AppendLiteral(&quot;!&quot;);
</code></pre>
<p>コンパイル時に展開してくれるというのは性能上非常に重要で、つまり<code>String.Format</code>のように実行時に文字列式のパースをしないで済む、わけです。また、ボクシングなしに全ての値を書き込みに呼んでくれます。</p>
<p><code>[InterpolatedStringHandler]</code>を付与している<code>ref Utf8StringWriter</code> に <code>$&quot;{}&quot;</code>を渡すと、自動的に展開してくれるという仕様になっています。そのUtf8StringWriterは以下のような実装になっています。</p>
<pre><code class="language-csharp">// internal struct writer write value to utf8 directly without boxing.
[InterpolatedStringHandler]
public ref struct Utf8StringWriter&lt;TBufferWriter&gt; where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    TBufferWriter bufferWriter; // when buffer is full, advance and get more buffer
    Span&lt;byte&gt; buffer;          // current write buffer

    public void AppendLiteral(string value)
    {
        // encode string literal to Utf8 buffer directly
        var bytesWritten = Encoding.UTF8.GetBytes(value, buffer);
        buffer = buffer.Slice(bytesWritten);
    }

    public void AppendFormatted&lt;T&gt;(T value, int alignment = 0, string? format = null)
        where T : IUtf8SpanFormattable
    {
        // write value to Utf8 buffer directly
        while (!value.TryFormat(buffer, out bytesWritten, format))
        {
            Grow();
        }
        buffer = buffer.Slice(bytesWritten);
    }
}
</code></pre>
<p>.NET 8 の場合は、値が <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0">IUtf8SpanFormattable</a> という.NET 8から追加されたインターフェイスを実装している場合(intなど標準のプリミティブはほぼ実装されています）、直接TryFormatによりUTF8としてSpanに書き込みます。</p>
<p>さすがに .NET 8 にしか対応していません！というのはエクストリームすぎるので、 .NET Standard 2.1, .NET 6(.NET 7)では <a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=net-7.0">Utf8Formatter.TryFormat</a> を使うことで、同様の性能を担保しています。</p>
<h2>Builder vs Writer</h2>
<p>ZStringのときはStringBuilderに引っ張られすぎていて、Builderとして内部でバッファを抱えるようにしていたのですが、ちょっとUTF8的な利用ではイマイチだということが徐々に分かってきました。今の .NET の基本は <code>IBufferWriter&lt;byte&gt;</code> である。というのはついこないだのCEDEC 2023での発表 <a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition">モダンハイパフォーマンスC# 2023 Edition</a> でかなり語らせていただいたのですが</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>
<p>BuilderというよりもWriterとして構築すべきだな、ということに至りました。そこで <code>Utf8StringWriter</code> は基本的に<code>IBufferWriter&lt;byte&gt;</code>を受け取ってそれに書き込むという仕様となりました。</p>
<pre><code class="language-csharp">public ref partial struct Utf8StringWriter&lt;TBufferWriter&gt;
    where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    Span&lt;byte&gt; destination;
    TBufferWriter bufferWriter;
    int currentWritten;

    public Utf8StringWriter(TBufferWriter bufferWriter)
    {
        this.bufferWriter = bufferWriter;
        this.destination = bufferWriter.GetSpan();
    }

    public void Flush()
    {
        if (currentWritten != 0)
        {
            bufferWriter.Advance(currentWritten);
            currentWritten = 0;
        }
    }
</code></pre>
<p>バッファが足りなくなったときは拡大するのではなくて、Advanceして新たにGetSpanを呼んで新しいバッファを確保しにいくという形を取りました。StringBuilderと違ってFlushの概念が必要になってしまいましたが、パフォーマンス的には大きな向上を果たしています。</p>
<p>Flushが必要ということを除けば、StringBuilderのように扱うことができます。</p>
<pre><code class="language-csharp">var writer = Utf8String.CreateWriter(bufferWriter);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(or Dispose)
writer.Flush();
</code></pre>
<p>また、ちょっとStringBuilder的に使いたいだけの時に <code>IBufferWriter&lt;byte&gt;</code> を用意するのは面倒くさい！という場合のために、内部でプーリングを行っているバッファを使えるオーバーロードも用意しています。戻り値がバッファのコントローラーになっていて、ToArrayや他の<code>IBufferWriter&lt;byte&gt;</code>にコピーしたり<code>ReadOnlySpan&lt;byte&gt;</code>の取得ができます。</p>
<pre><code class="language-csharp">// buffer must Dispose after used(recommend to use using)
using var buffer = Utf8String.CreateWriter(out var writer);

// call each append methods.
writer.Append(&quot;foo&quot;);
writer.AppendFormat($&quot;bar {Guid.NewGuid()}&quot;);
writer.AppendLine();

// finally call Flush(no need to call Dispose for writer)
writer.Flush();

// copy to written byte[]
var bytes = buffer.ToArray();

// or copy to other IBufferWriter&lt;byte&gt;, get ReadOnlySpan&lt;byte&gt;
buffer.CopyTo(otherBufferWriter);
var writtenData = buffer.WrittenSpan;
</code></pre>
<p>その他、<code>Format</code>, <code>Join</code>, <code>Concat</code> メソッドなども <code>IBufferWriter&lt;byte&gt;</code> を受け取るオーバーロードと <code>byte[]</code>を返すオーバーロードの2種を用意しています。</p>
<h2>.NET 8 と StandardFormat</h2>
<p>値のフォーマット書式は、特にDateTimeでよく使うと思いますが、数値型などでも多くの書式が用意されています。<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/formatting-types">.NET の数値、日付、列挙、その他の型の書式を設定する方法</a> や各種カスタム書式指定文字列は非常に便利です。</p>
<p>しかし、UTF8に値を直接書き込む手段として従来用意されていた<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat">Utf8Formatter.TryFormat</a>では、その標準的な書式指定文字列は使えませんでした！代わりに用意されたのが<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.standardformat">StandardFormat</a>なのですが、恐ろしく限定的なことしかできず(例えば'G', 'D', or 'X'のような一文字charの指定しかできない)、使い物にならないといっても過言ではないぐらいでした。</p>
<p>ところが .NET 8 から追加された IUtf8SpanFormattable.TryFormat では、通常の書式指定文字列が帰ってきました！</p>
<pre><code class="language-csharp">// Utf8Formatter.TryFormat
static bool TryFormat (int value, Span&lt;byte&gt; destination, out int bytesWritten, System.Buffers.StandardFormat format = default);

// .NET 8 IUtf8SpanFormattable.TryFormat
bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);
</code></pre>
<p>パラメーターは非常に似ていますが、formatを文字列で受け取るようになっています。実際に比較してみるとこんな感じです。</p>
<pre><code class="language-csharp">Span&lt;byte&gt; dest = stackalloc byte[16];
int written = 0;

// ParseできなくてExceptionがthrowされるので表現できない
Utf8Formatter.TryFormat(123.456789, dest, out written, StandardFormat.Parse(&quot;.###&quot;));

// 123.456
123.456123.TryFormat(dest, out written, &quot;.###&quot;);


// カスタム書式文字列は指定できないので例外！サポートしてるのは `G`, `R`, `l`, `O` だけ！
Utf8Formatter.TryFormat(DateTime.Now, dest, out written, StandardFormat.Parse(&quot;yyyy-MM-dd&quot;));

// もちろんちゃんと動作する
DateTime.Now.TryFormat(dest, out written, &quot;yyyy-MM-dd&quot;);

Console.WriteLine(Encoding.UTF8.GetString(dest.Slice(0, written)));
</code></pre>
<p>良かった、やと普通の世界が到達した……！これは ZString や、それを内部に使っていた <a href="https://github.com/Cysharp/ZLogger">ZLogger</a>で最もフラストレーションを感じていた点です。</p>
<p>Utf8StringInterpolationは .NET 8 では全て IUtf8SpanFormattable で変換するようにしています。しかし、 .NET Standard 2.1, .NET 6, .NET 7では残念ながらUtf8Formatter利用となっているので、書式指定に関しては制限があります。数値に関してはターゲットプラットフォームによって動作したりしなかったりが発生します。</p>
<pre><code class="language-csharp">// .NET 8 supports all numeric custom format string but .NET Standard 2.1, .NET 6(.NET 7) does not.
Utf8String.Format($&quot;Double value is {123.456789:.###}&quot;);
</code></pre>
<p>ただし、 <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeSpan</code> に関しては <code>Utf8Formatter</code> を使わない処理をしているため、全てのターゲットプラットフォームでカスタム書式指定が利用可能です！</p>
<pre><code class="language-csharp">// DateTime, DateTimeOffset, TimeSpan support custom format string on all target plaftorms.
// https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
Utf8String.Format($&quot;Today is {DateTime.Now:yyyy-MM-dd}&quot;);
</code></pre>
<p>とにかくDateTimeの書式指定がまともに出来ないのはZString/ZLoggerで一番辛かったところなので、それを改善できてとても良かった……。ただしこの対応により、DateTimeの変換性能が落ちているため、性能が最大限引き出せるのは .NET 8 となります。</p>
<h2>Unity</h2>
<p>Unity対応はありません！いや、可能な限り私は .NET と Unityの両対応のライブラリを作りたいと思っていて、実際今までもそうしてきているわけですが、今回ばかりはどうにもならないのです。そもそもImproved Interpolated Stringsが C# 10.0 からで、Unityの現在のC#のバージョンは C# 9.0……！さすがにそれはどうにもならない。</p>
<p>C# 9.0で止まってから結構長いんですよね。別にランタイムのバージョンは上げなくてもいいから、コンパイラのバージョンだけ上げて欲しいと切実に思いますが、まぁC# 10.0にしたらDefaultInterpolatedStringHandlerがなくて動作しないじゃんとかなるだろうから、結局はランタイムのバージョンアップもセットでやらなければならない……。</p>
<p>Unityが C# 10.0 に対応したらすぐに対応させるつもりではあります！待ってます！</p>
<h2>Next</h2>
<p>さて、とはいえ、UTF8文字列を直接扱わなければならないケースというのは、別にそんなに多くはないでしょう。実際、私も本命は<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>の大型バージョンアップでの利用を考えています。ZLoggerは今まではZStringベースでしたが、根本からデザインをやり直した新しいものを開発中です。その中の文字列化にUtf8StringInterpolationを使っています。</p>
<p>といったように、アプリケーションの基盤レイヤーに差し込んであげると有効に機能するシチュエーションは色々あると思います。もちろん、直接使ってもらってもいいのですが……！？</p>
</div>
<h1><a href="https://neue.cc/2023/09/21_privateproxy.html">.NET 8 UnsafeAccessor を活用したライブラリ PrivateProxy を公開しました</a></h1>
<ul class="date"><li>2023-09-21</li></ul>
<div class="entry_body"><p>PrivateProxyというライブラリを公開しました。つまるところ、privateフィールド/プロパティ/メソッドにアクセスするライブラリなのですが、.NET 8 のUnsafeAccessorという新機能を活用することでNo Reflection、ハイパフォーマンス、AOTセーフになっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/PrivateProxy">Cysharp/PrivateProxy</a></li>
</ul>
<p>もちろん .NET 8 でしか動きません！ので、.NET 8が正式リリースされた頃に思い出して使ってみてください。エクストリームな人は今すぐ試しましょう。</p>
<p>雰囲気としては、privateメンバーにアクセスしたい型があったとして、<code>[GeneratePrivateProxy(type)]</code>をつけた型を用意します。</p>
<pre><code class="language-csharp">using PrivateProxy;

public class Sample
{
    int _field1;
    int PrivateAdd(int x, int y) =&gt; x + y;
}

[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p>すると、いい感じにアクセスできるようになります。</p>
<pre><code class="language-csharp">// You can access like this.
var sample = new Sample();
sample.AsPrivateProxy()._field1 = 10;
</code></pre>
<p>いいところとしては、 Source Generatorベースの生成なので、型がついていて入力補完も効くし、変数名を変更したらコンパイルエラーで検出可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/269376472-f6dd22e1-e82e-4acc-ba6e-8895c8c8734b.png" alt="" /></p>
<p>ここまではSource Generatorベースで作れば、今まででもやれないことはなかったのですが、UnsafeAccessorのいいところとして、objectが一切出てこないで元のメソッドそのままの型がそのまま使えることです。生成されたコードを見ると、こうなっています。</p>
<pre><code class="language-csharp">// Source Generator generate this type
partial struct SampleProxy(Sample target)
{
    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &quot;_field1&quot;)]
    static extern ref int ___field1__(Sample target);

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;PrivateAdd&quot;)]
    static extern int __PrivateAdd__(Sample target, int x, int y);

    public ref int _field1 =&gt; ref ___field1__(target);
    public int PrivateAdd(int x, int y) =&gt; __PrivateAdd__(target, x, y);
}

public static class SamplePrivateProxyExtensions
{
    public static SampleProxy AsPrivateProxy(this Sample target)
    {
        return new SampleProxy(target);
    }
}
</code></pre>
<p>これによって <code>ref</code> や <code>readonly</code> などの言語機能をそのまま反映できたり、mutableなstructの対応が自然にできたり、そして何よりパフォーマンスの低下も一切ありません。</p>
<p>使い道は、主にユニットテスト用になるとは思いますので、なのでパフォーマンスはそこまで重要ではないといえばないのですが、性能的にはアプリケーションの実行時に使っても問題ないものとなっています。</p>
<p>私は昔<a href="https://github.com/neuecc/ChainingAssertion">Chaining Assertion</a>というユニットテスト用のライブラリを作っていたのですが、現在は<a href="https://fluentassertions.com/">Fluent Assertions</a>という別のライブラリを使っています。ほとんどの機能は概ねなんとかなっているのですが、<code>AsDynamic()</code>を呼ぶと、移行はprivateフィールドやメソッドにアクセスし放題という機能は結構便利で、そしてそれがFluent Assertionsにないのは若干不便と思ってたんですね。今回、やっとそれの進化系を作れたのでメデタシメデタシです。</p>
<h2>C# 12</h2>
<p>ところで、冒頭のSampleProxyの書き方、地味にこれはC# 12の記法を使っています。どこだかわかりますか？</p>
<pre><code class="language-csharp">[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
</code></pre>
<p><code>SampleProxy;</code> の部分で、空のクラスを作る際に <code>{ }</code> じゃなくて <code>;</code> だけで済ませられるようになりました。これは地味ですがかなりいい機能で、というのもSource Generatorだと空クラスに割り当てることが多かったんですよね。そして、たった2文字が1文字に変わっただけ、ではあるのですが、 <code>{ }</code> だとコードフォーマットに影響があります。改行して3行で表現するのか、後ろにつけるのか。そうした判断のブレが <code>;</code> だとなくなります。だから2文字が1文字に変わっただけ、以上のインパクトがある、良い機能追加だと思います。</p>
<h2>ref field</h2>
<p>PrivateProxyはstaticメソッドにも対応していますし、そしてmutable structにも対応しています。</p>
<pre><code class="language-csharp">using PrivateProxy;

public struct MutableStructSample
{
    int _counter;
    void Increment() =&gt; _counter++;

    // static and ref sample
    static ref int GetInstanceCounter(ref MutableStructSample sample) =&gt; ref sample._counter;
}

// use ref partial struct
[GeneratePrivateProxy(typeof(MutableStructSample))]
public ref partial struct MutableStructSampleProxy;
</code></pre>
<pre><code class="language-csharp">var sample = new MutableStructSample();
var proxy = sample.AsPrivateProxy();
proxy.Increment();
proxy.Increment();
proxy.Increment();

// call private static method.
ref var counter = ref MutableStructSampleProxy.GetInstanceCounter(ref sample);

Console.WriteLine(counter); // 3
counter = 9999;
Console.WriteLine(proxy._counter); // 9999
</code></pre>
<p>mutable structの対応って結構難しい話で、というのもフィールドにstructを保持するとコピーが渡されることになるので、普通に書いていると変更が元のstructに反映されないんですね。この問題をPrivateProxyではC# 11 ref fieldで解決しました。</p>
<p>MutableStructSampleProxyはSource Generatorによって以下のようなコードが生成されます。</p>
<pre><code class="language-csharp">ref partial struct MutableStructSampleProxy
{
    ref MutableStructSample target;

    public MutableStructSampleProxy(ref MutableStructSample target)
    {
        this.target = ref target;
    }

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &quot;Increment&quot;)]
    static extern void __Increment__(ref MutableStructSample target);
    
    public void Increment() =&gt; __Increment__(ref this.target);
}

public static class MutableStructSamplePrivateProxyExtensions
{
    public static MutableStructSampleProxy AsPrivateProxy(this ref MutableStructSample target)
    {
        return new MutableStructSampleProxy(ref target);
    }
}
</code></pre>
<p>AsPrivateProxy(これはthis refですが、拡張メソッドの場合、予備側はrefを書かなくていいので自然に使えます)で渡されたstructは、そのままずっとrefのまま保持されています。これにより、メソッド呼び出しでstructの状態に変更があった場合も問題なく変更が共有されています。</p>
<h2>privateメソッドの単体テスト</h2>
<p><a href="https://t-wada.hatenablog.jp/entry/should-we-test-private-methods">プライベートメソッドのテストは書かない</a>みたいな流儀も世の中にはありますが、私は何言ってんの？と思ってます。パブリックメソッドのテストでprivateメソッドの確認が内包されるから不要というなら、はぁー？だったら全部E2Eテストでいいんじゃないですかー？真の振る舞いがテストされますよー？</p>
<p>もちろんそれは非現実的で、E2Eでパブリックメソッドのロジックを全て通過させるのは手間とコストがかかりすぎる。というのと同じ話で、privateメソッドのエッジケースを全てチェックする時に、public経由だとやりにくいことは往々にある。場合によってはコード通すためにモックを仕込まなければならないかもしれない。そこまでいくとアホらしいですよね、privateメソッドを直接テストすればすむだけの話なのに？メソッドは小さければ小さいほど良いし、テストもしやすい。そしてprivateを内包したpublicよりもprivateそのもののほうが小さく、テストしやすい。</p>
<p>ようするにコスト面を考えて境界をどこに置くかというだけの話で。そして、privateメソッドのテストそのものは、C#の場合reflection呼び出しだと、変更コストがかかるなど、コスパは悪い部類に入ってしまう。でもそれはただの言語からの制約であって、だからプライベートメソッドのテストは不要みたいなしょーもない理屈をこねて絶対視するほどのことでもない。リフレクション使うとコスパ感が合わないから原則publicで済ませること、ぐらいだったらいいけど、変な教義立てるのはおかしいでしょ。</p>
<p>チェックしたいがためにprivateであるべきものをinternalにする（たまによくやる、internalならInternalsVisibleToをテストプロジェクトに指定することで、ユニットテストプロジェクトで参照できるようになる）こともありますが、あまりお行儀の良いことではない。そもそもinternalなので同一アセンブリ内では不要に可視レベル上がっちゃってるし。</p>
<p>と、いうわけで、PrivateProxyは比較的低コストでprivateメソッドをテスト対象にすることができるので、全然使っちゃっていいし、テストも書いちゃって良い、わけです。</p>
<h2>UnsafeAccessor for InternalCall</h2>
<p>UnsafeAccessor の使い道として、corelibの InternalCall を強引に呼べることはかなりいいこと（？）だと思ってます。例えば string の生成には大元に <a href="https://source.dot.net/#System.Private.CoreLib/src/System/String.CoreCLR.cs,12">FastAllocateString</a> というのがあって、通常ユーザーはこれを呼ぶことはできないのですが</p>
<pre><code class="language-csharp">[UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = &quot;FastAllocateString&quot;)]
static extern string FastAllocateString(string _, int length);

var rawString = FastAllocateString(null!, 10);
var mutableSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(rawString.AsSpan()), rawString.Length);

&quot;abcde&quot;.CopyTo(mutableSpan);
&quot;fghij&quot;.CopyTo(mutableSpan.Slice(5));

Console.WriteLine(rawString); // abcdefghij
</code></pre>
<p>といったようにUnsafeAccessorを通せばやりたい放題できます。</p>
<p>Stringに関しては、やりたい放題させないために、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.string.create">String.Create</a>というメソッドが用意されていて、Actionのコールバックで変更して、不変のStringを返すというものが用意されてはいるのですが、ActionだとTStateに<code>Span&lt;T&gt;</code>を渡せないとか、使えないケースがそれなりにあります、というか使いたいシチュエーションに限って使えないことが多い……。</p>
<p>なお、こういうFastAllocateStringを呼んでStringに変更をかけるというのは、<a href="https://github.com/dotnet/runtime/issues/36989">dotnet/runtime#36989 Make string.FastAllocateString public</a>で見事に却下されています。つまり、やるな、ということです。</p>
<blockquote>
<p>It is never safe or supported to mutate the contents of a returned string instance.
If you mutate a string instance within your own library or application, you are entering unsupported territory.
A future framework update could break you. Or - more likely - you'll encounter memory corruption that will be very painful for you or your customers to diagnose.</p>
</blockquote>
<p>お怒りはご尤もです。しかしString.CreateでAction渡す口あるんだからそれでいいだろーというのはお粗末すぎだと思うんですよねー、どうせやってること一緒なんだから弄るの許可してよ、というのもそれはそれで理解してもらいたいです（私は弄りたいほうの人間なので！）。というわけで、自己責任で、やっていきましょう、つまりやっていくということです……！</p>
<h2>まとめ</h2>
<p>.NET 8でしか動きません！11月に .NET 8 がリリースされるので、その時まで忘れないでください！</p>
</div>
<h1><a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html">Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</a></h1>
<ul class="date"><li>2023-07-28</li></ul>
<div class="entry_body"><p>Cysharpから(主に)Unity用のHTTP/2, gRPC, MagicOnion用の通信ネットワーククライアントを公開しました。実装者は週刊.NET情報配信<a href="https://weekref.net/">WeekRef.NET</a>を運営している<a href="https://twitter.com/mayuki">@mayuki</a>さんです。</p>
<ul>
<li><a href="https://github.com/Cysharp/YetAnotherHttpHandler">Cysharp/YetAnotherHttpHandler</a></li>
</ul>
<p>何故これが必要なのかの背景情報としては、<a href="https://synamon.hatenablog.com/entry/grpc-dotnet-unity">Synamon’s Engineer blog - Unityでもgrpc-dotnetを使ったgRPCがしたい</a> が詳しいのですが、まず、.NETには2つのgRPC実装があります。googleが提供してきたgRPCのネイティブバインディングのGrpc.Core(C-Core)と、Microsoftが提供しているPure C#実装のgrpc-dotnet。現在.NETのgRPCはサーバーもクライアントも完全にPure C#実装のほうに寄っていて、<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>もサーバーはPure C#実装のものを使っています。</p>
<p>しかしクライアントに関しては、諸事情によりUnityでは動かない（TLS関連の問題など）ため、ずっとC-Coreを推奨してきました。更に、Unity用のビルドは元々experimentalだったうえに、とっくにメンテナンスモードに入り、そしてついに今年5月にサポート期限も切れて完全に宜しくない気配が漂っていました。また、古いx64ビルドなので最近のMac(M1, M2チップ)では動かないためUnity Editorで使うのにも難儀するといった問題も出てきていました。</p>
<p>と、いうわけで、CysharpではUnityで使うgRPCを推奨してきたということもあり、Unityで問題なく使えるgRPC実装としてYetAnotherHttpHandlerを開発・リリースしました。HttpClientの通信レイヤーであるHttpHandlerを差し替えるという形で実装してあるので、ほとんど通常の .NET でのgRPCと同様に扱えます。</p>
<p>内部実装としてはPure Rust実装のHTTP/2ライブラリ<a href="https://hyper.rs/">hyper</a>とPure RustのTLSライブラリ<a href="https://github.com/rustls/rustls">rustls</a>を基盤として作ったネイティブライブラリに対して、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>で生成したC#バインディングを通して通信する形になっています。</p>
<h2>余談</h2>
<p>YetAnotherHttpHandlerはgRPCやMagicOnionに限らず、Unityで自由に使える HTTP/2 Clientなので、アセットダウンロードの高速化にHTTP/2を用いる、といったような使い道も考えられます。既にモバイルゲームでも幾つかのタイトルでHTTP/2でアセットダウンロードしているタイトルは確認できていまして、例えばセガさんは<a href="https://speakerdeck.com/segadevtech/cedec2021-taunrotoshi-jian-woda-fu-jian-da-liang-falseasetutowosahakugao-su-nashi-zhuang-toyun-yong-shi-li-falsegong-you">CEDEC2021 ダウンロード時間を大幅減！～大量のアセットをさばく高速な実装と運用事例の共有～</a>のような発表もされています。ネイティブプラグインを自前でビルドして持ち込むというのはだいぶ敷居が高い話でしたが、YetAnotherHttpHandlerを入れるだけでいいなら、だいぶやれるんじゃないか感も出てくるんじゃないでしょうか……？</p>
</div>
<h1><a href="https://neue.cc/2023/07/20_nats_client_v2.html">AlterNats は 公式の NATS .NET Client v2 に引き継がれました</a></h1>
<ul class="date"><li>2023-07-20</li></ul>
<div class="entry_body"><p><a href="https://nats.io/">NATS</a>のサードパーティー(alternative)クライアントであった<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>は、公式に引き取られて<a href="https://github.com/nats-io/nats.net.v2">NATS.NET V2</a>となりました。v2の詳細に関してはNATS公式からのブログ<a href="https://nats.io/blog/nats-dotnet-v2-alpha-release/">NATS .NET Client v2 Alpha Released with Core NATS Support</a>を参照ください。</p>
<blockquote>
<p>NATS community members started to take note, and develop client libraries for NATS based on modern .NET APIs. One notable client library that emerged was the AlterNats library by Cysharp, which includes a fully asynchronous API, leverages Span<T> , and supports client-side WebSockets from browsers in Blazor . NATS maintainers and AlterNats maintainers agreed that AlterNats would make a great starting point for NATS.Client v2!</p>
</blockquote>
<p>NATSに関してはAlterNatsリリース時の記事 <a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a>に色々書きましたが、<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>配下のPubSubミドルウェアで、RedisなどでのPubSubに比べるとパフォーマンスを始めとして多くのメリットがあります。</p>
<p>ただしこういうものはサーバー実装も重要ですがクライアント実装も重要であり、そして当時のNATSの公式クライアント(v1)は正直酷かった！せっかくの素晴らしいミドルウェアが.NETでは活かされない、また、RedisでのPubSubには不満があり、そもそも.NETでのベストなPubSubのソリューションがないことに危機意識を感じていたので、独自に実装を進めたのがAlterNatsでした。</p>
<p>ただし、枯れたプロトコルならまだしも、進化が早いミドルウェアのクライアントが乱立しているのは決して良いことでもないでしょう。新機能への追随速度やメンテナンスの保証という点でも、サードパーティクライアントとして進んでいくよりも、公式に統合されることのほうが絶対に良いはずです。</p>
<p>というわけで今回の流れは大変ポジティブなことだし、野良実装にとって最高の道を辿れたんじゃないかと思っています。私自身は実装から一歩引きますが、使っていく上で気になるところがあれば積極的にPR上げていくつもりではあります。</p>
<p>なお、NATSに関しては来月CEDEC 2023でのセッション<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>で触れる、かもしれません、多分。というわけでぜひ聞きに来てください……！</p>
<p>メタバース関連では、今年の5月にTGS VRなどを手掛けている<a href="https://ambr.co.jp/">ambr</a>さんのテックブログにて<a href="https://ambr-inc.hatenablog.com/entry/20230512/1683882000">VRメタバースのリアルタイム通信サーバーの技術にMagicOnionとNATSを選んだ話</a>という紹介もしていただいていました。</p>
<h2>OSSとメンテナンスの引き継ぎ</h2>
<p>権限の移管は何度か経験があって</p>
<ul>
<li><a href="https://github.com/mihaifm/linq">linq.js</a>、</li>
<li><a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a></li>
<li><a href="https://github.com/xin9le/CloudStructures">CloudStructures</a></li>
</ul>
<p>は完全に手放しています。ほか、<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>はCysharp名義に移ったうえで、現在の開発リードは私ではありません。また、最近では<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#</a>はMessagePack-CSharp Organizationに移していて共同のOwner権限になっています。</p>
<p>どうしても常に100%の力を一つのOSSに注ぐことはできないので、本来はうまく移管していけるのが良いわけですが、いつもうまくできるわけじゃなくて、<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>なんかはうまく移管できないままarchivedにしてしまっています。</p>
<p>やっぱ出した当時は自分が手綱を握っていたいという気持ちがとても強いわけですが、関心が徐々に薄れていくタイミングと他の人に渡せるタイミングがうまく噛み合わないと、死蔵になってしまうというところがあり、まぁ、難しいです。これだけやっていても上手くできないなあ、と……。</p>
<p>今回のは大変良い経験だったので、作ってメンテナンスを続ける、そしてその先についても考えてやっていきたいところですね。</p>
<p>ともあれ、良い事例を一つ作れた＆素晴らしいライブラリをC#に一つ持ち込むことができたということで、とても気分がよいですです。</p>
</div>
<h1><a href="https://neue.cc/2023/07/07_mvp-renew13.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2023-07-07</li></ul>
<div class="entry_body"><p>13回目です！一年ごとに再審査での更新で、変わらずC#の最前線に立てています。</p>
<p>活動の中心は引き続きOSSですが、<a href="https://github.com/Cysharp">github/Cysharp</a>でのスター数は変わらず他を圧倒していると思いますし、毎年の新規の公開数の勢いも変わらずで新しいアイディアを出し続けています。</p>
<p>今年は<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>を起点にしてRustを活用してC#の活用幅をより広げていくことを狙っています。先日公開した<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>の他にも色々計画がって、かなり面白いインパクトが出せるんじゃないかと思っています。</p>
<p>MessagePack for C#も<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack-CSharp/MessagePack-CSharp</a>と、organization名義に移したことで（変わらず私はOwnerなので権限を手放したわけではありません）より中立的に発展させていきます。直近ではSource Generator対応が予定されています(preview版を公開中）。</p>
<p>というわけで、これはもう満場一致でC#に貢献しているということでいいんじゃないでしょうかね……？</p>
<p>ここ最近は登壇していなかったのですが、去年は<a href="https://speakerdeck.com/neuecc/c-number-11-niyorushi-jie-zui-su-bainarisiriaraiza-memorypack-nozuo-rifang">C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a>というセッションをしました。その流れということで、今年の8月にCEDEC 2023にて<a href="https://cedec.cesa.or.jp/2023/session/detail/s642165615a6b5">モダンハイパフォーマンスC# 2023 Edition</a>、それと共同講演で<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>という2つの登壇予定があるので、ぜひ見に来てください。</p>
</div>
<h1><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></h1>
<ul class="date"><li>2023-07-04</li></ul>
<div class="entry_body"><p>MagicPhysXというライブラリを新しく公開しました！.NETで物理エンジンを動かすというもので、その名の通り、<a href="https://github.com/NVIDIA-Omniverse/PhysX">NVIDIA PhysX
</a>のC#バインディングとなっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/MagicPhysX">Cysharp/MagicPhysX</a></li>
</ul>
<p>使い道としては</p>
<ul>
<li>GUIアプリケーションの3D部分</li>
<li>自作ゲームエンジンへの物理エンジン組み込み</li>
<li>ディープラーニングのためのシミュレーション</li>
<li>リアルタイム通信におけるサーバーサイド物理</li>
</ul>
<p>といったことが考えられます。</p>
<p>.NET用のPhysXバインディングは他にも存在しますが、C++/CLIでバインディングを生成している都合上Windowsでしか動かせなかったり、バージョンが最新ではない4.xベースだったりしますが、MagicPhysXは最新のPhysX 5ベースで、かつ、Windows, MacOS, Linuxの全てで動きます！(win-x64, osx-x64, osx-arm64, linux-x64, linux-arm64)。これはバインディングの作り方としてクロスプラットフォームコンパイルに強いRustと、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>によってC#のバインディングの自動生成をしているからです。</p>
<p>先にアーキテクチャの話をしましょう。MagicPhysXは<a href="https://www.embark-studios.com/">EmbarkStudios</a>による<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>をビルド元に使っています。</p>
<blockquote>
<p>EmbarkStudiosはEA DICEで<a href="https://www.ea.com/frostbite">Frostbite</a>ゲームエンジン(Battlefield)を作っていた人たちが独立して立ち上げたスタジオで、Rustによるゲームエンジンを作成中です。また、その過程で生まれたRustのライブラリをOSSとして積極的に公開しています。一覧は<a href="https://embark.dev/">Embark Studios Open Source</a>にあります。必見！</p>
</blockquote>
<p>PhysXのライブラリはC++で出来ていて、他の言語で使うことは考慮されていません。そのために他の言語に持ち込むためには、C++上で別言語で使うためのブリッジ部分を作った上で、バインディングを用意するという二度手間が必要になってきます。それはRustであっても例外ではありません。また、二度手間というだけではなく、PhysXのソースコードはかなり大きいため、その作業量も膨大です。</p>
<p>以前に<a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a>で紹介しましたが、<a href="https://www.swig.org/">SWIG</a>などのC++からの自動生成、Rustであれば<a href="https://cxx.rs/">cxx</a>、<a href="https://github.com/google/autocxx">autocxx</a>のような自動化プロジェクトも存在しますが、C++そのものの複雑さからいっても、求めるものを全自動で出力するのは難しかったりします。</p>
<p>physx-rsでは<a href="https://www.youtube.com/watch?v=RxtXGeDHu0w">An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)</a>というセッションでPhysXをRustに持ち込むための手段の候補、実際に採用した手段についての解説があります。最終的に採用された手段について端的に言うと、PhysXに特化してコード解析してC APIを生成する独自ジェネレーターを用意した、といったところでしょうか。そしてつまり、physx-rsには他言語でもバインディング手段として使えるPhysXのC APIを作ってくれたということにもなります！</p>
<p>更にcsbindgenには、rsファイル内のextern &quot;C&quot;の関数からC#を自動生成する機能が備わっているので、Rustを経由することでC++のPhysXをC#に持ち込めるというビルドパイプラインとなりました。</p>
<p>そういう成り立ちであるため、MagicPhysXのAPIはPhysXのAPIそのものになっています。</p>
<pre><code class="language-csharp">using MagicPhysX; // for enable Extension Methods.
using static MagicPhysX.NativeMethods; // recommend to use C API.

// create foundation(allocator, logging, etc...)
var foundation = physx_create_foundation();

// create physics system
var physics = physx_create_physics(foundation);

// create physics scene settings
var sceneDesc = PxSceneDesc_new(PxPhysics_getTolerancesScale(physics));

// you can create PhysX primitive(PxVec3, etc...) by C# struct
sceneDesc.gravity = new PxVec3 { x = 0.0f, y = -9.81f, z = 0.0f };

var dispatcher = phys_PxDefaultCpuDispatcherCreate(1, null, PxDefaultCpuDispatcherWaitForWorkMode.WaitForWork, 0);
sceneDesc.cpuDispatcher = (PxCpuDispatcher*)dispatcher;
sceneDesc.filterShader = get_default_simulation_filter_shader();

// create physics scene
var scene = physics-&gt;CreateSceneMut(&amp;sceneDesc);

var material = physics-&gt;CreateMaterialMut(0.5f, 0.5f, 0.6f);

// create plane and add to scene
var plane = PxPlane_new_1(0.0f, 1.0f, 0.0f, 0.0f);
var groundPlane = physics-&gt;PhysPxCreatePlane(&amp;plane, material);
scene-&gt;AddActorMut((PxActor*)groundPlane, null);

// create sphere and add to scene
var sphereGeo = PxSphereGeometry_new(10.0f);
var vec3 = new PxVec3 { x = 0.0f, y = 40.0f, z = 100.0f };
var transform = PxTransform_new_1(&amp;vec3);
var identity = PxTransform_new_2(PxIDENTITY.PxIdentity);
var sphere = physics-&gt;PhysPxCreateDynamic(&amp;transform, (PxGeometry*)&amp;sphereGeo, material, 10.0f, &amp;identity);
PxRigidBody_setAngularDamping_mut((PxRigidBody*)sphere, 0.5f);
scene-&gt;AddActorMut((PxActor*)sphere, null);

// simulate scene
for (int i = 0; i &lt; 200; i++)
{
    // 30fps update
    scene-&gt;SimulateMut(1.0f / 30.0f, null, null, 0, true);
    uint error = 0;
    scene-&gt;FetchResultsMut(true, &amp;error);

    // output to console(frame-count: position-y)
    var pose = PxRigidActor_getGlobalPose((PxRigidActor*)sphere);
    Console.WriteLine($&quot;{i:000}: {pose.p.y}&quot;);
}

// release resources
PxScene_release_mut(scene);
PxDefaultCpuDispatcher_release_mut(dispatcher);
PxPhysics_release_mut(physics);
</code></pre>
<p>つまり、そのままでは決して扱いやすくはないです。部分的に動かすだけではなく、本格的にアプリケーションを作るなら、ある程度C#に沿った高レベルなフレームワークを用意する必要があるでしょう。MagicPhysX内ではそうしたサンプルを用意しています。それによって上のコードはこのぐらいシンプルになります。</p>
<pre><code class="language-csharp">using MagicPhysX.Toolkit;
using System.Numerics;

unsafe
{
    using var physics = new PhysicsSystem(enablePvd: false);
    using var scene = physics.CreateScene();

    var material = physics.CreateMaterial(0.5f, 0.5f, 0.6f);

    var plane = scene.AddStaticPlane(0.0f, 1.0f, 0.0f, 0.0f, new Vector3(0, 0, 0), Quaternion.Identity, material);
    var sphere = scene.AddDynamicSphere(1.0f, new Vector3(0.0f, 10.0f, 0.0f), Quaternion.Identity, 10.0f, material);

    for (var i = 0; i &lt; 200; i++)
    {
        scene.Update(1.0f / 30.0f);

        var position = sphere.transform.position;
        Console.WriteLine($&quot;{i:D2} : x={position.X:F6}, y={position.Y:F6}, z={position.Z:F6}&quot;);
    }
}
</code></pre>
<p>ただしあくまでサンプルなので、参考にしてもらいつつも、必要な部分は自分で作ってもらう必要があります。</p>
<p>Unityのようなエディターがないと可視化されてなくて物理エンジンが正しい挙動になっているのか確認できない、ということがありますが、PhysXにはPhysX Visual Debuggerというツールが用意されていて、MagicPhysXでも設定することでこれと連動させることが可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/250030945-2018e821-41c4-44a2-aac6-f0705993ab9b.png" alt="" /></p>
<h2>Dedicated Server</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>といったサーバーサイドでゲームのロジックを動かすためのライブラリを開発しています。その路線から行って物理エンジンが必要なゲームでさえも通常の .NET サーバーで動かしたいという欲求が出てくるのは至極当然でしょう……（？）</p>
<p>UEやUnityのDedicated Serverの構成だとヘッドレスなUE/Unityアプリケーションをサーバー用ビルドしてホスティングすることになりますが、サーバー用のフレームワークではないので、あまり作りやすいとは言えないんですよね。通常用サーバー向けのライブラリとの互換性、ライフサイクルの違い、ランタイムとしてのパフォーマンスの低さ、などなど。</p>
<p>というわけで、MagicOnionのようなサーバー向けフレームワークを使ったほうがいいのですが、物理エンジンだけはどうにもならない。今までは……？</p>
<p>と、言いたいのですが、まずちゃんとしっかり言っておきたいのですが、現実的には少々（かなり）難しいでしょう！コライダーどう持ってくるの？とかAPIが違う（Unityの物理エンジンはPhysXですが、API的に1:1の写しではないので細かいところに差異がある）のでそもそも挙動を合わせられないし、でもこういう構成ならサーバーだけじゃなくクライアントでも動かしたい、そもそもそうじゃないとデバッガビリティが違いすぎる。</p>
<p>と、ようするに、もしゲーム自体にある程度、物理エンジンに寄せた挙動が必要なら、「物理エンジン大統一」が必須だと。MagicPhysXは残念ながらそうではありません。実のところ当初はそれを目指していました、Unityとほぼ同一挙動でほぼ同一APIになるのでシームレスに持ち込むことができるライブラリなのだ、と。しかし現状はそうではないということは留意してください。また、その当初予定である互換APIを作り込む予定もありません。</p>
<h2>まとめ</h2>
<p>このライブラリ、かなり迷走したプロジェクトでもあって、そもそも最初は<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>を採用する予定でした。ライブラリ名が先に決めてあってMagicBulletってカッコイイじゃん、みたいな。その後に<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>を使おうとして、これもバインディングをある程度作って動く状態にしたのですが、「物理エンジン大統一」のためにPhysXにすべきだろうな、という流れで最終的にPhysXを使って作ることにしました。</p>
<p>形になって良かったというのはありますが（そしてcsbindgenの実用性！）、「物理エンジン大統一」を果たせなかったのは少々残念ではあります。最初の完成予想図ではもっともっと革命的なもののはずだったのですが……！</p>
<p>とはいえ、PhysX 5をクロスプラットフォームで.NETに持ち込んだということだけでも十分に難易度が高く新しいことだと思っているので、試す機会があれば、是非触って見ください。</p>
</div>
<h1><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></h1>
<ul class="date"><li>2023-03-09</li></ul>
<div class="entry_body"><p>ネイティブコードとC#を透過的に接続するために、RustのFFIからC#のDllImportコードを自動生成するライブラリを作成し、公開しました。Cysharp初のRustライブラリです！先週にプレビューを出していましたが、しっかりした機能強化とReadMeの充実をして正式公開、です！</p>
<ul>
<li><a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a></li>
<li><a href="https://crates.io/crates/csbindgen">crates.io/crates/csbindgen</a></li>
</ul>
<p>めちゃくちゃスムーズにネイティブコードがC#から呼べるようになります。すごい簡単に。超便利。こりゃもうばんばんネイティブコード書きたくなりますね……！ただし書くコードはRustのみ対応です。いや、別にRustでいいでしょ、Rustはいいぞ……！</p>
<p>しかしまず前提として言っておくと、ネイティブコードは別に偉くもなければ、必ず速いというわけでもないので、極力書くのはやめましょう。C#で書くべき、です。高速なコードが欲しければ、ネイティブコードに手を出す前にC#で速くすることを試みたほうがずっと良いです。C#は十分高速に書くことのできる言語です！ネイティブコードを書くべきでない理由は山ほどありますが、私的に最大の避けたい理由はクロスプラットフォームビルドで、今の世の中、ターゲットにしなければならないプラットフォーム/アーキテクチャの組み合わせは、普通にやっていても10を超えてしまいます。win/linux/osx/iOS/Android x x86/x64/arm。C#では .NET のランタイムやUnityが面倒見てくれますが、ネイティブコードの場合はこれを自前で面倒みていく必要があります。そこそこ面倒みてくれるはずのUnityだって辛いのに、それにプラスして俺々ビルド生態系を加えるのはかなり厳しいものがある。</p>
<p>とはいえ、C#をメインに据えつつもネイティブコードを利用すべきシチュエーションもあるにはあります。</p>
<ul>
<li>Android NDKや .NET unmanaged hosting APIなど、ネイティブAPIしか提供されていないものを使いたい場合</li>
<li>C で作られているネイティブライブラリを利用したい場合</li>
<li>ランタイムのライブラリの利用を避けたい場合、例えばUnityで .NET のSocket(Unityの場合 .NET のランタイムが古いのでパフォーマンスを出しにくい)を避けてネイティブのネットワークコードを書くのには一定の道理がある</li>
</ul>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/core/deploying/native-aot/">NativeAOT</a>という解決策もなくはないですが、まだそんなに現実的でもなければ、用途的にもこういうシチュエーションでは限定的でもあるので、そこは素直にネイティブコードを書いていくべき、でしょう。</p>
<p>そこでの最初の選択肢は当然C++なわけですが、いやー、C++のクロスプラットフォームビルドは大変だしなあ。となると、最近評判を聞く<a href="https://ziglang.org/ja/">Zig</a>はどうだろうか、と試してみました、が、撤退。目指すコンセプトは大変共感するところがあるのですが(FFIなしのCライブラリとの統合や、安全だけど複雑さを抑えた文法など)、まだ、完成度が、かなり、厳しい……。</p>
<p>で、最後の選択肢が<a href="https://www.rust-lang.org/ja">Rust</a>でした。FFIなしでの呼び出しではないものの<a href="https://crates.io/crates/cc">cc crate</a>や<a href="https://crates.io/crates/cmake">cmake crate</a>といったライブラリを使うと自然に統合されるし、<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>によるバインディングの自動生成はよく使われているだけあってめっちゃ安定して簡単に生成できます。ていうかZigが全然安定感なかった（シームレスなCとの統合とは……）ので雲泥の差でびっくりした。開発環境もまぁまぁ充実してるしコマンド体系も現代的。クロスプラットフォームビルドも容易！そして難しいと評判で避けていた言語面でも、いや、全然いいね。仕組みが理屈で納得できるし、C#とは文法面でもあまり離れていないので、全然すんなりと入れました。もちろん難しいところも多々ありますが、ラーニングカーブはそんなに急ではない、少なくとも最近のモダンC#をやり込んでる人なら全然大丈夫でしょう……！</p>
<p>と、いうわけで、しかし主な用途はC#からの利用で、特にCライブラリの取り込みにRustを使おうと決めたわけですが、C#に対して公開するためのコードが膨大でキツかったので、自動化したかったんですね。DllImportの自動化は<a href="https://www.swig.org/">SWIG</a>や<a href="https://github.com/mono/CppSharp">CppSharp</a>というのもありますが、普通のC++をそのまま持ってこようとする思想は、複雑なコードを吐いてしまったりで正直イマイチだな、と。</p>
<p>csbindgenは、まず、面倒なところをRustのbindgenに丸投げです。複雑なC(C++)のコードを解析対処にするから複雑になるのであって、bindgenによって綺麗なRustに整形してもらって、生成対象にするのはそうしたFFI向けに整理されたRustのみを対象にすることで、精度と生成コードの単純さを担保しました。自分でネイティブコードを書く場合も、RustはFFI不可能な型を公開しようとすると警告も出してくれるので、必然的に生成しやすい綺麗なコードになっています。型もRustは非常に整理されているため、C#とマッピングしやすくなっています。C#もまた近年のnintや<code>delegate*</code>、.NET 6からの<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.clong">CLong</a>などの追加によって自然なやり取りができるようになりました。csbindgenはそれら最新の言語機能を反映することで、自然で、かつパフォーマンスの良いバインディングコードを生成しています。</p>
<h2>Getting Started</h2>
<p>コンフィグにビルド時依存に追加してもらって、<code>build.rs</code>というコンパイル前呼び出し(Rustのコードでpre-build書ける機能やビルド時依存を追加できる機能はとても良い)に設定を入れるだけです、簡単！</p>
<pre><code class="language-toml">[build-dependencies]
csbindgen = &quot;1.2.0&quot;
</code></pre>
<pre><code class="language-rust">// extern &quot;C&quot; fnが書かれているlib.rsを読み取って DllImport[&quot;nativelib&quot;]なコードを&quot;NativeMethods.g.cs&quot;に出力する
csbindgen::Builder::default()
    .input_extern_file(&quot;lib.rs&quot;)
    .csharp_dll_name(&quot;nativelib&quot;)
    .generate_csharp_file(&quot;../dotnet/NativeMethods.g.cs&quot;)
    .unwrap();
</code></pre>
<p>単純なコードを例に出すと、このx, yを受け取ってintを返す関数は</p>
<pre><code class="language-csharp">#[no_mangle]
pub extern &quot;C&quot; fn my_add(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>こういったC#コードを生成します。</p>
<pre><code class="language-csharp">// NativeMethods.g.cs
using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;nativelib&quot;;

        [DllImport(__DllName, EntryPoint = &quot;my_add&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int my_add(int x, int y);
    }
}
</code></pre>
<p>直感的で単純な出力です、逆にそれがいい、むしろそれがいい。生成に対応している型はプリミティブ以外にもstructやunion、enum、関数やポインターなどRustのFFIで流せる型のほとんどには対応しています。</p>
<p>また、Rustのbindgenやcc/cmake crateを併用すると、CのライブラリをC#に簡単に持ちこむことができます。例えば圧縮ライブラリの<a href="https://github.com/lz4/lz4">lz4</a>は、csbindgenでの生成の前にbindgenとccの設定も足してあげると</p>
<pre><code class="language-csharp">// lz4.h を読み込んで lz4.rs にRust用のbindingコードを出力する
bindgen::Builder::default()
    .header(&quot;c/lz4/lz4.h&quot;)
    .generate().unwrap()
    .write_to_file(&quot;lz4.rs&quot;).unwrap();

// cc(C Compiler)によってlz4.cを読み込んでコンパイルしてリンクする
cc::Build::new().file(&quot;lz4.c&quot;).compile(&quot;lz4&quot;);

// bindgenの吐いたコードを読み込んでcsファイルを出力する
csbindgen::Builder::default()
    .input_bindgen_file(&quot;lz4.rs&quot;)
    .rust_file_header(&quot;use super::lz4::*;&quot;)
    .csharp_entry_point_prefix(&quot;csbindgen_&quot;)
    .csharp_dll_name(&quot;liblz4&quot;)
    .generate_to_file(&quot;lz4_ffi.rs&quot;, &quot;../dotnet/NativeMethods.lz4.g.cs&quot;)
    .unwrap();
</code></pre>
<p>これでC#から呼び出せるコードが簡単に生成できます。ビルドもRustで <code>cargo build</code> するだけでCのコードがリンクされてDLLに含まれています。</p>
<pre><code class="language-csharp">// NativeMethods.lz4.g.cs

using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;liblz4&quot;;

        [DllImport(__DllName, EntryPoint = &quot;csbindgen_LZ4_compress_default&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int LZ4_compress_default(byte* src, byte* dst, int srcSize, int dstCapacity);

        // snip...
    }
}
</code></pre>
<p>試してもらうと、本当に簡単にCライブラリが持ち込みができて感動します。Rustやbindgenがとにかく偉い。</p>
<p>csbindgenはUnityでの利用も念頭においているので、よくあるiOSでのIL2CPPだけ __Internal にしたいみたいなシチュエーションでも</p>
<pre><code class="language-csharp">#if UNITY_IOS &amp;&amp; !UNITY_EDITOR
    const string __DllName = &quot;__Internal&quot;;
#else
    const string __DllName = &quot;nativelib&quot;;
#endif
</code></pre>
<p>といったような生成ルールの変更がコンフィグに含めてあります。とても実用的で気が利いてます。</p>
<h2>LibraryImport vs DllImport</h2>
<p>.NET 7から<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke-source-generation">LibraryImport</a>という新しい呼び出しのためのソースジェネレーターが追加されました。これはDllImportのラッパーになっていて、DllImportは、本来ネイティブコードとやり取りできない型(例えば配列や文字列などの参照型はC#のヒープ上に存在するもので、ネイティブ側に渡せない)を裏で自動的にやってくれるという余計なお世話が含まれていて、それがややこしさや性能面、そしてNativeAOTビリティの欠如などの問題を含んでいたので、そういう型が渡された場合はLibraryImportの生成するC#コードで吸収した上で、byte* としてDllImportに渡すようなラッパーが生成されるようになっています。</p>
<p>つまり余計なお世話をする本来ネイティブコードとやり取りできない型を生成しないようにすればDllImportでも何の問題もないので、今回はDllImportでの生成を選んでいます。そのほうがUnityでも使いやすいし。</p>
<p>Win32のAPIをDllImportで簡単に呼び出せるようにするために暗黙的な自動変換を多数用意しておく、というのは時代背景的には理解できます。C#がWindowsのためだけの言語であり、時折Win32 APIの呼び出しが必須なこともあったのは事実であり、便利な側面もあったでしょう。しかし現在はWindowsのためだけの言語でもなく、またWin32 APIの呼び出しに関しては<a href="https://github.com/microsoft/CsWin32">CsWin32</a>というSource Generatorを活用した支援も存在します。</p>
<p>もう現代では、そうしたDllImportの古い設計を引きずって考える必要はない、頼るべきではないでしょう。つまり参照型を渡したり[In]や[Out]は使うべきではないし、変換を考慮した設計を練る必要もありません。実際 .NET 7ではそうしたDllImportの機能を使うとエラーにする<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.disableruntimemarshallingattribute">DisableRuntimeMarshallingAttribute</a>が追加されました。</p>
<p>ポインターに関しても今はあまり忌避するものではないと思っています。そもそもネイティブとの通信はunsafeだし、Spanによって比較的使いやすい型に変換することも容易なので。中途半端に隠蔽するぐらいなら、DllImportするレイヤーではポインターはポインターとして持っておきましょう。C#として使いやすくするのは、その外側できっちりやればいい話です、DllImportで吸収するものではない。というのが今風の設計思想であると考えています。なんだったら私はIntPtrよりvoid*のほうが好きだよ。</p>
<h2>コールバックの相互受け渡し</h2>
<p>C# -&gt; Rust あるいは Rust -&gt; C# でコールバックを渡し合ってみましょう。まずRust側はこんな風に書くとします。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn csharp_to_rust(cb: extern &quot;C&quot; fn(x: i32, y: i32) -&gt; i32) {
    let sum = cb(10, 20); // invoke C# method
    println!(&quot;{sum}&quot;);
}

#[no_mangle]
pub extern &quot;C&quot; fn rust_to_csharp() -&gt; extern fn(x: i32, y: i32) -&gt; i32 {
    sum // return rust method
}

extern &quot;C&quot; fn sum(x:i32, y:i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>C#のメソッドを受け取ったら、それを読んで表示(println)するだけ、あるいは足し算する関数をC#に渡すだけ、のシンプルなメソッドです。生成コードは以下のようなものになります。</p>
<pre><code class="language-csharp">[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(delegate* unmanaged[Cdecl]&lt;int, int, int&gt; cb);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern delegate* unmanaged[Cdecl]&lt;int, int, int&gt; rust_to_csharp();
</code></pre>
<p><code>delegate* unmanaged[Cdecl]&lt;int, int, int&gt;</code> というのは、あまり見慣れない定義だと思うのですが、C# 9.0から追加された本物の<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers">関数ポインター</a>になります。定義を手書きするのは少しややこしいですが、自動生成されるので特に問題なしでしょう（？）。使い勝手はかなりよく、普通の静的メソッドのように扱えます。</p>
<pre><code class="language-csharp">// ネイティブ側に渡したい静的メソッドはUnmanagedCallersOnlyを付ける必要がある
[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
static int Sum(int x, int y) =&gt; x + y;

// &amp;で関数ポインターを取得して渡す
NativeMethods.csharp_to_rust(&amp;Sum);

// Rustからdelegate*を受け取る
var f = NativeMethods.rust_to_csharp();

// 受け取った関数ポインターは普通に呼び出せる
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>インスタンスメソッドを渡せないのか？というと渡せません。Cとの相互運用にそんなものはない。どうでもいい勝手な変換はしなくていい。第一引数にコンテキスト(void*)を受け取るコードを用意しておけばいいでしょう。</p>
<p>ところで、UnityもC# 9.0対応、しているし関数ポインターも使えるには使えるのですが、<a href="https://docs.unity3d.com/ja/2021.3/Manual/CSharpCompiler.html">Extensible calling conventions for unmanaged function pointers is not supported</a>です。UnmanagedCallersOnlyAttributeもないしね。Unity Editor上では普通に動いちゃったりとかしますが、IL2CPPでは動かないのでちゃんと対応しましょう。csbindgenでは <code>csharp_use_function_pointer(false)</code> というオプションを設定すると、従来のデリゲートを使用したコードを出力します。</p>
<pre><code class="language-csharp">// csharp_use_function_pointer(false) の場合の出力結果、専用のデリゲートを一緒に吐き出すようになる
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int csharp_to_rust_cb_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(csharp_to_rust_cb_delegate cb);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int rust_to_csharp_return_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern rust_to_csharp_return_delegate rust_to_csharp();

// MonoPInvokeCallback属性を静的メソッドにつける(typeofでデリゲートを設定)
[MonoPInvokeCallback(typeof(NativeMethods.csharp_to_rust_cb_delegate))]
static int Sum(int x, int y) =&gt; x + y;

// そのまま渡す
NativeMethods.csharp_to_rust(Method);

// 受け取る関数ポインターに関しては .NET の場合と一緒
var f = NativeMethods.rust_to_csharp();
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>面倒くさい専用のデリゲートも同時に出力してくれるので、定義はそこそこ楽になります（Action/Funcといった汎用デリゲートを使うと場合によりクラッシュしてしまったので、必ずそれぞれのパラメーター専用のデリゲートを出力するようにしています）。概ねcsbindgenがよしなに動くように面倒見てあげるので、属性の違いだけ考えればほぼ問題はありません。</p>
<h2>コンテキスト</h2>
<p>多値返しみたいなのは、普通にStructを作ってくださいという話になって、その場合は、C#側でStructはコピーされて、Rust側のメモリからはすぐ消えるということになります。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn return_tuple() -&gt; MyTuple {
    MyTuple { is_foo: true, bar: 9999 }
}

#[repr(C)]
pub struct MyTuple {
    pub is_foo: bool,
    pub bar: i32,
}
</code></pre>
<p>もう少し寿命を長く、返却するStructをポインターで返して状態を持ちたい、という場合はRust的には少し工夫が必要です。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_context() -&gt; *mut Context {
    let ctx = Box::new(Context { foo: true });
    Box::into_raw(ctx)
}

#[no_mangle]
pub extern &quot;C&quot; fn delete_context(context: *mut Context) {
    unsafe { Box::from_raw(context) };
}

#[repr(C)]
pub struct Context {
    pub foo: bool,
    pub bar: i32,
    pub baz: u64
}
</code></pre>
<pre><code class="language-csharp">// C#側、Context*を受け取って
var context = NativeMethods.create_context();

// なにか色々したりずっと持っていたり

// 最後に明示的にfreeしにいく
NativeMethods.delete_context(context);
</code></pre>
<p><code>Box::new</code> でヒープ上にデータを確保して、<code>Box::into_raw</code>でRust上でのメモリ管理から外します。Rustは通常だとスコープが外れると即座にメモリを返却する、のですが、寿命をRust管理外のC#に飛ばすので、素直に（？）unsafeにRust上の管理から外してしまうのが普通に素直でしょう。Rust側で確保しているメモリを開放する場合は、<code>Box::from_raw</code>でRust上の管理に戻します。そうするとスコープが外れたらメモリ返却という通常の動作をして、返却が完了します。</p>
<p>この辺はRustだから難しい！という話ではなく、C#でもfixedスコープを外れてポインタを管理したい場合には <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して手動でunsafeな管理しなければいけないので、完全に同じ話です。そう考えると、むしろ素直にC#と変わらない話でいいですね。</p>
<p>なお、C#上でこうしたコンテキストの管理をする場合に専用のSafeHandleを作って、それにラップするという流儀がありますが、大仰で、基本的にはそこまでやる必要はないと思ってます。No SafeHandle。そもそも境界越えというunsafeなことをしているのだから、最後まで自己責任でいいでしょう。</p>
<p>csbindgenは戻り値にstructが指定されていると、C#側にも同様のものを生成しに行ってしまいますが、Rust内だけで使うのでC#側には内容公開したくない、というか参照(Box)とかも含まれてるから公開できないし、みたいな場合もあると思います。その場合は <code>c_void</code> を返してください。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_counter_context() -&gt; *mut c_void {
    let ctx = Box::new(CounterContext {
        set: HashSet::new(),
    });
    Box::into_raw(ctx) as *mut c_void // voidで返す
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn insert_counter_context(context: *mut c_void, value: i32) {
    let mut counter = Box::from_raw(context as *mut CounterContext); // as で型を戻す
    counter.set.insert(value);
    Box::into_raw(counter); // contextを使い続ける場合はinto_rawを忘れないように
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn delete_counter_context(context: *mut c_void) {
    let counter = Box::from_raw(context as *mut CounterContext);
    for value in counter.set.iter() {
        println!(&quot;counter value: {}&quot;, value)
    }
}

// C#側には公開しない
pub struct CounterContext {
    pub set: HashSet&lt;i32&gt;,
}
</code></pre>
<pre><code class="language-csharp">// C#側では ctx = void* として受け取る
var ctx = NativeMethods.create_counter_context();
    
NativeMethods.insert_counter_context(ctx, 10);
NativeMethods.insert_counter_context(ctx, 20);

NativeMethods.delete_counter_context(ctx);
</code></pre>
<p>この辺、<code>PhantomData&lt;T&gt;</code>を使って格好良く処理する手法も一応あるんですが、正直複雑になるだけなので、素直に <code>void*</code> ベースでやり取りする、に倒したほうがむしろ健全でいいのではと思っています。どっちにしろunsafeな処理してるんだから素直にunsafeな業を受け入れるべき！</p>
<h2>Stringと配列のマーシャリング</h2>
<p>Stringと配列は、C#とRustでそれぞれ構造が違うので、そのままやり取りはできません。ポインタと長さ、つまりC#でいうところのSpanのみがやり取りできます。Span的な処理をするだけならゼロコピーですが、Stringや配列に変換したくなったら、C#とRust、どちらの側でも新規のアロケーションが発生します。これはネイティブコードを導入することの弱みで、Pure C#で通したほうが融通が効く（或いはパフォーマンスに有利に働く）ポイントですね。まあ、ともあれ、つまり基本はSpanです。DllImport上でStringを受けたり配列を受けたりしてはいけません、その手の自動変換にゆだねてはダメ！アロケーションも自己責任で明示的に。</p>
<p>さて、まずは文字列ですが、こういったケースでやり取りする文字列の種類は3つ、UTF8とUTF16と<a href="https://ja.wikipedia.org/wiki/%E3%83%8C%E3%83%AB%E7%B5%82%E7%AB%AF%E6%96%87%E5%AD%97%E5%88%97">ヌル終端文字列</a>、です。UTF8はRustの文字列(RustのStringは<code>Vec&lt;u8&gt;</code>)、C#の文字列はUTF16、そしてCのライブラリなどはヌル終端文字列を返してくることがあります。</p>
<p>今回は例なので明示的にRust上でヌル終端文字列を返してみます。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_c_string() -&gt; *mut c_char {
    let str = CString::new(&quot;foo bar baz&quot;).unwrap();
    str.into_raw()
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_c_string(str: *mut c_char) {
    unsafe { CString::from_raw(str) };
}
</code></pre>
<pre><code class="language-csharp">// null-terminated `byte*` or sbyte* can materialize by new String()
var cString = NativeMethods.alloc_c_string();
var str = new String((sbyte*)cString);
NativeMethods.free_c_string(cString);
</code></pre>
<p>C#上では new Stringでポインタ(<code>sbyte*</code>)を渡すとヌル終端を探してStringを作ってくれます。明示的にアロケーションしているという雰囲気がいいですね。ポインタはこの場合Rustで確保したメモリなので、C#のヒープ上にコピー（新規String作成）したなら、即返却してやりましょう。</p>
<p>Rustで確保したUTF8、byte[]、あるいはint[]などとにかく配列全般の話はもう少し複雑になってきます。Rustでの配列的なもの(<code>Vec&lt;T&gt;</code>)をC#に渡すにあたっては、ポインタと長さをC#に渡せばOKといえばOKなのですが、解放する時にそれだけだと困ります。<code>Vec&lt;T&gt;</code>の実態はポインタ、長さ、そしてキャパシティの3点セットになっているので、この3つを渡さなきゃいけないのですね。そして、都度3点セットを処理するのも面倒です、Rust的なメモリ管理を外したり戻したりの作業もあるし。</p>
<p>というわけでちょっと長くなりますが以下のようなユーティリティーを用意しましょう。これの元コードは(元)Rustの開発元であるMozillaのコードなので安全安心です……！</p>
<pre><code class="language-rust">#[repr(C)]
pub struct ByteBuffer {
    ptr: *mut u8,
    length: i32,
    capacity: i32,
}

impl ByteBuffer {
    pub fn len(&amp;self) -&gt; usize {
        self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;)
    }

    pub fn from_vec(bytes: Vec&lt;u8&gt;) -&gt; Self {
        let length = i32::try_from(bytes.len()).expect(&quot;buffer length cannot fit into a i32.&quot;);
        let capacity = i32::try_from(bytes.capacity()).expect(&quot;buffer capacity cannot fit into a i32.&quot;);

        // keep memory until call delete
        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr(),
            length,
            capacity,
        }
    }

    pub fn from_vec_struct&lt;T: Sized&gt;(bytes: Vec&lt;T&gt;) -&gt; Self {
        let element_size = std::mem::size_of::&lt;T&gt;() as i32;

        let length = (bytes.len() as i32) * element_size;
        let capacity = (bytes.capacity() as i32) * element_size;

        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr() as *mut u8,
            length,
            capacity,
        }
    }

    pub fn destroy_into_vec(self) -&gt; Vec&lt;u8&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let capacity: usize = self.capacity.try_into().expect(&quot;buffer capacity negative or overflowed&quot;);
            let length: usize = self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;);

            unsafe { Vec::from_raw_parts(self.ptr, length, capacity) }
        }
    }

    pub fn destroy_into_vec_struct&lt;T: Sized&gt;(self) -&gt; Vec&lt;T&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let element_size = std::mem::size_of::&lt;T&gt;() as i32;
            let length = (self.length * element_size) as usize;
            let capacity = (self.capacity * element_size) as usize;

            unsafe { Vec::from_raw_parts(self.ptr as *mut T, length, capacity) }
        }
    }

    pub fn destroy(self) {
        drop(self.destroy_into_vec());
    }
}
</code></pre>
<p>Box::into_raw/from_rawのVec版という感じで、from_vecしたタイミングでメモリ管理から外すのと、destroy_into_vecするとメモリ管理を呼び側に戻す（何もしなければスコープを抜けて破棄される）といったような動作になっています。これはC#側でも(csbindgenによって)定義が生成されているので、メソッドを追加してやります。</p>
<pre><code class="language-csharp">// C# side span utility
partial struct ByteBuffer
{
    public unsafe Span&lt;byte&gt; AsSpan()
    {
        return new Span&lt;byte&gt;(ptr, length);
    }

    public unsafe Span&lt;T&gt; AsSpan&lt;T&gt;()
    {
        return MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;T&gt;(ptr), length / Unsafe.SizeOf&lt;T&gt;());
    }
}
</code></pre>
<p>これでByteBuffer*で受け取ったものを即Spanに変換できるようになりました！というわけで、Rust上の通常のstring、byte[]、それとint[]の例を見てみると</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_string() -&gt; *mut ByteBuffer {
    let str = format!(&quot;foo bar baz&quot;);
    let buf = ByteBuffer::from_vec(str.into_bytes());
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_string(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need String, use String::from_utf8_unchecked(buf.destroy_into_vec()) instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;u8&gt; = vec![1, 10, 100];
    let buf = ByteBuffer::from_vec(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;u8&gt;, use buf.destroy_into_vec() instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_i32_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;i32&gt; = vec![1, 10, 100, 1000, 10000];
    let buf = ByteBuffer::from_vec_struct(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_i32_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;i32&gt;, use buf.destroy_into_vec_struct::&lt;i32&gt;() instead.
    buf.destroy();
}
</code></pre>
<p>ByteBuffer自体の管理を外す(into_raw)が必要なのと、from_rawで戻したあとの中身のByteBufferもdestoryかinto_vecしなきゃいけないという、入れ子の管理になっているというのが紛らわしくて死にそうになりますが、ソウイウモノということで諦めましょう……。Drop traitを実装しておくことでクリーンナップ側の処理はもう少しいい感じにできる余地がありますが、Drop traitを実装しないことの理由もそれなりにある（と、Mozillaが言っている）ので、トレードオフになっています。</p>
<p>C#側では、とりあえずAsSpanして、あとはよしなにするという感じですね。</p>
<pre><code class="language-csharp">var u8String = NativeMethods.alloc_u8_string();
var u8Buffer = NativeMethods.alloc_u8_buffer();
var i32Buffer = NativeMethods.alloc_i32_buffer();
try
{
    var str = Encoding.UTF8.GetString(u8String-&gt;AsSpan());
    Console.WriteLine(str);

    Console.WriteLine(&quot;----&quot;);

    var buffer = u8Buffer-&gt;AsSpan();
    foreach (var item in buffer)
    {
        Console.WriteLine(item);
    }

    Console.WriteLine(&quot;----&quot;);

    var i32Span = i32Buffer-&gt;AsSpan&lt;int&gt;();
    foreach (var item in i32Span)
    {
        Console.WriteLine(item);
    }
}
finally
{
    NativeMethods.free_u8_string(u8String);
    NativeMethods.free_u8_buffer(u8Buffer);
    NativeMethods.free_i32_buffer(i32Buffer);
}
</code></pre>
<p>Rust側で確保したメモリはRust側で解放する！という基本に関しては忠実に守っていきましょう。この例だとC#側で処理したら即解放なので、いい感じにしてくれよ、なんだったらDllImportで暗黙的に自動処理最高、みたいな気になるかもしれませんが、もう少し長寿命で持つケースもあるので、やはりマニュアルでちゃんと解放していきましょう。ていうか暗黙的なアロケーションは一番最悪じゃないです？？？</p>
<p>最後に、C#で確保したメモリをRust側で使う場合の例をどうぞ。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_string(utf16_str: *const u16, utf16_len: i32) {
    let slice = std::slice::from_raw_parts(utf16_str, utf16_len as usize);
    let str = String::from_utf16(slice).unwrap();
    println!(&quot;{}&quot;, str);
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_utf8(utf8_str: *const u8, utf8_len: i32) {
    let slice = std::slice::from_raw_parts(utf8_str, utf8_len as usize);
    let str = String::from_utf8_unchecked(slice.to_vec());
    println!(&quot;{}&quot;, str);
}


#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_bytes(bytes: *const u8, len: i32) {
    let slice = std::slice::from_raw_parts(bytes, len as usize);
    let vec = slice.to_vec();
    println!(&quot;{:?}&quot;, vec);
}
</code></pre>
<pre><code class="language-csharp">var str = &quot;foobarbaz:あいうえお&quot;; // JPN(Unicode)
fixed (char* p = str)
{
    NativeMethods.csharp_to_rust_string((ushort*)p, str.Length);
}

var str2 = Encoding.UTF8.GetBytes(&quot;あいうえお:foobarbaz&quot;);
fixed (byte* p = str2)
{
    NativeMethods.csharp_to_rust_utf8(p, str2.Length);
}

var bytes = new byte[] { 1, 10, 100, 255 };
fixed (byte* p = bytes)
{
    NativeMethods.csharp_to_rust_bytes(p, bytes.Length);
}
</code></pre>
<p>std::slice::from_raw_partsでSliceを作って、あとはよしなに処理したいことをします。関数を超えて長い寿命を持たせたいならコピー(String作りなりVec作るなり)は必須になってきます。Rust側で確保したメモリはRust側で解放する、のと同じように、C#側で確保したメモリはC#側で解放する、のが重要です。C#の場合はfixedスコープを抜けて参照を持っていない場合は、そのうちGCが処理してくれるでしょう、といった話ですね。</p>
<p>なお、fixedを超えてC#でもう少し長い寿命で持ち回したいときは <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して持ち回します。</p>
<h2>Rust for C# Developer</h2>
<p>Rustは、正直すごい気に入ってます。C#の次に気に入りました……！まぁ正直、これで全部やる、Webもなにもかも作る、みたいなのはヤバいかな、と思います。RustでWebやりたいって人はあれでしょ、型がついてて開発環境が充実していてエコシステムが回ってる言語がいいんでしょ？ちょうどいい言語があるんですよ、C#という。……。ではあるんですが、ネイティブが必要って局面で、やりたくないーって逃げたり、NativeAOTがなんとかしてくれるだのといった現実逃避したりせず、ちゃんと正面から向き合えるようになったということはいいことです。</p>
<p>で、実際RustはかなりC#erに馴染む道具だと思っていて、そもそもインターフェイスがないかわりにstructとジェネリクスとtrait(インターフェイスみたいなやつ)で処理するってのは、別にそれC#でもやってますよ！C#のパフォーマンス最速パターンってstructにインターフェイス実装してジェネリクスの型制約でインターフェイス指定してボクシング/仮想メソッド呼び出し回避でstruct投げ込むことですからね。ようはC#の最速パターンだけが強制されてるんだと思えば何も違和感がない。</p>
<p>インスタンスメソッドがないかわりに全部拡張メソッドみたいな雰囲気なのも、いやー、C#も、もはやインスタンスメソッドと拡張メソッド、どっちで実装すればいいかなーって切り分けに悩むこともあるし、<a href="https://ufcpp.net/blog/2023/3/extensions/">C# 12候補のExtensions</a>なんてきたら完全にどこで実装すりゃいいのかわからんわ、ってなるので、拡張メソッド一択(impl, trait)ですよ、みたいなのはすっきり整理されていて逆にいい。</p>
<p>シンタックスも自然というかC系の多数派に寄り添った感じで親しみやすいし、ドットでメソッド繋げていくので、馴染み深いオブジェクト指向的な手触りが十分ある。それとミュータブルに寛容なところがいいですね。関数型にありがちなイミュータブル至上主義ではなく、どちらかというとメモリそこにあるんだからミュータブルやろ、みたいな雰囲気なのがとてもいい。無駄もないし。所有権周りが厳密なのでミュータブルであっても固めな手応えなのは、これでいいんだよというかこれで的な何かではある。</p>
<p>マクロはコンパイル時ExpresionTreeみたいなもので、proc-macroはSource Generatorみたいなものなので、何が可能になるかすぐに理解できるし、便利さもよくわかる。ていうかコンパイル時ExpressionTreeはC#にも欲しい（実行時だからコスト重いのであんま使わないのでコンパイル時に解決するならもっとばんばん使えるはずなんだよねえ）。ただ、自由度がとても高いせいでマクロに入ると入力補完が完全に効かなくなる。そして自由度が高いのでマクロでDSL的な流れに高級ライブラリほどなりがちで、完全にマニュアル引きが必要になってくるのが、見た目はキレイにおさまるけど書き味はよくないな、的な体感になるのがもったいない。その点でいうとC#はやっぱ入力補完最優先な言語で、一貫した安定感を提供しているのはとても良いですね。</p>
<p>キツいかなーと思うのは所有権がどうとかっていうよりも、ジェネリクスの見た目がキツい。C#だったらインターフェイスで動的ディスパッチで整理されているものが、ジェネリクスで静的ディスパッチに倒れているのでジェネリクスの出現率がめっちゃ高い。いや、だってC#でもジェネリクスでると読みやすさ的には一段落下がるわけじゃないですか、それが当たり前って感じだと、慣れとかって問題じゃなく見やすさレベルは下がる。更にその上にジェネリクスがネストするのが当たり前。C#だったらジェネリクスがネストしてるのは見やすさレベル最底辺なので極力出現しないようにしたいって感じなのですが、Rustだと日常茶飯事に出てくる。<code>Option&lt;Rc&lt;RefCell&lt;_&gt;&gt;&gt;</code>とかも全然普通に出現するのが、うーむ。理屈では納得いくから特に文句があるようでなにもないんですが。</p>
<p>なんだったらパターンマッチも別に好きじゃないしOptionもResultも好きじゃないしnullの何が悪いんだよぐらいの気持ちにならなくもないんですが、まぁそれはそれ。でも全体的には凄い良いですね、ほんと。</p>
<h2>まとめ</h2>
<p>ところで<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>のReadMeのほうには更にもっといっぱい変換パターンを紹介していますので、是非そちらもチェックしてみてください。</p>
<p>ネイティブ呼び出しは定義の部分でも、二重定義がそもそもダルいうえに、かなり気を使わなきゃいけないことがなにげに多くて割と大変というか知識量と単純作業量を要求してくるのですが、csbindgenはその部分を完全自動化してくれます。自分でも使っててネイティブコードめっちゃ楽……！という気になります。事実楽。すごい。その後のメモリ管理に関しては、そこはまぁ思う存分悩んでくれという話になるのですが、もはや複雑な点がそれだけに落ち着いたという点では、やはり革命的に便利なのでは？という気になります。</p>
<p>Cのライブラリを持ってくるのも圧倒的に楽なので、私の中でもちょっと考え方が変わってきました。今までは割とPure C#実装至上主義、みたいなところがあったんですが、うまい切り分け、使い分けみたいなのを考えられるようになりました。そして、Cライブラリ利用がより自由になると、まさに<a href="https://cysharp.co.jp/">Cysharp</a>の掲げる「C#の可能性を切り開いていく」ことにまた一つ繋がってしまったな、と。</p>
<p>まずはこの後に数個、csbindgenを活用したC#ライブラリを提供する予定があります！のですが、その前に、Rustかー、とは思わずに是非csbindgen、試してみてもらえると嬉しいです。</p>
</div>
<h1><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></h1>
<ul class="date"><li>2023-01-30</li></ul>
<div class="entry_body"><p>ついこないだの<a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a>は、SoAになってるとSIMDを適用しやすいよ、という話だったのですが、そもそもSIMD手書きはカジュアルにやらないし、気合い入れてSIMD書くシチュエーションなら構造も気合い入れて専用に設計するよなぁ。と、なると、カジュアルにSIMD使えるライブラリが必要で、まぁLINQですね、と。</p>
<ul>
<li><a href="https://github.com/Cysharp/SimdLinq">Cysharp/SimdLinq</a></li>
</ul>
<p>これを入れると別にSoA関係なく、SIMDが適用できる状態(例えばint[]にSum)だと、自動的にSIMDが適用されるようになります。そして、実際めちゃくちゃ速い。</p>
<p><img src="https://user-images.githubusercontent.com/46207/215410106-b68d8567-5abf-4aa4-a050-a803b1913187.png" alt="" /></p>
<p>SIMDとLINQの組み合わせが威力を発揮するというのは、別に新しいことではなく、そもそも .NET 7でも<a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#linq">Performance Improvements in .NET 7 LINQ</a>で、幾つかのメソッドが内部でSIMD化されて高速化されていることが発表されています。しかし、 .NET 7のSIMD対応は非常に限定的なもので、具体的には<code>int[]</code>の<code>Average</code>,<code>Min</code>,<code>Max</code>、それと<code>long[]</code>の<code>Min</code>,<code>Max</code>だけです。これには理由はなくはないのですが、本来SIMD対応できる範囲はもっと広いため、これでは非常にもったいない。</p>
<p>SimdLinqを適用できるメソッドは <code>Sum</code>, <code>Average</code>, <code>Min</code>, <code>Max</code>, <code>MinMax</code>, <code>Contains</code>, <code>SequenceEqual</code>、要素の型は <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code> int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code>、コレクションの型は <code>T[]</code>, <code>List&lt;T&gt;</code>, <code>Span&lt;T&gt;</code>, <code>ReadOnlySpan&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, <code>ReadOnlyMemory&lt;T&gt;</code> と理屈上SIMD化できるものを全て詰め込みました。特に<code>Span&lt;T&gt;</code>/<code>ReadOnlySpan&lt;T&gt;</code>は通常のLINQでは使えない（メソッドが定義されていない）ので、有益です。また、Min, Maxを同時に取得する<code>MinMax</code>というメソッドを独自に追加しています。</p>
<p>専用メソッドを呼ばせる（例えば<code>SumSimd()</code>とか)ようでは使いにくいと思ったので、現在のコードを何も弄らずとも、ライブラリ参照してglobal usingを設定すれば、全ての適用可能なメソッドに自動適用される仕組みにしました。これは同名メソッドを定義して、具象型のほうにオーバーロード解決が優先採用されることを利用しています。</p>
<h2>使い方</h2>
<p>なので、使い方もなにもなく、usingすれば勝手にSimdLinqになって高速化されます。</p>
<pre><code class="language-csharp">using SimdLinq; // enable SimdLinq extension methods

var array = Enumerable.Range(1, 100000).ToArray();

var sum = array.Sum(); // used SimdLinqExtensions.Sum
</code></pre>
<p>using忘れちゃうというのはあるので、そこでglobal usingです。csprojに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Using Include=&quot;SimdLinq&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>というのを仕込んでやれば、SimdLinqが使える場合はSimdLinqに、そうじゃないものは普通のLinqでオーバーロードが解決されるようになります。便利。</p>
<p>具体的にSimdLinqが適用されるメソッドは以下のものになります。</p>
<ul>
<li><code>Sum</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>LongSum</code> for <code>int</code>, <code>uint</code></li>
<li><code>Average</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Min</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Max</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>MinMax</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Contains</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>SequenceEqual</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
</ul>
<h2>互換性と安全性</h2>
<p>.NET 7の標準に、このSimdLinqのようなアグレッシブなSIMD化が入らなかった理由は、互換性と安全性になります。え、安全じゃないの？というと怖くなるので、何が違うのかはしっかり把握しておきましょう。別に危険、というわけではないですが。</p>
<p>まずSumとAverage(Averageの中身はSumしたのをLengthで割るだけなので中身は実質Sum)ですが、LINQのSumはcheckedで、オーバーフローすると例外を吐きます。SimdLinqはuncheckedです、つまりオーバーフローするとそのままオーバーフローしたまま結果を返します。checkedのほうが挙動としてはいいんですが、SIMD演算がオーバーフローのチェックできないので、SimdLinqではuncheckedとして提供しています。オーバーフローに関しては自己責任で。さすがにbyteのSumとかだとすぐオーバーフローしちゃうので、SimdLinqのSumは32 bit以上の要素にだけ提供しています、つまり<code>int</code>, <code>long</code>, <code>uint</code>, <code>ulong</code>, <code>double</code>, <code>float</code> です。そもそも元々のLINQのSum(引数なし)も<code>int</code>からなので、その辺は一緒ということで。</p>
<p>そうしたオーバーフローの危険性を避けたい場合、独自拡張として <code>LongSum</code> というlongを戻り値にするSumメソッドを追加しています。内部的にlongで処理するため、(若干性能は落ちますが)オーバーフローしなくなります。</p>
<p>float/doubleの扱いは挙動の違いが若干あります。まず、通常のLINQのMin, Maxは<code>NaN</code>をチェックしますがSimdLinqは<code>NaN</code>をチェックしません。<code>NaN</code>チェックがあったほうが丁寧ですが、SIMDでそれは入れずらい＆NaNが入ってくるケースってあまりないので現実的にすごい問題か、というとそうではないかな、と。</p>
<p>それとSumの場合に足し算の順序が変わって(LINQは前から順番に足しますが、SIMDだと並列に足すので)、浮動小数点演算だと足す順序が変わると微妙に誤差が出て同じ結果になりません。例えばLINQだと<code>1.5710588F</code>だけどSimdLinqだと<code>1.5710589F</code>になる、といったような違いが出てきます。結果としては別にどっちでも良い（ある意味で別にどっちも厳密にはあってない）と思いますが、結果の互換性がないですよ、ということは留意してください。</p>
<h2>まとめ</h2>
<p>高速なLINQのAlternativeって、結構あります。<a href="https://github.com/kevin-montrose/LinqAF">LinqAF</a>、<a href="https://github.com/jackmott/LinqFaster">LinqFaster</a>、<a href="https://github.com/NetFabric/NetFabric.Hyperlinq">NetFabric.Hyperlinq</a>など。ただ、どれも大仰なんですよね、StructのIteratorを作ってー、とか。専用メソッドを呼ぶためにラップするのも手間だし、その割に凄い効果的というほどでもないから、依存を増やす割にはメリットも薄くなので、私自身は使おうとはあまり思ってませんでした。</p>
<p>そこでSimdLinqではLINQ全体を高速化させることを狙っているわけではなくて、SIMDが適用できるものだけピンポイントに、そしてソースコードには一切手を入れる必要のない&quot;Drop-in replacement&quot;になるようにデザインしました。また、SIMDのみに絞ったことで性能面に明らかに圧倒的な差をだして、あえて使う理由を作る、といったところですね。</p>
<p>ついでにそうなると欲張ってどんどん適用できる箇所を増やしたい、つまりは<a href="https://github.com/Cysharp/StructureOfArraysGenerator">StructureOfArraysGenerator</a>だ、みたいなコンボも狙っています。エコシステム囲い込み！囲い込みはEvil！</p>
<p>そんなわけでSIMDシリーズ第一弾でした。今年はSIMD関連も幾つか出していくかもしれませんし、Source Generatorネタがめちゃくちゃ溜まってるので時間が無限大に必要です。まぁ、ともかくまずはSimdLinqを使って見てください！</p>
</div>
<h1><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></h1>
<ul class="date"><li>2023-01-27</li></ul>
<div class="entry_body"><p>最近はSource Generatorブームが続いていて、去年末に<a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a>という記事を出しましたが、まずは今年第一弾のSource Generatorライブラリです。</p>
<ul>
<li><a href="https://github.com/Cysharp/StructureOfArraysGenerator/">github.com/Cysharp/StructureOfArraysGenerator</a></li>
</ul>
<p>これは何かというと、structure of arrays(SoA)を使いやすくするためのコードを生成するというものです。まずそもそもSoAですが、Wikipediaの<a href="https://en.wikipedia.org/wiki/AoS_and_SoA">AoS and SoA</a>という記事によるところ（日本語版はない）、CPUキャッシュを有効活用したりSIMDを適用させやすくなる構造だよ、と。通常C#の配列はarray of structures(AoS)になります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png" alt="" /></p>
<p>上の通常の配列がAoSでXYZXYZXYZXYZといったように並んでいる構造ですが、下のStructureOfArraysGeneratorで生成したSoAの配列はXXXXYYYYZZZZという並び順になります。実際にシンプルなパフォーマンステスト（Vector3[10000]に対してYの最大値を求める）によるところ</p>
<p><img src="https://user-images.githubusercontent.com/46207/215027253-6f94739f-b827-46ba-a395-690d1df89d46.png" alt="" /></p>
<p>そのまま書いても2倍、SIMDで書きやすい状態なのでSIMDで処理してしまえば10倍高速化されます。というわけで、パフォーマンスが求められるシチュエーションで非常に有用です。</p>
<p>このライブラリはZigという最近、日本でも注目されている言語（Node.jsの高速な代替として注目されている<a href="https://bun.sh/">Bun</a>の実装言語）のMultiArrayListにインスパイアされました。Zigの作者 Andrew Kelley氏が講演した <a href="https://vimeo.com/649009599">A Practical Guide to Applying Data-Oriented Design</a> という素晴らしい講演があるので是非見て欲しいのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/215052372-1ab33bd2-a578-4c26-8e99-7615a49707ea.png" alt="image" /></p>
<p>データ指向設計(Data-Oriented Design)はパフォーマンスを飛躍的に改善する魔法なのです。ん、それはどこかで聞いたような……？そう、<a href="https://unity.com/ja/dots">UnityのDOTS</a>です。Data-Oriented Technology Stackです。ECSです。……。まぁ、そんなわけで全体に導入するにはそうとうガラッと設計を変える必要があるので大変厳しくはあるのですが、講演での実例としてZig自身のコンパイラの事例が出てますが、まぁつまりは徹底的にやれば成果は出ます。</p>
<p>しかしまぁ徹底的にやらず部分的に使っても効果があるのはUnityで Job System + Burst ぐらいでいいじゃん、という気持ちになっていることからも明らかです。というわけで部分的なSoA構造の導入にお使いください、かつ、導入や利用の敷居は全然高くないように設計しました。</p>
<h2>MultiArray</h2>
<p>NuGetからインストール（Unityの場合はgit参照か.unitypackageで）するとAnalyzerとして参照されます。StructureOfArraysGeneratorは属性も含めて依存はなく全てのコードが生成コードに含まれる（属性はinternal attributeとして吐かれる）ので、不要なライブラリ依存が増えることはありません。</p>
<p><code>[MultiArray(Type)]</code>を配列的に使いたい<code>readonly partial struct</code>につけます。</p>
<pre><code class="language-csharp">using StructureOfArraysGenerator;

[MultiArray(typeof(Vector3))]
public readonly partial struct Vector3MultiArray
{
}
</code></pre>
<p>するとSource Generatorは内部的にはこういうコードを生成します。</p>
<pre><code class="language-csharp">partial struct Vector3MultiArray
{
    // constructor
    public Vector3MultiArray(int length)

    // Span&lt;T&gt; properties for Vector3 each fields
    public Span&lt;float&gt; X =&gt; ...;
    public Span&lt;float&gt; Y =&gt; ...;
    public Span&lt;float&gt; Z =&gt; ...;

    // indexer
    public Vector3 this[int index] { get{} set{} }

    // foreach
    public Enumerator GetEnumerator()
}
</code></pre>
<p>Structure of <strong>Arrays</strong> と言ってますが、StructureOfArraysGeneratorは Arrays は生成しません。内部的には単一の <code>byte[]</code> と各開始地点のオフセットのみを持っていて、生成されるプロパティによって<code>Span&lt;T&gt;</code>のビューを返すという設計になっています。</p>
<p>使い方的には配列のように使えますが、<code>Span&lt;T&gt;</code>の操作、例えばref var item inによるforeachを使うと、より効率的に扱えます。</p>
<pre><code class="language-csharp">var array = new Vector3MultiArray(4);

array.X[0] = 10;
array[1] = new Vector3(1.1f, 2.2f, 3.3f);

// multiply Y
foreach (ref var item in v.Y)
{
    item *= 2;
}

// iterate Vector3
foreach (var item in array)
{
    Console.WriteLine($&quot;{item.X}, {item.Y}, {item.Z}&quot;);
}
</code></pre>
<p>Yに2倍を掛ける処理などは、メモリ領域が連続していることにより、<code>Vector3[]</code>を <code>item.Y *= 2</code> などとして書くよりも高速に処理されます．</p>
<p>他に<code>List&lt;T&gt;</code>のようにAddできる<code>MultiArrayList</code>や、内部的には<code>byte[]</code>を持っているだけであることを生かした<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での超高速なシリアライズなどにも対応しています。気になったら是非ReadMeのほうを見てください。</p>
<h2>.NET 7 時代のSIMD</h2>
<p>.NETはSIMD対応が進んでいて、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.x86">System.Runtime.Intrinsics.X86</a>によって、直接ハードウェア命令を書くことが出来ます。</p>
<p>しかし、しかしですね、最近は .NET を Arm で動かすことが現実的になってきました。iOSやAndroidでけはなくMacのArm化、そしてAWS GravitonのようなArmサーバーはコスト面でも有利で、選択肢に十分入ります。そこでAvx.Addなんて書いていたらArmで動きません。勿論 <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.arm">System.Runtime.Intrinsics.Arm</a> というクラスも公開されていて、Arm版のSIMDを手書きすることもできるんですが、分岐して似たようなものを二個書けというのか！という話です。</p>
<p>そこで、 <a href="https://zenn.dev/pcysl5edgo/articles/d3e787599c5c8b">.NET 7こそがC# SIMDプログラミングを始めるのに最適である理由</a> という記事があるのですが、確かに .NET 7 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256.loadunsafe">Vector256.LoadUnsafe</a> がまずめちゃくくちゃイイ！馴染みが深い（？）Unsafeによる ref var T で書けます！そして<a href="https://github.com/dotnet/runtime/issues/49397">Expose cross-platform helpers for Vector64, Vector128, and Vector256</a>により、<code>Vector64/128/256&lt;T&gt;</code>にプラットフォーム抽象化されたSIMD処理が書けるようになりました、やはり .NET 7から。</p>
<p>例えば .NET 7 でint[]のSumのSIMD化を書いてみます。</p>
<pre><code class="language-csharp">var array = Enumerable.Range(1, 100).ToArray();

ref var begin = ref MemoryMarshal.GetArrayDataReference(array);
ref var last = ref Unsafe.Add(ref begin, array.Length);

var vectorSum = Vector256&lt;int&gt;.Zero;
ref var current = ref begin;

// Vector256で処理できるだけ処理
ref var to = ref Unsafe.Add(ref begin, array.Length - Vector256&lt;int&gt;.Count);
while (Unsafe.IsAddressLessThan(ref current, ref to))
{
    // 直接足し算できて便利
    vectorSum += Vector256.LoadUnsafe(ref current);
    current = ref Unsafe.Add(ref current, Vector256&lt;int&gt;.Count);
}

// Vector256をintに戻す
 var sum = Vector256.Sum(vectorSum);

// 残りの分は単純処理
while (Unsafe.IsAddressLessThan(ref current, ref last))
{
    sum += current;
    current = ref Unsafe.Add(ref current, 1);
}

Console.WriteLine(sum); // 5050
</code></pre>
<p>まぁforがwhileのアドレス処理になっていたり、最後にはみ出た分を処理する必要がありますが、かなり自然にSIMDを扱えているといってもいいんじゃないでしょうか。(Unsafeに慣れていれば)かなり書きやすいです。いいね。</p>
<p>ところで .NET 7からLINQがSIMD対応してるからこんなの書く必要ないでしょ？というと、対応してません。LINQのSIMDはint[]のAverage, int[]のMin, Max, long[]のMin, Maxのみと、かなり限定的です。これは互換性の問題などなどがあり、まぁオマケみたいなものだと思っておきましょう。必要な局面があるなら自分で用意する方が無難です。</p>
<p>ともあれ、.NET 7 からは手書きX86 SIMDはArm対応が漏れやすいので、極力Vectorによって抽象化されたコードで書きましょう、ということになります。どうしてもVectorじゃ書けないところだけ、仕方なく書くという感じですね。</p>
<h2>まとめ</h2>
<p>反響全然ないだろうなあと想定していましたが、やはり反響全然ないです！まぁでも結構面白いライブラリになったと思うので、是非使ってください。それと、Incremental Source Generatorの作り方がMemoryPackの頃よりも習熟していて、コードがかなり洗練されたものになっているので、Source Generatorの作り方として参照するならMemoryPackのコードよりもこちらのコードのほうがお薦めです。</p>
<p>というわけで、まだまだSource Generatorネタはいっぱいあるので、今年は大量に量産します！</p>
</div>
<h1><a href="https://neue.cc/2022/12/30_year.html">2022年を振り返る</a></h1>
<ul class="date"><li>2022-12-30</li></ul>
<div class="entry_body"><p>今年はCysharpとしては、（控えめながら）露出があったので、何やってるかわからない、むしろ存在してるんですか？といったところから脱却したのではないでしょうか……？相変わらず<a href="https://cysharp.co.jp/">ホームページはペライチ</a>ですけれど。そろそろいい加減、更新したい。</p>
<p>大きなところでは <a href="https://neue.cc/2022/04/">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a> というわけで、結構長くCygamesと一緒に作っていたゲームがリリースされました。超期間限定だったのでもうプレイできませんが……！技術的な詳細はCygamesのほうから <a href="https://cedil.cesa.or.jp/cedil_sessions/view/2637">C#によるクライアント/サーバーの開発言語統一がもたらす高効率な開発体制 ～プリコネ！グランドマスターズ開発事例～</a> という形でCEDECで講演していますが、2022年現在の開発体制としてはかなり先端を走っている、かつ、とてもいい感じに仕上がっています。</p>
<p>MagicOnion採用タイトルも増えていて、特に今年リリースされたタイトルで一番大きなものは<a href="https://mememori-game.com/">メメントモリ</a>でしょうか、<a href="https://twitter.com/neuecc/status/1595729906528587781">MagicOnion, MessagePack for C#を採用していただいています</a>。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>は12/28にv5をリリースしたばかりです！内部アーキテクチャの変更によるパフォーマンス向上や拡張性の確保、そして<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>への対応といった、次世代に向けて大きく基盤整理されました。今後もSource Generatorフル対応などが控えています。</p>
<p>OSS関連も、振り返るとかなり充実していました。後半、既存OSSのメンテが滞り気味だったのは来年消化します……！</p>
<ul>
<li><a href="https://neue.cc/2022/02/28_DFrame.html">DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</a></li>
<li><a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a></li>
<li><a href="https://neue.cc/2022/11/04_memorypack.html">MemoryPackにみる .NET 7/C# 11世代のシリアライザー最適化技法</a></li>
</ul>
<p>今年も自分のプログラミング能力の成長を実感できています。技術的に腐り始めたら一瞬！みたいな危機感はあるので、こうして毎年の成長を、ちゃんと対外的にも示し続けられているのはいいことかな。自分はできてると思ってるけど外から見るとやべぇ、みたいなパターンは往々にありますからね、常に実証と共にありたいです。</p>
<p>特にMemoryPackは次世代の基準を打ち立てられたのではないかと思います。GitHub Starも3ヶ月で1300到達、非常に良い感じです。作ってる最中は、私が今これをやりきらなきゃC#は10年遅れてしまうんだ、みたいな気持ちでヒィヒィいいながら書いてましたが、大言壮語な妄想ではなく実際いい感じのものを出せたのではないでしょうか。</p>
<p>Source Generatorの解説を <a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a> として書きましたが、改めてC#にとってSource Generatorはめちゃくちゃ重要なテクノロジーになると、今更ながらに理解しました。いや、2020年の終わりに <a href="https://neue.cc/2020/12/15_597.html">UnitGenerator</a> を作ってから（これは今も使ってます）、しかしそこまで突き詰めてこなかったんですよね、今の今まで。来年はSource Generator元年ということで、色々な分野で革命的なものを大量に投下したいと思ってます。今なんかアイディアが溢れてるんですよ……！</p>
<p>というわけで来年はいっぱいやることがある！今年に悔いが残るとすれば、Cysharpとして現在、自称革命的なサービス（？）を作ってるんですが、それの進捗があまり良くなかったことですかねえ。原因としては私がOSS関連でフラフラしててプロジェクトマネージャー/プロダクトオーナーとして1ミリも機能いてなかったせいなのですが！反省。PM的な話は昔からずっと反省し続けてるので一向に進歩してないですね……。そこに脳みそ注ぎ込む余力がないのだと言い訳してますが……。</p>
<p>そんなわけで、来年こそは革命的サービスもリリースするので期待していてください。OSS関連も革命的なものをどかどか投下する予定なので、引き続きCysharpは時代の最先端を全力疾走していきます。</p>
</div>
<a href="https://neue.cc/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
