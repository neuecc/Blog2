<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
<meta property="og:url" content="https://neue.cc" />
<meta property="og:type" content="website" />
<meta property="og:title" content="neue cc" />
<meta property="og:description" content="..." />

 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2023/07/20_nats_client_v2.html">AlterNats は 公式の NATS .NET Client v2 に引き継がれました</a></h1>
<ul class="date"><li>2023-07-20</li></ul>
<div class="entry_body"><p><a href="https://nats.io/">NATS</a>のサードパーティー(alternative)クライアントであった<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>は、公式に引き取られて<a href="https://github.com/nats-io/nats.net.v2">NATS.NET V2</a>となりました。v2の詳細に関してはNATS公式からのブログ<a href="https://nats.io/blog/nats-dotnet-v2-alpha-release/">NATS .NET Client v2 Alpha Released with Core NATS Support</a>を参照ください。</p>
<blockquote>
<p>NATS community members started to take note, and develop client libraries for NATS based on modern .NET APIs. One notable client library that emerged was the AlterNats library by Cysharp, which includes a fully asynchronous API, leverages Span<T> , and supports client-side WebSockets from browsers in Blazor . NATS maintainers and AlterNats maintainers agreed that AlterNats would make a great starting point for NATS.Client v2!</p>
</blockquote>
<p>NATSに関してはAlterNatsリリース時の記事 <a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a>に色々書きましたが、<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>配下のPubSubミドルウェアで、RedisなどでのPubSubに比べるとパフォーマンスを始めとして多くのメリットがあります。</p>
<p>ただしこういうものはサーバー実装も重要ですがクライアント実装も重要であり、そして当時のNATSの公式クライアント(v1)は正直酷かった！せっかくの素晴らしいミドルウェアが.NETでは活かされない、また、RedisでのPubSubには不満があり、そもそも.NETでのベストなPubSubのソリューションがないことに危機意識を感じていたので、独自に実装を進めたのがAlterNatsでした。</p>
<p>ただし、枯れたプロトコルならまだしも、進化が早いミドルウェアのクライアントが乱立しているのは決して良いことでもないでしょう。新機能への追随速度やメンテナンスの保証という点でも、サードパーティクライアントとして進んでいくよりも、公式に統合されることのほうが絶対に良いはずです。</p>
<p>というわけで今回の流れは大変ポジティブなことだし、野良実装にとって最高の道を辿れたんじゃないかと思っています。私自身は実装から一歩引きますが、使っていく上で気になるところがあれば積極的にPR上げていくつもりではあります。</p>
<h2>OSSとメンテナンスの引き継ぎ</h2>
<p>権限の移管は何度か経験があって</p>
<ul>
<li><a href="https://github.com/mihaifm/linq">linq.js</a>、</li>
<li><a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a></li>
<li><a href="https://github.com/xin9le/CloudStructures">CloudStructures</a></li>
</ul>
<p>は完全に手放しています。ほか、<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>はCysharp名義に移ったうえで、現在の開発リードは私ではありません。また、最近では<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack for C#</a>はMessagePack-CSharp Organizationに移していて共同のOwner権限になっています。</p>
<p>どうしても常に100%の力を一つのOSSに注ぐことはできないので、本来はうまく移管していけるのが良いわけですが、いつもうまくできるわけじゃなくて、<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>なんかはうまく移管できないままarchivedにしてしまっています。</p>
<p>やっぱ出した当時は自分が手綱を握っていたいという気持ちがとても強いわけですが、関心が徐々に薄れていくタイミングと他の人に渡せるタイミングがうまく噛み合わないと、死蔵になってしまうというところがあり、まぁ、難しいです。これだけやっていても上手くできないなあ、と……。</p>
<p>今回のは大変良い経験だったので、作ってメンテナンスを続ける、そしてその先についても考えてやっていきたいところですね。</p>
<p>ともあれ、良い事例を一つ作れた＆素晴らしいライブラリをC#に一つ持ち込むことができたということで、とても気分がよいですです。</p>
</div>
<h1><a href="https://neue.cc/2023/07/07_mvp-renew13.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2023-07-07</li></ul>
<div class="entry_body"><p>13回目です！一年ごとに再審査での更新で、変わらずC#の最前線に立てています。</p>
<p>活動の中心は引き続きOSSですが、<a href="https://github.com/Cysharp">github/Cysharp</a>でのスター数は変わらず他を圧倒していると思いますし、毎年の新規の公開数の勢いも変わらずで新しいアイディアを出し続けています。</p>
<p>今年は<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>を起点にしてRustを活用してC#の活用幅をより広げていくことを狙っています。先日公開した<a href="https://github.com/Cysharp/MagicPhysX">MagicPhysX</a>の他にも色々計画がって、かなり面白いインパクトが出せるんじゃないかと思っています。</p>
<p>MessagePack for C#も<a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp">MessagePack-CSharp/MessagePack-CSharp</a>と、organization名義に移したことで（変わらず私はOwnerなので権限を手放したわけではありません）より中立的に発展させていきます。直近ではSource Generator対応が予定されています(preview版を公開中）。</p>
<p>というわけで、これはもう満場一致でC#に貢献しているということでいいんじゃないでしょうかね……？</p>
<p>ここ最近は登壇していなかったのですが、去年は<a href="https://speakerdeck.com/neuecc/c-number-11-niyorushi-jie-zui-su-bainarisiriaraiza-memorypack-nozuo-rifang">C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a>というセッションをしました。その流れということで、今年の8月にCEDEC 2023にて<a href="https://cedec.cesa.or.jp/2023/session/detail/s642165615a6b5">モダンハイパフォーマンスC# 2023 Edition</a>、それと共同講演で<a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3">メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～</a>という2つの登壇予定があるので、ぜひ見に来てください。</p>
</div>
<h1><a href="https://neue.cc/2023/07/04_MagicPhysX.html">MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</a></h1>
<ul class="date"><li>2023-07-04</li></ul>
<div class="entry_body"><p>MagicPhysXというライブラリを新しく公開しました！.NETで物理エンジンを動かすというもので、その名の通り、<a href="https://github.com/NVIDIA-Omniverse/PhysX">NVIDIA PhysX
</a>のC#バインディングとなっています。</p>
<ul>
<li><a href="https://github.com/Cysharp/MagicPhysX">Cysharp/MagicPhysX</a></li>
</ul>
<p>使い道としては</p>
<ul>
<li>GUIアプリケーションの3D部分</li>
<li>自作ゲームエンジンへの物理エンジン組み込み</li>
<li>ディープラーニングのためのシミュレーション</li>
<li>リアルタイム通信におけるサーバーサイド物理</li>
</ul>
<p>といったことが考えられます。</p>
<p>.NET用のPhysXバインディングは他にも存在しますが、C++/CLIでバインディングを生成している都合上Windowsでしか動かせなかったり、バージョンが最新ではない4.xベースだったりしますが、MagicPhysXは最新のPhysX 5ベースで、かつ、Windows, MacOS, Linuxの全てで動きます！(win-x64, osx-x64, osx-arm64, linux-x64, linux-arm64)。これはバインディングの作り方としてクロスプラットフォームコンパイルに強いRustと、<a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a>によってC#のバインディングの自動生成をしているからです。</p>
<p>先にアーキテクチャの話をしましょう。MagicPhysXは<a href="https://www.embark-studios.com/">EmbarkStudios</a>による<a href="https://github.com/EmbarkStudios/physx-rs">physx-rs</a>をビルド元に使っています。</p>
<blockquote>
<p>EmbarkStudiosはEA DICEで<a href="https://www.ea.com/frostbite">Frostbite</a>ゲームエンジン(Battlefield)を作っていた人たちが独立して立ち上げたスタジオで、Rustによるゲームエンジンを作成中です。また、その過程で生まれたRustのライブラリをOSSとして積極的に公開しています。一覧は<a href="https://embark.dev/">Embark Studios Open Source</a>にあります。必見！</p>
</blockquote>
<p>PhysXのライブラリはC++で出来ていて、他の言語で使うことは考慮されていません。そのために他の言語に持ち込むためには、C++上で別言語で使うためのブリッジ部分を作った上で、バインディングを用意するという二度手間が必要になってきます。それはRustであっても例外ではありません。また、二度手間というだけではなく、PhysXのソースコードはかなり大きいため、その作業量も膨大です。</p>
<p>以前に<a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a>で紹介しましたが、<a href="https://www.swig.org/">SWIG</a>などのC++からの自動生成、Rustであれば<a href="https://cxx.rs/">cxx</a>、<a href="https://github.com/google/autocxx">autocxx</a>のような自動化プロジェクトも存在しますが、C++そのものの複雑さからいっても、求めるものを全自動で出力するのは難しかったりします。</p>
<p>physx-rsでは<a href="https://www.youtube.com/watch?v=RxtXGeDHu0w">An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)</a>というセッションでPhysXをRustに持ち込むための手段の候補、実際に採用した手段についての解説があります。最終的に採用された手段について端的に言うと、PhysXに特化してコード解析してC APIを生成する独自ジェネレーターを用意した、といったところでしょうか。そしてつまり、physx-rsには他言語でもバインディング手段として使えるPhysXのC APIを作ってくれたということにもなります！</p>
<p>更にcsbindgenには、rsファイル内のextern &quot;C&quot;の関数からC#を自動生成する機能が備わっているので、Rustを経由することでC++のPhysXをC#に持ち込めるというビルドパイプラインとなりました。</p>
<p>そういう成り立ちであるため、MagicPhysXのAPIはPhysXのAPIそのものになっています。</p>
<pre><code class="language-csharp">using MagicPhysX; // for enable Extension Methods.
using static MagicPhysX.NativeMethods; // recommend to use C API.

// create foundation(allocator, logging, etc...)
var foundation = physx_create_foundation();

// create physics system
var physics = physx_create_physics(foundation);

// create physics scene settings
var sceneDesc = PxSceneDesc_new(PxPhysics_getTolerancesScale(physics));

// you can create PhysX primitive(PxVec3, etc...) by C# struct
sceneDesc.gravity = new PxVec3 { x = 0.0f, y = -9.81f, z = 0.0f };

var dispatcher = phys_PxDefaultCpuDispatcherCreate(1, null, PxDefaultCpuDispatcherWaitForWorkMode.WaitForWork, 0);
sceneDesc.cpuDispatcher = (PxCpuDispatcher*)dispatcher;
sceneDesc.filterShader = get_default_simulation_filter_shader();

// create physics scene
var scene = physics-&gt;CreateSceneMut(&amp;sceneDesc);

var material = physics-&gt;CreateMaterialMut(0.5f, 0.5f, 0.6f);

// create plane and add to scene
var plane = PxPlane_new_1(0.0f, 1.0f, 0.0f, 0.0f);
var groundPlane = physics-&gt;PhysPxCreatePlane(&amp;plane, material);
scene-&gt;AddActorMut((PxActor*)groundPlane, null);

// create sphere and add to scene
var sphereGeo = PxSphereGeometry_new(10.0f);
var vec3 = new PxVec3 { x = 0.0f, y = 40.0f, z = 100.0f };
var transform = PxTransform_new_1(&amp;vec3);
var identity = PxTransform_new_2(PxIDENTITY.PxIdentity);
var sphere = physics-&gt;PhysPxCreateDynamic(&amp;transform, (PxGeometry*)&amp;sphereGeo, material, 10.0f, &amp;identity);
PxRigidBody_setAngularDamping_mut((PxRigidBody*)sphere, 0.5f);
scene-&gt;AddActorMut((PxActor*)sphere, null);

// simulate scene
for (int i = 0; i &lt; 200; i++)
{
    // 30fps update
    scene-&gt;SimulateMut(1.0f / 30.0f, null, null, 0, true);
    uint error = 0;
    scene-&gt;FetchResultsMut(true, &amp;error);

    // output to console(frame-count: position-y)
    var pose = PxRigidActor_getGlobalPose((PxRigidActor*)sphere);
    Console.WriteLine($&quot;{i:000}: {pose.p.y}&quot;);
}

// release resources
PxScene_release_mut(scene);
PxDefaultCpuDispatcher_release_mut(dispatcher);
PxPhysics_release_mut(physics);
</code></pre>
<p>つまり、そのままでは決して扱いやすくはないです。部分的に動かすだけではなく、本格的にアプリケーションを作るなら、ある程度C#に沿った高レベルなフレームワークを用意する必要があるでしょう。MagicPhysX内ではそうしたサンプルを用意しています。それによって上のコードはこのぐらいシンプルになります。</p>
<pre><code class="language-csharp">using MagicPhysX.Toolkit;
using System.Numerics;

unsafe
{
    using var physics = new PhysicsSystem(enablePvd: false);
    using var scene = physics.CreateScene();

    var material = physics.CreateMaterial(0.5f, 0.5f, 0.6f);

    var plane = scene.AddStaticPlane(0.0f, 1.0f, 0.0f, 0.0f, new Vector3(0, 0, 0), Quaternion.Identity, material);
    var sphere = scene.AddDynamicSphere(1.0f, new Vector3(0.0f, 10.0f, 0.0f), Quaternion.Identity, 10.0f, material);

    for (var i = 0; i &lt; 200; i++)
    {
        scene.Update(1.0f / 30.0f);

        var position = sphere.transform.position;
        Console.WriteLine($&quot;{i:D2} : x={position.X:F6}, y={position.Y:F6}, z={position.Z:F6}&quot;);
    }
}
</code></pre>
<p>ただしあくまでサンプルなので、参考にしてもらいつつも、必要な部分は自分で作ってもらう必要があります。</p>
<p>Unityのようなエディターがないと可視化されてなくて物理エンジンが正しい挙動になっているのか確認できない、ということがありますが、PhysXにはPhysX Visual Debuggerというツールが用意されていて、MagicPhysXでも設定することでこれと連動させることが可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/250030945-2018e821-41c4-44a2-aac6-f0705993ab9b.png" alt="" /></p>
<h2>Dedicated Server</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>といったサーバーサイドでゲームのロジックを動かすためのライブラリを開発しています。その路線から行って物理エンジンが必要なゲームでさえも通常の .NET サーバーで動かしたいという欲求が出てくるのは至極当然でしょう……（？）</p>
<p>UEやUnityのDedicated Serverの構成だとヘッドレスなUE/Unityアプリケーションをサーバー用ビルドしてホスティングすることになりますが、サーバー用のフレームワークではないので、あまり作りやすいとは言えないんですよね。通常用サーバー向けのライブラリとの互換性、ライフサイクルの違い、ランタイムとしてのパフォーマンスの低さ、などなど。</p>
<p>というわけで、MagicOnionのようなサーバー向けフレームワークを使ったほうがいいのですが、物理エンジンだけはどうにもならない。今までは……？</p>
<p>と、言いたいのですが、まずちゃんとしっかり言っておきたいのですが、現実的には少々（かなり）難しいでしょう！コライダーどう持ってくるの？とかAPIが違う（Unityの物理エンジンはPhysXですが、API的に1:1の写しではないので細かいところに差異がある）のでそもそも挙動を合わせられないし、でもこういう構成ならサーバーだけじゃなくクライアントでも動かしたい、そもそもそうじゃないとデバッガビリティが違いすぎる。</p>
<p>と、ようするに、もしゲーム自体にある程度、物理エンジンに寄せた挙動が必要なら、「物理エンジン大統一」が必須だと。MagicPhysXは残念ながらそうではありません。実のところ当初はそれを目指していました、Unityとほぼ同一挙動でほぼ同一APIになるのでシームレスに持ち込むことができるライブラリなのだ、と。しかし現状はそうではないということは留意してください。また、その当初予定である互換APIを作り込む予定もありません。</p>
<h2>まとめ</h2>
<p>このライブラリ、かなり迷走したプロジェクトでもあって、そもそも最初は<a href="https://github.com/bulletphysics/bullet3">Bullet Physics</a>を採用する予定でした。ライブラリ名が先に決めてあってMagicBulletってカッコイイじゃん、みたいな。その後に<a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>を使おうとして、これもバインディングをある程度作って動く状態にしたのですが、「物理エンジン大統一」のためにPhysXにすべきだろうな、という流れで最終的にPhysXを使って作ることにしました。</p>
<p>形になって良かったというのはありますが（そしてcsbindgenの実用性！）、「物理エンジン大統一」を果たせなかったのは少々残念ではあります。最初の完成予想図ではもっともっと革命的なもののはずだったのですが……！</p>
<p>とはいえ、PhysX 5をクロスプラットフォームで.NETに持ち込んだということだけでも十分に難易度が高く新しいことだと思っているので、試す機会があれば、是非触って見ください。</p>
</div>
<h1><a href="https://neue.cc/2023/03/09-csbindgen.html">csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について</a></h1>
<ul class="date"><li>2023-03-09</li></ul>
<div class="entry_body"><p>ネイティブコードとC#を透過的に接続するために、RustのFFIからC#のDllImportコードを自動生成するライブラリを作成し、公開しました。Cysharp初のRustライブラリです！先週にプレビューを出していましたが、しっかりした機能強化とReadMeの充実をして正式公開、です！</p>
<ul>
<li><a href="https://github.com/Cysharp/csbindgen">Cysharp/csbindgen</a></li>
<li><a href="https://crates.io/crates/csbindgen">crates.io/crates/csbindgen</a></li>
</ul>
<p>めちゃくちゃスムーズにネイティブコードがC#から呼べるようになります。すごい簡単に。超便利。こりゃもうばんばんネイティブコード書きたくなりますね……！ただし書くコードはRustのみ対応です。いや、別にRustでいいでしょ、Rustはいいぞ……！</p>
<p>しかしまず前提として言っておくと、ネイティブコードは別に偉くもなければ、必ず速いというわけでもないので、極力書くのはやめましょう。C#で書くべき、です。高速なコードが欲しければ、ネイティブコードに手を出す前にC#で速くすることを試みたほうがずっと良いです。C#は十分高速に書くことのできる言語です！ネイティブコードを書くべきでない理由は山ほどありますが、私的に最大の避けたい理由はクロスプラットフォームビルドで、今の世の中、ターゲットにしなければならないプラットフォーム/アーキテクチャの組み合わせは、普通にやっていても10を超えてしまいます。win/linux/osx/iOS/Android x x86/x64/arm。C#では .NET のランタイムやUnityが面倒見てくれますが、ネイティブコードの場合はこれを自前で面倒みていく必要があります。そこそこ面倒みてくれるはずのUnityだって辛いのに、それにプラスして俺々ビルド生態系を加えるのはかなり厳しいものがある。</p>
<p>とはいえ、C#をメインに据えつつもネイティブコードを利用すべきシチュエーションもあるにはあります。</p>
<ul>
<li>Android NDKや .NET unmanaged hosting APIなど、ネイティブAPIしか提供されていないものを使いたい場合</li>
<li>C で作られているネイティブライブラリを利用したい場合</li>
<li>ランタイムのライブラリの利用を避けたい場合、例えばUnityで .NET のSocket(Unityの場合 .NET のランタイムが古いのでパフォーマンスを出しにくい)を避けてネイティブのネットワークコードを書くのには一定の道理がある</li>
</ul>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/core/deploying/native-aot/">NativeAOT</a>という解決策もなくはないですが、まだそんなに現実的でもなければ、用途的にもこういうシチュエーションでは限定的でもあるので、そこは素直にネイティブコードを書いていくべき、でしょう。</p>
<p>そこでの最初の選択肢は当然C++なわけですが、いやー、C++のクロスプラットフォームビルドは大変だしなあ。となると、最近評判を聞く<a href="https://ziglang.org/ja/">Zig</a>はどうだろうか、と試してみました、が、撤退。目指すコンセプトは大変共感するところがあるのですが(FFIなしのCライブラリとの統合や、安全だけど複雑さを抑えた文法など)、まだ、完成度が、かなり、厳しい……。</p>
<p>で、最後の選択肢が<a href="https://www.rust-lang.org/ja">Rust</a>でした。FFIなしでの呼び出しではないものの<a href="https://crates.io/crates/cc">cc crate</a>や<a href="https://crates.io/crates/cmake">cmake crate</a>といったライブラリを使うと自然に統合されるし、<a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>によるバインディングの自動生成はよく使われているだけあってめっちゃ安定して簡単に生成できます。ていうかZigが全然安定感なかった（シームレスなCとの統合とは……）ので雲泥の差でびっくりした。開発環境もまぁまぁ充実してるしコマンド体系も現代的。クロスプラットフォームビルドも容易！そして難しいと評判で避けていた言語面でも、いや、全然いいね。仕組みが理屈で納得できるし、C#とは文法面でもあまり離れていないので、全然すんなりと入れました。もちろん難しいところも多々ありますが、ラーニングカーブはそんなに急ではない、少なくとも最近のモダンC#をやり込んでる人なら全然大丈夫でしょう……！</p>
<p>と、いうわけで、しかし主な用途はC#からの利用で、特にCライブラリの取り込みにRustを使おうと決めたわけですが、C#に対して公開するためのコードが膨大でキツかったので、自動化したかったんですね。DllImportの自動化は<a href="https://www.swig.org/">SWIG</a>や<a href="https://github.com/mono/CppSharp">CppSharp</a>というのもありますが、普通のC++をそのまま持ってこようとする思想は、複雑なコードを吐いてしまったりで正直イマイチだな、と。</p>
<p>csbindgenは、まず、面倒なところをRustのbindgenに丸投げです。複雑なC(C++)のコードを解析対処にするから複雑になるのであって、bindgenによって綺麗なRustに整形してもらって、生成対象にするのはそうしたFFI向けに整理されたRustのみを対象にすることで、精度と生成コードの単純さを担保しました。自分でネイティブコードを書く場合も、RustはFFI不可能な型を公開しようとすると警告も出してくれるので、必然的に生成しやすい綺麗なコードになっています。型もRustは非常に整理されているため、C#とマッピングしやすくなっています。C#もまた近年のnintや<code>delegate*</code>、.NET 6からの<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.clong">CLong</a>などの追加によって自然なやり取りができるようになりました。csbindgenはそれら最新の言語機能を反映することで、自然で、かつパフォーマンスの良いバインディングコードを生成しています。</p>
<h2>Getting Started</h2>
<p>コンフィグにビルド時依存に追加してもらって、<code>build.rs</code>というコンパイル前呼び出し(Rustのコードでpre-build書ける機能やビルド時依存を追加できる機能はとても良い)に設定を入れるだけです、簡単！</p>
<pre><code class="language-toml">[build-dependencies]
csbindgen = &quot;1.2.0&quot;
</code></pre>
<pre><code class="language-rust">// extern &quot;C&quot; fnが書かれているlib.rsを読み取って DllImport[&quot;nativelib&quot;]なコードを&quot;NativeMethods.g.cs&quot;に出力する
csbindgen::Builder::default()
    .input_extern_file(&quot;lib.rs&quot;)
    .csharp_dll_name(&quot;nativelib&quot;)
    .generate_csharp_file(&quot;../dotnet/NativeMethods.g.cs&quot;)
    .unwrap();
</code></pre>
<p>単純なコードを例に出すと、このx, yを受け取ってintを返す関数は</p>
<pre><code class="language-csharp">#[no_mangle]
pub extern &quot;C&quot; fn my_add(x: i32, y: i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>こういったC#コードを生成します。</p>
<pre><code class="language-csharp">// NativeMethods.g.cs
using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;nativelib&quot;;

        [DllImport(__DllName, EntryPoint = &quot;my_add&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int my_add(int x, int y);
    }
}
</code></pre>
<p>直感的で単純な出力です、逆にそれがいい、むしろそれがいい。生成に対応している型はプリミティブ以外にもstructやunion、enum、関数やポインターなどRustのFFIで流せる型のほとんどには対応しています。</p>
<p>また、Rustのbindgenやcc/cmake crateを併用すると、CのライブラリをC#に簡単に持ちこむことができます。例えば圧縮ライブラリの<a href="https://github.com/lz4/lz4">lz4</a>は、csbindgenでの生成の前にbindgenとccの設定も足してあげると</p>
<pre><code class="language-csharp">// lz4.h を読み込んで lz4.rs にRust用のbindingコードを出力する
bindgen::Builder::default()
    .header(&quot;c/lz4/lz4.h&quot;)
    .generate().unwrap()
    .write_to_file(&quot;lz4.rs&quot;).unwrap();

// cc(C Compiler)によってlz4.cを読み込んでコンパイルしてリンクする
cc::Build::new().file(&quot;lz4.c&quot;).compile(&quot;lz4&quot;);

// bindgenの吐いたコードを読み込んでcsファイルを出力する
csbindgen::Builder::default()
    .input_bindgen_file(&quot;lz4.rs&quot;)
    .rust_file_header(&quot;use super::lz4::*;&quot;)
    .csharp_entry_point_prefix(&quot;csbindgen_&quot;)
    .csharp_dll_name(&quot;liblz4&quot;)
    .generate_to_file(&quot;lz4_ffi.rs&quot;, &quot;../dotnet/NativeMethods.lz4.g.cs&quot;)
    .unwrap();
</code></pre>
<p>これでC#から呼び出せるコードが簡単に生成できます。ビルドもRustで <code>cargo build</code> するだけでCのコードがリンクされてDLLに含まれています。</p>
<pre><code class="language-csharp">// NativeMethods.lz4.g.cs

using System;
using System.Runtime.InteropServices;

namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = &quot;liblz4&quot;;

        [DllImport(__DllName, EntryPoint = &quot;csbindgen_LZ4_compress_default&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int LZ4_compress_default(byte* src, byte* dst, int srcSize, int dstCapacity);

        // snip...
    }
}
</code></pre>
<p>試してもらうと、本当に簡単にCライブラリが持ち込みができて感動します。Rustやbindgenがとにかく偉い。</p>
<p>csbindgenはUnityでの利用も念頭においているので、よくあるiOSでのIL2CPPだけ __Internal にしたいみたいなシチュエーションでも</p>
<pre><code class="language-csharp">#if UNITY_IOS &amp;&amp; !UNITY_EDITOR
    const string __DllName = &quot;__Internal&quot;;
#else
    const string __DllName = &quot;nativelib&quot;;
#endif
</code></pre>
<p>といったような生成ルールの変更がコンフィグに含めてあります。とても実用的で気が利いてます。</p>
<h2>LibraryImport vs DllImport</h2>
<p>.NET 7から<a href="https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke-source-generation">LibraryImport</a>という新しい呼び出しのためのソースジェネレーターが追加されました。これはDllImportのラッパーになっていて、DllImportは、本来ネイティブコードとやり取りできない型(例えば配列や文字列などの参照型はC#のヒープ上に存在するもので、ネイティブ側に渡せない)を裏で自動的にやってくれるという余計なお世話が含まれていて、それがややこしさや性能面、そしてNativeAOTビリティの欠如などの問題を含んでいたので、そういう型が渡された場合はLibraryImportの生成するC#コードで吸収した上で、byte* としてDllImportに渡すようなラッパーが生成されるようになっています。</p>
<p>つまり余計なお世話をする本来ネイティブコードとやり取りできない型を生成しないようにすればDllImportでも何の問題もないので、今回はDllImportでの生成を選んでいます。そのほうがUnityでも使いやすいし。</p>
<p>Win32のAPIをDllImportで簡単に呼び出せるようにするために暗黙的な自動変換を多数用意しておく、というのは時代背景的には理解できます。C#がWindowsのためだけの言語であり、時折Win32 APIの呼び出しが必須なこともあったのは事実であり、便利な側面もあったでしょう。しかし現在はWindowsのためだけの言語でもなく、またWin32 APIの呼び出しに関しては<a href="https://github.com/microsoft/CsWin32">CsWin32</a>というSource Generatorを活用した支援も存在します。</p>
<p>もう現代では、そうしたDllImportの古い設計を引きずって考える必要はない、頼るべきではないでしょう。つまり参照型を渡したり[In]や[Out]は使うべきではないし、変換を考慮した設計を練る必要もありません。実際 .NET 7ではそうしたDllImportの機能を使うとエラーにする<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.disableruntimemarshallingattribute">DisableRuntimeMarshallingAttribute</a>が追加されました。</p>
<p>ポインターに関しても今はあまり忌避するものではないと思っています。そもそもネイティブとの通信はunsafeだし、Spanによって比較的使いやすい型に変換することも容易なので。中途半端に隠蔽するぐらいなら、DllImportするレイヤーではポインターはポインターとして持っておきましょう。C#として使いやすくするのは、その外側できっちりやればいい話です、DllImportで吸収するものではない。というのが今風の設計思想であると考えています。なんだったら私はIntPtrよりvoid*のほうが好きだよ。</p>
<h2>コールバックの相互受け渡し</h2>
<p>C# -&gt; Rust あるいは Rust -&gt; C# でコールバックを渡し合ってみましょう。まずRust側はこんな風に書くとします。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn csharp_to_rust(cb: extern &quot;C&quot; fn(x: i32, y: i32) -&gt; i32) {
    let sum = cb(10, 20); // invoke C# method
    println!(&quot;{sum}&quot;);
}

#[no_mangle]
pub extern &quot;C&quot; fn rust_to_csharp() -&gt; extern fn(x: i32, y: i32) -&gt; i32 {
    sum // return rust method
}

extern &quot;C&quot; fn sum(x:i32, y:i32) -&gt; i32 {
    x + y
}
</code></pre>
<p>C#のメソッドを受け取ったら、それを読んで表示(println)するだけ、あるいは足し算する関数をC#に渡すだけ、のシンプルなメソッドです。生成コードは以下のようなものになります。</p>
<pre><code class="language-csharp">[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(delegate* unmanaged[Cdecl]&lt;int, int, int&gt; cb);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern delegate* unmanaged[Cdecl]&lt;int, int, int&gt; rust_to_csharp();
</code></pre>
<p><code>delegate* unmanaged[Cdecl]&lt;int, int, int&gt;</code> というのは、あまり見慣れない定義だと思うのですが、C# 9.0から追加された本物の<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers">関数ポインター</a>になります。定義を手書きするのは少しややこしいですが、自動生成されるので特に問題なしでしょう（？）。使い勝手はかなりよく、普通の静的メソッドのように扱えます。</p>
<pre><code class="language-csharp">// ネイティブ側に渡したい静的メソッドはUnmanagedCallersOnlyを付ける必要がある
[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
static int Sum(int x, int y) =&gt; x + y;

// &amp;で関数ポインターを取得して渡す
NativeMethods.csharp_to_rust(&amp;Sum);

// Rustからdelegate*を受け取る
var f = NativeMethods.rust_to_csharp();

// 受け取った関数ポインターは普通に呼び出せる
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>インスタンスメソッドを渡せないのか？というと渡せません。Cとの相互運用にそんなものはない。どうでもいい勝手な変換はしなくていい。第一引数にコンテキスト(void*)を受け取るコードを用意しておけばいいでしょう。</p>
<p>ところで、UnityもC# 9.0対応、しているし関数ポインターも使えるには使えるのですが、<a href="https://docs.unity3d.com/ja/2021.3/Manual/CSharpCompiler.html">Extensible calling conventions for unmanaged function pointers is not supported</a>です。UnmanagedCallersOnlyAttributeもないしね。Unity Editor上では普通に動いちゃったりとかしますが、IL2CPPでは動かないのでちゃんと対応しましょう。csbindgenでは <code>csharp_use_function_pointer(false)</code> というオプションを設定すると、従来のデリゲートを使用したコードを出力します。</p>
<pre><code class="language-csharp">// csharp_use_function_pointer(false) の場合の出力結果、専用のデリゲートを一緒に吐き出すようになる
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int csharp_to_rust_cb_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;csharp_to_rust&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern void csharp_to_rust(csharp_to_rust_cb_delegate cb);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate int rust_to_csharp_return_delegate(int x, int y);

[DllImport(__DllName, EntryPoint = &quot;rust_to_csharp&quot;, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
public static extern rust_to_csharp_return_delegate rust_to_csharp();

// MonoPInvokeCallback属性を静的メソッドにつける(typeofでデリゲートを設定)
[MonoPInvokeCallback(typeof(NativeMethods.csharp_to_rust_cb_delegate))]
static int Sum(int x, int y) =&gt; x + y;

// そのまま渡す
NativeMethods.csharp_to_rust(Method);

// 受け取る関数ポインターに関しては .NET の場合と一緒
var f = NativeMethods.rust_to_csharp();
var v = f(20, 30);
Console.WriteLine(v); // 50
</code></pre>
<p>面倒くさい専用のデリゲートも同時に出力してくれるので、定義はそこそこ楽になります（Action/Funcといった汎用デリゲートを使うと場合によりクラッシュしてしまったので、必ずそれぞれのパラメーター専用のデリゲートを出力するようにしています）。概ねcsbindgenがよしなに動くように面倒見てあげるので、属性の違いだけ考えればほぼ問題はありません。</p>
<h2>コンテキスト</h2>
<p>多値返しみたいなのは、普通にStructを作ってくださいという話になって、その場合は、C#側でStructはコピーされて、Rust側のメモリからはすぐ消えるということになります。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn return_tuple() -&gt; MyTuple {
    MyTuple { is_foo: true, bar: 9999 }
}

#[repr(C)]
pub struct MyTuple {
    pub is_foo: bool,
    pub bar: i32,
}
</code></pre>
<p>もう少し寿命を長く、返却するStructをポインターで返して状態を持ちたい、という場合はRust的には少し工夫が必要です。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_context() -&gt; *mut Context {
    let ctx = Box::new(Context { foo: true });
    Box::into_raw(ctx)
}

#[no_mangle]
pub extern &quot;C&quot; fn delete_context(context: *mut Context) {
    unsafe { Box::from_raw(context) };
}

#[repr(C)]
pub struct Context {
    pub foo: bool,
    pub bar: i32,
    pub baz: u64
}
</code></pre>
<pre><code class="language-csharp">// C#側、Context*を受け取って
var context = NativeMethods.create_context();

// なにか色々したりずっと持っていたり

// 最後に明示的にfreeしにいく
NativeMethods.delete_context(context);
</code></pre>
<p><code>Box::new</code> でヒープ上にデータを確保して、<code>Box::into_raw</code>でRust上でのメモリ管理から外します。Rustは通常だとスコープが外れると即座にメモリを返却する、のですが、寿命をRust管理外のC#に飛ばすので、素直に（？）unsafeにRust上の管理から外してしまうのが普通に素直でしょう。Rust側で確保しているメモリを開放する場合は、<code>Box::from_raw</code>でRust上の管理に戻します。そうするとスコープが外れたらメモリ返却という通常の動作をして、返却が完了します。</p>
<p>この辺はRustだから難しい！という話ではなく、C#でもfixedスコープを外れてポインタを管理したい場合には <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して手動でunsafeな管理しなければいけないので、完全に同じ話です。そう考えると、むしろ素直にC#と変わらない話でいいですね。</p>
<p>なお、C#上でこうしたコンテキストの管理をする場合に専用のSafeHandleを作って、それにラップするという流儀がありますが、大仰で、基本的にはそこまでやる必要はないと思ってます。No SafeHandle。そもそも境界越えというunsafeなことをしているのだから、最後まで自己責任でいいでしょう。</p>
<p>csbindgenは戻り値にstructが指定されていると、C#側にも同様のものを生成しに行ってしまいますが、Rust内だけで使うのでC#側には内容公開したくない、というか参照(Box)とかも含まれてるから公開できないし、みたいな場合もあると思います。その場合は <code>c_void</code> を返してください。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn create_counter_context() -&gt; *mut c_void {
    let ctx = Box::new(CounterContext {
        set: HashSet::new(),
    });
    Box::into_raw(ctx) as *mut c_void // voidで返す
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn insert_counter_context(context: *mut c_void, value: i32) {
    let mut counter = Box::from_raw(context as *mut CounterContext); // as で型を戻す
    counter.set.insert(value);
    Box::into_raw(counter); // contextを使い続ける場合はinto_rawを忘れないように
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn delete_counter_context(context: *mut c_void) {
    let counter = Box::from_raw(context as *mut CounterContext);
    for value in counter.set.iter() {
        println!(&quot;counter value: {}&quot;, value)
    }
}

// C#側には公開しない
pub struct CounterContext {
    pub set: HashSet&lt;i32&gt;,
}
</code></pre>
<pre><code class="language-csharp">// C#側では ctx = void* として受け取る
var ctx = NativeMethods.create_counter_context();
    
NativeMethods.insert_counter_context(ctx, 10);
NativeMethods.insert_counter_context(ctx, 20);

NativeMethods.delete_counter_context(ctx);
</code></pre>
<p>この辺、<code>PhantomData&lt;T&gt;</code>を使って格好良く処理する手法も一応あるんですが、正直複雑になるだけなので、素直に <code>void*</code> ベースでやり取りする、に倒したほうがむしろ健全でいいのではと思っています。どっちにしろunsafeな処理してるんだから素直にunsafeな業を受け入れるべき！</p>
<h2>Stringと配列のマーシャリング</h2>
<p>Stringと配列は、C#とRustでそれぞれ構造が違うので、そのままやり取りはできません。ポインタと長さ、つまりC#でいうところのSpanのみがやり取りできます。Span的な処理をするだけならゼロコピーですが、Stringや配列に変換したくなったら、C#とRust、どちらの側でも新規のアロケーションが発生します。これはネイティブコードを導入することの弱みで、Pure C#で通したほうが融通が効く（或いはパフォーマンスに有利に働く）ポイントですね。まあ、ともあれ、つまり基本はSpanです。DllImport上でStringを受けたり配列を受けたりしてはいけません、その手の自動変換にゆだねてはダメ！アロケーションも自己責任で明示的に。</p>
<p>さて、まずは文字列ですが、こういったケースでやり取りする文字列の種類は3つ、UTF8とUTF16と<a href="https://ja.wikipedia.org/wiki/%E3%83%8C%E3%83%AB%E7%B5%82%E7%AB%AF%E6%96%87%E5%AD%97%E5%88%97">ヌル終端文字列</a>、です。UTF8はRustの文字列(RustのStringは<code>Vec&lt;u8&gt;</code>)、C#の文字列はUTF16、そしてCのライブラリなどはヌル終端文字列を返してくることがあります。</p>
<p>今回は例なので明示的にRust上でヌル終端文字列を返してみます。</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_c_string() -&gt; *mut c_char {
    let str = CString::new(&quot;foo bar baz&quot;).unwrap();
    str.into_raw()
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_c_string(str: *mut c_char) {
    unsafe { CString::from_raw(str) };
}
</code></pre>
<pre><code class="language-csharp">// null-terminated `byte*` or sbyte* can materialize by new String()
var cString = NativeMethods.alloc_c_string();
var str = new String((sbyte*)cString);
NativeMethods.free_c_string(cString);
</code></pre>
<p>C#上では new Stringでポインタ(<code>sbyte*</code>)を渡すとヌル終端を探してStringを作ってくれます。明示的にアロケーションしているという雰囲気がいいですね。ポインタはこの場合Rustで確保したメモリなので、C#のヒープ上にコピー（新規String作成）したなら、即返却してやりましょう。</p>
<p>Rustで確保したUTF8、byte[]、あるいはint[]などとにかく配列全般の話はもう少し複雑になってきます。Rustでの配列的なもの(<code>Vec&lt;T&gt;</code>)をC#に渡すにあたっては、ポインタと長さをC#に渡せばOKといえばOKなのですが、解放する時にそれだけだと困ります。<code>Vec&lt;T&gt;</code>の実態はポインタ、長さ、そしてキャパシティの3点セットになっているので、この3つを渡さなきゃいけないのですね。そして、都度3点セットを処理するのも面倒です、Rust的なメモリ管理を外したり戻したりの作業もあるし。</p>
<p>というわけでちょっと長くなりますが以下のようなユーティリティーを用意しましょう。これの元コードは(元)Rustの開発元であるMozillaのコードなので安全安心です……！</p>
<pre><code class="language-rust">#[repr(C)]
pub struct ByteBuffer {
    ptr: *mut u8,
    length: i32,
    capacity: i32,
}

impl ByteBuffer {
    pub fn len(&amp;self) -&gt; usize {
        self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;)
    }

    pub fn from_vec(bytes: Vec&lt;u8&gt;) -&gt; Self {
        let length = i32::try_from(bytes.len()).expect(&quot;buffer length cannot fit into a i32.&quot;);
        let capacity = i32::try_from(bytes.capacity()).expect(&quot;buffer capacity cannot fit into a i32.&quot;);

        // keep memory until call delete
        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr(),
            length,
            capacity,
        }
    }

    pub fn from_vec_struct&lt;T: Sized&gt;(bytes: Vec&lt;T&gt;) -&gt; Self {
        let element_size = std::mem::size_of::&lt;T&gt;() as i32;

        let length = (bytes.len() as i32) * element_size;
        let capacity = (bytes.capacity() as i32) * element_size;

        let mut v = std::mem::ManuallyDrop::new(bytes);

        Self {
            ptr: v.as_mut_ptr() as *mut u8,
            length,
            capacity,
        }
    }

    pub fn destroy_into_vec(self) -&gt; Vec&lt;u8&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let capacity: usize = self.capacity.try_into().expect(&quot;buffer capacity negative or overflowed&quot;);
            let length: usize = self.length.try_into().expect(&quot;buffer length negative or overflowed&quot;);

            unsafe { Vec::from_raw_parts(self.ptr, length, capacity) }
        }
    }

    pub fn destroy_into_vec_struct&lt;T: Sized&gt;(self) -&gt; Vec&lt;T&gt; {
        if self.ptr.is_null() {
            vec![]
        } else {
            let element_size = std::mem::size_of::&lt;T&gt;() as i32;
            let length = (self.length * element_size) as usize;
            let capacity = (self.capacity * element_size) as usize;

            unsafe { Vec::from_raw_parts(self.ptr as *mut T, length, capacity) }
        }
    }

    pub fn destroy(self) {
        drop(self.destroy_into_vec());
    }
}
</code></pre>
<p>Box::into_raw/from_rawのVec版という感じで、from_vecしたタイミングでメモリ管理から外すのと、destroy_into_vecするとメモリ管理を呼び側に戻す（何もしなければスコープを抜けて破棄される）といったような動作になっています。これはC#側でも(csbindgenによって)定義が生成されているので、メソッドを追加してやります。</p>
<pre><code class="language-csharp">// C# side span utility
partial struct ByteBuffer
{
    public unsafe Span&lt;byte&gt; AsSpan()
    {
        return new Span&lt;byte&gt;(ptr, length);
    }

    public unsafe Span&lt;T&gt; AsSpan&lt;T&gt;()
    {
        return MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;T&gt;(ptr), length / Unsafe.SizeOf&lt;T&gt;());
    }
}
</code></pre>
<p>これでByteBuffer*で受け取ったものを即Spanに変換できるようになりました！というわけで、Rust上の通常のstring、byte[]、それとint[]の例を見てみると</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_string() -&gt; *mut ByteBuffer {
    let str = format!(&quot;foo bar baz&quot;);
    let buf = ByteBuffer::from_vec(str.into_bytes());
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_string(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need String, use String::from_utf8_unchecked(buf.destroy_into_vec()) instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_u8_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;u8&gt; = vec![1, 10, 100];
    let buf = ByteBuffer::from_vec(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_u8_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;u8&gt;, use buf.destroy_into_vec() instead.
    buf.destroy();
}

#[no_mangle]
pub extern &quot;C&quot; fn alloc_i32_buffer() -&gt; *mut ByteBuffer {
    let vec: Vec&lt;i32&gt; = vec![1, 10, 100, 1000, 10000];
    let buf = ByteBuffer::from_vec_struct(vec);
    Box::into_raw(Box::new(buf))
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn free_i32_buffer(buffer: *mut ByteBuffer) {
    let buf = Box::from_raw(buffer);
    // drop inner buffer, if you need Vec&lt;i32&gt;, use buf.destroy_into_vec_struct::&lt;i32&gt;() instead.
    buf.destroy();
}
</code></pre>
<p>ByteBuffer自体の管理を外す(into_raw)が必要なのと、from_rawで戻したあとの中身のByteBufferもdestoryかinto_vecしなきゃいけないという、入れ子の管理になっているというのが紛らわしくて死にそうになりますが、ソウイウモノということで諦めましょう……。Drop traitを実装しておくことでクリーンナップ側の処理はもう少しいい感じにできる余地がありますが、Drop traitを実装しないことの理由もそれなりにある（と、Mozillaが言っている）ので、トレードオフになっています。</p>
<p>C#側では、とりあえずAsSpanして、あとはよしなにするという感じですね。</p>
<pre><code class="language-csharp">var u8String = NativeMethods.alloc_u8_string();
var u8Buffer = NativeMethods.alloc_u8_buffer();
var i32Buffer = NativeMethods.alloc_i32_buffer();
try
{
    var str = Encoding.UTF8.GetString(u8String-&gt;AsSpan());
    Console.WriteLine(str);

    Console.WriteLine(&quot;----&quot;);

    var buffer = u8Buffer-&gt;AsSpan();
    foreach (var item in buffer)
    {
        Console.WriteLine(item);
    }

    Console.WriteLine(&quot;----&quot;);

    var i32Span = i32Buffer-&gt;AsSpan&lt;int&gt;();
    foreach (var item in i32Span)
    {
        Console.WriteLine(item);
    }
}
finally
{
    NativeMethods.free_u8_string(u8String);
    NativeMethods.free_u8_buffer(u8Buffer);
    NativeMethods.free_i32_buffer(i32Buffer);
}
</code></pre>
<p>Rust側で確保したメモリはRust側で解放する！という基本に関しては忠実に守っていきましょう。この例だとC#側で処理したら即解放なので、いい感じにしてくれよ、なんだったらDllImportで暗黙的に自動処理最高、みたいな気になるかもしれませんが、もう少し長寿命で持つケースもあるので、やはりマニュアルでちゃんと解放していきましょう。ていうか暗黙的なアロケーションは一番最悪じゃないです？？？</p>
<p>最後に、C#で確保したメモリをRust側で使う場合の例をどうぞ。</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_string(utf16_str: *const u16, utf16_len: i32) {
    let slice = std::slice::from_raw_parts(utf16_str, utf16_len as usize);
    let str = String::from_utf16(slice).unwrap();
    println!(&quot;{}&quot;, str);
}

#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_utf8(utf8_str: *const u8, utf8_len: i32) {
    let slice = std::slice::from_raw_parts(utf8_str, utf8_len as usize);
    let str = String::from_utf8_unchecked(slice.to_vec());
    println!(&quot;{}&quot;, str);
}


#[no_mangle]
pub unsafe extern &quot;C&quot; fn csharp_to_rust_bytes(bytes: *const u8, len: i32) {
    let slice = std::slice::from_raw_parts(bytes, len as usize);
    let vec = slice.to_vec();
    println!(&quot;{:?}&quot;, vec);
}
</code></pre>
<pre><code class="language-csharp">var str = &quot;foobarbaz:あいうえお&quot;; // JPN(Unicode)
fixed (char* p = str)
{
    NativeMethods.csharp_to_rust_string((ushort*)p, str.Length);
}

var str2 = Encoding.UTF8.GetBytes(&quot;あいうえお:foobarbaz&quot;);
fixed (byte* p = str2)
{
    NativeMethods.csharp_to_rust_utf8(p, str2.Length);
}

var bytes = new byte[] { 1, 10, 100, 255 };
fixed (byte* p = bytes)
{
    NativeMethods.csharp_to_rust_bytes(p, bytes.Length);
}
</code></pre>
<p>std::slice::from_raw_partsでSliceを作って、あとはよしなに処理したいことをします。関数を超えて長い寿命を持たせたいならコピー(String作りなりVec作るなり)は必須になってきます。Rust側で確保したメモリはRust側で解放する、のと同じように、C#側で確保したメモリはC#側で解放する、のが重要です。C#の場合はfixedスコープを抜けて参照を持っていない場合は、そのうちGCが処理してくれるでしょう、といった話ですね。</p>
<p>なお、fixedを超えてC#でもう少し長い寿命で持ち回したいときは <code>GCHandle.Allocc(obj, GCHandleType.Pinned)</code> して持ち回します。</p>
<h2>Rust for C# Developer</h2>
<p>Rustは、正直すごい気に入ってます。C#の次に気に入りました……！まぁ正直、これで全部やる、Webもなにもかも作る、みたいなのはヤバいかな、と思います。RustでWebやりたいって人はあれでしょ、型がついてて開発環境が充実していてエコシステムが回ってる言語がいいんでしょ？ちょうどいい言語があるんですよ、C#という。……。ではあるんですが、ネイティブが必要って局面で、やりたくないーって逃げたり、NativeAOTがなんとかしてくれるだのといった現実逃避したりせず、ちゃんと正面から向き合えるようになったということはいいことです。</p>
<p>で、実際RustはかなりC#erに馴染む道具だと思っていて、そもそもインターフェイスがないかわりにstructとジェネリクスとtrait(インターフェイスみたいなやつ)で処理するってのは、別にそれC#でもやってますよ！C#のパフォーマンス最速パターンってstructにインターフェイス実装してジェネリクスの型制約でインターフェイス指定してボクシング/仮想メソッド呼び出し回避でstruct投げ込むことですからね。ようはC#の最速パターンだけが強制されてるんだと思えば何も違和感がない。</p>
<p>インスタンスメソッドがないかわりに全部拡張メソッドみたいな雰囲気なのも、いやー、C#も、もはやインスタンスメソッドと拡張メソッド、どっちで実装すればいいかなーって切り分けに悩むこともあるし、<a href="https://ufcpp.net/blog/2023/3/extensions/">C# 12候補のExtensions</a>なんてきたら完全にどこで実装すりゃいいのかわからんわ、ってなるので、拡張メソッド一択(impl, trait)ですよ、みたいなのはすっきり整理されていて逆にいい。</p>
<p>シンタックスも自然というかC系の多数派に寄り添った感じで親しみやすいし、ドットでメソッド繋げていくので、馴染み深いオブジェクト指向的な手触りが十分ある。それとミュータブルに寛容なところがいいですね。関数型にありがちなイミュータブル至上主義ではなく、どちらかというとメモリそこにあるんだからミュータブルやろ、みたいな雰囲気なのがとてもいい。無駄もないし。所有権周りが厳密なのでミュータブルであっても固めな手応えなのは、これでいいんだよというかこれで的な何かではある。</p>
<p>マクロはコンパイル時ExpresionTreeみたいなもので、proc-macroはSource Generatorみたいなものなので、何が可能になるかすぐに理解できるし、便利さもよくわかる。ていうかコンパイル時ExpressionTreeはC#にも欲しい（実行時だからコスト重いのであんま使わないのでコンパイル時に解決するならもっとばんばん使えるはずなんだよねえ）。ただ、自由度がとても高いせいでマクロに入ると入力補完が完全に効かなくなる。そして自由度が高いのでマクロでDSL的な流れに高級ライブラリほどなりがちで、完全にマニュアル引きが必要になってくるのが、見た目はキレイにおさまるけど書き味はよくないな、的な体感になるのがもったいない。その点でいうとC#はやっぱ入力補完最優先な言語で、一貫した安定感を提供しているのはとても良いですね。</p>
<p>キツいかなーと思うのは所有権がどうとかっていうよりも、ジェネリクスの見た目がキツい。C#だったらインターフェイスで動的ディスパッチで整理されているものが、ジェネリクスで静的ディスパッチに倒れているのでジェネリクスの出現率がめっちゃ高い。いや、だってC#でもジェネリクスでると読みやすさ的には一段落下がるわけじゃないですか、それが当たり前って感じだと、慣れとかって問題じゃなく見やすさレベルは下がる。更にその上にジェネリクスがネストするのが当たり前。C#だったらジェネリクスがネストしてるのは見やすさレベル最底辺なので極力出現しないようにしたいって感じなのですが、Rustだと日常茶飯事に出てくる。<code>Option&lt;Rc&lt;RefCell&lt;_&gt;&gt;&gt;</code>とかも全然普通に出現するのが、うーむ。理屈では納得いくから特に文句があるようでなにもないんですが。</p>
<p>なんだったらパターンマッチも別に好きじゃないしOptionもResultも好きじゃないしnullの何が悪いんだよぐらいの気持ちにならなくもないんですが、まぁそれはそれ。でも全体的には凄い良いですね、ほんと。</p>
<h2>まとめ</h2>
<p>ところで<a href="https://github.com/Cysharp/csbindgen">csbindgen</a>のReadMeのほうには更にもっといっぱい変換パターンを紹介していますので、是非そちらもチェックしてみてください。</p>
<p>ネイティブ呼び出しは定義の部分でも、二重定義がそもそもダルいうえに、かなり気を使わなきゃいけないことがなにげに多くて割と大変というか知識量と単純作業量を要求してくるのですが、csbindgenはその部分を完全自動化してくれます。自分でも使っててネイティブコードめっちゃ楽……！という気になります。事実楽。すごい。その後のメモリ管理に関しては、そこはまぁ思う存分悩んでくれという話になるのですが、もはや複雑な点がそれだけに落ち着いたという点では、やはり革命的に便利なのでは？という気になります。</p>
<p>Cのライブラリを持ってくるのも圧倒的に楽なので、私の中でもちょっと考え方が変わってきました。今までは割とPure C#実装至上主義、みたいなところがあったんですが、うまい切り分け、使い分けみたいなのを考えられるようになりました。そして、Cライブラリ利用がより自由になると、まさに<a href="https://cysharp.co.jp/">Cysharp</a>の掲げる「C#の可能性を切り開いていく」ことにまた一つ繋がってしまったな、と。</p>
<p>まずはこの後に数個、csbindgenを活用したC#ライブラリを提供する予定があります！のですが、その前に、Rustかー、とは思わずに是非csbindgen、試してみてもらえると嬉しいです。</p>
</div>
<h1><a href="https://neue.cc/2023/01/30-SimdLinq.html">SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ</a></h1>
<ul class="date"><li>2023-01-30</li></ul>
<div class="entry_body"><p>ついこないだの<a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a>は、SoAになってるとSIMDを適用しやすいよ、という話だったのですが、そもそもSIMD手書きはカジュアルにやらないし、気合い入れてSIMD書くシチュエーションなら構造も気合い入れて専用に設計するよなぁ。と、なると、カジュアルにSIMD使えるライブラリが必要で、まぁLINQですね、と。</p>
<ul>
<li><a href="https://github.com/Cysharp/SimdLinq">Cysharp/SimdLinq</a></li>
</ul>
<p>これを入れると別にSoA関係なく、SIMDが適用できる状態(例えばint[]にSum)だと、自動的にSIMDが適用されるようになります。そして、実際めちゃくちゃ速い。</p>
<p><img src="https://user-images.githubusercontent.com/46207/215410106-b68d8567-5abf-4aa4-a050-a803b1913187.png" alt="" /></p>
<p>SIMDとLINQの組み合わせが威力を発揮するというのは、別に新しいことではなく、そもそも .NET 7でも<a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#linq">Performance Improvements in .NET 7 LINQ</a>で、幾つかのメソッドが内部でSIMD化されて高速化されていることが発表されています。しかし、 .NET 7のSIMD対応は非常に限定的なもので、具体的には<code>int[]</code>の<code>Average</code>,<code>Min</code>,<code>Max</code>、それと<code>long[]</code>の<code>Min</code>,<code>Max</code>だけです。これには理由はなくはないのですが、本来SIMD対応できる範囲はもっと広いため、これでは非常にもったいない。</p>
<p>SimdLinqを適用できるメソッドは <code>Sum</code>, <code>Average</code>, <code>Min</code>, <code>Max</code>, <code>MinMax</code>, <code>Contains</code>, <code>SequenceEqual</code>、要素の型は <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code> int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code>、コレクションの型は <code>T[]</code>, <code>List&lt;T&gt;</code>, <code>Span&lt;T&gt;</code>, <code>ReadOnlySpan&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, <code>ReadOnlyMemory&lt;T&gt;</code> と理屈上SIMD化できるものを全て詰め込みました。特に<code>Span&lt;T&gt;</code>/<code>ReadOnlySpan&lt;T&gt;</code>は通常のLINQでは使えない（メソッドが定義されていない）ので、有益です。また、Min, Maxを同時に取得する<code>MinMax</code>というメソッドを独自に追加しています。</p>
<p>専用メソッドを呼ばせる（例えば<code>SumSimd()</code>とか)ようでは使いにくいと思ったので、現在のコードを何も弄らずとも、ライブラリ参照してglobal usingを設定すれば、全ての適用可能なメソッドに自動適用される仕組みにしました。これは同名メソッドを定義して、具象型のほうにオーバーロード解決が優先採用されることを利用しています。</p>
<h2>使い方</h2>
<p>なので、使い方もなにもなく、usingすれば勝手にSimdLinqになって高速化されます。</p>
<pre><code class="language-csharp">using SimdLinq; // enable SimdLinq extension methods

var array = Enumerable.Range(1, 100000).ToArray();

var sum = array.Sum(); // used SimdLinqExtensions.Sum
</code></pre>
<p>using忘れちゃうというのはあるので、そこでglobal usingです。csprojに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Using Include=&quot;SimdLinq&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>というのを仕込んでやれば、SimdLinqが使える場合はSimdLinqに、そうじゃないものは普通のLinqでオーバーロードが解決されるようになります。便利。</p>
<p>具体的にSimdLinqが適用されるメソッドは以下のものになります。</p>
<ul>
<li><code>Sum</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>LongSum</code> for <code>int</code>, <code>uint</code></li>
<li><code>Average</code> for <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Min</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Max</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>MinMax</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>Contains</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
<li><code>SequenceEqual</code> for <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code>, <code>float</code>, <code>double</code></li>
</ul>
<h2>互換性と安全性</h2>
<p>.NET 7の標準に、このSimdLinqのようなアグレッシブなSIMD化が入らなかった理由は、互換性と安全性になります。え、安全じゃないの？というと怖くなるので、何が違うのかはしっかり把握しておきましょう。別に危険、というわけではないですが。</p>
<p>まずSumとAverage(Averageの中身はSumしたのをLengthで割るだけなので中身は実質Sum)ですが、LINQのSumはcheckedで、オーバーフローすると例外を吐きます。SimdLinqはuncheckedです、つまりオーバーフローするとそのままオーバーフローしたまま結果を返します。checkedのほうが挙動としてはいいんですが、SIMD演算がオーバーフローのチェックできないので、SimdLinqではuncheckedとして提供しています。オーバーフローに関しては自己責任で。さすがにbyteのSumとかだとすぐオーバーフローしちゃうので、SimdLinqのSumは32 bit以上の要素にだけ提供しています、つまり<code>int</code>, <code>long</code>, <code>uint</code>, <code>ulong</code>, <code>double</code>, <code>float</code> です。そもそも元々のLINQのSum(引数なし)も<code>int</code>からなので、その辺は一緒ということで。</p>
<p>そうしたオーバーフローの危険性を避けたい場合、独自拡張として <code>LongSum</code> というlongを戻り値にするSumメソッドを追加しています。内部的にlongで処理するため、(若干性能は落ちますが)オーバーフローしなくなります。</p>
<p>float/doubleの扱いは挙動の違いが若干あります。まず、通常のLINQのMin, Maxは<code>NaN</code>をチェックしますがSimdLinqは<code>NaN</code>をチェックしません。<code>NaN</code>チェックがあったほうが丁寧ですが、SIMDでそれは入れずらい＆NaNが入ってくるケースってあまりないので現実的にすごい問題か、というとそうではないかな、と。</p>
<p>それとSumの場合に足し算の順序が変わって(LINQは前から順番に足しますが、SIMDだと並列に足すので)、浮動小数点演算だと足す順序が変わると微妙に誤差が出て同じ結果になりません。例えばLINQだと<code>1.5710588F</code>だけどSimdLinqだと<code>1.5710589F</code>になる、といったような違いが出てきます。結果としては別にどっちでも良い（ある意味で別にどっちも厳密にはあってない）と思いますが、結果の互換性がないですよ、ということは留意してください。</p>
<h2>まとめ</h2>
<p>高速なLINQのAlternativeって、結構あります。<a href="https://github.com/kevin-montrose/LinqAF">LinqAF</a>、<a href="https://github.com/jackmott/LinqFaster">LinqFaster</a>、<a href="https://github.com/NetFabric/NetFabric.Hyperlinq">NetFabric.Hyperlinq</a>など。ただ、どれも大仰なんですよね、StructのIteratorを作ってー、とか。専用メソッドを呼ぶためにラップするのも手間だし、その割に凄い効果的というほどでもないから、依存を増やす割にはメリットも薄くなので、私自身は使おうとはあまり思ってませんでした。</p>
<p>そこでSimdLinqではLINQ全体を高速化させることを狙っているわけではなくて、SIMDが適用できるものだけピンポイントに、そしてソースコードには一切手を入れる必要のない&quot;Drop-in replacement&quot;になるようにデザインしました。また、SIMDのみに絞ったことで性能面に明らかに圧倒的な差をだして、あえて使う理由を作る、といったところですね。</p>
<p>ついでにそうなると欲張ってどんどん適用できる箇所を増やしたい、つまりは<a href="https://github.com/Cysharp/StructureOfArraysGenerator">StructureOfArraysGenerator</a>だ、みたいなコンボも狙っています。エコシステム囲い込み！囲い込みはEvil！</p>
<p>そんなわけでSIMDシリーズ第一弾でした。今年はSIMD関連も幾つか出していくかもしれませんし、Source Generatorネタがめちゃくちゃ溜まってるので時間が無限大に必要です。まぁ、ともかくまずはSimdLinqを使って見てください！</p>
</div>
<h1><a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html">StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator</a></h1>
<ul class="date"><li>2023-01-27</li></ul>
<div class="entry_body"><p>最近はSource Generatorブームが続いていて、去年末に<a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a>という記事を出しましたが、まずは今年第一弾のSource Generatorライブラリです。</p>
<ul>
<li><a href="https://github.com/Cysharp/StructureOfArraysGenerator/">github.com/Cysharp/StructureOfArraysGenerator</a></li>
</ul>
<p>これは何かというと、structure of arrays(SoA)を使いやすくするためのコードを生成するというものです。まずそもそもSoAですが、Wikipediaの<a href="https://en.wikipedia.org/wiki/AoS_and_SoA">AoS and SoA</a>という記事によるところ（日本語版はない）、CPUキャッシュを有効活用したりSIMDを適用させやすくなる構造だよ、と。通常C#の配列はarray of structures(AoS)になります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png" alt="" /></p>
<p>上の通常の配列がAoSでXYZXYZXYZXYZといったように並んでいる構造ですが、下のStructureOfArraysGeneratorで生成したSoAの配列はXXXXYYYYZZZZという並び順になります。実際にシンプルなパフォーマンステスト（Vector3[10000]に対してYの最大値を求める）によるところ</p>
<p><img src="https://user-images.githubusercontent.com/46207/215027253-6f94739f-b827-46ba-a395-690d1df89d46.png" alt="" /></p>
<p>そのまま書いても2倍、SIMDで書きやすい状態なのでSIMDで処理してしまえば10倍高速化されます。というわけで、パフォーマンスが求められるシチュエーションで非常に有用です。</p>
<p>このライブラリはZigという最近、日本でも注目されている言語（Node.jsの高速な代替として注目されている<a href="https://bun.sh/">Bun</a>の実装言語）のMultiArrayListにインスパイアされました。Zigの作者 Andrew Kelley氏が講演した <a href="https://vimeo.com/649009599">A Practical Guide to Applying Data-Oriented Design</a> という素晴らしい講演があるので是非見て欲しいのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/215052372-1ab33bd2-a578-4c26-8e99-7615a49707ea.png" alt="image" /></p>
<p>データ指向設計(Data-Oriented Design)はパフォーマンスを飛躍的に改善する魔法なのです。ん、それはどこかで聞いたような……？そう、<a href="https://unity.com/ja/dots">UnityのDOTS</a>です。Data-Oriented Technology Stackです。ECSです。……。まぁ、そんなわけで全体に導入するにはそうとうガラッと設計を変える必要があるので大変厳しくはあるのですが、講演での実例としてZig自身のコンパイラの事例が出てますが、まぁつまりは徹底的にやれば成果は出ます。</p>
<p>しかしまぁ徹底的にやらず部分的に使っても効果があるのはUnityで Job System + Burst ぐらいでいいじゃん、という気持ちになっていることからも明らかです。というわけで部分的なSoA構造の導入にお使いください、かつ、導入や利用の敷居は全然高くないように設計しました。</p>
<h2>MultiArray</h2>
<p>NuGetからインストール（Unityの場合はgit参照か.unitypackageで）するとAnalyzerとして参照されます。StructureOfArraysGeneratorは属性も含めて依存はなく全てのコードが生成コードに含まれる（属性はinternal attributeとして吐かれる）ので、不要なライブラリ依存が増えることはありません。</p>
<p><code>[MultiArray(Type)]</code>を配列的に使いたい<code>readonly partial struct</code>につけます。</p>
<pre><code class="language-csharp">using StructureOfArraysGenerator;

[MultiArray(typeof(Vector3))]
public readonly partial struct Vector3MultiArray
{
}
</code></pre>
<p>するとSource Generatorは内部的にはこういうコードを生成します。</p>
<pre><code class="language-csharp">partial struct Vector3MultiArray
{
    // constructor
    public Vector3MultiArray(int length)

    // Span&lt;T&gt; properties for Vector3 each fields
    public Span&lt;float&gt; X =&gt; ...;
    public Span&lt;float&gt; Y =&gt; ...;
    public Span&lt;float&gt; Z =&gt; ...;

    // indexer
    public Vector3 this[int index] { get{} set{} }

    // foreach
    public Enumerator GetEnumerator()
}
</code></pre>
<p>Structure of <strong>Arrays</strong> と言ってますが、StructureOfArraysGeneratorは Arrays は生成しません。内部的には単一の <code>byte[]</code> と各開始地点のオフセットのみを持っていて、生成されるプロパティによって<code>Span&lt;T&gt;</code>のビューを返すという設計になっています。</p>
<p>使い方的には配列のように使えますが、<code>Span&lt;T&gt;</code>の操作、例えばref var item inによるforeachを使うと、より効率的に扱えます。</p>
<pre><code class="language-csharp">var array = new Vector3MultiArray(4);

array.X[0] = 10;
array[1] = new Vector3(1.1f, 2.2f, 3.3f);

// multiply Y
foreach (ref var item in v.Y)
{
    item *= 2;
}

// iterate Vector3
foreach (var item in array)
{
    Console.WriteLine($&quot;{item.X}, {item.Y}, {item.Z}&quot;);
}
</code></pre>
<p>Yに2倍を掛ける処理などは、メモリ領域が連続していることにより、<code>Vector3[]</code>を <code>item.Y *= 2</code> などとして書くよりも高速に処理されます．</p>
<p>他に<code>List&lt;T&gt;</code>のようにAddできる<code>MultiArrayList</code>や、内部的には<code>byte[]</code>を持っているだけであることを生かした<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>での超高速なシリアライズなどにも対応しています。気になったら是非ReadMeのほうを見てください。</p>
<h2>.NET 7 時代のSIMD</h2>
<p>.NETはSIMD対応が進んでいて、<a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.x86">System.Runtime.Intrinsics.X86</a>によって、直接ハードウェア命令を書くことが出来ます。</p>
<p>しかし、しかしですね、最近は .NET を Arm で動かすことが現実的になってきました。iOSやAndroidでけはなくMacのArm化、そしてAWS GravitonのようなArmサーバーはコスト面でも有利で、選択肢に十分入ります。そこでAvx.Addなんて書いていたらArmで動きません。勿論 <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.intrinsics.arm">System.Runtime.Intrinsics.Arm</a> というクラスも公開されていて、Arm版のSIMDを手書きすることもできるんですが、分岐して似たようなものを二個書けというのか！という話です。</p>
<p>そこで、 <a href="https://zenn.dev/pcysl5edgo/articles/d3e787599c5c8b">.NET 7こそがC# SIMDプログラミングを始めるのに最適である理由</a> という記事があるのですが、確かに .NET 7 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256.loadunsafe">Vector256.LoadUnsafe</a> がまずめちゃくくちゃイイ！馴染みが深い（？）Unsafeによる ref var T で書けます！そして<a href="https://github.com/dotnet/runtime/issues/49397">Expose cross-platform helpers for Vector64, Vector128, and Vector256</a>により、<code>Vector64/128/256&lt;T&gt;</code>にプラットフォーム抽象化されたSIMD処理が書けるようになりました、やはり .NET 7から。</p>
<p>例えば .NET 7 でint[]のSumのSIMD化を書いてみます。</p>
<pre><code class="language-csharp">var array = Enumerable.Range(1, 100).ToArray();

ref var begin = ref MemoryMarshal.GetArrayDataReference(array);
ref var last = ref Unsafe.Add(ref begin, array.Length);

var vectorSum = Vector256&lt;int&gt;.Zero;
ref var current = ref begin;

// Vector256で処理できるだけ処理
ref var to = ref Unsafe.Add(ref begin, array.Length - Vector256&lt;int&gt;.Count);
while (Unsafe.IsAddressLessThan(ref current, ref to))
{
    // 直接足し算できて便利
    vectorSum += Vector256.LoadUnsafe(ref current);
    current = ref Unsafe.Add(ref current, Vector256&lt;int&gt;.Count);
}

// Vector256をintに戻す
 var sum = Vector256.Sum(vectorSum);

// 残りの分は単純処理
while (Unsafe.IsAddressLessThan(ref current, ref last))
{
    sum += current;
    current = ref Unsafe.Add(ref current, 1);
}

Console.WriteLine(sum); // 5050
</code></pre>
<p>まぁforがwhileのアドレス処理になっていたり、最後にはみ出た分を処理する必要がありますが、かなり自然にSIMDを扱えているといってもいいんじゃないでしょうか。(Unsafeに慣れていれば)かなり書きやすいです。いいね。</p>
<p>ところで .NET 7からLINQがSIMD対応してるからこんなの書く必要ないでしょ？というと、対応してません。LINQのSIMDはint[]のAverage, int[]のMin, Max, long[]のMin, Maxのみと、かなり限定的です。これは互換性の問題などなどがあり、まぁオマケみたいなものだと思っておきましょう。必要な局面があるなら自分で用意する方が無難です。</p>
<p>ともあれ、.NET 7 からは手書きX86 SIMDはArm対応が漏れやすいので、極力Vectorによって抽象化されたコードで書きましょう、ということになります。どうしてもVectorじゃ書けないところだけ、仕方なく書くという感じですね。</p>
<h2>まとめ</h2>
<p>反響全然ないだろうなあと想定していましたが、やはり反響全然ないです！まぁでも結構面白いライブラリになったと思うので、是非使ってください。それと、Incremental Source Generatorの作り方がMemoryPackの頃よりも習熟していて、コードがかなり洗練されたものになっているので、Source Generatorの作り方として参照するならMemoryPackのコードよりもこちらのコードのほうがお薦めです。</p>
<p>というわけで、まだまだSource Generatorネタはいっぱいあるので、今年は大量に量産します！</p>
</div>
<h1><a href="https://neue.cc/2022/12/30_year.html">2022年を振り返る</a></h1>
<ul class="date"><li>2022-12-30</li></ul>
<div class="entry_body"><p>今年はCysharpとしては、（控えめながら）露出があったので、何やってるかわからない、むしろ存在してるんですか？といったところから脱却したのではないでしょうか……？相変わらず<a href="https://cysharp.co.jp/">ホームページはペライチ</a>ですけれど。そろそろいい加減、更新したい。</p>
<p>大きなところでは <a href="https://neue.cc/2022/04/">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a> というわけで、結構長くCygamesと一緒に作っていたゲームがリリースされました。超期間限定だったのでもうプレイできませんが……！技術的な詳細はCygamesのほうから <a href="https://cedil.cesa.or.jp/cedil_sessions/view/2637">C#によるクライアント/サーバーの開発言語統一がもたらす高効率な開発体制 ～プリコネ！グランドマスターズ開発事例～</a> という形でCEDECで講演していますが、2022年現在の開発体制としてはかなり先端を走っている、かつ、とてもいい感じに仕上がっています。</p>
<p>MagicOnion採用タイトルも増えていて、特に今年リリースされたタイトルで一番大きなものは<a href="https://mememori-game.com/">メメントモリ</a>でしょうか、<a href="https://twitter.com/neuecc/status/1595729906528587781">MagicOnion, MessagePack for C#を採用していただいています</a>。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>は12/28にv5をリリースしたばかりです！内部アーキテクチャの変更によるパフォーマンス向上や拡張性の確保、そして<a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>への対応といった、次世代に向けて大きく基盤整理されました。今後もSource Generatorフル対応などが控えています。</p>
<p>OSS関連も、振り返るとかなり充実していました。後半、既存OSSのメンテが滞り気味だったのは来年消化します……！</p>
<ul>
<li><a href="https://neue.cc/2022/02/28_DFrame.html">DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</a></li>
<li><a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a></li>
<li><a href="https://neue.cc/2022/11/04_memorypack.html">MemoryPackにみる .NET 7/C# 11世代のシリアライザー最適化技法</a></li>
</ul>
<p>今年も自分のプログラミング能力の成長を実感できています。技術的に腐り始めたら一瞬！みたいな危機感はあるので、こうして毎年の成長を、ちゃんと対外的にも示し続けられているのはいいことかな。自分はできてると思ってるけど外から見るとやべぇ、みたいなパターンは往々にありますからね、常に実証と共にありたいです。</p>
<p>特にMemoryPackは次世代の基準を打ち立てられたのではないかと思います。GitHub Starも3ヶ月で1300到達、非常に良い感じです。作ってる最中は、私が今これをやりきらなきゃC#は10年遅れてしまうんだ、みたいな気持ちでヒィヒィいいながら書いてましたが、大言壮語な妄想ではなく実際いい感じのものを出せたのではないでしょうか。</p>
<p>Source Generatorの解説を <a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a> として書きましたが、改めてC#にとってSource Generatorはめちゃくちゃ重要なテクノロジーになると、今更ながらに理解しました。いや、2020年の終わりに <a href="https://neue.cc/2020/12/15_597.html">UnitGenerator</a> を作ってから（これは今も使ってます）、しかしそこまで突き詰めてこなかったんですよね、今の今まで。来年はSource Generator元年ということで、色々な分野で革命的なものを大量に投下したいと思ってます。今なんかアイディアが溢れてるんですよ……！</p>
<p>というわけで来年はいっぱいやることがある！今年に悔いが残るとすれば、Cysharpとして現在、自称革命的なサービス（？）を作ってるんですが、それの進捗があまり良くなかったことですかねえ。原因としては私がOSS関連でフラフラしててプロジェクトマネージャー/プロダクトオーナーとして1ミリも機能いてなかったせいなのですが！反省。PM的な話は昔からずっと反省し続けてるので一向に進歩してないですね……。そこに脳みそ注ぎ込む余力がないのだと言い訳してますが……。</p>
<p>そんなわけで、来年こそは革命的サービスもリリースするので期待していてください。OSS関連も革命的なものをどかどか投下する予定なので、引き続きCysharpは時代の最先端を全力疾走していきます。</p>
</div>
<h1><a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a></h1>
<ul class="date"><li>2022-12-16</li></ul>
<div class="entry_body"><p>このブログでもSource GeneratorやAnalyzerの開発手法に関しては定期的に触れてきていて、新しめだと</p>
<ul>
<li><a href="https://neue.cc/2020/12/15_597.html">2020/12/15 - UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips</a></li>
<li><a href="https://neue.cc/2021/05/08_600.html">2021/05/07 - 2021年のC# Roslyn Analyzerの開発手法、或いはUnityでの利用法</a></li>
</ul>
<p>という記事を出していますが、今回 <a href="https://github.com/Cysharp/MemoryPack/">MemoryPack</a> の実装で比較的大規模にSource Generatorを使ってみたことで、より実践的なノウハウが手に入りました。また、開発環境も年々良くなっていることや、Unityのサポート状況も強化されているので、状況を一通りまとめてみようと思いました。Source Generatorは非常に強力で、今後必須の開発技法になるので（少なくとも私はもうIL書きません！）是非、この機会に手を出して頂ければです。</p>
<h2>Microsoft.CodeAnalysis.CSharpのバージョン問題</h2>
<p>Source Generatorを作成するには <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp/">Microsoft.CodeAnalysis.CSharp</a>を参照したライブラリを作ればいい、のですが、ここで大事なのはバージョンです。何も考えずに最新を入れると動かないという罠が待ってます。Source Generatorは、インストールされている .NET のバージョンや IDEのコンパイラバージョンと深く紐づいています。.NETのバージョンだけ上げてもダメで、特にVisual Studioの場合は.NETのバージョンと独立して、同梱されているコンパイラのバージョンがあり、それと合わせる必要があります。Unityの場合も同じく、Unityに含まれるC#コンパイラのバージョン(/Editor/Data/DotNetSdkRoslyn/Microsoft.CodeAnalysis.CSharp.dll)を精査する必要があります。使わているバージョンよりも高いバージョンのものを参照すると、動かないという理屈です。</p>
<p>Visual Studioのバージョンとの紐づきは <a href="https://learn.microsoft.com/ja-jp/visualstudio/extensibility/roslyn-version-support">.NET コンパイラ プラットフォーム パッケージ バージョン リファレンス</a>を見れば分かりますが、現状の私のオススメは <code>4.3.1</code> です（現時点での最新は <code>4.4.0</code> ）。これは最小サポートバージョンがVisual Studio 2022 Version 17.3ということで、VS2019は切り捨てでいいでしょう。VS2022使ってるなら、とりあえずそこまでアップデートしてくれ、ということで。古ければ古いほどカバーできる範囲が広がっていい！ようでいて、古ければ古いほど、新しい言語機能の解析ができないなどの問題があるので、お薦めはできません、むしろ何も問題がなければ新しければ新しいほどいいぐらいです。4.3.1がおすすめな最大の理由としては、<code>SyntaxValueProvider.ForAttributeWithMetadataName</code> という、後で説明しますが、Source Generator作成の際に必須とも言える便利メソッドが追加されていることです。<code>4.4.0</code> だとC# 11解析サポートが追加されている、はずなのですが公式ドキュメントのほうにVisual Studioとの対応関係がまだ追加されていないというのもあり手を出しにくい……。</p>
<p>Unityの場合は公式にC#コンパイラのバージョンが何であるかのリストはないので、自分で調べていく必要がありますが、とりあえず<a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Roslyn analyzers and source generators</a>という公式ドキュメントによると「must use Microsoft.CodeAnalysis 3.8」、というわけで3.8じゃないと動かないぞ、と脅しをかけてきてます。が、実際は現状のLTS環境では3.9が搭載されているようなので、3.9を使ったほうがいいでしょう。例えばUnity 2021.3は3.9が入っていて、実際ちゃんと3.9でも動きますし、APIが3.8と3.9でかなり変わっているので、3.9で作ったほうが楽です。ドキュメントは更新が遅れて最新の話が反映されていない場合が往々にあるので、正しい現状把握は重要ですね。</p>
<p>Microsoft.CodeAnalysis.CSharpのバージョンは大きく分けて 3.* と 4.* があり、3.* はv1の <code>ISourceGenerator</code>、4.* はv2である <code>IIncrementalGenerator</code> が使えます。</p>
<p><a href="https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md">Incremental Generators</a>は、性能面で大きく改善されている他、作りやすさも大きく上がっているため、現状は Incremental Generators で作ることを最優先で考えたほうがいいでしょう。登場の黎明期では、IDEのバージョン問題があったために、3.* と 4.* の両方のSource Generatorを作って一緒にNuGetパッケージングする、という（かなりややこしい）手法が取られたこともありましたが、もう .NET 7も登場した2022年、も終わろうとしている現在ですので、 3.* は切り捨ててしまってもいいと考えています。</p>
<p>ただしUnityは除く。調べたところUnityでは Unity 2022.2, Unity 2023.1 から、4.1.0のコンパイラが搭載されているようなので、そこを最小ターゲットにすればIncremental Generatorを動かすこともできなくはないのですが、さすがに攻めすぎなので、Unityをターゲットにする場合のみ 3.* で生成したものを配布する、といった形がいいのではないかと思っています。 3.* と 4.* 版の両方を作るという手間はありますが、NuGetパッケージングのややこしさには手を出さなくてもいい。ぐらいが現状の落としどころじゃないでしょうか。</p>
<h2>最小プロジェクトとデバッグ実行</h2>
<p>Source Generator開発は、デバッグ環境をきっちり構築できていないとかなり大変です。なので環境構築をしっかりやってから挑みましょう。ここではWindowsのVisual Studio 2022を使った場合の説明のみしますが、他の環境でも、同等のことができるようにしておかないとめちゃくちゃ大変です。</p>
<p>まず「.NET Compiler Platform SDK」を入れましょう。標準では入ってないので。入れておかなくても開発はできるのですが、デバッグ起動ができなくなるため、ほぼ必須と思ってください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/207808216-9b65a422-5cd5-4a74-99a8-8635c65437c6.png" alt="image" /></p>
<p>次に、「netstandard2.0」のクラスライブラリプロジェクトを作成します。え、2022年にもなってnetstandard2.0なの？なんで？standard2.1やnet7じゃダメなの？という感じですが、そもそもVisual Studioが .NET Frameworkで動いているというしょっぱい事情があり、Source Generatorプロジェクトはnetstandard2.0で作る必要があるという制限があります。使えるクラスライブラリが少なくて辛い感もありますが我慢です。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;

		&lt;!-- LangVersionは明示的に書いておこう --&gt;
		&lt;LangVersion&gt;11&lt;/LangVersion&gt;
		&lt;!-- Analyzer(Source Generator)ですという設定 --&gt;
		&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
		&lt;AnalyzerLanguage&gt;cs&lt;/AnalyzerLanguage&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.1&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;

namespace SourceGeneratorSample;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Providerシリーズ
        // context.AdditionalTextsProvider
        // context.AnalyzerConfigOptionsProvider
        // context.CompilationProvider
        // context.MetadataReferencesProvider
        // context.ParseOptionsProvider
        // context.SyntaxProvider

        // Registerシリーズ
        // context.RegisterImplementationSourceOutput
        // context.RegisterPostInitializationOutput
        // context.RegisterSourceOutput
    }
}
</code></pre>
<p>これで無のSource Generatorができたので（contextの解説は準備が一通り終わったらします）、次に、このGeneratorを参照するConsoleAppを適当に作成します。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Exe&lt;/OutputType&gt;
		&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\SourceGeneratorSample\SourceGeneratorSample.csproj&quot;&gt;
			&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
			&lt;ReferenceOutputAssembly&gt;false&lt;/ReferenceOutputAssembly&gt;
		&lt;/ProjectReference&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>Source Generatorのプロジェクト参照では、OutputItemTypeとReferenceOutputAssemblyの設定を追加で手書きしてください。</p>
<p>次にまたSource Generator側のプロジェクトに戻って、プロジェクトのプロパティから「デバッグ起動プロファイルUIを開く」を選んでください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009373-a5f32edb-998b-4fde-844b-f67b52da8747.png" alt="image" /></p>
<p>既にあるプロファイルは削除した上で、左上の「新しいプロファイルの作成」から「Roslyn Component」を選択。ここでRoslyn Componentが出てこない場合は、「.NET Compiler Platform SDK」を入れているかどうかの確認と、csprojに<code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code>を追加しているかどうかの確認をしてください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009505-a6e86403-c42c-4f0b-bf53-97c5e42d367d.png" alt="image" /></p>
<p>そしてTarget Projectに、先ほど作成したSource Generatorを参照しているコンソールアプリプロジェクトを選びます。プロジェクトが選べない場合は、対象プロジェクトがSource GeneratorをAnalyzerとしてのプロジェクト参照をしているかどうかを確認してください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009562-74d267c6-584e-43fd-93a5-c180b1c4de1e.png" alt="image" /></p>
<p>これで準備が完了で、Source Generatorをデバッグ実行(F5)すると、対象コンソールアプリプロジェクトを引っ掛けた状態で起動するようになります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208011024-62d3cae7-08f7-45d3-b910-312b3137d663.png" alt="image" /></p>
<p>あとは、ひたすら、Generatorのコードを書いていくだけです、めでたし。</p>
<h2>ForAttributeWithMetadataName</h2>
<p>細かい説明に行く前に、基本的な流れの説明を。Source Generatorは、通常、なにか適当な属性がついているpartial classやpartial methodを探して、それに対して追加のpartial class/methodを生成する、という流れになります。原理的には属性がついていなくてもいいですが、勝手に何かを生成されるとわけわかんなくて困るので、ユーザーに明示的に生成を指示させるような流れにすべき、ということで、起点は属性付与だけと考えていいでしょう。</p>
<p>そんなわけでSource Generatorでまずやることは、属性が付与されてるclass/methodを探し出すことなのですが、Roslyn 4.3.1からは <code>SyntaxValueProvider.ForAttributeWithMetadataName</code> というメソッドで一発で探し出すことができるようになりました。</p>
<p>というわけで、小さなサンプル用ジェネレーターとして、classのToStringをrecordのように自動実装するジェネレーターを作ってみます。</p>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGeneratorSample;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // PostInitializationOutputでSource Generatorでしか使わない属性を出力
        context.RegisterPostInitializationOutput(static context =&gt;
        {
            // C# 11のRaw String Literal便利
            context.AddSource(&quot;SampleGeneratorAttribute.cs&quot;, &quot;&quot;&quot;
namespace SourceGeneratorSample;

using System;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class GenerateToStringAttribute : Attribute
{
}
&quot;&quot;&quot;);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            &quot;SourceGeneratorSample.GenerateToStringAttribute&quot;, // 引っ掛ける属性のフルネーム
            static (node, token) =&gt; true, // predicate, 属性で既に絞れてるので特別何かやりたいことがなければ基本true
            static (context, token) =&gt; context); // GeneratorAttributeSyntaxContextにはNode, SemanticModel(Compilation), Symbolが入ってて便利

        // 出力コード部分はちょっとごちゃつくので別メソッドに隔離
        context.RegisterSourceOutput(source, Emit);
    }
</code></pre>
<p>Initializeメソッドの行数の短さ！というわけで、Source Generator作り自体はかなり簡単になりました。ここまでがSourceGeneratorとして属性を引っ掛けて何かするための準備部分の全てであり、過去の諸々に比べると明らかに改善されています。</p>
<p>ただし、そうして抽出したところを加工して何かする部分は特に変わりないので、気合で頑張っていきましょう。↑のコードの続きは以下のものになります。</p>
<pre><code class="language-csharp">    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        // classで引っ掛けてるのでTypeSymbol/Syntaxとして使えるように。
        // SemaintiModelが欲しい場合は source.SemanticModel
        // Compilationが欲しい場合は source.SemanticModel.Compilation から
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        // ToStringがoverride済みならエラー出す
        if (typeSymbol.GetMembers(&quot;ToString&quot;).Length != 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ExistsOverrideToString, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // グローバルネームスペース対応漏れするとたまによく泣くので気をつける
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? &quot;&quot;
            : $&quot;namespace {typeSymbol.ContainingNamespace};&quot;;

        // 出力ファイル名として使うので雑エスケープ
        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace(&quot;global::&quot;, &quot;&quot;)
            .Replace(&quot;&lt;&quot;, &quot;_&quot;)
            .Replace(&quot;&gt;&quot;, &quot;_&quot;);

        // Field/Propertyを抽出する
        var publicMembers = typeSymbol.GetMembers() // MethodがほしければOfType&lt;IMethodSymbol&gt;()などで絞る
            .Where(x =&gt; x is (IFieldSymbol or IPropertySymbol)
                         and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true })
            .Select(x =&gt; $&quot;{x.Name}:{{{x.Name}}}&quot;); // MyProperty:{MyProperty}

        var toString = string.Join(&quot;, &quot;, publicMembers);

        // C# 11のRaw String Literalを使ってText Template的な置換(便利)
        // ファイルとして書き出される時対策として &lt;auto-generated/&gt; を入れたり
        // nullable enableしつつ、nullable系のwarningがウザいのでdisableして回ったりなどをテンプレコードとして入れておいたりする
        var code = $$&quot;&quot;&quot;
// &lt;auto-generated/&gt;
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

{{ns}}

partial class {{typeSymbol.Name}}
{
    public override string ToString()
    {
        return $&quot;{{toString}}&quot;;
    }
}
&quot;&quot;&quot;;

        // AddSourceで出力
        context.AddSource($&quot;{fullType}.SampleGenerator.g.cs&quot;, code);
    }
}

// DiagnosticDescriptorは大量に作るので一覧性のためにもまとめておいたほうが良い
public static class DiagnosticDescriptors
{
    const string Category = &quot;SampleGenerator&quot;;

    public static readonly DiagnosticDescriptor ExistsOverrideToString = new(
        id: &quot;SAMPLE001&quot;,
        title: &quot;ToString override&quot;,
        messageFormat: &quot;The GenerateToString class '{0}' has ToString override but it is not allowed.&quot;,
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}
</code></pre>
<p>作り方のポイントとしては、Source Generator(Analyzer)で使うものにはSyntaxNodeとISymbolの二系統があって、SyntaxNodeは文字列としてのソースコードの構造を指していて、ISymbolはコンパイルされた状態での型の中間状態を指します。情報を取ったりするにはISymbolのほうが圧倒的にやりやすいので、基本的にはSymbolを辿って処理していきます。SyntaxNodeは、エラーの波線表示の位置を示したりする時のみに使うという感じですね。</p>
<p>では、これをビルドして、Visual Studioを、再起動します……！というのも、ConsoleApp1側ではSource Generatorを掴みっぱなしになってしまうので、プロジェクト参照でのSource Generatorの更新ができないからです。今回AttributeをGenerator側で追加しているので、再起動してそれの生成を含めてあげる必要があります。今後もConsoleApp1側での動作確認が必要な際は、定期的に再起動する羽目になります。ただしデバッグ起動では更新されたコードで動くので、大きな変動がなければそのまま作業を進められます。といった、IDEを再起動しなきゃいけないシチュエーションなのかしなくてもいいのか、の切り分けが求められます……。</p>
<p>ConsoleApp1側で以下のようなテスト型を用意して</p>
<pre><code class="language-csharp">using SourceGeneratorSample;

var mc = new MyClass() { Hoge = 10, Bar = &quot;tako&quot; };
Console.WriteLine(mc);

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public string? Bar { get; set; }
}
</code></pre>
<p>Source Generator側でデバッグ実行です。いったんの出力の確認でお薦めなのは、AddSourceの直前あたりにブレークポイント貼って見ることですかね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208027141-ae09c996-a7a4-4780-bce0-8a9e22727a5e.png" alt="image" /></p>
<p>そうして何度かデバッグ実行を繰り返して、理想となるコードが吐けるように調整していって、そして、最終的にそれで大丈夫かどうかはコンパイラ通さないとわからんので、Visual Studioを再起動してConsoleApp1側でコンパイル走らせて、みたいなことになりますね。この段階で問題が出ると、Visual Studio再起動祭りになるのでダルい！</p>
<p>問題なく吐けていれば、ソリューションエクスプローラーで生成コードを確認することができます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208027544-81eb7279-aef7-48ff-8241-fa6fa2b4efa3.png" alt="image" /></p>
<p>以上、基本的な流れでした！C# 11のRaw String Literalsのお陰で別途テンプレートエンジンを用いなくても、テンプレート的な処理をC#のコード中に埋め込めるようになったのが、かなり楽になりました。（ただしif や for が埋め込めるわけではないので、複雑なものを書く場合はそれなりの工夫は必要）。</p>
<p>Source Generatorの良いところはAnalyzerも兼ねているところで、今回はToStringが既に定義されている場合はエラーにするという処理を入れているのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/208030486-1baf9e07-c22e-4c40-8c0c-7b968180ee58.png" alt="image" /></p>
<p>属性でどうこうする系ってどうしても今までは実行時エラーになりがちだったのですが、エディット時に間違って定義をばんばん教えてあげられるようになったのは親切度が相当上がっています。</p>
<h2>IncrementalGeneratorInitializationContext詳解</h2>
<p>Incremental Generatorの強みは複数のProviderを繋げてパイプラインを作れるところ、ではあるのですが、基本的なことは SyntaxProvider.ForAttributeWithMetadataName がほとんど全部やってくれるから、特に考えなくてもいいかな……。</p>
<p>ではあるんですが、細かい処理をしたい場合にはいくつか必要になりますので、Provider見ていきましょう。</p>
<ul>
<li>AdditionalTextsProvider</li>
</ul>
<p>AdditionalTextsProviderは、AdditionalFilesを読み取るのに使います。<a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">BannedApiAnalyzers</a>などでも活用されていますが、例えばコンフィグを渡したいケースなどに有用です。</p>
<p>例えば <code>sampleGenerator.config.json</code> を読み取りたい、といったケースを考えますと、ConsoleApp1側ではこういったcsprojとファイルを用意するとして</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
	&lt;AdditionalFiles Include=&quot;sampleGenerator.config.json&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>AdditionalTextsProviderを使ってこんな風に読み取っていきます。</p>
<pre><code class="language-csharp">var configuration = context.AdditionalTextsProvider.Select((text, token) =&gt;
    {
        if (text.Path.EndsWith(&quot;sampleGenerator.config.json&quot;)) return text.GetText(token);
        return null;
    })
    .Where(x =&gt; x != null)
    .Collect(); //雑Collect

// sampleにあったやつ
var types = context.SyntaxProvider.ForAttributeWithMetadataName(
      &quot;SourceGeneratorSample.GenerateToStringAttribute&quot;,
      static (node, token) =&gt; true,
      static (context, token) =&gt; context)
    .Collect(); //雑Collect

var source = configuration.Combine(types);  // くっつける

context.RegisterSourceOutput(source, static (context, source) =&gt;
{
    var configJson = source.Left.FirstOrDefault();
    var types = source.Right;
    foreach (var type in types)
    {
        // よしなに処理
    }
});
</code></pre>
<p>なるほどコードが増えた？</p>
<p>まず、Providerが触った直後のやつは <code>IncrementalValuesProvider&lt;T&gt;</code> になります。そしてCollectすると <code>IncrementalValueProvider&lt;ImmutableArray&lt;T&gt;&gt;</code> になります。違いはImmutableArray、ではなくて、 ValueProvider と ValuesProvider のほうです。ValueProviderの状態だと(IObservableみたいに)複数値が流れてくるのですが、ValuesProviderの状態だと、ImmutableArrayとして一塊になったものが一発流れてきます。</p>
<p>で、複数ProviderをCombineで繋いで、RegsiterSourceOutputに流し込むという流れになるわけですが、ValueとValuesが混在してるとCombineの型合わせがめちゃくちゃ大変です……！なんかよくわからんがCombineできない！の原因は型が合わないせいなのですね。というわけで雑にCollectしておくと合わせやすくなるので良いです。</p>
<p>というわけで、こんな感じで次のProvider行きましょう。</p>
<ul>
<li>AnalyzerConfigOptionsProvider</li>
</ul>
<p>GlobalOptionsと、AdditionalTextやSyntaxTreeに紐付けられたオプションを引っ張るGetOptionsがあります。例えばMemoryPackではcsprojのオプションから取り出すために使いました。</p>
<p>こういう記述をして</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_SerializationInfoOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_SerializationInfoOutputDirectory&gt;$(MSBuildProjectDirectory)\MemoryPackLogs&lt;/MemoryPackGenerator_SerializationInfoOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>こんな風に取り出すことができる( <code>build_property.</code> が接頭辞に必要)みたいな。</p>
<pre><code class="language-csharp">var outputDirProvider = context.AnalyzerConfigOptionsProvider
    .Select((configOptions, token) =&gt;
    {
        if (configOptions.GlobalOptions.TryGetValue(&quot;build_property.MemoryPackGenerator_SerializationInfoOutputDirectory&quot;, out var path))
        {
            return path;
        }

        return (string?)null;
    });
</code></pre>
<p>csproj側があんま書きやすい感じじゃないので、AdditionalFilesでjsonを渡すのとどちらがいいのか、みたいなのは考えどころですね。こちらだとcsproj内のマクロが使える（出力パスとか）のはいいところかもしれません。</p>
<ul>
<li>CompilationProvider</li>
</ul>
<p>Compilationが拾える最重要Provider、のはずが <code>ForAttributeWithMetadataName</code> がくっつけてくれるので用無し。</p>
<ul>
<li>MetadataReferencesProvider</li>
</ul>
<p>読み込んでるDLLの情報が拾えます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208037687-47a65304-e8d9-42cb-bdd6-f88ea622bc03.png" alt="image" /></p>
<p>そんな使わないかも。</p>
<ul>
<li>ParseOptionsProvider</li>
</ul>
<p>csprojを解析した情報が取れます。例えば言語バージョンやプリプロセッサシンボルから、.NETのバージョンを取り出したりできます。</p>
<pre><code class="language-csharp">var parseOptions = context.ParseOptionsProvider.Select((parseOptions, token) =&gt;
{
    var csOptions = (CSharpParseOptions)parseOptions;
    var langVersion = csOptions.LanguageVersion;
    var net7 = csOptions.PreprocessorSymbolNames.Contains(&quot;NET7_0_OR_GREATER&quot;);
    return (langVersion, net7);
});
</code></pre>
<p>つまり、言語バージョンや.NETのバージョン別の出し分けに使える、ということですね。細かくやると面倒くさいのであんまギチギチにやらないほうがいいとは思いますが、どうしてもそういう処理が必要なシチュエーションでは使えます。というか実際MemoryPackではこれで出し分けしています。scoped ref(C# 11)やfile scoped namespace(C# 10)、static abstract method(.NET 7)という切り分けですねー。</p>
<ul>
<li>SyntaxProvider</li>
</ul>
<p><code>ForAttributeWithMetadataName</code> を叩くためのやつ。</p>
<ul>
<li>RegisterPostInitializationOutput</li>
</ul>
<p>ここからはRegisterシリーズですが、PostInitializeationOutputは、Source Generatorのためのマーカーとしてしか使わない属性をinternal classとして解析走らせる前に出力しておきたい、というやつですね。<a href="https://github.com/Cysharp/UnitGenerator/">UnitGenerator</a>では <code>UnitOfAttribute</code> をそういった形で吐き出しています（なので結果としてUnitGeneratorを使ったプロジェクトはUnitGeneratorへの依存DLLはなし、ということになる）。一方でMemoryPackで使ってる属性 <code>MemoryPackableAttribute</code> は、<code>MemoryPack.Core.dll</code>に含めているので、RegisterPostInitializationOutputは使っていません。どうせReader/Writerとかの他の依存が必要になるので、属性だけ依存なしにしてもしょーがないですからね。</p>
<ul>
<li>RegisterSourceOutput</li>
</ul>
<p>Providerを繋げて、実際にSource Generateさせるやつ。大事というか必須。</p>
<ul>
<li>RegisterImplementationSourceOutput</li>
</ul>
<p>ドキュメントが一切ない上に、なんか想定通りの動きをしていないような私の想定が悪いのか、まぁよくわからないけどよくわからないのでよくわからないです。ドキュメントも無なので、とりあえず無視しておきましょう。</p>
<h2>ユニットテスト</h2>
<p>厳密にやるとキリがないので、そこそこゆるふわ感覚でやるようにしてます。もちろんTDDなんてしません。基本的な考え方としては、ユニットテストプロジェクトがAnalyzerとして開発中のSource Generatorプロジェクトをプロジェクト参照して、ソース生成されるようにしておいて、ユニットテストでは、その生成されたコードが期待通り動いているかのテストをする、みたいな雰囲気で良いんじゃないかと思います。生成ソースコードの中身をチェックして一致するか、みたいなのはちょっと手間が無駄にかかりすぎるので……。</p>
<p>テストプロジェクトはxUnitと、補助ライブラリとして<a href="https://fluentassertions.com/">FluentAssertion</a>を好んで使っています。また、GlobalUsingにテスト系の名前空間を突っ込んでおくと気持ち楽です。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;6.7.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.4.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.3.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.5&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\SourceGeneratorSample\SourceGeneratorSample.csproj&quot;&gt;
			&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
            &lt;!-- ReferenceOutputAssemblyをtrueにする! --&gt;
			&lt;ReferenceOutputAssembly&gt;true&lt;/ReferenceOutputAssembly&gt;
		&lt;/ProjectReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Using Include=&quot;Xunit&quot; /&gt;
		&lt;Using Include=&quot;Xunit.Abstractions&quot; /&gt;
		&lt;Using Include=&quot;FluentAssertions&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>後述しますが C# 11の内部コンパイルを行うために参照する Microsoft.CodeAnalysis.CSharp は 4.4.0 です。</p>
<pre><code class="language-csharp">namespace SourceGeneratorSample.Tests;

public class ToStringTest
{
    [Fact]
    public void Basic()
    {
        var mc = new MyClass() { Hoge = 33, Huga = 99 };
        mc.ToString().Should().Be(&quot;Hoge:33, Huga:99&quot;);
    }
}

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public int Huga { get; set; }
}
</code></pre>
<p>とりあえずこれをテストすればOK、と。なんか生成結果が更新されてない気がして無限にTestがこけるんだが？という時は、例によってVisual Studio再起動です。</p>
<p>Source Generatorのいいところとして、生成コードへのステップ実行も可能ということで、なんかよーわからん挙動だわーという時はデバッガでどんどん突っ込んでいくといいでしょう。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208041286-54162ad8-fe1a-41d6-a1f2-37e0dd19c533.png" alt="image" /></p>
<p>正常に動くケースはこれで概ねいいんですが、Analyzerとしてコンパイルエラーを出すようなケースをテストしたい場合は、もう一捻り必要です。対応としては <code>CSharpGeneratorDriver</code> というのが標準で用意されていて、それにソースコード渡せばいい、という話なのですが、少し手間なのは、元になるCSharpCompilationを作らなければいけない、というところで。この辺もよしなに見てくれる便利ジェネレーターユニットテストヘルパーライブラリみたいなのもありますが、原理原則を知るためにも、ここは手で書いてみましょう。</p>
<p>というわけで、こういうヘルパーを用意してみます。</p>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

namespace MemoryPack.Tests.Utils;

public static class CSharpGeneratorRunner
{
    static Compilation baseCompilation = default!;

    [ModuleInitializer]
    public static void InitializeCompilation()
    {
        // running .NET Core system assemblies dir path
        var baseAssemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location)!;
        var systemAssemblies = Directory.GetFiles(baseAssemblyPath)
            .Where(x =&gt;
            {
                var fileName = Path.GetFileName(x);
                if (fileName.EndsWith(&quot;Native.dll&quot;)) return false;
                return fileName.StartsWith(&quot;System&quot;) || (fileName is &quot;mscorlib.dll&quot; or &quot;netstandard.dll&quot;);
            });

        var references = systemAssemblies
            // .Append(typeof(Foo).Assembly.Location) // 依存DLLがある場合はそれも追加しておく
            .Select(x =&gt; MetadataReference.CreateFromFile(x))
            .ToArray();

        var compilation = CSharpCompilation.Create(&quot;generatortest&quot;,
            references: references,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        baseCompilation = compilation;
    }

    public static Diagnostic[] RunGenerator(string source, string[]? preprocessorSymbols = null, AnalyzerConfigOptionsProvider? options = null)
    {
        // NET 7 + C# 11
        if (preprocessorSymbols == null)
        {
            preprocessorSymbols = new[] { &quot;NET7_0_OR_GREATER&quot; };
        }
        var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp11, preprocessorSymbols: preprocessorSymbols);
        var driver = CSharpGeneratorDriver.Create(new SourceGeneratorSample.SampleGenerator()).WithUpdatedParseOptions(parseOptions);
        if (options != null)
        {
            driver = (Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver)driver.WithUpdatedAnalyzerConfigOptions(options);
        }

        var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        // combine diagnostics as result.
        var compilationDiagnostics = newCompilation.GetDiagnostics();
        return diagnostics.Concat(compilationDiagnostics).ToArray();
    }
}
</code></pre>
<p>CSharpGeneratorDriver.Create して AddSyntaxTrees して RunGeneratorsAndUpdateCompilation して diagnostics を取り出す。というだけなのですが、Compilationを作るところに癖があります、というか Compilation に渡すDLLをかき集めるのが微妙に面倒くさいです。net7の依存関係のDLLを全部持ってくる、とかが一発でできないんですね。素直に typeof().Assembly.Location だけだと全然持ってこれないため、ディレクトリから漁ってくるという処理をいれています。</p>
<p>これを使ってテスト書くと、こんな感じでしょうか。</p>
<pre><code class="language-csharp">    [Fact]
    public void ERROR_SAMPLE001()
    {
        // C#11のRaw String Literals本当に便利
        var result = CSharpGeneratorRunner.RunGenerator(&quot;&quot;&quot;
using SourceGeneratorSample;

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public int Huga { get; set; }

    public override string ToString()
    {
        return &quot;hogemoge&quot;;
    }
}
&quot;&quot;&quot;);

        result.Length.Should().Be(1);
        result[0].Id.Should().Be(&quot;SAMPLE001&quot;);
    }
</code></pre>
<p>厳密にやるなら、エラーの波線をどこに敷いているかのチェックをすべし、みたいな話もあるのですが、私的にはまぁ面倒くさいのでちゃんと狙ったエラーが出せてるかどうかをDiangnositcsのIdを拾うぐらいでいいかな、みたいな感じでやってます。</p>
<h2>NuGetパッケージング</h2>
<p>というわけで <code>dotnet pack</code> するわけですが、 追加でコンフィグ仕込む必要があります。</p>
<pre><code class="language-csharp">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;LangVersion&gt;11&lt;/LangVersion&gt;

		&lt;!-- NuGetPackのための追加をもりもり --&gt;
		&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
		&lt;AnalyzerLanguage&gt;cs&lt;/AnalyzerLanguage&gt;
		&lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
		&lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
		&lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;
		&lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.1&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;!-- 出力先を analyzers/dotnet/cs にする --&gt;
	&lt;ItemGroup&gt;
		&lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>外部依存DLLがいたりすると(例えばJSON .NET使いたいとか！)もう少し面倒くさくなるので、外部依存DLLは使わないようにしましょう！というのが第一原則になります。どうしても使いたい場合は頑張ってください。</p>
<h2>Unity対応</h2>
<p>まずIncremental Source Generator使えないし ForAttributeWithMetadataName も使えないしちくしょーって感じですが、とはいえそこまで差分が多いわけでもないのでやってきましょう。</p>
<p>まず、簡易的な ForAttributeWithMetadataName っぽいものを用意します。MemoryPackでは以下のコードを使ってます。</p>
<pre><code class="language-csharp">class SyntaxContextReceiver : ISyntaxContextReceiver
{
    internal static ISyntaxContextReceiver Create()
    {
        return new SyntaxContextReceiver();
    }

    public HashSet&lt;TypeDeclarationSyntax&gt; ClassDeclarations { get; } = new();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        var node = context.Node;
        if (node is ClassDeclarationSyntax
                    or StructDeclarationSyntax
                    or RecordDeclarationSyntax
                    or InterfaceDeclarationSyntax)
        {
            var typeSyntax = (TypeDeclarationSyntax)node;
            if (typeSyntax.AttributeLists.Count &gt; 0)
            {
                var attr = typeSyntax.AttributeLists.SelectMany(x =&gt; x.Attributes)
                    .FirstOrDefault(x =&gt;
                    {
                        var packable = x.Name.ToString() is &quot;MemoryPackable&quot; or &quot;MemoryPackableAttribute&quot; or &quot;MemoryPack.MemoryPackable&quot; or &quot;MemoryPack.MemoryPackableAttribute&quot;;
                        if (packable) return true;
                        return false;
                    });
                if (attr != null)
                {
                    ClassDeclarations.Add(typeSyntax);
                }
            }
        }
    }
}
</code></pre>
<p>ざっくりしてる感じですが、機能はするのでよしとしておきましょう。次にSourceGenerator と IncrementalGenerator を共通化するContextを用意しておきます。</p>
<pre><code class="language-csharp">// share context for SourceGenerator and IncrementalGenerator
public interface IGeneratorContext
{
    CancellationToken CancellationToken { get; }
    void ReportDiagnostic(Diagnostic diagnostic);
    void AddSource(string hintName, string source);
}
</code></pre>
<p>そして、最初のサンプルコードでいうところのEmit部分を↑のIGeneratorContextを使うようにしてファイル分離、そしてCompile Includeで.csを参照するようにします。MemoryPackでは以下のようにしています。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Compile Include=&quot;../MemoryPack.Generator/**/*.cs&quot; Exclude=&quot;**/obj/**;**/MemoryPackGenerator.cs;**/*TypeScript*.cs&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>大事なのはプロジェクト分離しないこと、ですね！NuGetパッケージングのところでも書きましたがAnalyzer(Source Generator)でごちゃごちゃした依存作ると面倒臭さが跳ね上がるので、シングルアセンブリに収まるように作るべし、ということです。</p>
<p>あとは<a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unityのマニュアル</a>通りにビルド済みdllを配置してRoslynAnalyzerとしてLabel設定したmetaを置いておけば、UPMのgit参照とかでも、特に何もせずに自動で認識されます。dllの配置場所はUnityの公式のジェネレーター(例えば com.unity.properties とか)がRuntime配下にいるので、Editorではなく、Runtime側に配置することとしています。</p>
<p>なお、Unity用限定のSource Generatorを作る場合でも、通常の .NET のライブラリとして扱い、普通に .NET ライブラリとしての開発環境やユニットテストプロジェクトを作ったほうが良いでしょう。普通に作るにもかなり環境をしっかり作らないと大変なので、Unity限定だから！みたいな気持ちで挑むとしんどみが爆発します。</p>
<h2>まとめ</h2>
<p>C#に最初にこの手の機構が登場したのは2014年、 <a href="https://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a> といった記事も書いていたのですが、まぁ正直めっっっちゃくちゃ作りづらかったんですね。</p>
<p>で、現代、この2022年のSource Generator開発はめっっっっちゃくちゃ作りやすくなってます。もちろん、Roslyn自体の知識が必要で、そしてRoslynはドキュメントが無なので、どちらかというとIntelliSenseから勘をどう働かせるかという勝負になっていて、それはそれで大変ではあるのですが、しかし本当に作りやすくなったな、と思います。もちろんそしてIL.Emitよりも遥かに作りやすいし、パフォーマンスも良い。もうEmitの時代は終わりです。もはや黒魔術を誇る時代でもないのです！動的コード生成の民主化！</p>
<p>というわけで、どしどしコード生成していきましょう……！私も今温めてるアイディアが3つぐらいあるので、どんどんリリースしていきたいと思ってます。</p>
</div>
<h1><a href="https://neue.cc/2022/12/08_MemoryPackSessionInDotNetConfRecapTokyo.html">C# 11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a></h1>
<ul class="date"><li>2022-12-08</li></ul>
<div class="entry_body"><p>と題して、.NET Conf 2022 Recap Event Tokyo というイベントで話してきました。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/7b71dc84ae4a4241aa241340fa890f65" title="C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 840px; height: 471px;" data-ratio="1.78343949044586"></iframe>
<p>今回は久々の（数年ぶりの！）オフライン登壇イベントということで、なんだか新鮮な気分で、そして実際、オンライン登壇よりも目の前にオーディエンスがいたほうがいいなぁという思いを新たに。事前レコーディングやオンライン登壇だと、どうしてもライブ感のない、冷めた感じになっちゃうな、と。セッション単体の完成度で言ったら何度も取り直して完璧に仕上げた事前録画のほうがいい、かもしれませんが、でもそういうもんじゃあないかなあ、と。スタジオアルバムとライブアルバムみたいなもんですね。そしてスタジオアルバムに相当するのは念入りに書かれたブログ記事とかだったりするので、事前録画のセッションって、なんか中途半端に感じてしまったりはしますね。スタジオライブみたいな。あれってなんかいまいちじゃないですか、そういうことで。</p>
<p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>は先程 v1.9.0 をリリースしました！日刊MemoryPackか？というぐらいに更新ラッシュをしていたのですが、バグというかは機能追加をめちゃくちゃやってました。性能面で究極のシリアライザーを目指した、というのはセッションスライドのほうにも書かせてもらっていますが、機能面でも究極のシリアライザーを目指しています、ということで、めちゃくちゃやれる幅が広がってます。GitHub Star数も既に1200と、めちゃくちゃ凄い勢いで伸びているので（過去最高の勢いです）、出す前は独自フォーマットのシリアライザーだと、どのぐらいまで使ってもらえるものだろうか？と不安に思ったところもあったのですが、割と自信もって押していける感じです。実際、性能も機能も凄い。</p>
<h2>Formatterという名前付けについて</h2>
<p>特に誰にも聞かれていないのですが説明しておきたいのが <code>MemoryPackFormatter</code> という名前を。Formatterって正直馴染みがないし(<code>BinaryFormatter</code>かよ？)、 <code>IMemoryPackSerializer</code> にしようかな、と当初は考えていたのですが最終的には(MessagePack for C#と同じの)Formatterに落ち着きました。理由は、エントリーポイントである <code>MemoryPackSerializer</code> と紛らわしいんですよね。 <code>MemoryPackFormatter</code>は自作でもしない限りは表に出て来ないし、上級向けのオプションなので、すっきりと名前で区別がついたほうが良いかな、という感じでつけてます。System.Text.Jsonの場合は <code>JsonSerializer</code> と <code>JsonConverter</code>という分類で、同じような感じです。</p>
<p>候補になる名前としては<code>Serializer</code>か<code>Formatter</code>か<code>Converter</code>か<code>Encoder</code>か<code>Codec</code>という感じでしょうか。単純で当たり前のチョイスのようでいて、ユーザーがなるべく悩まず直感的に理解できるように、しっかり考えて悩みながらつけてるんですよということで。それで出来上がった名前が、単純で当たり前のように思ってもらえれば正解なわけです。</p>
<h2>イベント2</h2>
<p>久々のオンフライン登壇！だったのですが、こういうのは始まると続くもので、今月は12/14に <a href="https://bitflyer.connpass.com/event/266685/">bitFlyer.C#/Azure 01</a>というイベントに、Azureじゃないほうの枠として登壇する予定です。「AlterNatsにみる .NET 7世代のハイパフォーマンスSocketプログラミング技法」という内容ですが<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>というよりかは、最新のC#でハイパフォーマンスなSocketプログラミングをどうすればいいか、ということに重点を置いた内容になってますので、C#の最適化に興味ある方は是非是非来てください。まだ席空いてますので……！</p>
</div>
<h1><a href="https://neue.cc/2022/11/04_memorypack.html">MemoryPackにみる .NET 7/C# 11世代のシリアライザー最適化技法</a></h1>
<ul class="date"><li>2022-11-04</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>という、C#に特化することで従来のシリアライザーとは比較にならないほどのパフォーマンスを発揮する新しいシリアライザーを新しく開発しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/192748136-262ac2e7-4646-46e1-afb8-528a51a4a987.png" alt="" /></p>
<p>高速なバイナリシリアライザーである <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a> と比較しても、通常のオブジェクトでも数倍、データが最適な場合は50~100倍ほどのパフォーマンスにもなります。System.Text.Jsonとでは全く比較になりません。当初は .NET 7 限定としてリリースしましたが、現在は .NET Standard 2.1(.NET 5, 6)やUnity、そしてTypeScriptにも対応しています。</p>
<p>シリアライザーのパフォーマンスは「データフォーマットの仕様」と「各言語における実装」の両輪で成り立っています。例えば、一般的にはバイナリフォーマットのほうがテキストフォーマット（JSONとか）よりも有利ですが、バイナリシリアライザーより速いJSONシリアライザといったものは有り得ます(Utf8Jsonでそれを実証しました)。では最速のシリアライザーとは何なのか？というと、仕様と実装を突き詰めれば、真の最速のシリアライザーが誕生します。</p>
<p>私は、今もですが、長年<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>の開発とメンテナンスをしてきました。MessagePack for C#は .NET の世界で非常に成功したシリアライザーで、4000以上のGitHub Starと、Visual Studio内部や、SignalR, Blazor Serverのバイナリプロトコルなど、Microsoftの標準プロダクトにも採用されています。また、この5年間で1000近くのIssueをさばいてきました。そのため、シリアライザーの実装の詳細からユーザーのリアルなユースケース、要望、問題などを把握しています。Roslynを使用したコードジェネレーターによるAOT対応にも当初から取り組み、特にAOT環境(IL2CPP)であるUnityで実証してきました。更にMessagePack for C#以外にも ZeroFormatter(独自フォーマット)、Utf8Json(JSON) といった、これも多くのGitHub Starを獲得したシリアライザーを作成してきているため、異なるフォーマットの性能特性についても深く理解しています。シリアライザーを活用するシチュエーションにおいても、RPCフレームワーク<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>の作成、インメモリデータベース<a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a>、そして複数のゲームタイトルにおけるクライアント(Unity)/サーバー、両方の実装に関わってきました。</p>
<p>ようするところ私は .NET のシリアライザー実装について最も詳しい人間の一人であり、MemoryPackはその知見がフルに詰め込まれた、なおかつ、 .NET 7 / C# 11という最新のランタイム/言語機能を使い倒したライブラリになっています。そりゃ速くて当然で異論はないですよね？</p>
<p>というだけではアレなので、実際なんで速いのかというのを理屈で説明していきます……！きっと納得してもらえるはず！ C#の最適化のTipsとしてもどうぞ。</p>
<h2>Incremental Source Generator</h2>
<p>MemoryPackでは .NET 5/C# 9.0 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview">Source Generator</a>、それも .NET 6 で強化された <a href="https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md">Incremental Source Generator</a>を全面的に採用しています。使い方的には、対象型をpartialに変更する程度で、MessagePack for C#とあまり変わりません（というか極力同じAPIになるように揃えました）。</p>
<pre><code class="language-csharp">using MemoryPack;

[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}

// usage
var v = new Person { Age = 40, Name = &quot;John&quot; };

var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>Source Generatorの最大の利点はAOTフレンドリーであることで、従来行っていたIL.Emitによる動的コード生成をせずとも、リフレクションを使用しない、各型に最適化されたシリアライザーコードを自動生成しています。それによりUnityのIL2CPPなどでも安全に動作させることが可能です。</p>
<p>MessagePack for C#では外部ツール(mpc.exe)経由でコード生成することでAOTセーフなシリアライズ処理を実現していましたが、言語機能と統合されたことによって、煩わしい生成プロセス不要で、自然な書き心地のまま高速なシリアライズ処理を可能にしました。</p>
<p>なお、Unity版の場合は言語/コンパイラバージョンの都合上、Incremental Source Generatorではなくて、古いSource Generatorを採用しています。</p>
<h2>C#のためのバイナリ仕様</h2>
<p>キャッチコピーは「Zero encoding」ということで、エンコードしないから速いんだ！という理論を打ち出しています。奇妙に思えて、実のところ別に特殊な話をしているわけではなくて、例えばRustのメジャーなバイナリシリアライザーである<a href="https://github.com/bincode-org/bincode">bincode</a>なども似通った仕様を持っています。<a href="https://github.com/google/flatbuffers">FlatBuffers</a>も、without parsingな実装のために、メモリデータに近い内容を読み書きします。ただしMemoryPackはFlatBuffersなどと違い、特別な型を必要としない汎用的なシリアライザーであり、POCOに対してのシリアライズ/デシリアライズを行うものです。また、スキーマのメンバー追加へのバージョニング耐性やポリモーフィズムサポート(Union)も持ちます。さすがにメモリダンプしてるだけ、では全く実用にならないわけで、一般的なシリアライザーとして使えるための仕様として整えてあります。</p>
<h2>varint encoding vs fixed</h2>
<p>Int32は4バイトですが、例えばJSONでは数値を文字列として、1バイト~11バイト(例えば <code>1</code> であったり <code>-2147483648</code> であったり)の可変長なエンコーディングが施されます。バイナリフォーマットでも、サイズの節約のために1~5バイトの可変長にエンコードされる仕様を持つものが多くあります。例えば<a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Protocol Buffersの数値型</a>は、値を7ビットに、後続があるかないかのフラグを1ビットに格納する可変長整数エンコーディングになっています(varint)。これにより数値が小さければ小さいほど、バイト数が少なくなります。逆にワーストケースでは本来の4バイトより大きい5バイトに膨れることになります。とはいえ現実的には小さい数値のほうが圧倒的に頻出するはずなので、とても理にかなった方式です。<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack</a>や<a href="https://cbor.io/">CBOR</a>も同じように、小さい数値では最小で1バイト、大きい場合は最大5バイトになる可変長エンコーディングで処理されます。</p>
<p>つまり、固定長の場合よりも余計な処理が走ることになります。具体的なコードで比較してみましょう。可変長はprotobufで使われるvarint + <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">ZigZagエンコーディング</a>(負数と正数をまとめる)です。</p>
<pre><code class="language-csharp">// 固定長の場合
static void WriteFixedInt32(Span&lt;byte&gt; buffer, int value)
{
    ref byte p = ref MemoryMarshal.GetReference(buffer);
    Unsafe.WriteUnaligned(ref p, value);
}

// 可変長の場合
static void WriteVarInt32(Span&lt;byte&gt; buffer, int value) =&gt; WriteVarInt64(buffer, (long)value);

static void WriteVarInt64(Span&lt;byte&gt; buffer, long value)
{
    ref byte p = ref MemoryMarshal.GetReference(buffer);

    ulong n = (ulong)((value &lt;&lt; 1) ^ (value &gt;&gt; 63));
    while ((n &amp; ~0x7FUL) != 0)
    {
        Unsafe.WriteUnaligned(ref p, (byte)((n &amp; 0x7f) | 0x80));
        p = ref Unsafe.Add(ref p, 1);
        n &gt;&gt;= 7;
    }
    Unsafe.WriteUnaligned(ref p, (byte)n);
}
</code></pre>
<p>固定長は、つまりC#のメモリをそのまま書き出している(Zero encoding)わけで、さすがにどう見ても固定長のほうが速いでしょう。</p>
<p>このことは配列に適用した場合、より顕著になります。</p>
<pre><code class="language-csharp">// https://sharplab.io/
Inspect.Heap(new int[]{ 1, 2, 3, 4, 5 });
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/199924027-492a163c-9bd9-41e7-8489-4f5aa61cac52.png" alt="image" /></p>
<p>C#のstructの配列は、データが直列に並びます。この時、<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/unmanaged-types">structが参照型を持っていない場合(unmanaged type)</a>は、データが完全にメモリ上に並んでいることになります。MessagePackとMemoryPackでコードでシリアライズ処理を比較してみましょう。</p>
<pre><code class="language-csharp">// 固定長の場合(実際には長さも書き込みます)
void Serialize(int[] value)
{
    // サイズが算出可能なので事前に一発で確保
    var size = (sizeof(int) * value.Length) + 4;
    EnsureCapacity(size);

    // 一気にメモリコピー
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer);
}

// 可変長の場合
void Serialize(int[] value)
{
    foreach (var item in value)
    {
        // サイズが不明なので都度バッファサイズのチェック
        EnsureCapacity(); // if (buffer.Length &lt; writeLength) Resize();
        // 1要素毎に可変長エンコード
        WriteVarInt32(item);
    }
}
</code></pre>
<p>固定長の場合は、多くのメソッド呼び出しを省いて、メモリコピー一発だけで済ませることが可能です。</p>
<p>C#の配列はintのようなプリミティブ型だけではなく、これは複数のプリミティブを持ったstructでも同様の話で、例えば(float x, float y, float z)を持つVector3の配列の場合は、以下のようなメモリレイアウトになります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/199926307-bad558f9-b912-4b96-90fc-5c2d1a2837ea.png" alt="image" /></p>
<p>float(4バイト)はMessagePackにおいて、固定長で5バイトです。追加の1バイトは、その値が何の型(IntなのかFloatなのかStringなのか...)を示す識別子が先頭に入ります。具体的には[0xca, x, x, x, x]といったように。いわばタグ付与エンコーディングを行っているわけです。MemoryPackのフォーマットは識別子を持たないため、4バイトをそのまま書き込みます。</p>
<p>ベンチマークで50倍の差だった、Vector3[10000]で考えてみましょう。</p>
<pre><code class="language-csharp">// 以下の型がフィールドにあるとする
// byte[] buffer
// int offset

void SerializeMemoryPack(Vector3[] value)
{
    // どれだけ複雑だろうとコピー一発で済ませられる
    var size = Unsafe.SizeOf&lt;Vector3&gt;() * value.Length;   
    if ((buffer.Length - offset) &lt; size)
    {
        Array.Resize(ref buffer, buffer.Length * 2);
    }
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer.AsSpan(0, offset))
}

void SerializeMessagePack(Vector3[] value)
{
    // 配列の長さ x フィールドの数だけ繰り返す
    foreach (var item in value)
    {
        // X
        {
            // EnsureCapacity
            if ((buffer.Length - offset) &lt; 5)
            {
                // 実際にはResizeではなくてbufferWriter.Advance()です
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.X);
            offset += 5;
        }
        // Y
        {
            if ((buffer.Length - offset) &lt; 5)
            {
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.Y);
            offset += 5;
        }
        // Z
        {
            if ((buffer.Length - offset) &lt; 5)
            {
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.Z);
            offset += 5;
        }
    }
}
</code></pre>
<p>MessagePackだと30000回のメソッド呼び出しが必要なところが(そしてそのメソッド内では、書き込みメモリが足りているかのチェックと、書き終わった後のオフセットの追加が(愚直に処理する場合)都度必要になる)、一回のメモリコピーだけになります。こうなると、処理時間が文字通り桁違いに変わってきて、冒頭のグラフの50倍~100倍の高速化の理由はここにあります。</p>
<p>もちろん、デシリアライズ処理もコピー一発になります。</p>
<pre><code class="language-csharp">// MemoryPackのデシリアライズ、コピーするだけ。
Vector3[] DeserializeMemoryPack(ReadOnlySpan&lt;byte&gt; buffer, int size)
{
    var dest = new Vector3[size];
    MemoryMarshal.Cast&lt;byte, Vector3&gt;(buffer).CopyTo(dest);
    return dest;
}

// ループで都度floatの読み取りが必要
Vector3[] DeserializeMessagePack(ReadOnlySpan&lt;byte&gt; buffer, int size)
{
    var dest = new Vector3[size];
    for (int i = 0; i &lt; size; i++)
    {
        var x = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        var y = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        var z = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        dest[i] = new Vector3(x, y, z);
    }
    return dest;
}
</code></pre>
<p>この辺は、MessagePackのフォーマットそのものの限界のため、仕様に従う限りは、圧倒的な速度差はどうやっても覆せません。ただしMessagePackの場合はext format familyという仕様があり、独自仕様としてこれらの配列だけ特別扱いして処理する（MessagePackとしての互換性はなくなりますが）ことも許されています。実際、MessagePack for C#ではUnity向けに <code>UnsafeBlitResolver</code> という、上記のような処理をする特別な拡張オプションを用意していました。</p>
<p>しかし恐らく、ほとんどの人が使っていないでしょう。別に普通にシリアライズできるものを、言語間運用製を壊す、C#だけの独自拡張オプションをわざわざ使おうとは、中々思わない、というのは分かります。そこがまた歯痒かったんですよね、明らかに遅いのに、明らかに速くできるのに、だからせっかく用意したのに、デフォルトではない限り使われない、しかしデフォルトは絶対に仕様に従うべきであり……。</p>
<h2>string処理の最適化</h2>
<p>MemoryPackではStringに関して、2つの仕様を持っています。UTF8か、UTF16か、です。C#のstringはUTF16のため、UTF16のままシリアライズすると、UTF8へのエンコード/デコードコストを省くことができます。</p>
<pre><code class="language-csharp">void EncodeUtf16(string value)
{
    var size = value.Length * 2;
    EnsureCapacity(size);

    // char[] -&gt; byte[] -&gt; Copy
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer);
}

string DecodeUtf16(ReadOnlySpan&lt;byte&gt; buffer, int length)
{
    ReadOnlySpan&lt;char&gt; src = MemoryMarshal.Cast&lt;byte, char&gt;(buffer).Slice(0, length);
    return new string(src);
}
</code></pre>
<p>ただし、MemoryPackのデフォルトはUTF8です。これは単純にペイロードのサイズの問題で、UTF16だとASCII文字が2倍のサイズになってしまうため、UTF8にしました（なお、日本語の場合はUTF16のほうがむしろ縮まる可能性が高いです）。</p>
<p>UTF8の場合でも、他のシリアライザにはない最適化をしています。</p>
<pre><code class="language-csharp">void WriteUtf8MemoryPack(string value)
{
    var source = value.AsSpan();
    var maxByteCount = (source.Length + 1) * 3;
    EnsureCapacity(maxByteCount);
    Utf8.FromUtf16(source, dest, out var _, out var bytesWritten, replaceInvalidSequences: false);
}

void WriteUtf8StandardSerializer(string value)
{
    var maxByteCount = Encoding.UTF8.GetByteCount(value);
    EnsureCapacity(maxByteCount);
    Encoding.UTF8.GetBytes(value, dest);
}
</code></pre>
<p><code>var bytes = Encoding.UTF8.GetBytes(value);</code> は論外です、stringの書き込みで <code>byte[]</code> のアロケーションは許されません。しかし、多くのシリアライザはで使われている <code>Encoding.UTF8.GetByteCount</code> も避けるべきです、UTF8は可変長のエンコーディングであり、 GetByteCount は正確なエンコード後のサイズを算出するために、文字列を完全に走査します。つまり GetByteCount -&gt; GetBytes は文字列を二度も走査することになります。</p>
<p>通常シリアライザーは余裕を持ったバッファの確保が許されています。そこでMemoryPackではUTF8エンコードした場合のワーストケースである文字列長の3倍の確保にすることで、二度の走査を避けています。</p>
<p>デコードの場合は、更に特殊な最適化を施しています。</p>
<pre><code class="language-csharp">string ReadUtf8MemoryPack(int utf16Length, int utf8Length)
{
    unsafe
    {
        fixed (byte* p = &amp;buffer)
        {
            return string.Create(utf16Length, ((IntPtr)p, utf8Length), static (dest, state) =&gt;
            {
                var src = MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;byte&gt;((byte*)state.Item1), state.Item2);
                Utf8.ToUtf16(src, dest, out var bytesRead, out var charsWritten, replaceInvalidSequences: false);
            });
        }
    }
}

string ReadStandardSerialzier(int utf8Length)
{
    return Encoding.UTF8.GetString(buffer.AsSpan(0, utf8Length));
}
</code></pre>
<p>通常、byte[]からstringを取り出すには Encoding.UTF8.GetString(buffer) を使います。MessagePack for C#でもそうです。しかし、改めて、UTF8は可変長のエンコーディングであり、そこからUTF16としての長さは分かりません。そのためUTF8.GetStringだと、stringに変換するためのUTF16としての長さ算出が必要なので、中では文字列を二度走査しています。擬似コードでいうと</p>
<pre><code class="language-csharp">var length = CalcUtf16Length(utf8data);
var str = String.Create(length);
Encoding.Utf8.DecodeToString(utf8data, str);
</code></pre>
<p>といったことになっています。一般的なシリアライザの文字列フォーマットはUTF8であり、当たり前ですがUTF16へのデコードなどといったことは考慮されていないため、C#の文字列としての効率的なデコードのためにUTF16の長さが欲しくても、データの中にはありません。</p>
<p>しかしMemoryPackの場合はC#を前提においた独自フォーマットのため、文字列はUTF16-LengthとUTF8-Lengthの両方(8バイト)をヘッダに記録しています。そのため、<code>String.Create&lt;TState&gt;(Int32, TState, SpanAction&lt;Char,TState&gt;)</code> と<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.unicode.utf8.toutf16">Utf8.ToUtf16</a>の組み合わせにより、最も効率的なC# Stringへのデコードを実現しました。</p>
<h2>ペイロードサイズについて</h2>
<p>MemoryPackは固定長エンコーディングのため可変長エンコーディングに比べてどうしてもサイズが膨らむ場合があります。特にlongを可変長エンコードすると最小1バイトになるので、固定長8バイトに比べると大きな差となり得ます。しかし、MemoryPackはフィールド名を持たない(JSONやMessagePackのMap)ことやTagがないことなどから、JSONよりも小さいのはもちろん、可変長エンコーディングを持つprotobufやMsgPackと比較しても大きな差となることは滅多にないと考えています。</p>
<p>データは別に整数だけじゃないので、真にサイズを小さくしたければ、圧縮(LZ4やZStandardなど)を考えるべきですし、圧縮してしまえばあえて可変長エンコーディングする意味はほぼなくなります。より特化して小さくしたい場合は、列指向圧縮にしたほうがより大きな成果を得られる(Apache Parquetなど)ので、現代的には可変長エンコーディングを採用するほうがデメリットは大きいのではないか？と私は考えています。冒頭でも少し紹介しましたが、実際Rustのシリアライザー<a href="https://github.com/bincode-org/bincode">bincode</a>のデフォルトは固定長だったりします。</p>
<p>MemoryPackの実装と統合された効率的な圧縮については、現在BrotliEncode/Decodeのための補助クラスを標準で用意しています。しかし、性能を考えるとLZ4やZStandardを使えたほうが良いため、将来的にはそれらの実装も提供する予定です。</p>
<h2>.NET 7 / C#11を活用したハイパフォーマンスシリアライザーのための実装</h2>
<p>MemoryPackは .NET Standard 2.1向けの実装と .NET 7向けの実装で、メソッドシグネチャが若干異なります。.NET 7向けには、最新の言語機能を活用した、より性能を追求したアグレッシブな実装になっています。</p>
<p>まずシリアライザのインターフェイスは以下のような static abstract membersが活用されています。</p>
<pre><code class="language-csharp">public interface IMemoryPackable&lt;T&gt;
{
    // note: serialize parameter should be `ref readonly` but current lang spec can not.
    // see proposal https://github.com/dotnet/csharplang/issues/6010
    static abstract void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref T? value)
        where TBufferWriter : IBufferWriter&lt;byte&gt;;
    static abstract void Deserialize(ref MemoryPackReader reader, scoped ref T? value);
}
</code></pre>
<p>MemoryPackはSource Generatorを採用し、対象型が <code>[MemortyPackable]public partial class Foo</code> であることを要求するため、最終的に対象型は</p>
<pre><code class="language-csharp">[MemortyPackable]
partial class Foo : IMemoryPackable
{
    static void IMemoryPackable&lt;Foo&gt;.Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref Foo? value) 
    {
    }
        
    static void IMemoryPackable&lt;Foo&gt;.Deserialize(ref MemoryPackReader reader, scoped ref Foo? value)
    {
    }
}
</code></pre>
<p>といったものを生成します。これにより、仮想メソッド経由呼び出しのコストを避けています。</p>
<pre><code class="language-csharp">public void WritePackable&lt;T&gt;(scoped in T? value)
    where T : IMemoryPackable&lt;T&gt;
{
    // IMemoryPackableが対象の場合、静的メソッドを直接呼び出しに行く
    T.Serialize(ref this, ref Unsafe.AsRef(value));
}

// 
public void WriteValue&lt;T&gt;(scoped in T? value)
{
    // IMemoryPackFormatter&lt;T&gt; を取得し、仮想メソッド経由で Serialize を呼び出す
    var formatter = MemoryPackFormatterProvider.GetFormatter&lt;T&gt;();
    formatter.Serialize(ref this, ref Unsafe.AsRef(value));
}
</code></pre>
<p>また、<code>MemoryPackWriter</code>/<code>MemoryPackReader</code> では <code>ref field</code> を活用しています。</p>
<pre><code class="language-csharp">public ref struct MemoryPackWriter&lt;TBufferWriter&gt;
    where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    ref TBufferWriter bufferWriter;
    ref byte bufferReference;
    int bufferLength;
</code></pre>
<p><code>ref byte bufferReference</code>, <code>int bufferLength</code> の組み合わせは、つまり<code>Span&lt;byte&gt;</code>のインライン化です。また、<code>TBufferWriter</code>を<code>ref TBufferWriter</code>として受け取ることにより、ミュータブルな<code>struct TBufferWriter : IBufferWrite&lt;byte&gt;</code>を安全に受け入れて呼び出すことができるようになりました。</p>
<h2>全ての型への最適化</h2>
<p>例えばコレクションは <code>IEnumerable&lt;T&gt;</code> としてシリアライズ/デシリアライズすることで実装の共通化が可能ですが、MemoryPackでは全ての型に対して個別の実装をするようにしています。単純なところでは <code>List&lt;T&gt;</code>を処理するのに</p>
<pre><code class="language-csharp">public void Serialize(ref MemoryPackWriter writer, IEnumerable&lt;T&gt; value)
{
    foreach(var item in source)
    {
        writer.WriteValue(item);
    }
}

public void Serialize(ref MemoryPackWriter writer, List&lt;T&gt; value)
{
    foreach(var item in source)
    {
        writer.WriteValue(item);
    }
}
</code></pre>
<p>この2つでは全然性能が違います。<code>IEnumerable&lt;T&gt;</code>へのforeachは <code>IEnumerator&lt;T&gt;</code> を取得しますが、<code>List&lt;T&gt;</code>へのforeachは <code>struct List&lt;T&gt;.Enumerator</code> という最適化された専用の構造体のEnumeratorを取得するからです。</p>
<p>しかし、もっと最適化する余地があります。</p>
<pre><code class="language-csharp">public sealed class ListFormatter&lt;T&gt; : MemoryPackFormatter&lt;List&lt;T?&gt;&gt;
{
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref List&lt;T?&gt;? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        writer.WriteSpan(CollectionsMarshal.AsSpan(value));
    }
}

// MemoryPackWriter.WriteSpan
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void WriteSpan&lt;T&gt;(scoped Span&lt;T?&gt; value)
{
    if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
    {
        DangerousWriteUnmanagedSpan(value);
        return;
    }

    var formatter = GetFormatter&lt;T&gt;();
    WriteCollectionHeader(value.Length);
    for (int i = 0; i &lt; value.Length; i++)
    {
        formatter.Serialize(ref this, ref value[i]);
    }
}

// MemoryPackWriter.DangerousWriteUnmanagedSpan
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void DangerousWriteUnmanagedSpan&lt;T&gt;(scoped Span&lt;T&gt; value)
{
    if (value.Length == 0)
    {
        WriteCollectionHeader(0);
        return;
    }

    var srcLength = Unsafe.SizeOf&lt;T&gt;() * value.Length;
    var allocSize = srcLength + 4;

    ref var dest = ref GetSpanReference(allocSize);
    ref var src = ref Unsafe.As&lt;T, byte&gt;(ref MemoryMarshal.GetReference(value));

    Unsafe.WriteUnaligned(ref dest, value.Length);
    Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)srcLength);

    Advance(allocSize);
}
</code></pre>
<p>まず、そもそも現代では <code>List&lt;T&gt;</code> の列挙は <code>CollectionsMarshal.AsSpan(value)</code> 経由で、<code>Span&lt;T&gt;</code>を取得して、それを列挙するのが最適です。それによってEnumerator経由というコストすら省くことが可能です。更に、<code>Span&lt;T&gt;</code>が取得できているなら、<code>List&lt;int&gt;</code>や<code>List&lt;Vector3&gt;</code>の場合にコピーのみで処理することもできます。</p>
<p>Deserializeの場合にも、興味深い最適化があります。まず、MemoryPackのDeserializeは <code>ref T? value</code> を受け取るようになっていて、valueがnullの場合は内部で生成したオブジェクトを（普通のシリアライザと同様）、valueが渡されている場合は上書きするようになっています。これによってDeserialize時の新規オブジェクト生成というアロケーションをゼロにすることが可能です。コレクションの場合も、<code>List&lt;T&gt;</code>の場合は<code>Clear()</code>を呼び出すことで再利用します。</p>
<p>その上で、特殊なSpanの呼び出しをすることにより、 <code>List&lt;T&gt;.Add</code> すら避けることに成功しました。</p>
<pre><code class="language-csharp">public sealed class ListFormatter&lt;T&gt; : MemoryPackFormatter&lt;List&lt;T?&gt;&gt;
{
    public override void Deserialize(ref MemoryPackReader reader, scoped ref List&lt;T?&gt;? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (value == null)
        {
            value = new List&lt;T?&gt;(length);
        }
        else if (value.Count == length)
        {
            value.Clear();
        }

        var span = CollectionsMarshalEx.CreateSpan(value, length);
        reader.ReadSpanWithoutReadLengthHeader(length, ref span);
    }
}

internal static class CollectionsMarshalEx
{
    /// &lt;summary&gt;
    /// similar as AsSpan but modify size to create fixed-size span.
    /// &lt;/summary&gt;
    public static Span&lt;T?&gt; CreateSpan&lt;T&gt;(List&lt;T?&gt; list, int length)
    {
        list.EnsureCapacity(length);

        ref var view = ref Unsafe.As&lt;List&lt;T?&gt;, ListView&lt;T?&gt;&gt;(ref list);
        view._size = length;
        return view._items.AsSpan(0, length);
    }

    // NOTE: These structure depndent on .NET 7, if changed, require to keep same structure.

    internal sealed class ListView&lt;T&gt;
    {
        public T[] _items;
        public int _size;
        public int _version;
    }
}

// MemoryPackReader.ReadSpanWithoutReadLengthHeader
public void ReadSpanWithoutReadLengthHeader&lt;T&gt;(int length, scoped ref Span&lt;T?&gt; value)
{
    if (length == 0)
    {
        value = Array.Empty&lt;T&gt;();
        return;
    }

    if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
    {
        if (value.Length != length)
        {
            value = AllocateUninitializedArray&lt;T&gt;(length);
        }

        var byteCount = length * Unsafe.SizeOf&lt;T&gt;();
        ref var src = ref GetSpanReference(byteCount);
        ref var dest = ref Unsafe.As&lt;T, byte&gt;(ref MemoryMarshal.GetReference(value)!);
        Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

        Advance(byteCount);
    }
    else
    {
        if (value.Length != length)
        {
            value = new T[length];
        }

        var formatter = GetFormatter&lt;T&gt;();
        for (int i = 0; i &lt; length; i++)
        {
            formatter.Deserialize(ref this, ref value[i]);
        }
    }
}
</code></pre>
<p><code>new List&lt;T&gt;(capacity)</code> や <code>List&lt;T&gt;.EnsurceCapacity(capacity)</code> によって、<code>List&lt;T&gt;</code>の抱える内部の配列のサイズを事前に拡大しておくことが可能です。これにより、都度拡大/コピーが内部で発生することを避けることができます。</p>
<p>その状態で <code>CollectionsMarshal.CreateSpan</code> を使うと、取得できるSpanは、長さ0のものです。なぜなら内部のsizeは変更されていないため、です。もし <code>CollectionMarshals.AsMemory</code>があれば、そこから<code>MemoryMarshal.TryGetArray</code>のコンボで生配列を取得できて良いのですが、残念ながら Span からは元になっている配列を取得する手段がありません。そこで、<code>Unsafe.As</code>で強引に型の構造を合わせて、<code>List&lt;T&gt;._size</code>を弄ることによって、拡大済みの内部配列を取得することができました。</p>
<p>そうすればunamanged型の場合はコピーだけで済ませてしまう最適化や、<code>List&lt;T&gt;.Add</code>(これは都度、配列のサイズチェックが入る)を避けた、<code>Span&lt;T&gt;[index]</code>経由での値の詰め込みが可能になり、従来のシリアライザのデシリアライズよりも遥かに高いパフォーマンスを実現しました。</p>
<p><code>List&lt;T&gt;</code>への最適化が代表的ではありますが、他にも紹介しきれないほど、全ての型を精査し、可能な限りの最適化をそれぞれに施してあります。</p>
<h2>まとめ</h2>
<p>なぜ開発しようかと思ったかというと、MessagePack for C#に不満がでてきたから、です。残念ながら .NET「最速」とはいえないような状況があり、その理由としてバイナリ仕様が足を引っ張っているため、改善するのにも限界があることには随分前から気づいていました。また、実装面でもIL生成とRoslynを使った外部ツールとしてのコードジェネレーター(mpc)の、二種のメンテナンスがかなり厳しくなってきているということもありました。外部ツールとしてのコードジェネレーターはトラブルの種で、何かと環境によって動かないということが多発していて、Source Generatorにフル対応できるのなら、もはや廃止したいぐらいにも思っていました。</p>
<p>そこに .NET 7/C# 11 の ref fieldやstatic abstract methodを見た時、これをシリアライザー開発に応用したらパフォーマンスの底上げが可能になる、ついでにSource Generator化すれば、いっそIL生成も廃止してSource Generatorに一本化できるのではないか？それならもう、それをMessagPack for C#に適用する前に、パフォーマンス向上に問題のあるバイナリ仕様の限界も無視した、C#のためだけに究極の性能を実現するシリアライザーを作って、本当の最速を実証してしまえばいいのでは？と。</p>
<p>性能特化の実験的シリアライザーではなくて、実用性も重視したシリアライザーであるために、MessagePack for C#での経験も元にして、多くの機能も備えるようにしました。</p>
<pre><code>* .NETのモダンI/O API対応(IBufferWriter&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, ReadOnlySequence&lt;byte&gt;)
* 既存オブジェクトへの上書きデシリアライズ
* ポリモーフィズムなシリアライズ(Union)
* PipeWriter/Readerを活用したストリーミングシリアライズ/デシリアライズ
* (やや限定的ながらも)バージョニング耐性
* TypeScriptコード生成
* Unity(2021.3)サポート
</code></pre>
<p>欠点としては、バージョニング耐性が、仕様上やや貧弱です。詳しくは<a href="https://github.com/Cysharp/MemoryPack#version-tolerant">ドキュメントを参照してください</a>。パフォーマンスをやや落としてバージョニング耐性を上げるオプションを追加することは検討しています。また、メモリコピーを多用するので、実行環境が little-endian であることを前提にしています。ただし現代のコンピューターはほぼすべて little-endian であるため、問題にはならないはずです。</p>
<p>パフォーマンスのために特化したstructを作ってメモリコピーする、といったことはC#の最適化のための手段として、そこまで珍しいわけではなく、やったことある人もいるのではないかと思います。そこからすると、あるいはこの記事を読んで、MemoryPackは一見ただのメモリコピーの塊じゃん、みたいな感じがあるかもしれませんが、汎用シリアライザーとして成立させるのはかなり大変で、そこをやりきっているのが新しいところです。</p>
<p>当初実現していなかった .NET 5/6(Standard 2.1)対応やUnity対応は完了したので、今後は<a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a>のSource Generator/MemoryPack対応や、<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>のシリアライザ変更対応など、利用できる範囲をより広げることを考えています。Cysharpの C#ライブラリ のエコシステムの中心になると位置づけているので、今後もかなり力入れて成長させていこうと思っていますので、まずは、是非是非試してみてください！</p>
</div>
<h1><a href="https://neue.cc/2022/07/13_Cancellation.html">async/awaitのキャンセル処理やタイムアウトを効率的に扱うためのパターン＆プラクティス</a></h1>
<ul class="date"><li>2022-07-13</li></ul>
<div class="entry_body"><p>async/awaitの鬼門の一つとして、適切なキャンセル処理が挙げられます。別に基本的にはそんな難しいことではなく、CancellationTokenSourceを作る、CanellationTokenを渡す、OperationCanceledExceptionをハンドリングする。というだけの話です。けれど、Tokenに手動でコールバックをRegisterしたときとか、渡す口が空いてないものに無理やりなんとかするときとか、タイムアウトに使った場合の始末とか、ちょっと気の利いた処理をしたいような場面もあり、そうした時にどうすれば良いのか悩むこともあります。</p>
<p>こういうのはパターンと対応さえ覚えてしまえばいい話でもあるので、今回は<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>の実装時に直面したパターンから、「外部キャンセル・タイムアウト・大元のDispose」が複合された状況での処理の記述方法と、適切な例外処理、そして最後にObjectPoolなども交えた効率的なゼロアロケーションでのCancellationTokenSourceのハンドリング手法を紹介します。</p>
<h2>CreateLinkedTokenSourceを使ったパターン</h2>
<p>何かのClientを実装してみる、ということにしましょう。キャンセル処理の最も単純なパターンは引数の末尾にCancellationTokenを用意して、内部のメソッドにひたすら伝搬させていくことです。きちんと伝搬させていけば、最奥の処理が適切にCancellationTokenをハンドリングしてキャンセル検知時にOperationCanceledExceptionを投げてくれます。CancellationTokenをデフォルト引数にするか、必ず渡す必要があるよう強制するかは、アプリケーションの性質次第です。アプリケーションに近いコードでは強制させるようにしておくと、渡し忘れを避けれるので良いでしょう。</p>
<pre><code class="language-csharp">class Client
{
    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        await SendCoreAsync(cancellationToken);
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // nanika...
    }
}
</code></pre>
<p>非同期メソッドのキャンセルはCancellationTokenで処理するのが基本で、別途Cancelメソッドを用意する、といったことはやめておきましょう。実装が余計に複雑化するだけです。CancellationTokenを伝搬させるのが基本であり全てです。</p>
<p>任意のキャンセルの他に、タイムアウト処理を入れたい、というのは特に通信系ではよくあります。async/awaitでのタイムアウトの基本は、タイムアウトもキャンセル処理の一つである、ということです。CancellationTokenSourceにはCancelAfterという一定時間後にCancelを発火させるというメソッドが用意されているので、これを使ってCancellationTokenを渡せば、すなわちタイムアウトになります。</p>
<pre><code class="language-csharp">// Disposeすると内部タイマーがストップされるのでリークしない
using var cts = new CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromMinutes(1));

await client.SendAsync(cts.Token);
</code></pre>
<blockquote>
<p><a href="https://github.com/Cysharp/UniTask">UniTask</a>ではCancelAfterSlimというメソッドが用意されているため、そちらを使うことをお薦めします。Cancelはスレッドプールを使いますが、CancelAfterSlimはPlayerLoop上で動くため、Unityフレンドリーな実装になっています。ただし内部タイマーのストップ手法がCancelAfterSlimの戻り値をDisposeする必要があるというように、実装に若干差異があります。</p>
</blockquote>
<p>タイムアウト時間は大抵固定のため、ユーザーに都度CancelAfterを叩かせるというのは、だいぶ使いにくい設計です。そこで、CancelAfterの実行はSendAsyncメソッドの内部で行うことにしましょう。そうした内部のタイムアウト用CancellationTokenと、外部からくるCancellationTokenを合成して一つのCancellationTokenに変換するには、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.createlinkedtokensource">CancellationTokenSource.CreateLinkedTokenSource</a>が使えます。</p>
<pre><code class="language-csharp">class Client
{
    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        // 連結された新しいCancellationTokenSourceを作る
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        cts.CancelAfter(Timeout);

        await SendCoreAsync(cts.Token);
    }

    // snip...
}
</code></pre>
<p>CreateLinkedTokenSourceで生成されたCancellationTourceは連結されたいずれかがCancelされると、生成されたCancellationTokenSource自体もCancelされます。また、それ自体からもCancelが発火できます。</p>
<p>これで完成！なのですが、このままだと例外処理に問題があります。</p>
<p>OperationCanceledExceptionは <code>CancellationToken</code>というプロパティを持っていて、これを元に呼び出し側はキャンセルの原因を判別することができます。一つ例を出しますが、以下のようにOperationCanceledExceptionをcatchしたうえで、更に判定を入れてコード分岐をかけることがあります。</p>
<pre><code class="language-csharp">try
{
    await client.SendAsync(token);
}
catch (OperationCanceledException ex) when (ex.CancellationToken == token)
{
    // Cancelの原因をTokenによって判定できる
}
</code></pre>
<p>例外を何も処理せずに全部おまかせでやると、投げられる OperationCanceledException.CancellationToken は CreateLinkedTokenSource で連結したTokenになってしまい、何の意味もない情報ですし、原因の判別に使うこともできません。</p>
<p>また、タイムアウトをOperationCanceledExceptionとして扱ってしまうことも問題です。OperationCanceledExceptionは特殊な例外で、既知の例外であるとしてロギングから抜いたりすることもままあります（例えばウェブサーバーでクライアントの強制切断(リクエスト中にブラウザ閉じたりとか)でキャンセルされることはよくあるけれど、それをいちいちエラーで記録していたらエラー祭りになってしまう）。タイムアウトは明らかな異常であり、そうしたキャンセルとは確実に区別して欲しいし、OperationCanceledExceptionではない例外になって欲しい。</p>
<p>これは .NET のHttpClientでも <a href="https://github.com/dotnet/runtime/issues/21965">HttpClient throws TaskCanceledException on timeout #21965</a> としてIssueがあがり(TaskCanceledExceptionはOperationCanceledExceptionとほぼ同義です)、大激論(121コメントもある！)を巻き起こしました。HttpClientはタイムアウトだろうが手動キャンセルだろうが区別なくTaskCanceledExceptionを投げるのですが、原因は、実装が上の例の通りCreateLinkedTokenSourceで繋げたもので処理していて、そして、特に何のハンドリングもしていなかったからです。</p>
<p>結論としてこれはHttpClientの設計ミスなのですが、一度世の中に出したクラスの例外の型を変更することは .NET の互換性維持のポリシーに反するということで（実際、これを変更してしまうと影響は相当大きくなるでしょう）、お茶を濁した対応(InnerExceptionにTimeoutExceptionを仕込んで、判定はそちら経由で一応できなくもないようにした)となってしまったのですが、今から実装する我々は同じ轍を踏んではいけない。ということで、ちゃんと正しく処理するようにしましょう。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    cts.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(cts.Token);
    }
    catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            // 引数のCancellationTokenが原因なので、それを保持したOperationCanceledExceptionとして投げる
            throw new OperationCanceledException(ex.Message, ex, cancellationToken);
        }
        else
        {
            // タイムアウトが原因なので、TimeoutException(或いは独自の例外)として投げる
            throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
        }
    }
}
</code></pre>
<p>やることは別に難しくはなく、OperationCanceledExceptionをcatchしたうえで、外から渡されたcancellationTokenがキャンセルされているならそれが原因、そうでないならタイムアウトが原因であるという判定をして、それに応じた例外を投げ直します。</p>
<p>最後に、Client自体がDisposeできるとして、それに反応するようなコードにしましょう。</p>
<pre><code class="language-csharp">class Client : IDisposable
{
    // IDisposableと引っ掛けて、Client自体がDisposeされたら実行中のリクエストも終了させるようにする
    readonly CancellationTokenSource clientLifetimeTokenSource;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.clientLifetimeTokenSource = new CancellationTokenSource();
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(clientLifetimeTokenSource.Token, cancellationToken);
        cts.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(cts.Token);
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                // 引数のCancellationTokenが原因なので、それを保持したOperationCanceledExceptionとして投げる
                throw new OperationCanceledException(ex.Message, ex, cancellationToken);
            }
            else if (clientLifetimeTokenSource.IsCancellationRequested)
            {
                // クライアント自体がDisposeされたのでOperationCanceledException、或いは独自の例外を投げる
                throw new OperationCanceledException(&quot;Client is disposed.&quot;, ex, clientLifetimeTokenSource.Token);
            }
            else
            {
                // タイムアウトが原因なので、TimeoutException(或いは独自の例外)として投げる
                throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
            }
        }
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // nanika...
    }

    public void Dispose()
    {
        clientLifetimeTokenSource.Cancel();
        clientLifetimeTokenSource.Dispose();
    }
}
</code></pre>
<p>差分はCreateLinkedTokenSourceで連結するトークンを増やすのと、例外処理時の分岐を増やすことだけです。</p>
<h2>ゼロアロケーション化する</h2>
<p>殆どの場合は上記のパターンで全く問題ないのですが、都度CreateLinkedTokenSourceで新しいCancellationTokenSourceを作るのが気になる、かもしれません。どちらにせよasyncメソッドが非同期で実行される場合には、非同期ステートマシン自体のアロケーションが発生するので実際のところ別に気にするほどのことではない。のですが、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.sources.ivaluetasksource">IValueTaskSource</a>や<a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.poolingasyncvaluetaskmethodbuilder-1">PoolingAsyncValueTaskMethodBuilder</a>を使ったアロケーションを避ける非同期実装を行っていた場合には、相当気になる問題になってきます。また、HTTP/1のREST呼び出しのような頻度では大したことないですが、これが例えばサーバーで大量の並列実行をさばく、クライアントではリアルタイム通信で毎フレーム通信する、といった用途だと、この辺も気を配りたくなってくるかもしれません。</p>
<p>なお、ここでは説明の簡略化のために、SendAsyncメソッド自体はasync Taskのままにします。</p>
<p>まずは外部キャンセルのない、タイムアウトだけのケースを見ていきます。タイムアウトは正常系の場合は発火しない、つまり殆どの場合は発火しないため、非発火時にはCancellationTokenSourceを使い回すようにしましょう。</p>
<pre><code class="language-csharp">class Client
{
    // SqlConnectionのようなメソッドを多重に呼ぶことを禁止しているクラスの場合はフィールドにCancellationTokenSourceを一つ
    // HttpClientのようにあちこちから多重に呼ばれる場合があるものはObjectPoolで保持する

    readonly ObjectPool&lt;CancellationTokenSource&gt; timeoutTokenSourcePool;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.timeoutTokenSourcePool = ObjectPool.Create&lt;CancellationTokenSource&gt;();
    }

    public async Task SendAsync()
    {
        var timeoutTokenSource = timeoutTokenSourcePool.Get();
        timeoutTokenSource.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(timeoutTokenSource.Token);
        }
        finally
        {
            // Timeout処理が発火していない場合はリセットして再利用できる
            if (timeoutTokenSource.TryReset())
            {
                timeoutTokenSourcePool.Return(timeoutTokenSource);
            }
        }
    }
}
</code></pre>
<p>ObjectPoolの実装は色々ありますが、今回は説明の簡略化のために<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.objectpool">Microsoft.Extensions.ObjectPool</a>を使いました(NuGetからMicrosoft.Extensions.ObjectPoolを参照する必要あり)。タイムアウトが発動した場合は再利用不能なので、プールに戻してはいけません。なお、 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.tryreset">CancellationTokenSource.TryReset</a>は .NET 6 からのメソッドになります。それ以前の場合は <code>CancelAfter(Timeout.InfiniteTimeSpan)</code> を呼んでタイマー時間を無限大に引き伸ばす変更を入れる（内部的にはTimerがChangeされる）というハックがあります。</p>
<p>外部キャンセルが入る場合には、LinkedTokenを作らず、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.unsaferegister">CancellationToken.UnsafeRegister</a>でタイマー用のCancellationTokenSourceをキャンセルするようにします。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    var timeoutTokenSource = timeoutTokenSourcePool.Get();

    CancellationTokenRegistration externalCancellation = default;
    if (cancellationToken.CanBeCanceled)
    {
        // 引数のCancellationTokenが発動した場合もTimeout用のCancellationTokenを発火させる
        externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);
    }

    timeoutTokenSource.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(timeoutTokenSource.Token);
    }
    finally
    {
        // Registerの解除(TryResetの前に「必ず」先に解除すること)
        // CancellationTokenRegistration.Disposeは解除完了（コールバック実行中の場合は実行終了）までブロックして確実に待ちます
        externalCancellation.Dispose();
        if (timeoutTokenSource.TryReset())
        {
            timeoutTokenSourcePool.Return(timeoutTokenSource);
        }
    }
}
</code></pre>
<p>CancellationToken.UnsafeRegisterは .NET 6 からのメソッドでExecutionContextをCaptureしないため、より高効率です。それ以前の場合はRegisterを使うか、呼び出しの前後でExecutionContext.SuppressFlow/RestoreFlowするというハックが使えます(UniTaskのRegisterWithoutCaptureExecutionContextはこの実装を採用しています)。</p>
<p>CancellationTokenにコールバックを仕込む場合、レースコンディションが発生する可能性が出てきます。この場合だとTimeout用のCancellationTokenSourceをプールに戻した後にCancelが発生すると、最悪なことになります。それを防ぐために、CancellationTokenRegistration.DisposeをTryResetの前に必ず呼びましょう。CancellationTokenRegistration.Disposeの優れているところは、コールバックが実行中の場合は実行終了までブロックして確実に待ってくれます。これによりマルチスレッドのタイミング問題ですり抜けてしまうといったことを防いでくれます。</p>
<p>ブロックといいますが、コールバックに登録されたメソッドがすぐに完了する性質のものならば、lockみたいなものなので神経質になる必要はないでしょう。<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokenregistration">CancellationTokenRegistration</a>にはDisposeAsyncも用意されていますが、むしろそちらを呼ぶほうがオーバーヘッドであるため、無理にDisposeAsyncのほうを優先する必要はないと考えています。CancellationTokenRegistrationには他にUnregisterメソッドもあり、これはfire-and-forget的に解除処理したい場合に有効です。使い分けですね。</p>
<p>なお、CancellationTokenへのコールバックのRegister(UnsafeRegister)は、初回はコールバック登録用のスロットを生成するといったアロケーションがありますが、Dispose/Registerを繰り返す二回目以降はスロットを再利用してくれます。このへんも新規に(Linked)CancellationTokenSourceを作るより有利な点となりますね。</p>
<p>引き続き、Client自体の寿命に引っ掛けるCancellationTokenを追加した実装を見ていきましょう。といっても、単純にRegisterを足すだけです。</p>
<pre><code class="language-csharp">class Client : IDisposable
{
    readonly TimeSpan timeout;
    readonly ObjectPool&lt;CancellationTokenSource&gt; timeoutTokenSourcePool;
    readonly CancellationTokenSource clientLifetimeTokenSource;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.timeoutTokenSourcePool = ObjectPool.Create&lt;CancellationTokenSource&gt;();
        this.clientLifetimeTokenSource = new CancellationTokenSource();
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        var timeoutTokenSource = timeoutTokenSourcePool.Get();

        CancellationTokenRegistration externalCancellation = default;
        if (cancellationToken.CanBeCanceled)
        {
            // 引数のCancellationTokenが発動した場合もTimeout用のCancellationTokenを発火させる
            externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
            {
                ((CancellationTokenSource)state!).Cancel();
            }, timeoutTokenSource);
        }

        // Clientの寿命に合わせたものも同じように追加しておく
        var clientLifetimeCancellation = clientLifetimeTokenSource.Token.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);

        timeoutTokenSource.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(timeoutTokenSource.Token);
        }
        finally
        {
            // Registerの解除増量
            externalCancellation.Dispose();
            clientLifetimeCancellation.Dispose();
            if (timeoutTokenSource.TryReset())
            {
                timeoutTokenSourcePool.Return(timeoutTokenSource);
            }
        }
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // snip...
    }

    public void Dispose()
    {
        clientLifetimeTokenSource.Cancel();
        clientLifetimeTokenSource.Dispose();
    }
}
</code></pre>
<p>例外処理も当然必要です！が、ここは最初の例のLinkedTokenで作ったときと同じです。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    var timeoutTokenSource = timeoutTokenSourcePool.Get();

    CancellationTokenRegistration externalCancellation = default;
    if (cancellationToken.CanBeCanceled)
    {
        externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);
    }

    var clientLifetimeCancellation = clientLifetimeTokenSource.Token.UnsafeRegister(static state =&gt;
    {
        ((CancellationTokenSource)state!).Cancel();
    }, timeoutTokenSource);

    timeoutTokenSource.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(timeoutTokenSource.Token);
    }
    catch (OperationCanceledException ex) when (ex.CancellationToken == timeoutTokenSource.Token)
    {
        // 例外発生時の対応はLinkedTokenで作ったときと特に別に変わらず

        if (cancellationToken.IsCancellationRequested)
        {
            throw new OperationCanceledException(ex.Message, ex, cancellationToken);
        }
        else if (clientLifetimeTokenSource.IsCancellationRequested)
        {
            throw new OperationCanceledException(&quot;Client is disposed.&quot;, ex, clientLifetimeTokenSource.Token);
        }
        else
        {
            throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
        }
    }
    finally
    {
        externalCancellation.Dispose();
        clientLifetimeCancellation.Dispose();
        if (timeoutTokenSource.TryReset())
        {
            timeoutTokenSourcePool.Return(timeoutTokenSource);
        }
    }
}
</code></pre>
<p>ということで、↑のものが最終形となりました。</p>
<p>async/awaitで実装されている場合、Tokenのコールバックも一メソッド内で収まっているために挙動の見通しがだいぶ良くなります。async/awaitを封印してIValueTaskSourceを使った実装をする場合は、複数のコールバックを手で処理する必要があり、また登録、発火する箇所も複数箇所にちらばってしまうため、遥かに複雑性が増します。</p>
<p>AlterNatsでは<a href="https://neue.cc/2022/05/11_AlterNats.html">ハイパフォーマンスSocketプログラミングとして実装を解説した記事</a>で、IValueTaskSourceをChannel（キュー）に詰め込むとしていますが、キャンセル時には<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.sources.manualresetvaluetasksourcecore-1">ManualResetValueTaskSourceCore</a>のSetExceptionを叩き、正常完了時にはSetResultの前でTryResetからのReturnするという、まぁ基本的な流れは一緒です。少し異なるのは、キャンセルで発火するのはawaitに紐付けられた継続処理だけで、実体はキューに残り続けていて、取り出し時にキャンセル状況をチェックして、何もしないようにする。といったことでしょうか。状況が複雑化する分、レースコンディション起因のバグが入り込みやすくなってしまうので、CancellationTokenRegistrationの挙動をしっかり把握して実装する必要があります。</p>
<h2>まとめ</h2>
<p>簡単かどうかでいうと、言われればなるほどそうですねーって感じですが、都度考えてやれって言われると結構難しいと思います。なので、こういうパターンなんですね、というのを頭に叩き込んでおくというのは重要だと思いますし、まぁとりあえず覚えてください。覚えれば、別にコード的に複雑というわけでもないので、易易と対処できるようになるはずです。</p>
<p><a href="https://github.com/StackExchange/StackExchange.Redis/">StackExchange.Redis</a>も非同期メソッド、CancellationTokenを受け取ってなかったりしますし、パフォーマンスを追求しつつCancellationToken対応を入れるのは、かなり難しい問題だったりします。しかしこの .NET 6世代ではかなりメソッドも増えていて、やろうと思えばやりきれるだけの手札が揃っています。なので、パターン化して真正面から立ち向かいましょう……！</p>
</div>
<h1><a href="https://neue.cc/2022/07/06_mvp-renew.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2022-07-06</li></ul>
<div class="entry_body"><p>12回目。一年ごとに再審査があって7月に一斉更新されるシステムになっていて、今年も継続しました。</p>
<p>元々、私の活動はオンライン一人自己完結型なので、C#布教活動（？）的にコロナの影響は一切受けていないのですが、勉強会開催などコミュニティ構築型の人だと影響を受けやすいここ数年だったのではないかと思います。ただ、やはりアフターコロナで人との繋がりは極度に減ったし、人の入れ替わり、新しい台頭みたいなのも少なくなってきたなあ、というのが肌間ありますね。改めて、コミュニティを維持してくれている人のありがたさを知りました。というわけで、C#コミュニティ盛り上がっていって欲しい！のですが、私自身のスタンスは変わらず、OSSで世の中に存在感を出していくことだとは思っています。</p>
<p>好不調の並が割と激しくて、ここ数ヶ月何もやってないわーみたいなときもよくあるのですが、年を通すと毎年3, 4個は新規にOSSをリリースしているし、既存ライブラリのメンテナンスやテコ入れ大型リニューアルも数個やっていたりするので、年間通して見ればかなりハイパフォーマンスで、それを10年以上継続してるんだから中々なんじゃないですか？と自画自賛したくなったり。</p>
<p>そんなこんなの活動を続けてきた結果、CEDECという国内最大のゲーム業界のカンファレンスでも<a href="https://cedec.cesa.or.jp/2022/event/awards">CEDEC AWARDS 2022</a>のエンジニアリング部門で、「.NET/Unity開発の可能性を広げるオープンソースソフトウェアの提供」として優秀賞を受賞しました。C#は元々裏方で便利に使っていたというのはありましたが、表でもガンガン使っていけるよ、といったC#の存在感は、高めていけてるんじゃないかと思います。CysharpとしてOSSを通じてC#の可能性を広げるということがしっかり伝わってるというのがとても嬉しいですね！参加者投票で部門別最優秀賞が決まるらしいので、是非投票を……！</p>
<p>また、今年は<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a>という記事で書きましたが、開発に関わっていた「プリコネ！グランドマスターズ」のリリースがありました。の事例発表をCEDEC 2022で<a href="https://cedec.cesa.or.jp/2022/session/detail/80">C#によるクライアント/サーバーの開発言語統一がもたらす高効率な開発体制 ～プリコネ！グランドマスターズ開発事例～</a>としてCygamesさんより発表があります。</p>
<ul>
<li>クライアント/サーバーの開発言語統一によるメリット</li>
<li>MagicOnion(gRPC)を利用したリアルタイムサーバー実装手法と具体例</li>
<li>Blazorを使用したツールの開発例、開発プロジェクトおよびソリューション統合管理の手法</li>
</ul>
<p>ということで、かなり面白い感じの内容になるのではないでしょうか、期待……！</p>
<p>C#がエンタープライズ業界（とは）で強いというのは重々承知だしAzureもシェア高くめっちゃ使われてるんだよ、という話は分かりはするのですが、to Cやスタートアップ企業で積極的に使われる言語になって欲しい、というのがずーっとの願いで、私自身もそうした業界に身をおいて、実績で示し続けて来たと思いますし、これからも引き続き道を示せるようにしていきたいです。</p>
<p>もちろん、ハイパフォーマンスなC#によって最前線での実力を見せていく、ということも変わらずに……！</p>
</div>
<h1><a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a></h1>
<ul class="date"><li>2022-05-11</li></ul>
<div class="entry_body"><p>タイトルはここぞとばかりに全盛りにしてみました！今回NATSの.NETクライアント実装としてAlterNatsというライブラリを新しく作成し、公開しました。</p>
<ul>
<li><a href="https://github.com/Cysharp/AlterNats">github - Cysharp/AlterNats</a></li>
</ul>
<p>公式の既存クライアントの3倍以上、StackExchange.RedisのPubSubと比較して5倍以上高速であり、通常のPubSubメソッドは全てゼロアロケーションです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164392256-46d09111-ec70-4cf3-b33d-38dc5d258455.png" alt="image" /></p>
<p>そもそも<a href="https://nats.io/">NATS</a>とはなんぞやか、というと、クラウドネイティブなPubSubのミドルウェアです。<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>のincubating projectなので、それなりの知名度と実績はあります。</p>
<p>PubSubというと、特にC#だと<a href="https://redis.io/">Redis</a>のPubSub機能で行うのが、<a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>という実績あるライブラリもあるし、AWSやAzure、GCPがマネージドサービスも用意しているしで、お手軽でいいのですが、盲目的にそれを使うのが良いのか少し疑問に思っていました。</p>
<p>RedisはKVS的な使い方がメインであり、PubSubはどちらかというとオマケ機能であるため</p>
<ul>
<li>PubSub専用のモニタリングの欠如</li>
<li>PubSub用のクラスタリング対応</li>
<li>マネージドサービスでの価格体系のバランスの悪さ（PubSub特化ならメモリはあまりいらない）</li>
<li>そもそものパフォーマンス</li>
</ul>
<p>といった点が具体的な懸念です。そして、NATSはPubSub専用に特化されているため、そのためのシステムが豊富に組まれているし、性能も申し分なさそうに思えました。しいて欠点を言えばマネージドサービスが存在しないのがネックですが、純粋なPubSubとしての利用ならば永続化処理について考える必要がないので、ミドルウェアとしては運用しやすい部類にはいるのではないかと思っています。（NATS自体はNATS JetStreamという機能によってAt-least / exactly onceの保証のあるメッセージングの対応も可能ですが、そこに対応させるにはストレージが必要になる場合もあります）</p>
<p>しかし調べていくうちに懸念となったのが公式クライアントである<a href="https://github.com/nats-io/nats.net">nats.net</a>で、あまり使いやすくないのですね。async/awaitにも対応していないし、古くさく、それどころかそもそも.NET的に奇妙に見えるAPIであり、そうなるとパフォーマンスに関しても疑問に思えてくる。</p>
<p>何故そうなっているかの理由はReadMeにも明記されていて、メンテナンス性のためにGoクライアント(ちなみにNATS Server自体はGoで書かれている)と同じようなコードベースになっている、と。そのためC#的ではない部分が多々あるし、GoとC#ではパフォーマンスを出すための書き方が全く異なるので、あまり良い状況ではなさそう。</p>
<p>それならば完全にC#に特化して独自に作ってしまうほうがいいだろうということで、作りました。公式クライアントと比べると全ての機能をサポートしているわけではない（JetStreamにも対応していないしLeaf Nodes運用で必須になるであろうTLSにも対応していません）のですが、PubSubのNATS Coreに特化して、まずは最高速を叩き出せるようにしました。PubSub利用する分には機能面での不足はないはずです。</p>
<p>AlterNatsは公式じゃないAlternativeなNATSクライアントという意味です。まんまですね。割と語感が良いので命名的には結構気に入ってます。</p>
<h2>Getting Started</h2>
<p>APIは、<code>nats.net</code>があまりにもC#っぽくなくややこしい、ということを踏まえて、シンプルに、簡単に、C#っぽく書けるように調整しました。</p>
<pre><code class="language-csharp">// create connection(default, connect to nats://localhost:4222)
await using var conn = new NatsConnection();

// for subscriber. await register to NATS server(not means await complete)
var subscription = await conn.SubscribeAsync&lt;Person&gt;(&quot;foo&quot;, x =&gt;
{
    Console.WriteLine($&quot;Received {x}&quot;);
});

// for publisher.
await conn.PublishAsync(&quot;foo&quot;, new Person(30, &quot;bar&quot;));

// unsubscribe
subscription.Dipose();

// ---

public record Person(int Age, string Name);
</code></pre>
<p>Subscribeでhandlerを登録し、Publishでメッセージを飛ばす。データは全て自動でシリアライズされます（デフォルトではSystem.Text.Json、MessagePack for C#を用いたハイパフォーマンスなシリアライズも可能な拡張オプションも標準で用意してあります）</p>
<p>別のURLへの接続や、認証のための設定などを行うNatsOptions/ConnectOptionsはイミュータブルです。そのため、with式で構築するやり方を取っています。</p>
<pre><code class="language-csharp">// Options can configure `with` operator
var options = NatsOptions.Default with
{
    Url = &quot;nats://127.0.0.1:9999&quot;,
    LoggerFactory = new MinimumConsoleLoggerFactory(LogLevel.Information),
    Serializer = new MessagePackNatsSerializer(),
    ConnectOptions = ConnectOptions.Default with
    {
        Echo = true,
        Username = &quot;foo&quot;,
        Password = &quot;bar&quot;,
    }
};

await using var conn = new NatsConnection(options);
</code></pre>
<p>NATSには標準で結果を受け取るプロトコルも用意されています。サーバー間の簡易的なRPCとして使うと便利なところもあるのではないかと思います。これも<code>SubscribeRequestAsync</code>/<code>RequestAsync</code>という形で簡単に直感的に書けるようにしました（Request側は戻り値の型を指定する必要があるため、型指定が少しだけ冗長になります）</p>
<pre><code class="language-csharp">// Server
await conn.SubscribeRequestAsync(&quot;foobar&quot;, (int x) =&gt; $&quot;Hello {x}&quot;);

// Client(response: &quot;Hello 100&quot;)
var response = await conn.RequestAsync&lt;int, string&gt;(&quot;foobar&quot;, 100);
</code></pre>
<p>例では <code>await using</code>ですぐに破棄してしまっていますが、基本的にはConnectionはシングルトンによる保持を推奨しています。staticな変数に詰めてもいいし、DIでシングルトンとして登録してしまってもいいでしょう。接続は明示的にConnectAsyncすることもできますが、接続されていない場合は自動で接続を開くようにもなっています。</p>
<p>コネクションはスレッドセーフで、物理的にも一つのコネクションには一つの接続として繋がり、全てのコマンドは自動的に多重化されます。これにより裏側で自動的にバッチ化された高効率な通信を実現していますが、負荷状況に応じて複数のコネクションを貼った場合が良いケースもあります。AlterNatsではNatsConnectionPoolという複数コネクションを内包したコネクションも用意しています。また、クライアント側で水平シャーディングを行うためのNatsShardingConnectionもあるため、必要に応じて使い分けることが可能です。</p>
<p>内部のロギングはMicrosoft.Extensions.Loggingで管理されています。<code>AlterNats.Hosting</code>パッケージを使うと、Generic Hostと統合された形で適切なILoggerFactoryの設定と、シングルトンのサービス登録を行ってくれます。</p>
<p>DIでの取り出しは直接NatsConnectionを使わずに、INatsCommandを渡すことで余計な操作（コネクションの切断など）が出来ないようになります。</p>
<pre><code class="language-csharp">using AlterNats;

var builder = WebApplication.CreateBuilder(args);

// Register NatsConnectionPool, NatsConnection, INatsCommand to ServiceCollection
builder.Services.AddNats();

var app = builder.Build();

app.MapGet(&quot;/subscribe&quot;, (INatsCommand command) =&gt; command.SubscribeAsync(&quot;foo&quot;, (int x) =&gt; Console.WriteLine($&quot;received {x}&quot;)));
app.MapGet(&quot;/publish&quot;, (INatsCommand command) =&gt; command.PublishAsync(&quot;foo&quot;, 99));

app.Run();
</code></pre>
<h2>メタバースアーキテクチャ</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>という .NET/Unity で使えるネットワークフレームワークを作っているわけですが、AlterNatsはこれと絡めることで、構成の幅を広げることができると考えています、というかむしろそのために作りました。</p>
<p>クライアントにUnity、サーバーにMagicOnionがいるとして、サーバーが一台構成なら、平和です、繋げるだけですもの。開発の最初とかローカルでは楽なのでこの状態でもいいですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164406771-58318153-c6a7-49c0-b3af-2b8389e2c9c1.png" alt="image" /></p>
<p>しかし現実的にはサーバーは複数台になるので、そうなると色々なパターンが出てきます。よくあるのが、ロードバランサーを立ててそれぞれが別々のサーバーに繋がっているものを、更に後ろのPubSubサーバーを通して全サーバーに分配するパターン。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164409016-b6e99f36-bdf7-47a9-80a6-558010963a36.png" alt="image" /></p>
<p>これはNode.jsのリアルタイムフレームワークである<a href="https://socket.io/">Socket.IO</a>のRedisアダプター、それの.NET版である<a href="https://docs.microsoft.com/ja-jp/aspnet/signalr/overview/getting-started/introduction-to-signalr">SignalR</a>のRedisバックプレーン、もちろんMagicOnionにもあるのですが、このパターンはフレームワークでサポートされている場合も多いです。RedisのPubSubでできることはNATSでもできる、ということで、NATSでもできます。</p>
<p>これは各サーバーをステートレスにできるのと、スケールしやすいので、Chatなどの実装にはやりやすい。欠点はステートを持ちにくいので、クライアントにステートがあり、データのやり取りをするタイプしか実装できません。サーバー側にステートを持ったゲームロジックは持たせずらいでしょう（ステートそのものは各サーバーで共有できないため）。また、PubSubを通すことによるオーバーヘッドも気になるところかもしれません。</p>
<p>ロードバランサーを立てる場合、ロードバランサーのスティッキーセッションを活用して一台のサーバーに集約させるというパターンもあります（あるいは独自プロトコルでもリバースプロキシーを全面に立てて、カスタムなロジックで後ろの台を決定することもほぼ同様の話です）。ただし、色々なユーザーを同一サーバーに集約させたいようなケースでは、そのクッキーの発行誰がやるの、みたいなところは変わらずありますね。そこまで決めれるならIPアドレスを返して直繋ぎさせてしまってもいいんじゃないの？というのも真です。</p>
<p>そうした外側に対象のIPアドレスを教えてくれるサービスがいて、先にそれに問い合わせてから、対象のサーバーへ繋ぎに行くパターンは、古典的ですが安定です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164417937-7d1adedb-36ee-453b-9ca6-9d41aded50af.png" alt="image" /></p>
<p>この場合は同一サーバーに繋ぎにいくためにサーバー内にインメモリでフルにステートを持たせることが出来ますし、いわゆるゲームループを中で動かして処理するようなこともできます。また、画面のないヘッドレスUnityなどをホストして、クライアントそのものをサーバー上で動かすこともできますね。</p>
<p>しかし、このパターンは素直なようでいて、実際VMだとやりやすいのですが、Kubernetesでやるのは難しかったりします。というのも、Kubernetesの場合は外部にIPが露出していないため、クラスター内の一台の特定サーバーに繋ぎにいくというのが難しい……！</p>
<p>このような場合に最近よく活用されているのが<a href="https://agones.dev/site/">Agones</a>というGoogleが主導して作っているKubernetesの拡張で、まさにゲーム向きにKubernetesを使えるようにするためのシステムです。</p>
<p>ただし、これはこれで難点があって、Agonesが想定しているゲームサーバーは1プロセス1ゲームセッション(まさにヘッドレスUnityのような)のホスティングであるため、1つのプロセスに多数のゲームセッションをホストさせるような使い方はそのままだと出来ません。コンテナなので、仮想的なプロセスを複数立ち上げればいいでしょ、というのが思想なのはわからなくもないのですが、現実的には軽量なゲームサーバー（それこそMagicOnionで組んだりする場合）なら、1プロセスに多数のゲームセッションを詰め込めれるし、これをコンテナで分けて立ち上げてしまうとコスト面では大きな差が出てしまいます。</p>
<p>さて、Cysharpではステートフルな、特にゲームに向いたC#サーバーを構築するための補助ライブラリとして<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>というゲームループを公開しています。このライブラリはこないだリリースした<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズ</a>でも使用していますが、従来MagicOnionと同居して使っていたLogicLooperを、剥がしたアーキテクチャはどうだろうか、という提案があります。（実際のプリコネ！グランドマスターズのアーキテクチャはMagicOnionと同居し、リバースプロキシーを使った方式を採用しているので（↑の画像のものに近い）、この案とは異なります）</p>
<p><img src="https://user-images.githubusercontent.com/46207/164417734-f2ec80e7-f12f-4a84-8252-ce28f9b53f05.png" alt="image" /></p>
<p>パーツが増えて複雑になったように見えて、この構成には大きな利点があります。まず、同居しているものがなくなったので複雑になったようで実はシンプルになっています。それぞれがそれぞれの役割にフルに集中できるようになるため、パフォーマンスも良くなり、かつ、性能予測もしやすくなります。特にロジックをフルに回転させるLogicLooperがクライアントや接続数の影響を受けずに独立できているのは大きな利点です。</p>
<p>ゲーム全体のステートはLogicLooper自体が管理するため、クライアントとの接続を直接受けているMagicOnion自体はステートレスな状態です。そのため、インフラ的にもロードバランサーの下にMagicOnionを並べるだけで済みますし、サーバー間の接続に伴う面倒事は全てNATSに押し付けられるため、インフラ管理自体はかなりシンプルな構成が取れます。</p>
<p>また、MagicOnion自体はステートを持てるシステムであり、各ユーザーそれぞれのステートを持つのは容易です（サーバーを越えなければいい）。そこで、LogicLooperから届いたデータのうち、繋がってるユーザーに届ける必要がないデータは、MagicOnionの持つユーザーのステートを使ってカリング処理をして、そもそも転送しなかったり間引いたりして通信量を削減することで、ユーザーの体験が良くなります。</p>
<p>各ユーザーから届くデータを使ったステート更新/データ送信に関しては、LogicLooperがゲームループ状になっているので、ループの間に溜まったデータをもとにしてバッチ処理を行えばいいでしょう。バッチ化というと、通信「回数」の削減のためのコマンドを単純にまとめあげて一斉送信するものと、内容を見て処理内容を縮小するパターンが考えられますが、LogicLooperを使ったアプローチでは後者を効率的に行なえます。前者のコマンドの一斉送信に関しては、AlterNatsが裏側で自動パイプライニング化としてまとめているので（後で詳しく説明します）、そこに関しても効率化されています。</p>
<p>このアーキテクチャで気になるのがPubSub通信のオーバーヘッドですが、それに関しての解決策がAlterNatsで、究極的に高速なクライアントがあれば（さすがにインメモリには到底及ばないとはいえ）、そもそものクライアントとサーバーの間にもネットワークがいるわけで、経路のトータルで見れば実用的な範囲に収められる。という想定で作りました。</p>
<p>ところで、そして究極的な利点は、全てC#で組めるということです。どういうことかというと、MagicOnionもLogicLooperも汎用的なC#フレームワークです。特別なプラグインを差し込んで処理するというわけではなくて、ふつーのC#コードをふつーに書くことで、それぞれの箇所に、アプリケーション固有のコードを仕込んでいくことができる。これが、本当の大きな利点です。専用のC++ミドルウェアを作って挟んで最適化できるぞ！などといったシステムは、素晴らしいことですが、専門性が高く再現性が低い。MagicOnionとLogicLooper、そしてAlterNatsを活用したこの構成なら、C#エンジニアなら誰でも（容易に）できる構成です。<a href="https://cysharp.co.jp/">Cysharp</a>のメッセージは「C#の可能性を切り開いていく」ですが、誰もが実現できる世界を作っていくというのが目標でもあります。</p>
<p>なお、ワーカーとしてのLogicLooperを作るに<a href="https://docs.microsoft.com/ja-jp/dotnet/core/extensions/workers">Worker Service</a>という.NET 6からのプロジェクトタイプが適切です。</p>
<h2>ハイパフォーマンスSocketプログラミング</h2>
<ul>
<li>Socket API</li>
</ul>
<p>C#で最も低レベルにネットワーク処理を扱えるクラスは<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socket">Socket</a>です。そして、非同期でハイパフォーマンスな処理を求めるなら<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socketasynceventargs">SocketAsyncEventArgs</a>をうまく再利用しながらコールバックを仕込む必要があります。</p>
<p>これは非常に厄介で些か難易度も高いのですが、現在はasync/awaitの時代、ちゃんとawaitできる***Asyncメソッド郡が用意されています。しかし、使ってはいけないAPI、使ってはいけないオーバーロードも並んでいるので、その選別が必要です。SocketのAPIは歴史的事情もあり混沌としてしまっているのです……。</p>
<p>使うべきAPIを分かりやすく見分ける手段があります。それは戻り値が <code>ValueTask</code> のものを選ぶことです。</p>
<pre><code class="language-csharp">public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken)
public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
public ValueTask&lt;int&gt; SendAsync(ReadOnlyMemory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken))
</code></pre>
<p>オーバーロードにはTask返しのものもあるので、気をつけてください。</p>
<pre><code class="language-csharp">// これらのAPIは使ってはいけない
public Task ConnectAsync(string host, int port)
public Task&lt;int&gt; ReceiveAsync(ArraySegment&lt;byte&gt; buffer, SocketFlags socketFlags)
public Task&lt;int&gt; SendAsync(ArraySegment&lt;byte&gt; buffer, SocketFlags socketFlags)
</code></pre>
<p>ValueTask返しのAPIは内部的には <code>AwaitableSocketAsyncEventArgs</code> というものがValueTaskの中身になるようになっていて、これがいい感じに使いまわされる(awaitされると内部に戻るようになっている）ことで、Taskのアロケーションもなく効率的な非同期処理を実現しています。<code>SocketAsyncEventArgs</code>の使いにくさとは雲泥の差なので、これは非常にお薦めできます。</p>
<p>また、同期APIはSpanを受け取れるのですが、非同期APIは（ステートをヒープに置く都合上）Memoryしか受け取れないことには注意してください。これはSocketプログラミングに限らず非同期系APIにおける一般的な話で、全体的に上手く組んでおかないと、Spanが使えないことが障壁になることがあります。必ず、Memoryで取り回せるようにしておきましょう。</p>
<ul>
<li>テキストプロトコルのバイナリコード判定</li>
</ul>
<p><a href="https://docs.nats.io/reference/reference-protocols/nats-protocol">NATSのプロトコル</a>はテキストプロトコルになっていて、文字列処理で簡単に切り出すことができます。実際これはStreamReaderを使うことで簡単にプロトコルの実装ができます。ReadLineするだけですから。しかし、ネットワークに流れるのは(UTF8)バイナリデータであり、文字列化は無駄なオーバーヘッドとなるため、パフォーマンスを求めるなら、バイナリデータのまま処理する必要があります。</p>
<p>NATSでは先頭の文字列(<code>INFO</code>, <code>MSG</code>, <code>PING</code>, <code>+OK</code>, <code>-ERR</code>など)によって流れてくるメッセージの種類が判定できます。文字列処理で空白でSplitして if (msg == &quot;INFO&quot;) などとすればめちゃくちゃ簡単ですが、先にも言った通り文字列変換は意地でも通しません。INFOは[73, 78, 70, 79]なので、Slice(0, 4).SequenceEqual で判定するのは悪くないでしょう。<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.sequenceequal"><code>ReadOnlySpan&lt;byte&gt;</code>のSequenceEqual</a>はめちゃくちゃ最適化されていて、長いものであれば必要であればSIMDとかも使って高速に同値判定します。LINQのSequenceEqualとは別物です！</p>
<p>しかし、もっと欲張って見てみましょう、プロトコルの識別子はサーバーから送られてくるものは全て4文字以内に収まっています。つまり、これはIntに変換しやすい状態です！というわけで、AlterNatsのメッセージ種判定コードはこうなっています。</p>
<pre><code class="language-csharp">// msg = ReadOnlySpan&lt;byte&gt;
if(Unsafe.ReadUnaligned&lt;int&gt;(ref MemoryMarshal.GetReference&lt;byte&gt;(msg)) == 1330007625) // INFO
{
}
</code></pre>
<p>これ以上速い判定はできないと思うので、理論上最速ということでいいでしょう。3文字の命令も、直後に必ずスペースや改行が来るので、それを含めた以下のような定数を使って判定に回しています。</p>
<pre><code class="language-csharp">internal static class ServerOpCodes
{
    public const int Info = 1330007625;  // Encoding.ASCII.GetBytes(&quot;INFO&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Msg = 541545293;    // Encoding.ASCII.GetBytes(&quot;MSG &quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Ping = 1196312912;  // Encoding.ASCII.GetBytes(&quot;PING&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Pong = 1196314448;  // Encoding.ASCII.GetBytes(&quot;PONG&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Ok = 223039275;     // Encoding.ASCII.GetBytes(&quot;+OK\r&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Error = 1381123373; // Encoding.ASCII.GetBytes(&quot;-ERR&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
}
</code></pre>
<p>バイナリプロトコルなら特に何のひねりも必要なく実装できるので、バイナリプロトコルのほうが実装者に優しくて好きです……。</p>
<ul>
<li>自動パイプライニング</li>
</ul>
<p>NATSプロトコルの書き込み、読み込みは全てパイプライン（バッチ）化されています。これは<a href="https://redis.io/docs/manual/pipelining/">RedisのPipelining</a>の解説が分かりやすいですが、例えばメッセージを3つ送るのに、一つずつ送って、都度応答を待っていると、送受信における多数の往復がボトルネックになります。</p>
<p>メッセージの送信において、AlterNatsは自動でパイプライン化しています。<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>を用いてメッセージは一度キューに詰め込まれ、書き込み用のループが一斉に取り出してバッチ化します。ネットワーク送信が完了したら、再び送信処理待ち中に溜め込まれたメッセージを一括処理していく、という書き込みループのアプローチを取ることで、最高速の書き込み処理を実現しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/167585601-5634057e-812d-4b60-ab5b-61d9c8c37063.png" alt="image" /></p>
<p>ラウンドトリップタイムの話だけではなく（そもそもNATSの場合はPublish側とSubscribe側が独立しているので応答待ちというのもないのですが）、システムコールの連続した呼び出し回数を削減できるという点でも効果が高いです。</p>
<p>なお、.NET最高速ロガーである<a href="https://github.com/Cysharp/ZLogger/">ZLogger</a>でも同じアプローチを取っています。</p>
<ul>
<li>一つのオブジェクトに機能を盛る</li>
</ul>
<p>Channelに詰め込む都合上、データを書き込みメッセージオブジェクトに入れてヒープに保持しておく必要があります。また、書き込み完了まで待つ非同期メソッドのためのPromiseも必要です。</p>
<pre><code class="language-csharp">await connection.PublishAsync(value);
</code></pre>
<p>こうしたAPIを効率よく実装するために、どうしても確保する必要のある一つのメッセージオブジェクト（内部的にはCommandと命名されている）に、あらゆる機能を同居して詰め込みましょう。</p>
<pre><code class="language-csharp">class AsyncPublishCommand&lt;T&gt; : ICommand, IValueTaskSource, IThreadPoolWorkItem, IObjectPoolNode&lt;AsyncPublishCommand&lt;T&gt;&gt;

internal interface ICommand
{
    void Write(ProtocolWriter writer);
}

internal interface IObjectPoolNode&lt;T&gt;
{
    ref T? NextNode { get; }
}
</code></pre>
<p>このオブジェクト(<code>AsyncPublishCommand&lt;T&gt;</code>)自体は、T dataを保持して、Socketにバイナリデータとして書き込むための役割(<code>ICommand</code>)をまずは持っています。</p>
<p>それに加えて<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.sources.ivaluetasksource">IValueTaskSource</a>であることにより、このオブジェクト自身がValueTaskになります。</p>
<p>そしてawait時のコールバックとして、書き込みループを阻害しないためにThreadPoolに流す必要があります。そこで従来の<code>ThreadPool.QueueUserWorkItem(callback)</code>を使うと、内部的には <code>ThreadPoolWorkItem</code> を生成してキューに詰め込むため、余計なアロケーションがあります。 .NET Core 3.0から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.ithreadpoolworkitem">IThreadPoolWorkItem</a>を実装することで、内部の<code>ThreadPoolWorkItem</code>の生成をなくすことができます。</p>
<p>最後に、同居させることで必要なオブジェクトが1つになりましたが、その1つをプーリングしてゼロアロケーション化します。オブジェクトプールは<code>ConcurrentQueue&lt;T&gt;</code>などを使うと簡単に実装できますが、自分自身をStackのNodeにすることで、配列を確保しないで済むようにしています。また、Nodeの出し入れに関しては、今回のキャッシュの実装では正確に取り出せる必要性はないため、lockは使わず、マルチスレッドで競合が発生した場合はキャッシュミス扱いにして新規生成するようにしています。これはオブジェクトプーリングにおける性能バランスとしては、良いチョイスだと考えています。</p>
<pre><code class="language-csharp">internal sealed class ObjectPool&lt;T&gt;
    where T : class, IObjectPoolNode&lt;T&gt;
{
    int gate;
    int size;
    T? root;
    readonly int limit;

    public ObjectPool(int limit)
    {
        this.limit = limit;
    }

    public int Size =&gt; size;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPop([NotNullWhen(true)] out T? result)
    {
        // Instead of lock, use CompareExchange gate.
        // In a worst case, missed cached object(create new one) but it's not a big deal.
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            var v = root;
            if (!(v is null))
            {
                ref var nextNode = ref v.NextNode;
                root = nextNode;
                nextNode = null;
                size--;
                result = v;
                Volatile.Write(ref gate, 0);
                return true;
            }

            Volatile.Write(ref gate, 0);
        }
        result = default;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPush(T item)
    {
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            if (size &lt; limit)
            {
                item.NextNode = root;
                root = item;
                size++;
                Volatile.Write(ref gate, 0);
                return true;
            }
            else
            {
                Volatile.Write(ref gate, 0);
            }
        }
        return false;
    }
}
</code></pre>
<ul>
<li>Zero-copy Architecture</li>
</ul>
<p>Publish/Subscribeするデータは通常、C#の型をJSONやMessagePackなどにシリアライズしたものを流します。この場合、どうしてもbyte[]でやり取りすることが多くなります、例えばStackExchange.Redisの<code>RedisValue</code>の中身は実質byte[]で、送信にせよ受信にせよ、byte[]を生成して保持することになります。</p>
<p>これを避けるために、ArrayPoolから出し入れしてごまかしてゼロアロケーションにする、みたいなのはありがちではありますが、それでもコピーのコストが発生していることには代わりありません。ゼロアロケーションは当然目指すところですが、ゼロコピーに向けても頑張りましょう！</p>
<p>AlterNatsのシリアライザーはWriteに<code>IBufferWriter&lt;byte&gt;</code>, Readに<code>ReadOnlySequence&lt;byte&gt;</code>を要求します。</p>
<pre><code class="language-csharp">public interface INatsSerializer
{
    int Serialize&lt;T&gt;(ICountableBufferWriter bufferWriter, T? value);
    T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer);
}

public interface ICountableBufferWriter : IBufferWriter&lt;byte&gt;
{
    int WrittenCount { get; }
}
</code></pre>
<pre><code class="language-csharp">// 例えばMessagePack for C#を使う場合の実装
public class MessagePackNatsSerializer : INatsSerializer
{
    public int Serialize&lt;T&gt;(ICountableBufferWriter bufferWriter, T? value)
    {
        var before = bufferWriter.WrittenCount;
        MessagePackSerializer.Serialize(bufferWriter, value);
        return bufferWriter.WrittenCount - before;
    }

    public T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer)
    {
        return MessagePackSerializer.Deserialize&lt;T&gt;(buffer);
    }
}
</code></pre>
<p>System.Text.JsonやMessagePack for C#のSerializeメソッドには<code>IBufferWriter&lt;byte&gt;</code>を受け取るオーバーロードが用意されています。<code>IBufferWriter&lt;byte&gt;</code>経由でSocketに書き込むために用意しているバッファーにシリアライザが直接アクセスし、書き込みすることで、Socketとシリアライザ間でのbyte[]のコピーをなくします。</p>
<p><img src="https://user-images.githubusercontent.com/46207/167587816-c50b0af3-edaa-4a2a-b536-67aed0a5f908.png" alt="image" /></p>
<p>Read側では、<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.readonlysequence-1"><code>ReadOnlySequence&lt;byte&gt;</code></a>を要求します。Socketからのデータの受信は断片的な場合も多く、それをバッファのコピーと拡大ではなく、連続した複数のバッファを一塊として扱うことでゼロコピーで処理するために用意されたクラスが<code>ReadOnlySequence&lt;T&gt;</code>です。</p>
<p>「ハイパフォーマンスの I/O をより簡単に行えるように設計されたライブラリ」である<a href="https://docs.microsoft.com/ja-jp/dotnet/standard/io/pipelines">System.IO.Pipelines</a>の<code>PipeReader</code>で読み取ったものを扱うのが、よくあるパターンとなります。ただし、AlterNatsではPipelinesは使わずに独自の読み取り機構と<code>ReadOnlySequence&lt;byte&gt;</code>を使用しました。</p>
<p>System.Text.JsonやMessagePack for C#のSerializeメソッドには<code>IBufferWriter&lt;byte&gt;</code>を受け取るオーバーロードが用意されているため、それを直接渡すことができます。つまり、現代的なシリアライザは<code>IBufferWriter&lt;byte&gt;</code>と<code>ReadOnlySequence&lt;byte&gt;</code>のサポートは必須です。これらをサポートしていないシリアライザはそれだけで失格です。</p>
<h2>まとめ</h2>
<p>プロトコルが単純で少ないのでちゃちゃっと作れると思いきや、まあ確かに雑にTcpClientとStreamReader/Writerでやれば秒殺だったのですが、プロトコルって量産部分でしかないので、そこがどんだけ量少なかろうと、基盤の作り込みは相応に必要で、普通に割と時間かかってしまった、のですが結構良い感じに作れたと思います。コード的にも例によって色々な工夫が盛り込まれていますので、是非ソースコードも読んでみてください。</p>
<p>クライアント側の実装によってパフォーマンスが大きく違うというのはシリアライザでもよくあり経験したことですが、NATSのパフォーマンスを論じるにあたって、その言語のクライアントは大丈夫ですか？というところがあり、そして、C#は大丈夫ですよ、と言えるものになっていると思います。</p>
<p>NATSの活用に関してはこれからやっていくので実例あるんですか？とか言われると知らんがな、というところですが（ところでMagicOnionはこないだの<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズ</a>だけではなく最近特によくあるので、実例めっちゃあります）、これから色々使っていこうかなと思っているので、まぁ是非AlterNatsと共に試してみてください。</p>
</div>
<h1><a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a></h1>
<ul class="date"><li>2022-04-08</li></ul>
<div class="entry_body"><p>Cygamesから4/1にリリースされた<a href="https://priconne-grandmasters.jp/">プリコネ！グランドマスターズ</a>のサーバーサイドとインフラ開発をCysharpが開発協力しました。リアルタイム通信を含むオートバトラー系のゲームです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/162343388-734840a1-4b7d-467b-902c-1e06e527d208.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/162401207-d9e2bceb-6b94-435c-8e63-d96ce62cf97b.png" alt="image" /></p>
<p>Cysharpはサーバー側のアーキテクチャ設計と基盤実装、クラウドインフラ構築、一部サーバーロジック実装を担いました。リアルタイム通信部分だけではなくてAPIサーバーからマッチメイキング、インフラまで、構成されるあらゆる要素がC#で作られています！</p>
<ul>
<li>クライアント (Unity)</li>
<li>API サーバー(MagicOnion)</li>
<li>バトルエンジンサーバー (リアルタイム通信; MagicOnion, LogicLooper)</li>
<li>マッチメイキングサーバー (リアルタイム通信; MagicOnion)</li>
<li>バッチ(ConsoleAppFramework)</li>
<li>デバッグ機能サーバー (Web; Blazor)</li>
<li>管理画面サーバー (Web; Blazor)</li>
<li>インフラ (Infrastructure as Code; <a href="https://www.pulumi.com/">Pulumi + C#</a>)</li>
</ul>
<p>サーバー側アプリケーションは.NET 6をKubernetes上で動かしています。Unityクライアント側でも<a href="https://github.com/Cysharp/">CysharpのOSS</a>は7つクレジットされていますが、表記のないサーバー側専用のものを合わせたら10個以上使用しています。ここまで徹頭徹尾C#でやっているプロジェクトは世界的にも珍しいんじゃないでしょうか。中心的に活躍しているのは<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>ですが、サーバーサイドゲームループのための<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>、負荷テストのための<a href="https://github.com/Cysharp/DFrame/">DFrame</a>なども実戦投入されて、成果を出しました。サーバートラブルも特になく、しっかり安定稼働しました。という事後報告です。そして今日、もとより期間限定公開ということで一週間の配信期間が終了しました。</p>
<p>アーキテクチャ含めの詳しい話は後日どこかでできるといいですね……！今回、私は実装者としては裏方というか監督というかという感じなので、発表する際は別の人にお任せします……！</p>
<p>C#でのサーバー構成をまた一つ実証できて、参考になって欲しいのですが（そしてC#採用事例増えて欲しい！）、こういった構成を、Cysharpだから出来る、のではなくて、誰もが実現できる環境にしていきたいとも思っています。重要なパーツは積極的にOSS化していますし、実績も着実に積み重ねられています。が、しかしまだまだ難しい面も数多くあるということは認識しています。かといってmBaaSの方向でやっていくべき、とは思わないんですね。ロジックはゲームの差別化のための重要な要素であり、サーバーサイドでも書くべきで。だから注力しているのは書きやすくするための環境で、そのために足りないものを提供していっています。</p>
<p>ところでサーバーとクライアントの繋ぎ、あるいはサーバーとサーバーの繋ぎが、MagicOnionだけだと複雑で難しくなってしまうところがあるな、と思っていまして、ちょうど先月-今月はメッセージングライブラリの開発に注力しています。<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>という名前でPreview公開していますが、これを挟むと色々改善されるんじゃないかなあ、と思っているので、少々お待ち下さい。そんな感じに、常により最善のC#アーキテクチャの探究と、OSSを通じた共有をまだまだ続けていきます。</p>
</div>
<h1><a href="https://neue.cc/2022/02/28_DFrame.html">DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</a></h1>
<ul class="date"><li>2022-02-28</li></ul>
<div class="entry_body"><p>と、いうものをリリースしました。Web UIとなるDFrame.Controllerと、負荷テストシナリオをC#で書くDFrame.Workerの組み合わせで成り立っていて、DFrame.Workerをウェブ上のクラスターに配置することで(Controllerと接続するただの常駐アプリなので、配置先はオンプレでもVMでもコンテナでもKuberenetesでもなんでもいい)、1から数千のワーカーが連動して、大量のリクエストを発生させます。また、テストシナリオをプレーンなC#で記述できるということは、HTTP/1だけではなく、あらゆる種類の通信をカバーできます。WebSocket、HTTP/2、gRPC、MagicOnion、あるいはPhotonや自作のTCPトランスポート、更にはRedisやデータベースなどが対象になります。</p>
<p>DFrame.Workerは通常の.NETの他に、Unityにも対応しています！つまり、大量のHeadless Unity、あるいはデバイスファームに配置することで、Unityでしか動かないような独自通信フレームワークであっても負荷テストをかけることが可能です。</p>
<p>また、あまり注目されていませんが負荷テストツールにもパフォーマンスの違いは「かなり」あり、性能の良さは重要で、そこのところにもかなりチューニングしました。</p>
<ul>
<li><a href="https://github.com/Cysharp/DFrame/">github - Cysharp/DFrame</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/46207/155904375-084a199b-a473-4bc6-8362-009d214bd009.png" alt="image" /></p>
<p>Web UI(DFrame.Controller)はBlazor Serverで作られていて、分散ワーカーとの通信はMagicOnionで行っています。自動化のためのWeb APIの口もあるため、Blazor Server, ASP.NET Minimum API, MagicOnionのキメラ同居なアーキテクチャでC#でフル活用なのが設計的にも面白いポイントです。</p>
<h2>C#で負荷テストシナリオを書く意義</h2>
<p>負荷テストフレームワークは世の中に山のようにあります。代表的なものでも<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">ab</a>, <a href="https://jmeter.apache.org/">jMeter</a>, <a href="https://k6.io/">k6</a>, <a href="https://www.artillery.io/">Artillery</a>, <a href="https://gatling.io/">Gatling</a>, <a href="https://github.com/wg/wrk">wrk</a>, <a href="https://github.com/codesenberg/bombardier">bombardier</a>, <a href="https://locust.io/">Locust</a>、k6やArtillery、GatlingなどはSaaSとしても提供していますし、クラウドサービス側も、<a href="https://azure.microsoft.com/ja-jp/services/load-testing/">Azure Load Testing(Managed jMeter)</a>のようなマネージドサービスを出していますし、.NETでも<a href="https://github.com/dotnet/crank">dotnet/crank</a>というものが存在していたりします。</p>
<p>DFrameはこの中でいうとアーキテクチャ含めLocustに近い(Controller-Worker構成やWebUIなど)のですが、その特徴の中で重要な点として挙げられているのが、シナリオをコードで書けること、です。よくわからんUIで設定させたり、複雑怪奇なXMLやYAMLやJSON書かせたりせず、プレーンなコードで書ける。これが大事。LocustはPythonですが、他にk6はJavaScriptで書けるようになっています。</p>
<p>じゃあLocustでいいじゃん、k6でいいじゃん、という話になるのですが、C#で書きたいんですね、シナリオを。これは別にただ単に自分の好きな言語で書きたいからというわけではなくて、サーバーあるいはクライアント言語と負荷試験シナリオ作成言語は同一のものであるべきだからです。例えばUnityのゲームを開発している場合（サーバーサイドの言語は何でもいい）、UnityのゲームはC#で記述されていますが、その場合C#でテストシナリオが書けるのなら</p>
<ul>
<li>最初からクライアントSDK(エンドポイントと型付きのRequest/Response)に相当するものがある</li>
<li>クライアントの実装と完全に等しいのでゲームのドメインロジックが最初からある</li>
</ul>
<p>となります。それによりテストシナリオの記述の手間を大幅に削減できます。もちろん、Unity依存の部分を引き剥がすなどの追加の作業は必要ですが、完全に書き起こすなどといった無駄は発生しません。もしPythonでもJavaScriptでもLuaでも、とにかく異なる言語である場合は、比較にならないほどに作業量が膨大になってきます。</p>
<p>そして実際のクライアントコードとある程度共通になることで、サーバー/クライアント側の変化への追随が用意になります。それにより一回のリリースのための負荷テストではなく、継続的な負荷テスト環境を作っていけます。</p>
<p>また、プレーンなC#で記述できることで、冒頭にも書きましたがあらゆる通信の種類をカバーできるのは、通信プロトコルが多様化している昨今、大きな利点となります。</p>
<h2>DFrameApp.Run</h2>
<p>NuGetからDFrameをパッケージ参照したうえで、一行で起動します。テストシナリオ(Workload)の記述の行数もありますが、それでもこれだけで。</p>
<pre><code class="language-csharp">using DFrame;

DFrameApp.Run(7312, 7313); // WebUI:7312, WorkerListen:7313

public class SampleWorkload : Workload
{
    public override async Task ExecuteAsync(WorkloadContext context)
    {
        Console.WriteLine($&quot;Hello {context.WorkloadId}&quot;);
    }
}
</code></pre>
<p>これで <code>http://localhost:7312</code> をブラウザで開けば、<code>SampleWorkload</code>がいます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155892546-c00f1554-0e2c-4e11-acdd-f0d9be9c40c9.png" alt="image" /></p>
<p>と、いうわけで、WorkloadのExecuteAsyncにコードを書くのが基本です。ExecuteAsync前の準備用としてSetupAsync、後始末としてTeardownAsyncもあります。単純なgRPCのテストを書くとこなります。</p>
<pre><code class="language-csharp">public class GrpcTest : Workload
{
    GrpcChannel? channel;
    Greeter.GreeterClient? client;

    public override async Task SetupAsync(WorkloadContext context)
    {
        channel = GrpcChannel.ForAddress(&quot;http://localhost:5027&quot;);
        client = new Greeter.GreeterClient(channel);
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await client!.SayHelloAsync(new HelloRequest(), cancellationToken: context.CancellationToken);
    }

    public override async Task TeardownAsync(WorkloadContext context)
    {
        if (channel != null)
        {
            await channel.ShutdownAsync();
            channel.Dispose();
        }
    }
}
</code></pre>
<p>Concurrencyの数だけWorkloadが生成されて、Total Request / Workers / Concurrencyの数だけExecuteAsyncが実行されます。コードで書くと言っても別にそう複雑なこともなく、よくわからんDSLで書くわけでもないので、むしろ(C#が書けるなら)とても書きやすいでしょう。中身も見てのとおり単純なので、gRPCでもMagicOnionでも何でも実行できます。</p>
<p>引数を受け取ることも可能なので、任意のURLを渡すようなものも作れます。コンストラクタでは、パラメーター、あるいはDIでインジェクトしたインスタンスを受け取れます。</p>
<pre><code class="language-csharp">using DFrame;
using Microsoft.Extensions.DependencyInjection;

// use builder can configure services, logging, configuration, etc.
var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureServices(services =&gt;
{
    services.AddSingleton&lt;HttpClient&gt;();
});
await builder.RunAsync();

public class HttpGetString : Workload
{
    readonly HttpClient httpClient;
    readonly string url;

    // HttpClient is from DI, URL is passed from Web UI
    public HttpGetString(HttpClient httpClient, string url)
    {
        this.httpClient = httpClient;
        this.url = url;
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await httpClient.GetStringAsync(url, context.CancellationToken);
    }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/155893829-fc9f5e9d-fb05-4bcc-b8ee-6067be674b51.png" alt="image" /></p>
<p>WebUI画面にString urlの入力箇所が現れて、好きなURLを叩き込むことができるようになりました。</p>
<p>なお、単純なHTTPのGET/POST/PUT/DELETEをテストしたいという場合は、IncludesDefaultHttpWorkloadを有効にしてもらうと、内蔵のパラメーターを受け取るWorkloadが追加されます。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureWorker(x =&gt;
{
    x.IncludesDefaultHttpWorkload = true;
});
builder.Run();
</code></pre>
<h2>分散テスト</h2>
<p>Workerは起動時に指定したControllerのアドレスにHTTP/2(MagicOnion/gRPC)で繋ぎに行って、常駐します。という普通の（？）アプリケーションなので、ウェブサーバーを分散させるのと同様に複数のWorkerを立ち上げてもらえれば、自動的に繋がります。</p>
<p>構成としては、以下の画像のようにControllerとWorkerのプロジェクトを分けるのが正当派（？）ですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/154921606-b9955331-1d15-4c4f-a769-faeb61b13872.png" alt="" /></p>
<p>同居させてしまって、起動時のコマンドライン引数でどちらかのモード（あるいは両方）が起動するようにすることも、ローカルでの開発がしやすくなるのでお薦めです。 <code>DFrameApp.CreateBuilder</code> にはそのための補助的な機構が用意されています。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(5555, 5556); // portWeb, portListenWorker

if (args.Length == 0)
{
    // local, run both(host WebUI on http://localhost:portWeb)
    await builder.RunAsync();
}
else if (args[0] == &quot;controller&quot;)
{
    // listen http://*:portWeb as WebUI and http://*:portListenWorker as Worker listen gRPC
    await builder.RunControllerAsync();
}
else if (args[0] == &quot;worker&quot;)
{
    // worker connect to (controller) address.
    // You can also configure from appsettings.json via builder.ConfigureWorker((ctx, options) =&gt; { options.ControllerAddress = &quot;&quot; });
    await builder.RunWorkerAsync(&quot;http://foobar:5556&quot;);
}
</code></pre>
<p>ローカルでWorkerの.exeを複数実行する、とかでも手元でとりあえずのWorker connectionsが増える様は確認できます。</p>
<p>Workerを増やすと表がにぎやかになって楽しい。実行するWorkerの数はスライダーで調整できるので、各種パラメーターを台数1で調整したあとに、徐々に実行Workerを増やしていく、といった使い方も可能です。また、その辺を自動でやってくれるRepeatモード(TotalRequestとWorkerを完了後に指定数増やして繰り返す)も用意しました。jMeterでいうところのRamp-Upの代わりに使えればいいかな、という想定でもあります。</p>
<p>アーキテクチャ的に最初から分散前提で作られているというのもあり、増やしても性能が劣化しない、リニアに性能が向上していくように作りました。Controllerは単一なのでスケールしないのですが、なるべく多くのWorkerをぶら下げられるように工夫しています。Controller &lt;-&gt; WorkerはMagicOnionで通信しているので、DFrame自身がMagicOnionの負荷テストになっているのです。</p>
<h2>パフォーマンス</h2>
<p>多数ある負荷テストフレームワークですが、パフォーマンスはそれぞれかなり異なります。詳しくはk6のブログ<a href="https://k6.io/blog/comparing-best-open-source-load-testing-tools/">Open source load testing tool review 2020</a>に非常に詳細に書かれていますが、例えばとにかくwrkがぶっちぎって他の数十倍~数百倍速かったりする、と。パフォーマンスは当然ながらとても重要で、ワーガーの非力さでターゲットに負荷をかけきれなかったりします。それに対応するためクラスターを組んでいくにしても、多くの台数やより高いスペックのマシンが必要になって、色々と辛い。</p>
<p>というわけでパフォーマンスは高ければ高いほうがいいのですが、先のブログに書かれている通り、拡張性の口やレポート取り出しの口などは必要です。その点でWrkは機能を満たさないということで、ブログではなんか結果から取り除かれてますね（その対応がいいのかどうかはなんとも言えませんが、まぁk6自身のアピールのためでもあるのでしょうがないね）。ちなみにフレームワークのパフォーマンスの指標として使われている<a href="https://www.techempower.com/benchmarks/">TechEmpower Web Framework Benchmarks</a>の負荷クライアントはwrkのようです。</p>
<p>さて、で、DFrameはどうかというと、かなり良好です。というのも、DFrameはライブラリとして提供されて、実行時は全てがC#の実行ファイルとしてコンパイル済みの状態になるのですね。スクリプトを動的に読んで実行するから遅くなってしまう、みたいなことがない。比較的高速な言語であるC#をそのまま利用するので、その時点である程度はいける。理論上。理屈上。</p>
<p>と、いう甘い見込みのもと実際作っていくと、さすがにそこまでさっくりとはいかず、相応にチューニングが必要だったのですが、最終的にはかなりの数字が出るようになりました。比較としてabとk6で測ってみると</p>
<p><img src="https://user-images.githubusercontent.com/46207/155854372-6cd3976c-fb08-4ddb-b4a8-75235421cfc8.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854390-a2360f29-956f-4ace-a848-ecc03c79cb21.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854413-969e59c2-a914-4131-b3d7-f1f50591413b.png" alt="image" /></p>
<p>本来はターゲットとワーカーは別マシンにしないといけないのですが(ワーカーの負荷でCPUが跳ね上がる影響をサーバー側がモロに影響受けてしまうので)、それでもそれなりに数字は変動しますし動きはするしマシンパワーも結構強め(Ryzen 9 5950x)なので、ちょっと手抜きでlocalhost上の無を返すHTTP/1サーバーをターゲットに、32並列(-c 32, -32VUs, Concurrency=32)で実行。</p>
<p>abが、6287 req/sec、k6が125619 req/sec、DFrameが207634 req/secです。abは、厳しい、厳しい……。もっと出るはずと思っているんですが、私の環境(Windows)だと昔からこんな感じなので、性能的には信用できないかなぁ。Windowsだとダメだったりするのかもしないのかもしれませんね。DFrameの場合Concurrencyにまだ余裕があって、増やすとまだまだ伸びたのですが、k6は割と頭打ちでした。</p>
<p>また、画像は出してませんがLocustは残念ながらかなり遅い上にCPUを食いまくるという感じで(Pythonだしね……）、いくらクラスタ化が容易とはいえ、ここまで1ワーカーあたりの性能が低いと、ないかなあ、という感想です。JMeterはそこまで悪くはないですが、パフォーマンスに影響を与える地雷コンフィグを必死にかいくぐってなおそこそこ程度なのはしんどみ。</p>
<p>ちなみになんで圧倒的性能番長であるwrkと比較しないのかというと、Windowsで動かすのが大変だからです。すみません……。</p>
<h2>自動化のためのREST API</h2>
<p>最初はいいけど、毎回GUIでポチポチやるの面倒で、それはそれで嫌だよね。CIで定期的に回したりもできないし。というわけで、バッチ起動モード、はついていないのですが、代わりにREST APIが自動で有効になっています。例えば <code>/api/connections</code> で現在接続中のワーカーコネクション数が取れます。実行パラメーターなどはPostでJSONを投げる形になっています。</p>
<p>REST APIでJSONをやり取りするだけなので、どの言語から叩くことも可能ですが、C#の場合は <code>DFrame.RestSdk</code> パッケージにて型付けされたクライアントが用意されているので、手間なくはじめられます。</p>
<pre><code class="language-csharp">using DFrame.RestSdk;

var client = new DFrameClient(&quot;http://localhost:7312/&quot;);

// start request
await client.ExecuteRequestAsync(new()
{
    Workload = &quot;SampleWorkload&quot;,
    Concurrency = 10,
    TotalRequest = 100000
});

// loadtest is running, wait complete.
await client.WaitUntilCanExecute();

// get summary and results[]
var result = await client.GetLatestResultAsync();
</code></pre>
<p>実行状況は全て連動しているので、REST APIから実行した進捗もWeb UI側でリアルタイムに状況確認できます。</p>
<h2>Unityでも動く</h2>
<p>Unityで動かしやすいかといったら全然そんなことないので、動かせるようにするのはもはや執念という感じではあるのですが、Unity対応しました。冒頭で書いたようにヘッドレスUnityを並べてコントロールする、みたいな用途は考えられます。まぁ、あと普通の負荷テストでも、通信部分のC#を普通の .NET に切り出すのが面倒だという場合に、ヘッドレスUnityでとりあえずビルドすることで何もしなくてもOK（そうか？）という策もあります。</p>
<p>Unityで動かす場合は、依存の解決(MagicOnion、gRPC、MessagePack for C#)が大変です！まぁ、それは置いておいて。それが出来ているなら、以下のようなMonoBehaviourに寿命をくっつけたインスタンスで起動させると良い感じです（MagicOnionというかネイティブgRPCは適切にコネクションをCloseしないとUnity Editorがフリーズするという酷い問題があるのですが、このコードは問題なくちゃんとクリーンアップしてくれるようになっています）。</p>
<pre><code class="language-csharp">public class DFrameWorker : MonoBehaviour
{
    DFrameWorkerApp app;

    [RuntimeInitializeOnLoadMethod]
    static void Init()
    {
        new GameObject(&quot;DFrame Worker&quot;, typeof(SampleOne));
    }

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }

    async void Start()
    {
        // setup your controller address
        app = new DFrameWorkerApp(&quot;localhost:7313&quot;);
        await app.RunAsync();
    }

    private void OnDestroy()
    {
        app.Dispose();
    }
}

[Preserve]
public class SampleWorkload : Workload
{
    public override Task ExecuteAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Exec&quot;);
        return Task.CompletedTask;
    }

    public override Task TeardownAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Teardown&quot;);
        return Task.CompletedTask;
    }
}

// Preserve for Unity IL2CPP

internal class PreserveAttribute : System.Attribute
{
}
</code></pre>
<p>Editor上の確認だとこんな具合です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155901725-4ce8a36f-46e9-4437-aba7-639425f4b93f.png" alt="image" /></p>
<h2>ライブラリかツールか</h2>
<p>DFrame.Controller、他の設定を入れなければただのウェブアプリなので、ビルド済みのexeとしての提供も可能です。Locustなど他のツールも入れたら、とりあえず実行できる、のに比べると、必ず自分で組み込んでビルドしなきゃいけない。のは欠点に見える。</p>
<p>なのでビルド済みコンテナをDocker Hubかなんかで提供するという案もあったのですが、Workerはどうしても自分で組み込んでビルドする必要があるので、そこだけ省けても利点あるのかな？と考えて、最終的に却下しました。かわりに <code>DFrameApp.Run</code> の一行だけでController+Workerの同居が起動できるようにして、最初の一歩の面倒臭さをライブラリデザインの工夫で乗り切ることにしました。Controller自体も、<code>Microsoft.NET.Sdk.Web</code>ではなく、コンソールアプリケーションのテンプレートの<code>Microsoft.NET.Sdk</code>から起動できるようにしました。</p>
<p>DFrame.Controllerがライブラリとして提供されていることのメリットは、コンフィグが通常のコードやASP.NETの仕組みに乗っかったほうが圧倒的にシンプルになります。DIで好きなロガーを設定して、URLの指定やSSLなどもappsettings.jsonで行うのは、大量の複雑怪奇なコマンドラインオプションよりもずっと良いでしょう。</p>
<p>ログの永続化処理も、プラグイン的に用意するのではなく、普通にDIでインジェクトしてもらう(<code>IExecutionResultHistoryProvider</code>というものが用意されていて、これを実装したものをDIに登録してもらえば、結果をデータベースに入れたり時系列DBに入れたりして統計的な参照ができるようになります)ほうが、使いやすいはずです。</p>
<h2>Blazor Server + MagicOnion</h2>
<p>DFrame.ControllerはBlazor ServerとMagicOnion(grpc-dotnet)が同居した構成になっています。これは中々面白い構成で、Web UIとMagicOnion(Server側)が同じメモリを共有しているので、末端のMagicOnion(Client側)の変更をダイレクトにC#だけを通してブラウザにまで届けているんですね。逆もしかりで、APIからのアクセス含めて、全てがリアルタイムに伝搬して画面も同期しているのですが、普通にやるとかなり複雑怪奇になるはずが、かなりシンプルに実装できています。</p>
<p>と、いうわけで、Cysharpではこの組み合わせに可能性を感じていて、別のサービスも同種のアーキテクチャで絶賛制作中なので興味ありましたら以下略。</p>
<h2>紆余曲折</h2>
<p>最初のバージョンは2年ぐらい前に作っていました。コンセプトは「自己分裂する分散バッチフレームワーク」ということで、自分自身のコピーを動的に作って無限大に分散して実行していくというもので。分散のための基盤としてKubernetesを使って。クラウドネイティブ！かっこいい！そして、一応動くものはできていました。あとは仕上げていくだけ、といったところで、放置していました。完成させなきゃ、と思いつつ、内心薄々あんまいい感じではないな、と思っていたため手が進まず無限放置モードへ。そして時が流れ、社内でもがっつり使うことになり引っ張り出されてきたそれは、やはりあまりいい感じではなく。で、最終的に言われたんですね、そもそも分裂機能いらなくね？と。</p>
<p>それでようやく気づくわけです、コンセプトから完全に間違っているからうまくいくわけがない！</p>
<p>反省として良くなかった理由としては、まず、現代のクラウドコンピューターを過大に評価していた。「自己分裂する」のは、一瞬で無限大にスケールして即起動、そして終わったら即終了、ならば、まぁそれでいいんですが、現実のスケールする時間はそんなに立派じゃない。サーバーレスといいつつ、別に1リクエスト毎にコンテナが起動して処理するわけはなく、常駐してリクエストを待つ。そりゃそうだ、と。自己分裂のコンセプトだと、分裂コストが重たいのは否めない。</p>
<p>もう一つは分裂するためのコードがDFrame内に記述されている。Kuberentesをコントロールするコードがたっぷり入ってしまって。そのせいでコードサイズが膨らんでしまったし、使う方も複雑なコンフィグをDFrame側に埋めなきゃいけなくなってしまった。これは二重にイケてない。作るのも複雑で、使うのも複雑ですからね、いいところがない……。</p>
<p>と、いうわけで、最初のかっこいいコンセプトを否定して、自己分裂しない。単純に繋ぎに行くだけ。としたことで、頭を抱えてうまくいかないと感じていた行き詰まりは解消したのでした。</p>
<h2>まとめ</h2>
<p>もう少し早くに作って提供したかった、という後悔がめっちゃあるのですが、同時に .NET 6だから出来たという要素もめっちゃあるので(パラメーター渡しの仕組みなどは<a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4</a>の設計の経験からスムーズに実装できた)、しょーがない。という気もする。Blazor Serverなどの進化も必要だったし。</p>
<p>しかし↑で書いたとおり最初に立てたコンセプトが間違っていて、長いこと軌道修正できず放置してしまっていたというのは個人的には割と手痛い経験です……。まぁ、間違ったコンセプトのまま進行してしまうというのは別によくあるので、それはしょーがないものとして別にいいんですが、自力で気づいてパーッと作り上げられてたらなあ、みたいな、みたいな。。。</p>
<p>ともあれ、完成したものとしてはかなり良い感じで（私の出すものとしては珍しくUIもちゃんとついているし！←UI作業は他の人に助力を請うてます）、ちょっとニッチ感もありますがC#アプリケーション開発の必需品として成り得る出来だと思っていますので、ぜひぜひお試しください。</p>
</div>
<a href="https://neue.cc/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
