<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
<meta property="og:url" content="https://neue.cc" />
<meta property="og:type" content="website" />
<meta property="og:title" content="neue cc" />
<meta property="og:description" content="..." />

 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2022/12/16_IncrementalSourceGenerator.html">2022年のC# (Incremental) Source Generator開発手法</a></h1>
<ul class="date"><li>2022-12-16</li></ul>
<div class="entry_body"><p>このブログでもSource GeneratorやAnalyzerの開発手法に関しては定期的に触れてきていて、新しめだと</p>
<ul>
<li><a href="https://neue.cc/2020/12/15_597.html">2020/12/15 - UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips</a></li>
<li><a href="https://neue.cc/2021/05/08_600.html">2021/05/07 - 2021年のC# Roslyn Analyzerの開発手法、或いはUnityでの利用法</a></li>
</ul>
<p>という記事を出していますが、今回 <a href="https://github.com/Cysharp/MemoryPack/">MemoryPack</a> の実装で比較的大規模にSource Generatorを使ってみたことで、より実践的なノウハウが手に入りました。また、開発環境も年々良くなっていることや、Unityのサポート状況も強化されているので、状況を一通りまとめてみようと思いました。Source Generatorは非常に強力で、今後必須の開発技法になるので（少なくとも私はもうIL書きません！）是非、この機会に手を出して頂ければです。</p>
<h2>Microsoft.CodeAnalysis.CSharpのバージョン問題</h2>
<p>Source Generatorを作成するには <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp/">Microsoft.CodeAnalysis.CSharp</a>を参照したライブラリを作ればいい、のですが、ここで大事なのはバージョンです。何も考えずに最新を入れると動かないという罠が待ってます。Source Generatorは、インストールされている .NET のバージョンや IDEのコンパイラバージョンと深く紐づいています。.NETのバージョンだけ上げてもダメで、特にVisual Studioの場合は.NETのバージョンと独立して、同梱されているコンパイラのバージョンがあり、それと合わせる必要があります。Unityの場合も同じく、Unityに含まれるC#コンパイラのバージョン(/Editor/Data/DotNetSdkRoslyn/Microsoft.CodeAnalysis.CSharp.dll)を精査する必要があります。使わているバージョンよりも高いバージョンのものを参照すると、動かないという理屈です。</p>
<p>Visual Studioのバージョンとの紐づきは <a href="https://learn.microsoft.com/ja-jp/visualstudio/extensibility/roslyn-version-support">.NET コンパイラ プラットフォーム パッケージ バージョン リファレンス</a>を見れば分かりますが、現状の私のオススメは <code>4.3.1</code> です（現時点での最新は <code>4.4.0</code> ）。これは最小サポートバージョンがVisual Studio 2022 Version 17.3ということで、VS2019は切り捨てでいいでしょう。VS2022使ってるなら、とりあえずそこまでアップデートしてくれ、ということで。古ければ古いほどカバーできる範囲が広がっていい！ようでいて、古ければ古いほど、新しい言語機能の解析ができないなどの問題があるので、お薦めはできません、むしろ何も問題がなければ新しければ新しいほどいいぐらいです。4.3.1がおすすめな最大の理由としては、<code>SyntaxValueProvider.ForAttributeWithMetadataName</code> という、後で説明しますが、Source Generator作成の際に必須とも言える便利メソッドが追加されていることです。<code>4.4.0</code> だとC# 11解析サポートが追加されている、はずなのですが公式ドキュメントのほうにVisual Studioとの対応関係がまだ追加されていないというのもあり手を出しにくい……。</p>
<p>Unityの場合は公式にC#コンパイラのバージョンが何であるかのリストはないので、自分で調べていく必要がありますが、とりあえず<a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Roslyn analyzers and source generators</a>という公式ドキュメントによると「must use Microsoft.CodeAnalysis 3.8」、というわけで3.8じゃないと動かないぞ、と脅しをかけてきてます。が、実際は現状のLTS環境では3.9が搭載されているようなので、3.9を使ったほうがいいでしょう。例えばUnity 2021.3は3.9が入っていて、実際ちゃんと3.9でも動きますし、APIが3.8と3.9でかなり変わっているので、3.9で作ったほうが楽です。ドキュメントは更新が遅れて最新の話が反映されていない場合が往々にあるので、正しい現状把握は重要ですね。</p>
<p>Microsoft.CodeAnalysis.CSharpのバージョンは大きく分けて 3.* と 4.* があり、3.* はv1の <code>ISourceGenerator</code>、4.* はv2である <code>IIncrementalGenerator</code> が使えます。</p>
<p><a href="https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md">Incremental Generators</a>は、性能面で大きく改善されている他、作りやすさも大きく上がっているため、現状は Incremental Generators で作ることを最優先で考えたほうがいいでしょう。登場の黎明期では、IDEのバージョン問題があったために、3.* と 4.* の両方のSource Generatorを作って一緒にNuGetパッケージングする、という（かなりややこしい）手法が取られたこともありましたが、もう .NET 7も登場した2022年、も終わろうとしている現在ですので、 3.* は切り捨ててしまってもいいと考えています。</p>
<p>ただしUnityは除く。調べたところUnityでは Unity 2022.2, Unity 2023.1 から、4.1.0のコンパイラが搭載されているようなので、そこを最小ターゲットにすればIncremental Generatorを動かすこともできなくはないのですが、さすがに攻めすぎなので、Unityをターゲットにする場合のみ 3.* で生成したものを配布する、といった形がいいのではないかと思っています。 3.* と 4.* 版の両方を作るという手間はありますが、NuGetパッケージングのややこしさには手を出さなくてもいい。ぐらいが現状の落としどころじゃないでしょうか。</p>
<h2>最小プロジェクトとデバッグ実行</h2>
<p>Source Generator開発は、デバッグ環境をきっちり構築できていないとかなり大変です。なので環境構築をしっかりやってから挑みましょう。ここではWindowsのVisual Studio 2022を使った場合の説明のみしますが、他の環境でも、同等のことができるようにしておかないとめちゃくちゃ大変です。</p>
<p>まず「.NET Compiler Platform SDK」を入れましょう。標準では入ってないので。入れておかなくても開発はできるのですが、デバッグ起動ができなくなるため、ほぼ必須と思ってください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/207808216-9b65a422-5cd5-4a74-99a8-8635c65437c6.png" alt="image" /></p>
<p>次に、「netstandard2.0」のクラスライブラリプロジェクトを作成します。え、2022年にもなってnetstandard2.0なの？なんで？standard2.1やnet7じゃダメなの？という感じですが、そもそもVisual Studioが .NET Frameworkで動いているというしょっぱい事情があり、Source Generatorプロジェクトはnetstandard2.0で作る必要があるという制限があります。使えるクラスライブラリが少なくて辛い感もありますが我慢です。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;

		&lt;!-- LangVersionは明示的に書いておこう --&gt;
		&lt;LangVersion&gt;11&lt;/LangVersion&gt;
		&lt;!-- Analyzer(Source Generator)ですという設定 --&gt;
		&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
		&lt;AnalyzerLanguage&gt;cs&lt;/AnalyzerLanguage&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.1&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;

namespace SourceGeneratorSample;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Providerシリーズ
        // context.AdditionalTextsProvider
        // context.AnalyzerConfigOptionsProvider
        // context.CompilationProvider
        // context.MetadataReferencesProvider
        // context.ParseOptionsProvider
        // context.SyntaxProvider

        // Registerシリーズ
        // context.RegisterImplementationSourceOutput
        // context.RegisterPostInitializationOutput
        // context.RegisterSourceOutput
    }
}
</code></pre>
<p>これで無のSource Generatorができたので（contextの解説は準備が一通り終わったらします）、次に、このGeneratorを参照するConsoleAppを適当に作成します。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;OutputType&gt;Exe&lt;/OutputType&gt;
		&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\SourceGeneratorSample\SourceGeneratorSample.csproj&quot;&gt;
			&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
			&lt;ReferenceOutputAssembly&gt;false&lt;/ReferenceOutputAssembly&gt;
		&lt;/ProjectReference&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>Source Generatorのプロジェクト参照では、OutputItemTypeとReferenceOutputAssemblyの設定を追加で手書きしてください。</p>
<p>次にまたSource Generator側のプロジェクトに戻って、プロジェクトのプロパティから「デバッグ起動プロファイルUIを開く」を選んでください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009373-a5f32edb-998b-4fde-844b-f67b52da8747.png" alt="image" /></p>
<p>既にあるプロファイルは削除した上で、左上の「新しいプロファイルの作成」から「Roslyn Component」を選択。ここでRoslyn Componentが出てこない場合は、「.NET Compiler Platform SDK」を入れているかどうかの確認と、csprojに<code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code>を追加しているかどうかの確認をしてください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009505-a6e86403-c42c-4f0b-bf53-97c5e42d367d.png" alt="image" /></p>
<p>そしてTarget Projectに、先ほど作成したSource Generatorを参照しているコンソールアプリプロジェクトを選びます。プロジェクトが選べない場合は、対象プロジェクトがSource GeneratorをAnalyzerとしてのプロジェクト参照をしているかどうかを確認してください。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208009562-74d267c6-584e-43fd-93a5-c180b1c4de1e.png" alt="image" /></p>
<p>これで準備が完了で、Source Generatorをデバッグ実行(F5)すると、対象コンソールアプリプロジェクトを引っ掛けた状態で起動するようになります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208011024-62d3cae7-08f7-45d3-b910-312b3137d663.png" alt="image" /></p>
<p>あとは、ひたすら、Generatorのコードを書いていくだけです、めでたし。</p>
<h2>ForAttributeWithMetadataName</h2>
<p>細かい説明に行く前に、基本的な流れの説明を。Source Generatorは、通常、なにか適当な属性がついているpartial classやpartial methodを探して、それに対して追加のpartial class/methodを生成する、という流れになります。原理的には属性がついていなくてもいいですが、勝手に何かを生成されるとわけわかんなくて困るので、ユーザーに明示的に生成を指示させるような流れにすべき、ということで、起点は属性付与だけと考えていいでしょう。</p>
<p>そんなわけでSource Generatorでまずやることは、属性が付与されてるclass/methodを探し出すことなのですが、Roslyn 4.3.1からは <code>SyntaxValueProvider.ForAttributeWithMetadataName</code> というメソッドで一発で探し出すことができるようになりました。</p>
<p>というわけで、小さなサンプル用ジェネレーターとして、classのToStringをrecordのように自動実装するジェネレーターを作ってみます。</p>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGeneratorSample;

[Generator(LanguageNames.CSharp)]
public partial class SampleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // PostInitializationOutputでSource Generatorでしか使わない属性を出力
        context.RegisterPostInitializationOutput(static context =&gt;
        {
            // C# 11のRaw String Literal便利
            context.AddSource(&quot;SampleGeneratorAttribute.cs&quot;, &quot;&quot;&quot;
namespace SourceGeneratorSample;

using System;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class GenerateToStringAttribute : Attribute
{
}
&quot;&quot;&quot;);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            &quot;SourceGeneratorSample.GenerateToStringAttribute&quot;, // 引っ掛ける属性のフルネーム
            static (node, token) =&gt; true, // predicate, 属性で既に絞れてるので特別何かやりたいことがなければ基本true
            static (context, token) =&gt; context); // GeneratorAttributeSyntaxContextにはNode, SemanticModel(Compilation), Symbolが入ってて便利

        // 出力コード部分はちょっとごちゃつくので別メソッドに隔離
        context.RegisterSourceOutput(source, Emit);
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        // classで引っ掛けてるのでTypeSymbol/Syntaxとして使えるように。
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        // ToStringがoverride済みならエラー出す
        if (typeSymbol.GetMembers(&quot;ToString&quot;).Length != 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ExistsOverrideToString, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // グローバルネームスペース対応漏れするとたまによく泣くので気をつける
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? &quot;&quot;
            : $&quot;namespace {typeSymbol.ContainingNamespace};&quot;;

        // 出力ファイル名として使うので雑エスケープ
        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace(&quot;global::&quot;, &quot;&quot;)
            .Replace(&quot;&lt;&quot;, &quot;_&quot;)
            .Replace(&quot;&gt;&quot;, &quot;_&quot;);

        // Field/Propertyを抽出する
        var publicMembers = typeSymbol.GetMembers() // MethodがほしければOfType&lt;IMethodSymbol&gt;()などで絞る
            .Where(x =&gt; x is (IFieldSymbol or IPropertySymbol)
                         and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true })
            .Select(x =&gt; $&quot;{x.Name}:{{{x.Name}}}&quot;); // MyProperty:{MyProperty}

        var toString = string.Join(&quot;, &quot;, publicMembers);

        // C# 11のRaw String Literalを使ってText Template的な置換(便利)
        // ファイルとして書き出される時対策として &lt;auto-generated/&gt; を入れたり
        // nullable enableしつつ、nullable系のwarningがウザいのでdisableして回ったりなどをテンプレコードとして入れておいたりする
        var code = $$&quot;&quot;&quot;
// &lt;auto-generated/&gt;
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

{{ns}}

partial class {{typeSymbol.Name}}
{
    public override string ToString()
    {
        return $&quot;{{toString}}&quot;;
    }
}
&quot;&quot;&quot;;

        // AddSourceで出力
        context.AddSource($&quot;{fullType}.SampleGenerator.g.cs&quot;, code);
    }
}

// DiagnosticDescriptorは大量に作るので一覧性のためにもまとめておいたほうが良い
public static class DiagnosticDescriptors
{
    const string Category = &quot;SampleGenerator&quot;;

    public static readonly DiagnosticDescriptor ExistsOverrideToString = new(
        id: &quot;SAMPLE001&quot;,
        title: &quot;ToString override&quot;,
        messageFormat: &quot;The GenerateToString class '{0}' has ToString override but it is not allowed.&quot;,
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}
</code></pre>
<p>Initializeメソッドの行数の短さ！というわけで、Source Generator作り自体はかなり簡単になりました。その後のSymbolを使ってどうこうというのは、まぁ頑張ってくださいになるのですが、それはそれとして。作り方のポイントとしては、Source Generator(Analyzer)で使うものにはSyntaxNodeとISymbolの二系統があって、SyntaxNodeは文字列としてのソースコードの構造を指していて、ISymbolはコンパイルされた状態での型の中間状態を指します。情報を取ったりするにはISymbolのほうが圧倒的にやりやすいので、基本的にはSymbolを辿って処理していきます。SyntaxNodeは、エラーの波線表示の位置を示したりする時のみに使うという感じですね。</p>
<p>では、これをビルドして、Visual Studioを、再起動します……！というのも、ConsoleApp1側ではSource Generatorを掴みっぱなしになってしまうので、プロジェクト参照でのSource Generatorの更新ができないからです。今回AttributeをGenerator側で追加しているので、再起動してそれの生成を含めてあげる必要があります。今後もConsoleApp1側での動作確認が必要な際は、定期的に再起動する羽目になります。ただしデバッグ起動では更新されたコードで動くので、大きな変動がなければそのまま作業を進められます。といった、IDEを再起動しなきゃいけないシチュエーションなのかしなくてもいいのか、の切り分けが求められます……。</p>
<p>ConsoleApp1側で以下のようなテスト型を用意して</p>
<pre><code class="language-csharp">using SourceGeneratorSample;

var mc = new MyClass() { Hoge = 10, Bar = &quot;tako&quot; };
Console.WriteLine(mc);

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public string? Bar { get; set; }
}
</code></pre>
<p>Source Generator側でデバッグ実行です。いったんの出力の確認でお薦めなのは、AddSourceの直前あたりにブレークポイント貼って見ることですかね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208027141-ae09c996-a7a4-4780-bce0-8a9e22727a5e.png" alt="image" /></p>
<p>そうして何度かデバッグ実行を繰り返して、理想となるコードが吐けるように調整していって、そして、最終的にそれで大丈夫かどうかはコンパイラ通さないとわからんので、Visual Studioを再起動してConsoleApp1側でコンパイル走らせて、みたいなことになりますね。この段階で問題が出ると、Visual Studio再起動祭りになるのでダルい！</p>
<p>問題なく吐けていれば、ソリューションエクスプローラーで生成コードを確認することができます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208027544-81eb7279-aef7-48ff-8241-fa6fa2b4efa3.png" alt="image" /></p>
<p>以上、基本的な流れでした！C# 11のRaw String Literalsのお陰で別途テンプレートエンジンを用いなくても、テンプレート的な処理をC#のコード中に埋め込めるようになったのが、かなり楽になりました。（ただしif や for が埋め込めるわけではないので、複雑なものを書く場合はそれなりの工夫は必要）。</p>
<p>Source Generatorの良いところはAnalyzerも兼ねているところで、今回はToStringが既に定義されている場合はエラーにするという処理を入れているのですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/208030486-1baf9e07-c22e-4c40-8c0c-7b968180ee58.png" alt="image" /></p>
<p>属性でどうこうする系ってどうしても今までは実行時エラーになりがちだったのですが、エディット時に間違って定義をばんばん教えてあげられるようになったのは親切度が相当上がっています。</p>
<h2>IncrementalGeneratorInitializationContext詳解</h2>
<p>Incremental Generatorの強みは複数のProviderを繋げてパイプラインを作れるところ、ではあるのですが、基本的なことは SyntaxProvider.ForAttributeWithMetadataName がほとんど全部やってくれるから、特に考えなくてもいいかな……。</p>
<p>ではあるんですが、細かい処理をしたい場合にはいくつか必要になりますので、Provider見ていきましょう。</p>
<ul>
<li>AdditionalTextsProvider</li>
</ul>
<p>AdditionalTextsProviderは、AdditionalFilesを読み取るのに使います。<a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">BannedApiAnalyzers</a>などでも活用されていますが、例えばコンフィグを渡したいケースなどに有用です。</p>
<p>例えば <code>sampleGenerator.config.json</code> を読み取りたい、といったケースを考えますと、ConsoleApp1側ではこういったcsprojとファイルを用意するとして</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
	&lt;AdditionalFiles Include=&quot;sampleGenerator.config.json&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>AdditionalTextsProviderを使ってこんな風に読み取っていきます。</p>
<pre><code class="language-csharp">var configuration = context.AdditionalTextsProvider.Select((text, token) =&gt;
    {
        if (text.Path.EndsWith(&quot;sampleGenerator.config.json&quot;)) return text.GetText(token);
        return null;
    })
    .Where(x =&gt; x != null)
    .Collect(); //雑Collect

// sampleにあったやつ
var types = context.SyntaxProvider.ForAttributeWithMetadataName(
      &quot;SourceGeneratorSample.GenerateToStringAttribute&quot;,
      static (node, token) =&gt; true,
      static (context, token) =&gt; context)
    .Collect(); //雑Collect

var source = configuration.Combine(types);  // くっつける

context.RegisterSourceOutput(source, static (context, source) =&gt;
{
    var configJson = source.Left.FirstOrDefault();
    var types = source.Right;
    foreach (var type in types)
    {
        // よしなに処理
    }
});
</code></pre>
<p>なるほどコードが増えた？</p>
<p>まず、Providerが触った直後のやつは <code>IncrementalValuesProvider&lt;T&gt;</code> になります。そしてCollectすると <code>IncrementalValueProvider&lt;ImmutableArray&lt;T&gt;&gt;</code> になります。違いはImmutableArray、ではなくて、 ValueProvider と ValuesProvider のほうです。ValueProviderの状態だと(IObservableみたいに)複数値が流れてくるのですが、ValuesProviderの状態だと、ImmutableArrayとして一塊になったものが一発流れてきます。</p>
<p>で、複数ProviderをCombineで繋いで、RegsiterSourceOutputに流し込むという流れになるわけですが、ValueとValuesが混在してるとCombineの型合わせがめちゃくちゃ大変です……！なんかよくわからんがCombineできない！の原因は型が合わないせいなのですね。というわけで雑にCollectしておくと合わせやすくなるので良いです。</p>
<p>というわけで、こんな感じで次のProvider行きましょう。</p>
<ul>
<li>AnalyzerConfigOptionsProvider</li>
</ul>
<p>GlobalOptionsと、AdditionalTextやSyntaxTreeに紐付けられたオプションを引っ張るGetOptionsがあります。例えばMemoryPackではcsprojのオプションから取り出すために使いました。</p>
<p>こういう記述をして</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_SerializationInfoOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_SerializationInfoOutputDirectory&gt;$(MSBuildProjectDirectory)\MemoryPackLogs&lt;/MemoryPackGenerator_SerializationInfoOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>こんな風に取り出すことができる( <code>build_property.</code> が接頭辞に必要)みたいな。</p>
<pre><code class="language-csharp">var outputDirProvider = context.AnalyzerConfigOptionsProvider
    .Select((configOptions, token) =&gt;
    {
        if (configOptions.GlobalOptions.TryGetValue(&quot;build_property.MemoryPackGenerator_SerializationInfoOutputDirectory&quot;, out var path))
        {
            return path;
        }

        return (string?)null;
    });
</code></pre>
<p>csproj側があんま書きやすい感じじゃないので、AdditionalFilesでjsonを渡すのとどちらがいいのか、みたいなのは考えどころですね。こちらだとcsproj内のマクロが使える（出力パスとか）のはいいところかもしれません。</p>
<ul>
<li>CompilationProvider</li>
</ul>
<p>Compilationが拾える最重要Provider、のはずが <code>ForAttributeWithMetadataName</code> がくっつけてくれるので用無し。</p>
<ul>
<li>MetadataReferencesProvider</li>
</ul>
<p>読み込んでるDLLの情報が拾えます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208037687-47a65304-e8d9-42cb-bdd6-f88ea622bc03.png" alt="image" /></p>
<p>そんな使わないかも。</p>
<ul>
<li>ParseOptionsProvider</li>
</ul>
<p>csprojを解析した情報が取れます。例えば言語バージョンやプリプロセッサシンボルから、.NETのバージョンを取り出したりできます。</p>
<pre><code class="language-csharp">var parseOptions = context.ParseOptionsProvider.Select((parseOptions, token) =&gt;
{
    var csOptions = (CSharpParseOptions)parseOptions;
    var langVersion = csOptions.LanguageVersion;
    var net7 = csOptions.PreprocessorSymbolNames.Contains(&quot;NET7_0_OR_GREATER&quot;);
    return (langVersion, net7);
});
</code></pre>
<p>つまり、言語バージョンや.NETのバージョン別の出し分けに使える、ということですね。細かくやると面倒くさいのであんまギチギチにやらないほうがいいとは思いますが、どうしてもそういう処理が必要なシチュエーションでは使えます。というか実際MemoryPackではこれで出し分けしています。scoped ref(C# 11)やfile scoped namespace(C# 10)、static abstract method(.NET 7)という切り分けですねー。</p>
<ul>
<li>SyntaxProvider</li>
</ul>
<p><code>ForAttributeWithMetadataName</code> を叩くためのやつ。</p>
<ul>
<li>RegisterPostInitializationOutput</li>
</ul>
<p>ここからはRegisterシリーズですが、PostInitializeationOutputは、Source Generatorのためのマーカーとしてしか使わない属性をinternal classとして解析走らせる前に出力しておきたい、というやつですね。<a href="https://github.com/Cysharp/UnitGenerator/">UnitGenerator</a>では <code>UnitOfAttribute</code> をそういった形で吐き出しています（なので結果としてUnitGeneratorを使ったプロジェクトはUnitGeneratorへの依存DLLはなし、ということになる）。一方でMemoryPackで使ってる属性 <code>MemoryPackableAttribute</code> は、<code>MemoryPack.Core.dll</code>に含めているので、RegisterPostInitializationOutputは使っていません。どうせReader/Writerとかの他の依存が必要になるので、属性だけ依存なしにしてもしょーがないですからね。</p>
<ul>
<li>RegisterSourceOutput</li>
</ul>
<p>Providerを繋げて、実際にSource Generateさせるやつ。大事というか必須。</p>
<ul>
<li>RegisterImplementationSourceOutput</li>
</ul>
<p>ドキュメントが一切ない上に、なんか想定通りの動きをしていないような私の想定が悪いのか、まぁよくわからないけどよくわからないのでよくわからないです。ドキュメントも無なので、とりあえず無視しておきましょう。</p>
<h2>ユニットテスト</h2>
<p>厳密にやるとキリがないので、そこそこゆるふわ感覚でやるようにしてます。もちろんTDDなんてしません。基本的な考え方としては、ユニットテストプロジェクトがAnalyzerとして開発中のSource Generatorプロジェクトをプロジェクト参照して、ソース生成されるようにしておいて、ユニットテストでは、その生成されたコードが期待通り動いているかのテストをする、みたいな雰囲気で良いんじゃないかと思います。生成ソースコードの中身をチェックして一致するか、みたいなのはちょっと手間が無駄にかかりすぎるので……。</p>
<p>テストプロジェクトはxUnitと、補助ライブラリとして<a href="https://fluentassertions.com/">FluentAssertion</a>を好んで使っています。また、GlobalUsingにテスト系の名前空間を突っ込んでおくと気持ち楽です。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;IsPackable&gt;false&lt;/IsPackable&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;6.7.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.4.0&quot; /&gt;
		&lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.3.1&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;
		&lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.5&quot;&gt;
			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
		&lt;/PackageReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;ProjectReference Include=&quot;..\SourceGeneratorSample\SourceGeneratorSample.csproj&quot;&gt;
			&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
      &lt;!-- ReferenceOutputAssemblyをtrueにする! --&gt;
			&lt;ReferenceOutputAssembly&gt;true&lt;/ReferenceOutputAssembly&gt;
		&lt;/ProjectReference&gt;
	&lt;/ItemGroup&gt;

	&lt;ItemGroup&gt;
		&lt;Using Include=&quot;Xunit&quot; /&gt;
		&lt;Using Include=&quot;Xunit.Abstractions&quot; /&gt;
		&lt;Using Include=&quot;FluentAssertions&quot; /&gt;
	&lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<pre><code class="language-csharp">namespace SourceGeneratorSample.Tests;

public class ToStringTest
{
    [Fact]
    public void Basic()
    {
        var mc = new MyClass() { Hoge = 33, Huga = 99 };
        mc.ToString().Should().Be(&quot;Hoge:33, Huga:99&quot;);
    }
}

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public int Huga { get; set; }
}
</code></pre>
<p>あれ、なんか生成結果が更新されてない気がして無限にTestがこけるんだが？という時は、例によってVisual Studio再起動です。</p>
<p>Source Generatorのいいところとして、生成コードへのステップ実行も可能ということで、なんかよーわからん挙動だわーという時はデバッガでどんどん突っ込んでいくといいでしょう。</p>
<p><img src="https://user-images.githubusercontent.com/46207/208041286-54162ad8-fe1a-41d6-a1f2-37e0dd19c533.png" alt="image" /></p>
<p>正常に動くケースはこれで概ねいいんですが、Analyzerとしてコンパイルエラーを出すようなケースをテストしたい場合は、もう一捻り必要です。対応としては <code>CSharpGeneratorDriver</code> というのが標準で用意されていて、それにソースコード渡せばいい、という話なのですが、少し手間なのは、元になるCSharpCompilationを作らなければいけない、というところで。この辺もよしなに見てくれる便利ジェネレーターユニットテストヘルパーライブラリみたいなのもありますが、原理原則を知るためにも、ここは手で書いてみましょう。</p>
<p>というわけで、こういうヘルパーを用意してみます。</p>
<pre><code class="language-csharp">using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;

namespace MemoryPack.Tests.Utils;

public static class CSharpGeneratorRunner
{
    static Compilation baseCompilation = default!;

    [ModuleInitializer]
    public static void InitializeCompilation()
    {
        // running .NET Core system assemblies dir path
        var baseAssemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location)!;
        var systemAssemblies = Directory.GetFiles(baseAssemblyPath)
            .Where(x =&gt;
            {
                var fileName = Path.GetFileName(x);
                if (fileName.EndsWith(&quot;Native.dll&quot;)) return false;
                return fileName.StartsWith(&quot;System&quot;) || (fileName is &quot;mscorlib.dll&quot; or &quot;netstandard.dll&quot;);
            });

        var references = systemAssemblies
            // .Append(typeof(Foo).Assembly.Location) // 依存DLLがある場合はそれも追加しておく
            .Select(x =&gt; MetadataReference.CreateFromFile(x))
            .ToArray();

        var compilation = CSharpCompilation.Create(&quot;generatortest&quot;,
            references: references,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        baseCompilation = compilation;
    }

    public static Diagnostic[] RunGenerator(string source, AnalyzerConfigOptionsProvider? options = null)
    {
        var driver = CSharpGeneratorDriver.Create(new SourceGeneratorSample.SampleGenerator());
        if (options != null)
        {
            driver = (Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver)driver.WithUpdatedAnalyzerConfigOptions(options);
        }

        var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, new CSharpParseOptions(LanguageVersion.CSharp11))); // use C#11

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        // combine diagnostics as result.
        var compilationDiagnostics = newCompilation.GetDiagnostics();
        return diagnostics.Concat(compilationDiagnostics).ToArray();
    }
}
</code></pre>
<p>CSharpGeneratorDriver.Create して AddSyntaxTrees して RunGeneratorsAndUpdateCompilation して diagnostics を取り出す。というだけなのですが、Compilationを作るところに癖があります、というか Compilation に渡すDLLをかき集めるのが微妙に面倒くさいです。net7の依存関係のDLLを全部持ってくる、とかが一発でできないんですね。素直に typeof().Assembly.Location だけだと全然持ってこれないため、ディレクトリから漁ってくるという処理をいれています。</p>
<p>これを使ってテスト書くと、こんな感じでしょうか。</p>
<pre><code class="language-csharp">    [Fact]
    public void ERROR_SAMPLE001()
    {
        // C#11のRaw String Literals本当に便利
        var result = CSharpGeneratorRunner.RunGenerator(&quot;&quot;&quot;
using SourceGeneratorSample;

[GenerateToString]
public partial class MyClass
{
    public int Hoge { get; set; }
    public int Huga { get; set; }

    public override string ToString()
    {
        return &quot;hogemoge&quot;;
    }
}
&quot;&quot;&quot;);

        result.Length.Should().Be(1);
        result[0].Id.Should().Be(&quot;SAMPLE001&quot;);
    }
</code></pre>
<p>厳密にやるなら、エラーの波線をどこに敷いているかのチェックをすべし、みたいな話もあるのですが、私的にはまぁ面倒くさいのでちゃんと狙ったエラーが出せてるかどうかをDiangnositcsのIdを拾うぐらいでいいかな、みたいな感じでやってます。</p>
<h2>NuGetパッケージング</h2>
<p>というわけで <code>dotnet pack</code> するわけですが、 追加でコンフィグ仕込む必要があります。</p>
<pre><code class="language-csharp">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

	&lt;PropertyGroup&gt;
		&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
		&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
		&lt;LangVersion&gt;11&lt;/LangVersion&gt;

		&lt;!-- NuGetPackのための追加をもりもり --&gt;
		&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
		&lt;AnalyzerLanguage&gt;cs&lt;/AnalyzerLanguage&gt;
		&lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
		&lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
		&lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;
		&lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
	&lt;/PropertyGroup&gt;

	&lt;ItemGroup&gt;
		&lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.1&quot; /&gt;
	&lt;/ItemGroup&gt;

	&lt;!-- 出力先を analyzers/dotnet/cs にする --&gt;
	&lt;ItemGroup&gt;
		&lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
	&lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>外部依存DLLがいたりすると(例えばJSON .NET使いたいとか！)もう少し面倒くさくなるので、外部依存DLLは使わないようにしましょう！というのが第一原則になります。どうしても使いたい場合は頑張ってください。</p>
<h2>Unity対応</h2>
<p>まずIncremental Source Generator使えないし ForAttributeWithMetadataName も使えないしちくしょーって感じですが、とはいえそこまで差分が多いわけでもないのでやってきましょう。</p>
<p>まず、簡易的な ForAttributeWithMetadataName っぽいものを用意します。MemoryPackでは以下のコードを使ってます。</p>
<pre><code class="language-csharp">class SyntaxContextReceiver : ISyntaxContextReceiver
{
    internal static ISyntaxContextReceiver Create()
    {
        return new SyntaxContextReceiver();
    }

    public HashSet&lt;TypeDeclarationSyntax&gt; ClassDeclarations { get; } = new();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        var node = context.Node;
        if (node is ClassDeclarationSyntax
                    or StructDeclarationSyntax
                    or RecordDeclarationSyntax
                    or InterfaceDeclarationSyntax)
        {
            var typeSyntax = (TypeDeclarationSyntax)node;
            if (typeSyntax.AttributeLists.Count &gt; 0)
            {
                var attr = typeSyntax.AttributeLists.SelectMany(x =&gt; x.Attributes)
                    .FirstOrDefault(x =&gt;
                    {
                        var packable = x.Name.ToString() is &quot;MemoryPackable&quot; or &quot;MemoryPackableAttribute&quot; or &quot;MemoryPack.MemoryPackable&quot; or &quot;MemoryPack.MemoryPackableAttribute&quot;;
                        if (packable) return true;
                        return false;
                    });
                if (attr != null)
                {
                    ClassDeclarations.Add(typeSyntax);
                }
            }
        }
    }
}
</code></pre>
<p>ざっくりしてる感じですが、機能はするのでよしとしておきましょう。次にSourceGenerator と IncrementalGenerator を共通化するContextを用意しておきます。</p>
<pre><code class="language-csharp">// share context for SourceGenerator and IncrementalGenerator
public interface IGeneratorContext
{
    CancellationToken CancellationToken { get; }
    void ReportDiagnostic(Diagnostic diagnostic);
    void AddSource(string hintName, string source);
}
</code></pre>
<p>そして、最初のサンプルコードでいうところのEmit部分を↑のIGeneratorContextを使うようにしてファイル分離、そしてCompile Includeで.csを参照するようにします。MemoryPackでは以下のようにしています。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;Compile Include=&quot;../MemoryPack.Generator/**/*.cs&quot; Exclude=&quot;**/obj/**;**/MemoryPackGenerator.cs;**/*TypeScript*.cs&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>大事なのはプロジェクト分離しないこと、ですね！NuGetパッケージングのところでも書きましたがAnalyzer(Source Generator)でごちゃごちゃした依存作ると面倒臭さが跳ね上がるので、シングルアセンブリに収まるように作るべし、ということです。</p>
<p>あとは<a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unityのマニュアル</a>通りにビルド済みdllを配置してRoslynAnalyzerとしてLabel設定したmetaを置いておけば、UPMのgit参照とかでも、特に何もせずに自動で認識されます。dllの配置場所はUnityの公式のジェネレーター(例えば com.unity.properties とか)がRuntime配下にいるので、Editorではなく、Runtime側に配置することとしています。</p>
<p>なお、Unity用限定のSource Generatorを作る場合でも、通常の .NET のライブラリとして扱い、普通に .NET ライブラリとしての開発環境やユニットテストプロジェクトを作ったほうが良いでしょう。普通に作るにもかなり環境をしっかり作らないと大変なので、Unity限定だから！みたいな気持ちで挑むとしんどみが爆発します。</p>
<h2>まとめ</h2>
<p>C#に最初にこの手の機構が登場したのは2014年、 <a href="https://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a> といった記事も書いていたのですが、まぁ正直めっっっちゃくちゃ作りづらかったんですね。</p>
<p>で、現代、この2022年のSource Generator開発はめっっっっちゃくちゃ作りやすくなってます。もちろん、Roslyn自体の知識が必要で、そしてRoslynはドキュメントが無なので、どちらかというとIntelliSenseから勘をどう働かせるかという勝負になっていて、それはそれで大変ではあるのですが、しかし本当に作りやすくなったな、と思います。もちろんそしてIL.Emitよりも遥かに作りやすいし、パフォーマンスも良い。もうEmitの時代は終わりです。もはや黒魔術を誇る時代でもないのです！動的コード生成の民主化！</p>
<p>というわけで、どしどしコード生成していきましょう……！私も今温めてるアイディアが3つぐらいあるので、どんどんリリースしていきたいと思ってます。</p>
</div>
<h1><a href="https://neue.cc/2022/12/08_MemoryPackSessionInDotNetConfRecapTokyo.html">C# 11 による世界最速バイナリシリアライザー「MemoryPack」の作り方</a></h1>
<ul class="date"><li>2022-12-08</li></ul>
<div class="entry_body"><p>と題して、.NET Conf 2022 Recap Event Tokyo というイベントで話してきました。</p>
<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/7b71dc84ae4a4241aa241340fa890f65" title="C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 840px; height: 471px;" data-ratio="1.78343949044586"></iframe>
<p>今回は久々の（数年ぶりの！）オフライン登壇イベントということで、なんだか新鮮な気分で、そして実際、オンライン登壇よりも目の前にオーディエンスがいたほうがいいなぁという思いを新たに。事前レコーディングやオンライン登壇だと、どうしてもライブ感のない、冷めた感じになっちゃうな、と。セッション単体の完成度で言ったら何度も取り直して完璧に仕上げた事前録画のほうがいい、かもしれませんが、でもそういうもんじゃあないかなあ、と。スタジオアルバムとライブアルバムみたいなもんですね。そしてスタジオアルバムに相当するのは念入りに書かれたブログ記事とかだったりするので、事前録画のセッションって、なんか中途半端に感じてしまったりはしますね。スタジオライブみたいな。あれってなんかいまいちじゃないですか、そういうことで。</p>
<p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>は先程 v1.9.0 をリリースしました！日刊MemoryPackか？というぐらいに更新ラッシュをしていたのですが、バグというかは機能追加をめちゃくちゃやってました。性能面で究極のシリアライザーを目指した、というのはセッションスライドのほうにも書かせてもらっていますが、機能面でも究極のシリアライザーを目指しています、ということで、めちゃくちゃやれる幅が広がってます。GitHub Star数も既に1200と、めちゃくちゃ凄い勢いで伸びているので（過去最高の勢いです）、出す前は独自フォーマットのシリアライザーだと、どのぐらいまで使ってもらえるものだろうか？と不安に思ったところもあったのですが、割と自信もって押していける感じです。実際、性能も機能も凄い。</p>
<h2>Formatterという名前付けについて</h2>
<p>特に誰にも聞かれていないのですが説明しておきたいのが <code>MemoryPackFormatter</code> という名前を。Formatterって正直馴染みがないし(<code>BinaryFormatter</code>かよ？)、 <code>IMemoryPackSerializer</code> にしようかな、と当初は考えていたのですが最終的には(MessagePack for C#と同じの)Formatterに落ち着きました。理由は、エントリーポイントである <code>MemoryPackSerializer</code> と紛らわしいんですよね。 <code>MemoryPackFormatter</code>は自作でもしない限りは表に出て来ないし、上級向けのオプションなので、すっきりと名前で区別がついたほうが良いかな、という感じでつけてます。System.Text.Jsonの場合は <code>JsonSerializer</code> と <code>JsonConverter</code>という分類で、同じような感じです。</p>
<p>候補になる名前としては<code>Serializer</code>か<code>Formatter</code>か<code>Converter</code>か<code>Encoder</code>か<code>Codec</code>という感じでしょうか。単純で当たり前のチョイスのようでいて、ユーザーがなるべく悩まず直感的に理解できるように、しっかり考えて悩みながらつけてるんですよということで。それで出来上がった名前が、単純で当たり前のように思ってもらえれば正解なわけです。</p>
<h2>イベント2</h2>
<p>久々のオンフライン登壇！だったのですが、こういうのは始まると続くもので、今月は12/14に <a href="https://bitflyer.connpass.com/event/266685/">bitFlyer.C#/Azure 01</a>というイベントに、Azureじゃないほうの枠として登壇する予定です。「AlterNatsにみる .NET 7世代のハイパフォーマンスSocketプログラミング技法」という内容ですが<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>というよりかは、最新のC#でハイパフォーマンスなSocketプログラミングをどうすればいいか、ということに重点を置いた内容になってますので、C#の最適化に興味ある方は是非是非来てください。まだ席空いてますので……！</p>
</div>
<h1><a href="https://neue.cc/2022/11/04_memorypack.html">MemoryPackにみる .NET 7/C# 11世代のシリアライザー最適化技法</a></h1>
<ul class="date"><li>2022-11-04</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MemoryPack">MemoryPack</a>という、C#に特化することで従来のシリアライザーとは比較にならないほどのパフォーマンスを発揮する新しいシリアライザーを新しく開発しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/192748136-262ac2e7-4646-46e1-afb8-528a51a4a987.png" alt="" /></p>
<p>高速なバイナリシリアライザーである <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a> と比較しても、通常のオブジェクトでも数倍、データが最適な場合は50~100倍ほどのパフォーマンスにもなります。System.Text.Jsonとでは全く比較になりません。当初は .NET 7 限定としてリリースしましたが、現在は .NET Standard 2.1(.NET 5, 6)やUnity、そしてTypeScriptにも対応しています。</p>
<p>シリアライザーのパフォーマンスは「データフォーマットの仕様」と「各言語における実装」の両輪で成り立っています。例えば、一般的にはバイナリフォーマットのほうがテキストフォーマット（JSONとか）よりも有利ですが、バイナリシリアライザーより速いJSONシリアライザといったものは有り得ます(Utf8Jsonでそれを実証しました)。では最速のシリアライザーとは何なのか？というと、仕様と実装を突き詰めれば、真の最速のシリアライザーが誕生します。</p>
<p>私は、今もですが、長年<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>の開発とメンテナンスをしてきました。MessagePack for C#は .NET の世界で非常に成功したシリアライザーで、4000以上のGitHub Starと、Visual Studio内部や、SignalR, Blazor Serverのバイナリプロトコルなど、Microsoftの標準プロダクトにも採用されています。また、この5年間で1000近くのIssueをさばいてきました。そのため、シリアライザーの実装の詳細からユーザーのリアルなユースケース、要望、問題などを把握しています。Roslynを使用したコードジェネレーターによるAOT対応にも当初から取り組み、特にAOT環境(IL2CPP)であるUnityで実証してきました。更にMessagePack for C#以外にも ZeroFormatter(独自フォーマット)、Utf8Json(JSON) といった、これも多くのGitHub Starを獲得したシリアライザーを作成してきているため、異なるフォーマットの性能特性についても深く理解しています。シリアライザーを活用するシチュエーションにおいても、RPCフレームワーク<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>の作成、インメモリデータベース<a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a>、そして複数のゲームタイトルにおけるクライアント(Unity)/サーバー、両方の実装に関わってきました。</p>
<p>ようするところ私は .NET のシリアライザー実装について最も詳しい人間の一人であり、MemoryPackはその知見がフルに詰め込まれた、なおかつ、 .NET 7 / C# 11という最新のランタイム/言語機能を使い倒したライブラリになっています。そりゃ速くて当然で異論はないですよね？</p>
<p>というだけではアレなので、実際なんで速いのかというのを理屈で説明していきます……！きっと納得してもらえるはず！ C#の最適化のTipsとしてもどうぞ。</p>
<h2>Incremental Source Generator</h2>
<p>MemoryPackでは .NET 5/C# 9.0 から追加された <a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview">Source Generator</a>、それも .NET 6 で強化された <a href="https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md">Incremental Source Generator</a>を全面的に採用しています。使い方的には、対象型をpartialに変更する程度で、MessagePack for C#とあまり変わりません（というか極力同じAPIになるように揃えました）。</p>
<pre><code class="language-csharp">using MemoryPack;

[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}

// usage
var v = new Person { Age = 40, Name = &quot;John&quot; };

var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>Source Generatorの最大の利点はAOTフレンドリーであることで、従来行っていたIL.Emitによる動的コード生成をせずとも、リフレクションを使用しない、各型に最適化されたシリアライザーコードを自動生成しています。それによりUnityのIL2CPPなどでも安全に動作させることが可能です。</p>
<p>MessagePack for C#では外部ツール(mpc.exe)経由でコード生成することでAOTセーフなシリアライズ処理を実現していましたが、言語機能と統合されたことによって、煩わしい生成プロセス不要で、自然な書き心地のまま高速なシリアライズ処理を可能にしました。</p>
<p>なお、Unity版の場合は言語/コンパイラバージョンの都合上、Incremental Source Generatorではなくて、古いSource Generatorを採用しています。</p>
<h2>C#のためのバイナリ仕様</h2>
<p>キャッチコピーは「Zero encoding」ということで、エンコードしないから速いんだ！という理論を打ち出しています。奇妙に思えて、実のところ別に特殊な話をしているわけではなくて、例えばRustのメジャーなバイナリシリアライザーである<a href="https://github.com/bincode-org/bincode">bincode</a>なども似通った仕様を持っています。<a href="https://github.com/google/flatbuffers">FlatBuffers</a>も、without parsingな実装のために、メモリデータに近い内容を読み書きします。ただしMemoryPackはFlatBuffersなどと違い、特別な型を必要としない汎用的なシリアライザーであり、POCOに対してのシリアライズ/デシリアライズを行うものです。また、スキーマのメンバー追加へのバージョニング耐性やポリモーフィズムサポート(Union)も持ちます。さすがにメモリダンプしてるだけ、では全く実用にならないわけで、一般的なシリアライザーとして使えるための仕様として整えてあります。</p>
<h2>varint encoding vs fixed</h2>
<p>Int32は4バイトですが、例えばJSONでは数値を文字列として、1バイト~11バイト(例えば <code>1</code> であったり <code>-2147483648</code> であったり)の可変長なエンコーディングが施されます。バイナリフォーマットでも、サイズの節約のために1~5バイトの可変長にエンコードされる仕様を持つものが多くあります。例えば<a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Protocol Buffersの数値型</a>は、値を7ビットに、後続があるかないかのフラグを1ビットに格納する可変長整数エンコーディングになっています(varint)。これにより数値が小さければ小さいほど、バイト数が少なくなります。逆にワーストケースでは本来の4バイトより大きい5バイトに膨れることになります。とはいえ現実的には小さい数値のほうが圧倒的に頻出するはずなので、とても理にかなった方式です。<a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack</a>や<a href="https://cbor.io/">CBOR</a>も同じように、小さい数値では最小で1バイト、大きい場合は最大5バイトになる可変長エンコーディングで処理されます。</p>
<p>つまり、固定長の場合よりも余計な処理が走ることになります。具体的なコードで比較してみましょう。可変長はprotobufで使われるvarint + <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">ZigZagエンコーディング</a>(負数と正数をまとめる)です。</p>
<pre><code class="language-csharp">// 固定長の場合
static void WriteFixedInt32(Span&lt;byte&gt; buffer, int value)
{
    ref byte p = ref MemoryMarshal.GetReference(buffer);
    Unsafe.WriteUnaligned(ref p, value);
}

// 可変長の場合
static void WriteVarInt32(Span&lt;byte&gt; buffer, int value) =&gt; WriteVarInt64(buffer, (long)value);

static void WriteVarInt64(Span&lt;byte&gt; buffer, long value)
{
    ref byte p = ref MemoryMarshal.GetReference(buffer);

    ulong n = (ulong)((value &lt;&lt; 1) ^ (value &gt;&gt; 63));
    while ((n &amp; ~0x7FUL) != 0)
    {
        Unsafe.WriteUnaligned(ref p, (byte)((n &amp; 0x7f) | 0x80));
        p = ref Unsafe.Add(ref p, 1);
        n &gt;&gt;= 7;
    }
    Unsafe.WriteUnaligned(ref p, (byte)n);
}
</code></pre>
<p>固定長は、つまりC#のメモリをそのまま書き出している(Zero encoding)わけで、さすがにどう見ても固定長のほうが速いでしょう。</p>
<p>このことは配列に適用した場合、より顕著になります。</p>
<pre><code class="language-csharp">// https://sharplab.io/
Inspect.Heap(new int[]{ 1, 2, 3, 4, 5 });
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/199924027-492a163c-9bd9-41e7-8489-4f5aa61cac52.png" alt="image" /></p>
<p>C#のstructの配列は、データが直列に並びます。この時、<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/unmanaged-types">structが参照型を持っていない場合(unmanaged type)</a>は、データが完全にメモリ上に並んでいることになります。MessagePackとMemoryPackでコードでシリアライズ処理を比較してみましょう。</p>
<pre><code class="language-csharp">// 固定長の場合(実際には長さも書き込みます)
void Serialize(int[] value)
{
    // サイズが算出可能なので事前に一発で確保
    var size = (sizeof(int) * value.Length) + 4;
    EnsureCapacity(size);

    // 一気にメモリコピー
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer);
}

// 可変長の場合
void Serialize(int[] value)
{
    foreach (var item in value)
    {
        // サイズが不明なので都度バッファサイズのチェック
        EnsureCapacity(); // if (buffer.Length &lt; writeLength) Resize();
        // 1要素毎に可変長エンコード
        WriteVarInt32(item);
    }
}
</code></pre>
<p>固定長の場合は、多くのメソッド呼び出しを省いて、メモリコピー一発だけで済ませることが可能です。</p>
<p>C#の配列はintのようなプリミティブ型だけではなく、これは複数のプリミティブを持ったstructでも同様の話で、例えば(float x, float y, float z)を持つVector3の配列の場合は、以下のようなメモリレイアウトになります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/199926307-bad558f9-b912-4b96-90fc-5c2d1a2837ea.png" alt="image" /></p>
<p>float(4バイト)はMessagePackにおいて、固定長で5バイトです。追加の1バイトは、その値が何の型(IntなのかFloatなのかStringなのか...)を示す識別子が先頭に入ります。具体的には[0xca, x, x, x, x]といったように。いわばタグ付与エンコーディングを行っているわけです。MemoryPackのフォーマットは識別子を持たないため、4バイトをそのまま書き込みます。</p>
<p>ベンチマークで50倍の差だった、Vector3[10000]で考えてみましょう。</p>
<pre><code class="language-csharp">// 以下の型がフィールドにあるとする
// byte[] buffer
// int offset

void SerializeMemoryPack(Vector3[] value)
{
    // どれだけ複雑だろうとコピー一発で済ませられる
    var size = Unsafe.SizeOf&lt;Vector3&gt;() * value.Length;   
    if ((buffer.Length - offset) &lt; size)
    {
        Array.Resize(ref buffer, buffer.Length * 2);
    }
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer.AsSpan(0, offset))
}

void SerializeMessagePack(Vector3[] value)
{
    // 配列の長さ x フィールドの数だけ繰り返す
    foreach (var item in value)
    {
        // X
        {
            // EnsureCapacity
            if ((buffer.Length - offset) &lt; 5)
            {
                // 実際にはResizeではなくてbufferWriter.Advance()です
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.X);
            offset += 5;
        }
        // Y
        {
            if ((buffer.Length - offset) &lt; 5)
            {
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.Y);
            offset += 5;
        }
        // Z
        {
            if ((buffer.Length - offset) &lt; 5)
            {
                Array.Resize(ref buffer, buffer.Length * 2);
            }
            var p = MemoryMarshal.GetArrayDataReference(buffer);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset), (byte)0xca);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, offset + 1), item.Z);
            offset += 5;
        }
    }
}
</code></pre>
<p>MessagePackだと30000回のメソッド呼び出しが必要なところが(そしてそのメソッド内では、書き込みメモリが足りているかのチェックと、書き終わった後のオフセットの追加が(愚直に処理する場合)都度必要になる)、一回のメモリコピーだけになります。こうなると、処理時間が文字通り桁違いに変わってきて、冒頭のグラフの50倍~100倍の高速化の理由はここにあります。</p>
<p>もちろん、デシリアライズ処理もコピー一発になります。</p>
<pre><code class="language-csharp">// MemoryPackのデシリアライズ、コピーするだけ。
Vector3[] DeserializeMemoryPack(ReadOnlySpan&lt;byte&gt; buffer, int size)
{
    var dest = new Vector3[size];
    MemoryMarshal.Cast&lt;byte, Vector3&gt;(buffer).CopyTo(dest);
    return dest;
}

// ループで都度floatの読み取りが必要
Vector3[] DeserializeMessagePack(ReadOnlySpan&lt;byte&gt; buffer, int size)
{
    var dest = new Vector3[size];
    for (int i = 0; i &lt; size; i++)
    {
        var x = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        var y = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        var z = ReadSingle(buffer);
        buffer = buffer.Slice(5);
        dest[i] = new Vector3(x, y, z);
    }
    return dest;
}
</code></pre>
<p>この辺は、MessagePackのフォーマットそのものの限界のため、仕様に従う限りは、圧倒的な速度差はどうやっても覆せません。ただしMessagePackの場合はext format familyという仕様があり、独自仕様としてこれらの配列だけ特別扱いして処理する（MessagePackとしての互換性はなくなりますが）ことも許されています。実際、MessagePack for C#ではUnity向けに <code>UnsafeBlitResolver</code> という、上記のような処理をする特別な拡張オプションを用意していました。</p>
<p>しかし恐らく、ほとんどの人が使っていないでしょう。別に普通にシリアライズできるものを、言語間運用製を壊す、C#だけの独自拡張オプションをわざわざ使おうとは、中々思わない、というのは分かります。そこがまた歯痒かったんですよね、明らかに遅いのに、明らかに速くできるのに、だからせっかく用意したのに、デフォルトではない限り使われない、しかしデフォルトは絶対に仕様に従うべきであり……。</p>
<h2>string処理の最適化</h2>
<p>MemoryPackではStringに関して、2つの仕様を持っています。UTF8か、UTF16か、です。C#のstringはUTF16のため、UTF16のままシリアライズすると、UTF8へのエンコード/デコードコストを省くことができます。</p>
<pre><code class="language-csharp">void EncodeUtf16(string value)
{
    var size = value.Length * 2;
    EnsureCapacity(size);

    // char[] -&gt; byte[] -&gt; Copy
    MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(buffer);
}

string DecodeUtf16(ReadOnlySpan&lt;byte&gt; buffer, int length)
{
    ReadOnlySpan&lt;char&gt; src = MemoryMarshal.Cast&lt;byte, char&gt;(buffer).Slice(0, length);
    return new string(src);
}
</code></pre>
<p>ただし、MemoryPackのデフォルトはUTF8です。これは単純にペイロードのサイズの問題で、UTF16だとASCII文字が2倍のサイズになってしまうため、UTF8にしました（なお、日本語の場合はUTF16のほうがむしろ縮まる可能性が高いです）。</p>
<p>UTF8の場合でも、他のシリアライザにはない最適化をしています。</p>
<pre><code class="language-csharp">void WriteUtf8MemoryPack(string value)
{
    var source = value.AsSpan();
    var maxByteCount = (source.Length + 1) * 3;
    EnsureCapacity(maxByteCount);
    Utf8.FromUtf16(source, dest, out var _, out var bytesWritten, replaceInvalidSequences: false);
}

void WriteUtf8StandardSerializer(string value)
{
    var maxByteCount = Encoding.UTF8.GetByteCount(value);
    EnsureCapacity(maxByteCount);
    Encoding.UTF8.GetBytes(value, dest);
}
</code></pre>
<p><code>var bytes = Encoding.UTF8.GetBytes(value);</code> は論外です、stringの書き込みで <code>byte[]</code> のアロケーションは許されません。しかし、多くのシリアライザはで使われている <code>Encoding.UTF8.GetByteCount</code> も避けるべきです、UTF8は可変長のエンコーディングであり、 GetByteCount は正確なエンコード後のサイズを算出するために、文字列を完全に走査します。つまり GetByteCount -&gt; GetBytes は文字列を二度も走査することになります。</p>
<p>通常シリアライザーは余裕を持ったバッファの確保が許されています。そこでMemoryPackではUTF8エンコードした場合のワーストケースである文字列長の3倍の確保にすることで、二度の走査を避けています。</p>
<p>デコードの場合は、更に特殊な最適化を施しています。</p>
<pre><code class="language-csharp">string ReadUtf8MemoryPack(int utf16Length, int utf8Length)
{
    unsafe
    {
        fixed (byte* p = &amp;buffer)
        {
            return string.Create(utf16Length, ((IntPtr)p, utf8Length), static (dest, state) =&gt;
            {
                var src = MemoryMarshal.CreateSpan(ref Unsafe.AsRef&lt;byte&gt;((byte*)state.Item1), state.Item2);
                Utf8.ToUtf16(src, dest, out var bytesRead, out var charsWritten, replaceInvalidSequences: false);
            });
        }
    }
}

string ReadStandardSerialzier(int utf8Length)
{
    return Encoding.UTF8.GetString(buffer.AsSpan(0, utf8Length));
}
</code></pre>
<p>通常、byte[]からstringを取り出すには Encoding.UTF8.GetString(buffer) を使います。MessagePack for C#でもそうです。しかし、改めて、UTF8は可変長のエンコーディングであり、そこからUTF16としての長さは分かりません。そのためUTF8.GetStringだと、stringに変換するためのUTF16としての長さ算出が必要なので、中では文字列を二度走査しています。擬似コードでいうと</p>
<pre><code class="language-csharp">var length = CalcUtf16Length(utf8data);
var str = String.Create(length);
Encoding.Utf8.DecodeToString(utf8data, str);
</code></pre>
<p>といったことになっています。一般的なシリアライザの文字列フォーマットはUTF8であり、当たり前ですがUTF16へのデコードなどといったことは考慮されていないため、C#の文字列としての効率的なデコードのためにUTF16の長さが欲しくても、データの中にはありません。</p>
<p>しかしMemoryPackの場合はC#を前提においた独自フォーマットのため、文字列はUTF16-LengthとUTF8-Lengthの両方(8バイト)をヘッダに記録しています。そのため、<code>String.Create&lt;TState&gt;(Int32, TState, SpanAction&lt;Char,TState&gt;)</code> と<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.unicode.utf8.toutf16">Utf8.ToUtf16</a>の組み合わせにより、最も効率的なC# Stringへのデコードを実現しました。</p>
<h2>ペイロードサイズについて</h2>
<p>MemoryPackは固定長エンコーディングのため可変長エンコーディングに比べてどうしてもサイズが膨らむ場合があります。特にlongを可変長エンコードすると最小1バイトになるので、固定長8バイトに比べると大きな差となり得ます。しかし、MemoryPackはフィールド名を持たない(JSONやMessagePackのMap)ことやTagがないことなどから、JSONよりも小さいのはもちろん、可変長エンコーディングを持つprotobufやMsgPackと比較しても大きな差となることは滅多にないと考えています。</p>
<p>データは別に整数だけじゃないので、真にサイズを小さくしたければ、圧縮(LZ4やZStandardなど)を考えるべきですし、圧縮してしまえばあえて可変長エンコーディングする意味はほぼなくなります。より特化して小さくしたい場合は、列指向圧縮にしたほうがより大きな成果を得られる(Apache Parquetなど)ので、現代的には可変長エンコーディングを採用するほうがデメリットは大きいのではないか？と私は考えています。冒頭でも少し紹介しましたが、実際Rustのシリアライザー<a href="https://github.com/bincode-org/bincode">bincode</a>のデフォルトは固定長だったりします。</p>
<p>MemoryPackの実装と統合された効率的な圧縮については、現在BrotliEncode/Decodeのための補助クラスを標準で用意しています。しかし、性能を考えるとLZ4やZStandardを使えたほうが良いため、将来的にはそれらの実装も提供する予定です。</p>
<h2>.NET 7 / C#11を活用したハイパフォーマンスシリアライザーのための実装</h2>
<p>MemoryPackは .NET Standard 2.1向けの実装と .NET 7向けの実装で、メソッドシグネチャが若干異なります。.NET 7向けには、最新の言語機能を活用した、より性能を追求したアグレッシブな実装になっています。</p>
<p>まずシリアライザのインターフェイスは以下のような static abstract membersが活用されています。</p>
<pre><code class="language-csharp">public interface IMemoryPackable&lt;T&gt;
{
    // note: serialize parameter should be `ref readonly` but current lang spec can not.
    // see proposal https://github.com/dotnet/csharplang/issues/6010
    static abstract void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref T? value)
        where TBufferWriter : IBufferWriter&lt;byte&gt;;
    static abstract void Deserialize(ref MemoryPackReader reader, scoped ref T? value);
}
</code></pre>
<p>MemoryPackはSource Generatorを採用し、対象型が <code>[MemortyPackable]public partial class Foo</code> であることを要求するため、最終的に対象型は</p>
<pre><code class="language-csharp">[MemortyPackable]
partial class Foo : IMemoryPackable
{
    static void IMemoryPackable&lt;Foo&gt;.Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref Foo? value) 
    {
    }
        
    static void IMemoryPackable&lt;Foo&gt;.Deserialize(ref MemoryPackReader reader, scoped ref Foo? value)
    {
    }
}
</code></pre>
<p>といったものを生成します。これにより、仮想メソッド経由呼び出しのコストを避けています。</p>
<pre><code class="language-csharp">public void WritePackable&lt;T&gt;(scoped in T? value)
    where T : IMemoryPackable&lt;T&gt;
{
    // IMemoryPackableが対象の場合、静的メソッドを直接呼び出しに行く
    T.Serialize(ref this, ref Unsafe.AsRef(value));
}

// 
public void WriteValue&lt;T&gt;(scoped in T? value)
{
    // IMemoryPackFormatter&lt;T&gt; を取得し、仮想メソッド経由で Serialize を呼び出す
    var formatter = MemoryPackFormatterProvider.GetFormatter&lt;T&gt;();
    formatter.Serialize(ref this, ref Unsafe.AsRef(value));
}
</code></pre>
<p>また、<code>MemoryPackWriter</code>/<code>MemoryPackReader</code> では <code>ref field</code> を活用しています。</p>
<pre><code class="language-csharp">public ref struct MemoryPackWriter&lt;TBufferWriter&gt;
    where TBufferWriter : IBufferWriter&lt;byte&gt;
{
    ref TBufferWriter bufferWriter;
    ref byte bufferReference;
    int bufferLength;
</code></pre>
<p><code>ref byte bufferReference</code>, <code>int bufferLength</code> の組み合わせは、つまり<code>Span&lt;byte&gt;</code>のインライン化です。また、<code>TBufferWriter</code>を<code>ref TBufferWriter</code>として受け取ることにより、ミュータブルな<code>struct TBufferWriter : IBufferWrite&lt;byte&gt;</code>を安全に受け入れて呼び出すことができるようになりました。</p>
<h2>全ての型への最適化</h2>
<p>例えばコレクションは <code>IEnumerable&lt;T&gt;</code> としてシリアライズ/デシリアライズすることで実装の共通化が可能ですが、MemoryPackでは全ての型に対して個別の実装をするようにしています。単純なところでは <code>List&lt;T&gt;</code>を処理するのに</p>
<pre><code class="language-csharp">public void Serialize(ref MemoryPackWriter writer, IEnumerable&lt;T&gt; value)
{
    foreach(var item in source)
    {
        writer.WriteValue(item);
    }
}

public void Serialize(ref MemoryPackWriter writer, List&lt;T&gt; value)
{
    foreach(var item in source)
    {
        writer.WriteValue(item);
    }
}
</code></pre>
<p>この2つでは全然性能が違います。<code>IEnumerable&lt;T&gt;</code>へのforeachは <code>IEnumerator&lt;T&gt;</code> を取得しますが、<code>List&lt;T&gt;</code>へのforeachは <code>struct List&lt;T&gt;.Enumerator</code> という最適化された専用の構造体のEnumeratorを取得するからです。</p>
<p>しかし、もっと最適化する余地があります。</p>
<pre><code class="language-csharp">public sealed class ListFormatter&lt;T&gt; : MemoryPackFormatter&lt;List&lt;T?&gt;&gt;
{
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref List&lt;T?&gt;? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        writer.WriteSpan(CollectionsMarshal.AsSpan(value));
    }
}

// MemoryPackWriter.WriteSpan
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void WriteSpan&lt;T&gt;(scoped Span&lt;T?&gt; value)
{
    if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
    {
        DangerousWriteUnmanagedSpan(value);
        return;
    }

    var formatter = GetFormatter&lt;T&gt;();
    WriteCollectionHeader(value.Length);
    for (int i = 0; i &lt; value.Length; i++)
    {
        formatter.Serialize(ref this, ref value[i]);
    }
}

// MemoryPackWriter.DangerousWriteUnmanagedSpan
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void DangerousWriteUnmanagedSpan&lt;T&gt;(scoped Span&lt;T&gt; value)
{
    if (value.Length == 0)
    {
        WriteCollectionHeader(0);
        return;
    }

    var srcLength = Unsafe.SizeOf&lt;T&gt;() * value.Length;
    var allocSize = srcLength + 4;

    ref var dest = ref GetSpanReference(allocSize);
    ref var src = ref Unsafe.As&lt;T, byte&gt;(ref MemoryMarshal.GetReference(value));

    Unsafe.WriteUnaligned(ref dest, value.Length);
    Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)srcLength);

    Advance(allocSize);
}
</code></pre>
<p>まず、そもそも現代では <code>List&lt;T&gt;</code> の列挙は <code>CollectionsMarshal.AsSpan(value)</code> 経由で、<code>Span&lt;T&gt;</code>を取得して、それを列挙するのが最適です。それによってEnumerator経由というコストすら省くことが可能です。更に、<code>Span&lt;T&gt;</code>が取得できているなら、<code>List&lt;int&gt;</code>や<code>List&lt;Vector3&gt;</code>の場合にコピーのみで処理することもできます。</p>
<p>Deserializeの場合にも、興味深い最適化があります。まず、MemoryPackのDeserializeは <code>ref T? value</code> を受け取るようになっていて、valueがnullの場合は内部で生成したオブジェクトを（普通のシリアライザと同様）、valueが渡されている場合は上書きするようになっています。これによってDeserialize時の新規オブジェクト生成というアロケーションをゼロにすることが可能です。コレクションの場合も、<code>List&lt;T&gt;</code>の場合は<code>Clear()</code>を呼び出すことで再利用します。</p>
<p>その上で、特殊なSpanの呼び出しをすることにより、 <code>List&lt;T&gt;.Add</code> すら避けることに成功しました。</p>
<pre><code class="language-csharp">public sealed class ListFormatter&lt;T&gt; : MemoryPackFormatter&lt;List&lt;T?&gt;&gt;
{
    public override void Deserialize(ref MemoryPackReader reader, scoped ref List&lt;T?&gt;? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (value == null)
        {
            value = new List&lt;T?&gt;(length);
        }
        else if (value.Count == length)
        {
            value.Clear();
        }

        var span = CollectionsMarshalEx.CreateSpan(value, length);
        reader.ReadSpanWithoutReadLengthHeader(length, ref span);
    }
}

internal static class CollectionsMarshalEx
{
    /// &lt;summary&gt;
    /// similar as AsSpan but modify size to create fixed-size span.
    /// &lt;/summary&gt;
    public static Span&lt;T?&gt; CreateSpan&lt;T&gt;(List&lt;T?&gt; list, int length)
    {
        list.EnsureCapacity(length);

        ref var view = ref Unsafe.As&lt;List&lt;T?&gt;, ListView&lt;T?&gt;&gt;(ref list);
        view._size = length;
        return view._items.AsSpan(0, length);
    }

    // NOTE: These structure depndent on .NET 7, if changed, require to keep same structure.

    internal sealed class ListView&lt;T&gt;
    {
        public T[] _items;
        public int _size;
        public int _version;
    }
}

// MemoryPackReader.ReadSpanWithoutReadLengthHeader
public void ReadSpanWithoutReadLengthHeader&lt;T&gt;(int length, scoped ref Span&lt;T?&gt; value)
{
    if (length == 0)
    {
        value = Array.Empty&lt;T&gt;();
        return;
    }

    if (!RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())
    {
        if (value.Length != length)
        {
            value = AllocateUninitializedArray&lt;T&gt;(length);
        }

        var byteCount = length * Unsafe.SizeOf&lt;T&gt;();
        ref var src = ref GetSpanReference(byteCount);
        ref var dest = ref Unsafe.As&lt;T, byte&gt;(ref MemoryMarshal.GetReference(value)!);
        Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

        Advance(byteCount);
    }
    else
    {
        if (value.Length != length)
        {
            value = new T[length];
        }

        var formatter = GetFormatter&lt;T&gt;();
        for (int i = 0; i &lt; length; i++)
        {
            formatter.Deserialize(ref this, ref value[i]);
        }
    }
}
</code></pre>
<p><code>new List&lt;T&gt;(capacity)</code> や <code>List&lt;T&gt;.EnsurceCapacity(capacity)</code> によって、<code>List&lt;T&gt;</code>の抱える内部の配列のサイズを事前に拡大しておくことが可能です。これにより、都度拡大/コピーが内部で発生することを避けることができます。</p>
<p>その状態で <code>CollectionsMarshal.CreateSpan</code> を使うと、取得できるSpanは、長さ0のものです。なぜなら内部のsizeは変更されていないため、です。もし <code>CollectionMarshals.AsMemory</code>があれば、そこから<code>MemoryMarshal.TryGetArray</code>のコンボで生配列を取得できて良いのですが、残念ながら Span からは元になっている配列を取得する手段がありません。そこで、<code>Unsafe.As</code>で強引に型の構造を合わせて、<code>List&lt;T&gt;._size</code>を弄ることによって、拡大済みの内部配列を取得することができました。</p>
<p>そうすればunamanged型の場合はコピーだけで済ませてしまう最適化や、<code>List&lt;T&gt;.Add</code>(これは都度、配列のサイズチェックが入る)を避けた、<code>Span&lt;T&gt;[index]</code>経由での値の詰め込みが可能になり、従来のシリアライザのデシリアライズよりも遥かに高いパフォーマンスを実現しました。</p>
<p><code>List&lt;T&gt;</code>への最適化が代表的ではありますが、他にも紹介しきれないほど、全ての型を精査し、可能な限りの最適化をそれぞれに施してあります。</p>
<h2>まとめ</h2>
<p>なぜ開発しようかと思ったかというと、MessagePack for C#に不満がでてきたから、です。残念ながら .NET「最速」とはいえないような状況があり、その理由としてバイナリ仕様が足を引っ張っているため、改善するのにも限界があることには随分前から気づいていました。また、実装面でもIL生成とRoslynを使った外部ツールとしてのコードジェネレーター(mpc)の、二種のメンテナンスがかなり厳しくなってきているということもありました。外部ツールとしてのコードジェネレーターはトラブルの種で、何かと環境によって動かないということが多発していて、Source Generatorにフル対応できるのなら、もはや廃止したいぐらいにも思っていました。</p>
<p>そこに .NET 7/C# 11 の ref fieldやstatic abstract methodを見た時、これをシリアライザー開発に応用したらパフォーマンスの底上げが可能になる、ついでにSource Generator化すれば、いっそIL生成も廃止してSource Generatorに一本化できるのではないか？それならもう、それをMessagPack for C#に適用する前に、パフォーマンス向上に問題のあるバイナリ仕様の限界も無視した、C#のためだけに究極の性能を実現するシリアライザーを作って、本当の最速を実証してしまえばいいのでは？と。</p>
<p>性能特化の実験的シリアライザーではなくて、実用性も重視したシリアライザーであるために、MessagePack for C#での経験も元にして、多くの機能も備えるようにしました。</p>
<pre><code>* .NETのモダンI/O API対応(IBufferWriter&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, ReadOnlySequence&lt;byte&gt;)
* 既存オブジェクトへの上書きデシリアライズ
* ポリモーフィズムなシリアライズ(Union)
* PipeWriter/Readerを活用したストリーミングシリアライズ/デシリアライズ
* (やや限定的ながらも)バージョニング耐性
* TypeScriptコード生成
* Unity(2021.3)サポート
</code></pre>
<p>欠点としては、バージョニング耐性が、仕様上やや貧弱です。詳しくは<a href="https://github.com/Cysharp/MemoryPack#version-tolerant">ドキュメントを参照してください</a>。パフォーマンスをやや落としてバージョニング耐性を上げるオプションを追加することは検討しています。また、メモリコピーを多用するので、実行環境が little-endian であることを前提にしています。ただし現代のコンピューターはほぼすべて little-endian であるため、問題にはならないはずです。</p>
<p>パフォーマンスのために特化したstructを作ってメモリコピーする、といったことはC#の最適化のための手段として、そこまで珍しいわけではなく、やったことある人もいるのではないかと思います。そこからすると、あるいはこの記事を読んで、MemoryPackは一見ただのメモリコピーの塊じゃん、みたいな感じがあるかもしれませんが、汎用シリアライザーとして成立させるのはかなり大変で、そこをやりきっているのが新しいところです。</p>
<p>当初実現していなかった .NET 5/6(Standard 2.1)対応やUnity対応は完了したので、今後は<a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a>のSource Generator/MemoryPack対応や、<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>のシリアライザ変更対応など、利用できる範囲をより広げることを考えています。Cysharpの C#ライブラリ のエコシステムの中心になると位置づけているので、今後もかなり力入れて成長させていこうと思っていますので、まずは、是非是非試してみてください！</p>
</div>
<h1><a href="https://neue.cc/2022/07/13_Cancellation.html">async/awaitのキャンセル処理やタイムアウトを効率的に扱うためのパターン＆プラクティス</a></h1>
<ul class="date"><li>2022-07-13</li></ul>
<div class="entry_body"><p>async/awaitの鬼門の一つとして、適切なキャンセル処理が挙げられます。別に基本的にはそんな難しいことではなく、CancellationTokenSourceを作る、CanellationTokenを渡す、OperationCanceledExceptionをハンドリングする。というだけの話です。けれど、Tokenに手動でコールバックをRegisterしたときとか、渡す口が空いてないものに無理やりなんとかするときとか、タイムアウトに使った場合の始末とか、ちょっと気の利いた処理をしたいような場面もあり、そうした時にどうすれば良いのか悩むこともあります。</p>
<p>こういうのはパターンと対応さえ覚えてしまえばいい話でもあるので、今回は<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>の実装時に直面したパターンから、「外部キャンセル・タイムアウト・大元のDispose」が複合された状況での処理の記述方法と、適切な例外処理、そして最後にObjectPoolなども交えた効率的なゼロアロケーションでのCancellationTokenSourceのハンドリング手法を紹介します。</p>
<h2>CreateLinkedTokenSourceを使ったパターン</h2>
<p>何かのClientを実装してみる、ということにしましょう。キャンセル処理の最も単純なパターンは引数の末尾にCancellationTokenを用意して、内部のメソッドにひたすら伝搬させていくことです。きちんと伝搬させていけば、最奥の処理が適切にCancellationTokenをハンドリングしてキャンセル検知時にOperationCanceledExceptionを投げてくれます。CancellationTokenをデフォルト引数にするか、必ず渡す必要があるよう強制するかは、アプリケーションの性質次第です。アプリケーションに近いコードでは強制させるようにしておくと、渡し忘れを避けれるので良いでしょう。</p>
<pre><code class="language-csharp">class Client
{
    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        await SendCoreAsync(cancellationToken);
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // nanika...
    }
}
</code></pre>
<p>非同期メソッドのキャンセルはCancellationTokenで処理するのが基本で、別途Cancelメソッドを用意する、といったことはやめておきましょう。実装が余計に複雑化するだけです。CancellationTokenを伝搬させるのが基本であり全てです。</p>
<p>任意のキャンセルの他に、タイムアウト処理を入れたい、というのは特に通信系ではよくあります。async/awaitでのタイムアウトの基本は、タイムアウトもキャンセル処理の一つである、ということです。CancellationTokenSourceにはCancelAfterという一定時間後にCancelを発火させるというメソッドが用意されているので、これを使ってCancellationTokenを渡せば、すなわちタイムアウトになります。</p>
<pre><code class="language-csharp">// Disposeすると内部タイマーがストップされるのでリークしない
using var cts = new CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromMinutes(1));

await client.SendAsync(cts.Token);
</code></pre>
<blockquote>
<p><a href="https://github.com/Cysharp/UniTask">UniTask</a>ではCancelAfterSlimというメソッドが用意されているため、そちらを使うことをお薦めします。Cancelはスレッドプールを使いますが、CancelAfterSlimはPlayerLoop上で動くため、Unityフレンドリーな実装になっています。ただし内部タイマーのストップ手法がCancelAfterSlimの戻り値をDisposeする必要があるというように、実装に若干差異があります。</p>
</blockquote>
<p>タイムアウト時間は大抵固定のため、ユーザーに都度CancelAfterを叩かせるというのは、だいぶ使いにくい設計です。そこで、CancelAfterの実行はSendAsyncメソッドの内部で行うことにしましょう。そうした内部のタイムアウト用CancellationTokenと、外部からくるCancellationTokenを合成して一つのCancellationTokenに変換するには、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.createlinkedtokensource">CancellationTokenSource.CreateLinkedTokenSource</a>が使えます。</p>
<pre><code class="language-csharp">class Client
{
    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        // 連結された新しいCancellationTokenSourceを作る
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        cts.CancelAfter(Timeout);

        await SendCoreAsync(cts.Token);
    }

    // snip...
}
</code></pre>
<p>CreateLinkedTokenSourceで生成されたCancellationTourceは連結されたいずれかがCancelされると、生成されたCancellationTokenSource自体もCancelされます。また、それ自体からもCancelが発火できます。</p>
<p>これで完成！なのですが、このままだと例外処理に問題があります。</p>
<p>OperationCanceledExceptionは <code>CancellationToken</code>というプロパティを持っていて、これを元に呼び出し側はキャンセルの原因を判別することができます。一つ例を出しますが、以下のようにOperationCanceledExceptionをcatchしたうえで、更に判定を入れてコード分岐をかけることがあります。</p>
<pre><code class="language-csharp">try
{
    await client.SendAsync(token);
}
catch (OperationCanceledException ex) when (ex.CancellationToken == token)
{
    // Cancelの原因をTokenによって判定できる
}
</code></pre>
<p>例外を何も処理せずに全部おまかせでやると、投げられる OperationCanceledException.CancellationToken は CreateLinkedTokenSource で連結したTokenになってしまい、何の意味もない情報ですし、原因の判別に使うこともできません。</p>
<p>また、タイムアウトをOperationCanceledExceptionとして扱ってしまうことも問題です。OperationCanceledExceptionは特殊な例外で、既知の例外であるとしてロギングから抜いたりすることもままあります（例えばウェブサーバーでクライアントの強制切断(リクエスト中にブラウザ閉じたりとか)でキャンセルされることはよくあるけれど、それをいちいちエラーで記録していたらエラー祭りになってしまう）。タイムアウトは明らかな異常であり、そうしたキャンセルとは確実に区別して欲しいし、OperationCanceledExceptionではない例外になって欲しい。</p>
<p>これは .NET のHttpClientでも <a href="https://github.com/dotnet/runtime/issues/21965">HttpClient throws TaskCanceledException on timeout #21965</a> としてIssueがあがり(TaskCanceledExceptionはOperationCanceledExceptionとほぼ同義です)、大激論(121コメントもある！)を巻き起こしました。HttpClientはタイムアウトだろうが手動キャンセルだろうが区別なくTaskCanceledExceptionを投げるのですが、原因は、実装が上の例の通りCreateLinkedTokenSourceで繋げたもので処理していて、そして、特に何のハンドリングもしていなかったからです。</p>
<p>結論としてこれはHttpClientの設計ミスなのですが、一度世の中に出したクラスの例外の型を変更することは .NET の互換性維持のポリシーに反するということで（実際、これを変更してしまうと影響は相当大きくなるでしょう）、お茶を濁した対応(InnerExceptionにTimeoutExceptionを仕込んで、判定はそちら経由で一応できなくもないようにした)となってしまったのですが、今から実装する我々は同じ轍を踏んではいけない。ということで、ちゃんと正しく処理するようにしましょう。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    cts.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(cts.Token);
    }
    catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            // 引数のCancellationTokenが原因なので、それを保持したOperationCanceledExceptionとして投げる
            throw new OperationCanceledException(ex.Message, ex, cancellationToken);
        }
        else
        {
            // タイムアウトが原因なので、TimeoutException(或いは独自の例外)として投げる
            throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
        }
    }
}
</code></pre>
<p>やることは別に難しくはなく、OperationCanceledExceptionをcatchしたうえで、外から渡されたcancellationTokenがキャンセルされているならそれが原因、そうでないならタイムアウトが原因であるという判定をして、それに応じた例外を投げ直します。</p>
<p>最後に、Client自体がDisposeできるとして、それに反応するようなコードにしましょう。</p>
<pre><code class="language-csharp">class Client : IDisposable
{
    // IDisposableと引っ掛けて、Client自体がDisposeされたら実行中のリクエストも終了させるようにする
    readonly CancellationTokenSource clientLifetimeTokenSource;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.clientLifetimeTokenSource = new CancellationTokenSource();
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(clientLifetimeTokenSource.Token, cancellationToken);
        cts.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(cts.Token);
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cts.Token)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                // 引数のCancellationTokenが原因なので、それを保持したOperationCanceledExceptionとして投げる
                throw new OperationCanceledException(ex.Message, ex, cancellationToken);
            }
            else if (clientLifetimeTokenSource.IsCancellationRequested)
            {
                // クライアント自体がDisposeされたのでOperationCanceledException、或いは独自の例外を投げる
                throw new OperationCanceledException(&quot;Client is disposed.&quot;, ex, clientLifetimeTokenSource.Token);
            }
            else
            {
                // タイムアウトが原因なので、TimeoutException(或いは独自の例外)として投げる
                throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
            }
        }
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // nanika...
    }

    public void Dispose()
    {
        clientLifetimeTokenSource.Cancel();
        clientLifetimeTokenSource.Dispose();
    }
}
</code></pre>
<p>差分はCreateLinkedTokenSourceで連結するトークンを増やすのと、例外処理時の分岐を増やすことだけです。</p>
<h2>ゼロアロケーション化する</h2>
<p>殆どの場合は上記のパターンで全く問題ないのですが、都度CreateLinkedTokenSourceで新しいCancellationTokenSourceを作るのが気になる、かもしれません。どちらにせよasyncメソッドが非同期で実行される場合には、非同期ステートマシン自体のアロケーションが発生するので実際のところ別に気にするほどのことではない。のですが、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.sources.ivaluetasksource">IValueTaskSource</a>や<a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.poolingasyncvaluetaskmethodbuilder-1">PoolingAsyncValueTaskMethodBuilder</a>を使ったアロケーションを避ける非同期実装を行っていた場合には、相当気になる問題になってきます。また、HTTP/1のREST呼び出しのような頻度では大したことないですが、これが例えばサーバーで大量の並列実行をさばく、クライアントではリアルタイム通信で毎フレーム通信する、といった用途だと、この辺も気を配りたくなってくるかもしれません。</p>
<p>なお、ここでは説明の簡略化のために、SendAsyncメソッド自体はasync Taskのままにします。</p>
<p>まずは外部キャンセルのない、タイムアウトだけのケースを見ていきます。タイムアウトは正常系の場合は発火しない、つまり殆どの場合は発火しないため、非発火時にはCancellationTokenSourceを使い回すようにしましょう。</p>
<pre><code class="language-csharp">class Client
{
    // SqlConnectionのようなメソッドを多重に呼ぶことを禁止しているクラスの場合はフィールドにCancellationTokenSourceを一つ
    // HttpClientのようにあちこちから多重に呼ばれる場合があるものはObjectPoolで保持する

    readonly ObjectPool&lt;CancellationTokenSource&gt; timeoutTokenSourcePool;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.timeoutTokenSourcePool = ObjectPool.Create&lt;CancellationTokenSource&gt;();
    }

    public async Task SendAsync()
    {
        var timeoutTokenSource = timeoutTokenSourcePool.Get();
        timeoutTokenSource.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(timeoutTokenSource.Token);
        }
        finally
        {
            // Timeout処理が発火していない場合はリセットして再利用できる
            if (timeoutTokenSource.TryReset())
            {
                timeoutTokenSourcePool.Return(timeoutTokenSource);
            }
        }
    }
}
</code></pre>
<p>ObjectPoolの実装は色々ありますが、今回は説明の簡略化のために<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.objectpool">Microsoft.Extensions.ObjectPool</a>を使いました(NuGetからMicrosoft.Extensions.ObjectPoolを参照する必要あり)。タイムアウトが発動した場合は再利用不能なので、プールに戻してはいけません。なお、 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.tryreset">CancellationTokenSource.TryReset</a>は .NET 6 からのメソッドになります。それ以前の場合は <code>CancelAfter(Timeout.InfiniteTimeSpan)</code> を呼んでタイマー時間を無限大に引き伸ばす変更を入れる（内部的にはTimerがChangeされる）というハックがあります。</p>
<p>外部キャンセルが入る場合には、LinkedTokenを作らず、<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.unsaferegister">CancellationToken.UnsafeRegister</a>でタイマー用のCancellationTokenSourceをキャンセルするようにします。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    var timeoutTokenSource = timeoutTokenSourcePool.Get();

    CancellationTokenRegistration externalCancellation = default;
    if (cancellationToken.CanBeCanceled)
    {
        // 引数のCancellationTokenが発動した場合もTimeout用のCancellationTokenを発火させる
        externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);
    }

    timeoutTokenSource.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(timeoutTokenSource.Token);
    }
    finally
    {
        // Registerの解除(TryResetの前に「必ず」先に解除すること)
        // CancellationTokenRegistration.Disposeは解除完了（コールバック実行中の場合は実行終了）までブロックして確実に待ちます
        externalCancellation.Dispose();
        if (timeoutTokenSource.TryReset())
        {
            timeoutTokenSourcePool.Return(timeoutTokenSource);
        }
    }
}
</code></pre>
<p>CancellationToken.UnsafeRegisterは .NET 6 からのメソッドでExecutionContextをCaptureしないため、より高効率です。それ以前の場合はRegisterを使うか、呼び出しの前後でExecutionContext.SuppressFlow/RestoreFlowするというハックが使えます(UniTaskのRegisterWithoutCaptureExecutionContextはこの実装を採用しています)。</p>
<p>CancellationTokenにコールバックを仕込む場合、レースコンディションが発生する可能性が出てきます。この場合だとTimeout用のCancellationTokenSourceをプールに戻した後にCancelが発生すると、最悪なことになります。それを防ぐために、CancellationTokenRegistration.DisposeをTryResetの前に必ず呼びましょう。CancellationTokenRegistration.Disposeの優れているところは、コールバックが実行中の場合は実行終了までブロックして確実に待ってくれます。これによりマルチスレッドのタイミング問題ですり抜けてしまうといったことを防いでくれます。</p>
<p>ブロックといいますが、コールバックに登録されたメソッドがすぐに完了する性質のものならば、lockみたいなものなので神経質になる必要はないでしょう。<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokenregistration">CancellationTokenRegistration</a>にはDisposeAsyncも用意されていますが、むしろそちらを呼ぶほうがオーバーヘッドであるため、無理にDisposeAsyncのほうを優先する必要はないと考えています。CancellationTokenRegistrationには他にUnregisterメソッドもあり、これはfire-and-forget的に解除処理したい場合に有効です。使い分けですね。</p>
<p>なお、CancellationTokenへのコールバックのRegister(UnsafeRegister)は、初回はコールバック登録用のスロットを生成するといったアロケーションがありますが、Dispose/Registerを繰り返す二回目以降はスロットを再利用してくれます。このへんも新規に(Linked)CancellationTokenSourceを作るより有利な点となりますね。</p>
<p>引き続き、Client自体の寿命に引っ掛けるCancellationTokenを追加した実装を見ていきましょう。といっても、単純にRegisterを足すだけです。</p>
<pre><code class="language-csharp">class Client : IDisposable
{
    readonly TimeSpan timeout;
    readonly ObjectPool&lt;CancellationTokenSource&gt; timeoutTokenSourcePool;
    readonly CancellationTokenSource clientLifetimeTokenSource;

    public TimeSpan Timeout { get; }

    public Client(TimeSpan timeout)
    {
        this.Timeout = timeout;
        this.timeoutTokenSourcePool = ObjectPool.Create&lt;CancellationTokenSource&gt;();
        this.clientLifetimeTokenSource = new CancellationTokenSource();
    }

    public async Task SendAsync(CancellationToken cancellationToken = default)
    {
        var timeoutTokenSource = timeoutTokenSourcePool.Get();

        CancellationTokenRegistration externalCancellation = default;
        if (cancellationToken.CanBeCanceled)
        {
            // 引数のCancellationTokenが発動した場合もTimeout用のCancellationTokenを発火させる
            externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
            {
                ((CancellationTokenSource)state!).Cancel();
            }, timeoutTokenSource);
        }

        // Clientの寿命に合わせたものも同じように追加しておく
        var clientLifetimeCancellation = clientLifetimeTokenSource.Token.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);

        timeoutTokenSource.CancelAfter(Timeout);

        try
        {
            await SendCoreAsync(timeoutTokenSource.Token);
        }
        finally
        {
            // Registerの解除増量
            externalCancellation.Dispose();
            clientLifetimeCancellation.Dispose();
            if (timeoutTokenSource.TryReset())
            {
                timeoutTokenSourcePool.Return(timeoutTokenSource);
            }
        }
    }

    async Task SendCoreAsync(CancellationToken cancellationToken)
    {
        // snip...
    }

    public void Dispose()
    {
        clientLifetimeTokenSource.Cancel();
        clientLifetimeTokenSource.Dispose();
    }
}
</code></pre>
<p>例外処理も当然必要です！が、ここは最初の例のLinkedTokenで作ったときと同じです。</p>
<pre><code class="language-csharp">public async Task SendAsync(CancellationToken cancellationToken = default)
{
    var timeoutTokenSource = timeoutTokenSourcePool.Get();

    CancellationTokenRegistration externalCancellation = default;
    if (cancellationToken.CanBeCanceled)
    {
        externalCancellation = cancellationToken.UnsafeRegister(static state =&gt;
        {
            ((CancellationTokenSource)state!).Cancel();
        }, timeoutTokenSource);
    }

    var clientLifetimeCancellation = clientLifetimeTokenSource.Token.UnsafeRegister(static state =&gt;
    {
        ((CancellationTokenSource)state!).Cancel();
    }, timeoutTokenSource);

    timeoutTokenSource.CancelAfter(Timeout);

    try
    {
        await SendCoreAsync(timeoutTokenSource.Token);
    }
    catch (OperationCanceledException ex) when (ex.CancellationToken == timeoutTokenSource.Token)
    {
        // 例外発生時の対応はLinkedTokenで作ったときと特に別に変わらず

        if (cancellationToken.IsCancellationRequested)
        {
            throw new OperationCanceledException(ex.Message, ex, cancellationToken);
        }
        else if (clientLifetimeTokenSource.IsCancellationRequested)
        {
            throw new OperationCanceledException(&quot;Client is disposed.&quot;, ex, clientLifetimeTokenSource.Token);
        }
        else
        {
            throw new TimeoutException($&quot;The request was canceled due to the configured Timeout of {Timeout.TotalSeconds} seconds elapsing.&quot;, ex);
        }
    }
    finally
    {
        externalCancellation.Dispose();
        clientLifetimeCancellation.Dispose();
        if (timeoutTokenSource.TryReset())
        {
            timeoutTokenSourcePool.Return(timeoutTokenSource);
        }
    }
}
</code></pre>
<p>ということで、↑のものが最終形となりました。</p>
<p>async/awaitで実装されている場合、Tokenのコールバックも一メソッド内で収まっているために挙動の見通しがだいぶ良くなります。async/awaitを封印してIValueTaskSourceを使った実装をする場合は、複数のコールバックを手で処理する必要があり、また登録、発火する箇所も複数箇所にちらばってしまうため、遥かに複雑性が増します。</p>
<p>AlterNatsでは<a href="https://neue.cc/2022/05/11_AlterNats.html">ハイパフォーマンスSocketプログラミングとして実装を解説した記事</a>で、IValueTaskSourceをChannel（キュー）に詰め込むとしていますが、キャンセル時には<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.sources.manualresetvaluetasksourcecore-1">ManualResetValueTaskSourceCore</a>のSetExceptionを叩き、正常完了時にはSetResultの前でTryResetからのReturnするという、まぁ基本的な流れは一緒です。少し異なるのは、キャンセルで発火するのはawaitに紐付けられた継続処理だけで、実体はキューに残り続けていて、取り出し時にキャンセル状況をチェックして、何もしないようにする。といったことでしょうか。状況が複雑化する分、レースコンディション起因のバグが入り込みやすくなってしまうので、CancellationTokenRegistrationの挙動をしっかり把握して実装する必要があります。</p>
<h2>まとめ</h2>
<p>簡単かどうかでいうと、言われればなるほどそうですねーって感じですが、都度考えてやれって言われると結構難しいと思います。なので、こういうパターンなんですね、というのを頭に叩き込んでおくというのは重要だと思いますし、まぁとりあえず覚えてください。覚えれば、別にコード的に複雑というわけでもないので、易易と対処できるようになるはずです。</p>
<p><a href="https://github.com/StackExchange/StackExchange.Redis/">StackExchange.Redis</a>も非同期メソッド、CancellationTokenを受け取ってなかったりしますし、パフォーマンスを追求しつつCancellationToken対応を入れるのは、かなり難しい問題だったりします。しかしこの .NET 6世代ではかなりメソッドも増えていて、やろうと思えばやりきれるだけの手札が揃っています。なので、パターン化して真正面から立ち向かいましょう……！</p>
</div>
<h1><a href="https://neue.cc/2022/07/06_mvp-renew.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2022-07-06</li></ul>
<div class="entry_body"><p>12回目。一年ごとに再審査があって7月に一斉更新されるシステムになっていて、今年も継続しました。</p>
<p>元々、私の活動はオンライン一人自己完結型なので、C#布教活動（？）的にコロナの影響は一切受けていないのですが、勉強会開催などコミュニティ構築型の人だと影響を受けやすいここ数年だったのではないかと思います。ただ、やはりアフターコロナで人との繋がりは極度に減ったし、人の入れ替わり、新しい台頭みたいなのも少なくなってきたなあ、というのが肌間ありますね。改めて、コミュニティを維持してくれている人のありがたさを知りました。というわけで、C#コミュニティ盛り上がっていって欲しい！のですが、私自身のスタンスは変わらず、OSSで世の中に存在感を出していくことだとは思っています。</p>
<p>好不調の並が割と激しくて、ここ数ヶ月何もやってないわーみたいなときもよくあるのですが、年を通すと毎年3, 4個は新規にOSSをリリースしているし、既存ライブラリのメンテナンスやテコ入れ大型リニューアルも数個やっていたりするので、年間通して見ればかなりハイパフォーマンスで、それを10年以上継続してるんだから中々なんじゃないですか？と自画自賛したくなったり。</p>
<p>そんなこんなの活動を続けてきた結果、CEDECという国内最大のゲーム業界のカンファレンスでも<a href="https://cedec.cesa.or.jp/2022/event/awards">CEDEC AWARDS 2022</a>のエンジニアリング部門で、「.NET/Unity開発の可能性を広げるオープンソースソフトウェアの提供」として優秀賞を受賞しました。C#は元々裏方で便利に使っていたというのはありましたが、表でもガンガン使っていけるよ、といったC#の存在感は、高めていけてるんじゃないかと思います。CysharpとしてOSSを通じてC#の可能性を広げるということがしっかり伝わってるというのがとても嬉しいですね！参加者投票で部門別最優秀賞が決まるらしいので、是非投票を……！</p>
<p>また、今年は<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a>という記事で書きましたが、開発に関わっていた「プリコネ！グランドマスターズ」のリリースがありました。の事例発表をCEDEC 2022で<a href="https://cedec.cesa.or.jp/2022/session/detail/80">C#によるクライアント/サーバーの開発言語統一がもたらす高効率な開発体制 ～プリコネ！グランドマスターズ開発事例～</a>としてCygamesさんより発表があります。</p>
<ul>
<li>クライアント/サーバーの開発言語統一によるメリット</li>
<li>MagicOnion(gRPC)を利用したリアルタイムサーバー実装手法と具体例</li>
<li>Blazorを使用したツールの開発例、開発プロジェクトおよびソリューション統合管理の手法</li>
</ul>
<p>ということで、かなり面白い感じの内容になるのではないでしょうか、期待……！</p>
<p>C#がエンタープライズ業界（とは）で強いというのは重々承知だしAzureもシェア高くめっちゃ使われてるんだよ、という話は分かりはするのですが、to Cやスタートアップ企業で積極的に使われる言語になって欲しい、というのがずーっとの願いで、私自身もそうした業界に身をおいて、実績で示し続けて来たと思いますし、これからも引き続き道を示せるようにしていきたいです。</p>
<p>もちろん、ハイパフォーマンスなC#によって最前線での実力を見せていく、ということも変わらずに……！</p>
</div>
<h1><a href="https://neue.cc/2022/05/11_AlterNats.html">AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</a></h1>
<ul class="date"><li>2022-05-11</li></ul>
<div class="entry_body"><p>タイトルはここぞとばかりに全盛りにしてみました！今回NATSの.NETクライアント実装としてAlterNatsというライブラリを新しく作成し、公開しました。</p>
<ul>
<li><a href="https://github.com/Cysharp/AlterNats">github - Cysharp/AlterNats</a></li>
</ul>
<p>公式の既存クライアントの3倍以上、StackExchange.RedisのPubSubと比較して5倍以上高速であり、通常のPubSubメソッドは全てゼロアロケーションです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164392256-46d09111-ec70-4cf3-b33d-38dc5d258455.png" alt="image" /></p>
<p>そもそも<a href="https://nats.io/">NATS</a>とはなんぞやか、というと、クラウドネイティブなPubSubのミドルウェアです。<a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>のincubating projectなので、それなりの知名度と実績はあります。</p>
<p>PubSubというと、特にC#だと<a href="https://redis.io/">Redis</a>のPubSub機能で行うのが、<a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>という実績あるライブラリもあるし、AWSやAzure、GCPがマネージドサービスも用意しているしで、お手軽でいいのですが、盲目的にそれを使うのが良いのか少し疑問に思っていました。</p>
<p>RedisはKVS的な使い方がメインであり、PubSubはどちらかというとオマケ機能であるため</p>
<ul>
<li>PubSub専用のモニタリングの欠如</li>
<li>PubSub用のクラスタリング対応</li>
<li>マネージドサービスでの価格体系のバランスの悪さ（PubSub特化ならメモリはあまりいらない）</li>
<li>そもそものパフォーマンス</li>
</ul>
<p>といった点が具体的な懸念です。そして、NATSはPubSub専用に特化されているため、そのためのシステムが豊富に組まれているし、性能も申し分なさそうに思えました。しいて欠点を言えばマネージドサービスが存在しないのがネックですが、純粋なPubSubとしての利用ならば永続化処理について考える必要がないので、ミドルウェアとしては運用しやすい部類にはいるのではないかと思っています。（NATS自体はNATS JetStreamという機能によってAt-least / exactly onceの保証のあるメッセージングの対応も可能ですが、そこに対応させるにはストレージが必要になる場合もあります）</p>
<p>しかし調べていくうちに懸念となったのが公式クライアントである<a href="https://github.com/nats-io/nats.net">nats.net</a>で、あまり使いやすくないのですね。async/awaitにも対応していないし、古くさく、それどころかそもそも.NET的に奇妙に見えるAPIであり、そうなるとパフォーマンスに関しても疑問に思えてくる。</p>
<p>何故そうなっているかの理由はReadMeにも明記されていて、メンテナンス性のためにGoクライアント(ちなみにNATS Server自体はGoで書かれている)と同じようなコードベースになっている、と。そのためC#的ではない部分が多々あるし、GoとC#ではパフォーマンスを出すための書き方が全く異なるので、あまり良い状況ではなさそう。</p>
<p>それならば完全にC#に特化して独自に作ってしまうほうがいいだろうということで、作りました。公式クライアントと比べると全ての機能をサポートしているわけではない（JetStreamにも対応していないしLeaf Nodes運用で必須になるであろうTLSにも対応していません）のですが、PubSubのNATS Coreに特化して、まずは最高速を叩き出せるようにしました。PubSub利用する分には機能面での不足はないはずです。</p>
<p>AlterNatsは公式じゃないAlternativeなNATSクライアントという意味です。まんまですね。割と語感が良いので命名的には結構気に入ってます。</p>
<h2>Getting Started</h2>
<p>APIは、<code>nats.net</code>があまりにもC#っぽくなくややこしい、ということを踏まえて、シンプルに、簡単に、C#っぽく書けるように調整しました。</p>
<pre><code class="language-csharp">// create connection(default, connect to nats://localhost:4222)
await using var conn = new NatsConnection();

// for subscriber. await register to NATS server(not means await complete)
var subscription = await conn.SubscribeAsync&lt;Person&gt;(&quot;foo&quot;, x =&gt;
{
    Console.WriteLine($&quot;Received {x}&quot;);
});

// for publisher.
await conn.PublishAsync(&quot;foo&quot;, new Person(30, &quot;bar&quot;));

// unsubscribe
subscription.Dipose();

// ---

public record Person(int Age, string Name);
</code></pre>
<p>Subscribeでhandlerを登録し、Publishでメッセージを飛ばす。データは全て自動でシリアライズされます（デフォルトではSystem.Text.Json、MessagePack for C#を用いたハイパフォーマンスなシリアライズも可能な拡張オプションも標準で用意してあります）</p>
<p>別のURLへの接続や、認証のための設定などを行うNatsOptions/ConnectOptionsはイミュータブルです。そのため、with式で構築するやり方を取っています。</p>
<pre><code class="language-csharp">// Options can configure `with` operator
var options = NatsOptions.Default with
{
    Url = &quot;nats://127.0.0.1:9999&quot;,
    LoggerFactory = new MinimumConsoleLoggerFactory(LogLevel.Information),
    Serializer = new MessagePackNatsSerializer(),
    ConnectOptions = ConnectOptions.Default with
    {
        Echo = true,
        Username = &quot;foo&quot;,
        Password = &quot;bar&quot;,
    }
};

await using var conn = new NatsConnection(options);
</code></pre>
<p>NATSには標準で結果を受け取るプロトコルも用意されています。サーバー間の簡易的なRPCとして使うと便利なところもあるのではないかと思います。これも<code>SubscribeRequestAsync</code>/<code>RequestAsync</code>という形で簡単に直感的に書けるようにしました（Request側は戻り値の型を指定する必要があるため、型指定が少しだけ冗長になります）</p>
<pre><code class="language-csharp">// Server
await conn.SubscribeRequestAsync(&quot;foobar&quot;, (int x) =&gt; $&quot;Hello {x}&quot;);

// Client(response: &quot;Hello 100&quot;)
var response = await conn.RequestAsync&lt;int, string&gt;(&quot;foobar&quot;, 100);
</code></pre>
<p>例では <code>await using</code>ですぐに破棄してしまっていますが、基本的にはConnectionはシングルトンによる保持を推奨しています。staticな変数に詰めてもいいし、DIでシングルトンとして登録してしまってもいいでしょう。接続は明示的にConnectAsyncすることもできますが、接続されていない場合は自動で接続を開くようにもなっています。</p>
<p>コネクションはスレッドセーフで、物理的にも一つのコネクションには一つの接続として繋がり、全てのコマンドは自動的に多重化されます。これにより裏側で自動的にバッチ化された高効率な通信を実現していますが、負荷状況に応じて複数のコネクションを貼った場合が良いケースもあります。AlterNatsではNatsConnectionPoolという複数コネクションを内包したコネクションも用意しています。また、クライアント側で水平シャーディングを行うためのNatsShardingConnectionもあるため、必要に応じて使い分けることが可能です。</p>
<p>内部のロギングはMicrosoft.Extensions.Loggingで管理されています。<code>AlterNats.Hosting</code>パッケージを使うと、Generic Hostと統合された形で適切なILoggerFactoryの設定と、シングルトンのサービス登録を行ってくれます。</p>
<p>DIでの取り出しは直接NatsConnectionを使わずに、INatsCommandを渡すことで余計な操作（コネクションの切断など）が出来ないようになります。</p>
<pre><code class="language-csharp">using AlterNats;

var builder = WebApplication.CreateBuilder(args);

// Register NatsConnectionPool, NatsConnection, INatsCommand to ServiceCollection
builder.Services.AddNats();

var app = builder.Build();

app.MapGet(&quot;/subscribe&quot;, (INatsCommand command) =&gt; command.SubscribeAsync(&quot;foo&quot;, (int x) =&gt; Console.WriteLine($&quot;received {x}&quot;)));
app.MapGet(&quot;/publish&quot;, (INatsCommand command) =&gt; command.PublishAsync(&quot;foo&quot;, 99));

app.Run();
</code></pre>
<h2>メタバースアーキテクチャ</h2>
<p>Cysharpでは<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>という .NET/Unity で使えるネットワークフレームワークを作っているわけですが、AlterNatsはこれと絡めることで、構成の幅を広げることができると考えています、というかむしろそのために作りました。</p>
<p>クライアントにUnity、サーバーにMagicOnionがいるとして、サーバーが一台構成なら、平和です、繋げるだけですもの。開発の最初とかローカルでは楽なのでこの状態でもいいですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164406771-58318153-c6a7-49c0-b3af-2b8389e2c9c1.png" alt="image" /></p>
<p>しかし現実的にはサーバーは複数台になるので、そうなると色々なパターンが出てきます。よくあるのが、ロードバランサーを立ててそれぞれが別々のサーバーに繋がっているものを、更に後ろのPubSubサーバーを通して全サーバーに分配するパターン。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164409016-b6e99f36-bdf7-47a9-80a6-558010963a36.png" alt="image" /></p>
<p>これはNode.jsのリアルタイムフレームワークである<a href="https://socket.io/">Socket.IO</a>のRedisアダプター、それの.NET版である<a href="https://docs.microsoft.com/ja-jp/aspnet/signalr/overview/getting-started/introduction-to-signalr">SignalR</a>のRedisバックプレーン、もちろんMagicOnionにもあるのですが、このパターンはフレームワークでサポートされている場合も多いです。RedisのPubSubでできることはNATSでもできる、ということで、NATSでもできます。</p>
<p>これは各サーバーをステートレスにできるのと、スケールしやすいので、Chatなどの実装にはやりやすい。欠点はステートを持ちにくいので、クライアントにステートがあり、データのやり取りをするタイプしか実装できません。サーバー側にステートを持ったゲームロジックは持たせずらいでしょう（ステートそのものは各サーバーで共有できないため）。また、PubSubを通すことによるオーバーヘッドも気になるところかもしれません。</p>
<p>ロードバランサーを立てる場合、ロードバランサーのスティッキーセッションを活用して一台のサーバーに集約させるというパターンもあります（あるいは独自プロトコルでもリバースプロキシーを全面に立てて、カスタムなロジックで後ろの台を決定することもほぼ同様の話です）。ただし、色々なユーザーを同一サーバーに集約させたいようなケースでは、そのクッキーの発行誰がやるの、みたいなところは変わらずありますね。そこまで決めれるならIPアドレスを返して直繋ぎさせてしまってもいいんじゃないの？というのも真です。</p>
<p>そうした外側に対象のIPアドレスを教えてくれるサービスがいて、先にそれに問い合わせてから、対象のサーバーへ繋ぎに行くパターンは、古典的ですが安定です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/164417937-7d1adedb-36ee-453b-9ca6-9d41aded50af.png" alt="image" /></p>
<p>この場合は同一サーバーに繋ぎにいくためにサーバー内にインメモリでフルにステートを持たせることが出来ますし、いわゆるゲームループを中で動かして処理するようなこともできます。また、画面のないヘッドレスUnityなどをホストして、クライアントそのものをサーバー上で動かすこともできますね。</p>
<p>しかし、このパターンは素直なようでいて、実際VMだとやりやすいのですが、Kubernetesでやるのは難しかったりします。というのも、Kubernetesの場合は外部にIPが露出していないため、クラスター内の一台の特定サーバーに繋ぎにいくというのが難しい……！</p>
<p>このような場合に最近よく活用されているのが<a href="https://agones.dev/site/">Agones</a>というGoogleが主導して作っているKubernetesの拡張で、まさにゲーム向きにKubernetesを使えるようにするためのシステムです。</p>
<p>ただし、これはこれで難点があって、Agonesが想定しているゲームサーバーは1プロセス1ゲームセッション(まさにヘッドレスUnityのような)のホスティングであるため、1つのプロセスに多数のゲームセッションをホストさせるような使い方はそのままだと出来ません。コンテナなので、仮想的なプロセスを複数立ち上げればいいでしょ、というのが思想なのはわからなくもないのですが、現実的には軽量なゲームサーバー（それこそMagicOnionで組んだりする場合）なら、1プロセスに多数のゲームセッションを詰め込めれるし、これをコンテナで分けて立ち上げてしまうとコスト面では大きな差が出てしまいます。</p>
<p>さて、Cysharpではステートフルな、特にゲームに向いたC#サーバーを構築するための補助ライブラリとして<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>というゲームループを公開しています。このライブラリはこないだリリースした<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズ</a>でも使用していますが、従来MagicOnionと同居して使っていたLogicLooperを、剥がしたアーキテクチャはどうだろうか、という提案があります。（実際のプリコネ！グランドマスターズのアーキテクチャはMagicOnionと同居し、リバースプロキシーを使った方式を採用しているので（↑の画像のものに近い）、この案とは異なります）</p>
<p><img src="https://user-images.githubusercontent.com/46207/164417734-f2ec80e7-f12f-4a84-8252-ce28f9b53f05.png" alt="image" /></p>
<p>パーツが増えて複雑になったように見えて、この構成には大きな利点があります。まず、同居しているものがなくなったので複雑になったようで実はシンプルになっています。それぞれがそれぞれの役割にフルに集中できるようになるため、パフォーマンスも良くなり、かつ、性能予測もしやすくなります。特にロジックをフルに回転させるLogicLooperがクライアントや接続数の影響を受けずに独立できているのは大きな利点です。</p>
<p>ゲーム全体のステートはLogicLooper自体が管理するため、クライアントとの接続を直接受けているMagicOnion自体はステートレスな状態です。そのため、インフラ的にもロードバランサーの下にMagicOnionを並べるだけで済みますし、サーバー間の接続に伴う面倒事は全てNATSに押し付けられるため、インフラ管理自体はかなりシンプルな構成が取れます。</p>
<p>また、MagicOnion自体はステートを持てるシステムであり、各ユーザーそれぞれのステートを持つのは容易です（サーバーを越えなければいい）。そこで、LogicLooperから届いたデータのうち、繋がってるユーザーに届ける必要がないデータは、MagicOnionの持つユーザーのステートを使ってカリング処理をして、そもそも転送しなかったり間引いたりして通信量を削減することで、ユーザーの体験が良くなります。</p>
<p>各ユーザーから届くデータを使ったステート更新/データ送信に関しては、LogicLooperがゲームループ状になっているので、ループの間に溜まったデータをもとにしてバッチ処理を行えばいいでしょう。バッチ化というと、通信「回数」の削減のためのコマンドを単純にまとめあげて一斉送信するものと、内容を見て処理内容を縮小するパターンが考えられますが、LogicLooperを使ったアプローチでは後者を効率的に行なえます。前者のコマンドの一斉送信に関しては、AlterNatsが裏側で自動パイプライニング化としてまとめているので（後で詳しく説明します）、そこに関しても効率化されています。</p>
<p>このアーキテクチャで気になるのがPubSub通信のオーバーヘッドですが、それに関しての解決策がAlterNatsで、究極的に高速なクライアントがあれば（さすがにインメモリには到底及ばないとはいえ）、そもそものクライアントとサーバーの間にもネットワークがいるわけで、経路のトータルで見れば実用的な範囲に収められる。という想定で作りました。</p>
<p>ところで、そして究極的な利点は、全てC#で組めるということです。どういうことかというと、MagicOnionもLogicLooperも汎用的なC#フレームワークです。特別なプラグインを差し込んで処理するというわけではなくて、ふつーのC#コードをふつーに書くことで、それぞれの箇所に、アプリケーション固有のコードを仕込んでいくことができる。これが、本当の大きな利点です。専用のC++ミドルウェアを作って挟んで最適化できるぞ！などといったシステムは、素晴らしいことですが、専門性が高く再現性が低い。MagicOnionとLogicLooper、そしてAlterNatsを活用したこの構成なら、C#エンジニアなら誰でも（容易に）できる構成です。<a href="https://cysharp.co.jp/">Cysharp</a>のメッセージは「C#の可能性を切り開いていく」ですが、誰もが実現できる世界を作っていくというのが目標でもあります。</p>
<p>なお、ワーカーとしてのLogicLooperを作るに<a href="https://docs.microsoft.com/ja-jp/dotnet/core/extensions/workers">Worker Service</a>という.NET 6からのプロジェクトタイプが適切です。</p>
<h2>ハイパフォーマンスSocketプログラミング</h2>
<ul>
<li>Socket API</li>
</ul>
<p>C#で最も低レベルにネットワーク処理を扱えるクラスは<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socket">Socket</a>です。そして、非同期でハイパフォーマンスな処理を求めるなら<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socketasynceventargs">SocketAsyncEventArgs</a>をうまく再利用しながらコールバックを仕込む必要があります。</p>
<p>これは非常に厄介で些か難易度も高いのですが、現在はasync/awaitの時代、ちゃんとawaitできる***Asyncメソッド郡が用意されています。しかし、使ってはいけないAPI、使ってはいけないオーバーロードも並んでいるので、その選別が必要です。SocketのAPIは歴史的事情もあり混沌としてしまっているのです……。</p>
<p>使うべきAPIを分かりやすく見分ける手段があります。それは戻り値が <code>ValueTask</code> のものを選ぶことです。</p>
<pre><code class="language-csharp">public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken)
public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
public ValueTask&lt;int&gt; SendAsync(ReadOnlyMemory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken))
</code></pre>
<p>オーバーロードにはTask返しのものもあるので、気をつけてください。</p>
<pre><code class="language-csharp">// これらのAPIは使ってはいけない
public Task ConnectAsync(string host, int port)
public Task&lt;int&gt; ReceiveAsync(ArraySegment&lt;byte&gt; buffer, SocketFlags socketFlags)
public Task&lt;int&gt; SendAsync(ArraySegment&lt;byte&gt; buffer, SocketFlags socketFlags)
</code></pre>
<p>ValueTask返しのAPIは内部的には <code>AwaitableSocketAsyncEventArgs</code> というものがValueTaskの中身になるようになっていて、これがいい感じに使いまわされる(awaitされると内部に戻るようになっている）ことで、Taskのアロケーションもなく効率的な非同期処理を実現しています。<code>SocketAsyncEventArgs</code>の使いにくさとは雲泥の差なので、これは非常にお薦めできます。</p>
<p>また、同期APIはSpanを受け取れるのですが、非同期APIは（ステートをヒープに置く都合上）Memoryしか受け取れないことには注意してください。これはSocketプログラミングに限らず非同期系APIにおける一般的な話で、全体的に上手く組んでおかないと、Spanが使えないことが障壁になることがあります。必ず、Memoryで取り回せるようにしておきましょう。</p>
<ul>
<li>テキストプロトコルのバイナリコード判定</li>
</ul>
<p><a href="https://docs.nats.io/reference/reference-protocols/nats-protocol">NATSのプロトコル</a>はテキストプロトコルになっていて、文字列処理で簡単に切り出すことができます。実際これはStreamReaderを使うことで簡単にプロトコルの実装ができます。ReadLineするだけですから。しかし、ネットワークに流れるのは(UTF8)バイナリデータであり、文字列化は無駄なオーバーヘッドとなるため、パフォーマンスを求めるなら、バイナリデータのまま処理する必要があります。</p>
<p>NATSでは先頭の文字列(<code>INFO</code>, <code>MSG</code>, <code>PING</code>, <code>+OK</code>, <code>-ERR</code>など)によって流れてくるメッセージの種類が判定できます。文字列処理で空白でSplitして if (msg == &quot;INFO&quot;) などとすればめちゃくちゃ簡単ですが、先にも言った通り文字列変換は意地でも通しません。INFOは[73, 78, 70, 79]なので、Slice(0, 4).SequenceEqual で判定するのは悪くないでしょう。<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.sequenceequal"><code>ReadOnlySpan&lt;byte&gt;</code>のSequenceEqual</a>はめちゃくちゃ最適化されていて、長いものであれば必要であればSIMDとかも使って高速に同値判定します。LINQのSequenceEqualとは別物です！</p>
<p>しかし、もっと欲張って見てみましょう、プロトコルの識別子はサーバーから送られてくるものは全て4文字以内に収まっています。つまり、これはIntに変換しやすい状態です！というわけで、AlterNatsのメッセージ種判定コードはこうなっています。</p>
<pre><code class="language-csharp">// msg = ReadOnlySpan&lt;byte&gt;
if(Unsafe.ReadUnaligned&lt;int&gt;(ref MemoryMarshal.GetReference&lt;byte&gt;(msg)) == 1330007625) // INFO
{
}
</code></pre>
<p>これ以上速い判定はできないと思うので、理論上最速ということでいいでしょう。3文字の命令も、直後に必ずスペースや改行が来るので、それを含めた以下のような定数を使って判定に回しています。</p>
<pre><code class="language-csharp">internal static class ServerOpCodes
{
    public const int Info = 1330007625;  // Encoding.ASCII.GetBytes(&quot;INFO&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Msg = 541545293;    // Encoding.ASCII.GetBytes(&quot;MSG &quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Ping = 1196312912;  // Encoding.ASCII.GetBytes(&quot;PING&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Pong = 1196314448;  // Encoding.ASCII.GetBytes(&quot;PONG&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Ok = 223039275;     // Encoding.ASCII.GetBytes(&quot;+OK\r&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
    public const int Error = 1381123373; // Encoding.ASCII.GetBytes(&quot;-ERR&quot;) |&gt; MemoryMarshal.Read&lt;int&gt;
}
</code></pre>
<p>バイナリプロトコルなら特に何のひねりも必要なく実装できるので、バイナリプロトコルのほうが実装者に優しくて好きです……。</p>
<ul>
<li>自動パイプライニング</li>
</ul>
<p>NATSプロトコルの書き込み、読み込みは全てパイプライン（バッチ）化されています。これは<a href="https://redis.io/docs/manual/pipelining/">RedisのPipelining</a>の解説が分かりやすいですが、例えばメッセージを3つ送るのに、一つずつ送って、都度応答を待っていると、送受信における多数の往復がボトルネックになります。</p>
<p>メッセージの送信において、AlterNatsは自動でパイプライン化しています。<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">System.Threading.Channels</a>を用いてメッセージは一度キューに詰め込まれ、書き込み用のループが一斉に取り出してバッチ化します。ネットワーク送信が完了したら、再び送信処理待ち中に溜め込まれたメッセージを一括処理していく、という書き込みループのアプローチを取ることで、最高速の書き込み処理を実現しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/167585601-5634057e-812d-4b60-ab5b-61d9c8c37063.png" alt="image" /></p>
<p>ラウンドトリップタイムの話だけではなく（そもそもNATSの場合はPublish側とSubscribe側が独立しているので応答待ちというのもないのですが）、システムコールの連続した呼び出し回数を削減できるという点でも効果が高いです。</p>
<p>なお、.NET最高速ロガーである<a href="https://github.com/Cysharp/ZLogger/">ZLogger</a>でも同じアプローチを取っています。</p>
<ul>
<li>一つのオブジェクトに機能を盛る</li>
</ul>
<p>Channelに詰め込む都合上、データを書き込みメッセージオブジェクトに入れてヒープに保持しておく必要があります。また、書き込み完了まで待つ非同期メソッドのためのPromiseも必要です。</p>
<pre><code class="language-csharp">await connection.PublishAsync(value);
</code></pre>
<p>こうしたAPIを効率よく実装するために、どうしても確保する必要のある一つのメッセージオブジェクト（内部的にはCommandと命名されている）に、あらゆる機能を同居して詰め込みましょう。</p>
<pre><code class="language-csharp">class AsyncPublishCommand&lt;T&gt; : ICommand, IValueTaskSource, IThreadPoolWorkItem, IObjectPoolNode&lt;AsyncPublishCommand&lt;T&gt;&gt;

internal interface ICommand
{
    void Write(ProtocolWriter writer);
}

internal interface IObjectPoolNode&lt;T&gt;
{
    ref T? NextNode { get; }
}
</code></pre>
<p>このオブジェクト(<code>AsyncPublishCommand&lt;T&gt;</code>)自体は、T dataを保持して、Socketにバイナリデータとして書き込むための役割(<code>ICommand</code>)をまずは持っています。</p>
<p>それに加えて<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.sources.ivaluetasksource">IValueTaskSource</a>であることにより、このオブジェクト自身がValueTaskになります。</p>
<p>そしてawait時のコールバックとして、書き込みループを阻害しないためにThreadPoolに流す必要があります。そこで従来の<code>ThreadPool.QueueUserWorkItem(callback)</code>を使うと、内部的には <code>ThreadPoolWorkItem</code> を生成してキューに詰め込むため、余計なアロケーションがあります。 .NET Core 3.0から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.ithreadpoolworkitem">IThreadPoolWorkItem</a>を実装することで、内部の<code>ThreadPoolWorkItem</code>の生成をなくすことができます。</p>
<p>最後に、同居させることで必要なオブジェクトが1つになりましたが、その1つをプーリングしてゼロアロケーション化します。オブジェクトプールは<code>ConcurrentQueue&lt;T&gt;</code>などを使うと簡単に実装できますが、自分自身をStackのNodeにすることで、配列を確保しないで済むようにしています。また、Nodeの出し入れに関しては、今回のキャッシュの実装では正確に取り出せる必要性はないため、lockは使わず、マルチスレッドで競合が発生した場合はキャッシュミス扱いにして新規生成するようにしています。これはオブジェクトプーリングにおける性能バランスとしては、良いチョイスだと考えています。</p>
<pre><code class="language-csharp">internal sealed class ObjectPool&lt;T&gt;
    where T : class, IObjectPoolNode&lt;T&gt;
{
    int gate;
    int size;
    T? root;
    readonly int limit;

    public ObjectPool(int limit)
    {
        this.limit = limit;
    }

    public int Size =&gt; size;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPop([NotNullWhen(true)] out T? result)
    {
        // Instead of lock, use CompareExchange gate.
        // In a worst case, missed cached object(create new one) but it's not a big deal.
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            var v = root;
            if (!(v is null))
            {
                ref var nextNode = ref v.NextNode;
                root = nextNode;
                nextNode = null;
                size--;
                result = v;
                Volatile.Write(ref gate, 0);
                return true;
            }

            Volatile.Write(ref gate, 0);
        }
        result = default;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPush(T item)
    {
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            if (size &lt; limit)
            {
                item.NextNode = root;
                root = item;
                size++;
                Volatile.Write(ref gate, 0);
                return true;
            }
            else
            {
                Volatile.Write(ref gate, 0);
            }
        }
        return false;
    }
}
</code></pre>
<ul>
<li>Zero-copy Architecture</li>
</ul>
<p>Publish/Subscribeするデータは通常、C#の型をJSONやMessagePackなどにシリアライズしたものを流します。この場合、どうしてもbyte[]でやり取りすることが多くなります、例えばStackExchange.Redisの<code>RedisValue</code>の中身は実質byte[]で、送信にせよ受信にせよ、byte[]を生成して保持することになります。</p>
<p>これを避けるために、ArrayPoolから出し入れしてごまかしてゼロアロケーションにする、みたいなのはありがちではありますが、それでもコピーのコストが発生していることには代わりありません。ゼロアロケーションは当然目指すところですが、ゼロコピーに向けても頑張りましょう！</p>
<p>AlterNatsのシリアライザーはWriteに<code>IBufferWriter&lt;byte&gt;</code>, Readに<code>ReadOnlySequence&lt;byte&gt;</code>を要求します。</p>
<pre><code class="language-csharp">public interface INatsSerializer
{
    int Serialize&lt;T&gt;(ICountableBufferWriter bufferWriter, T? value);
    T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer);
}

public interface ICountableBufferWriter : IBufferWriter&lt;byte&gt;
{
    int WrittenCount { get; }
}
</code></pre>
<pre><code class="language-csharp">// 例えばMessagePack for C#を使う場合の実装
public class MessagePackNatsSerializer : INatsSerializer
{
    public int Serialize&lt;T&gt;(ICountableBufferWriter bufferWriter, T? value)
    {
        var before = bufferWriter.WrittenCount;
        MessagePackSerializer.Serialize(bufferWriter, value);
        return bufferWriter.WrittenCount - before;
    }

    public T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer)
    {
        return MessagePackSerializer.Deserialize&lt;T&gt;(buffer);
    }
}
</code></pre>
<p>System.Text.JsonやMessagePack for C#のSerializeメソッドには<code>IBufferWriter&lt;byte&gt;</code>を受け取るオーバーロードが用意されています。<code>IBufferWriter&lt;byte&gt;</code>経由でSocketに書き込むために用意しているバッファーにシリアライザが直接アクセスし、書き込みすることで、Socketとシリアライザ間でのbyte[]のコピーをなくします。</p>
<p><img src="https://user-images.githubusercontent.com/46207/167587816-c50b0af3-edaa-4a2a-b536-67aed0a5f908.png" alt="image" /></p>
<p>Read側では、<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.readonlysequence-1"><code>ReadOnlySequence&lt;byte&gt;</code></a>を要求します。Socketからのデータの受信は断片的な場合も多く、それをバッファのコピーと拡大ではなく、連続した複数のバッファを一塊として扱うことでゼロコピーで処理するために用意されたクラスが<code>ReadOnlySequence&lt;T&gt;</code>です。</p>
<p>「ハイパフォーマンスの I/O をより簡単に行えるように設計されたライブラリ」である<a href="https://docs.microsoft.com/ja-jp/dotnet/standard/io/pipelines">System.IO.Pipelines</a>の<code>PipeReader</code>で読み取ったものを扱うのが、よくあるパターンとなります。ただし、AlterNatsではPipelinesは使わずに独自の読み取り機構と<code>ReadOnlySequence&lt;byte&gt;</code>を使用しました。</p>
<p>System.Text.JsonやMessagePack for C#のSerializeメソッドには<code>IBufferWriter&lt;byte&gt;</code>を受け取るオーバーロードが用意されているため、それを直接渡すことができます。つまり、現代的なシリアライザは<code>IBufferWriter&lt;byte&gt;</code>と<code>ReadOnlySequence&lt;byte&gt;</code>のサポートは必須です。これらをサポートしていないシリアライザはそれだけで失格です。</p>
<h2>まとめ</h2>
<p>プロトコルが単純で少ないのでちゃちゃっと作れると思いきや、まあ確かに雑にTcpClientとStreamReader/Writerでやれば秒殺だったのですが、プロトコルって量産部分でしかないので、そこがどんだけ量少なかろうと、基盤の作り込みは相応に必要で、普通に割と時間かかってしまった、のですが結構良い感じに作れたと思います。コード的にも例によって色々な工夫が盛り込まれていますので、是非ソースコードも読んでみてください。</p>
<p>クライアント側の実装によってパフォーマンスが大きく違うというのはシリアライザでもよくあり経験したことですが、NATSのパフォーマンスを論じるにあたって、その言語のクライアントは大丈夫ですか？というところがあり、そして、C#は大丈夫ですよ、と言えるものになっていると思います。</p>
<p>NATSの活用に関してはこれからやっていくので実例あるんですか？とか言われると知らんがな、というところですが（ところでMagicOnionはこないだの<a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズ</a>だけではなく最近特によくあるので、実例めっちゃあります）、これから色々使っていこうかなと思っているので、まぁ是非AlterNatsと共に試してみてください。</p>
</div>
<h1><a href="https://neue.cc/2022/04/08_priconne-grandmasters.html">プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</a></h1>
<ul class="date"><li>2022-04-08</li></ul>
<div class="entry_body"><p>Cygamesから4/1にリリースされた<a href="https://priconne-grandmasters.jp/">プリコネ！グランドマスターズ</a>のサーバーサイドとインフラ開発をCysharpが開発協力しました。リアルタイム通信を含むオートバトラー系のゲームです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/162343388-734840a1-4b7d-467b-902c-1e06e527d208.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/162401207-d9e2bceb-6b94-435c-8e63-d96ce62cf97b.png" alt="image" /></p>
<p>Cysharpはサーバー側のアーキテクチャ設計と基盤実装、クラウドインフラ構築、一部サーバーロジック実装を担いました。リアルタイム通信部分だけではなくてAPIサーバーからマッチメイキング、インフラまで、構成されるあらゆる要素がC#で作られています！</p>
<ul>
<li>クライアント (Unity)</li>
<li>API サーバー(MagicOnion)</li>
<li>バトルエンジンサーバー (リアルタイム通信; MagicOnion, LogicLooper)</li>
<li>マッチメイキングサーバー (リアルタイム通信; MagicOnion)</li>
<li>バッチ(ConsoleAppFramework)</li>
<li>デバッグ機能サーバー (Web; Blazor)</li>
<li>管理画面サーバー (Web; Blazor)</li>
<li>インフラ (Infrastructure as Code; <a href="https://www.pulumi.com/">Pulumi + C#</a>)</li>
</ul>
<p>サーバー側アプリケーションは.NET 6をKubernetes上で動かしています。Unityクライアント側でも<a href="https://github.com/Cysharp/">CysharpのOSS</a>は7つクレジットされていますが、表記のないサーバー側専用のものを合わせたら10個以上使用しています。ここまで徹頭徹尾C#でやっているプロジェクトは世界的にも珍しいんじゃないでしょうか。中心的に活躍しているのは<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>ですが、サーバーサイドゲームループのための<a href="https://github.com/Cysharp/LogicLooper">LogicLooper</a>、負荷テストのための<a href="https://github.com/Cysharp/DFrame/">DFrame</a>なども実戦投入されて、成果を出しました。サーバートラブルも特になく、しっかり安定稼働しました。という事後報告です。そして今日、もとより期間限定公開ということで一週間の配信期間が終了しました。</p>
<p>アーキテクチャ含めの詳しい話は後日どこかでできるといいですね……！今回、私は実装者としては裏方というか監督というかという感じなので、発表する際は別の人にお任せします……！</p>
<p>C#でのサーバー構成をまた一つ実証できて、参考になって欲しいのですが（そしてC#採用事例増えて欲しい！）、こういった構成を、Cysharpだから出来る、のではなくて、誰もが実現できる環境にしていきたいとも思っています。重要なパーツは積極的にOSS化していますし、実績も着実に積み重ねられています。が、しかしまだまだ難しい面も数多くあるということは認識しています。かといってmBaaSの方向でやっていくべき、とは思わないんですね。ロジックはゲームの差別化のための重要な要素であり、サーバーサイドでも書くべきで。だから注力しているのは書きやすくするための環境で、そのために足りないものを提供していっています。</p>
<p>ところでサーバーとクライアントの繋ぎ、あるいはサーバーとサーバーの繋ぎが、MagicOnionだけだと複雑で難しくなってしまうところがあるな、と思っていまして、ちょうど先月-今月はメッセージングライブラリの開発に注力しています。<a href="https://github.com/Cysharp/AlterNats">AlterNats</a>という名前でPreview公開していますが、これを挟むと色々改善されるんじゃないかなあ、と思っているので、少々お待ち下さい。そんな感じに、常により最善のC#アーキテクチャの探究と、OSSを通じた共有をまだまだ続けていきます。</p>
</div>
<h1><a href="https://neue.cc/2022/02/28_DFrame.html">DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</a></h1>
<ul class="date"><li>2022-02-28</li></ul>
<div class="entry_body"><p>と、いうものをリリースしました。Web UIとなるDFrame.Controllerと、負荷テストシナリオをC#で書くDFrame.Workerの組み合わせで成り立っていて、DFrame.Workerをウェブ上のクラスターに配置することで(Controllerと接続するただの常駐アプリなので、配置先はオンプレでもVMでもコンテナでもKuberenetesでもなんでもいい)、1から数千のワーカーが連動して、大量のリクエストを発生させます。また、テストシナリオをプレーンなC#で記述できるということは、HTTP/1だけではなく、あらゆる種類の通信をカバーできます。WebSocket、HTTP/2、gRPC、MagicOnion、あるいはPhotonや自作のTCPトランスポート、更にはRedisやデータベースなどが対象になります。</p>
<p>DFrame.Workerは通常の.NETの他に、Unityにも対応しています！つまり、大量のHeadless Unity、あるいはデバイスファームに配置することで、Unityでしか動かないような独自通信フレームワークであっても負荷テストをかけることが可能です。</p>
<p>また、あまり注目されていませんが負荷テストツールにもパフォーマンスの違いは「かなり」あり、性能の良さは重要で、そこのところにもかなりチューニングしました。</p>
<ul>
<li><a href="https://github.com/Cysharp/DFrame/">github - Cysharp/DFrame</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/46207/155904375-084a199b-a473-4bc6-8362-009d214bd009.png" alt="image" /></p>
<p>Web UI(DFrame.Controller)はBlazor Serverで作られていて、分散ワーカーとの通信はMagicOnionで行っています。自動化のためのWeb APIの口もあるため、Blazor Server, ASP.NET Minimum API, MagicOnionのキメラ同居なアーキテクチャでC#でフル活用なのが設計的にも面白いポイントです。</p>
<h2>C#で負荷テストシナリオを書く意義</h2>
<p>負荷テストフレームワークは世の中に山のようにあります。代表的なものでも<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">ab</a>, <a href="https://jmeter.apache.org/">jMeter</a>, <a href="https://k6.io/">k6</a>, <a href="https://www.artillery.io/">Artillery</a>, <a href="https://gatling.io/">Gatling</a>, <a href="https://github.com/wg/wrk">wrk</a>, <a href="https://github.com/codesenberg/bombardier">bombardier</a>, <a href="https://locust.io/">Locust</a>、k6やArtillery、GatlingなどはSaaSとしても提供していますし、クラウドサービス側も、<a href="https://azure.microsoft.com/ja-jp/services/load-testing/">Azure Load Testing(Managed jMeter)</a>のようなマネージドサービスを出していますし、.NETでも<a href="https://github.com/dotnet/crank">dotnet/crank</a>というものが存在していたりします。</p>
<p>DFrameはこの中でいうとアーキテクチャ含めLocustに近い(Controller-Worker構成やWebUIなど)のですが、その特徴の中で重要な点として挙げられているのが、シナリオをコードで書けること、です。よくわからんUIで設定させたり、複雑怪奇なXMLやYAMLやJSON書かせたりせず、プレーンなコードで書ける。これが大事。LocustはPythonですが、他にk6はJavaScriptで書けるようになっています。</p>
<p>じゃあLocustでいいじゃん、k6でいいじゃん、という話になるのですが、C#で書きたいんですね、シナリオを。これは別にただ単に自分の好きな言語で書きたいからというわけではなくて、サーバーあるいはクライアント言語と負荷試験シナリオ作成言語は同一のものであるべきだからです。例えばUnityのゲームを開発している場合（サーバーサイドの言語は何でもいい）、UnityのゲームはC#で記述されていますが、その場合C#でテストシナリオが書けるのなら</p>
<ul>
<li>最初からクライアントSDK(エンドポイントと型付きのRequest/Response)に相当するものがある</li>
<li>クライアントの実装と完全に等しいのでゲームのドメインロジックが最初からある</li>
</ul>
<p>となります。それによりテストシナリオの記述の手間を大幅に削減できます。もちろん、Unity依存の部分を引き剥がすなどの追加の作業は必要ですが、完全に書き起こすなどといった無駄は発生しません。もしPythonでもJavaScriptでもLuaでも、とにかく異なる言語である場合は、比較にならないほどに作業量が膨大になってきます。</p>
<p>そして実際のクライアントコードとある程度共通になることで、サーバー/クライアント側の変化への追随が用意になります。それにより一回のリリースのための負荷テストではなく、継続的な負荷テスト環境を作っていけます。</p>
<p>また、プレーンなC#で記述できることで、冒頭にも書きましたがあらゆる通信の種類をカバーできるのは、通信プロトコルが多様化している昨今、大きな利点となります。</p>
<h2>DFrameApp.Run</h2>
<p>NuGetからDFrameをパッケージ参照したうえで、一行で起動します。テストシナリオ(Workload)の記述の行数もありますが、それでもこれだけで。</p>
<pre><code class="language-csharp">using DFrame;

DFrameApp.Run(7312, 7313); // WebUI:7312, WorkerListen:7313

public class SampleWorkload : Workload
{
    public override async Task ExecuteAsync(WorkloadContext context)
    {
        Console.WriteLine($&quot;Hello {context.WorkloadId}&quot;);
    }
}
</code></pre>
<p>これで <code>http://localhost:7312</code> をブラウザで開けば、<code>SampleWorkload</code>がいます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155892546-c00f1554-0e2c-4e11-acdd-f0d9be9c40c9.png" alt="image" /></p>
<p>と、いうわけで、WorkloadのExecuteAsyncにコードを書くのが基本です。ExecuteAsync前の準備用としてSetupAsync、後始末としてTeardownAsyncもあります。単純なgRPCのテストを書くとこなります。</p>
<pre><code class="language-csharp">public class GrpcTest : Workload
{
    GrpcChannel? channel;
    Greeter.GreeterClient? client;

    public override async Task SetupAsync(WorkloadContext context)
    {
        channel = GrpcChannel.ForAddress(&quot;http://localhost:5027&quot;);
        client = new Greeter.GreeterClient(channel);
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await client!.SayHelloAsync(new HelloRequest(), cancellationToken: context.CancellationToken);
    }

    public override async Task TeardownAsync(WorkloadContext context)
    {
        if (channel != null)
        {
            await channel.ShutdownAsync();
            channel.Dispose();
        }
    }
}
</code></pre>
<p>Concurrencyの数だけWorkloadが生成されて、Total Request / Workers / Concurrencyの数だけExecuteAsyncが実行されます。コードで書くと言っても別にそう複雑なこともなく、よくわからんDSLで書くわけでもないので、むしろ(C#が書けるなら)とても書きやすいでしょう。中身も見てのとおり単純なので、gRPCでもMagicOnionでも何でも実行できます。</p>
<p>引数を受け取ることも可能なので、任意のURLを渡すようなものも作れます。コンストラクタでは、パラメーター、あるいはDIでインジェクトしたインスタンスを受け取れます。</p>
<pre><code class="language-csharp">using DFrame;
using Microsoft.Extensions.DependencyInjection;

// use builder can configure services, logging, configuration, etc.
var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureServices(services =&gt;
{
    services.AddSingleton&lt;HttpClient&gt;();
});
await builder.RunAsync();

public class HttpGetString : Workload
{
    readonly HttpClient httpClient;
    readonly string url;

    // HttpClient is from DI, URL is passed from Web UI
    public HttpGetString(HttpClient httpClient, string url)
    {
        this.httpClient = httpClient;
        this.url = url;
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await httpClient.GetStringAsync(url, context.CancellationToken);
    }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/155893829-fc9f5e9d-fb05-4bcc-b8ee-6067be674b51.png" alt="image" /></p>
<p>WebUI画面にString urlの入力箇所が現れて、好きなURLを叩き込むことができるようになりました。</p>
<p>なお、単純なHTTPのGET/POST/PUT/DELETEをテストしたいという場合は、IncludesDefaultHttpWorkloadを有効にしてもらうと、内蔵のパラメーターを受け取るWorkloadが追加されます。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureWorker(x =&gt;
{
    x.IncludesDefaultHttpWorkload = true;
});
builder.Run();
</code></pre>
<h2>分散テスト</h2>
<p>Workerは起動時に指定したControllerのアドレスにHTTP/2(MagicOnion/gRPC)で繋ぎに行って、常駐します。という普通の（？）アプリケーションなので、ウェブサーバーを分散させるのと同様に複数のWorkerを立ち上げてもらえれば、自動的に繋がります。</p>
<p>構成としては、以下の画像のようにControllerとWorkerのプロジェクトを分けるのが正当派（？）ですが</p>
<p><img src="https://user-images.githubusercontent.com/46207/154921606-b9955331-1d15-4c4f-a769-faeb61b13872.png" alt="" /></p>
<p>同居させてしまって、起動時のコマンドライン引数でどちらかのモード（あるいは両方）が起動するようにすることも、ローカルでの開発がしやすくなるのでお薦めです。 <code>DFrameApp.CreateBuilder</code> にはそのための補助的な機構が用意されています。</p>
<pre><code class="language-csharp">using DFrame;

var builder = DFrameApp.CreateBuilder(5555, 5556); // portWeb, portListenWorker

if (args.Length == 0)
{
    // local, run both(host WebUI on http://localhost:portWeb)
    await builder.RunAsync();
}
else if (args[0] == &quot;controller&quot;)
{
    // listen http://*:portWeb as WebUI and http://*:portListenWorker as Worker listen gRPC
    await builder.RunControllerAsync();
}
else if (args[0] == &quot;worker&quot;)
{
    // worker connect to (controller) address.
    // You can also configure from appsettings.json via builder.ConfigureWorker((ctx, options) =&gt; { options.ControllerAddress = &quot;&quot; });
    await builder.RunWorkerAsync(&quot;http://foobar:5556&quot;);
}
</code></pre>
<p>ローカルでWorkerの.exeを複数実行する、とかでも手元でとりあえずのWorker connectionsが増える様は確認できます。</p>
<p>Workerを増やすと表がにぎやかになって楽しい。実行するWorkerの数はスライダーで調整できるので、各種パラメーターを台数1で調整したあとに、徐々に実行Workerを増やしていく、といった使い方も可能です。また、その辺を自動でやってくれるRepeatモード(TotalRequestとWorkerを完了後に指定数増やして繰り返す)も用意しました。jMeterでいうところのRamp-Upの代わりに使えればいいかな、という想定でもあります。</p>
<p>アーキテクチャ的に最初から分散前提で作られているというのもあり、増やしても性能が劣化しない、リニアに性能が向上していくように作りました。Controllerは単一なのでスケールしないのですが、なるべく多くのWorkerをぶら下げられるように工夫しています。Controller &lt;-&gt; WorkerはMagicOnionで通信しているので、DFrame自身がMagicOnionの負荷テストになっているのです。</p>
<h2>パフォーマンス</h2>
<p>多数ある負荷テストフレームワークですが、パフォーマンスはそれぞれかなり異なります。詳しくはk6のブログ<a href="https://k6.io/blog/comparing-best-open-source-load-testing-tools/">Open source load testing tool review 2020</a>に非常に詳細に書かれていますが、例えばとにかくwrkがぶっちぎって他の数十倍~数百倍速かったりする、と。パフォーマンスは当然ながらとても重要で、ワーガーの非力さでターゲットに負荷をかけきれなかったりします。それに対応するためクラスターを組んでいくにしても、多くの台数やより高いスペックのマシンが必要になって、色々と辛い。</p>
<p>というわけでパフォーマンスは高ければ高いほうがいいのですが、先のブログに書かれている通り、拡張性の口やレポート取り出しの口などは必要です。その点でWrkは機能を満たさないということで、ブログではなんか結果から取り除かれてますね（その対応がいいのかどうかはなんとも言えませんが、まぁk6自身のアピールのためでもあるのでしょうがないね）。ちなみにフレームワークのパフォーマンスの指標として使われている<a href="https://www.techempower.com/benchmarks/">TechEmpower Web Framework Benchmarks</a>の負荷クライアントはwrkのようです。</p>
<p>さて、で、DFrameはどうかというと、かなり良好です。というのも、DFrameはライブラリとして提供されて、実行時は全てがC#の実行ファイルとしてコンパイル済みの状態になるのですね。スクリプトを動的に読んで実行するから遅くなってしまう、みたいなことがない。比較的高速な言語であるC#をそのまま利用するので、その時点である程度はいける。理論上。理屈上。</p>
<p>と、いう甘い見込みのもと実際作っていくと、さすがにそこまでさっくりとはいかず、相応にチューニングが必要だったのですが、最終的にはかなりの数字が出るようになりました。比較としてabとk6で測ってみると</p>
<p><img src="https://user-images.githubusercontent.com/46207/155854372-6cd3976c-fb08-4ddb-b4a8-75235421cfc8.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854390-a2360f29-956f-4ace-a848-ecc03c79cb21.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/155854413-969e59c2-a914-4131-b3d7-f1f50591413b.png" alt="image" /></p>
<p>本来はターゲットとワーカーは別マシンにしないといけないのですが(ワーカーの負荷でCPUが跳ね上がる影響をサーバー側がモロに影響受けてしまうので)、それでもそれなりに数字は変動しますし動きはするしマシンパワーも結構強め(Ryzen 9 5950x)なので、ちょっと手抜きでlocalhost上の無を返すHTTP/1サーバーをターゲットに、32並列(-c 32, -32VUs, Concurrency=32)で実行。</p>
<p>abが、6287 req/sec、k6が125619 req/sec、DFrameが207634 req/secです。abは、厳しい、厳しい……。もっと出るはずと思っているんですが、私の環境(Windows)だと昔からこんな感じなので、性能的には信用できないかなぁ。Windowsだとダメだったりするのかもしないのかもしれませんね。DFrameの場合Concurrencyにまだ余裕があって、増やすとまだまだ伸びたのですが、k6は割と頭打ちでした。</p>
<p>また、画像は出してませんがLocustは残念ながらかなり遅い上にCPUを食いまくるという感じで(Pythonだしね……）、いくらクラスタ化が容易とはいえ、ここまで1ワーカーあたりの性能が低いと、ないかなあ、という感想です。JMeterはそこまで悪くはないですが、パフォーマンスに影響を与える地雷コンフィグを必死にかいくぐってなおそこそこ程度なのはしんどみ。</p>
<p>ちなみになんで圧倒的性能番長であるwrkと比較しないのかというと、Windowsで動かすのが大変だからです。すみません……。</p>
<h2>自動化のためのREST API</h2>
<p>最初はいいけど、毎回GUIでポチポチやるの面倒で、それはそれで嫌だよね。CIで定期的に回したりもできないし。というわけで、バッチ起動モード、はついていないのですが、代わりにREST APIが自動で有効になっています。例えば <code>/api/connections</code> で現在接続中のワーカーコネクション数が取れます。実行パラメーターなどはPostでJSONを投げる形になっています。</p>
<p>REST APIでJSONをやり取りするだけなので、どの言語から叩くことも可能ですが、C#の場合は <code>DFrame.RestSdk</code> パッケージにて型付けされたクライアントが用意されているので、手間なくはじめられます。</p>
<pre><code class="language-csharp">using DFrame.RestSdk;

var client = new DFrameClient(&quot;http://localhost:7312/&quot;);

// start request
await client.ExecuteRequestAsync(new()
{
    Workload = &quot;SampleWorkload&quot;,
    Concurrency = 10,
    TotalRequest = 100000
});

// loadtest is running, wait complete.
await client.WaitUntilCanExecute();

// get summary and results[]
var result = await client.GetLatestResultAsync();
</code></pre>
<p>実行状況は全て連動しているので、REST APIから実行した進捗もWeb UI側でリアルタイムに状況確認できます。</p>
<h2>Unityでも動く</h2>
<p>Unityで動かしやすいかといったら全然そんなことないので、動かせるようにするのはもはや執念という感じではあるのですが、Unity対応しました。冒頭で書いたようにヘッドレスUnityを並べてコントロールする、みたいな用途は考えられます。まぁ、あと普通の負荷テストでも、通信部分のC#を普通の .NET に切り出すのが面倒だという場合に、ヘッドレスUnityでとりあえずビルドすることで何もしなくてもOK（そうか？）という策もあります。</p>
<p>Unityで動かす場合は、依存の解決(MagicOnion、gRPC、MessagePack for C#)が大変です！まぁ、それは置いておいて。それが出来ているなら、以下のようなMonoBehaviourに寿命をくっつけたインスタンスで起動させると良い感じです（MagicOnionというかネイティブgRPCは適切にコネクションをCloseしないとUnity Editorがフリーズするという酷い問題があるのですが、このコードは問題なくちゃんとクリーンアップしてくれるようになっています）。</p>
<pre><code class="language-csharp">public class DFrameWorker : MonoBehaviour
{
    DFrameWorkerApp app;

    [RuntimeInitializeOnLoadMethod]
    static void Init()
    {
        new GameObject(&quot;DFrame Worker&quot;, typeof(SampleOne));
    }

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }

    async void Start()
    {
        // setup your controller address
        app = new DFrameWorkerApp(&quot;localhost:7313&quot;);
        await app.RunAsync();
    }

    private void OnDestroy()
    {
        app.Dispose();
    }
}

[Preserve]
public class SampleWorkload : Workload
{
    public override Task ExecuteAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Exec&quot;);
        return Task.CompletedTask;
    }

    public override Task TeardownAsync(WorkloadContext context)
    {
        Debug.Log(&quot;Teardown&quot;);
        return Task.CompletedTask;
    }
}

// Preserve for Unity IL2CPP

internal class PreserveAttribute : System.Attribute
{
}
</code></pre>
<p>Editor上の確認だとこんな具合です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/155901725-4ce8a36f-46e9-4437-aba7-639425f4b93f.png" alt="image" /></p>
<h2>ライブラリかツールか</h2>
<p>DFrame.Controller、他の設定を入れなければただのウェブアプリなので、ビルド済みのexeとしての提供も可能です。Locustなど他のツールも入れたら、とりあえず実行できる、のに比べると、必ず自分で組み込んでビルドしなきゃいけない。のは欠点に見える。</p>
<p>なのでビルド済みコンテナをDocker Hubかなんかで提供するという案もあったのですが、Workerはどうしても自分で組み込んでビルドする必要があるので、そこだけ省けても利点あるのかな？と考えて、最終的に却下しました。かわりに <code>DFrameApp.Run</code> の一行だけでController+Workerの同居が起動できるようにして、最初の一歩の面倒臭さをライブラリデザインの工夫で乗り切ることにしました。Controller自体も、<code>Microsoft.NET.Sdk.Web</code>ではなく、コンソールアプリケーションのテンプレートの<code>Microsoft.NET.Sdk</code>から起動できるようにしました。</p>
<p>DFrame.Controllerがライブラリとして提供されていることのメリットは、コンフィグが通常のコードやASP.NETの仕組みに乗っかったほうが圧倒的にシンプルになります。DIで好きなロガーを設定して、URLの指定やSSLなどもappsettings.jsonで行うのは、大量の複雑怪奇なコマンドラインオプションよりもずっと良いでしょう。</p>
<p>ログの永続化処理も、プラグイン的に用意するのではなく、普通にDIでインジェクトしてもらう(<code>IExecutionResultHistoryProvider</code>というものが用意されていて、これを実装したものをDIに登録してもらえば、結果をデータベースに入れたり時系列DBに入れたりして統計的な参照ができるようになります)ほうが、使いやすいはずです。</p>
<h2>Blazor Server + MagicOnion</h2>
<p>DFrame.ControllerはBlazor ServerとMagicOnion(grpc-dotnet)が同居した構成になっています。これは中々面白い構成で、Web UIとMagicOnion(Server側)が同じメモリを共有しているので、末端のMagicOnion(Client側)の変更をダイレクトにC#だけを通してブラウザにまで届けているんですね。逆もしかりで、APIからのアクセス含めて、全てがリアルタイムに伝搬して画面も同期しているのですが、普通にやるとかなり複雑怪奇になるはずが、かなりシンプルに実装できています。</p>
<p>と、いうわけで、Cysharpではこの組み合わせに可能性を感じていて、別のサービスも同種のアーキテクチャで絶賛制作中なので興味ありましたら以下略。</p>
<h2>紆余曲折</h2>
<p>最初のバージョンは2年ぐらい前に作っていました。コンセプトは「自己分裂する分散バッチフレームワーク」ということで、自分自身のコピーを動的に作って無限大に分散して実行していくというもので。分散のための基盤としてKubernetesを使って。クラウドネイティブ！かっこいい！そして、一応動くものはできていました。あとは仕上げていくだけ、といったところで、放置していました。完成させなきゃ、と思いつつ、内心薄々あんまいい感じではないな、と思っていたため手が進まず無限放置モードへ。そして時が流れ、社内でもがっつり使うことになり引っ張り出されてきたそれは、やはりあまりいい感じではなく。で、最終的に言われたんですね、そもそも分裂機能いらなくね？と。</p>
<p>それでようやく気づくわけです、コンセプトから完全に間違っているからうまくいくわけがない！</p>
<p>反省として良くなかった理由としては、まず、現代のクラウドコンピューターを過大に評価していた。「自己分裂する」のは、一瞬で無限大にスケールして即起動、そして終わったら即終了、ならば、まぁそれでいいんですが、現実のスケールする時間はそんなに立派じゃない。サーバーレスといいつつ、別に1リクエスト毎にコンテナが起動して処理するわけはなく、常駐してリクエストを待つ。そりゃそうだ、と。自己分裂のコンセプトだと、分裂コストが重たいのは否めない。</p>
<p>もう一つは分裂するためのコードがDFrame内に記述されている。Kuberentesをコントロールするコードがたっぷり入ってしまって。そのせいでコードサイズが膨らんでしまったし、使う方も複雑なコンフィグをDFrame側に埋めなきゃいけなくなってしまった。これは二重にイケてない。作るのも複雑で、使うのも複雑ですからね、いいところがない……。</p>
<p>と、いうわけで、最初のかっこいいコンセプトを否定して、自己分裂しない。単純に繋ぎに行くだけ。としたことで、頭を抱えてうまくいかないと感じていた行き詰まりは解消したのでした。</p>
<h2>まとめ</h2>
<p>もう少し早くに作って提供したかった、という後悔がめっちゃあるのですが、同時に .NET 6だから出来たという要素もめっちゃあるので(パラメーター渡しの仕組みなどは<a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4</a>の設計の経験からスムーズに実装できた)、しょーがない。という気もする。Blazor Serverなどの進化も必要だったし。</p>
<p>しかし↑で書いたとおり最初に立てたコンセプトが間違っていて、長いこと軌道修正できず放置してしまっていたというのは個人的には割と手痛い経験です……。まぁ、間違ったコンセプトのまま進行してしまうというのは別によくあるので、それはしょーがないものとして別にいいんですが、自力で気づいてパーッと作り上げられてたらなあ、みたいな、みたいな。。。</p>
<p>ともあれ、完成したものとしてはかなり良い感じで（私の出すものとしては珍しくUIもちゃんとついているし！←UI作業は他の人に助力を請うてます）、ちょっとニッチ感もありますがC#アプリケーション開発の必需品として成り得る出来だと思っていますので、ぜひぜひお試しください。</p>
</div>
<h1><a href="https://neue.cc/2022/01/09_WebSerializer.html">WebSerializer - オブジェクトからクエリストリングに変換するHttpClientリクエスト用シリアライザ</a></h1>
<ul class="date"><li>2022-01-09</li></ul>
<div class="entry_body"><p><code>T value</code>から URLエンコードされたクエリストリング、または<code>x-www-form-urlencoded</code>なHttpContentを生成する、つまりはウェブ(HTTP/1)リクエスト用のシリアライザを作りました。</p>
<ul>
<li><a href="https://github.com/Cysharp/WebSerializer/">github.com/Cysharp/WebSerializer</a></li>
</ul>
<p>クエリストリングの生成、意外と面倒くさいな！と。(C#用の)専用のSDKが存在しないWeb APIの場合は、自分でURL組み立てたり<code>FormUrlEncodedContent</code>を組み立てたりしますが、数が多いとまぁ面倒くさい。リクエストのパラメーター数が多いと、null抜いたりも面倒くさい。</p>
<p>レスポンス側は<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.http.json.httpcontentjsonextensions.readfromjsonasync?view=net-6.0">ReadFromJsonAsync</a>などでダイレクトに変換できるようになって特に問題はないのですが、リクエスト側は、かなりの手作業が要求されます。そのへんを全部やってくれる<a href="https://github.com/reactiveui/refit">refit</a>というライブラリもありますが(Androidの<a href="https://github.com/square/retrofit">retrofit</a>にインスパイアされたもの)、導入するにはちょっと大仰だな、と思うときも多々あります、というか私は今まで一度も使ってません。</p>
<p>HttpClient用にURLを組み立てるのを簡略化してくれるぐらいでいいな、と思って考えていたら、そういえばそもそもそれってT valueから何かに変換する、つまりシリアライザじゃん、ということに気づきました。T -&gt; msgpack byte[]に変換すればMessagePackシリアライザだし、T -&gt; Json stringに変換すればJSONシリアライザだし、これはT -&gt; UrlEncoded stringに変換するということなのだと。シリアライザ脳なので、そう理解すれば話が早い。</p>
<pre><code class="language-csharp">using Cysharp.Web;

var req = new Request(sortBy: &quot;id&quot;, direction: SortDirection.Desc, currentPage: 3)

// sortBy=id&amp;direction=Desc&amp;currentPage=3
var q = WebSerializer.ToQueryString(req);

await httpClient.GetAsync(&quot;/sort?&quot;+ q);

// data...
public record Request(string? sortBy, SortDirection direction, int currentPage);

public enum SortDirection
{
    Default,
    Asc,
    Desc
}
</code></pre>
<p>基本的に使うメソッドは <code>WebSerializer.ToQueryString</code> か <code>WebSerializer.ToHttpContent</code> だけです。URLエンコードされてname=valueで&amp;連結された文字列が取り出せます。メソッドとして叩いたりする場合は、そのまま匿名型で渡してあげればちょうど良い。urlも一緒に渡してあげれば全て同時に組み立ててくれます。値が<code>null</code>のものは文字列化対象から自動で外されます。</p>
<pre><code class="language-csharp">const string UrlBase = &quot;https://foo.com/search&quot;;

// null, SortDirection.Asc, 0
async Task SearchAsync(string? sortBy, SortDirection direction, int currentPage)
{
    // &quot;https://foo.com/search?direction=Asc&amp;currentPage=0&quot;
    var url = WebSerializer.ToQueryString(UrlBase, new { sortBy, direction, currentPage });
    await httpClient.GetAsync(url);
}
</code></pre>
<p>動的に組み立てる場合は、<code>Dictionary&lt;string, object&gt;</code> も渡せます。(<code>FormUrlEncodedContent</code>は<code>Dictionary&lt;string, string&gt;</code>で、Value側のToString()が必須なのが地味に面倒くさいので、<code>object</code>で良いというのは何気に楽だったりします)。</p>
<pre><code class="language-csharp">var req = new Dictionary&lt;string, object&gt;
{
    { &quot;sortBy&quot;, &quot;id&quot; },
    { &quot;direction&quot;, SortDirection.Desc },
    { &quot;currentPage&quot;, 10 }
};
var q = WebSerializer.ToQueryString(req);
</code></pre>
<p>POST用には、<code>ToHttpContent</code>を使います。</p>
<pre><code class="language-csharp">async Task PostMessage(string name, string email, string message)
{
    var content = WebSerializer.ToHttpContent(new { name, email, message });
    await httpClient.PostAsync(&quot;/postmsg&quot;, content);
}
</code></pre>
<p>内部的には<code>FormUrlEncodedContent</code>は使わずに、専用のHttpContentを通しているため、<code>byte[]</code>変換のオーバーヘッドがありません。</p>
<h2>シリアライザ設計</h2>
<p>ただたんにクエリストリング組み立てるだけっしょ！というと軽く見られてしまうかもしれないのですが、中身はかなりガチめに作ってあって、構成としては<a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C#</a>と同様です。パフォーマンスに関しても超ギチギチに詰めているわけではないですが、かなり気を配って作られているので、手で組み立てるよりもむしろ高速になるケースも多いはずです。拡張性もかなり高く作れているはずです。</p>
<p>シリアライザのデザインに関してはMessagePack for C#の次期バージョン(v3)をどうしていこうかなあ、と考えているタイミングでもあるので、そのプロトタイプ的な意識もありますね。なので設計としてはむしろ最新型で、かなり洗練されています。.NET 5/6のみにしているので、レガシーも徹底的に切り捨てていますし。最初は .NET 6のみだったのですが、さすがにそれはやりすぎかと思い .NET 5は足しました。（が、2022-01-21のv1.3.0にて、.NET Standard 2.0/2.1対応もしました）</p>
<p>例えばコンフィグ(<code>WebSerializerOptions</code>)はイミュータブルなのですが、これ自体はrecordで作ってあってwith式でカスタムのコンフィグを作れます。</p>
<pre><code class="language-csharp">// CultureInfo: 数値型やDateTimeの文字列化変換に渡すCultureInfo、デフォルトはnull
// CollectionSeparator: 配列などを変換する場合のセパレーター、デフォルトはnullでname=value&amp;name=value...
// Provider: 対象の型をどのように変換するか(`IWebSerialzier&lt;T&gt;`)の変更
var newConfig = WebSerializerOptions.Default with
{
    CultureInfo = CultureInfo.InvariantCulture,
    CollectionSeparator = &quot;,&quot;,
    Provider = WebSerializerProvider.Create(
        new[] { new BoolZeroOneSerializer() },
        new[] { WebSerializerProvider.Default })
};

// Bool値を0, 1に変換する（こういうの求めてくるWeb APIあるんですよねー！）
public class BoolZeroOneSerializer : IWebSerializer&lt;bool&gt;
{
    public void Serialize(ref WebSerializerWriter writer, bool value, WebSerializerOptions options)
    {
        // true =&gt; 0, false =&gt; 1
        writer.AppendPrimitive(value ? 0 : 1);
    }
}
</code></pre>
<p><code>IWebSerializer&lt;T&gt;</code>のインターフェイスについて、<code>ref T value</code>にしようか検討したのですが、最終的にやめました。</p>
<pre><code class="language-csharp">public interface IWebSerializer&lt;T&gt; : IWebSerializer
{
    void Serialize(ref WebSerializerWriter writer, T value, WebSerializerOptions options);
}
</code></pre>
<p><code>ref T value</code>にすると、プロパティをそのまま渡せなくて、かなり面倒くさくなってね。理屈的にはlarge structに対するコピーコスト削減、ではあるけれど、まぁこのままだと99%効力ないかなあ、という感じがあり。入り口だけinにして一回分コピーを消すぐらいを落とし所にしました、とりあえず今回は。</p>
<pre><code class="language-csharp">public static string ToQueryString&lt;T&gt;(in T value, WebSerializerOptions? options = default)
</code></pre>
<p>それとSource Generator対応についても考えましたが、まぁ一旦今回は見送って、後でやるかもという感じでしょうか。アイディアは色々ありますが、まずは作ってみないとうまくハマるか見えないところがあるし、MessagePack for C#のような大きなものでドカンとやるよりは、最初は小さなものでテストしていくのが良いものを作る正攻法でもありますね。</p>
<h2>Deserializeがない問題</h2>
<p>ASP.NET CoreのAddControllerなら、Model Bindingでデシリアライズできるので、不要でしょう。.NET 6時点でのMinimal APIだとなんと自動モデルバインディングがなくて手動でQueryStringから組み立てるという手間が必要になってて、まぁそこでは必要かなあ？と思ったんですが、いや、それしたいならMinimal APIではなくてAddControllerしろや、と思ったので、機能入れるのやめました。実際、そのうちバインディング自体はいれるそうです（さすがに不便なので）。</p>
<h2>まとめ</h2>
<p>手で組み立てている人は結構多いと思うので、使えるシチュエーションはかなりあると思ってます。ただまあ、こんぐらいなら手でやるよ！と思う人は多いと思うので、その点ではニッチかなあ、というところですね。Web APIの仕様によってはリクエストパラメーターが微妙にデカくてイライラすることがあったり、まぁあとは数を作るときにはやっぱダルいので、ハマるシチュエーションも少なくはないかな、と。</p>
<p>とりあえずは試してみてもらえればと思います。</p>
</div>
<h1><a href="https://neue.cc/2021/12/31.html">2021年を振り返る</a></h1>
<ul class="date"><li>2021-12-31</li></ul>
<div class="entry_body"><p>例年、30日に投稿しているはずなのですが、今年は、どうしても今年中に作りきりたいという思いで<a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4</a>のリリースをしてしまったので31日で。今年の後半から道具をガラーッと変えて、それがいい感じに作用していったので、なんか満足した気でいます。</p>
<h2>Heyをとにかく薦めたい</h2>
<p>今年良かったもの第一位は<a href="https://hey.com/">Hey</a>です。Ruby on Rails作者のDHHがやってる会社(Basecamp)のメールサービスなのですが、これが抜群によく出来てる！今までメール一ヶ月放置は当たり前、未読1万件、みたいな状態だったのですが、After Heyでは未読0。すごい。メーラー変えただけでこんな変わるとは。よく出来たツールは人を変えるね。</p>
<p>どうしてもたまりがちな、スパムではないけど自分にとってはスパムに等しいもの（なんだかんだで送られてくる広告メールとかね）を、実質スパム扱いして、一生このメールは見ないという設定をワンポチでできるのが小気味よい。ワンポチどころか、最初のメール受信時に強制的に決めさせることで（決めないとメールが受信ボックスに入らないので、決めるしかない）、最初に使うときの罪悪感というか、とはいえ見るかもしれないしー、役に立つときもあるかもしれないしー、みたいななんとなくある抵抗感みたいなのを、その手で実行させ続けることにより薄れさせていく手腕は見事というほかない。</p>
<p>メールを3分類、読むものとフィード的に見るもの（メルマガとかGitHubのWatchとか）と、領収書系で分けたというのもセンスを感じる。領収書は、例えばKindleで購入するたびに買いましたメールは、捨てるのもアレだけど別に自明すぎて見たくはない、ものが溜まっていくとメールボックスがウザいことになる、を専用の置き場を用意しました、で解決しているのはなるほどなー、と。フィード的なのは全部連結されているので、スクロールさせてバッと流し見で終わらせられるのも良い。</p>
<p>細かいフィルターはできないけど、そもそも細かいフィルターなんて作るの面倒だしメンテ不能になるだけだから作るんじゃねえ、俺達の考えた最高のRailに乗ってりゃあいいんだよ、という押し付けがましさ全開の思想性溢れるのが、いいですね。そういうの、嫌いじゃないです。DHHの語るプログラミング的な思想も好きですしね、私は。Rubyは使いませんが、DHHの思想には納得できるものがめちゃくちゃ多くて割と好きなので。</p>
<p>メールアドレスという、なんだかんだで変えられない、変えにくいものなのに、 <code>hey.com</code> を使え！というのは中々ハードル高いのですが(基本的に汎用メーラーとしては使えず、専用メールアドレスが必要。GMailのクライアントにもPOP3クライアントにもならない)、今回私は10年以上使ってきたプロバイダのメールアドレスが不慮の事故により完全消滅したので、思い切って乗り換えることができました。結果、良かった。怪我の功名ということで。</p>
<h2>iPad miniがとにかく良い</h2>
<p>タブレットは、というかiPadはなんだかんだで今まで色々なサイズのものを買ってきました。普通のもAirもPro 13インチも。そしてほとんど全く使わなかったのですが……！なんか面倒くさくてねー、重いしー、と。で、iPhoneがPro Maxで大きいから、そこまでサイズ変わらないしねえと思ってminiだけは手を出さなかったのですが、世間でiPad mini 6があまりにも評判がいいので、じゃあまぁ試してみるかと買ったら、なるほど納得！これは超いい！最高……！</p>
<p>やっぱ重さとサイズ感ですかね。これなら手軽に持ち運べる（今の時期コートとかだったらポケットにすら入る）し、片手で持てるというのが読みやすさにもめっちゃ寄与してる。デカいと手も疲れるし、ちゃっと手にとってソファで読もうとかいう気になれなかったわけですが、このサイズ感は絶妙、でした。大きさ的にも全然iPhone Pro Maxよりは明らかに大きくて、雑誌も十分読めるレベルで、漫画は快適。</p>
<p>iPad miniのサイズのままで高級路線（有機EL積んでもらうとか）して欲しいですね。</p>
<p>で、とても気に入ったので、いい感じのスタンドないかなあと思って選んだのが<a href="https://www.moftjapan.com/products/moft-x-tablet-stand">MOFT X</a>。ちょうどiPad mini 6用のサイズのものが出たのでこれがまた快適。どこでもいつでもさっくりスタンドになるのがこんなに良いとは。厚すぎない/重すぎないので、背中に常時貼り付けている状態でも苦にならないし。なんだったらカメラの出っ張り（うざい！）が相殺されて、平らなところにおいてもガタつかなくなったのが最高。</p>
<h2>5K2Kは捗る</h2>
<p>家の作業環境に割と不満があって、特にモニタ環境が良くなかった（32インチ4K + WQXGAの組合わせ、別に悪くはないんですけどね）ので、5K2K(5120x2160)モニタに変更。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147818725-e1529666-172f-40fe-aa69-0491a27091d9.png" alt="image" /></p>
<p>現状だとこの解像度は<a href="https://www.dell.com/ja-jp/shop/dell-u4021qw-40%E3%82%A4%E3%83%B3%E3%83%81%E3%83%AF%E3%82%A4%E3%83%89%E6%9B%B2%E9%9D%A2usb-c-hub-%E3%83%A2%E3%83%8B%E3%82%BF-5k2k-21-9-ips%E9%9D%9E%E5%85%89%E6%B2%A2-tbhdmix2dprj45-%E9%AB%98%E3%81%95%E8%AA%BF%E6%95%B4/apd/210-aypy/%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC-%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B5%E3%83%AA%E3%83%BC">Dell U4021QW</a>一択。40インチは大きいかなーと思ったんですが、横に長いから高さ的には今まで使ってた32インチとそう変わらず、ですかね。デカいっちゃあデカですが、こんなもんかな、という感じでもある。この机も横1200の机でそんあ大きい机じゃないんですが、ジャストサイズぐらいで収まりますし。</p>
<p>人によっては100%サイズで使うのは小さい、と思ってしまいそうなところですが、私的には人体改造済み(<a href="https://www.sannoclc.or.jp/hospital/icl/">ICL</a>というレンズを眼球に埋める手術をしたので)なので問題なし、ということで100%サイズで使っています。</p>
<p>このサイズ、いい感じに視野に全部収まるので、デュアルやトリプルよりも快適さあります。今まで、最大で5画面ぐらいまでモニタ増やしてきたのですが、結局メイン以外のものは首をふるのもダルくてそんなに使える感じではないし、音楽プレイヤーのプレイリストを並べるとかだったら、置いてるiPadで聞いて表示しとけばいいじゃん、ということで、全然問題なし。</p>
<p>ツール補助がないとウィンドウがとっちらかってしまうので、Microsoft PowerToysの<a href="https://docs.microsoft.com/ja-jp/windows/powertoys/fancyzones">FancyZones</a>を使って割り振ってます。これのグリッド吸着がまた使いやすくて(Shift押しながら移動すると、事前定義したグリッドに張り付く)いいですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147815474-6deb6990-da99-44e0-9d29-c2c39917395e.png" alt="image" /></p>
<p>中央を広めに取りつつ(主にVisual Studioか、ブラウザがっつし見たりするときはブラウザを置く)、右にブラウザ、左は半分に割って下にGitKraken、上にExplorerみたいなパターンが多めでしょうか。Visual Studio + Unityとか、作業域的に大きく取りたいものを並べる場合は2分割のグリッドパターンも用意して、切り替えるようにしています。</p>
<p>3分割みたいなのは、5K2Kぐらいの解像度がないと出来ないので、この解像度のモニタ増えてくれーって感じですね。選択肢がDELLしかないのは寂しい。液晶自体の画質もそんな良いわけでもないので、もう少し良いのが欲しい。しっかりしたHDR対応のが欲しい。120Hz出るのが欲しい。とか、思うところはそれなりにあります。とはいえ、それでも大満足です。もうこれ以外の解像度のモニタには戻りたくないなあ。</p>
<p>と、いうわけで、モニタ変更のためにゴミ溜めだった机をキレイにした記念で、来年はずっとすっきりした机をキープするぞ、という強い気持ちがあります！単純に机がキレイになってたほうが作業やりやすいですしねー、やっぱゴミ溜めはダメですよ。</p>
<p>キーボードをREALFORCE R3にしたのですが（前はR2でした）、今回からデフォ無線なんですね。キーボードなんて置きっぱなしだから別に有線でいいだろ、と思ってたんですが、これはこれでアリというか、めっちゃいいじゃん？と。サッとキーボードどかしたりがやりやすくなったのがいいですね、デスクで他の作業がやりやすくて。Bluetoothだから、そのままiPadやiPhoneに繋げてもいいし。いやあ、時代は無線。ケーブルがなくなってすっきりするし。</p>
<p>と、いうわけで、無線環境が気に入ったので、デカい有線ヘッドフォン＋ヘッドフォンアンプを使っていたのですが(MDR-Z1R + TA-ZH1ES、合計40万もした)、撤去して、写真には写ってませんがAirPods Max買いました。これも満足。いやー、正直あんま有線ヘッドフォン使ってなかったんですよね、面倒くさくて。電源入れるだけ、ではありんですがやっぱ面倒くさくて。ケーブル太くて邪魔くさいし（無駄にケーブル換装して太いケーブルにしてしまったのも良くなかった）。PC専用になっちゃってiPhoneの音も聞けないし。</p>
<p>AirPods MaxだとiPhone/iPad/PCの切り替えが自由なのが想像の100億倍良いなあ、と。音質面でも悪くないし、Apple Musicの空間オーディオとの相性は抜群でこれはめちゃくちゃいいし、さすがのヘッドフォン型なのでAirPods Proよりも音がいい。デジタルクラウンによる音量調整は最高に便利。ゲーム用に<a href="https://www.dolby.com/jp/ja/apps/access.html">Dolby Access</a>入れてDolby Atmos for Headphonesを有効化してますが、これもなかなか良い。</p>
<p>スピーカーも置いてたんですが、撤去しました。簡単なものはモニタ内蔵のしょぼいスピーカーで済ませる。ちゃんと聴きたい場合はAirPods Max。それでいいや、と。割り切ったら、全然それでいいじゃん、という気になりました。そもそもあまりデスクトップのスピーカーを稼働させてないしなあ、というのもありますが。</p>
<h2>時代は無線</h2>
<p>スピーカー撤去の代わりに、じゃないのですが、今年はホームシアターシステムとして<a href="https://www.sony.jp/home-theater/products/HT-A9/">HT-A9</a>を導入したのですが、これも満足度高い。何がいいって、設置が無線で自由度高い。なんか今年は無線化の年ですね、時代は無線。</p>
<p>昔は9.1chにしてたり5.1chだったりでスピーカー並べてたのですが、諸事情あってここ数年はサウンドバーを使ってたんですが、とにかくその音質には不満だったんですね。かといってリアスピーカー並べる気力も起きずというか、そのスペースも確保できない状態なのでどうしたものか、と思っていたところに出たのが、フル無線4.1chシステムのHT-A9。360 Spatial Sound MappingでDolby Atomos時代なサラウンドにするという謳い文句もいいし、設置レイアウトが自由というのがいい。オフィシャルサイトのこの画像を見て購入を決めました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147816734-1c61b5b5-3150-47e0-b4f1-23aa0973f436.png" alt="image" /></p>
<p>HT-A9の画像、どれもフロントスピーカーの置き方が「わざとらしく」でたらめなんですよね、高さを絶対揃えない。これは、メーカーが別に高さ揃えなくていいんですよ、と推奨してるということなんですが、実際うちでの設置環境もフロントの高さは揃ってないです。揃えられないので。リアも位置も高さもグチャグチャで、適当における棚に置いてるだけって感じです。フロントもリアも無線スピーカーなので、そういう適当配置がめっちゃやりやすい。</p>
<p>それでもちゃんとサウランドするし、360 Spatialな音は心地良い。ただたんに音楽鳴らすだけにも使ってますね、起動も早いのでSpotify Connectでよく流してます。</p>
<p>アンプのサイズが小さい(Apple TVが一回り大きくなった程度)というのも設置が楽になった要因で、いやほんとよく出来てますね。確かに、全部無線なのでスピーカーを駆動するアンプは各スピーカー内蔵状態だから、本体をAVアンプあるあるなクソデカサイズにしなくてもいいんですね。そういうところにも無線の良さが出てますね。</p>
<h2>来年に向けてのC#</h2>
<p>こうしてダラダラと文章書いたり、そもそもこの12月はやたら記事量産しているなあ、というのは、ブログ書く環境が変わったからです！10年前のWordPressから<a href="https://neue.cc/2021/11/21.html">自家製サイトジェネレーターへの変更</a>によって快適度上がったからですね。いやあ、書きやすいと書く気になります。環境大事。</p>
<p>そんなわけでCysharpはC#はの環境を良くすることに今年一年もちゃんと務められたんじゃないでしょーか。Cysharpからの新規リリース/大型更新は</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">ProcessX Zx</a></li>
<li><a href="https://github.com/Cysharp/MessagePipe">MessagePipe</a></li>
<li><a href="https://github.com/Cysharp/Kokuban">Kokuban</a></li>
<li><a href="https://github.com/Cysharp/CsprojModifier">CsprojModifier</a></li>
<li><a href="https://github.com/Cysharp/NativeMemoryArray">NativeMemoryArray</a></li>
<li><a href="https://github.com/Cysharp/ConsoleAppFramework/">ConsoleAppFramework v4</a></li>
<li><a href="https://github.com/Cysharp/ObservableCollections">ObservableCollections</a> ←ReadMe/解説がまだな仕掛品</li>
</ul>
<p>MessagePipeが大きめかな？</p>
<p>こうした公開していく姿勢、足を少しでも止めてはダメだという思いがあるので、作ろうと思ったらできるだけ勢い持って作りきるようにしています（もちろん途中で止まってしまったものも幾つかありはしますが）。毎年継続的に、Cysharp全体としても既に20個以上公開していて、ヒット作もそれなりの量を出し続けていられる状態は中々のことだと思います。</p>
<p>と、いうわけで、OSSを通じてCysharpをアピールしていくという方向では、良い点をあげてもいいかな、と思うのですが、反面、他の仕事に集中しきれていないのではないかというのが散見していたのは個人的にはマイナスです。今年は「世の中の開発生産性を革命的に改善するプロダクト」の作成に着手し（構想は前からあったのですがようやく始動）、徐々に人も集めだしてCysharpが割とまともな（？）会社っぽく動き出した頃合いでもあるんですが、私がボトルネックになりがち、な状況になりがちなのが、まぁいくないですねえ、と。これはグラニの頃もそうだったので、なんかもうそういうもの感もあるんですが、今回は私が主導してやってるので尻拭いしてくれる人もいないので純粋に良くない！</p>
<p>というわけで、来年の中旬までにその「世の中の開発生産性を革命的に改善するプロダクト」をリリースするために全力でやっていくぞ、というのが目標です。実際出来上がってきて、かなりいいものになりそうな手応えはあるので、早く世の中に出して評価されたいものです。</p>
<p>まぁ、そんなわけで大きな何かがあったわけではないですが、確実に前進した年だと思うので、来年は爆発させる年にしましょう。</p>
</div>
<h1><a href="https://neue.cc/2021/12/30.html">ConsoleAppFramework v4 - Minimal API for CommandLine tool</a></h1>
<ul class="date"><li>2021-12-30</li></ul>
<div class="entry_body"><p>皆さん .NET 6で追加された<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/minimal-apis">Minimal API</a>使ってみました？最初は別にいらんやろ、とか思ってたんですが、いや、これ正直めっちゃ凄い、いい。まぁDelegateベースで書くかどうかは別として（書かないかなー）、謎Startupを葬り去ってBuilder/Runが素直に繋がった形が美しい。Top level statementとの相性も良いので、もうこっちのAPI以外で作る気しないなあ。</p>
<p>さて、ところでConsoleAppFrameworkです。今までクラスが必要だったんですよね、たった一個のメソッドを実装するにも。それがTop level statementとの相性が悪い。Top level statementだけで完結できるとき、クラスって作りたくないんですよね。と、いうわけで、そろそろ大改修が必要かなーと思っていたところにMinimal APIですよ。特にその場でラムダ式でばしばしAPI作っていくスタイルは、むしろコマンドラインツールのほうがマッチするじゃんどう考えても？</p>
<p>と、いうわけで大改修して、Minimal APIベースになったv4、作りました。何が凄いって、一行でコマンドライン引数をパースしてハンドラー定義できちゃうんですね。</p>
<p><img src="https://user-images.githubusercontent.com/46207/147662718-f7756523-67a9-4295-b090-3cfc94203017.png" alt="" /></p>
<pre><code class="language-csharp">ConsoleApp.Run(args, (string name) =&gt; Console.WriteLine($&quot;Hello {name}&quot;));
</code></pre>
<p>これは嘘偽りなくNuGetからダウンロードしたら、そのままでこう書けます。C# 10.0のglobal using(をNuGetのライブラリ側に埋め込むというEvilな手法を使ってます)と、ラムダ式の推論の向上によって実現しました。内側では、Minimal APIの実現のために Microsoft.Extensions.* 側にもかなり改修が入っていたので、それをそっくりそのまま利用できました。そういう意味で、 .NET 6になった今だからようやく作れた形になりますね。もちろんv1~v3までの蓄積のお陰というところもあります。集大成……！</p>
<ul>
<li><a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a></li>
</ul>
<p>さて、Runはちょっとウケ狙いなところもあるんですが、それ以外のAPIもBuilderベースになったので、だいぶ様変わりしています。ただし特徴としてGeneric Hostの上に乗っているというのは変わらないので、DbContext埋めたりappconfig.jsonから取ったりというのは、変わらずスムーズにできます。</p>
<pre><code class="language-csharp">// You can use full feature of Generic Host(same as ASP.NET Core).

var builder = ConsoleApp.CreateBuilder(args);
builder.ConfigureServices((ctx,services) =&gt;
{
    // Register EntityFramework database context
    services.AddDbContext&lt;MyDbContext&gt;();

    // Register appconfig.json to IOption&lt;MyConfig&gt;
    services.Configure&lt;MyConfig&gt;(ctx.Configuration);

    // Using Cysharp/ZLogger for logging to file
    services.AddLogging(logging =&gt;
    {
        logging.AddZLoggerFile(&quot;log.txt&quot;);
    });
});

var app = builder.Build();

// setup many command, async, short-name/description option, subcommand, DI
app.AddCommand(&quot;calc-sum&quot;, (int x, int y) =&gt; Console.WriteLine(x + y));
app.AddCommand(&quot;sleep&quot;, async ([Option(&quot;t&quot;, &quot;seconds of sleep time.&quot;)] int time) =&gt;
{
    await Task.Delay(TimeSpan.FromSeconds(time));
});
app.AddSubCommand(&quot;verb&quot;, &quot;childverb&quot;, () =&gt; Console.WriteLine(&quot;called via 'verb childverb'&quot;));

// You can insert all public methods as sub command =&gt; db select / db insert
// or AddCommand&lt;T&gt;() all public methods as command =&gt; select / insert
app.AddSubCommands&lt;DatabaseApp&gt;();

app.Run();
</code></pre>
<p>単独のコマンドラインツール用に使ってもいいのですが、ASP.NETのウェブアプリが他にあって、それのバッチを作りたいみたいなときに、こうしたコンフィグの共通化はめっちゃ便利に使えるはずです。ConfigureServicesのコードはまんま一緒にできて、そのままDIできますからね。</p>
<p>また、引き続き <code>AddCommands&lt;T&gt;</code> や <code>AddAllCommandType</code> によって、メソッド定義するだけで大量のコマンドを一括追加も可能になっています。</p>
<h2>v3 -&gt; v4の破壊的変更</h2>
<p>破壊的変更、は沢山あるのですが、基本的に今までの使い方をしている場合は互換オプションで動くようにしたので、アップデートしたから壊れるということはない、はずです。v4からは<code>ConsoleApp.Create/CreateBuilder</code> 経由で作るのが基本なのですが、v3は <code>Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&lt;T&gt;()</code> 経由なので、ちょうど互換性オプションを突っ込むのに都合が良かったんですね。なお、<code>RunConsoleAppFrameworkAsync</code>はエディタから見えないようにしてます。今後は非推奨で、本当に互換のためだけに残してます。</p>
<p>まず変わったところは、デフォルトで長いオプション名が<code>--</code>、短いオプション名が<code>-</code>になりました。v3では<code>-</code>が幾つついていてもいいというゆるふわマッチングだったのですが、(dotonet toolsと同じように)厳格化しています。</p>
<p>また、デフォルトのコマンド/オプション名の変換ルールが単純なlower化から、hoge-hugaというlowerなkebab-caseになりました。これもdotnet tools合わせですね。</p>
<p>また、<code>AddCommands&lt;T&gt;</code>した場合の挙動(v3では<code>RunConsoleAppFrameworkAsync&lt;T&gt;</code>した場合)が、全てのpublicメソッドをコマンドとして追加するようになりました。デフォルト(ルート)コマンドにしたい場合は<code>[RootCommand]</code>属性を付与してくださいということで。これは<code>AddSubCommand&lt;T&gt;</code>した時と挙動を合わせたかったからです、違うと一貫性がなくて戸惑うので。</p>
<p>と、いうわけで、互換性モードで動かした場合は<code>ConsoleAppOptions</code>は以下のような変更で動くようになっています。よきかなよきかな。（それとargsのコマンド名でHoge.Hugaが来てたらHoge Hugaに分解するのも、この互換性モードだけの挙動です）</p>
<pre><code class="language-csharp">options.StrictOption = false;
options.NoAttributeCommandAsImplicitlyDefault = true;
options.NameConverter = x =&gt; x.ToLower();
options.ReplaceToUseSimpleConsoleLogger = false;
</code></pre>
<p>そうだ、それとCtrl+Cした場合に、正しくCancellationTokenをハンドリングしていない場合でも、タイムアウトをハンドリングしてabortするようになりました。これは、なんか強制終了できなくてウゼーってなりがちというか、私自身よく引っかかってヤバかったので。むしろこれは今までがバグに近くて、正しく<code>HostOptions.ShutdownTimeout</code>を処理していないせいでした。</p>
<p>ちなみにこのタイムアウト時間はデフォルトは5秒で、ConfigureHostOptions(地味にこれは.NET 6(というかMicrosoft.Extensionsのv6)からの新API)で変更できます。</p>
<pre><code class="language-csharp">var app = ConsoleApp.CreateBuilder(args)
    .ConfigureHostOptions(options =&gt;
    {
        // change timeout.
        options.ShutdownTimeout = TimeSpan.FromMinutes(30);
    })
    .Build();
</code></pre>
<h2>まとめ</h2>
<p>無計画にアドホックに作っていったせいで、どうにもクソコードすぎて、改修にめっちゃ手間取ったというか内部的にはほぼ作り直した……。弄るのだるくて嫌だなあと内心実際今まで思ってたんですが、やはりとても嫌なコードであった。v1の時の最初の発想が Class.Method にパラメータ分解してバッチを大量に作りたい(そもそもライブラリ名もMicroBatchFrameworkだったし)というものだけだったのが、徐々に汎用コマンドラインツールに進化していって、都度、適当に追加していった結果ではある。</p>
<p>今回がっつし仕切り直したので、しばらくはメンテが楽になれるかなあ、という感じで、よきかなよきかな。</p>
<p>まぁしかしC# 10.0は地味にヤバいですよ！使えば使うほど味が出てくるというか、最近ようやく手に馴染んで、よくわかってきた感じです。なんというか、とにかく、めっちゃいい。それとC# 10.0 + ConsoleAppFrameworkは全言語見渡しても最強のコマンドラインツール作成ライブラリじゃないです？いや、API自体のできの良さはほとんど ASP .NET CoreのMinimal APIのコピーにすぎないんですが、まぁしかしそれでもやっぱ、これはかなり良い感じじゃないかという手応えがあります。</p>
</div>
<h1><a href="https://neue.cc/2021/12/22.html">NativeMemoryArray - .NET 6 APIをフル活用した2GB超えの巨大データを扱うライブラリ</a></h1>
<ul class="date"><li>2021-12-22</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/microsoft">.NET 6 Advent Calendar 2021</a>の12日の代理投稿となります。プレゼント付きですと！？<a href="https://www.balmuda.com/jp/brew/special-model">BALMUDA The Brew STARBUCKS RESERVE LIMITED EDITION</a>が欲しいです！</p>
<p>さて、先程NativeMemoryArrayという新しいライブラリを作成し、公開しました。.NET Standard 2.0でも動作しますが、全体的に .NET 6 の新API群(NativeMemory, Scatter/Gather I/O)を活かすための作りになっていますので、今回のAdvent Calendarにもピッタリ。実用性も、ある……！あります……！もちろんUnity版も用意してあります（NativeArrayと何が違うって？まぁ違うと言えば違います）。</p>
<ul>
<li><a href="https://github.com/Cysharp/NativeMemoryArray">GitHub - Cysharp/NativeMemoryArray</a></li>
</ul>
<p>C#には配列、特にbyte[]を扱う上で大きな制約が一つあります。それは、一次元配列の上限値が0x7FFFFFC7(2,147,483,591)ということ。int.MaxValueよりちょっと小さめに設定されていて、ようするにざっくり2GBちょいが限界値になっています。</p>
<blockquote>
<p>この限界値は、正確には .NET 6 でひっそり破壊的変更が行われましたので、.NET 6とそれ以外で少し異なります。詳しくは後で述べます。</p>
</blockquote>
<p>この2GBという値は、int Lengthの都合上しょうがない(intの限界値に引っ張られている)のですが、昨今は4K/8Kビデオや、ディープラーニングの大容量データセットや、3Dスキャンの巨大点群データなどで、大きな値を扱うことも決して少ないわけではないため、2GB制約は正直厳しいです。そして、この制約は<code>Span&lt;T&gt;</code>や<code>Memory&lt;T&gt;</code>であっても変わりません(Lengthがintのため)。</p>
<p>ちなみに<code>LongLength</code>は多次元配列における全次元の総数を返すためのAPIのため、一次元配列においては特に意味をなしません。.NET Frameworkの設定である<a href="https://docs.microsoft.com/ja-jp/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element">gcAllowVeryLargeObjects</a>も、構造体などを入れた場合の大きなサイズを許容するものであり(例えば4バイト構造体の配列ならば、2GB*4のサイズになる)、要素数の限界は超えられないため、byte[]としては2GBが限界であることに変わりはありません。</p>
<p>こうした限界に突き当たった場合は、ストリーミング処理に切り替えるか、またはポインタを使って扱うかになりますが、どちらもあまり処理しやすいとは言えませんし、必ずしもインメモリで行っていた操作が代替できるわけではありません（ポインタなら頑張れば最終的にはなんとでもなりますが）。</p>
<p>そこで、2GB制約を超えつつも、新しいAPI群(<code>Span&lt;T&gt;</code>, <code>IBufferWriter&lt;T&gt;</code>, <code>ReadOnlySequence&lt;T&gt;</code>, <code>RandomAccess.Write/Read</code>, <code>System.IO.Pipelines</code>など)と親和性の高いネイティブメモリを裏側に持つ配列（みたいな何か）を作りました。</p>
<p>これによって、例えば巨大データの読み込み/書き込みも、 .NET 6の新Scatter/Gather APIの<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>を用いると、簡単に処理できます。</p>
<pre><code class="language-csharp">// for example, load large file.
using var handle = File.OpenHandle(&quot;4GBfile.bin&quot;, FileMode.Open, FileAccess.Read, options: FileOptions.Asynchronous);
var size = RandomAccess.GetLength(handle);

// via .NET 6 Scatter/Gather API
using var array = new NativeMemoryArray&lt;byte&gt;(size);
await RandomAccess.ReadAsync(handle, array.AsMemoryList(), 0);

// iterate Span&lt;byte&gt; as chunk
foreach (var chunk in array)
{
    Console.WriteLine(chunk.Length);
}
</code></pre>
<p>Scatter/Gather APIに馴染みがなくても、<code>IBufferWriter&lt;T&gt;</code>や <code>IEnumerable&lt;Memory&lt;T&gt;&gt;</code> を経由してStreamで処理する手法も選べます。</p>
<pre><code class="language-csharp">public static async Task ReadFromAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    var writer = buffer.CreateBufferWriter();

    int read;
    while ((read = await stream.ReadAsync(writer.GetMemory(), cancellationToken).ConfigureAwait(false)) != 0)
    {
        writer.Advance(read);
    }
}

public static async Task WriteToAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    foreach (var item in buffer.AsMemorySequence())
    {
        await stream.WriteAsync(item, cancellationToken);
    }
}
</code></pre>
<p>あるいは<code>Span&lt;T&gt;</code>のSliceを取り出して処理してもいいし、<code>ref T this[long index]</code>によるインデクサアクセスやポインタの取り出しもできます。 .NET 6時代に完全にマッチしたAPIを揃えることで、標準の配列と同等、もしくはそれ以上の使い心地に仕上げることによって、C#の限界をまた一つ超える提供できたと思っています。</p>
<p>とはいえもちろん、 .NET Standard 2.0/2.1 にも対応しているので、非 .NET 6なAPIでも大丈夫です、というかScatter/Gather API以外は別に今までもありますし普通に使えますので。</p>
<p>普通の配列的にも使えます。GC避けには、こうした普通のAPIを使っていくのでも便利でしょう、</p>
<pre><code class="language-csharp">// call ctor with length, when Dispose free memory.
using var buffer = new NativeMemoryArray&lt;byte&gt;(10);

buffer[0] = 100;
buffer[1] = 100;

// T allows all unmanaged(struct that not includes reference type) type.
using var mesh = new NativeMemoryArray&lt;Vector3&gt;(100);

// AsSpan() can create Span view so you can use all Span APIs(CopyTo/From, Write/Read etc.).
var otherMeshArray = new Vector3[100];
otherMeshArray.CopyTo(mesh.AsSpan());
</code></pre>
<h2><code>NativeMemoryArray&lt;T&gt;</code></h2>
<p><code>NativeMemoryArray&lt;T&gt;</code>はwhere T : unmanagedです。つまり、参照型を含まない構造体にしか使えません。まぁ巨大配列なんて使う場合には参照型含めたものなんて含めてんじゃねーよなので、いいでしょうきっと。巨大配列で使えることを念頭においてはいますが、別に普通のサイズの配列として使っても構いません。ネイティブメモリに確保するので、ヒープを汚さないため、適切な管理が行える箇所では便利に使えるはずです。</p>
<p><code>Span&lt;T&gt;</code>との違いですが、<code>NativeMemoryArray&lt;T&gt;</code>そのものはクラスなので、フィールドに置けます。<code>Span&lt;T&gt;</code>と違って、ある程度の長寿命の確保が可能ということです。<code>Memory&lt;T&gt;</code>のSliceが作れるため、Async系のメソッドに投げ込むこともできます。また、もちろん、<code>Span&lt;T&gt;</code>の長さの限界はint.MaxValueまで(ざっくり2GB)なので、それ以上の大きさも確保できます。</p>
<p>Unityにおける<code>NativeArray&lt;T&gt;</code>との違いですが、<code>NativeArray&lt;T&gt;</code>はUnity Engine側との効率的なやりとりのための入れ物なので、あくまでC#側で使うための<code>NativeMemoryArray&lt;T&gt;</code>とは全然役割が異なります。まぁ、必要に思えない状況ならば、おそらく必要ではありません。</p>
<p>主な長所は、以下になります。</p>
<ul>
<li>ネイティブメモリから確保するためヒープを汚さない</li>
<li>2GBの制限がなく、メモリの許す限り無限大の長さを確保できる</li>
<li><code>IBufferWriter&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonWriter, System.IO.Pipelinesなどから直接読み込み可能</li>
<li><code>ReadOnlySequence&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonReaderなどへ直接データを渡すことが可能</li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt;</code>, <code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt;</code> 経由で <code>RandomAccess</code>(Scatter/Gather API)に巨大データを直接渡すことが可能</li>
</ul>
<p>あまりピンと来ない、かもしれませんが、使ってみてもらえれば分かる、かも。</p>
<p><code>NativeMemoryArray&lt;T&gt;</code>の全APIは以下のようになっています。</p>
<ul>
<li><code>NativeMemoryArray(long length, bool skipZeroClear = false, bool addMemoryPressure = false)</code></li>
<li><code>long Length</code></li>
<li><code>ref T this[long index]</code></li>
<li><code>ref T GetPinnableReference()</code></li>
<li><code>Span&lt;T&gt; AsSpan()</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start)</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start, int length)</code></li>
<li><code>Memory&lt;T&gt; AsMemory()</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start)</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start, int length)</code></li>
<li><code>bool TryGetFullSpan(out Span&lt;T&gt; span)</code></li>
<li><code>IBufferWriter&lt;T&gt; CreateBufferWriter()</code></li>
<li><code>SpanSequence AsSpanSequence(int chunkSize = int.MaxValue)</code></li>
<li><code>MemorySequence AsMemorySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt; AsMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt; AsReadOnlyMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>ReadOnlySequence&lt;T&gt; AsReadOnlySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>SpanSequence GetEnumerator()</code></li>
<li><code>void Dispose()</code></li>
</ul>
<p><code>AsSpan()</code>, <code>AsMemory()</code>はスライスのためのAPIです。取得したSpanやMemoryは書き込みも可能なため、 .NET 5以降に急増したSpan系のAPIに渡せます。SpanやMemoryには最大値(int.MaxValue)の限界があるため、lengthの指定がない場合は、例外が発生する可能性もあります。そこで<code>TryGetFullSpan()</code>を使うと、単一Spanでフル取得が可能かどうか判定できます。また、<code>AsSpanSequence()</code>, <code>AsMemorySequence()</code>でチャンク毎のforeachで全要素を列挙することが可能です。直接foreachした場合は、<code>AsSpanSequence()</code>と同様の結果となります。</p>
<pre><code class="language-csharp">long written = 0;
foreach (var chunk in array)
{
    // do anything
    written += chunk.Length;
}
</code></pre>
<p>ポインタの取得は、配列とほぼ同様に、そのまま渡せば0から(これは<code>GetPinnableReference()</code>の実装によって実現できます)、インデクサ付きで渡せばそこから取れます。</p>
<pre><code class="language-csharp">fixed (byte* p = buffer)
{
}

fixed (byte* p = &amp;buffer[42])
{
}
</code></pre>
<p><code>CreateBufferWriter()</code> によって <code>IBufferWriter&lt;T&gt;</code>を取得できます。これは<code>MessagePackSerializer.Serialize</code>などに直接渡すこともできるほかに、先の例でも出しましたがStreamからの読み込みのように、先頭からチャンク毎に取得して書き込んでいくようなケースで便利に使えるAPIとなっています。</p>
<p><code>AsReadOnlySequence()</code> で取得できる<code>ReadOnlySequence&lt;T&gt;</code>は、<code>MessagePackSerializer.Deserialize</code>などに直接渡すこともできるほかに .NET 5から登場した <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-6.0">SequenceReader</a>に通すことで、長大なデータのストリーミング処理をいい具合に行える余地があります。</p>
<p><code>AsMemoryList()</code>, <code>AsReadOnlySequence()</code>は .NET 6から登場した<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>の<code>Read/Write</code>に渡すのに都合の良いデータ構造です。プリミティブな処理なので使いにくいと思いきや、意外とすっきりと処理できるので、File経由の処理だったらStreamよりもいっそもうこちらのほうがいいかもしれません。</p>
<h2>NativeMemory</h2>
<p>.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.nativememory?view=net-6.0">NativeMemory</a>というクラスが新たに追加されました。その名の通り、ネイティブメモリを扱いやすくするものです。今までも<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=net-6.0">Marshal.AllocHGlobal</a>といったメソッド経由でネイティブメモリを確保することは可能であったので、何が違うのか、というと、何も違いません。実際NativeMemoryArrayの .NET 6以前版はMarshalを使ってますし。そして .NET 6 では Marshal.AllocHGlobal は NativeMemory.Alloc を呼ぶので、完全に同一です。</p>
<p>ただしもちろん .NET 6 実装時にいい感じに整理された、ということではあるので、NativeMemory、いいですよ。NativeMemory.Allocがmalloc、NativeMemory.AllocZeroedがcalloc、NativeMemory.Freeがfreeと対応。わかりやすいですし。</p>
<p>ちなみにゼロ初期化する NativeMemory.AllocZeroed に相当するものはMarshalにはないので、その点でも良くなったところです。<code>NativeMemoryArray&lt;T&gt;</code>では、コンストラクタのskipZeroClear(<code>public NativeMemoryArray(long length, bool skipZeroClear = false)</code>)によってゼロ初期化する/しないを選べます。デフォルトは（危ないので）初期化しています。非.NET 6版では、メモリ確保後に<code>Span&lt;T&gt;.Clear()</code>経由で初期化処理を入れています。</p>
<h2>真のArray.MaxValue</h2>
<p>.NET 6以前では、配列の要素数はバイト配列(1バイト構造体の配列)と、それ以外の配列で異なる値がリミットに設定されていました。例えば<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array?view=net-6.0">System.Arrayのドキュメント</a>を引いてくると</p>
<blockquote>
<p>配列のサイズは、合計で40億の要素に制限され、任意の次元の0X7FEFFFFF の最大インデックス (バイト配列の場合は0X7FFFFFC7、1バイト構造体の配列の場合) に制限されます。</p>
</blockquote>
<p>つまり、0X7FFFFFC7の場合と、0X7FEFFFFFの場合がある、と。</p>
<p>と、いうはずだったのですが、.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.maxlength">Array.MaxLength</a>というプロパティが新規に追加されて、これは単一の定数を返します。その値は、0X7FFFFFC7です。よって、いつのまにかひっそりと配列の限界値は(ちょびっと大きい方に)大統一されました。</p>
<p>この変更は意外とカジュアルに行われ、まず最大値を取得する、ただし単一じゃないため型によって結果の変わる <code>Array.GetMaxLength&lt;T&gt;()</code> を入れよう、<a href="https://github.com/dotnet/runtime/pull/43301">という実装があがってきました</a>。そうしたら、そのPR上での議論で、そもそも当初は最適化を期待したけど別にそんなことなかったし、統一しちゃってよくね？という話になり、そのまま限界値は統一されました。そして新規APIも無事、Array.MaxLengthという定数返しプロパティになりました。</p>
<p>まぁ、シンプルになって良いですけどね。大きい方で統一されたので実害も特にないでしょうし。前述のSystem.Arrayのドキュメントは更新されてないということで、正しくは、.NET 6からは0x7FFFFFC7が限界で、その値はArray.MaxLengthで取れる。ということになります。</p>
<p><code>Span&lt;T&gt;</code>の限界値はint.MaxValueなので、限界に詰め込んだ<code>Span&lt;T&gt;</code>をそのままToArray()すると死ぬ、という微妙な問題が発生することがあるんですが、まぁそこはしょうがないね。</p>
<h2>まとめ</h2>
<p>NativeArrayという名前にしたかったのですがUnityと被ってしまうので避けました。しょーがない。</p>
<p>着手当時はマネージド配列のチャンクベースで作っていたのですが(<a href="https://gist.github.com/neuecc/e6293b1d88244cf942753d6408b3e966">LargeArray.cs</a>)、Sliceが作りづらいし、ネイティブメモリでやったほうが出来ること多くて何もかもが圧倒的にいいじゃん、ということに作業進めている最中に気づいて、破棄しました。参照型の配列が作れるという点で利点はありますが、まぁ参照型で巨大配列なんて作らねーだろ、思うと、わざわざ実装増やして提供するメリットもないかな、とは。</p>
<p>配列はもう昔からあるのでint Lengthなのはしょうがないのですが、<code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>のLengthはlongであって欲しかったかなー、とは少し思っています。<a href="https://github.com/dotnet/apireviews/tree/main/2016/11-04-SpanOfT#spant-and-64-bit">2016年の段階でのSpanのAPIどうするかドキュメント</a>によると、候補は幾つかあったけど、結果的に配列踏襲のint Lengthになったそうで。2GBでも別に十分だろ、みたいなことも書いてありますが、いや、そうかなー？年にそこそこの回数でたまによく引っかかるんだけどねー？</p>
<p>そして2016年の議論時点ではなかった、C# 9.0で<a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/nint-nuint">nuint, nuint</a>が追加されたので、<code>nuint Span&lt;T&gt;/Memory&lt;T&gt;.Length</code>はありなんじゃないかな、と。</p>
<p>ただNativeMemoryArrayの開発当初は<code>nuint Length</code>で作っていたのですが、<code>AsSpan(nuint start, nuint length)</code>みたいなAPIは、カジュアルにintやlongを突っ込めなくて死ぬほど使いづらかったので、最終的にlongで統一することにしました。ので、<code>nuint Length</code>は、なしかな。つまり一周回って現状維持。そんなものかー、そんなもんですねー。</p>
</div>
<h1><a href="https://neue.cc/2021/12/04.html">.NET 6とAngleSharpによるC#でのスクレイピング技法</a></h1>
<ul class="date"><li>2021-12-04</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/csharplang">C# Advent Calendar 2021</a>の参加記事となっています。去年は2個エントリーしたあげく、1個すっぽかした（！）という有様だったので、今年は反省してちゃんと書きます。</p>
<p>スクレイピングに関しては10年前に<a href="https://neue.cc/2010/03/02_244.html">C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法</a>という記事でSGMLReaderを使ったやり方を紹介していたのですが、10年前ですよ、10年前！さすがにもう古臭くて、現在ではもっとずっと効率的に簡単にできるようになってます。</p>
<p>今回メインで使うのは<a href="https://anglesharp.github.io/">AngleSharp</a>というライブラリです。AngleSharp自体は2015年ぐらいからもう既に定番ライブラリとして、日本でも紹介記事が幾つかあります。が、いまいち踏み込んで書かれているものがない気がするので、今回はもう少しがっつりと紹介していきたいと思っています。それと直近Visual StudioのWatchウィンドウの使い方を知らん、みたいな話を聞いたりしたので、デバッグ方法の手順みたいなものを厚めに紹介したいなあ、という気持ちがあります！</p>
<p>AngleSharpの良いところは、まずはHTMLをパースしてCSSセレクターで抽出できるところです。以前はLINQ(to DOM)があればCSSセレクターじゃなくてもいいっす、WhereとSelectManyとDescendantsでやってきますよ、とか言ってましたが、そんなにきちんと構造化されてるわけじゃないHTMLを相手にするのにあたっては、CSSセレクターのほうが100億倍楽！CSSセレクターの文法なんて大したことないので、普通に覚えて使えってやつですね。SQLと正規表現とCSSセレクターは三大言語関係なく覚えておく教養、と。</p>
<p>もう一つは、それ自体でネットワークリクエストが可能なこと。FormへのSubmitなどもサポートして、Cookieも保持し続けるとかが出来るので、ログインして会員ページを弄る、といったようなクローラーが簡単に書けるんですね。この辺非常に良く出来ていて、もう自前クローラーなんて投げ捨てるしかないです。また、<a href="https://github.com/sebastienros/jint">Jint</a>というPure C#なJavaScriptインタプリタと統合したプラグインも用意されているので、JavaScriptがDOMをガリガリっと弄ってくる今風のサイトにも、すんなり対応できます。</p>
<p>AngleSharpの紹介記事では、よくHttpClientなどで別途HTMLを取ってきたから、それをAngleSharpのHtmlParserに読み込ませる、というやり方が書かれていることが多いのですが、取得も含めて全てAngleSharp上で行ったほうが基本的には良いでしょう。</p>
<p>ここまで来るとPure C#の軽量なヘッドレスブラウザとしても動作する、ということになるので、カジュアルなE2Eテストの実装基盤にもなり得ます。普通のユニットテストと並べて <code>dotnet test</code> だけでその辺もある程度まかなえたら、とても素敵なことですよね？がっつりとしたE2Eテストを書きたい場合は<a href="https://github.com/microsoft/playwright">Playwright</a>などを使わなければ、ということになってしまいますが、まずは軽い感じから始めたい、という時にうってつけです。C#で書けるし。いいことです。</p>
<h2>BrowingContextとQuerySelectorの基本</h2>
<p>まずはシンプルなHTMLのダウンロードと解析を。基本は <code>BrowsingContext</code> を作って、それをひたすら操作していくことになります。</p>
<pre><code class="language-csharp">// この辺で色々設定する
var config = Configuration.Default
    .WithDefaultLoader(); // LoaderはデフォではいないのでOpenAsyncする場合につける

// Headless Browser的なものを作る
using var context = BrowsingContext.New(config);

// とりあえずこのサイトの、右のArchivesのリンクを全部取ってみる
var doc = await context.OpenAsync(&quot;https://neue.cc&quot;);
</code></pre>
<p>OpenAsyncで取得できた <code>IDocument</code> をよしなにCSSセレクターで解析していくわけですが、ここで絞り込みクエリー作成に使うのがVisual StudioのWatchウィンドウ。（Chromeのデベロッパーツールなどで機械的に取得したい要素のCSSセレクターを取得できたりしますが、手セレクターのほうがブレなくルールは作りやすいかな、と）。</p>
<p>デバッガーを起動して、とりあえずウォッチウィンドウを開いておもむろに、Nameのところでコードを書きます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144583627-0c7982e4-4933-41f7-ba04-81836f10da8c.png" alt="image" /></p>
<p>ウォッチウィンドウは見たい変数を並べておく、お気に入り的な機能、と思いきや本質的にはそうじゃなくて、式を自由に書いて、結果を保持する、ついでに式自体も保持できるという、実質REPLなのです。代入もラムダ式もLINQも自由に書けるし、入力補完も普通に出てくる。Immediate Windowよりも結果が遥かに見やすいので、Immediate Windowは正直不要です。</p>
<p>デバッガー上で動いているので実データを自由に扱えるというところがいいですね。というわけで、ToHtml()でHTMLを見て、QuerySelectorAllをゆっくり評価しながら書いていきましょう。まずはサイドバーにあるので <code>.side_body</code> を出してみると、あれ、二個あるの？と。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144582934-371930f2-dbff-4341-9f92-87e27c56d477.png" alt="image" /></p>
<p>中開けてInnerHtml見ると、なるほどProfile部分とArchive部分、と。とりあえず後ろのほうで固定のはずなのでlast-childね、というところで一旦評価して大丈夫なのを確認した後に、あとはa、と。でここまでで期待通りの結果が取れていれば、コピペる。よし。</p>
<pre><code class="language-csharp">// 基本、QuerySelectorかQuerySelectorAllでDOMを絞り込む
var anchors = doc.QuerySelectorAll(&quot;.side_body:last-child a&quot;)
    .Cast&lt;IHtmlAnchorElement&gt;() // AngleSharp.Html.Dom
    .Select(x =&gt; x.Href)
    .ToArray();
</code></pre>
<p>単一の要素に絞り込んだ場合は、 <code>IHtml***</code> にキャストしてあげると扱いやすくなります(attributeのhrefのtextを取得、みたいにしなくていい)。頻出パターンなので、<code>QuerySelectorAll&lt;T&gt;</code>でCastもセットになってすっきり。</p>
<pre><code class="language-csharp">doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;)
</code></pre>
<p>せっかくなので、年に何本記事を書いていたかの集計を出してみたいと思います！URLから正規表現で年と月を取り出すので、とりあえずここでもウォッチウィンドウです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144590970-34c3bff4-0f0b-4db3-a259-f37a6f1e5f40.png" alt="image" /></p>
<p>anchrosの[0]を確認して、これをデータソースとしてRegex.Matchを書いて、どのGroupに収まったのかを見ます。この程度だったら特にミスらないでしょー、と思いきや普通に割とミスったりするのが正規表現なので、こういうので確認しながらやっていけるのはいいですね。</p>
<p>後は普通の（？）LINQコード。グルーピングした後に、ひたすら全ページをOpenAsyncしていきます。記事の本数を数えるのはh1の数をチェックするだけなので、特に複雑なCSSセレクターは必要なし。本来はページングの考慮は必要ですが、一月単位だとページングが出てくるほどの記事量がないので、そこも考慮なしで。</p>
<pre><code class="language-csharp">var yearGrouped = anchors
    .Select(x =&gt;
    {
        var match = Regex.Match(x, @&quot;(\d+)/(\d+)&quot;);
        return new
        {
            Url = x,
            Year = int.Parse(match.Groups[1].Value),
            Month = int.Parse(match.Groups[2].Value)
        };
    })
    .GroupBy(x =&gt; x.Year);

foreach (var year in yearGrouped.OrderBy(x =&gt; x.Key))
{
    var postCount = 0;
    foreach (var month in year)
    {
        var html = await context.OpenAsync(month.Url);
        postCount += html.QuerySelectorAll(&quot;h1&quot;).Count(); // h1 == 記事ヘッダー
    }
    Console.WriteLine($&quot;{year.Key}年記事更新数: {postCount}&quot;);
}
</code></pre>
<p>結果は</p>
<pre><code>2009年記事更新数: 92
2010年記事更新数: 61
2011年記事更新数: 66
2012年記事更新数: 30
2013年記事更新数: 33
2014年記事更新数: 22
2015年記事更新数: 19
2016年記事更新数: 24
2017年記事更新数: 13
2018年記事更新数: 11
2019年記事更新数: 14
2020年記事更新数: 11
2021年記事更新数: 5
</code></pre>
<p>ということで右肩下がりでした、メデタシメデタシ。今年は特に書いてないなあ、せめて2ヶ月に1本は書きたいところ……。</p>
<p>なお、<a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a>
で紹介しているのですが、このサイトは完全に<a href="https://github.com/neuecc/Blog2/tree/master/articles">GitHub上に.mdがフラットに並んで.mdが管理されている</a>ので、こういうの出すなら別にスクレイピングは不要です。</p>
<h2>UserAgentを変更する</h2>
<p>スクレイピングといったらログインしてごにょごにょする。というわけで、そうしたログイン処理をさくっとやってくれるのがAngleSharpの良いところです。ので紹介していきたいのですが、まずはやましいことをするので（？）、UserAgentを偽装しましょう。</p>
<p>AngleSharpが現在何を送っているのかを確認するために、とりあえずダミーのサーバーを立てます。その際には .NET 6 のASP .NET から搭載されたMinimal APIが非常に便利です！そしてそれを<a href="https://www.linqpad.net/">LINQPad</a>で動かすと、テスト用サーバーを立てるのにめっちゃ便利です！やってみましょう。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586706-aa067b51-d8d3-44ac-91b3-552c62e7ce6d.png" alt="image" /></p>
<p>たった三行でサーバーが立ちます。便利。</p>
<pre><code class="language-csharp">await context.OpenAsync(&quot;http://localhost:5000/headers&quot;);
</code></pre>
<p>でアクセスして、 <code>AngleSharp/1.0.0.0</code> で送られていることが確認できました。</p>
<p>なお、LINQPadでASP.NETのライブラリを使うには、Referene ASP.NET Core assembliesのチェックを入れておく必要があります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586956-fddb4821-59a3-4f37-9086-1624d471ed36.png" alt="image" /></p>
<p>他、よく使うNuGetライブラリや名前空間なども設定したうえで、<code>Set as default for new queries</code>しておくと非常に捗ります。</p>
<p>さて、で、このUser-Agentのカスタマイズの方法ですが、AngleSharpはServicesに機能が詰まっているようなDI、というかService Locatorパターンの設計になっているので、ロードされてるServicesを(Watch Windowで)一通り見ます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144601687-3ee78e1d-2f95-404f-b2f9-162deb8eeda0.png" alt="image" /></p>
<p>型に限らず全Serviceを取得するメソッドが用意されていない場合でも、<code>&lt;object&gt;</code>で取ってやると全部出てくるような実装は割と多い（ほんと）ので、とりあえずやってみるのはオススメです。今回も無事それで取れました。</p>
<p>で、型名を眺めてそれっぽそうなのを見ると <code>DefaultHttpRequester</code> というのがかなりそれっぽく、その中身を見るとHeadersという輩がいるので、これを書き換えればいいんじゃないだろうかと当たりがつきます。</p>
<p>ここはやましい気持ちがあるので（？）Chromeに偽装しておきましょう。</p>
<pre><code class="language-csharp">var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;;
</code></pre>
<p>再びOpenAsyncしてLINQPadの表示を見て、変更されてること確認できました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144602382-aba63413-2065-46ed-bd52-f4adf65bd30f.png" alt="image" /></p>
<p>ちなみに、DefaultじゃないHttpRequesterをConfigurationに登録しておく、ということも出来ますが、よほどカスタムでやりたいことがなければ、デフォルトのものをちょっと弄るぐらいの方向性でやっていったほうが楽です。</p>
<h2>FormにSubmitする</h2>
<p>クローラーと言ったらFormにSubmit、つまりログイン！そしてクッキーをいただく！認証！</p>
<p>さて、が、まぁ認証付きの何かを例にするのはアレなので、googleの検索フォームを例にさせていただきたいと思います。先にまずはコード全体像と結果を。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom; // 拡張メソッドとかで有効化されたりするのでusing大事
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies(); // login form的なものの場合これでクッキーを持ち歩く

using var context = BrowsingContext.New(config);

// お行儀悪いので（？）前述のこれやっておく
var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://google.com/&quot;);
var form = doc.Forms[0];
var result = await form.SubmitAsync(new { q = &quot;AngleSharp&quot; }); // name = valueは匿名型が使える

// とりあえず結果を表示しておく
var titles = result.QuerySelectorAll&lt;IHtmlHeadingElement&gt;(&quot;h3&quot;).Select(x =&gt; x.TextContent);
var i = 1;
foreach (var item in titles)
{
    Console.WriteLine($&quot;{i++:00}: {item}&quot;);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/144704506-b0d7038f-ad26-42e4-b8dd-b63b250759c5.png" alt="image" /></p>
<p><code>WithDefaultLoader</code> と、そして認証クッキー持ち歩きのために <code>WithDefaultCookies</code> をコンフィギュレーションに足しておくことが事前準備として必須です。User-Agentの書き換えはご自由に、ただやましいこと、ではなくてUA判定をもとにして処理する、みたいなサイトも少なからずあるので、余計ないこと考えなくて済む対策としてはUAをChromeに偽装しておくのはアリです。</p>
<p>FormへのSubmit自体は3行というか2行です。ページをOpenしてFormに対してSubmitするだけ。超簡単。 <code>.Forms</code> で <code>IHtmlElementForms</code>がすっと取れるので、あとは単純にSubmitするだけです。渡す値は <code>{ name = value }</code>の匿名型で投げ込めばOK。</p>
<p>度々出てくるウォッチウィンドウの宣伝ですが、この何の値を投げればいいのか、を調べるのにHTMLとニラメッコではなく、ウォッチウィンドウで調査していきます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/146650708-d2f1beb1-c21b-4a0a-851b-d0e78628bc00.png" alt="image" /></p>
<p>まず(&quot;input&quot;)を拾うのですが、9個ある。多いね、で、まぁこれはほとんどtype = &quot;hidden&quot;なので無視して良い（AngleSharpがSubmitAsync時にちゃんと自動でつけて送信してくれる）。値を入れる必要があるのはhiddden以外のものなので、それをウォッチで普通にLINQで書けば、3件に絞れました。で、中身見ると必要っぽいのはqだけなので、 new { q = &quot;hogemoge&quot; } を投下、と。</p>
<p>認証が必要なサイトでは、これでBrowingContextに認証クッキーがセットされた状態になるので、以降のこのContextでのOpenや画像、動画リクエストは認証付きになります。</p>
<h2>画像や動画を拾う</h2>
<p>スクレイピングといったら画像集めマンです（？）。AngleSharpでのそうしたリソース取得のやり方には幾つかあるのですが、私が最も良いかな、と思っているのはIDocumentLoader経由でのフェッチです。</p>
<pre><code class="language-csharp">// BrowsingContextから引っ張る。Contextが認証クッキー取得済みなら認証が必要なものもダウンロードできる。
var loader = context.GetService&lt;IDocumentLoader&gt;();

// とりあえず適当にこのブログの画像を引っ張る
var response = await loader.FetchAsync(new DocumentRequest(new Url(&quot;https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png&quot;))).Task;

using var ms = new MemoryStream();
await response.Content.CopyToAsync(ms);

var bytes = ms.ToArray(); // あとは適当にFile.WriteAllBytesでもなんでもどうぞ
</code></pre>
<p>内部用なので少し引数やAPIが冗長なところもありますが、それは後述しますが別になんとでもなるところなので、どちらかというと生のStreamが取れたりといった柔軟性のところがプラスだと思っています。普通にHttpClientで自前で取るのと比べると、認証周りやってくれた状態で始められるのが楽ですね。</p>
<p>並列ダウンロードもいけます、例えば、このブログの全画像を引っ張るコードを、↑に書いた全ページ取得コードを発展させてやってみましょう。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://neue.cc/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

foreach (var arvhives in doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;))
{
    var page = await context.OpenAsync(arvhives.Href);

    // content(ページ本体)下のimgを全部。
    // 今回はページ単位で5並列ダウンロードすることにする(粒度の考え方は色々ある)
    var imgs = page.QuerySelectorAll&lt;IHtmlImageElement&gt;(&quot;#content img&quot;);
    await Parallel.ForEachAsync(imgs, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (img, ct) =&gt;
     {
         var url = new Url(img.Source);
         var response = await loader.FetchAsync(new DocumentRequest(url)).Task;

         // とりあえず雑にFile書き出し。
         Console.WriteLine($&quot;Downloading {url.Path}&quot;);
         using (var fs = new FileStream(@$&quot;C:\temp\neuecc\{url.Path.Replace('/', '_')}&quot;, FileMode.Create))
         {
             await response.Content.CopyToAsync(fs, ct);
         }
     });
}
</code></pre>
<p>.NET 6から <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.parallel.foreachasync">Parallel.ForEachAsync</a> が追加されたので、asyncコードを並列数(MaxDegreeOfParallelism)で制御した並列実行が容易に書けるようになりました。async/await以降、Parallel系の出番は圧倒的に減ったのは確かなのですが、Task.WhenAllだけだと並列に走りすぎてしまって逆に非効率となってしまって、そこを制御するコードを自前で用意する必要が出てきていたりと面倒なものも残っていました。それが、このParallel.ForEachAsyncで解消されたと思います。</p>
<h2>Kurukuru Progress</h2>
<p>数GBの動画をダウンロードする時などは、プログレスがないとちゃんと動いているのか確認できなくて不便です。しかし、ただ単にConsole.WriteLineするだけだとログが凄い勢いで流れていってしまって見辛くて困りものです。そこを解決するC#ライブラリが<a href="https://github.com/mayuki/Kurukuru">Kurukuru</a>で、見ればどんなものかすぐわかるので、まずは実行結果を見てもらいましょう（素の回線だと一瞬でダウンロード終わってしまったので回線の低速シミュレーションしてます）</p>
<p><img src="https://user-images.githubusercontent.com/46207/144711389-7fa99e14-3f77-4fef-a7e7-5d12724aacd1.gif" alt="guruguru" /></p>
<p>一行だけを随時書き換えていってくれるので、見た目も非常に分かりやすくて良い感じです。これはとても良い。Kurukuru、今すぐ使いましょう。ちなみに今回の記事で一番時間がかかったのは、Kurukuruの並列リクエスト対応だったりして（対応していなかったのでコード書いてPR上げて、今日リリースしてもらいましたできたてほやほやコード）。</p>
<p>AngleSharp側のコードですが、この例は<a href="https://file-examples.com/index.php/sample-video-files/sample-mp4-files/">File Examples
</a>のMP4を並列で全部取るというものです。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;
using Kurukuru;
using System.Text;

// Kurukuruを使う上で大事なおまじない
// え、デフォルトのEncodingがUTF8じゃないシェルがあるんです！？←Windows
Console.OutputEncoding = Encoding.UTF8;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://file-examples.com/index.php/sample-video-files/sample-mp4-files/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

// ここから本体
var mp4s = doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;a&quot;).Where(x =&gt; x.Href.EndsWith(&quot;.mp4&quot;));
Console.WriteLine(&quot;Download sample-mp4-files&quot;);
await Parallel.ForEachAsync(mp4s, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (mp4, ct) =&gt;
{
    var bin = await loader.FetchBytesAsync(mp4.Href);
    // あとはFile.WriteAllBytesするとか好きにして
});
</code></pre>
<p>ポイントは <code>var bin = await loader.FetchBytesAsync(mp4.Href);</code> で、これは拡張メソッドです。loaderにProgress付きでbyte[]返すメソッドを生やしたことで、随分シンプルに書けるようになりました。StreamのままFileStreamに書いたほうがメモリ節約的にはいいんですが、中途半端なところでコケたりした場合のケアが面倒くさいので、ガチガチなパフォーマンスが重視される場合ではないならbyte[]のまま受けちゃってもいいでしょう。1つ4GBの動画を5並列なんですが？という場合でも、たかがメモリ20GB程度なので普通にメモリ積んで処理すればいいっしょ。</p>
<p>FetchBytesAsyncの中身は以下のようなコードになります。</p>
<pre><code class="language-csharp">public static class DocumentLoaderExtensions
{
    public static async Task&lt;byte[]&gt; FetchBytesAsync(this IDocumentLoader loader, string address, CancellationToken cancellationToken = default)
    {
        var url = new AngleSharp.Url(address);
        var response = await loader.FetchAsync(new DocumentRequest(url)).Task;
        if (response.StatusCode != System.Net.HttpStatusCode.OK)
        {
            return Array.Empty&lt;byte&gt;(); // return empty instead of throws error(ここをどういう挙動させるかは好みで……。)
        }

        // Content-Lengthが取れない場合は死でいいということにする
        var contentLength = int.Parse(response.Headers[&quot;Content-Length&quot;]);

        using var progress = new ProgressSpinner(url.Path.Split('/').Last(), contentLength);
        try
        {
            return await ReadAllDataAsync(response.Content, contentLength, progress, cancellationToken);
        }
        catch
        {
            progress.Cancel();
            throw;
        }
    }

    static async Task&lt;byte[]&gt; ReadAllDataAsync(Stream stream, int contentLength, IProgress&lt;int&gt; progress, CancellationToken cancellationToken)
    {
        var buffer = new byte[contentLength];
        var readBuffer = buffer.AsMemory();
        var len = 0;
        while ((len = await stream.ReadAsync(readBuffer, cancellationToken)) &gt; 0)
        {
            progress.Report(len);
            readBuffer = readBuffer.Slice(len);
        }
        return buffer;
    }
}

public class ProgressSpinner : IProgress&lt;int&gt;, IDisposable
{
    readonly Spinner spinner;
    readonly string fileName;
    readonly int? totalBytes;
    int received = 0;

    public ProgressSpinner(string fileName, int? totalBytes)
    {
        this.totalBytes = totalBytes;
        this.fileName = fileName;
        this.spinner = new Spinner($&quot;Downloading {fileName}&quot;);
        this.spinner.Start();
    }

    public void Report(int value)
    {
        received += value;
        if (totalBytes != null)
        {
            var percent = (received / (double)totalBytes) * 100;
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)} / {ToHumanReadableBytes(totalBytes.Value)} ( {Math.Floor(percent)}% )&quot;;
        }
        else
        {
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)}&quot;;
        }
    }

    public void Cancel()
    {
        spinner.Fail($&quot;Canceled {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    public void Dispose()
    {
        spinner.Succeed($&quot;Downloaded {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    static string ToHumanReadableBytes(int bytes)
    {
        var b = (double)bytes;
        if (b &lt; 1024) return $&quot;{b:0.00} B&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} KB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} MB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} GB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} TB&quot;;
        b /= 1024;

        return $&quot;{0:0.00} PB&quot;;
    }
}
</code></pre>
<p>KurukuruのSpinnerを内包した <code>IProgress&lt;T&gt;</code> を作ってあげて、その中でよしなにやってあげるということにしました。まぁちょっと長いですが、一回用意すれば後はコピペするだけなので全然いいでしょう。みなさんもこのProgressSpinner、使ってやってください。</p>
<h2>コマンド引数やロギング処理やオプション取得</h2>
<p>クローラーとしてガッツシやりたいなら、モードの切り替えとかロギングとか入れたいです、というか入れます。そこで私が定形として使っているのは<a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a>と<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>。Cysharpの提供です。ワシが作った。それと今回のようなケースだと<a href="https://github.com/Cysharp/Kokuban">Kokuban</a>も便利なので入れます。やはりCysharpの提供です。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;AngleSharp&quot; Version=&quot;1.0.0-alpha-844&quot; /&gt;
    &lt;PackageReference Include=&quot;Kurukuru&quot; Version=&quot;1.4.0&quot; /&gt;
    &lt;PackageReference Include=&quot;ConsoleAppFramework&quot; Version=&quot;3.3.2&quot; /&gt;
    &lt;PackageReference Include=&quot;ZLogger&quot; Version=&quot;1.6.1&quot; /&gt;
    &lt;PackageReference Include=&quot;Kokuban&quot; Version=&quot;0.2.0&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>この場合Program.csは以下のような感じになります。割と短いですよ！</p>
<pre><code class="language-csharp">using ConsoleAppFramework;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Text;
using ZLogger;

Console.OutputEncoding = Encoding.UTF8;

await Host.CreateDefaultBuilder()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.AddZLoggerConsole();
        x.AddZLoggerFile($&quot;logs/{args[0]}-{DateTime.Now.ToString(&quot;yyyMMddHHmmss&quot;)}.log&quot;);
    })
    .ConfigureServices((hostContext, services) =&gt;
    {
        services.Configure&lt;NanikaOptions&gt;(hostContext.Configuration.GetSection(&quot;Nanika&quot;));
    })
    .RunConsoleAppFrameworkAsync(args);

public class NanikaOptions
{
    public string UserId { get; set; } = default!;
    public string Password { get; set; } = default!;
    public string SaveDirectory { get; set; } = default!;
}
</code></pre>
<p>コンソールログだけだとウィンドウ閉じちゃったときにチッとかなったりするので（？）、ファイルログあると安心します。ZLoggerは秘伝のxmlコンフィグなどを用意する必要なく、これだけで有効化されるのが楽でいいところです。それでいてパフォーマンスも抜群に良いので。</p>
<p>ConsoleAppFrameworkはGenericHostと統合されているので、コンフィグの読み込みもOptionsで行います。appsettings.jsonを用意して</p>
<pre><code class="language-json">{
  &quot;Nanika&quot;: {
    &quot;UserId&quot;: &quot;hugahuga&quot;,
    &quot;Password&quot;: &quot;takotako&quot;,
    &quot;SaveDirectory&quot;: &quot;C:\\temp\\dir&quot;,
  }
}
</code></pre>
<p>.csprojのほうに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;None Update=&quot;appsettings.json&quot;&gt;
    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>と書いてあげれば、自動で読み込まれるようになるという仕様です。そして本体のコードは</p>
<pre><code class="language-csharp">public class NanikaDownloader : ConsoleAppBase
{
    readonly ILogger&lt;NanikaDownloader&gt; logger;
    readonly NanikaOptions options;

    // コンストラクタインジェクションでOptionsを受け取る
    public NanikaDownloader(ILogger&lt;NanikaDownloader&gt; logger, IOptions&lt;NanikaOptions&gt; options)
    {
        this.logger = logger;
        this.options = options.Value;
    }

    public async Task DownloadAre()
    {
        // Context.CancellationTokenを渡すのを忘れないように！(Ctrl+Cのキャンセル対応に必須)
        await loader.FecthAsyncBytes(&quot;...&quot;, Context.CancellationToken)
    }

    public async Task DownloadSore(int initialPage)
    {
        // Kokubanを使うとConsoleに出す文字列の色分けが簡単にできる！( `Chalk.Color +` だけで色が付く)
        logger.LogInformation(Chalk.Green + $&quot;Download sore {initialPage} start&quot;);
    }
}
</code></pre>
<p>のように書きます。これの場合は、引数で <code>NanikaDownloader.DownloadAre</code>, <code>NanikaDownloader.DownloadSore -initialPage *</code> の実行切り替えができるようになるわけですね……！</p>
<p>また、文字色が一色だけだとコンソール上のログはかなり見づらいわけですが、Kokubanを使うことで色の出し分けが可能になります。これは、地味にめちゃくちゃ便利なのでおすすめ。別にバッチ系に限らず、コンソールログの色を調整するのってめっちゃ大事だと、最近実感しているところです。</p>
<p>ASP .NET Core(とかMagicOnionとか)で、ZLoggerでエラーを赤くしたい！とか、フレームワークが吐いてくる重要でない情報はグレーにして目立たなくしたい！とかの場合は、ZLoggerのPrefix/SuffixFormatterを使うのをオススメしてます(Kokubanのようにさっくり書けはしないのですが、まぁConfigurationのところで一回やるだけなので)</p>
<pre><code class="language-csharp">logging.AddZLoggerConsole(options =&gt;
{
#if DEBUG
    // \u001b[31m =&gt; Red(ANSI Escape Code)
    // \u001b[0m =&gt; Reset
    // \u001b[38;5;***m =&gt; 256 Colors(08 is Gray)
    options.PrefixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error)
        {
            ZString.Utf8Format(writer, &quot;\u001b[31m[{0}]&quot;, info.LogLevel);
        }
        else
        {
            if (!info.CategoryName.StartsWith(&quot;MyApp&quot;)) // your application namespace.
            {
                ZString.Utf8Format(writer, &quot;\u001b[38;5;08m[{0}]&quot;, info.LogLevel);
            }
            else
            {
                ZString.Utf8Format(writer, &quot;[{0}]&quot;, info.LogLevel);
            }
        }
    };
    options.SuffixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error || !info.CategoryName.StartsWith(&quot;MyApp&quot;))
        {
            ZString.Utf8Format(writer, &quot;\u001b[0m&quot;, &quot;&quot;);
        }
    };
#endif

}, configureEnableAnsiEscapeCode: true); // configureEnableAnsiEscapeCode
</code></pre>
<p>こういうの、地味に開発効率に響くので超大事です。やっていきましょう。</p>
<h2>まとめ</h2>
<p>AngleSharpにかこつけてウォッチウィンドウをとにかく紹介したかったのです！ウォッチウィンドウ最強！値の変化があると赤くなってくれたりするのも便利ですね、使いこなしていきましょう。別にUnityとかでもクソ便利ですからね？</p>
<p>あ、で、AngleSharpはめっちゃいいと思います。他の言語のスクレピングライブラリ(Beautiful Soupとか)と比べても、全然張り合えるんじゃないかな。冒頭に書きましたがE2Eテストへの応用なども考えられるので、使いこなし覚えるのとてもいいんじゃないかと思います。ドキュメントが色々書いてあるようで実は別にほとんど大したこと書いてなくて役に立たないというのは若干問題アリなんですが、まぁ触って覚えるでもなんとかなるので、大丈夫大丈夫。</p>
</div>
<h1><a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a></h1>
<ul class="date"><li>2021-11-21</li></ul>
<div class="entry_body"><p>見た目はほとんど変わっていませんが(とはいえ横幅広くしたので印象は結構変わったかも)、このサイト、フルリニューアルしました。内部構造が。完全に。別物に。元々はWordPressだったのですが、今回から自作の静的サイトジェネレーターでhtmlを生成し、GitHub Pagesでホストするようにしました。元になるソース(<code>.md</code>)もGitHub上に置き、GitHub ActionsでビルドしてGitHub Pagesでホスティングされるという、完全GitHub完結ソリューション。また、記事を書くエディタも<a href="https://docs.github.com/ja/codespaces/the-githubdev-web-based-editor">GitHub web-based editor</a>(リポジトリのトップで<code>.</code>を打つと、VS Codeそのものが起動するやつ)を利用することで、非常に快適で、というかMarkdownエディタとしては最高品質のものが乗っかっていて、たかがブログ書くにしては面倒くさいPush/Pullもなくダイレクトコミットで反映出来てしまうというのがとても良い体験になっています。</p>
<ul>
<li><a href="https://github.com/neuecc/Blog2/">neuecc/Blog2</a></li>
</ul>
<p><code>.</code>でエディタを起動して、<a href="https://github.com/neuecc/Blog2/tree/master/articles">articles</a>配下に<code>YYYY-MM-DD.md</code>ファイルを新規作成。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737666-ec09db39-d517-4fb9-aa9f-b61bfb2cbfe7.png" alt="image" /></p>
<p>完全にVS Codeそのものでデスクトップアプリのものと全く区別が付かないレベルで、これを超える品質のエディタを普通のサイトに乗せることは不可能でしょう。当然もちろん画像のプレビューもできますし、なんだったら拡張すら入る。</p>
<p>GitHub管理だと画像置き場（アップロード）が面倒くさい問題があるのですが、これはIssueを画像アップローダーとして使うことで回避しています。Issueの入力フォームは、画像をCtrl+Vでそのままアップロードが可能です。そして嬉しいことに、マークダウンに変換してくれているのでコピペするだけでOK。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736683-d2b2acac-8523-4f54-a325-c1dbb12aa959.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/142736700-18928390-e53b-4014-a931-9cd974afcf56.png" alt="image" /></p>
<p>上がった先の<code>user-images.githubusercontent</code>は別にIssueそのものと紐付いているわけではないので、 アップローダ用に使ったIssueはSubmitすることなくポイ、です。そうしてどこにも紐付いていない<code>user-images.githubusercontent</code>ですが、別にだからといって削除されることもなく永続的に上がり続けているので、遠慮なく使わせてもらうことにします。まぁちゃんとGitHub上に上げてるコンテンツ用に使っているので、許されるでしょう、きっと。多分。</p>
<p>そうして出来上がった記事は、そのままエディタ上のgit UIからコミットすると、自身が作業している領域は直接サーバー上のmaster(main)なので、プッシュ不要で反映されます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png" alt="image" /></p>
<p>こうなると、もうWordPressで投稿をポスト、するのと変わらないわけです。ブログ記事程度でcloneしてpullしてstagingしてpushしてというのは地味に重たいので、このぐらい身軽で行きたいですね。（実際、投稿後に編集ラッシュとかよくあるので、ちょっと手数が増えるだけで猛烈に嫌気がさす）</p>
<p>ジェネレートは<a href="https://github.com/neuecc/Blog2/blob/master/.github/workflows/build.yml">workflows/buildy.yml</a>で、このリポジトリ内に配置されてるC#プロジェクトを直接ビルド/実行することで生成処理をしています。<code>dotnet run</code>便利。</p>
<pre><code class="language-yaml">build-blog:
runs-on: ubuntu-latest
steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.x
    - run: dotnet run --project ./src/Blog2/Blog2.csproj -c Release -- ./articles ./publish
    - uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./publish
        keep_files: true
</code></pre>
<p>生成されたファイルは<a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a>を使って<code>gh-pages</code>ブランチと同期します。その際、デフォルトでは既に上がってるファイルを全削除してしまうので、今回はstyleやassetを、同期とは別に置いてあるので削除されると困るので、<code>keep_files: true</code>も指定しています。そうすると記事の削除がしづらくなるんですが、記事の削除はしない or どうしても削除しなかったら二重に(articlesとgh-pages)削除すればいいだけ、という運用で回避。</p>
<p>と、いうわけでシステム的には満足です。</p>
<p>C#でも<a href="https://www.statiq.dev/">Statiq</a>などといった静的サイトジェネレーターは存在するのですが、あえて自作した理由は、サイトのシステムをそっくり移行するという都合上、URLを前のものと完璧に合わせたかったというのがあります。<a href="https://github.com/neuecc/Blog2/tree/gh-pages">生成結果のファイル一覧</a>が若干変というかクドいというか、といったところがあるのですが、これは前のWordPressでやっていたルーティングをそのまんま再現するためということで。WordPressからのエクスポートも、DB直接見てC#でそのままテーブルダンプから作ったので、まぁ別に大したコードが必要なわけでもないので一気に作っちゃえという気になったというのもあります。</p>
<p>外部ライブラリとしてはMarkdownのHTML化に<a href="https://github.com/xoofx/markdig">Markdig</a>を採用しました。色々高機能ではあるのですが、今回は <code>Markdown.ToHtml(input)</code> しか使っていませんけれど、感触的にはとても良かったです。</p>
<p>シンタックスハイライトには<a href="https://prismjs.com/">Prism.js</a>を用いました。Markdigの出力する```csharpの変換を、特に何も意識せずとも対象にしてくれるのが良かったですね。プラグインはautoloaderとnormalize-whitespaceを合わせて投下しています。</p>
<pre><code class="language-html">&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js&quot;&quot;&gt;&lt;/script&gt;
</code></pre>
<h2>まとめ</h2>
<p>最近ブログ投稿がだいぶ減ってしまっていたのですが、システムも一新したことでやる気が出てきたのでいいことです。まぁ見た目は本当にあんま全然変わってないんですが……！</p>
<p>なお、反映に必要な所要時間は30秒弱。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737556-eac40d7a-46c8-4534-96de-38895104d4cb.png" alt="image" /></p>
<p>遅いっちゃあ遅いですが、許容できるといえば許容できますね。サイトジェネレートプログラムの実行時間自体は1秒以下で、別に全然時間かかってないんで、CIセットアップとか、それ以外の時間が何かとかかっちゃってます。GitHub Actionsの仕組み的にしょうがないといえばしょうがないんですが、もう少しなんとかなってほしいかなあ。あとGitHub Pages自体が反映が若干遅い。遅い上に進捗が分からないのが地味にストレスフル。とはいえとはいえ、良いんじゃあないでしょうか。良さの殆どはGitHub web-based editorから来てますね、これは本当に革命的に良い。というわけで、このweb-based editorを活かすシステムを作っていくという手段と目的を逆転させた思考が最終的に実際良いんじゃないかと思ってます！</p>
</div>
<h1><a href="https://neue.cc/2021/08/23_602.html">C#でgoogle/zx風にシェルスクリプトを書く</a></h1>
<ul class="date"><li>2021-08-23</li></ul>
<div class="entry_body"><p>あまりシェルスクリプトを書かない私なのですが（小物でもなんでも書き捨てC#で書くスタイル）、CI だの .NET Core だのなんなので、全く書かないというわけにもいかない昨今です。まぁしかしcmdは嫌だし今更(？)PowerShellもなぁという感じもあり、bashねぇ、とかブツブツ言いながらしょっぱいスクリプトを書く羽目になるわけです。</p>
<p>そこに颯爽と現れたのが <a href="https://github.com/google/zx">google/zx</a>。素敵そうだなーと思いつつJavaScriptを日常的に書くわけでもないのでスルーしてたのですが、こないだも<a href="https://scrapbox.io/lacolaco-engineering/%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E8%A4%87%E9%9B%91%E3%81%AA%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92JavaScript%E3%81%A7%E6%9B%B8%E3%81%8F">ちょっと複雑なシェルスクリプトをJavaScriptで書く</a>で紹介されていて、なるほど色物じゃなくて便利なのか、そうだよね便利だよね！と思い、私は日常的にC#を書くので、C#だったら便利だな、同じ感じで書けるなら、と、思い至ったのでした。</p>
<p>というかまぁzx見て思ったのが、これぐらいの内部DSL、C#でもいけるよ、ということであり……。そして以下のようなものが誕生しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/130373766-0f16e9ad-57ba-446b-81ee-c255c7149035.png" alt="image" /></p>
<p>もともと<a href="http://neue.cc/2020/01/30_590.html">ProcessX - C#でProcessを C# 8.0非同期ストリームで簡単に扱うライブラリ</a>というものを公開していたので、更にそれをDSL風味に、zxっぽくシンタックスを弄りました。C# 5.0 async/awaitの拡張性、C# 6.0 using static、C# 6.0 String Interpolation、そしてC# 9.0のTop level statementsと、C#も内部DSLを容易にする構文がどんどん足されています。現在previewのC# 10.0でも、Improvement Interpolated Stringsとして、InterpolatedStringHandlerによって$&quot;&quot;の生成時の挙動そのものを生で弄ることが可能になり、よりますます表現のハックが可能になり、色々と期待が持てます。</p>
<p>さて、で、これが使いやすいかというと、見た通りで、使いやすい、です……！stringをawaitしていることに一瞬違和感はめちゃくちゃあるでしょうが、DSLだと思って慣れれば全然自然です（そうか？）。なんか言われてもgoogle/zxなもんです、で逃げれば説得力マシマシになった（そうか？）のが最高ですね。cmd/PowerShell/bashに対する利点は、google/zxの利点と同じように</p>
<ul>
<li>型が効いてる(C#なので)</li>
<li>async/awaitが便利(C#なので)</li>
<li>フォーマッタもある(C#なので)</li>
<li>エディタ支援が最高(C#なので)</li>
</ul>
<p>ということで、ぜひぜひお試しください。</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">https://github.com/Cysharp/ProcessX</a></li>
<li>PM&gt; Install-Package ProcessX</li>
</ul>
<h2>csx vs new csproj vs ConsoleAppFramework</h2>
<p>C#には.csxという失われしC#スクリプティングな構文が用意されていて、まさに1ファイルでC#の実行が完結するのでこうしたシェルスクリプト風味に最適、と思いきや、実行もエディッティング環境も貧弱で、まさに失われしテクノロジーになっているので、見なかったことにしておきましょう。実際、より良いC#スクリプティング的なシンプルC#の提案が <a href="https://github.com/dotnet/designs/pull/213">Add Simple C# Programs</a> として出ています(つまりcsxは完全に産廃、NO FUTURE……)。提案(<a href="https://github.com/dotnet/designs/blob/a27fd42a68370f315bc2293dc748145f4075697f/proposed/simple-csharp-programs.md">proposed/simple-csharp-pgorams.md</a>)読むと面白いですが、ちょっと少し時間かかりそうですね。</p>
<p>というわけで、csprojとProgram.csの2ファイル構成が良いんじゃないかと思います。ちょっと冗長ではあるけれど、しょーがないね。実行に関しては dotnet run でビルドと実行がその場でできるので、ビルドなしの直接スクリプト実行みたいな雰囲気にはできます。これは普通に便利で、CIとかでもgit pullしている状態のリポジトリ内のスクリプトに対して一行でdotnet run書くだけで動かせるので、非常に良い。こうした .NET Core以降のシンプルになったcsprojとdotnetコマンドの充実から、csxの価値がどんどん消えていったんですねえ。</p>
<p>さて、実際のプロジェクトなどでは、そもそもシェルスクリプト（に限らずバッチなんかも）は一つどころか大量にあったりすることもあるでしょう。そこでCysharpの提供している<a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a>を使うと、クラスを定義するだけで簡単に実行対象を増やしていけるので、大量のスクリプトの管理を1csprojでまかなうことが可能になります。実行は dotnet run -- foo/bar のようにすればいいだけです。非常におすすめ。シェルスクリプト的なものは、ConsoleAppFramework + ProcessX/zx で書いて回るのは、悪くない選択になると思います。</p>
</div>
<a href="https://neue.cc/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2023<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
