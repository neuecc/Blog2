<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2011-05-24" data-pagefind-meta="published:2011-05-24"><a href="https://neue.cc/2011/05/24_324.html">基礎からのCode Contracts</a></h1>
<ul class="date"><li>2011-05-24</li></ul>
<div class="entry_body"><p>23日に<a href="http://msdn.microsoft.com/en-us/devlabs/dd491992">Code Contracts</a>についてのセッションを行いました。</p>
<div style="width:595px" id="__ss_8069150"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/code-contracts-8069150" title="基礎からのCode Contracts">基礎からのCode Contracts</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/8069150?rel=0" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/neuecc">neuecc</a> </div> </div>
<p>ufcppさんのレポートとセッション資料は<a href="http://csharp-users.jp/meeting/%E7%AC%AC7%E5%9B%9E%E6%97%A5%E6%9C%ACc-%E3%83%A6%E3%83%BC%E3%82%B5%E3%83%BC%E4%BC%9A-%E5%8B%89%E5%BC%B7%E4%BC%9A%E3%83%AC%E3%83%9B%E3%83%BC%E3%83%88">第7回日本C#ユーザー会 勉強会レポート - 日本 C# ユーザー会</a>に。Code Contractsを説明する場合、通常は背後にあるDesign By Contractの説明をしてから流れると思うのですが、今回はufcppさんが前の時間で受け持ってくれたので、その辺は完全スルーで.NET上のCode Contractsの話のみにフォーカスしています。</p>
<p>標準入りしているようだけど何なの？→実際は標準入りとは全然言えません というところから入って、主眼はバイナリリライター、ということで、セッションでは<a href="http://reflector.red-gate.com/">.NET Reflector</a>を片手にどのようにリライトされるかを見ていきました。どう展開されるのかをそうして確認すると、仕組みが理解しやすいのではないかと思います。Reflector有料化ということで、代替も色々出てきているようですが、私はReflector使い続けますね。他のはまだ低速だったりと色々引っかかるところが多いので。それとまあ、恩返しというか、今までお世話になっていますし。</p>
<p>Code Contractsは<a href="http://msdn.microsoft.com/en-us/devlabs">DevLabs</a>の中でも、Axumは死亡が確定(Blogに開発チームｵﾜﾀと書いてあった、ページから消えるのも時間の問題？)だし、Dolotoは明らかに開発止まってて何故残り続けているのかが分からないぐらいだし、というわけで最古株となっていますね。GT先輩いつ卒業するの！（やっとしました！）という感じな某車ゲーを少し思い起こしたり。卒業出来る日は来るのでしょうか。</p>
<p>それにしてもDevLabsはTC Labsばかりとなってしまい、何かツマラナサも感じてしまうような。というかtcのロゴの3って、最初にリリースされたSho, Dataflow, Dryadと3つだから3なのかと思ってましたが、最近Solver Foundationも入ってしまって4じゃねーか、という感。ていうかSolver Foundationは結構イケてるロゴがあるので、別にTCを冠しなくても良かったような。DryadはDryadで、<a href="http://blogs.technet.com/b/windowshpc/archive/2011/05/20/dryad-becomes-linq-to-hpc.aspx">'Dryad' becomes 'LINQ to HPC' !</a>だそうで、色々整理しきれてない感。</p>
<p>ところでスライド作りは結構楽しくはあるんですが、やっぱ大変ですねー。コードはコンパクトでなければならないし、全体的にしっかり流れが整ってなければならないし。かなり考えますが、そのお陰で、私の普段のだらだらブログ記事よりは分かりやすさアップしてるかな？というところです、前回のRxのスライド - <a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>もそうでしたが。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-21" data-pagefind-meta="published:2011-05-21"><a href="https://neue.cc/2011/05/21_323.html">Reactive Extensionsで非同期処理を簡単に</a></h1>
<ul class="date"><li>2011-05-21</li></ul>
<div class="entry_body"><p><a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a>にて、Reactive Extensionsの概要と、特に非同期を中心に話しました。以下、発表資料になります。</p>
<div style="width:640" id="__ss_8049041"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041" title="Reactive Extensionsで非同期処理を簡単に">Reactive Extensionsで非同期処理を簡単に</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/8049041" width="640" height="534" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/neuecc">neuecc</a> </div> </div>
<p>当初は初心者向け、と思ったんですが、どう見ても一回触ったことのある人向けですねこれ……。Rxを触ったことない人は、よくわからないけど普通に書くと大変なのがスッキリして何だか凄そう、触ってみようと思ってもらえれば。Rxを既に触っている人には使いこなしのTipsとして役立てて貰えればと思います。</p>
<p><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="480" height="296" id="utv73143" name="utv_n_921786"><param name="flashvars" value="loc=%2F&amp;autoplay=false&amp;vid=14850251&amp;locale=ja_JP&amp;hasticket=false&amp;v3=1" /><param name="allowfullscreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="src" value="http://www.ustream.tv/flash/viewer.swf" /><embed flashvars="loc=%2F&amp;autoplay=false&amp;vid=14850251&amp;locale=ja_JP&amp;hasticket=false&amp;v3=1" width="480" height="296" allowfullscreen="true" allowscriptaccess="always" id="utv73143" name="utv_n_921786" src="http://www.ustream.tv/flash/viewer.swf" type="application/x-shockwave-flash" /></object></p>
<p>はい、Ustreamも残っています。マイクがなかったからという言い訳をしますが、声が全然入ってないですね、声入ってないということは会場でもモゴモゴーという感じで聞き取りにくかったはずで、すみません。それと、「まぁ」言い過ぎ。繋ぐ言葉を捜す枕詞として使いまくりで、うわちゃー、という感じ。慣れてないというか、こういうの（ほぼ）初めてで全然分かってなかったんですが、これを活かして次も頑張りたいです。（Usreamで自分の発表が自分で後から見れるのは自分が嬉しい(笑)）。スピーカーできて楽しかったです。機会をくれたすまべんの方々に感謝します。</p>
<p>……こういう機会がないと中々まとめないよね、というのもかなりあったり。合成系のメソッドの図はずーっと書こうと思っていて、書いてなくてこのセッションが初めてです。IObservableは時間軸に乗っているという話もこれが初めて。Twitterでボソッと書くだけじゃなくて、しっかりブログにまとめるようにならないといけないなぁ。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-17" data-pagefind-meta="published:2011-05-17"><a href="https://neue.cc/2011/05/17_322.html">Reactive Extensionsによる非同期クエリ</a></h1>
<ul class="date"><li>2011-05-17</li></ul>
<div class="entry_body"><p><a href="http://www.infoq.com/jp/news/2011/05/akka11">InfoQ: Future、性能、依存性の低減など多くの改善がされたAkka 1.1リリース</a>から「- Futureは完全にモナドになった。したがってfor内包表記を利用できる。」。リスト内包表記は、ようするところLINQなわけなので、では、とりあえず<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">C# + Reactive Extensions</a>で。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 非同期に対するLINQ(map, filter, etc...)
var asyncQuery =
    from a in Observable.Start(() =&gt; 10 / 2)
    from b in Observable.Start(() =&gt; a + 1)
    from c in Observable.Start(() =&gt; a - 1)
    select b * c;

// 非同期のまま実行したいならSubscribe
var canceler = asyncQuery.Subscribe(Console.WriteLine);

// 実行をキャンセルする場合はSubscribe時の戻り値をDispose
canceler.Dispose();

// 同期的に待って値取得したいならFirst
var result = asyncQuery.First();
</code></pre>
<p>Rx抜きで、TaskのContinueWithで↑を書くのはカッタルイ。また、Rxでもメソッド構文でSelectManyを連鎖でも辛い。何故か、というと、aの値をcの部分で使えないから。メソッドチェーンの形だと、どうしても一つ手前の値しか持ち越せない。そこで、クエリ構文が活きます。また、LINQであるが故にクエリ構文が使えるRxの嬉しさ。</p>
<p>じゃあ、調子にのって<a href="http://akka.io/docs/akka/1.1/scala/futures.html">Futures (Scala) — Akka Documentation</a>をRxで書き換えてみようかしら。同じような内容としては以前に<a href="http://neue.cc/2010/10/09_278.html" title="neue cc - Rxを使って非同期プログラミングを簡単に">Rxを使って非同期プログラミングを簡単に</a>という記事でTaskと比較していたのでそちらも参照を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// directly
var f1 = Observable.Return(&quot;Hello World&quot;);

// LINQが使える
var f2 = f1.Select(x =&gt; x.Length);

// Subscribeまで実行が遅延されるのでSleepしないよ
var f3 = Observable.Defer(() =&gt;
{
    Thread.Sleep(1000);
    return Observable.Return(&quot;Hello World&quot;);
});
var f4 = f3.Select(x =&gt; x.Length); // まだ実行されないよ
var result = f4.First(); // ここで実行

// Observableの連鎖はSelectManyで
var f5 = f1.SelectMany(x =&gt; f3);

// SelectManyはクエリ構文のfrom連打でも置き換えられる
var f6 = from a in Observable.Return(10 / 2)
         from b in Observable.Return(a + 1)
         from c in Observable.Return(a - 1)
         select b * c;
</code></pre>
<p>と、この辺まではいいんですが、Composing Futuresが何やってるのかよくわからないので(Scala知識ゼロですみません)、眺めながら<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360" title="Visual Studio Asynchronous Programming">Async CTP</a>でも持ち出します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async void HomuHomu()
{
    var f1 = Observable.Return(100); // IObservable&lt;int&gt;
    var f2 = TaskEx.FromResult(200); // Task&lt;int&gt;

    var a = await f1; // 何気にIObservable&lt;T&gt;はawait出来る
    var b = await f2; // 当然ですがTask&lt;T&gt;もawait出来る
    var result = a + b; // 300

    // じゃあObservableが幾つも値持ってる場合は？
    var f3 = new[] { &quot;homu&quot;, &quot;mado&quot; }.ToObservable();
    var c = await f3;
    Console.WriteLine(c); // &quot;mado&quot;

    // つまり、完了まで待って(OnCompleted)、最後の値が取得される

    // ところでObservable.Return = TaskEx.FromResultなわけですが
    // 以下の3つも同じと捉えていいです
    Task.Factory.StartNew(() =&gt; 100);
    TaskEx.Run(() =&gt; 200);
    Observable.Start(() =&gt; 300); // つまりfunc自体は即時実行
    
    // こちらも等しい(実行が遅延される)
    var t = new Task&lt;int&gt;(() =&gt; 100);
    var o = Observable.ToAsync(() =&gt; 100);
    // 実行するには
    t.Start();
    o.Invoke(); // もしくは o() ←ただのデリゲートなので

    // ToAsyncでは実行時に引数を渡すことも可能
    var o2 = Observable.ToAsync((int arg) =&gt; arg * 2);
    o2(1000).Select(x =&gt; x).Subscribe(Console.WriteLine);
}
</code></pre>
<p>雰囲気で何となくそうなのだろうと思いつつ、よくわからないので、適当に解釈しながら次。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IObservable&lt;T&gt;はそのものがリスト状態とも言えるので、
// 複数値を持てるし、LINQなのでSelectしてAggregateも出来る
var futureSum = Observable.Range(1, 1000)
    .Select(x =&gt; x * 2)
    .Sum();
    
var sum = futureSum.First();
</code></pre>
<p>とりあえずこの辺で(特に言いたいことはない)。全く読めないとこういう時辛い。ActorとReactiveの関係とは、とか、見えそうな見えないような気持ち悪さが脳に渦巻いていて、勉強したいところです。F#で。</p>
<h2>上の話とは関係なく告知</h2>
<p>二件ほどお話を頂いたので、セッションします。まず、2011/05/21(Sat)にすまべん特別編でRxについて。内容はRx全般になるので、WP7ではなくても適用出来る話になります。</p>
<ul>
<li><a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a></li>
</ul>
<p>Rxの多くの機能のうち非同期に絞って、かつ、初心者向けに説明しますので、Rxって何それ食べれるのという感じでも全然大丈夫です。また、既に触っている人も、割とためになるTipsが得られるのではないかなと思いながら資料作成中。そうなるよう頑張ります。なので、是非聞きに来てください。セッション資料は、通信環境があればセッション終了後即座に上げるつもりです。なければまた後日で。Ustreamとかもあるのかな？あれば、そちらでも。</p>
<p>もう一件、5月23日(月)にC#ユーザー会でCode Contractsについて。</p>
<ul>
<li><a href="http://csharp-users.jp/meeting/%E7%AC%AC66%E5%9B%9Ecodeseek%E5%8B%89%E5%BC%B7%E4%BC%9A%EF%BC%86%E7%AC%AC7%E5%9B%9E%E6%97%A5%E6%9C%ACc-%E3%83%A6%E3%83%BC%E3%82%B5%E3%83%BC%E4%BC%9A-%E5%8B%89%E5%BC%B7%E4%BC%9A" title="第66回codeseek勉強会＆第7回日本C#ユーザー会 勉強会 - 日本 C# ユーザー会">第66回codeseek勉強会＆第7回日本C#ユーザー会 勉強会 - 日本 C# ユーザー会</a></li>
</ul>
<p>背景であるDbCなどについてはufcppさんが説明してくださるので、私はCode Contractsとして実装されていることを、Reflectorでこうリライトされるんですねー、とか見ながらデモ中心に、「一から使ってみよう」といった内容にしようと思っています。Code Contracts…… 名前だけなら聞いたことがある、いや、名前も聞いたことない何それ、ぐらいからが対象なのぜ、是非どうぞ。もう使っている、という人には物足りないかも(むしろそこは私が教えて欲しいもがもがもがもが)。</p>
<p>どちらも、まだ参加申し込み出来るようなので是非聞きにきてください。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-11" data-pagefind-meta="published:2011-05-11"><a href="https://neue.cc/2011/05/11_321.html">Reactive Extensions RC0リリースによる変更点</a></h1>
<ul class="date"><li>2011-05-11</li></ul>
<div class="entry_body"><p>DevLabsの実験的プロジェクトから<a href="http://msdn.microsoft.com/en-us/data/gg577609">Data Developer Center</a>への正式プロジェクトとして昇格したRxですが、ついにDevLabsのページ自体が消滅(リダイレクトされる)し、いよいよ実験的なノリは一段落し、正式なプロジェクトとしての道を歩み始めたようです。その手始めとして、馬鹿デカい破壊的変更がやってきました。……っていきなりなんじゃそりゃ。</p>
<p>今回の変更はRC0、そしてStableであると銘打たれ、(今度こそ)APIの破壊的変更はないものと思われます。きっとAPIを変更するなら本当の本当に最後のタイミングだから、ということなのでしょうね、変更の嵐は。そんなわけで、DLLの分け方が変わってるし、名前空間も全部変わってるし、メソッド名もばかばか変わってるし、メソッドシグネチャも変わってるし、なくなったのもあるし、大量すぎて書ききれないほどに変更点がある。</p>
<p>しかし、本当の本当に安定版の始まりなので、つまり、学ぶなら今からが正に最適ということです！また、基本的な使い方が変わったわけではないので、既存の知識は生かせますしコード自体もそのままでも大体は行けます。大体は。</p>
<p>詳しい変更内容自体はフォーラム <a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/527002a3-18af-4eda-8e35-760ca0006b98">New Release: Reactive Extensions v1.0.10425</a> に書かれています。こういうのはフォーラムじゃなくてBlogのほうでちゃんと告知してください……。リリースから半月近く経つのに、まだBlogのほうは更新されてないという。</p>
<h2>Rxの入手方法・パッケージ・DLL内容について Part2</h2>
<p>以前に<a href="http://neue.cc/2011/01/26_300.html">Reactive Extensionsを学習するためのリソースまとめ</a>としてまとめましたが、そのうちDLL内容がまるっと変わったので、そこの部分を修正します。なお、学習リソースについては変りないので、以前のまとめ記事をそのまま参照してください。また、Windows Phone 7に標準搭載されているものは(当然)変わりはありません。最近WP7本体のアップデートにコソッと紛れて更新(バグフィックス)されたようですけど。</p>
<p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>のGet itからDownloadするといいでしょう。色々書いてありますが、2のDownload the Reactive ExtensionsからRx for all Platformsを選べばよいかと思います。</p>
<p>StableとExperimentalがあるように、安定版と実験版に分かれています。そして現時点ではそのページのExperimentalをクリックしてもExperimentalは手に入りません(なにそれ……)。Experimentalが欲しい人は<a href="http://www.microsoft.com/downloads/en/results.aspx?freetext=reactive+extensions&amp;displaylang=en&amp;stype=s_basic">Microsoft Download Center: Search Results</a>のExperimental Releaseから入手するといいでしょう。バージョン番号は、Stableは1.0.10425、Experimentalは1.1.10425になっています。</p>
<p>けれど、何だかんだで更新頻度が高いので、NuGet経由での利用が一番お薦めです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rxrc0nuget.jpg">
</p>
<p>が、NuGetの画面は新旧入り乱れていて何を入れていいか分からないカオスになっていたりして。説明すると、Rx-Mainとか、名前がRx-になっているものが新しいもので選ぶべきもの。Reactive Extensions -のものは古い残骸なので無視してください。また、NuGet経由で入るものはExperimentalのほうになります。</p>
<p>さて、今回からDLL類の分類がばっさり変わりました。</p>
<ul>
<li>System.Reactive (NuGetではRx-Main)</li>
</ul>
<p>以前あったCoreExは消滅し、コアコンポーネントはSystem.Reactiveのみとなりました。また、名前空間も全てSystem.Reactive以下に集められていて、例えば今までObservableクラスはSystem.Linqでしたが、今回よりSystem.Reactive.Linqに変更されました（拡張メソッドの利用に名前空間の参照は必須なので、この名前空間のusingは忘れずに）。</p>
<ul>
<li>System.Reactive.Windows.Threading (NuGetではRx-WPF/Rx-Silverlight)</li>
</ul>
<p>WPF/Silverlight向けでDispatcherに対するObserveOnとSubscribeOnのオーバーロードが追加されています。また、Dispatcher.CurrentDispatcherに対してObserveOn/SubscribeOnを行うObserveOnDispatcher/SubscribeOnDispatcherの利用もこのDLLの参照が必要になりました。それとDispatcherに対してBeginInvokeして実行するスケジューラDispatcherSchedulerが追加されました。</p>
<p>WPF/SilverlightでRxを使う場合はこれの参照は必需と思われます。NuGetを使う場合は依存の解決で、これを選択するとRx-Mainも入れてくれるので、こちらからInstallすると良いでしょう。</p>
<ul>
<li>System.Reactive.Windows.Forms (NuGetではRx-WinForms)</li>
</ul>
<p>WindowsFormsのControlに対するObserveOnとSubscribeOnのオーバーロードが追加されています。それとControlScheduler(Controlに対してBeginInvokeして実行するスケジューラ)。それだけです。というわけで、その名の通りWinFormsで使う場合だけ、あると便利。</p>
<ul>
<li>System.Reactive.Providers (NuGetではRx-Providers)</li>
</ul>
<p>Qbservableが収納されています。QbservableはIEnumerableに対するIQueryableみたいなもので、式木からObservableを生成するためのもの。今のとこ有効活用されている例も人もいないと思われます。(というかよく正式リリースにも生き残ったものだ、ぐらいの)。ちなみにQueryable Observableの略だそうで。QBみたいなものだと思えば可愛い！</p>
<p>例えばLinq to Twitterを非同期しかないSilverlightでやるなら、これを使うのが適切でしょう。現状だとコールバックでどうだのという格好悪い仕組みなので。(但し、System.Reactive.Providersは現状ではDesktop版にしか同梱されていませんが)。あとは公式の例として挙げられているWQL Provider。WMIに対するSQLで、クエリ結果はイベント(つまりRx)になる。非常に都合よくQbservableに当てはまるようになってますね。なってるんですが、そう都合よく当てはまるのはこれぐらいしかないのではないか、感もあったり。</p>
<p>いや、むしろ全て非同期なら全部Rxでいいんですよぅー、to SqlだってSqlCommandのBeginExecuteReaderでやればIQueryableじゃなくてIQbservableの出番なんですよぅー。……とはいっても、誰がやるかって話ですね。</p>
<ul>
<li>Microsoft.Reactive.Testing.dll (NuGetではRx-Testing)</li>
</ul>
<p>ユニットテスト用のモック生成クラス群。使いやすさ的には個人的にはちょっと微妙で、今一つ上手く活用出来なくて色々見送り中。</p>
<h2>FromEvent/FromEventPattern</h2>
<p>BufferWithCount/BufferWithTimeが統合されてメソッド名がBufferになった、程度の変更は割とどうでもいいのですが、Rxの中核であるFromEventに大きな変更があったのは見逃せません。簡単に解説します。</p>
<p>今までFromEventというメソッド名だったものはFromEventPatternに変わりました。また、戻り値がIEventからEventPatternというものになりましたが、中身はプロパティにSenderとEventArgsを持つという、ほとんど同じものなので、感覚的には一緒です。今までの私の記事や古いウェブ上の記事を見る際にFromEventが使われていたら、それはFromEventPatternに置き換えてください。そうすれば、そのままで動きます。</p>
<p>では新しく新設されたことになるFromEventは何なのかというと、よくわかりません:) そのうち使い方の説明とか出てくると思うのでそれ待ちで……。いやすみません。</p>
<h2>ところでInteractiveはどうしたの？ClientProfileは？Asyncは？</h2>
<p>死にました。というのもアレですが、とりあえず先行きは不透明です。少なくともStableに同梱されることはないそうです。Experimental側でのリリースは、一応計画はされているようですが、現状は同梱されていません。どうなるんでしょうかねえ……。Interactiveは欲しい人はNuGetに古いのが残っているので、それを使えば、ですね……。</p>
<h2>Experimental</h2>
<p>さて、今のところ、どのメソッドが実験的とされているのか、見てみましょう。幸いExperimentalAttributeでマークされているので、確認はコードで容易に出来ます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">typeof(System.Reactive.Linq.Observable)
    .GetMethods()
    .Where(mi =&gt; mi.GetCustomAttributes(typeof(ExperimentalAttribute), false).Any())
    .Select(mi =&gt; mi.Name)
    .Distinct()
    .OrderBy(s =&gt; s)
    .ToList() // Interactiveが消滅してしまったから...
    .ForEach(Console.WriteLine);

// 実行結果
Case
Create // 追加のオーバーロードのみ、通常のはExperimentalではない
DoWhile
Expand
For
ForEachAsync
ForkJoin
GetAwaiter
If
IsEmpty
Let
ManySelect
Remotable
Start // 追加のオーバーロードのみ、通常のはExperimentalではない
While
</code></pre>
<p>あまり大したものは入ってないようなので、そんな気にすることもないですね。Expandは是非入れてきて欲しいところなのだけど。CreateやStartのオーバーロードはかなりややこしい事になっているので、実験的扱いなのは納得。</p>
<h2>ReactiveOAuth ver.0.3.0.0</h2>
<p>そんな大移動があったわけでReactiveOAuthも動かなくなってしまった。というわけで更新しました(WP7版の人は気にしなくてもいいです)。</p>
<ul>
<li><a href="http://reactiveoauth.codeplex.com/">ReactiveOAuth</a></li>
</ul>
<p>機能は変わってなし。とりあえず最新版のRxで動くように、というだけです。コードが、とにかく名前空間が変わったので全部書き換えて、かなり面倒……。そして一部のメソッドは名前が変わったので、WP7版と完全にコードを共有していたので発狂。ifディレクティブでメソッド呼び出し部分をひたすら書き換え、などというのは見通しも悪いし格好悪いしで最悪なので、別の方法として、WP7側に拡張メソッド作ってコード上の互換を維持するようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ObservableForCompatible
{
    // 本体のコードはRx RC0に合わせて、WP7側だけ拡張メソッドで同名のものを作って対処
    public static IObservable&lt;IList&lt;T&gt;&gt; Buffer&lt;T&gt;(this IObservable&lt;T&gt; source, int count)
    {
        return source.BufferWithCount(count);
    }
}
</code></pre>
<p>他にも挙動が若干変わってるのがあって原因掴むのに泣きそうになったりとか、思った以上に大変だった……。Stableと銘打ってるのに、次にこのクラスの大変更があったらさすがにブチ切れます。今回は、まあ、許す。</p>
<h2>Reactive Extensions Extensions(Rxx)</h2>
<p>コミュニティから面白いライブラリも上がってきています。</p>
<ul>
<li><a href="http://rxx.codeplex.com/" title="Reactive Extensions - Extensions (Rxx) - Home">Reactive Extensions - Extensions (Rxx) - Home</a></li>
</ul>
<p>Rx拡張メソッド集。C# 3.0の時も俺々拡張メソッドライブラリがいっぱい出てきましたが、そのノリですね。でも実際、Rx自体は原始的な機能のみなので、非同期処理とかイベント処理にフォーカスする場合は、もう一つ上の層で軽くラップしたライブラリは間違いなく必要だなと思っていますので、こういうのはいいな、と。私自身も非同期処理は<a href="http://neue.cc/2010/11/26_286.html" title="neue cc - Reactive Extensions用のWebRequest拡張メソッド">Reactive Extensions用のWebRequest拡張メソッド</a>として、結構ガッツし仕込んだものを使い回していて(ReactiveOAuthや<a href="http://neue.cc/2011/04/09_314.html" title="neue cc - Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション">Utakotoha </a>の内部はこれ)かなり重宝しています。余裕が出たら、このRxxプロジェクトにJoinしたいな、と思ってます。</p>
<h2>Rxの本</h2>
<p>オライリーから出ているProgramming C#でお馴染みのJesse Libertyと、共著者として<a href="http://www.reactiveui.net/" title="ReactiveUI">ReactiveUI</a>というRxでWPFのGUI面をサポートするライブラリを作成しているPaul Betts(Microsoft Office Labsに所属)による、Rxの本が今年の秋頃に出る予定です。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>執筆陣が豪華だしページ数も現時点amazon表示で300ページと、立派な仕上がりを予感させます。私は予約したよ！</p>
<h2>まとめ</h2>
<p>今回こそStableなはずなので、ようやーく人に自信を持って薦められるようになりました！いやマヂで。API的にも多分、じゃなくて絶対安定したわけなので、飛び込むなら今！です。</p>
<p>ところで本題とは関係ないんですが<a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a>でWP7+Rxのセッションをします。入門編として、主に非同期処理にフォーカスして、今すぐコピペで使ってコールバックを撲殺しよう、といった内容を考えていますので、是非聞きに来てください。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-29" data-pagefind-meta="published:2011-04-29"><a href="https://neue.cc/2011/04/29_320.html">DbExecutor ver.2 - C#での生SQL書き補助ライブラリ</a></h1>
<ul class="date"><li>2011-04-29</li></ul>
<div class="entry_body"><p>データベース用のどこにでも転がっていそうなシンプルなユーティリティ、Part2。全面的につくり直しました(Part1もありました、一年前に公開してます、が、正直イマイチだった！)。</p>
<ul>
<li><a href="http://dbexecutor.codeplex.com/" title="DbExecutor - Simple and Lightweight Database Executor">DbExecutor - Simple and Lightweight Database Executor</a></li>
<li><a href="http://www.nuget.org/List/Packages/DbExecutor" title="NuGet gallery">NuGet - DbExecutor</a></li>
</ul>
<p>何でこの時期に？というと、睨んでいるのはWP7にSQLCEが乗るという話、です。まあ、Linq to Hogeが積まれるようなので、イラネーだろという話はあるのですが！あるのですが、それでも生SQLを使わざるを得ないシチュエーションは出てくるはずで、そのために、今のうちに作っておく/作りなおしておこうかと。まだWP7でどういう形で載るのか分からないので、今は普通に.NET 4 Client Profile用です。WP7へはSDKが出次第、すぐに対応させるつもり。</p>
<p>さて、どんな場合がターゲットかというと、生SQLを発行したい場合向け。大抵は軽くラップしたの作ってると思うんですが、そういう軽めのユーティリティとしてはベストなものを提供したいな、と考えました。この手のもので一番なのは<a href="http://entlib.codeplex.com/">Enterprise Library</a>のDataなのでしょうか。確かに立派なんですが、見た感じ高尚すぎてお口に合いません(個人的にはかなり嫌いな雰囲気……)。古いものがベースのまま拡張している感がありありなところも見えるので、余分な贅肉をバッサリ切り落として極限までライトウェイトにしました。</p>
<h2>ExecuteReader</h2>
<p>基本的にはADO.NETのシンプルなラッパーです。生SQLを書いて実行を、少しだけ楽にサポートするという、それだけのものです。単純明快にIDbConnectionからインターフェイスだけで生やしているので、Sql Server, Sql Server Compactはもとより、Entity SQLでも動きます。SQL Azureもいけるかな。依存は極力廃したので、MySqlやOrcale、SQLiteでも(多分)動きます。但しプレースホルダは名前付きでないとダメなので(順序依存のものは動作を保証しません)、Accessとかはきっとダメ。</p>
<p>とりあえず、何もかぶせてないものとの比較で例を。DBは、例なので何でもいいんですが、Productsテーブルに、ProductNameとQuantityPerUnitとSupplierIDとUnitPriceというカラムがある。といったような代物です。ようは、Northwindですが。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなデータ格納クラスがあるとして
public class Product
{
    public string ProductName { get; set; }
    public string QuantityPerUnit { get; set; }
}

//

var connStr = @&quot;Data Source=NORTHWIND&quot;; // Northwindサンプルから...

// 何もかぶせてない素の状態だと結果セットを取得するためのListを予め作ってAdd
// コマンドの準備も面倒、結果セットを回すのも定型句なのに行数沢山取ってシンドイ
var products1 = new List&lt;Product&gt;();
using (var conn = new SqlConnection(connStr))
using (var cmd = conn.CreateCommand())
{
    conn.Open();
    cmd.CommandText = @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice&quot;;
    cmd.Parameters.Add(new SqlParameter(&quot;SupplierID&quot;, 1));
    cmd.Parameters.Add(new SqlParameter(&quot;UnitPrice&quot;, 10));

    using (var reader = cmd.ExecuteReader())
    {
        while (reader.Read())
        {
            var p = new Product
            {
                ProductName = (string)reader[&quot;ProductName&quot;],
                QuantityPerUnit = (string)reader[&quot;QuantityPerUnit&quot;]
            };
            products1.Add(p);
        }
    }
}

// DbExecutorを使うとパラメータは匿名型で生成
// 結果はIEnumerable&lt;IDataRecord&gt;からLinq to Objectsでさらさら書ける
var products2 = DbExecutor.ExecuteReader(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .Select(dr =&gt; new Product
    {
        ProductName = (string)dr[&quot;ProductName&quot;],
        QuantityPerUnit = (string)dr[&quot;QuantityPerUnit&quot;]
    })
    .ToArray();
</code></pre>
<p>そのまんまだと、ただ結果取りたいだけなのに、物凄く行数を使うんですね。コマンドパラメータの追加なども大変面倒くさいし、結果セットの受け取りも大変。DbExecutorでは、この二つに対処するため、コマンドパラメータは匿名型で渡せるように、結果はIEnumerable&lt;IDataRecord&gt;の形で受け取ることができます。そのため、Selectした後は、ToArrayするなり、Linq to Objectsの操作にそのまま流れることが可能です。</p>
<p>この手のユーティリティでたまに見かける、SqlDataReaderだけを返すものは、あまり意味ないのではかな。やることなんて99%、グルッと回して行の値を取ることなので、それなら、そこまで面倒見てあげよう。IEnumerable&lt;T&gt;を返されても扱いようがなかった石器時代と違って、今はLinqがあるので、yield returnで返す。Stream的なものは全てIEnumerable&lt;T&gt;に変換する。そして全部Linqで処理する。それが現代の常識(ｷﾘｯ</p>
<p>なお、基本的には静的メソッドで(DbConnection, SQL文字列, パラメータ(匿名型))という形でメソッドを呼びます。DbConnectionは実行完了時にDisposeするため、usingで囲う必要はありません。</p>
<h2>ExecuteReaderDynamic</h2>
<p>C#3.0の鉄則がストリームっぽいものはyield returnで返す、ならば、C#4.0の鉄則は、動的っぽいものは全部dynamicで返す。ことです。実に色々と楽になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ExecuteReaderDynamicはIDataRecordをdynamicで包んだものを列挙する
// dynamicであることにより、カラム名のアクセスが自然に、また、キャストが不要になる
var products3 = DbExecutor.ExecuteReaderDynamic(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .Select(d =&gt; new Product
    {
        ProductName = d.ProductName,
        QuantityPerUnit = d.QuantityPerUnit
    })
    .ToArray();
</code></pre>
<p>ExecuteReaderのものとの違いはSelectの箇所だけです。ExecuteReaderDynamicはIEnumerable&lt;dynamic&gt;を返し、そのdynamicの中身はIDataRecordをDynamicObjectで包んだものです。このことにより、見た目が更に自然に、また、煩わしい型変換をdynamicが自動でやってくれるので、キャストが不要になり、書くのがとても楽になります。</p>
<p>更に嬉しい特典はデバッガでの表示。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/dbexecutordynamic.jpg">
</p>
<p>列挙中にブレークポイントを張って観察すると、動的ビューでカラム名と値、型が見えるようになります。（おっと、これはカラム名にスペースが入っているので動かないというツッコミが、いやまあ、はは……）</p>
<p>簡単な出力ぐらいならSelectを通す必要すらないです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var query = DbExecutor.ExecuteReaderDynamic(new SqlConnection(connStr), @&quot;
    select * from Products where UnitPrice &lt; @UnitPrice
    &quot;, new { UnitPrice = 20.0 });

foreach (var item in query)
{
    Console.WriteLine(item.ProductName + &quot;:&quot; + item.UnitPrice);
}
</code></pre>
<p>大変シンプルに書けますね。C#はLLですから！</p>
<h2>ExecuteNonQuery/ExecuteScalar</h2>
<p>ExecuteNonQueryやExecuteScalarも同じノリで行けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// パラメータはプロパティから取得するので、別に匿名型でなく普通のクラスでも可(insertやupdateで便利)
DbExecutor.ExecuteNonQuery(new SqlConnection(connStr), @&quot;
    insert into Products(ProductName, QuantityPerUnit)
    values (@ProductName, @QuantityPerUnit)
    &quot;, new Product { ProductName = &quot;何か&quot;, QuantityPerUnit = &quot;QUQNQUN&quot; });

// パラメータが不要な場合は省略可
var serverTime = DbExecutor.ExecuteScalar&lt;DateTime&gt;(new SqlConnection(connStr), @&quot;
    select GetDate()&quot;);
</code></pre>
<p>パラメータは匿名型でなくても、普通のクラスでも可なので、UpdateやInsertの際に便利に使えるかと思います。クエリ文の@に書かれてないパラメータは無視されるので、クラス側に余計なパラメータがある分には問題ありません。</p>
<h2>Select/SelectDynamic/Insert/Update/Delete</h2>
<p>今までの4つは、IDataReaderの基本的な操作をラップしただけのものでしたが、他に、少し手の入ったメソッドを5つ用意してあります。メソッド名通り、Select/Insert/Update/Deleteをシンプルに行うためのものです。</p>
<ul>
<li>Select</li>
</ul>
<p>select文の結果をIDataRecordを触ることなく、指定した型に移します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IEnumerable&lt;T&gt;を返し、カラム名とプロパティ名を自動でマッピングする
var products4 = DbExecutor.Select&lt;Product&gt;(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .ToArray();
</code></pre>
<p>O/Rマッパーというには烏滸がましいというか別にそんな大仰なものではなく、単純にselect文をオブジェクトに転写するという、それだけ。それだけなんですが、それだけのシチュエーションって結構多いですよね？これだけで、生SQLの苦痛が随分と癒される。そう、生SQLを書くのが嫌なんじゃなくて、最後にオブジェクトに手作業で対応付けるのが嫌だったんだよ、と思える程度には。</p>
<p>パフォーマンスもほとんど問題ありません。一回目の実行時にデリゲートの動的生成＋キャッシュを行い、全てリフレクション経由ではなくデリゲート経由のアクセスを行うため、十分高速です。基本は<a href="http://neue.cc/2011/04/20_317.html" title="neue cc - Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化">neue cc - Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化</a>で書いたものですが、若干これ向けに修正してあります。</p>
<p>そうそう、今までのパラメータの匿名型渡しも同様にデリゲート生成していますので、匿名型渡しであることによる速度低下は全くありません。</p>
<ul>
<li>SelectDynamic</li>
</ul>
<p>select文の結果をExpandoObjectに移します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IEnumerable&lt;dynamic&gt;で、dynamicの中身はExpandoObject
var products5 = DbExecutor.SelectDynamic(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .ToArray();
</code></pre>
<p>SelectDynamicもExecuteReaderDynamicも、共にIEnumerable&lt;dynamic&gt;なのですが、ExecuteReaderDynamicのdynamicは、あくまでIDataRecord、というよりもIDataReaderをdynamicでラップしたに過ぎないため、Selectで何かに射影するか、そうでなければシーケンシャルにしか値が取れません。SelectDynamicは、結果の一行一行をExpandoObjectに予め射影しているので、それだけで永続化されます。</p>
<p>使い勝手的にはDataTableが近い。実際、例えばASP.NETでは (Container.DataItem as dynamic).PropName とすることでデータバインドも行けます。また、ExpandoObjectは何気にINotifyPropertyChangedが実装されていたりするので、存外使い勝手は良いかもですね。</p>
<p>DataTableと違ってデバッガに非常に優しいのも嬉しい。動的ビューで中身が簡単に確認できます。</p>
<ul>
<li>Insert</li>
</ul>
<p>Insertは指定したオブジェクトを元にInsertするというもの。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// テーブル名と対象オブジェクト(匿名型でも可)を渡すだけでInsert
DbExecutor.Insert(new SqlConnection(connStr), &quot;Products&quot;,
    new Product { ProductName = &quot;何か2&quot;, QuantityPerUnit = &quot;QOQOQUN&quot; });
</code></pre>
<p>Insertって書くの面倒。table名(列名)values(@列名)。クソ単純なのに……。というわけで、テーブル名とオブジェクトを指定するだけで極々シンプルなinsert into valuesに変換されます(これはExecuteNonQueryの例で出したSQL文と同じものになります)。やりたいことがシンプルなとき、シンプルに書ける。そういうのがいいなって思っていて。</p>
<ul>
<li>Update</li>
</ul>
<p>Insertと同じようなコンセプトです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// where条件(複数の場合はand連結)とupdate対象を渡します
DbExecutor.Update(new SqlConnection(connStr), &quot;Products&quot;,
    new { ProductName = &quot;何か!!!&quot; }), // update対象
    new { ProductName = &quot;何か!&quot;, SupplierID = 100 }); // where条件
    
// 以下のようなSQLが発行されます
update Products set ProductName = @ProductName
where ProductName = @__extra__ProductName
  and SupplierID = @__extra__SupplierID
</code></pre>
<p>第三引数にupdateする値を、第四引数にwhereの条件を、。whereの条件は必須なのと、また、複数の場合はandで連結されます。発行されるSQLに__extra__というのが付くのはupdate対象とプロパティ名が被っても大丈夫なようにするため、なので、特に気にしなくてもいいです。比較的そのまんまなSQLに変換される、とだけ分かってもらえれば。</p>
<ul>
<li>Delete</li>
</ul>
<p>Updateと同じような(以下略)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// delete条件を渡します(複数の場合は例によってand連結)
DbExecutor.Delete(new SqlConnection(connStr), &quot;Products&quot;,
    new { ProductName = &quot;何か2!&quot; });

// 以下のSQLが発行される
delete from Products where ProductName = @ProductName
</code></pre>
<p>ちなみに、nullだけを削除といったようなことは出来ません。いや、isnullがコマンド渡しで書けないからね…… そういうのは普通にExecuteNonQueryで書いてくださいな。そういえばでそれと、Insert, Update, Deleteは内部的にはExecuteNonQueryを実行しているので、戻り値は影響された行の個数が返ってきます。</p>
<p>これらは、あくまで補助的なものとして用意したので、生SQL文を完全に代替することは最初から意識していません。それが当てはまるシンプルなシチュエーションで、シンプルに書けること。それが目的です。</p>
<h2>接続を維持しての複数クエリ/トランザクション</h2>
<p>今までの例は全て静的メソッドの、一接続一実行の例だけでしたが、接続をつなぎっぱなしにしたりトランザクションをかけたりも出来ます。usingで囲んでnewでインスタンス化すればOK。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 静的メソッドではなくnewすればDisposeまで接続をCloseしないモード
using (var exec = new DbExecutor(new SqlConnection(connStr)))
{
    // 今まで第一引数に渡していたコネクションが(当然)不要になる
    var count = exec.ExecuteScalar&lt;int&gt;(&quot;select count(*) from Products&quot;);

    // なお、ストアドプロシージャの実行は第三引数でCommandTypeを変更すればOK
    var twoyears = exec.SelectDynamic(&quot;Sales by Year&quot;,
            new { Beginning_Date = &quot;1996-1-1&quot;, Ending_Date = &quot;1997-12-31&quot; },
            CommandType.StoredProcedure)
        .ToArray();
}

// 第二引数にIsolationLevelを渡すとTransactionがかかります
using (var exec = new DbExecutor(new SqlConnection(connStr), IsolationLevel.ReadCommitted))
{
    // こんな露骨でなくても、配列上に沢山オブジェクトがあって
    var products = Enumerable.Range(1, 10)
        .Select(i =&gt; new
        {
            ProductName = &quot;Test!&quot;,
            SupplierID = i
        });
    // サクッと一気にInsertするとか、あったりなかったり
    foreach (var product in products)
    {
        exec.Insert(&quot;Products&quot;, product);
    }


    exec.TransactionComplete(); // usingを抜ける前にこれを呼び出せばCommit、呼び出さなければRollback
}
</code></pre>
<p>new DbExecutorの際にIsolationLevelを渡すとトランザクションがかかります。TransactionScopeのように、確定させる際は最後にTransactionCompleteを。TransactionCompleteが実行されなかった場合はRollbackされます。なお、別に普通にTransactionScopeを使っても問題ありません。</p>
<h2>まとめ</h2>
<p>生SQLなんて、好きじゃない！どうやったって、異物だもの。生SQL文じゃないストアドプロシージャならいいかといえば勿論そんなわけはなく、呼び出し時のパラメータと値の受け取りが……。むしろ、実態のSQL文がコードと相当離れたところに置かれ、見通しが低下するわけで、それなら逐語的文字列リテラルでC#コード中に埋めたほうがいいよ。逐語的文字列リテラルのない言語だったら、悪夢すぎて考えたくないけれど。逐語的文字列リテラルの何がいいかって、コピペでSQL Server Management Studioに移せるところなんだよね。そして逆も然りで。XMLか何かに外出しも当然イマイチで、そんなことやるぐらいなら文字列埋め込みのほうがずっといい。んー、でも<a href="http://s2dao.seasar.org/ja/index.html" title="S2Dao - Top">S2Daoの2Way SQL</a>というのはいいですね。パラメータの修正などもせずManagement Studioでそのまま実行可能、という。Linq to Sql/EntitiesもLinq Padを使うことでそれらしいことは出来るかな？</p>
<p>と、まあ、なにはともあれで、SQLをどれだけ嫌ったところで、現実問題付き合っていかなければならない。ことはなくLinq to Hogeを使いたい。けど、無理なら、それならせめて軽やかに扱いたいよね、とは皆思うはずで、皆それぞれの俺々ユーティリティは用意されていると思いますが、私も作ってみました(一年ぶりに再チャレンジで)。</p>
<p>特徴はIEnumerableベース(Linq to Objectsに乗っかる基盤)であることと、匿名型を多用したパラメータの受け渡し、ExpressionTreeを用いた動的デリゲート生成による高速化、dynamicによるシンプルなアクセサ。C#3, 4の機能を満遍なく使って、軽快に書けるようにしたつもりです。生SQLを扱うわりには、かなりLL的な軽さは出せてるのではないかとー。とにかく簡素なAPIになるよう気を使いました。ついでに、今回はCode Contractsも全面的に導入しています。</p>
<p>とりあえず、SQLCEも4.0になってDLLのみでよくなって、更にはNuGetでサクッと用意できてと(EF CodeFirstも用意できる)、C#でもデータベースがもんのすごく身近に扱えるようになりました。とてもいい事です！というわけで、生SQLのお供に是非どうぞ。Linq to SqlやLinq to Entities使っていても普通に共存出来ますので～。</p>
<p>まあ私は生SQLよりもCodeFirstにしたいですが！生SQLなんてどうでもいいのでLinq to Entitiesでキャッキャウフフしたいです。そんなわけでDbExecutorのテストに使ったDBは、SQLCE4+EF CodeFirstで組んであったりして。Code FirstでDB組んだのにLinq to Entitiesではなく生SQLでアクセスするとか大変モニョる。</p>
<h2>4/30追記</h2>
<p>ver.2.0.0.1に。ExecuteScalarの契約で事後条件を!=nullとしていたのですが、大間違いで普通にnullりるので。DbNullが返ってくるものと勘違いしていてAssumeを足してわざわざ抑制してたんですが、全くもってダメダメな対応だった……。わざわざ（静的チェッカが）警告してくれたのを、深く考えずAssumeで消すとは、愚かすぎる。そして、1日で差し替えたのにStableリリースと言い張ったことを深く反省します。なお、リリースバイナリから事後条件は削除されているので、誤った契約による問題は、静的チェッカが正しく動作しない(nullではないとマークされる)ことだけになります。その程度の軽い障害なのだから良いかといえば、勿論全然よくはなく、本当にすみませんでした。</p>
<h2>流れるようなインターフェイス vs 生SQL</h2>
<p>で、思い出した。基本的には私は「流れるようなインターフェイス」自体が大嫌いというのもありますが、<a href="http://s2container.seasar.org/2.4/ja/s2jdbc_abstract.html" title="Seasar2 - S2JDBC - S2JDBCとは">Seasar2 - S2JDBC</a>のような仕掛けは全く無意味だと思いますね。Linqの式木のような深い解析が出来なければ、こういうのはただのファッションで、別に書きやすくも何ともないと思っていて。それなら生SQLのほうが遥かにマシだと。だから私はDbExecutorでは前段は生SQL、後段にLinq to Objectsという形体を取っています。「生SQLは避けられないもの」という認識が大前提のうえで、それを如何にサポートするかが主眼です（まあ、なので単純に比較しても意味のないところですが）。また、C#にはLinq to Entitesもあることですし、欠けてる部分を上手く補完出来ればというのが願うところです。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-29" data-pagefind-meta="published:2011-04-29"><a href="https://neue.cc/2011/04/29_319.html">XboxInfoTwit - ver.2.3.0.4</a></h1>
<ul class="date"><li>2011-04-29</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Twitterの認証周りが変わって、新規認証が出来なくなってしまってたので、それを修正しました。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-26" data-pagefind-meta="published:2011-04-26"><a href="https://neue.cc/2011/04/26_318.html">Tester-DoerパターンとCode Contracts</a></h1>
<ul class="date"><li>2011-04-26</li></ul>
<div class="entry_body"><p>僕と契約して安全性の高いソフトウェアを作ってよ！というだけじゃ、何か、弱い。動機付けに足りない。という、分かったような分からないような<a href="http://msdn.microsoft.com/en-us/devlabs/dd491992">Code Contracts</a>。困ったところは、で、何が嬉しいの？にたいする積極的具体的な動機付けを提供しにくいということ。契約をしっかり行うことで、強固なソフトウェアが設計出来ます。うーん、理念は分かりますけど実用的に便利ー？if hoge==null throw に毛が生えた程度のものだったら、ちょっとよくわからない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こういうコード見るともう目も当てられなくて、画面の半分が引数チェックで埋まってるよ！
public void Hoge(string arg1, string arg2, string arg3)
{
    if (arg1 == null)
    {
        throw new ArgumentNullException(&quot;arg1&quot;);
    }
    if (arg1.Length == 0)
    {
        throw new ArgumentException(&quot;arg1&quot;);
    }
    if (arg2 == null)
    {
        throw new ArgumentNullException(&quot;arg2&quot;);
    }
    if (arg2.Length == 0)
    {
        throw new ArgumentException(&quot;arg2&quot;);
    }
    if (arg3 == null)
    {
        throw new ArgumentNullException(&quot;arg3&quot;);
    }
    if (arg3.Length == 0)
    {
        throw new ArgumentException(&quot;arg3&quot;);
    }
    
    // やっとメソッドの本体...
}
</code></pre>
<p>うん、これは、イヤ。ifは必ず{}をつけなければ、とやると行数が嵩んで最悪の視認性に。個人的には、明らかに一行な処理はifの真横に書いてもいいと思う。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// これぐらいなら許す(えらそう)
public void Hoge(string arg1, string arg2, string arg3)
{
    if (string.IsNullOrEmpty(arg1)) throw new ArgumentException(&quot;arg1&quot;);
    if (string.IsNullOrEmpty(arg2)) throw new ArgumentException(&quot;arg2&quot;);
    if (string.IsNullOrEmpty(arg3)) throw new ArgumentException(&quot;arg3&quot;);

    // ↑もしくはGuard.NotNull(arg1, &quot;arg1&quot;); とか用意するなど、ね。
}
</code></pre>
<p>そんなわけかで、この手のnullチェックが好きでなくて、必要性だって、どうせ次の行のその引数使うところで死ぬんだからどうでもよくね？と思う場合があまりにも多いともにょもにょもにょ。書くけど書かないけど。</p>
<p>その延長線上でContractsも面倒くさいしなー、と思っていた時もありました。しかしCode Contractsは、あらゆる方向から契約を積極的に行うための動機付けを提供してくれています。Premiumにしか提供されていない静的チェックが最も強力なのは確かですが、Standardのユーザーのためにも、ドキュメント生成、<a href="http://visualstudiogallery.msdn.microsoft.com/85f0aa38-a8a8-4811-8b86-e7f0b8d8c71b/">IntelliSense表示サポート</a>、Pex自動テスト生成サポート、引数名を文字列で書かなくていい。などなど。</p>
<p>そこまであの手この手で、契約するといいよ、と迫ってこられれば納得です。理屈上素晴らしいから、というだけじゃなくて、何だかんだで面倒くさいものを、現実的にこんなにメリットがあるから契約しようよ！という。そういう姿勢がいいよね、普及させるために全方位から攻めるというの。それだけ並べられれば、そりゃ書くってものですよ？</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/codecontracts_enumerablerange.jpg">
</p>
<p>特にIntelliSense厨の私は、IntelliSenseへの契約表示に感動しまして。Enumerable.Rangeで条件が表示されてるよ、きゃー！って。そして、BCLが契約を表示してくれるなら、自前のクラス群も契約表示させてあげたい。と、いうのが一番のCode Contractsやろう！という動機付けになりましたね。頻繁にクラッシュするんですが、その辺は多めに見てあげます。</p>
<h2>Tester-DoerパターンとCode Contracts</h2>
<p>Code Contracts自体は<a href="http://d.hatena.ne.jp/zecl/20110213/p2">第54回CLR/H勉強会発表資料を公開します。 - Bug Catharsis</a>の「オブジェクト指向と契約による設計」と「Code Contracts入門」という資料が素晴らしいので、今すぐそちらを見たほうがいいです！</p>
<p>というわけでCode Contracts自体には全く触れないで、例でも。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Addのないstring, string辞書(これはひどい)
public class StringDictionary
{
    Dictionary&lt;string, string&gt; dict = new Dictionary&lt;string, string&gt;();

    public bool ContainsKey(string key)
    {
        return dict.ContainsKey(key);
    }

    public string Get(string key)
    {
        return dict[key];
    }
}

static void Main(string[] args)
{
    var dict = new StringDictionary();

    // 存在しないキーをGetすると例外
    dict.Get(&quot;hogehoge&quot;);

    // チェックしてから取得する(Tester-Doerパターン)
    if (dict.ContainsKey(&quot;hogehoge&quot;))
    {
        dict.Get(&quot;hogehoge&quot;);
    }
}
</code></pre>
<p>取得時にダメな可能性があるものは、先にチェックしてから取りに行く。といったことは、.NETのクラスライブラリ設計に書いてあるので読もう～。とてもお薦め本。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4891006765" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>問題は、キーの存在チェックをすることがほぼ必須なのに、それを強制出来ないんですね。あくまで任意でしかなく、別にチェックしなくてもコンパイラ通るし、そうして書かないでいるとうっかりな例外発生の可能性を常に抱えてしまう。こういう問題は例外自体にも言えますが。ほぅ、では検査例外が必要か…… いえ、あれはいりません。</p>
<p>まあともかくで、ここでCode Contractsを使うとどうなるか、というと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class StringDictionary
{
    Dictionary&lt;string, string&gt; dict = new Dictionary&lt;string, string&gt;();

    [Pure] // Pureじゃないと怒られるのでPureってことにしておこう（善意の申告制です）
    public bool ContainsKey(string key)
    {
        return dict.ContainsKey(key);
    }

    public string Get(string key)
    {
        Contract.Requires(ContainsKey(key)); // 事前条件 ContainsKeyがtrueでなければダメ

        return dict[key];
    }
}

static void Main(string[] args)
{
    var dict = new StringDictionary();

    // ContainsKeyの前にGetしようとすると...
    dict.Get(&quot;hogehoge&quot;);
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/codecontracts_unproven.jpg">
</p>
<p>静的チェッカーが警告を出してくれます。いいねいいね。そんなわけで、Code Contractsを使うと、比較的安全にTester-Doerパターンが適用できるのでした。こういう、コードだけでは表現できない約束事を表現でき、実行時ではなくコンパイル時に検出出来るようになる、っていうのは、魅力的な話なのではと思います。</p>
<h2>まとめ</h2>
<p>Code Contractsは一部で無理矢理感が否めません。そもそもバイナリリライター必須なうえに、文法的にもContract.Requiresぐらいならまあいいとしても、Ensures(Contracts.Result)やInvariantやContractClassForはC#的に不自然さを残す介入の仕方で、些か残念と言わざるをえない。</p>
<p>不自然さ漂う記述方法がC#に統合される(それ<a href="http://research.microsoft.com/en-us/projects/specsharp/">Spec#</a>)日は来るのだろうか(絶対来ないよね)。Spec#は軽く仕様とTutorialを眺めた感じだと、やはり言語統合されてると、洗練されてるし、書きやすさも段違いになるよねえ、などと思いました。全ては必要ないけれど、一部はC#に入って欲しい、のですが文法と衝突しなくても、既存のコードとルールが衝突してしまったりするので難しいかなあ。</p>
<p>とはいえ、Code Contracts全体のエコシステムがもたらすメリットも多大だし、mscorlibすらContractsが書き足されている(.NET4から)ぐらいなので、今のうちにそれに従って流行りものに乗っかるのもいいと思います。流行ってるか謎ですが。単純なnullチェックぐらいならサクッと書けますが、少し凝った契約をしようとすると途端にワケワカランし正道がサッパリ。という敷居の高さはありますが……。</p>
<p>実際ヨクワカラナイデス。少しよーし、張り切って書いちゃうぞー、とやると、それダメそれダメ、とリライターに言われてしまったりでnullチェックに毛の生えた程度しか使いこなせない昨今です。それだけでも有益といえば有益なんですが、あちこちでrequires not null, ensures not nullを書いていると、もうデフォルトを非nullにしてくれよ！と叫ばずにはいられない。何ともいえない不毛感がちょっと、かなり、嫌。</p>
<p>あと、静的チェッカが上手く機能するように書くには静的チェッカが必要なのも。当たり前？うーん、静的チェッカなしで、ただ普通にContractsを書いているだけじゃあダメなのかな？契約自体は成立していてリライターは通るけど静的チェッカ使うと警告だらけ。みたいな形になりがちで。Standardで書いてPremiumでチェックしたら涙目の落差が激しすぎて、じゃあ結局は静的チェッカ必須なの？でもそれPremium以上じゃん、というのが残念で。そうなるとStandardにも欲しいねえ、静的チェッカー。</p>
<p>でも、ちょっと気の利いたGuard句として、事前条件だけで画面半分が埋まるような事態が緩和されるなら、それはとっても嬉しいなって。まずは、その程度から始めよう。順を追ってステップアップすればいいのだから。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-20" data-pagefind-meta="published:2011-04-20"><a href="https://neue.cc/2011/04/20_317.html">Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化</a></h1>
<ul class="date"><li>2011-04-20</li></ul>
<div class="entry_body"><p>Expression Treeは、IQueryableの中心、Code as Dataなわけですが、それ以外にも用途は色々あります。ただたんに名前を取り出すだけ(考えてみると贅沢な使い方よね)とか、デリゲートを生成したりとか。varはLinqのために導入されたものだからそれ以外に無闇に使うのは良くない(ｷﾘｯ とか言う人は、式木も同じ考えなんですかね、匿名型へも同じ態度で？導入された、そして発展させたのはLinqだとしても、別にそれ以外に使ってもいいんだよって。縛られた考えイクナイ。</p>
<p>というわけで、今更に、初歩からの式木再入門。特に.NET 4から大幅に拡張されて式だけじゃなく文までいけるようになって、何でも表現出来るようになりました。式木の用途は多岐に渡るわけですが、今回はリフレクションの高速化をお題にしたいと思います。プロパティ名の文字列からPropertyInfoを取ってGetValueといったように、動的に値のGet/Setをするわけですが、それを動的コード生成で高速化しよう！</p>
<p>方針としては、プロパティアクセスのデリゲートを生成します。GetだったらFunc&lt;object, object&gt;を作って、引数が対象インスタンス、戻り値が取得結果の値、といった具合です。まんまPropertyInfoのGetValueがデリゲートになったもの、といった具合。</p>
<p>では、実際に書きながら見ていきます。というわけで、私の書き方などりを順を追って。まず、何をやりたいかを明確にするため、実際のコードで、具体的なラムダ式を書いてコンパイル通します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 適当なクラス
class MyClass
{
    public int MyProperty { get; set; }
}

static void Main(string[] args)
{
    // これで書くと(.NET 4以降の)代入やループはサポートされてないので、Funcでも全然いいです
    // ただ、デバッガで生成された式の結果が見えるので、Expressionでコンパイル通せたほうが楽かな
    Expression&lt;Func&lt;object, object&gt;&gt; expr =
        target =&gt; ((MyClass)target).MyProperty;
}
</code></pre>
<p>コンパイル通るということは、それで書けるということ。机上で、頭の中だけで考えてもいいことありません。ささっとコンパイラ使いませう。そして一旦デバッガでexprを覗いてみますと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ToString()
// target =&gt; Convert(Convert(target).MyProperty)

// DebugView
.Lambda #Lambda1&lt;System.Func`2[System.Object,System.Object]&gt;(System.Object $target) {
    (System.Object)((Program+MyClass)$target).MyProperty
}
</code></pre>
<p>Expressionで宣言して書くというのは、コンパイラがコンパイル時に式木を生成するということです。見た目はFuncに毛が生えた程度なのに、コンパイル結果は大違い。なんて恐ろしい！そして、なんて素晴らしい！ともあれ、結果から逆算してくのが手っ取り早い。大枠は機械生成に任せてしまって、微調整だけを手動でやればいいわけで。無から作るのは大変ですが、枠組みが出来ているなら簡単だもの。このToStringとDebugViewは大変便利です。なお、リフレクタで生成結果を見るという夢のない方法もあります。</p>
<p>上記結果から、具体的な成分に置き換えた、何を書くのかの式をイメージ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// (object target) =&gt; (object)((T)target).PropertyName
</code></pre>
<p>もう、あとは機械的に置き換えていくだけ！というわけで、具体的にこねこねしていきますが、まずパラメータとラムダ本体を用意します。この二つは、最終的にデリゲートの生成を目指した式木の作成では定型句みたいなものなので何も考えず用意。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// まず、引数のパラメータとLambda本体を書く
var target = Expression.Parameter(typeof(object), &quot;target&quot;);

var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
    /* body */
    , target);
</code></pre>
<p>基本的に、埋めやすいところから埋めていくのがいいのではないかなー。そして、Expressionは最後の引数が一番埋めやすいので、外から内に向かって書いていくことになります。最初のLambdaは、引数パラメータを最初に置いてしまって、bodyは後回しにする。というわけで、これで左辺は終了しました。次は右辺。外周から構築されるので、まずobjectへのキャスト。これはExpression.Convertです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
    Expression.Convert(
        /* body */
        , typeof(object))
    , target);
</code></pre>
<p>当然ですが、ちゃんとインデントつけたほうがいいです。カンマ前置は気持ち悪いですが、こうして後ろから埋めていく時は、こっちのほうが書きやすいかなー。気持ち悪ければ最後にまとめて直せばいいのではないかと。</p>
<p>次はTへのキャスト、ではなくプロパティ呼び出し。実行の順番はTにキャスト→プロパティ呼び出し→objectにキャストですからね。プロパティ呼び出しはExpression.Property。ですが、フィールドも似たようなものだし、幸いExpressionには両者を区別しないPropertyOrFieldがあるので、そちらを使いましょう。名前はstringで渡しますが、とりあえず&quot;PropertyName&quot;で。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
    Expression.Convert(
        Expression.PropertyOrField(
            /* body */
            , &quot;PropertyName&quot;)
        , typeof(object))
    , target);
</code></pre>
<p>最後は((T)target)。(T)は後で置き換えるとして、とりあえずMyClassにしておきますか。targetは、最初に作った右辺のパラメータです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var target = Expression.Parameter(typeof(object), &quot;target&quot;);

var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
    Expression.Convert(
        Expression.PropertyOrField(
            Expression.Convert(
                target
                , typeof(MyClass))
            , &quot;PropertyName&quot;)
        , typeof(object))
    , target);
</code></pre>
<p>埋まった！埋まったらとりあえずまずコンパイル。するとPropertyNameはMyClassにないよ、と例外出て終了。ふむふむ。ところで、ここでチェック入るんですね、へー。それでは、別関数に分けることを意識して、(ようやく)変数用意しますか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// あとで関数の引数にするとして
var type = typeof(MyClass);
var propertyName = &quot;MyProperty&quot;;

var target = Expression.Parameter(typeof(object), &quot;target&quot;);

var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
    Expression.Convert(
        Expression.PropertyOrField(
            Expression.Convert(
                target
                , type)
            , propertyName)
        , typeof(object))
    , target);
</code></pre>
<p>コンパイル通ったー。そしたら、とりあえずデバッガでlambda変数を観察。ToString結果とDebugViewプロパティを見るといいでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// lambda.ToString()
target =&gt; Convert(Convert(target).MyProperty)

// lambda.DebugView
.Lambda #Lambda1&lt;System.Func`2[System.Object,System.Object]&gt;(System.Object $target) {
    (System.Object)((Program+MyClass)$target).MyProperty
}
</code></pre>
<p>問題なさそうですね！この二つは作るときに非常に便利なので、大きめのを書くときは断片を書いてこれでチェック、みたいにするといいかも。では、最後にデリゲート生成(Compile)を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// デリゲート生成！
var func = lambda.Compile();

// てすと
var test = new MyClass { MyProperty = 200 };
var result = func(test);
Console.WriteLine(result);
</code></pre>
<p>というわけでした。DynamicMethodでILもにゃもにゃ(敷居高すぎ！)とか、Delegate.CreateDelegateだのでもにゃもにゃ(面倒くさい！)に比べると、随分素直に書けて素敵。.NET 4.0からはブロックやループなど、式だけではなく全ての表現が可能になったので、動的コード生成が身近になりました。</p>
<p>Setのほうも同様な感じに書けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// (object target, object value) =&gt; ((T)target).memberName = (U)value
static Action&lt;object, object&gt; CreateSetDelegate(Type type, string memberName)
{
    var target = Expression.Parameter(typeof(object), &quot;target&quot;);
    var value = Expression.Parameter(typeof(object), &quot;value&quot;);

    var left =
        Expression.PropertyOrField(
            Expression.Convert(target, type), memberName);

    var right = Expression.Convert(value, left.Type);

    var lambda = Expression.Lambda&lt;Action&lt;object, object&gt;&gt;(
        Expression.Assign(left, right),
        target, value);

    return lambda.Compile();
}

// Test
static void Main(string[] args)
{
    var target = new MyClass { MyProperty = 200 };
    var accessor = CreateSetDelegate(typeof(MyClass), &quot;MyProperty&quot;);

    accessor(target, 1000); // set
    Console.WriteLine(target.MyProperty); // 1000
}
</code></pre>
<p>Expression.Assignが代入なのと、objectで渡されるvalueは、プロパティに代入する際にプロパティの型へキャストする必要があるので、left.Typeで取り出しています。これ、Lambdaの中に一気に書いてしまうと値が取れないので、外で書く必要があるのが少々面倒かしらん。とりあえず、コメントで生成後の式を書いておいてあげると見る人に(少しだけ)優しい。</p>
<p>今回のSet/Getは微妙に汎用的なものにするため全てobjectで扱っていますが、ジェネリクスにすれば、余計なExpression.Convertがなくてスッキリ記述＋パフォーマンスも向上、が狙えそうですねん。</p>
<h2>何で突然？</h2>
<p>思うところあって、じゃなくて、WP7にSQLCE搭載の報を受けて、以前書いたデータベース用ユーティリティを書き直そうと思いまして。そして、コマンドパラメータの受け渡しには匿名型を使おうかな、と。そうすると、書くのがとても簡単になるんですね。凄く軽快で。これは良い。のですけど、実行の度にPropertyInfoを取ってきてNameとGetValueでの値取り出しはどうかと思ったわけです。そりゃねーよ、と。そこで、じゃあ、キャッシュしよう。キャッシュするならPropertyInfoをキャッシュしたってそんな速くはない、やるならデリゲート生成までやろう。と、紆余曲折あってそうなりました。</p>
<p>パラメータだけではなくて、簡易マッパー(selectの各カラムの名前とプロパティ名からインスタンス生成)も用意しているのですが、それもデリゲートのキャッシュで高速化効いてくるかなー、と。</p>
<p>で、速いのかというと、うーん、生成のコストが結構高いので、平均取ると、PropertyInfoのキャッシュと比べると、数千回実行しないとコスト回収出来ないかも。PropertyInfoのGetValueも遅い遅いというほどにそんな遅くないのかなあ、いや、デリゲートと比べると十数倍ぐらいは違うんですが、しかし。マッパー的に使って、一回の実行に100行取ってくる、とかだったら余裕ですぐ回収出来ますが、コマンド程度だとどうだろうなー。まあ、ASP.NET MVCなんかはTypeDescriptor(正直遅い)経由でやってるみたいだし、それと比べれば悪くないかもはしれない。でもWP7を見ると、アプリケーションのキャッシュ生存期間を考えると、ペイ出来そうな気がしない。</p>
<p>とはいえ、初回に少し重くてあとは高速、のほうがユーザーエクスペリエンス的にはいいかな、と思うので(あと、どちらにせよたかが知れてる！)、式木デリゲートキャッシュは採用の方向で。スッキリしてて、C#らしい美しさなところも好き。で、まあ一応、速度を気にしてのことなので、ベンチマークを取ったりするわけですが、生成時間が気になる……。エクストリームにハイパフォーマンスなシリアライザを作る！とかってわけじゃないので、あんまキチキチに気にしてもしょうがないのですが、でもちょっと気になる。Boxingが～、とかも少し、でもそれは放置として。</p>
<p><a href="http://d.hatena.ne.jp/machi_pon/20090821/1250813986">リフレクションは遅いから情報をキャッシュするとかのお話 - Usa*Usa日記</a> <a href="http://ufcpp.net/study/csharp/misc_dynamic.html">[雑記] 動的コード生成のパフォーマンス (C# によるプログラミング入門)</a> <a href="http://ugaya40.net/wpf/mvvm-dynamic-proxy-viewmodel.html">動的プロキシなViewModelの実装とパフォーマンスの比較(MVVMパターン) - the sea of fertility</a> <a href="http://d.hatena.ne.jp/NyaRuRu/20070216/p1">効率の良い実行時バインディングとインターフェイス指向プログラミングでの boxing の回避テクニック - NyaRuRuの日記</a> <a href="http://d.hatena.ne.jp/NyaRuRu/20070925/p1">パフォーマンスのための Delegate, LCG, LINQ, DLR (を後で書く) - NyaRuRuの日記</a> <a href="http://www.atmarkit.co.jp/fdotnet/dotnetdeepdive/dotnetdeepdive01/dotnetdeepdive01_03.html">インライン・メソッド・キャッシュによる動的ディスパッチ高速化 － ＠IT</a> <a href="http://d.hatena.ne.jp/matarillo/20100120/p1">ByRef parameter and C# - 猫とC#について書くmatarilloの日記</a> <a href="http://stackoverflow.com/questions/1722096/how-does-protobuf-net-achieve-respectable-performance">c# - How does protobuf-net achieve respectable performance? - Stack Overflow</a> <a href="http://www.codeproject.com/KB/cs/HyperPropertyDescriptor.aspx">HyperDescriptor: Accelerated dynamic property access - CodeProject</a> <a href="http://msmvps.com/blogs/jon_skeet/archive/2008/08/09/making-reflection-fly-and-exploring-delegates.aspx">Making reflection fly and exploring delegates - Jon Skeet: Coding Blog</a> <a href="http://entlib.codeplex.com/">patterns &amp; practices – Enterprise Library(Data)</a> <a href="http://msdn.microsoft.com/ja-jp/library/system.data.linq.mapping.metaaccessor.aspx">MetaAccessor クラス (System.Data.Linq.Mapping)</a> <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.typedescriptor(v=VS.100).aspx">TypeDescriptor クラス (System.ComponentModel)</a>  <a href="http://automapper.codeplex.com/">AutoMapper</a> <a href="https://github.com/kazuki/msgpack/tree/master/csharp/msgpack">csharp/msgpack at master from kazuki/msgpack - GitHub</a> <a href="https://github.com/yfakariya/msgpack/tree/master/cli/src/MsgPack">cli/src/MsgPack at master from yfakariya/msgpack - GitHub</a></p>
<p>ネタ元。先人が百億光年前に辿ってきた話だ、的な何か。コードは、シリアライザやマッパーはこの辺の仕組み載せてるよね、という当たりをつけて、ソースコードをPropertyInfoやDictionaryで検索してヒットした周辺を眺めるなど。で、まあ、分かったような分からないような。キャッシュの仕組みと含めて、上手くまとまったらDynamicJsonにも載せようと思っているんですが。一週間ぐらい延々と弄ってるんですが、どうも固まらなくて。この辺、コード書きの遅さに定評のある私です(ｷﾘｯ。</p>
<p>ちなみにWP7には今のところExpression.Compileはないんですけどね！(Betaの頃はあったけど削られたよう)。SQLCE搭載でLinq to Hogeも搭載するはずなので、それと一緒に復活するはずと信じています。あとSL4相当じゃないとExpression.AssignやUnboxが使えなくてどちらにせよ困るので、MangoではSL4相当にグレードアップしてくれないと。もし一切変わらなかったら、IL生成はもとから出来ないし将来も搭載されないと思うので、適当に何かでお茶濁しますか。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-14" data-pagefind-meta="published:2011-04-14"><a href="https://neue.cc/2011/04/14_315.html">Linq と Windows Phone 7(Mangoアップデート)</a></h1>
<ul class="date"><li>2011-04-14</li></ul>
<div class="entry_body"><p>今冬に予定されている大型アップデート(Mango)に向けて、MIX2011で大量に情報出てきました。色々ありましたが、その中でも目を引いたのがデータベース対応とQueryable対応。データベースは恐らくSQL Server Compact 4.0相当で、これはいいものだ。ただ、生SQL文かあ、という思いもあり。他のやり方ないのかなあ。オブジェクトDBとか？などと夢見てしまうけれど、高機能なエンジン(SQLCE4)がある以上は、それをそのまま使ったほうがいいのは自明で。</p>
<p>インピーダンスミスマッチを解消する、そのためのLinqでしょ！と、ああ、そうだね。でもLinq to Sqlはないし、Linq to Entitiesが乗っかるわけもないし、策はなく普通に生SQLの気もするなあ。どうでしょうね。どうなるのでしょうね。で、Queryable対応も発表された、というかデモられていました。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/mix11queryable.jpg">
</p>
<p>これでDB+Linqがあることが保証されたから安泰。何のQueryProviderと見るべきかしら。この辺、不透明なので、情報入り次第しっかり追っかけます。</p>
<p>Queryableの難点は、見た目はスッキリしてますが、コンパイル後の結果は式木のお化けになる＋実行時は式木のVisitというわけで、軽い処理とは言い難いところなのですが、軽いとか重いとか気にしないし！じゃあなくて、MangoではGC改善など性能向上も入るようなので、十分なパフォーマンスは確保できそうです。あと、ユーザーエクスペリエンスを損なうボトルネックは結局そこじゃあないんだよ、的なこともありそうだし。</p>
<p>例えば現行のWP7のListBoxは致命的に重くて、純正アプリは軽いのにユーザー作成アプリではクソ重く、純正だけネイティブでチートかよゴルァ、という勢いだったんですが(Mangoで改善されるそうです！)、これの要因の一つは画像の読み込み周りがアレだったことにあるようで……。</p>
<p><a href="http://cocktailflow.com/" title="CocktailFlow">CocktailFlow</a>という素敵な見た目のアプリがあるのですが、これはその辺の問題に対処するためか、事前にLoadingを取って、完全に読み込み終わってからしか表示しないようになってます。でも、それはそれでネットワーク読みに行ってるわけでもないのにLoadingが長くて、微妙だなあ、と。</p>
<h2>MIX11でのRx</h2>
<p>二つセッションがありました。一つはLinq in Actionの著者(最初期に出たものですが、良い内容でしたね)によるWP7でのRx活用例。</p>
<p class="noindent">
<object type="application/x-silverlight-2" data="data:application/x-silverlight-2," width="640" height="362"><param name="minRuntimeVersion" value="4.0.50401.0"/><param name="source" value="http://channel9.msdn.com/scripts/Channel9.xap?v=1.5"/><param name="initParams" value="mediaurl=http://files.ch9.ms/mix/2011/wmv/EXT08.wmv,thumbnail=http://files.ch9.ms/mix/2011/thumbs/EXT08_lg.jpg,deliverymethod=progressivedownload,autoplay=false,entryid=a7d49b6358ec482c99e59ea800e744a5"/></object>
</p>
<p>マイクのボリュームが不安定で聴きにくいですー。話はPull(Enumerable)とPush(Observable)の比較から入ってますね。MoveNextして、MoveNextして、MoveNextして、ええ、ああ、<a href="http://neue.cc/2010/06/24_263.html" title="neue cc - Reactive Extensions for .NET (Rx) メソッド探訪第7回:IEnumerable vs IObservable">メソッド探訪第7回:IEnumerable vs IObservable</a>の辺りで書きましたね～。それのEnumerbaleサイドのリライト版である<a href="http://neue.cc/2011/01/13_295.html" title="neue cc - LINQの仕組みと遅延評価の基礎知識">LINQの仕組みと遅延評価の基礎知識</a>の続きとして「Rxの仕組み」を書きたいのですが書くと思ってもう3ヶ月も経ってる、うぐぐ……。</p>
<p>話がそれた。んで、話の序盤は結構退屈です。IEnumerator vs IObserverとかつまらないです、って、あ、私もやってたっけ……。話の流れを上手くつながないと何か唐突なのね。さて、デモはサイコロ転がしを完成させていくというもの。どんどんコードがメソッドチェーンのお化けになっていく様はどこかで見たことある(笑)。最初は、重たい処理を、ObserveOn(Scheduler.ThreadPool)とするだけで実行スレッドを切り替えて、CPUバウンドの処理を簡単に同期→非同期に変換してUIをブロックしないというデモ。ちなみにObserveOn(Scheduler.ThreadPool)じゃなくて、これはToObservableの時点でScheduler渡したほうがいいんじゃあないのかなあ。まあ、大して違いはないといえばないですがー。</p>
<p>次は加速センサーをRxに変換して、TimestampをつけてShakeされたことを検出するというもの。生のセンサーイベントをRxで事前に加工して扱いやすくする、という手ですね。私も<a href="http://neue.cc/2011/04/09_314.html" title="neue cc - Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション">Utakotoha</a>の再生イベントでそれやったよ！（いちいち対抗心燃やして宣伝しなくてよろし）。ObservableだとMockに置き換えやすいんだよ、という話もね。気づいたらメソッドチェーンのお化けになっているのも。Linq使いの末路はみんなこんなのになってしまうという証明が！</p>
<p>セッションはもう一つ。RxチームのBart De SmetによるRxJSのセッション。MIX2011はIE10と合わせてHTML5推しもありましたしね。</p>
<p class="noindent">
<object type="application/x-silverlight-2" data="data:application/x-silverlight-2," width="640" height="362"><param name="minRuntimeVersion" value="4.0.50401.0"/><param name="source" value="http://channel9.msdn.com/scripts/Channel9.xap?v=1.5"/><param name="initParams" value="mediaurl=http://files.ch9.ms/mix/2011/wmv/HTM07.wmv,thumbnail=http://files.ch9.ms/mix/2011/thumbs/HTM07_lg.jpg,deliverymethod=progressivedownload,autoplay=false,entryid=9a0470e1b04347ed884d9eaf0092fdb3"/></object>
</p>
<p>最初の20分は、ObservableとObserverの購読概念などについて簡単な説明。あとRange,FromArray,Timerといった生成子。Pullとの比較がない、つまり&quot;Linq&quot;とは全く言わないのがJavaScript向けですね。喩えもHTML5のGeolocation APIが、などなど新鮮。そして、だからこそ分かりやすいかもしれません。その後はいきなりGeolocation APIをラップする自作Observableを作ろうが始まって難易度が、まあLevel300だものね。実用的な話ではあるし、Observableを作るということは仕組みを理解するという話でもあるので、こういうのも良い流れ。ほか、KeyUpを拾ってネットワークを問い合せてのリアルタイム検索(event+asynchronousの合成例)など。これはハンズオン資料でもお馴染みの例ですが、順に追ってデモしてもらえるとThrottleの意味は凄く分かりやすいですね。Switchも強力だけど分かりづらさを持つので、こうして丁寧に解説してもらえると、いいね。ともかく、概念としてC#もJavaScriptも超えたところにあるので、考え方、コード例はC#/WP7でも使えます。良いセッションだと思いますので見るのお薦め。</p>
<p>そういえばで、Async CTPが更新されていて、一部変更があったので、RxとAsyncとのブリッジライブラリ(Rx-AsyncLinq)が動かなくなったと思われるので、それに合わせて近いうちにRxもアップデートありそうな気がします。RxJSもここずっと更新とは遠かったのですが、こうしてセッションもあったことだし、大型アップデートはあってもおかしくないかな。</p>
<p>Async CTPはufcppさんの記事<a href="http://ufcpp.wordpress.com/2011/04/13/async-ctp-refresh/" title="Async CTP Refresh « ++C++; // 未確認飛行 C ブログ">Async CTP Refresh</a>に詳しく書かれていますが、ライセンス形態がご自由にお使いください(※但し自己責任)へと変更、日本語版でも入るようになった、WP7対応、といった具合に、WP7開発でも今すぐ投下しても大丈夫だ問題ないになったのは大きい。</p>
<p>他言語からWP7開発のために来たので、C#の経験があまりなくてLinqがイマイチ分からない。でも非同期ダルい。という人には、Rxよりも、Asyncのほうがずっと扱いやすく応えてくれるので、なし崩し的に投入してしまっていい気がしますねー。勿論、ある程度は大きな変更に対応していく気は持ってないとダメですが。</p>
<p>ある程度Linqが分かる人なら(別にそんな大仰なスキルを要求するわけじゃなく、SelectしてWhereして、Linq便利だな～、ぐらいでいいです！)Rxを学ぶのもお薦め。基本的にはLinqに沿っているので、学習曲線はそんなにキツくないです。特に、非同期をラップしてWhereしてSelectしてSubscribe、ぐらいならすぐ。他のは、徐々に覚えればいいだけで。</p>
<h2>まとめ</h2>
<p>WP7はRx標準搭載で、ただでさえLinq濃度が高かったというのに、Queryable搭載でLinq天国に！もはやWP7が好きなのかLinqが好きなのかよくわかりませんが(多分、後者です)、ともかく最高のプラットフォームなのは間違いない。</p>
<p>ところでDay1ではnugetが割とフィーチャーされていたのですが、その背景、よくみると……</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/mix11nuget.jpg">
</p>
<p>右のほうに<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js</a>が！すんごく嬉しい。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-09" data-pagefind-meta="published:2011-04-09"><a href="https://neue.cc/2011/04/09_314.html">Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション</a></h1>
<ul class="date"><li>2011-04-09</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_view.png">
</p>
<p>マーケットプレイスに通り、公開されました。フリーです(下で述べますがソースも公開しています)。再生中の音楽のアーティスト・タイトルを元に自動で検索して、歌詞を表示する、というものです。海外製の同種アプリとの違いは、対象が日本の曲ということになります。下記バナー、もしくはマーケットプレイス検索&quot;utakotoha&quot;でどうぞ。アプリケーション名は例によってヒネりなしで「歌詞」からそのままとりました。うたのことば。<a href="http://d.hatena.ne.jp/kaorun/20110211/1297427524">Utakata TextPad</a>と名前が似ていますが偶然の一致です(ほんと)</p>
<p class="noindent">
    <a href="http://social.zune.net/redirect?type=phoneApp&id=76526dfa-6260-e011-81d2-78e7d1fa76f8"><img src="http://neue.cc/wp-content/uploads/image/wp7_English_480x80_blue.png"></a>
</p>
<p>スクリーンショットでは格好つけてズームインして隠蔽していますが、スクリーンショット用詐欺なだけで、実際はこんな感じです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_ora.jpg">
</p>
<p>ようは、単純にWebBrowserに<a href="http://music.goo.ne.jp/lyric/">goo歌詞</a>を出しているだけです。ダブルタップでエリアに沿って幅一杯の拡大してくれるので、誤魔化し的にはまぁまぁ。WebBrowserを経由する理由は、APIが提供されているわけでもないので、権利関係考えるとこうでないとマズいかな、といったところで。goo歌詞を選んだ理由も直リンが許可されていたからです。</p>
<p>あと、WP7はテーマに黒背景のDarkと白背景のLightがあるわけですが、goo 音楽の背景は強制白で、どうもミスマッチなわけですね。アプリ自体を完全に白背景にしてしまうのもいいかな、とは思ったんですが、ブラウザのCSSを書き換えて黒背景にするという手を（ネタとして）取ってみました。オプションでOFFに出来るというか、デフォルトはOFFです。ズームすれば違和感はないんですが、画面いっぱいに広がってるものでは、微妙度極まりない。</p>
<p>ほか、Twitterに再生中楽曲を投稿する機能があります。</p>
<h2>ソースコード</h2>
<p>CodePlex上で公開しています。単機能アプリですので、コード規模は小さめです。あまりしっかりとはしてませんが、ユニットテストなども書いてあります。</p>
<ul>
<li><a href="http://utakotoha.codeplex.com/" title="Utakotoha">Utakotoha - CodePlex</a></li>
</ul>
<p>WP7の<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>実践例サンプル、のつもりで書いたので、Rxを全面的に使っています。むしろRx縛りと言ってもいいぐらいにRxのみでやるのを無駄に貫いています。意味がなくてただ複雑化しただけの箇所多数。UIと絡めて使うのがイマイチ分からず振り回されてますねー。とはいえ、バッチリはまった部分も勿論あり。というわけで、Windows Phone 7においてReactive Extensionsがどのような場所で使えるのか、というのをコードとともに解説していきます。</p>
<p>コードはWindows Phone 7向けですが、通常のSilverlightでもWPFでも適用できる話なので、WP7関係ないからー、と言わず、Rxに興味ありましたら、眺めてみてください。</p>
<h2>Linq to Event</h2>
<p>Rxの特徴の一つはイベントのLinq変換です。Linq化して何が嬉しいかというと、柔軟なフィルタリングが可能になることです。WP7では、センサーからのデータ処理やタッチパネルなど、様々な箇所で威力を発揮すると思われます。UtakotohaではMediaPlayerの再生情報の変化に対してRx化とフィルタリングを施しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Model/MediaPlayerStatus.cs
public class MediaPlayerStatus
{
    public MediaState MediaState { get; set; }
    public ActiveSong ActiveSong { get; set; }

    public static MediaPlayerStatus FromCurrent()
    {
        return new MediaPlayerStatus
        {
            MediaState = MediaPlayer.State,
            ActiveSong = MediaPlayer.Queue.ActiveSong
        };
    }

    public static IObservable&lt;MediaPlayerStatus&gt; ActiveSongChanged()
    {
        return Observable.FromEvent&lt;EventArgs&gt;(
                h =&gt; MediaPlayer.ActiveSongChanged += h, h =&gt; MediaPlayer.ActiveSongChanged -= h)
            .Select(_ =&gt; MediaPlayerStatus.FromCurrent());
    }

    public static IObservable&lt;MediaPlayerStatus&gt; MediaStateChanged()
    {
        return Observable.FromEvent&lt;EventArgs&gt;(
                h =&gt; MediaPlayer.MediaStateChanged += h, h =&gt; MediaPlayer.MediaStateChanged -= h)
            .Select(_ =&gt; MediaPlayerStatus.FromCurrent());
    }

    // (省略)すぐ下に...
}
</code></pre>
<p>Rx化は、ただFromEventをかますだけです。また、その際に、IEventではなく、本当に使う情報にだけ絞ったもの(この場合はMediaStateとActiveSong)をSelectで変換しておくと色々とコードが書きやすくなるのでお薦めです。</p>
<p>さて、「柔軟なフィルタリング」とは何か。ただデータを間引くだけなら、イベントの先頭でif(cond) return;を書けばいいだけです。RxではLinq化により、(自分自身を含めた)イベント同士の合成と、時間軸を絡めた処理が可能になります。これにより、従来一手間だった処理がたった一行で、連続した一塊のシーケンスとして処理することが可能になりました。</p>
<p>Utakotohaでも、生のイベントをそのまま扱わず、ある程度間引いて加工したものを渡しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">/// &lt;summary&gt;raise when ActiveSongChanged and MediaState is Playing&lt;/summary&gt;
public static IObservable&lt;Song&gt; PlayingSongChanged(int waitSeconds = 2, IScheduler scheduler = null)
{
    return ActiveSongChanged()
        .Throttle(TimeSpan.FromSeconds(waitSeconds), scheduler ?? Scheduler.ThreadPool) // wait for seeking
        .Where(s =&gt; s.MediaState == MediaState.Playing)
        .Select(s =&gt; new Song(s.ActiveSong.Artist.Name, s.ActiveSong.Name));
}
</code></pre>
<p>「再生中かつx秒間(デフォルトは2秒)新しいイベントが発生しなかった最新のものだけを流す」というものです。どういう意味かというと、連続で楽曲をスキップした時。Utakotohaでは再生曲の変更に合わせて、自動で歌詞検索をしますが、連続スキップにたいしても全て裏で検索に走っていたらネットワークの無駄です。なので、2秒間だけ間隔を置いて連続スキップされていない、と判断した曲のみを歌詞検索するようにしています。</p>
<p>こういう処理は、地味だけど必ず入れなければならない、けれど面倒くさい。でも、Rxを使えばなんてことはなく、Throttleで一撃です。Timer動かしたりDateTimeを比較したりなんて、もうしなくていいんだよって。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">/// &lt;summary&gt;raise when MediaState Pause/Stopped -&gt; Playing&lt;/summary&gt;
public static IObservable&lt;Song&gt; PlayingSongActive()
{
    return MediaStateChanged()
        .Zip(MediaStateChanged().Skip(1), (prev, curr) =&gt; new { prev, curr })
        .Where(a =&gt; (a.prev.MediaState == MediaState.Paused || a.prev.MediaState == MediaState.Stopped)
            &amp;&amp; a.curr.MediaState == MediaState.Playing)
        .Select(s =&gt; new Song(s.curr.ActiveSong.Artist.Name, s.curr.ActiveSong.Name));
}
</code></pre>
<p>こちらは、状態が停止-&gt;再生になったことを検知するというもの。停止-&gt;再生でも自動検索を走らせたいので。</p>
<p>この source.Zip(source.Skip(1), /* merge */) は、一見奇妙に見えるかもしれませんが、ある種のイディオムです。一つ先(Skip(1))の値と合流するということは、Skip(1)時の値を基準にすると、現在値と一つ前の値で合流させることができる、ということになります。それにより、一つ前の状態を参照して停止-&gt;再生を検知しています。</p>
<p>過去の値を参照するには、他に、Scan(Aggregateの列挙版、そう考えると現在値と一つ前の値が使えることのイメージつくでしょうか？)やBufferWithCount(Listでバッファを持つ、第二引数でずらす範囲を指定可能)など、幾つかやり方がありますが、このZip(Skip(1))が最も扱いやすいところ。ただし、通常のものとSkipしたものとで、二つ分Subscribeされるということは留意したほうがいいかもしれません。そのことが問題になるケースもあるので、キャッシュを使う(Pulish(xs=&gt;xs.Zip(xs.Skip(1)))など回避策を頭に入れておくと良いケースもあります。</p>
<h2>Linq to Asynchronous</h2>
<p>Rxのもう一つの大きな特徴は非同期のLinq変換です。そうすることにより、コールバックの連鎖で扱いにくかった非同期が、一本の流れに統一されます。</p>
<p>Utakotohaでは、歌詞の検索部分が代表的です。歌詞検索の背景ですが、goo歌詞のものを表示しているのだからgoo歌詞の検索を呼んでやるかなあ、と思ったのですが、それは色々マズいので、<a href="http://www.bing.com/developers/appids.aspx">Bing Api</a>のサイト内検索を経由して、表示しました。Bing Apiについては若干苦労話もあるので、いつかまた。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Model/Bing/BingRequest.cs
public IObservable&lt;SearchWebResult&gt; Search(params SearchWord[] keywords)
{
    var req = WebRequest.Create(BuildUrl(keywords));

    return Observable.Defer(() =&gt; req.GetResponseAsObservable())
        .Select(res =&gt;
        {
            var serializer = new DataContractJsonSerializer(typeof(SearchWebStructure));
            using (var stream = res.GetResponseStream())
            {
                return (SearchWebStructure)serializer.ReadObject(stream);
            }
        })
        .SelectMany(x =&gt; (x.SearchResponse.Web.Results != null)
            ? x.SearchResponse.Web.Results
            : Enumerable.Empty&lt;SearchWebResult&gt;());
}
</code></pre>
<p>割とあっさり。Bing APIならびにJSONに関しては、以前<a href="http://neue.cc/2011/03/31_312.html">Windows Phone 7でJSONを扱う方法について(+ Bing APIの使い方)</a>として書きました。ほとんどそのままです。SearchResponse.Web.Resultsは、配列なので、SelectManyで分解してやります(nullの場合は空シーケンスを流す)。すると、後続に繋げるのが非常にやりやすくなります。実際に</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Model/Song.cs
public IObservable&lt;SearchWebResult&gt; SearchLyric()
{
    return new BingRequest()
        .Search(MakeWord(Artist), MakeWord(Title), LyricSite, Location, Language)
        .Where(sr =&gt; sr.Url.EndsWith(&quot;index.html&quot;))
        .Do(Clean);
}
</code></pre>
<p>といったように、Searchから更に続いて、若干のフィルタリングが入っています。これを使う場面では、勿論、更にチェーンが続きます。といったように、Rxは一つの流れを構築するわけですが、それらを徹底的に分解・分割して適切な場所への配置・組み合わせが可能になっています。もし、通常の非同期処理のようなコールバックの連鎖だったら、組み合わせは大変でしょう(だから、その場だけで処理したくなって、ネストが嵩んでしまう)</p>
<h2>Orchestrate and Coordinate</h2>
<p>Rx全体の特徴として、また、他の非同期を扱うライブラリと最も異なる、しかし重要な点として、中に流れるデータを区別しません。非同期もイベントもタイマーもオブジェクトシーケンスも、全て同列に扱います。それはどういうことかというと、データの種別を超えて合成処理が可能になるということです。つまり、Rxは、あらゆるデータソースを統合する基盤といえます。上のAsynchronousの例でも、非同期のWebResponseが、SelectMany以降はオブジェクトシーケンスに摩り替わっていました。</p>
<p>Utakotohaでは、歌詞の表示部分で色々なデータを混ぜあわせる処理を行っています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// View/MainPage.xaml.cs
LyricBrowser.NavigatedAsObservable()
     .Where(ev =&gt; ev.EventArgs.Uri.AbsoluteUri.Contains(GooLyricUri))
     .SelectMany(ev =&gt;
     {
         // polling when can get attribute
         return Observable.Timer(TimeSpan.Zero, TimeSpan.FromSeconds(3))
             .ObserveOnDispatcher()
             .Select(_ =&gt; (ev.Sender as WebBrowser).SaveToString())
             .Select(s =&gt; Regex.Match(s, @&quot;s.setAttribute\('src', '(.+?)'&quot;))
             .Where(m =&gt; m.Success)
             .Take(1);
     })
     .Select(m =&gt; WebRequest.Create(GooUri + m.Groups[1].Value).DownloadStringAsync())
     .Switch()
     .Select(s =&gt; Regex.Replace(s.Trim(), @&quot;^draw\(|\);$&quot;, &quot;&quot;))
     .Where(s =&gt; !string.IsNullOrEmpty(s))
     .ObserveOnDispatcher()
     .Subscribe(jsonArray =&gt;
     {
         // insert json array to html
         LyricBrowser.InvokeScript(&quot;eval&quot;, @&quot;
            var array = &quot; + jsonArray + @&quot;;
            var sb = [];
            for(var i = 0; i &lt; array.length; i++) sb.push(array[i]);
            document.getElementById('lyric_area').innerHTML = sb.join('&lt;br /&gt;')&quot;);

         // (省略)
     }, e =&gt; MessageBox.Show(&quot;Browser Error&quot;))
     .Tap(disposables.Add);
</code></pre>
<p>歌詞の表示といっても、WebBrowserに表示しているこということは、歌詞のURLを渡すだけです。それだけで済むはずでした。が、……妙に複雑怪奇です。歌詞のURLが渡されて表示が完了してからが起点として(Navigated)、処理を開始しています。</p>
<p>何故こうなったか。WP7が現在積んでるIEは7。ついでにFlashはまだ未対応で見れません。それとこれとがどう関係あるかというと、歌詞表示に関係あります。日本の歌詞サイトは大抵はコピペ禁止のために右クリック禁止、だけでなく、Flashで表示していたりします。それじゃあ手が出せない。では今回利用しているgoo歌詞は、というと、少し変わっていてHTML5 Canvasに描画しています。勿論Canvasは古いブラウザじゃ動かないので、互換用JavaScriptも挟んでいるよう。<a href="http://uupaa-js-spinoff.googlecode.com/svn/trunk/uuCanvas.js/README.htm">uuCanvas.js </a>を使っているようですが、環境貧弱なWP7版のIE7じゃあ、土台動きませんでした。</p>
<p>このまんまじゃあ歌詞が表示出来なくて困ったわけですが、幸いgoo歌詞はJSONPで歌詞データを別途取得してCanvasにデータを流しているようなので、HTMLからJSONPの発行先を割り出して、歌詞データを頂いてしまえば問題ない(この時点で規約的にはグレーな気が)。生の歌詞データが手に入ってしまっ……。こいつをキャッシュするようにしてオフラインでも見れるといった機能を提供してあげられれば幸せになれるのですが、そういうのは利用規約に違反、してますね、明らかに。</p>
<p>じゃあどうするか。手元には歌詞の表示されていないブラウザ上のHTMLと、歌詞データがある。よし、じゃあブラウザにこちらからはめ込んでやればいいんじゃなイカ？</p>
<p>WP7ではWebBrowserのDOMは触れません。DOMを外から触ってappendChildしてサクッと終了、というわけにはいかず。ただ、外部から干渉出来る口が一つだけ用意されています。それがInvokeScript。外から実行関数を指定して、戻り値を受け取れます(DOMは無理なので、Stringで貰うのが無難)。ならば、evalして外から実行関数自体を注入してやれば、何だって出来る。どうにも馬鹿らしい気もしますが、このぐらいしか手がないのでShoganai(なお、予めWebBrowserのプロパティでスクリプト実行を許可しておかないと例外が出ます)。</p>
<h2>Timer and Polling</h2>
<p>イベント(Navigated)→タイマー(SaveToString)→非同期(DownloadStringAsync)という直列の合成でした。直列の合成を行うメソッドはSelectMany(もしくはSelect+Switch、両者には若干の違いがあるのですが、それに関しては後日説明します)で、Rxの中でも頻繁に使うことになるメソッドです。</p>
<p>ところで、タイマーが唐突なのですが、何故タイマーを仕込んでいるのか。どうもNavigated直後にSaveToString(WebBrowser内のHTMLを文字列化)だと、タイミング次第で上手く抽出できないことが多かったので(JSで色々処理されてる影響かな？)、必要なJSONPの書かれた属性が取れるまでSaveToStringをリトライするようにしました。つまり、ポーリング(定期問い合わせ)です。</p>
<p>ポーリングは普通だと面倒くさいはずなんですが、Rxだと恐ろしく簡単に書ける上に、こうして通常の処理の流れと合成することが可能になっているのが何よりも強力です。.NET Frameworkには幾つものTimerクラスがあって、何を使えばいいのかと戸惑ってしまうところがありますが、答えは出ました。Observable.Timerがベスト。大変扱いやすい。</p>
<p>これで、本来Canvasのあった領域にテキストデータとして歌詞を表示させられました。全く違和感のない、完璧なハメコミ合成。無駄なコダワリです。地味すぎて一手間かけてることなんてさっぱり分からない。だがそれがいい。……いや、ちょっと悲しい。それにしてもでしかし、Canvas, Flash対応になればこんなやり方は不要になるわけで、今年後半のアップデートでのIE9搭載が待ち遠しい。</p>
<h2>Unit Testing</h2>
<p>Silverlight向けのユニットテスト環境って、全然ない。ブラウザ上のSilverlightで動かす、というタイプは幾つかありますが、Visual Studioと統合された形のでないと、そんなのアタシが許さない。</p>
<p>TDDするわけでも、熱心にテスト書くわけでも、特段カバレッジを気にするわけでもない私ですが、テストが書けることは重要視しています。何故かというと、メソッドの動作確認が最も素早く行えるから。テスト(が出来ること)に何を期待しているかというと、確認したいんです、メソッドの動作を。手軽に、コンソールアプリを書く感覚で、素早く。処理をコンソールアプリにコピペって、もしくは並走してコンソールアプリを立てながら開発していたりなどを以前よくしたのですが、それを単体テストのメソッド部分に書けば、動作確認のついでに、テストまで手に入るので、それは素敵よね？と。</p>
<p>(単体)テストが第一の目的ではない、(動作確認)テストが目的なのだ。だから、テストフレームワークはVisual Studioと完全な統合を果たしていなければならない。ショートカットでIDE内のウィンドウで即座に実行。スピードが大事。また、シームレスなデバッグ実行への移行も。故にMSTestを選択するのである(ｷﾘｯ</p>
<p>などなどはその辺にしておいて、それはともかくで、素直にフル.NET Frameworkで動くMSTestを使います。一応Silverlightのアセンブリは<a href="http://blogs.msdn.com/b/clrteam/archive/2009/12/01/sharing-silverlight-assemblies-with-net-apps.aspx">フル.NETからも参照可能</a>のようなので、普通にテストプロジェクトを立ててDebug.dll を参照してやる(プロジェクト参照は警告出るので)という手も使えなくはなさそうなのですが、完全な互換を持つコアライブラリは全体のごく一部で、それ以外を使っていると普通に実行時例外でコケるなど、正直使えないと私は判断しました。よって、アセンブリ参照でやるのは諦め。プロジェクト参照で警告が出る理由も分かりました、あまり実用的な機能ではない……。</p>
<p>代わりにWP7プロジェクトとテストプロジェクトの間に、.NET4ライブラリプロジェクトを立てて、「追加-&gt;既存の項目-&gt;リンクとして追加」で、フルフレームワークとWP7間で.csファイルを共有してやります(Viewは勿論共有出来ないので、基本はModelのみ)。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_testref.jpg">
</p>
<p>勿論、コードレベルで互換が取れていないと動きません。そんなわけで、少なくともModelに関してはWPF/SL/WP7で共通で使いまわせるように意識して作りたいところです。移植性というだけじゃなく、MSTestの恩恵を受けれるので。ただまあ、無理な部分は無理で諦めちゃってもいいとは思います(SLのほうにだけあるクラスとかもありますから)。非同期のテストなどは、幸いRxを使っていれば非常に簡単なので、バシバシ書いちゃいましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Utakotoha.Test/SongTest.cs
[TestMethod]
[Timeout(3000)]
public void SearchLyric()
{
    var song = new Song(&quot;吉幾三&quot;, &quot;俺ら東京さ行ぐだ&quot;);
    var array = song.SearchLyric().ToEnumerable().ToArray();

    array.Count().Is(1);
    array.First().Title.Is(&quot;俺ら東京さ行ぐだ 吉幾三&quot;);
    array.First().Url.Is(&quot;http://music.goo.ne.jp/lyric/LYRUTND1127/index.html&quot;);
}
</code></pre>
<p>ToEnumerableしてToArrayするだけです！非同期のテストなんて怖くない。</p>
<p><a href="http://blogs.msdn.com/b/bclteam/archive/2011/01/19/announcing-portable-library-tools-ctp-justin-van-patten.aspx">Portable Library Tools CTP</a>という、各環境で互換性の取れるライブラリが作成出来るもの、なども出てきているので、リンクで追加とかいう間抜け(そして面倒)なことじゃなく、プロジェクトごと分離して、Modelは互換で生成、というのが将来的には良いやり方になるかなあ、などと思っています。そういう事情から、私は移植性とは関係ない立場からも、Portable Library Toolsの発展に期待しています。</p>
<p>なお、アサーションは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>使っています。ドッグフードドッグフード。というかもう、必需品なので、これないと書けない、書きたくない……。</p>
<h2>Mocking Event with Moles and Rx</h2>
<p>さて、このやり方の利点として、PexやMolesが使えます(Pexは一応SLをサポートしたものの、Molesは依然としてSL未サポート)。Moles(Microsoft Researchが提供するモックフレームワーク、フリー)の乗っ取り機構は強力なので、テスト可能範囲が大幅に広がります。詳しくは<a href="http://neue.cc/2011/03/10_309.html" title="neue cc - Rx + MolesによるC#での次世代非同期モックテスト考察">Rx + MolesによるC#での次世代非同期モックテスト考察</a>をどうぞ。</p>
<p>今回Linq to Eventで紹介したPlayingSongActiveは、以下のようにテストしています。MediaPlayer周りはXNAなので、Test側の参照DLLとしてXNA Game Studio v4.0のMicrosoft.Xna.Framework.dllを参照。そしてMolesで乗っ取り。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Utakotoha.Test/MediaPlayerStatusTest.cs

private MediaPlayerStatus CreateStatus(MediaState state, string artist, string name)
{
    return new MediaPlayerStatus
    {
        MediaState = state,
        ActiveSong = new Microsoft.Xna.Framework.Media.Moles.MSong
        {
            NameGet = () =&gt; name,
            ArtistGet = () =&gt; new MArtist
            {
                NameGet = () =&gt; artist
            }
        }
    };
}

[TestMethod, HostType(&quot;Moles&quot;)]
public void PlayingSongActiveTest()
{
    // event invoker
    var invoker = new Subject&lt;MediaPlayerStatus&gt;();
    MMediaPlayerStatus.MediaStateChanged = () =&gt; invoker;

    // make target observable
    var target = MediaPlayerStatus.PlayingSongActive().Publish();
    target.Connect();

    // at first, stopped
    using (target.VerifyZero())
    {
        invoker.OnNext(CreateStatus(MediaState.Stopped, &quot;&quot;, &quot;&quot;));
    }

    // next, playing
    using (target.VerifyOnce(song =&gt; song.Is(s =&gt; s.Title == &quot;song&quot; &amp;&amp; s.Artist == &quot;artist&quot;)))
    {
        invoker.OnNext(CreateStatus(MediaState.Playing, &quot;artist&quot;, &quot;song&quot;));
    }

    // pause
    using (target.VerifyZero())
    {
        invoker.OnNext(CreateStatus(MediaState.Paused, &quot;&quot;, &quot;&quot;));
    }

    // play again
    using (target.VerifyOnce(song =&gt; song.Is(s =&gt; s.Title == &quot;song2&quot; &amp;&amp; s.Artist == &quot;artist2&quot;)))
    {
        invoker.OnNext(CreateStatus(MediaState.Playing, &quot;artist2&quot;, &quot;song2&quot;));
    }
}
</code></pre>
<p>元のコード自体がイベント発火部分はRxで包んであるので、そのイベント発火だけを差し替え。SubjectとはイベントのRxでの表現。OnNextでイベント発火の代用が可能になっています。これで、任意のイベント(今回はMediaPlayerなので、再生停止であったり再生開始であったり)を発行して、その結果の挙動を確認しています。</p>
<p>VerifyなんたらはIObservableへの自前拡張メソッドで、発火されたか/回数の検証です。「イベントは発生したけれどフィルタリングされて値が届かなかった」ことの、フィルタリングが正常に出来たかの確認って、そのままだと難しい。如何せんSubscribeまで届いてくれないということですから。そのため、その辺を面倒みてくれるものを用意しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Utakotoha.Test/Tools/ObservableVerifyExtensions.cs

/// &lt;summary&gt;verify called count when disposed. first argument is called count.&lt;/summary&gt;
public static IObservable&lt;T&gt; Verify&lt;T&gt;(this IObservable&lt;T&gt; source, Expression&lt;Func&lt;int, bool&gt;&gt; verify)
{
    var count = 0;
    return source
        .Do(_ =&gt; count += 1)
        .Finally(() =&gt;
        {
            var msg = verify.Parameters.First().Name + &quot; = &quot; + count + &quot; =&gt; &quot; + verify.Body;
            Assert.IsTrue(verify.Compile().Invoke(count), &quot;Verifier &quot; + msg);
        });
}

/// &lt;summary&gt;verify called count when disposed. first argument is called count.&lt;/summary&gt;
public static IDisposable VerifyAll&lt;T&gt;(this IObservable&lt;T&gt; source, Expression&lt;Func&lt;int, bool&gt;&gt; verify, Action&lt;T&gt; onNext = null)
{
    return source.Verify(verify).Subscribe(onNext ?? (_ =&gt; { }));
}

/// &lt;summary&gt;verify not called when disposed.&lt;/summary&gt;
public static IDisposable VerifyZero&lt;T&gt;(this IObservable&lt;T&gt; source)
{
    return source.VerifyAll(i =&gt; i == 0);
}

/// &lt;summary&gt;verify called once when disposed.&lt;/summary&gt;
public static IDisposable VerifyOnce&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext = null)
{
    return source.VerifyAll(i =&gt; i == 1);
}
</code></pre>
<p>usingによるスコープを抜けるとFinallyで検証が入ります。RxでイベントをラップするとIDisposableになる、そのことの利点が生きてきます。</p>
<h2>今後の改善</h2>
<p>Pivotのヘッダーのデザインがどうも間抜け(マージンの取り方が変だし文字サイズも違和感あり)なのが気になってるので、変えたいです。HeaderTemplateの編集の仕方がよくわからずで放置なのですけれど、ゆったり紐解けば出来るでしょう。多分。</p>
<p>レジュームへの配慮が全くなくて、別画面にいくと真っ白になるのがビミョい。WebBrowserが絡むので完全な復元は無理だから、いっかー、とか思ったのが半分はあるのですが、いやまてその理屈はオカシイ。ので、ちょっと何とかさせないとですね。</p>
<p>xaml.csのコードが全体的にマズい。特にOAuth認証の部分はありえない強引さなのでとっとと変更。あと、もう少し適切な分割。MVVMはわからんちん。</p>
<p>Settingsが何か変。IsolatedStorageSettingsというか、その内部のDataContractSerializerの都合というか。これだ！というやり方ないかしら。今のやり方は、非常に間抜け。</p>
<p>ブラウザ画面黒背景はビミョーなので、設定でアプリ全体を白背景に変更するオプションを入れるのもいいかなー。それとアプリ起動時は楽曲を再生中でも自動検索しないのだけど、自動検索してくれたほうが嬉しいかなー。など、細かい点では色々考えること、追加することあります。</p>
<h2>まとめ</h2>
<p>上手く決まった部分しか解説してないので、実際のコードは残念ながらスパゲッティです:) というか、UI絡みのコードってほとんど書いたことないので、経験の無さが如実に現れていて苦すぃ。WP7で勝手がわからないというもの若干はありますが、それ以前の問題がかなり。サンプルアプリとしても、もう少し良くしたいので、コードは徐々に洗練させていきたいですます。</p>
<p>アプリとしては、まあまあいい出来というか、実用品として悪くないフィーリングだと思うのですが、どうでしょうか？画面周りは、このレイアウトで決まるまで何度も試して投げてを繰り返してこれに落ち着きました。実際に作りながら、試しながらでないとこういうの決められないよね。コードに関してもそうだけど。ともあれ、Pivotいいよねー。やはりWP7といったらPivot。</p>
<p>そんなわけで、RxはWP7開発のお供として欠かせない代物なので、是非使ってみてください。また、WP7で欠かせないということはSilverlightで欠かせないということであり、Silverlightで欠かせないということはWPFでも欠かせないということでも、あったりなかったりするので、Rxによるプログラミングパラダイムの変化を是非とも楽しんでみてください。Linq to Anything!</p>
<p>一記事に収めるため少々駆け足気味だったので、なにか不明な点、質問などありましたら気楽にコメントどうぞ。突っ込みも勿論歓迎です。</p>
</div>
<h1 data-pagefind-sort="date:2011-04-02" data-pagefind-meta="published:2011-04-02"><a href="https://neue.cc/2011/04/02_313.html">Microsoft MVP for Visual C#を受賞しました</a></h1>
<ul class="date"><li>2011-04-02</li></ul>
<div class="entry_body"><p><a href="http://www.microsoft.com/japan/communities/mvp/default.mspx" title="マイクロソフト MVP アワードプログラム">Microsoft MVP</a>から、Visual C#カテゴリで受賞しました。for Linqというカテゴリがないので大変厳しいかと思われましたが何とか認められたようです。活動申請には、ほんとうにLinqが～Linqが～ばかりで。今見返すと「活動の源泉は、C#/Linqの素晴らしさを伝えたい！ということです」などとコメント欄に書いちゃっていたり。あと、審査するのは本社の連中だからアメリカンに、大袈裟に書くぐらいがいいんだよ、とアドバイスを受けたので「RxJSによりJavaScriptにおいてもInterective(Enumerable)とReactive(Observable)の美しい融合が果たせることが可能となりました。そのうちのInterective側を支える(<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js</a>)ことが出来るのは自分しかいない」とかいう恥ずかしいことまで言っちゃってますね、うわあ。</p>
<p>というわけで、公約みたいなものなので、今後もC#/Linqの素晴らしさを伝える道を邁進したいと思います。</p>
<p>私とMVP。MVPアワードの存在を知ったのは<a href="http://www.xbox-news.com/press0407.html" title="XNEWSがマイクロソフトMVPアワードを受賞">XNEWSがマイクロソフトMVPアワードを受賞</a>した時のことで、ただのゲーマーだった頃でした。その頃は何なのか分からず月日は流れ、就職してC#を触りだしてから(2008年)、MVPがどういう存在であるかを知り、以下略。</p>
<p>私が成長できたのは多くの先人の、ネット上のリソースのお陰です。今度は、私が恩返しする番。今まで通り、今まで以上に知識を伝えていけたらと思っています。</p>
</div>
<h1 data-pagefind-sort="date:2011-03-31" data-pagefind-meta="published:2011-03-31"><a href="https://neue.cc/2011/03/31_312.html">Windows Phone 7でJSONを扱う方法について(+ Bing APIの使い方)</a></h1>
<ul class="date"><li>2011-03-31</li></ul>
<div class="entry_body"><p>C#と親和性の高いデータ形式はXMLです。何と言ってもLinq to Xmlが強力です。また、SOAPも悪くない、というのもVisual Studioの自動生成が効くので何も考えずともホイホイ使えます。ではJSONは、というと、これは割と扱いづらいところがあるのが正直なところ。しかしWindows Phone 7においては、JSONを選択すべきでしょう。なにせ、モバイル機器。ネットワークがとても貧弱。データは小さいに越したことはない。XMLとJSONとでは、雲泥の差です。</p>
<p>WPFではJsonReaderWriterFactory(と、内部にそれを用いた<a href="http://dynamicjson.codeplex.com/" title="DynamicJson">DynamicJson</a>)、SilverlightではSystem.Jsonなどが用意されていますが、WP7には一切ありません。じゃあどうするかといえば、シリアライザを使います。WP7ではDataContractJsonSerializerが標準で用意されている(WPF, SLにもあります)ので、それを使ってデシリアライズしてJSONをオブジェクトに変換するのが基本戦略となります。</p>
<p>外部ライブラリ、<a href="http://json.codeplex.com/" title="Json.NET">Json.NET</a>を使うという手も勿論ありますが。</p>
<h2>BingからのJSONの取得</h2>
<p>何はともあれ、サンプル題材のJSONを拾ってきましょう。Webからの取得というと、最近はいつもTwitterのPublic Timelineでマンネリ飽き飽きなので、別のものを。WP7なので、<a href="http://www.bing.com/developers" title="Bing Developer Center">Bing API</a>を使いましょう！Bing APIはIDを取得しないと使えないのでサンプル的にどうよ、というところもありますが、IDの取得は簡単(ほんとワンクリックです)だしWP7と親和性の高いAPIでもあるので、これを機に、試しに取ってみるのも良いのではと思います。画像検索、翻訳など色々種類があるのですが、今回はWeb検索(sources=web)にします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 標準WP7テンプレのMainPage.xaml.csにベタ書き

const string AppId = &quot;&quot;; // AppIdは登録してください

Uri CreateQuery(params string[] words)
{
    // countなどは変数で置き換えれるようにするといいのではと思います、ここでは固定決め打ちですが
    var query =
          &quot;?Appid=&quot; + AppId
        + &quot;&amp;query=&quot; + Uri.EscapeUriString(string.Join(&quot; &quot;, words))
        + &quot;&amp;sources=web&quot;
        + &quot;&amp;version=2.0&quot;
        + &quot;&amp;Market=ja-jp&quot;
        + &quot;&amp;web.count=20&quot;
        + &quot;&amp;web.offset=0&quot;;

    return new Uri(&quot;http://api.search.live.net/json.aspx&quot; + query);
}

public MainPage()
{
    InitializeComponent();

    var wc = new WebClient();

    Observable.FromEvent&lt;DownloadStringCompletedEventHandler, DownloadStringCompletedEventArgs&gt;(
            h =&gt; h.Invoke, h =&gt; wc.DownloadStringCompleted += h, h =&gt; wc.DownloadStringCompleted -= h)
        .ObserveOnDispatcher()
        .Subscribe(e =&gt;
        {
            var json = e.EventArgs.Result; // ダウンロード結果(json文字列)
            MessageBox.Show(json);
        });

    wc.DownloadStringAsync(CreateQuery(&quot;地震&quot;));
}
</code></pre>
<p>json.aspxにクエリ文字列をつけてGETするだけなので割とお手軽。クエリ文字列がゴチャゴチャして分かりづらいのですが、基本的に弄るのはqueryとweb.countぐらいかな、と思います。BingのReferenceは、生成元のクラス構造がまんま掲示されているだけで、恐ろしく分かりづらいので、適当にサンプルから当たりをつける感じで。</p>
<p>非同期通信の実行は<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions(Rx)</a>で行います。Windows Phone 7では標準で入っているのでSystem.ObservableとMicrosoft.Phone.Reactiveを参照に加えてください。非同期通信を生でやるなんてありえませんから！Rx利用を推奨します。</p>
<p>得られるJSONは下記のものです。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">{
    &quot;SearchResponse&quot;: {
        &quot;Version&quot;: &quot;2.0&quot;,
        &quot;Query&quot;: {
            &quot;SearchTerms&quot;: &quot;地震&quot;
        },
        &quot;Web&quot;: {
            &quot;Total&quot;: 88,
            &quot;Offset&quot;: 0,
            &quot;Results&quot;: [
                {
                    &quot;Title&quot;: &quot;地震情報 - Yahoo!天気情報&quot;,
                    &quot;Description&quot;: &quot;Yahoo!天気情報は、市区町村の天気予報、世界の天気...&quot;,
                    &quot;Url&quot;: &quot;http://typhoon.yahoo.co.jp/weather/jp/earthquake/&quot;,
                    &quot;DisplayUrl&quot;: &quot;typhoon.yahoo.co.jp/weather/jp/earthquake&quot;,
                    &quot;DateTime&quot;: &quot;2011-03-29T19:11:00Z&quot;
                },
                {
                    &quot;Title&quot;: &quot;地震情報 :: ウェザーニュース&quot;,
                    &quot;Description&quot;: &quot;最新の地震の震度、震源地、震度分布を速報で届けます...&quot;,
                    &quot;Url&quot;: &quot;http://weathernews.jp/quake/&quot;,
                    &quot;DisplayUrl&quot;: &quot;weathernews.jp/quake&quot;,
                    &quot;DateTime&quot;: &quot;2011-03-28T09:10:00Z&quot;
                },
                // 配列上なので幾つも...
            ]
        }
    }
}        
</code></pre>
<p>JSONに関しては<a href="http://jsonviewer.codeplex.com/">JSON Viewer</a>をVisual StudioのVisualizerに組み込むとかなり快適にプレビュー出来るようになります。が、カスタムVisualizerはWP7では実行出来ないのでテキストで見て、スタンドアロンのものにコピペってのを実行ですね、しょんぼり。</p>
<h2>DataContractJsonSerializer</h2>
<p>では、JSONをオブジェクトに変換しましょう。基本的には、1:1に対応するクラスを作るだけ。必要に応じて System.Runtime.Serializationの参照を加えDataContract, DataMember属性なども加えればよし。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class BingWebRoot
{
    public SearchResponse SearchResponse { get; set; }
}

public class SearchResponse
{
    public string Version { get; set; }
    public Query Query { get; set; }
    public Web Web { get; set; }
}

public class Query
{
    public string SearchTerms { get; set; }
}

public class Web
{
    public int Total { get; set; }
    public int Offset { get; set; }
    public Results[] Results { get; set; }
}

public class Results
{
    public string Title { get; set; }
    public string Description { get; set; }
    public string Url { get; set; }
    public string DisplayUrl { get; set; }
    public string DateTime { get; set; }
}
</code></pre>
<p>JSONは、JavaScriptのオブジェクトとほぼ同一の記述ですが、ようするに{}になっている部分はクラスで、[]になっている部分は配列で、置き換えていけばいい、ということで。難しくはないのですが、面倒くさいには大変面倒くさい。なお、JSONの構造を全部記述する必要はなく、必要なものだけでも構いません、例えばVersionやQueryはいらないから省くとか、全然アリです。</p>
<p>そして、 System.ServiceModel.Web を参照設定に加え、DataContractJsonSerializerを使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var wc = new WebClient();

Observable.FromEvent&lt;OpenReadCompletedEventHandler, OpenReadCompletedEventArgs&gt;(
        h =&gt; h.Invoke, h =&gt; wc.OpenReadCompleted += h, h =&gt; wc.OpenReadCompleted -= h)
    .ObserveOnDispatcher()
    .Subscribe(e =&gt;
    {
        using (var stream = e.EventArgs.Result)
        {
            var serializer = new DataContractJsonSerializer(typeof(BingWebRoot));
            var result = (BingWebRoot)serializer.ReadObject(stream);

            MessageBox.Show(result.SearchResponse.Web.Results[0].Title);
        }
    });

wc.OpenReadAsync(CreateQuery(&quot;地震&quot;));
</code></pre>
<p>デシリアライズはReadObject、シリアライズはWriteObjectで行います。基本はstreamを渡すだけでオブジェクトの出来上がり。</p>
<h2>with Reactive Extensions</h2>
<p>ですが、まあ、Resultsが欲しいだけなのにSearchResponse.Web.Resultsは長げーよ、とか、DateTimeがstringでイヤだー、とか色々あります。そういう場合はJSONとのマッピング用のクラスとは別に、アプリケーション側で使うクラスを別に立ててやればいいんぢゃないかしら。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class SearchResults
{
    public string Title { get; set; }
    public string Url { get; set; }
    public DateTime DateTime { get; set; }

    public override string ToString()
    {
        return DateTime + &quot; : &quot; + Title + &quot; : &quot; + Url;
    }
}
</code></pre>
<p>TitleとUrlとDateTimeしかいらない！という具合で。これを、今度はWebRequestを使って書くと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(CreateQuery(&quot;ほむほむ&quot;));

Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
    .Select(r =&gt;
    {
        using (var stream = r.GetResponseStream())
        {
            var serializer = new DataContractJsonSerializer(typeof(BingWebRoot));
            return (BingWebRoot)serializer.ReadObject(stream);
        }
    })
    .SelectMany(x =&gt; x.SearchResponse.Web.Results)
    .Select(x =&gt; new SearchResults { DateTime = DateTime.Parse(x.DateTime), Title = x.Title, Url = x.Url })
    .ObserveOnDispatcher()
    .Subscribe(x =&gt; 
    {
        // 加工は全部終わってるのでここで色々自由に処理
        Debug.WriteLine(x);
    });
</code></pre>
<p>となります。最初のSelectは非同期の結果、次のSelectManyではResults[]、つまり普通の配列を平坦化して、以降は普通のLinqのようなコレクション処理をしています。</p>
<p>非同期リクエストとオブジェクトのコレクション処理が、完全にシームレスに溶け込んでいます。これが、RxがLinqとして存ることの真価の一つです。記述が統一され、かつ限りなくシンプルになる。Rxは非同期が、イベントが、時間が、簡単に扱えます。でも、本当の真価は単独で使うというだけでなく、それらが全てPush型シーケンスに乗っていることで、統合することが可能だというところにあります。</p>
<p>でも、むしろ分かりにくい？ふむむ……。慣れの問題、などというと全く説得力がなくてアレですが、しかし、慣れです。記述がシンプルになり、柔軟性と再利用性が増していることには間違いないわけで、後は一度全て忘れてLINQの世界に飛び込んでしまえばいいと思うんだ。</p>
<p>Linqは各処理の単位が細分化されている(Selectは射影、Whereはフィルタ)ことも特徴ですが、これは思考の再利用可能性を促します。非同期-&gt;オブジェクト配列=SelectManyなど、単純な定型パターンに落とし込めます。C#はもとより強力なIntelliSenseにより、ブロックを組み立てるかの如きなプログラミングを可能にしていますが、Linqでは、それが更に先鋭化されていると見れます。</p>
<h2>まとめ</h2>
<p>これも現在製作中のWP7アプリからの一部です。最近Bing API利用に切り替えたので。無駄に汎用化して作りこみつつきりがないので適度なところできりあげつつ。ユニットテスト作ってあったので移行自体は幸いすんなりいった。良かった良かった。テスト大事。</p>
<p>Bing APIの前は諸事情あってGoogleからのスクレイピングでした。スクレイピングはグレーだろうということで代替案をずっと探していて、何とかBingに落ち着きました。最初はどうにも使い物にならない、と思ったのですが、検索パラメータを色々変えて、ある程度望む結果が出るようにはなったかな、と。Bingは結構癖があって、調整大変ですね。その話は後日、WP7アプリが完成したときにでも……。</p>
<p>コード的にはスクレイピングのほうも割と凝ってたんですけどねー、バッサリとゴミ箱行き。復活することは、ないかな。もったいないけどしょうがない。いつかそのうち紹介する日は、来るかも来ないかも。</p>
<p>そんなわけで延々と足踏みしていて実装は相変わらず一歩も進んでませんが(！) 順調に制作は進行中なので乞うご期待。いやほんと。</p>
</div>
<h1 data-pagefind-sort="date:2011-03-28" data-pagefind-meta="published:2011-03-28"><a href="https://neue.cc/2011/03/28_311.html">Widows Phone 7でアプリケーション名やバージョン番号をバインドする方法</a></h1>
<ul class="date"><li>2011-03-28</li></ul>
<div class="entry_body"><p>アプリケーション名の表示や、about画面に表示したいであろうバージョン番号、どうします？直書きのstringやリソースから？それもいいのですけれど、せっかくプロジェクトのプロパティ(AssemblyInfo.cs)で、アプリケーション名やバージョン番号を設定しているわけだから、そこから利用できたほうがいいですよね。</p>
<p>というわけで、これらの情報はアセンブリから取得しましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class AssemblyInfoData
{
    public static readonly AssemblyInfoData ExecutingAssembly = new AssemblyInfoData(Assembly.GetExecutingAssembly());

    public string FileName { get; private set; }
    public string Version { get; private set; }
    public string FileVersion { get; private set; }
    public string Title { get; private set; }
    public string Description { get; private set; }
    public string Configuration { get; private set; }
    public string Company { get; private set; }
    public string Product { get; private set; }
    public string Copyright { get; private set; }
    public string Trademark { get; private set; }
    public string Culture { get; private set; }

    public AssemblyInfoData(Assembly assembly)
    {
        var assemblyName = new AssemblyName(assembly.FullName);
        FileName = assemblyName.Name;
        Version = assemblyName.Version.ToString();

        FileVersion = GetAttributeName&lt;AssemblyFileVersionAttribute&gt;(assembly, a =&gt; a.Version);
        Title = GetAttributeName&lt;AssemblyTitleAttribute&gt;(assembly, a =&gt; a.Title);
        Description = GetAttributeName&lt;AssemblyDescriptionAttribute&gt;(assembly, a =&gt; a.Description);
        Configuration = GetAttributeName&lt;AssemblyConfigurationAttribute&gt;(assembly, a =&gt; a.Configuration);
        Company = GetAttributeName&lt;AssemblyCompanyAttribute&gt;(assembly, a =&gt; a.Company);
        Product = GetAttributeName&lt;AssemblyProductAttribute&gt;(assembly, a =&gt; a.Product);
        Copyright = GetAttributeName&lt;AssemblyCopyrightAttribute&gt;(assembly, a =&gt; a.Copyright);
        Trademark = GetAttributeName&lt;AssemblyTrademarkAttribute&gt;(assembly, a =&gt; a.Trademark);
        Culture = GetAttributeName&lt;AssemblyCultureAttribute&gt;(assembly, a =&gt; a.Culture);
    }

    private string GetAttributeName&lt;T&gt;(Assembly assembly, Func&lt;T, string&gt; selector) where T : Attribute
    {
        var attr = assembly.GetCustomAttributes(typeof(T), true).Cast&lt;T&gt;().FirstOrDefault();
        return (attr == null) ? &quot;&quot; : selector(attr);
    }
}
</code></pre>
<p>FileName, Versionはnew AssemblyNameに渡してから(WPFだとGetNameで直に取れるのですが、Silverlightだとセキュリティ違反で例外が飛ぶためこうする必要がある)、それ以外の値はカスタム属性から取得できます。また、任意のAssemblyの情報をコンストラクタに投げて取得出来るようになっていますが、どうせ必要なのは実行アセンブリの情報だけでしょ？ってことで、public staticなフィールドにExecutingAssemblyのデータを公開するようにしています。なので、コードからは、 AssemblyInfoData.ExecutingAssembly.Version とアクセスするだけで、簡単に取得できます。</p>
<p>でも、コードから欲しいということはほとんどなくて、UIに表示するためだけに欲しいのですよね、こういう情報は。バインディングしましょう！まず、こんなクラスを用意します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class AssemblyInfoDataBindingHelper
{
    public AssemblyInfoData Value { get { return AssemblyInfoData.ExecutingAssembly; } }
}
</code></pre>
<p>何故これが必要かというと、WPFの場合は{x:static}でstatic変数もバインド出来るのですが、Silverlight/WP7ではバインド出来ないためです。いやあ、カッコ悪いですね、{x:static}欲しいですね、まあ、ないものはしょうがない。</p>
<p>次にApp.xamlのApplication.Resourcesの中に</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Application.Resources&gt;
    &lt;!-- Applicationのところで xmlns:local=&quot;ネームスペース&quot; を宣言しておく--&gt;
    &lt;local:AssemblyInfoDataBindingHelper x:Key=&quot;AssemblyInfoData&quot;/&gt;
&lt;/Application.Resources&gt;
</code></pre>
<p>と書いてリソースを登録。準備はこれで完了で、あとはバインドするだけ。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;TextBlock x:Name=&quot;ApplicationTitle&quot; Text=&quot;{Binding Value.Title, Source={StaticResource AssemblyInfoData}}&quot; Style=&quot;{StaticResource PhoneTextNormalStyle}&quot;/&gt;
&lt;TextBlock x:Name=&quot;PageTitle&quot; Text=&quot;{Binding Value.Version, Source={StaticResource AssemblyInfoData}}&quot; Style=&quot;{StaticResource PhoneTextTitle1Style}&quot; /&gt;
</code></pre>
<p>と、以上です。これで下のような感じに</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/wp7asminfo.jpg">
</p>
<p>表示されました。ApplicationTitleにTitleは分かりますがPageTitleにVersionは丸っきりイミフ。ボタンは、何となく寂しいから置いただけで意味はないです気にしないで。</p>
<p>AssemblyInfoDataクラスのコードは完全に独立して使い回しが効くので、コピペってどうぞご自由にお使いください。煮るなり焼くなり……、パブリックドメインで。</p>
<h2>まとめ</h2>
<p>といったのは、一応、今製作中のWP7アプリの一部です。順調に制作は遅れまくり。うむむ。今月中といきたかったのだけど、まーだずれ込みそう。その前は二月中のつもりだったのだけど、<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>が思いの外引っ張りすぎて手を付けてる余裕がなかった。とにかく、4月中頃までには、マーケットプレイスで公開したいなあ。あとソースコードも公開します(というか既に製作中のがこっそり公開されてます)。Reactive Extensionsの実践例として、ただたんに非同期で使うというだけじゃなく、こういうケースで使える、コードはこうなる。というサンプルとして役立てればいいな、という思いで書いてますので、適当に待っていてください。</p>
<p>人に見せるためのコード、というのを念頭に置きすぎていて、同じ場所のコードの修正ばかり繰り返していてアプリ全体としては一歩も製作が進まないという超鈍足状態に陥ってますが(コード書きの遅さに定評のある私です(ｷﾘｯ)、でも、書きなおす度に確実によくなっていく実感はあるので、最終的にそこそこ見せれるコードになるのではないかと思っています。少なくとも、部分的には面白い内容になるはずです。</p>
</div>
<h1 data-pagefind-sort="date:2011-03-17" data-pagefind-meta="published:2011-03-17"><a href="https://neue.cc/2011/03/17_310.html">DynamicAccessor - Chaining Assertion ver.1.4.0.0</a></h1>
<ul class="date"><li>2011-03-17</li></ul>
<div class="entry_body"><ul>
<li><a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion - CodePlex</a></li>
</ul>
<p>テストブームはまだ続いています。さて、テスト可能性の高い設計は良いのですが、本来あるべきである設計を歪めて(単純なところでいえば、virtualである必要でないものをvirtualにするとか、privateであるべきものをprotectedにするとか、無駄なinterfaceとか、不自然な引数の取り方とか)テスト可能性を確保するのは、私は嫌だなー。などと思っていましたが、しかし、モックについては<a href="http://neue.cc/2011/03/10_309.html" title="neue cc - Rx + MolesによるC#での次世代非同期モックテスト考察">Molesを使うことで、最高の形で解決</a>しました。</p>
<p>次に何を考えるべきかな、と浮かんだのはprivateのテスト。privateのテストは考えないという流儀もあるし、それは尤もだと思いますが、publicのものをテストするにも、ちょっと確認とりたかったり値を弄ってやりたかったりなど、触れると楽な場合もいっぱいあるので、出来るにこしたことはありません。MSTestにはAccessorの自動生成で完全なタイプセーフとIntelliSenseの保証をしてくれて、それはそれで大変素敵。なのですが、もう少し軽くテスト出来る機構を用意しました。MSTestへの依存はないので、NUnitでも他のテストフレームワークでも使えます。</p>
<p>privateへのアクセスはリフレクションが常套手段ですが、C#4.0ならdynamicがあるよね。というわけで、dynamicで包んだアクセサを用意しました。dynamicにしたからってprivateのものは呼び出せないので、DynamicObjectで包んでリフレクション経由になるようにしています。</p>
<h2>AsDynamic()</h2>
<p>こんな感じで使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなprivateばっかなクラスがあったとして
public class PrivateMock
{
    private string privateField = &quot;homu&quot;;

    private string PrivateProperty
    {
        get { return privateField + privateField; }
        set { privateField = value; }
    }

    private string PrivateMethod(int count)
    {
        return string.Join(&quot;&quot;, Enumerable.Repeat(privateField, count));
    }
}

// AsDynamic()をつけるだけでPrivateプロパティが呼べる
var actual = new PrivateMock().AsDynamic().PrivateProperty;
Assert.AreEqual(&quot;homuhomu&quot;, actual);

// dynamicは拡張メソッドが呼べないのでIsを使う場合はキャストしてくださいな。
(new PrivateMock().AsDynamic().PrivateMethod(3) as string).Is(&quot;homuhomuhomu&quot;);

// 勿論setも出来ます（インデクサもいけます。ジェネリックメソッドも若干の制限付きですが呼べます）
var mock = new PrivateMock().AsDynamic();
mock.PrivateProperty = &quot;mogumogu&quot;;
(mock.privateField as string).Is(&quot;mogumogu&quot;);
</code></pre>
<p>オブジェクトへの拡張メソッドにより、全てのオブジェクトに対しAsDynamic()が使える状態です。IntelliSense汚染なので通常だとあまり許容できることではないのですが、UnitTestなのでOKだろう、と。AsDynamic()後はDynamicObjectとして、全ての呼び出しがリフレクション経由となり、public/privateのメソッド/プロパティ/フィールド/インデクサに自由にアクセス可能となっています。見た目は普通と全く一緒で大変自然なのがdynamicの利点。</p>
<p>dynamicの状態では拡張メソッドの呼び出しは不可能なので、IsによるAssertionを行う場合は、キャストして型を適用してやる必要があります。メンドクセーという場合はAssert.AreEqualなど、本来用意されているものはobjectが対象なので、そのまんま使えます。どちらでも好き好きでどうぞ。</p>
<h2>ダイナミックとジェネリックとメソッド呼び出し</h2>
<p>実装内部の話。DynamicObjectでTryInvokeMemberです。んで、最初はすんごく簡単に実装出来ると思ったんですよ！dynamicでリフレクション包むだけね、はいはい、余裕余裕、と。が、実際に書きだすとどうも引っかかる。オーバーロードが。ジェネリックが。型推論が。ふつーに呼んでるとうまくオーバーロードを解決してくれなくて、AmbiguousMatchException(あいまいな一致)を投げてくれます。なので、手動でマッチさせる必要があります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
{
    var csharpBinder = binder.GetType().GetInterface(&quot;Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder&quot;);
    if (csharpBinder == null) throw new ArgumentException(&quot;is not generic csharp code&quot;);

    var typeArgs = (csharpBinder.GetProperty(&quot;TypeArguments&quot;).GetValue(binder, null) as IList&lt;Type&gt;).ToArray();
    var method = MatchMethod(binder.Name, args, typeArgs);
    result = method.Invoke(target, args);

    return true;
}

private Type AssignableBoundType(Type left, Type right)
{
    return (left == null || right == null) ? null
        : left.IsAssignableFrom(right) ? left
        : right.IsAssignableFrom(left) ? right
        : null;
}

private MethodInfo MatchMethod(string methodName, object[] args, Type[] typeArgs)
{
    // name match
    var nameMatched = typeof(T).GetMethods(TransparentFlags)
        .Where(mi =&gt; mi.Name == methodName)
        .ToArray();
    if (!nameMatched.Any()) throw new ArgumentException(string.Format(&quot;\&quot;{0}\&quot; not found : Type &lt;{1}&gt;&quot;, methodName, typeof(T).Name));

    // type inference
    var typedMethods = nameMatched
        .Select(mi =&gt;
        {
            var genericArguments = mi.GetGenericArguments();

            if (!typeArgs.Any() &amp;&amp; !genericArguments.Any()) // non generic method
            {
                return new
                {
                    MethodInfo = mi,
                    TypeParameters = default(Dictionary&lt;Type, Type&gt;)
                };
            }
            else if (!typeArgs.Any())
            {
                var parameterGenericTypes = mi.GetParameters()
                    .Select(pi =&gt; pi.ParameterType)
                    .Zip(args.Select(o =&gt; o.GetType()), Tuple.Create)
                    .GroupBy(a =&gt; a.Item1, a =&gt; a.Item2)
                    .Where(g =&gt; g.Key.IsGenericParameter)
                    .Select(g =&gt; new { g.Key, Type = g.Aggregate(AssignableBoundType) })
                    .Where(a =&gt; a.Type != null);

                var typeParams = genericArguments
                    .GroupJoin(parameterGenericTypes, x =&gt; x, x =&gt; x.Key, (_, Args) =&gt; Args)
                    .ToArray();
                if (!typeParams.All(xs =&gt; xs.Any())) return null; // types short

                return new
                {
                    MethodInfo = mi,
                    TypeParameters = typeParams
                        .Select(xs =&gt; xs.First())
                        .ToDictionary(a =&gt; a.Key, a =&gt; a.Type)
                };
            }
            else
            {
                if (genericArguments.Length != typeArgs.Length) return null;

                return new
                {
                    MethodInfo = mi,
                    TypeParameters = genericArguments
                        .Zip(typeArgs, Tuple.Create)
                        .ToDictionary(t =&gt; t.Item1, t =&gt; t.Item2)
                };
            }
        })
        .Where(a =&gt; a != null)
        .Where(a =&gt; a.MethodInfo
            .GetParameters()
            .Select(pi =&gt; pi.ParameterType)
            .SequenceEqual(args.Select(o =&gt; o.GetType()), new EqualsComparer&lt;Type&gt;((x, y) =&gt;
                (x.IsGenericParameter)
                    ? a.TypeParameters[x].IsAssignableFrom(y)
                    : x.Equals(y)))
        )
        .ToArray();

    if (!typedMethods.Any()) throw new ArgumentException(string.Format(&quot;\&quot;{0}\&quot; not match arguments : Type &lt;{1}&gt;&quot;, methodName, typeof(T).Name));

    // nongeneric
    var nongeneric = typedMethods.Where(a =&gt; a.TypeParameters == null).ToArray();
    if (nongeneric.Length == 1) return nongeneric[0].MethodInfo;

    // generic--
    var lessGeneric = typedMethods
        .Where(a =&gt; !a.MethodInfo.GetParameters().All(pi =&gt; pi.ParameterType.IsGenericParameter))
        .ToArray();

    // generic
    var generic = (typedMethods.Length == 1)
        ? typedMethods[0]
        : (lessGeneric.Length == 1 ? lessGeneric[0] : null);

    if (generic != null) return generic.MethodInfo.MakeGenericMethod(generic.TypeParameters.Select(kvp =&gt; kvp.Value).ToArray());

    // ambiguous
    throw new ArgumentException(string.Format(&quot;\&quot;{0}\&quot; ambiguous arguments : Type &lt;{1}&gt;&quot;, methodName, typeof(T).Name));
}

private class EqualsComparer&lt;TX&gt; : IEqualityComparer&lt;TX&gt;
{
    private readonly Func&lt;TX, TX, bool&gt; equals;

    public EqualsComparer(Func&lt;TX, TX, bool&gt; equals)
    {
        this.equals = equals;
    }

    public bool Equals(TX x, TX y)
    {
        return equals(x, y);
    }

    public int GetHashCode(TX obj)
    {
        return 0;
    }
}
</code></pre>
<p>泥臭い。LINQ的には普段あまり使わないGroupJoinや、SequenceEqualでのIEqualityComparerとか、ここぞとばかりに色々仕込んで実に楽しげになりました。何とも酷いゴリ押し。速度とかどうなのこれ、ただリフレクションを使っただけじゃないよね、というのは、UnitTestですから。だから、許容される。そうでなければ、やれない。</p>
<p>名前からマッチ-&gt;型の当てはめ-&gt;実引数からマッチ-&gt;非ジェネリックメソッドを優先-&gt;引数が全てジェネリックでなければ優先-&gt;最終的にメソッドが一つにまで絞り込めなければエラー。コンパイラの行う、正確なオーバーロードの解決法はC#言語仕様書の7.5.3に書いてあります。従っていません。というか、outとかrefとか非対応だし、ジェネリックに関しても持ってる情報が足りなすぎてマッチしたくてもできない。特に痛いのはコード上での型が吹っ飛んでいて、GetTypeによる具象型しか取得できないこと。そのせいで、引数の複数の同一のTは、ほぼ同じ型同士でないとダメになってしまっていて（コード上で宣言しているインターフェイスの情報が取れないのでどうしょもない）。その他、入れ子なジェネリックの場合もコケます(対応させるの面倒くさい)。</p>
<p>でも、ふつーの9割がたなシチュエーションでは動作するはずです。</p>
<p>ちなみに、ジェネリックの型引数は通常、DynamicObjectのBinderでは取得出来ません。Binderの実際の型(の持つインターフェイス)であるICSharpInvokeOrInvokeMemberBinderのTypeArgumentsが持っているのですが、ICSharpInvokeOrInvokeMemberBinderがinternalのため、外側から手出しは出来ないのです。どうするかって、もうここまで来たら何も躊躇うことなくリフレクションです本当にありがとうございました。GetInterface(&quot;Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder&quot;);とか、負けたにも程がある。</p>
<p>そんなわけで、ふつーに作ると存外面倒くさいっぽいです。いや、こんな泥臭くなるのは何かおかしい気はかなりしなくもないんですが、うーん。まあ、泥臭くてもライブラリ側で吸収出来るなら、それはそれでいいかな、と。結果だけを見れば。ライブラリが泥臭さを担保するかわりに、ユーザーはAsDynamic()だけで綺麗に呼び出せる。それはとっても嬉しいなって。</p>
<h2>余談</h2>
<p>そんなDynamicAccessorのテスト作るのにIsとかAssertEx.Throws、あって良かった。大変助かった。ExpectedExceptionAttributeなんて使ってられない。どっぐふーどどっぐふーど。個人的にはMSTestは凄い好きというか、テストツール選ぶのにあたって優先度が一番高い項目はIDE統合(デバッグ含むというかデバッグ最重要)なので、統合できてないものはその時点でアウトです(どれも、一手間加えれば統合出来るのでしょうけれど)。その上で、<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>を使えばMSTestの色々な不満が一気に解消出来て、最高に幸せだなあ、と、自画自賛。</p>
<h2>まとめ</h2>
<p>当初のIsだけでサクッと軽量なテスト～とかってノリは何処に行ったんでしょうか。ぐぬぬ。それでも、最大限のシンプルさは保ち続けている、と、思いたい。内部がどうあれ、外からはAsDynamic()が足されただけだし、それ自体もシンプルそのものですよね、ね？コンセプトはまだ守れてると、思いたい。</p>
<p>ところで、dynamic使ってます？ぶっちけ全然使ってません。結局のところvarが最高に便利なわけで、dynamicは、例えば以前書いた<a href="http://dynamicjson.codeplex.com/" title="DynamicJson">DynamicJson</a>であったり、これのようなリフレクションであったりと、通常のC#とは違う場所との糊なわけで、そうそう出番のあるものでもない、ですねん。C#4.0の言語的な追加の最たるものはdynamicなわけですが、普段はそんな使わない代物なわけだと、言語的にはC#4.0はあんま変わらなかったねー、という印象で。LL的な視点から、C#にはdynamicで動的言語でもあるんだって？という意見をたまに見ますが、純C#上ではぶっちゃけほとんど使わないのでそんなでもない。</p>
<p>じゃあなくてもいいか、というと、んー、まあ、このように、たまにある分には便利だし、言語的にもスムースに入り込んでいるので、良いのではないか、むしろ良いのではないか、とは思います。あんま使わないけどたまには思い出してあげると大変可愛い。</p>
<p>そういえば私は<a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%82%BF%E6%A7%8B%E6%96%87%E5%A4%89%E6%95%B0" title="メタ構文変数 - Wikipedia">メタ構文変数</a>としてhoge, huga, hageの順にhogehogeと使ってるのですが、Twiterでhomuにする。というのを見て、なんかいいな、とか思ってしまったので、当分はhomu, mogu, mamiの順に使おうかと思っている昨今。こーいうのは半年後ぐらいに、あちゃーという気持ちになるのが常なのですがー。</p>
</div>
<h1 data-pagefind-sort="date:2011-03-10" data-pagefind-meta="published:2011-03-10"><a href="https://neue.cc/2011/03/10_309.html">Rx + MolesによるC#での次世代非同期モックテスト考察</a></h1>
<ul class="date"><li>2011-03-10</li></ul>
<div class="entry_body"><p>最近、妙にテストブームです。<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>を作ったからですね。ライブラリドリブンデベロップメント。とりあえずでも何か作って公開すると、その分野への情報収集熱に火がつくよね。そして<a href="http://gihyo.jp/dev/serial/01/tdd/0014">テスト厨</a>へ。さて、ユニットテストで次に考えるべきは、モックの活用。C#でモックといえば<a href="http://code.google.com/p/moq/">Moq</a>が評価高い。メソッドチェーンとExpression Treeを活かしたモック生成は、なるほど、良さそうです。読み方も可愛いしね。もっきゅ。もっきゅ。</p>
<p>というわけでスルーして(えー)<a href="http://research.microsoft.com/en-us/projects/pex/">Moles</a>を使いましょう。Microsoft Research謹製のモックフレームワークです。PexとのセットはMSDN Subscriptionが必要ですが、MolesのみならばFreeです。VS Galleryに置かれているので、VSの拡張機能マネージャーからでも検索に引っかかります。</p>
<p>Moles。Pex and Molesとして、つまりPex(パラメータ自動生成テスト)のオマケですよねー、と考えていたりしたりした私ですが(実際、Pexがこの種のモックシステムを必要とする、という要請があって出来た副産物のよう)、これがオマケだなんてとんでもない！アセンブリ解析＋DLL自動生成＋ILジャックという、吹っ飛んだ発想による出鱈目すぎる魔法の力でモック生成してしまうMolesは、他のモックフレームワークとは根源的に違いすぎる。</p>
<p>Molesとは何か。既存のクラスの静的/インスタンスメソッドやプロパティの動作を、自由に置き換えるもの。既存のクラスとは、自分の作ったものは勿論、.NET Frameworkのクラスライブラリも例外ではありません。Console.WriteLineやDateTime.Now、File.ReadAllTextなども、そのままに乗っ取ることが可能です。PublicもPrivateも、どちらでも乗っ取れます。</p>
<p>しかも使うのは簡単。往々に強力なものは扱いも難しくなってしまうものですが、常識はずれに強力な魔法が働いている場合は、逆に非常に簡単になります。対象となるメソッドにラムダ式を代入する。それだけ。moqなどよりも遥かに簡単。</p>
<h2>Molesを使う</h2>
<p>日本語での紹介は<a href="http://d.hatena.ne.jp/jamzz/20100416/1271399591">Moles - .NETのモック・スタブフレームワーク - Jamzzの日々</a>に、また、<a href="http://research.microsoft.com/en-us/projects/pex/documentation.aspx">MSRのページのDocumentation</a>にLevel分けされた沢山のドキュメントが用意されているので(素晴らしい！Rxも見習うべし！)、そちらに目を通せば大体分かると思われます。</p>
<p>とりあえず使ってみましょう。Molesをインストールしたら、テストプロジェクトを作って、参照設定を右クリックし、Add Moles Assembly for mscorlibを選択。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/addmolesref.jpg">
</p>
<p>するとmscorlib.molesというファイル(中身はただのXML)が追加されます。そして、とりあえずビルドするとMicrosoft.Moles.Framework, mscorlib.Behavior, mscorlib.Molesが参照設定に追加されます。つまり、mscorlibが解析され、モッククラスが自動生成されました！mscorlib以外のものも生成したい場合は、参照設定の対象dll上で右クリックし、Add Moles Assemblyを選べば、.molesが追加されます。なお、解析対象が更新されてHoge.Molesも更新したい、という場合はリビルドすれば更新されます（逆に言えばリビルドしないと更新されないため、コンパイルは通るものの実行時エラーになります）。また、もし追加したことによって何かエラーが出る場合(VS2010 SP1で私の環境ではSystem.dllでエラーが発生する)は、.molesの対象アセンブリの属性にReflectionOnly=&quot;true&quot;も記載すると回避できることもあります。</p>
<p>では簡単な例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// mscorlibに含まれる型の場合のみ、Molesで乗っ取りたい型を定義しておく必要があります
// 定義なしで実行すると、この型定義してね、って例外メッセージが出るので
// それが出たらコピペってAssemblyInfo.csの下にでも書いておけばいいんぢゃないかな
[assembly: MoledType(typeof(System.DateTime))]

[TestClass]
public class UnitTest1
{
    // 現在時刻を元に&quot;午前&quot;か&quot;午後&quot;かを返すメソッド
    public static string ImaDocchi()
    {
        return (DateTime.Now.Hour &lt; 12) ? &quot;午前&quot; : &quot;午後&quot;;
    }

    // HostType(&quot;Moles&quot;)属性を付与する必要がある
    [TestMethod, HostType(&quot;Moles&quot;)]
    public void TestMethod1()
    {
        // ラムダ式で置き換えたいメソッドを定義する
        // プリフィックスMが自動生成されているクラス、
        // サフィックスGetはプロパティのgetの意味

        MDateTime.NowGet = () =&gt; new DateTime(2000, 1, 1, 5, 0, 0);
        ImaDocchi().Is(&quot;午前&quot;);

        MDateTime.NowGet = () =&gt; new DateTime(2000, 1, 1, 15, 0, 0);
        ImaDocchi().Is(&quot;午後&quot;);
    }
}
</code></pre>
<p>お約束ごと(属性付与)が若干ありますが、エラーメッセージで親切に教えてくれるので、そう手間もなくMoles化出来ます。モック定義自体は何よりも簡単で、見たとおり、デリゲートで置き換えるだけです。非常に直感的。(Isは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>利用のものでAssert.AreEqualです、この場合)</p>
<p>システム時刻に依存したメソッドのテストは、単体テストの書き方として、よく例に上がります。そのままじゃテスト出来ないのでリファクタリング対象行き。メソッドの引数に時刻を渡すようにするか、時刻取得を含んだインターフェイスを定義して、それを渡すとか、ともかく、共通するのは、外部から時刻を操れるようにすることでテスト可能性を確保する。ということ。</p>
<p>Molesを使えば、そもそもDateTime.Now自体をジャックして任意の値を返すように定義出来てしまいます。これは単純な例でしかないので、いくら出来てもそんなことやらねーよ、かもですね。はい。それが良い設計かどうかは別としても、Molesの存在を前提とすると、テスト可能にするための設計方法にも、かなりの変化が生じるのは間違いないでしょう。時に、テスト可能性のために歪んだ設計となることも、Molesで乗っ取れるのだと思えば、自然な設計が導出できるはず。</p>
<h2>イベントのモック化</h2>
<p>続けてイベントの乗っ取りも画策してみましょう。イベントの乗っ取りは、正直なところ少し面倒です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな非同期でダウンロードして結果を表示するメソッドがあるとして
public static void ShowGoogle()
{
    var client = new WebClient();
    client.DownloadStringCompleted += (sender, e) =&gt;
    {
        Console.WriteLine(e.Result);
    };
    client.DownloadStringAsync(new Uri(&quot;http://google.co.jp/&quot;));
}

[TestMethod, HostType(&quot;Moles&quot;)]
public void WebClientTest()
{
    // 外から発火出来るように外部にデリゲートを用意
    DownloadStringCompletedEventHandler handler = (s, e) =&gt; { };

    // AddHandlerとRemoveHandlerを乗っ取って↑のものに差し替えてしまう
    MWebClient.AllInstances.DownloadStringCompletedAddDownloadStringCompletedEventHandler =
        (wc, h) =&gt; handler += h;
    MWebClient.AllInstances.DownloadStringCompletedRemoveDownloadStringCompletedEventHandler =
        (wc, h) =&gt; handler -= h;

    // DownloadStringAsyncをトリガに用意したデリゲートを実行
    MWebClient.AllInstances.DownloadStringAsyncUri = (wc, uri) =&gt;
    {
        // DownloadStringCompletedEventArgsはコンストラクタがinternalなので↓じゃダメ
        // handler(wc, new DownloadStringCompletedEventArgs(&quot;google!modoki&quot;));
        // というわけで、モックインスタンス作ってしまってそれを渡せばいいぢゃない
        var mockArgs = new MDownloadStringCompletedEventArgs()
        {
            ResultGet = () =&gt; &quot;google!modoki&quot;
        };
        handler(wc, mockArgs);
    };

    // 出力はConsole.WriteLineなので、それを乗っ取って、結果にたいしてアサート
    MConsole.WriteLineString = s =&gt; s.Is(&quot;google!modoki&quot;);

    ShowGoogle(); // 準備が終わったので、実行(本来非同期だけど、全て同期的処理に置き換えられてます)
}
</code></pre>
<p>ちょっと複雑です。テストしたい処理はDownloadStringCompletedの中ですが、外からこれを発火する手段は、ない。この例だとAddHandlerだけ乗っ取って、直に発火させてもいいのですが、（非同期だけじゃなく）他のイベントの場合でも応用が効くように、正攻法（？）でいきましょう。イベントの発火を自分でコントロール出来るように、まずはAddとRemoveに対し、外部デリゲートに通すよう差し替えます。なお、インスタンスメソッドを乗っ取る場合は.AllInstancesの下にあるインスタンスメソッドを、静的メソッドと同じようにラムダ式で直に書き換えるだけです。非常に簡単。なお、第一引数は必ず、そのインスタンス自身となっていることには注意。</p>
<p>あとは、トリガとなるメソッドがあればそれを（この場合はDownloadStringAsync）通して、そうでない場合（例えばただのボタンクリックとか）なら直にイベントを乗っ取ったデリゲートを発火してやれば完了。で、ここでEventArgsがコンストラクタがprivateなせいで生成出来なかったりというケースも少なくないのですが、それはモックインスタンスを作って、そいつを渡してやるだけで簡単に回避できます。</p>
<p>少し手順が多いですが、「出来る」ということと、まあ流れ自体は分かるしそれぞれは置き換えるだけで複雑じゃない。ということは分かるのではと思います。でも、それでも面倒くさいですよ。ええ、どう見ても面倒くさいです。しかし、このことはReactive Extensionsを使えば解決出来ます。んが、その前にもう一つ別の例を。</p>
<h2>APMのモック化</h2>
<p>非同期繋がりで、APM(Asynchronous Programming Model, BeginXxx-EndXxx)のモック化もやってみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな非同期でダウンロードして結果を表示するメソッドがあるとして
public static void ShowBing()
{
    var req = WebRequest.Create(&quot;http://bing.co.jp/&quot;);
    req.BeginGetResponse(ar =&gt;
    {
        var res = req.EndGetResponse(ar);
        using (var stream = res.GetResponseStream())
        using (var sr = new StreamReader(stream))
        {
            var result = sr.ReadToEnd();
            Console.WriteLine(result);
        }
    }, null);
}

[TestMethod, HostType(&quot;Moles&quot;)]
public void WebRequestTest()
{
    // Beginでコールバックを呼ぶ、EndでWebResponseを返す
    MHttpWebRequest.AllInstances.BeginGetResponseAsyncCallbackObject =
        (req, ac, obj) =&gt; { ac(null); return null; };
    MHttpWebRequest.AllInstances.EndGetResponseIAsyncResult = (req, ar) =&gt;
    {
        return new MHttpWebResponse
        {
            GetResponseStream = () =&gt; new MemoryStream(Encoding.UTF8.GetBytes(&quot;bing!modoki&quot;))
        };
    };

    MConsole.WriteLineString = s =&gt; s.Is(&quot;bing!modoki&quot;);

    ShowBing(); // 実行
}
</code></pre>
<p>イベントよりは少し簡単ですが、BeginとEndの絡み具合は混乱してしまいます。また、HttpWebResponseのダミーを作るのも面倒。</p>
<h2>Reactive Extensions</h2>
<p>見てきたように、イベントもAPMも、モック化は面倒です。そこで出てくるのが<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>。RxならばIObservableとして一つにまとまるので、その一点をモック化してしまえばそれだけですむ、しかもダミーのIObservableを生成するのは非常に簡単！というわけで、例を見ましょう。モック化、の前に非同期のRx化と、そのテストを。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こっち本体

public class Tweet
{
    public string Name { get; set; }
    public string Text { get; set; }

    // 実際やるなら静的メソッドじゃなくて、API操作はまとめて別のクラスで、と思いますが、まあとりあえずこれで
    public static IObservable&lt;Tweet&gt; FromPublicTL()
    {
        var req = WebRequest.Create(&quot;http://twitter.com/statuses/public_timeline.xml&quot;);
        return Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
            .Select(r =&gt;
            {
                // StreamはSilverlightでも同期で書けるので、同期で取得しちゃいます
                using (var stream = r.GetResponseStream())
                using (var sr = new StreamReader(stream))
                {
                    return sr.ReadToEnd();
                }
            })
            .SelectMany(s =&gt; XElement.Parse(s).Elements()) // 配列上のものをバラして
            .Select(x =&gt; new Tweet // Tweetに変換
            {
                Text = x.Element(&quot;text&quot;).Value,
                Name = x.Element(&quot;user&quot;).Element(&quot;screen_name&quot;).Value
            });
    }
}

// こっちがTest

[TestMethod]
[Timeout(3000)] // Timeoutはテスト全体のオプションで設定してもいいね
public void FromPublicTL()
{
    var tl = Tweet.FromPublicTL().ToEnumerable().ToArray();

    // 20件あって、NameとかTextが
    // 全部空じゃなければ正常にParse出来てるんじゃないの、的な(適当)
    tl.Length.Is(20);
    tl.All(t =&gt; t.Name != &quot;&quot; &amp;&amp; t.Text != &quot;&quot;).Is(true);
}
</code></pre>
<p>Twitterのpublic_timeline.xml、つまり認証のかかってない世界中のパブリックなツイートが20件(オプション無しの場合)XMLで取れるAPIを叩いています。RxのFromAsyncPatternを使い、リクエストは非同期。非同期のテストは通常難しい、のですが、Rxの場合はFirstやToEnumerableで簡単にブロックして同期的なものに変換出来るため、それで結果を取って、何食わぬ顔でアサートしちゃえます。</p>
<p>Rxは非同期が簡単にテスト出来てメデタシメデタシ。これはこれで良いのですが、ところでパブリックじゃなくて認証入るものを取るときはどうするの？ストリーミングAPI(ツイートだけじゃなくFavoriteなど色々な形式のXMLが届く)を試したいけど、誰かがFavoriteつけるまで待機とか、テストに不定な時間がかかるものはどうするの？などなどで、本物のウェブ上のデータをテストで毎回取ってくるのは大変です。また、誤ったデータが流れてきた/サーバーが応答不能状態な場合などの例外処理のテストは、通常では出来ないですね？</p>
<p>そこで、モック。ウェブからじゃなくてモックがダミーのデータを返せばいいわけだ。そして改めてFromPublicTLメソッドを見ると「データ取得」と「データパース」の二つを行っている。なので、ここはその二つに分けて、後者の「データパース」がモックでテスト出来るようにしてやりましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Tweet
{
    public string Name { get; set; }
    public string Text { get; set; }

    private static IObservable&lt;String&gt; GetRawPublicTL()
    {
        var req = WebRequest.Create(&quot;http://twitter.com/statuses/public_timeline.xml&quot;);
        return Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
            .Select(r =&gt;
            {
                using (var stream = r.GetResponseStream())
                using (var sr = new StreamReader(stream))
                {
                    return sr.ReadToEnd();
                }
            });
    }

    public static IObservable&lt;Tweet&gt; FromPublicTL()
    {
        return GetRawPublicTL()
            .SelectMany(s =&gt; XElement.Parse(s).Elements())
            .Select(x =&gt; new Tweet
            {
                Text = x.Element(&quot;text&quot;).Value,
                Name = x.Element(&quot;user&quot;).Element(&quot;screen_name&quot;).Value
            });
    }
}
</code></pre>
<p>リファクタリングというほど大仰なものでもなく、メソッドチェーンのうちのネットワークアクセス部分をprivateメソッドとして切り出しただけです。Rxは、メソッドチェーンの一つ一つが独立しているので、切った貼ったが簡単なのもメリット。では、このprivateメソッドをMolesで差し替えてしまおう！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod, HostType(&quot;Moles&quot;)]
public void FromPublicTLMock()
{
    // これは省略した文字列ですが、実際は取得したXMLをファイルに置いて、それを読み込むといいかも
    var statuses = @&quot;
        &lt;statuses&gt;
            &lt;status&gt;
                &lt;text&gt;Hello&lt;/text&gt;
                &lt;user&gt;
                    &lt;screen_name&gt;neuecc&lt;/screen_name&gt;
                &lt;/user&gt;
            &lt;/status&gt;
            &lt;status&gt;
                &lt;text&gt;Moles&lt;/text&gt;
                &lt;user&gt;
                    &lt;screen_name&gt;xbox99&lt;/screen_name&gt;
                &lt;/user&gt;
            &lt;/status&gt;
        &lt;/statuses&gt;
        &quot;;

    // 本来ネットワーク取得のものを、たった一行でただのシーケンスに置き換える
    MTweet.GetRawPublicTL = () =&gt; Observable.Return&lt;string&gt;(statuses);

    var tl = Tweet.FromPublicTL().ToEnumerable().ToArray();

    tl.Length.Is(2);
    tl[0].Is(t =&gt; t.Name == &quot;neuecc&quot; &amp;&amp; t.Text == &quot;Hello&quot;);
    tl[1].Is(t =&gt; t.Name == &quot;xbox99&quot; &amp;&amp; t.Text == &quot;Moles&quot;);
}
</code></pre>
<p>これだけです。データ用意は別として、モックへの差し替えはたった一行書いただけ。既存のコードに一切手を加えず、こんなにも簡単にモックへの置き換えが可能だなんて、わけがわからないよ。</p>
<p>理由として、Rxの持つ非同期もイベントも普通のシーケンスも、全て等しく同じ基盤に乗っている、という性質が生きています。この性質は時に分かりづらさを生むこともありますが、しかしそれ故に絶大な柔軟性も持っていて、その結果、本来非同期処理のものをただのシーケンスに置き換えることを可能にしています。非同期が、イベントがテストしづらいならMolesでただのシーケンスに差し替えてしまえばいい。別段「テストのため」の設計を意識しなくても、Rxで書くということ、それだけで自然にテスト可能な状態になっています。</p>
<p>なんて、さらっと流してしまっているわけですが、この事に気づいた瞬間にこれはヤバい！と悶えました。いや、凄いよ、凄過ぎるよRx + Moles。</p>
<h2>Moq vs Moles、あるいは検証のやり方</h2>
<p>Molesは非常に強力ですが、ではMoqと、どう使いわけよう？もしくは、全て代替出来てしまう？Molesは純粋な置き換えのみなので、呼び出しの検証はありません。モックとスタブの用語の違い、を言うならば、Molesの提供するものはモックではなくスタブ。自動生成クラスにつくプリフィックスのSは勿論Stubですが、MはMockではなく、Moleを指します(じゃあMoleって何よ、っていうと、何なんでしょうね……)</p>
<p>さて、使い分けとかいうほどのものでもないので、基本はMolesのみでいいんじゃないかなあー。もし呼び出しを保証したければ、こういうふうに書ける。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IDisposableのDisposeは1回しか呼ばれないとしたい場合を検証する
// インターフェイスの場合はMHogeではなくSHogeなことに注意
var callCount = 0;
var mock = new SIDisposable()
{
    Dispose = () =&gt; { callCount += 1; }
};

(mock as IDisposable).Dispose(); // mockを使った処理があるとする...
callCount.Is(1); // 1回のみ
</code></pre>
<p>フレームワークに用意されていないから一手間なのは事実ですが、Molesの持つシンプルさを失ってまで足したいほどでもなく、好きなようなチェックを自前で書けるのだから、それでいいかな。むしろこのほうが大抵スッキリ。といったようなことは、MolesのマニュアルのComparison to Existing Frameworksに書かれています。Molesの提供するシンプルさが、私は好きです。</p>
<p>フレームワークは最大限のシンプルさを保って、機能は他の機構に回すというのは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>も一緒ですよ←比較するとはなんておこがましい</p>
<p>もう一つ、もっと具体的なもので行きましょうか。LinqのCount()はICollectionの場合は全部列挙せず、Countプロパティのほうを使ってくれる(詳細は過去記事：<a href="http://neue.cc/2009/07/21_178.html" title="neue cc - LinqとCountの効率">LinqとCountの効率</a>をどうぞ)ことのテスト。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var countCalled = false;
var enumeratorCalled = false;
var mock = new SICollection01&lt;int&gt;
{
    CountGet = () =&gt; { countCalled = true; return 100; },
    GetEnumerator = () =&gt; { enumeratorCalled = true; return null; }
};

// 呼んでるのはLinqのCount()のほうね
mock.Count().Is(100);
countCalled.Is(true);
enumeratorCalled.Is(false);
</code></pre>
<p>CountGetで100返せば、それだけでいい気もしますが、念のため+意図を表明するということで。</p>
<p>そういえばですが、Chaining AssertionのIsは、散々DisったAssertThatに存外近かったりします。 Assert.That(actual, Is(expected)) と書くものを、 actual.Is(expected) と書けるようになった、ですから(但しこれはAreEqualsの場合であって、Shuold.Be.GreaterThanとかやり始めたらぶん殴る)。</p>
<h2>Silverlight? Windows Phone 7?</h2>
<p>Silverlightのテスト環境は貧弱です。当然それに連なってWP7のテスト環境も貧弱です。というかMSTestが使えない！というだけじゃなく、Molesも動かせませんし。どうする？そこは、「リンクとして追加」でSilverlight/WP7のファイルをWPFのプロジェクトにでも移して、そのWPFのコードをテストするという手段が取れなくもないです。非同期周りはRxが吸収出来るし、互換性は、元来クラス群が貧弱なSLのほうが第一ターゲットなので、まあまあ大丈夫なはず。ViewModelはともかくとして、Modelのテストなら行けるはずです。</p>
<p>非同期のテストは難しいって？うん、Rxを使えば簡単なんだ。大丈夫。</p>
<h2>まとめ</h2>
<p>次世代というか、もう現世代なんですよ。今まで理想論に過ぎなかったものを、急速に現実のものとしてくれています。徒手空拳では難しい領域はいっぱいあった。でも、今、手元にはRxとMolesがある。この二つを手に、もう一度領域を見てみたらどうだろう？晴れた景色が広がっているはずです。</p>
<p>それにしてもRxの素晴らしさがMolesで更に輝くことといったらない。</p>
<p>今回はRxと組み合わせた例を中心に説明しましたが、Molesは単体でも文句なく素晴らしい。Moqも悪くないけれど、選ぶならMolesです。とにかく抜群に使いやすい。機能が極まっていることと、APIのシンプルさは両立するんだって。自動生成を活かしきった事例ですねー。VSとのシームレスな一体化といい、文句のつけようがない。ついこないだまで軽視していた私が言うのもアレですが、これがそんなに知られていない(少なくともググッて引っかかる記事はid:jamzzさんの記事だけだ)のは勿体無い話。<a href="http://research.microsoft.com/en-us/projects/pex/">Moles</a>、是非試してみてください。</p>
</div>
<a href="https://neue.cc/17">Prev |</a>
<a href="https://neue.cc/19">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
