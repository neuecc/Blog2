<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2020-12</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-twilight.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2020/12/30_598.html">2020年を振り返る</a></h1>
<ul class="date"><li>2020-12-30</li></ul>
<div class="entry_body"><p>今年は前半が絶好調で、<a href="http://neue.cc/2020/01/09_588.html">ConsoleAppFramework</a>、<a href="http://neue.cc/2020/01/30_590.html">ProcessX</a>、<a href="https://tech.cygames.co.jp/archives/3383/">ZString</a>、<a href="https://tech.cygames.co.jp/archives/3401/">ZLogger</a>、そして<a href="https://tech.cygames.co.jp/archives/3417/">UniTask v2</a>と、凄い勢いでプログラミング的なクリエイティビティを発揮できていました。なので今年トータルとしてみれば良かったと言えます。</p>
<p>が、後半が絶不調で無。とにかく無。なんでこんな無になったのか分からないほどに無。コロナか、コロナが悪いんか。それも実際あるんですが、いや、というかそれが全てかなー。リモートワーク向いてないんすよー、みたいな。リモート前半で魂の貯金を使い切った。無が加速してからヤバいと思って自主リモート返納（自分だけオフィスワーク）に戻したんですが、それでもなんか違うんですよねえ。まぁ、言い訳なんですけどね！新環境に適応できない旧世代民には死あるのみ、って感じなので、来年は脳みそ入れ替えてやってきたいと思います。</p>
<p>この12月は、書く予定だったアドベントカレンダーも書けずにフィニッシュと最悪な感じですからねえ、終わりが全くしまらなかった結果、今年の印象としてはあんま良くない。でも客観的に一年通しで見たら、中々の成果を上げたとは言えます。</p>
<p>OSSがかなり出揃ったことで、<a href="https://cysharp.co.jp/">Cysharp</a>という会社の輪郭をはっきりさせられた年になりました。対外的には何やってる会社か分からない、まぁ実際そこは今もよくわからないと思うんですが、それでもC#の最先端を突っ走っている会社だというイメージは確固たるものになったのではないでしょうか。去年ではまだまだ足りてないと考えていたのですが、今年追加したOSS群によって、一つポジションを引き上げられたと思っています。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>もv4になって .NET 5/Pure C# gRPC 対応を果たしましたし、今年は実際に採用しているアプリケーションがリリースされていったことで、よりCysharpの目指しているヴィジョンの現実感が出てきました。来年はそのヴィジョンをより鮮明にしていくことと、もうプラスαに仕込んでいるものがあるので、その辺の露出がうまくできるといいかなーと思ってます。</p>
<p>私個人の能力の成長という点でも、UniTask v2を始めとしてパワーある実装をやりきったことと、そこから深く学んだこともいっぱいあるので、まだまだ行けるぞという感じです。ちゃんとね、毎年成長してますよ。はい。人間、停滞＝衰退ですから。</p>
<p>私は出したもののウケ度に割と拘るところがあるんですが、これは自分の感覚と市場の感覚が乖離していないかを測っているという面もあります。今日が誕生日でもうN回この振り返りも書いてるわけですが、そろそろ油断すると感性が腐る頃合いなんですよね。なんかピンとのズレたことを言い始めてしまうという。端的に言えばそれが老害というわけなんですが、自分も油断するとなりかねない。という危機感がそぞろ出てくるような頃合いでして。しかもね、そういうのは自覚がないわけですよ、本人は自覚がない！本人はイケてると思っているのが余計辛い！自覚がないからこそ老害なのだ。みたいなところがある。</p>
<p>と、いうわけで、客観的な指標が必要で、とりあえず今年はOKじゃないですかね。はい。</p>
<h2>その他文化</h2>
<p>今年のGame of the Yearは<a href="https://bethesda.net/ja/game/doom">DOOM Eternal</a>ですよね……！震えるほど面白いゲームって本当に数年単位で久々で、腐った感性を復活させてくれた神の救いですよ。というわけでマストバイ。（しかし超期待したDLCは微妙だった……）</p>
<p>今年のベストアルバムは中村佳穂のAINOUです。<a href="https://mikiki.tokyo.jp/articles/-/19940">中村佳穂『AINOU』はなぜ2018年を代表する名盤なのか?</a>とかって記事出てるように全然今年のアルバムじゃないんですが、聴いたのは今年だからshoganai。名盤。</p>
<p>読み物としては、ちょくちょく<a href="https://www.shibatashoten.co.jp/magazine.php?cid=3">月刊専門料理</a>を買ってて、これが面白いんですよね。料理とエンジニアリングは共通するものがあると<a href="https://www.oreilly.co.jp/books/9784873117874/">Cooking for Geeks</a>をはじめとしてよく言われるやつですが、それプラス経営的な話とかも中々身に沁みるものがあって良いわけです。あと、料理業界はまだまだ多分アナログなんですよね、だから紙の雑誌にも相応の密度がある。その点エンジニアの場合はウェブ媒体のほうが紙より良い状態なので、雑誌が面白くないんですよね（Web+DBとかもはやつまらんでしょ）。良くも悪くもですが、まぁもう進んでしまった業界は紙の媒体が面白くなることはないのでしょう。</p>
<h2>来年</h2>
<p>アドベントカレンダーネタは書いてないしGitHub Issuesもかなり手を付けてないのが残っちゃったしで、あんまりスッキリして来年を迎えられないんですが……！そのへんはなるはやですっきりさせたいとして、今年はCysharpの仕込みフェーズがとてもうまくいった。実際うまくいった。そして仕込みフェーズは終了。つまり来年はどーんといきましょう。というわけで、ぜひぜひ大躍進にご期待くださいな。</p>
</div>
<h1><a href="https://neue.cc/2020/12/15_597.html">UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips</a></h1>
<ul class="date"><li>2020-12-15</li></ul>
<div class="entry_body"><p>ValueObjectは好きですか？私は大嫌いです。いじょ。</p>
<p>ざっくり言えばプリミティブ型に専用の型を付ける教義です。例えばUserIdをintとして扱っているとTeamIdと取り違えるかもしれないし、Hpに突っ込んでしまうかもしれない。StrengthとIntelligenceとAgilityとSpeedは別物なのだから全部intじゃなくて区別して欲しい、そうじゃないと間違った演算しちゃうぞ、と。まぁそういう自体を避けるために、それぞれラップした個別型を作るのです。int strengthじゃなくてStrength strengthだぞ、と。</p>
<p>これは一見正しく実際正しいのですが、問題もあります。一つに面倒くさい。ラップしたctorを作るのだけでも定形でウザ、と思いますが、更に等値とか実装するのは面倒くさい。また、そのままだと計算できなくなるので、算術演算のために生の値を<code>.Value</code>で取り出す、が頻出すると安全度も下がるし見た目もめっちゃ汚くなる、当然ながらものすごく書きづらい。そしてシリアライゼーションの問題。Serialize(userId)としたときに「{ &quot;Value&quot; = 100 }」なんて形にシリアライズされたら最低で、全く許容できない。また、データベースで扱うときにもORMはそのままだとプリミティブしか扱えないので、マッピングできなくて不便なことになります。</p>
<p>といった問題があるため、基本的には大嫌いなのでそういうのやらない、プリミティブで何が悪いんだボケ。ぐらいの勢いでした。実際、社内でそうしたい、という話があった場合にはトップダウン権限で却下してたぐらいです（横暴！）。のですが、上記の問題が解決するのならば、全然許せます。むしろ良い。むしろすべき。かもしれません。</p>
<p>そこで C# 9.0 から新搭載されたSourceGeneratorの出番です。SourceGeneratorを活用したUnitGeneratorというライブラリを新しく作りました。今回はその内容の解説と、SourceGeneratorを実装する上でのTipsを紹介します。また、この記事は <a href="https://qiita.com/advent-calendar/2020/csharplang2">C# その2 Advent Calendar 2020</a> 15日用です。19日にも<a href="https://qiita.com/advent-calendar/2020/csharplang">C# Advent Calendar 2020</a>でSourceGeneratorネタを書く予定なので、まずはPart 1ということで合わせてお楽しみください。</p>
<p>ちなみにC# Advent Calendar 2020の初日の記事 <a href="https://qiita.com/RyotaMurohoshi/items/83775cf4ed1ce4f6378d">C# 9.0で加わったC# Source Generatorと、それで作ったValueObjectGeneratorの紹介</a> と内容的には非常に似通ってるんですが、そこはshoganai。また<a href="https://qiita.com/pierusan2010/items/d66b835240af30955da6">C#9.0 SourceGeneratorでReadonly構造体を生成するGeneratorを作ってみました。</a>とも被ってますね、しょーがしょーがない。</p>
<h2>SourceGeneratorの特性</h2>
<p>GitHubとNuGetに<code>UnitGenerator</code>として公開しました（この記事でも後で触れますが、ReadMe末尾にはUnityでの使い方も載せてあります）。</p>
<ul>
<li><a href="https://github.com/Cysharp/UnitGenerator">Cysharp/UnitGenerator</a></li>
</ul>
<p>使い方は、<code>public readonly partial struct</code>に対して、<code>[UnitOf(typeof(T))]</code>を書くだけです。</p>
<pre><code class="language-csharp">using UnitGenerator;

[UnitOf(typeof(int))]
public readonly partial struct UserId { }
</code></pre>
<p>これを書くと、SourceGeneratorが裏側で以下のpartial classをコンパイル時（ビルド前）に生成します。</p>
<pre><code class="language-csharp">[System.ComponentModel.TypeConverter(typeof(UserIdTypeConverter))]
public readonly partial struct UserId : IEquatable&lt;UserId&gt; 
{
    readonly int value;
    
    public UserId(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(UserId value) =&gt; value.value;
    public static explicit operator UserId(int value) =&gt; new UserId(value);
    public bool Equals(UserId other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;UserId(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in UserId x, in UserId y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in UserId x, in UserId y) =&gt; !x.value.Equals(y.value);

    private class UserIdTypeConverter : System.ComponentModel.TypeConverter
    {
        // snip...
    }
}
</code></pre>
<p>SourceGeneratorのいいところは、生成コードがC#コンパイラのメモリ内で完結していることです。つまり、ファイルが出てきません。ファイルが出てこないのは非常にいいことで、自動生成ファイルが減った時の管理をしなくてすみます。ディレクトリごと毎回Cleanするのもイマイチですし、かといって古いファイルが残り続けるのはマズいので、そこの管理をどうするか問題は毎度面倒くさいことです。</p>
<p>欠点はメモリ内で完結していることです。ソースが見えないとデバッガビリティも下がりますし、コンパイルしないと追加されたコードが使えないというのもコード書いてる最中の手触り的に面倒。というのが一般的な話なのですが、そこを言語組み込みの機能として用意したことでカバーしているのがSourceGeneratorの良いところです。まず、デバッガビリティに関してはIDE(Visual Studioなど)でコードジャンプできるようになっているし、デバッガのステップ実行もフルサポート。また、IDEのインクリメンタルコンパイルとフルに連動しているため、属性を書いた瞬間から、裏ではそこの部分だけコンパイルが走ってコードが生成されて、生成コードが利用可能になっています。これは今までのビルド時プリプロセッサー/ポストプロセッサーではできなかった体験で、中々小気味良いものです。</p>
<p>唯一の欠点は既存コードをEditできないので、partialであることが必須になることと、編集を要求する内容は作れないことでしょうか。まぁ、それは従来あったAnalyzer(CodeFixProvider)でやればいいということで、それなりに棲み分けもできてますし、ソースコードの追加しかできないという仕様のお陰で、作成に関してはかなりシンプルになったこともいいことです。</p>
<h2>UnitGenerateOptions</h2>
<p>値の等値性だけを実装するのはままあるのですが、それだけだと不便なんですよね。例えばHpは + 100 とかそのまま演算したいじゃん、と。その辺のサポートがないとすぐに.Valueで生の値を取り出すことになって
よくないし、MinやMaxなんかもそのまんま使いたい、例えばHpを現在値の2倍で回復する、みたいなのは <code>target.Hp = Hp.Min(target.Hp * 2, target.MaxHp)</code> と書けたるとかなり自然でいいよね、と。</p>
<p>その辺の生成をサポートするのが UnitGenerateOptions で、これを組み合わせることによって、算術演算子など好きなメソッドが追加されます。UserIdのようなものは算術演算子が生成されては困るので抑制したいし、Hpはフルで生成したい、みたいな使い分けができます。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Hp { }

// -- generates

[System.ComponentModel.TypeConverter(typeof(HpTypeConverter))]
public readonly partial struct Hp : IEquatable&lt;Hp&gt; , IComparable&lt;Hp&gt;
{
    readonly int value;

    public Hp(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(Hp value) =&gt; value.value;
    public static explicit operator Hp(int value) =&gt; new Hp(value);
    public bool Equals(Hp other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;Hp(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in Hp x, in Hp y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in Hp x, in Hp y) =&gt; !x.value.Equals(y.value);
    private class HpTypeConverter : System.ComponentModel.TypeConverter { /* snip... */ }

    // UnitGenerateOptions.ArithmeticOperator
    public static Hp operator +(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value + y.value)));
    public static Hp operator -(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value - y.value)));
    public static Hp operator *(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value * y.value)));
    public static Hp operator /(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value / y.value)));

    // UnitGenerateOptions.ValueArithmeticOperator
    public static Hp operator ++(in Hp x) =&gt; new Hp(checked((int)(x.value + 1)));
    public static Hp operator --(in Hp x) =&gt; new Hp(checked((int)(x.value - 1)));
    public static Hp operator +(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value + y)));
    public static Hp operator -(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value - y)));
    public static Hp operator *(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value * y)));
    public static Hp operator /(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value / y)));

    // UnitGenerateOptions.Comparable
    public int CompareTo(Hp other) =&gt; value.CompareTo(other);
    public static bool operator &gt;(in Hp x, in Hp y) =&gt; x.value &gt; y.value;
    public static bool operator &lt;(in Hp x, in Hp y) =&gt; x.value &lt; y.value;
    public static bool operator &gt;=(in Hp x, in Hp y) =&gt; x.value &gt;= y.value;
    public static bool operator &lt;=(in Hp x, in Hp y) =&gt; x.value &lt;= y.value;

    // UnitGenerateOptions.MinMaxMethod
    public static Hp Min(Hp x, Hp y) =&gt; new Hp(Math.Min(x.value, y.value));
    public static Hp Max(Hp x, Hp y) =&gt; new Hp(Math.Max(x.value, y.value));
}
</code></pre>
<p>この辺のメソッドがしっかり生成されることによって、プリミティブ型をそのまま使うのと遜色のない使用感が担保できるわけです。</p>
<pre><code class="language-csharp">if (character.Hp &lt;= 0) // Hp.GetType == typeof(Hp)
{
    // is dead.
}
</code></pre>
<p>みたいに書けるようになってとても嬉しい。</p>
<p>また、演算子のオーバーロードはしっかり考慮して作るのが地味に大変な代物なので、そこをちゃんとやってくれるのも助かりです。例えばboolの場合はtrue演算子を自動実装します。</p>
<pre><code class="language-csharp">public static bool operator true(Foo x) =&gt; x.value;
public static bool operator false(Foo x) =&gt; !x.value;
public static bool operator !(Foo x) =&gt; !x.value;
</code></pre>
<p>こんなの自分で実装する機会なんてほとんどないと思いますが、これによってifに直接突っ込めるようになります。</p>
<pre><code class="language-csharp">if (foo) // foo.GetType() == typeof(Foo)
{
}
</code></pre>
<p>UnitGenerateOptionsは現在のところ以下のオプションを提供しています。</p>
<pre><code class="language-csharp">[Flags]
internal enum UnitGenerateOptions
{
    None = 0,
    ImplicitOperator = 1,
    ParseMethod = 2,
    MinMaxMethod = 4,
    ArithmeticOperator = 8,
    ValueArithmeticOperator = 16,
    Comparable = 32,
    Validate = 64,
    JsonConverter = 128,
    MessagePackFormatter = 256,
    DapperTypeHandler = 512,
    EntityFrameworkValueConverter = 1024,
}
</code></pre>
<p>例えば以下のように指定できます。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Strength { }

[UnitOf(typeof(DateTime), UnitGenerateOptions.ParseMethod | UnitGenerateOptions.Comparable)]
public readonly partial struct EndDate { }

[UnitOf(typeof(string), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct Message { }

[UnitOf(typeof(byte[]))]
public readonly partial struct Image { }

[UnitOf(typeof((string street, string city)), UnitGenerateOptions.Validate)]
public readonly partial struct StreetAddress
{
    private partial void Validate()
    {
        if (!DataMaster.Contains(value.street)) throw new Exception(&quot;Invalid Street: &quot; + value.street);
        if (!DataMaster.Contains(value.city)) throw new Exception(&quot;Invalid City: &quot; + value.city);
    }   
}
</code></pre>
<p>Validateだけ少し特殊で、自動生成側のコードが<code>partial void Validate()</code>メソッドを生成して、自動生成されるコンストラクタでそれを呼ぶようになっています。Validateの実体をユーザー側が書けばOKということですね。プリミティブ型と違って、値が検証済みであることが保証されている、というのも一般的なプラクティスとしては重要な話です。（ただしstructのため、default(T)は防げないので、そういう意味では完全なValidationではありません）</p>
<h2>シリアライザの自動実装</h2>
<p>繰り返しますが 「{ &quot;Value&quot; = 100 }」みたいにシリアライズされるのは最低です。「100」とシリアライズされなければならない。と、いうわけで、そういう場合は専用のシリアライザを実装すれば回避できます。現状はSystem.Text.JsonのJsonConverterとMessagePack用のMessagePackFormatterを自動実装するオプションが用意されています。こういうのをちまちま用意するのは、私がシリアライザについて人一倍拘りがあるからで、普通はあんまないでしょうね。でもシリアライザはシステムにおいて本当に大事なことだから！</p>
<p>例えば <code>UnitGenerateOptions.MessagePackFormatter</code> は以下のようなコードを自動実装します。</p>
<pre><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct UserId { }

// -- generates

[MessagePackFormatter(typeof(UserIdMessagePackFormatter))]
public readonly partial struct UserId 
{
    class UserIdMessagePackFormatter : IMessagePackFormatter&lt;UserId&gt;
    {
        public void Serialize(ref MessagePackWriter writer, UserId value, MessagePackSerializerOptions options)
        {
            options.Resolver.GetFormatterWithVerify&lt;int&gt;().Serialize(ref writer, value.value, options);
        }

        public UserId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new UserId(options.Resolver.GetFormatterWithVerify&lt;int&gt;().Deserialize(ref reader, options));
        }
    }
}
</code></pre>
<p>private classでFormatterが実装されるのがポイントで、Attributeからそのフォーマッターを取り出すことで、外部のResolverへの登録をせずに専用の対応をしています。Serialize/DeserializeはResolver経由じゃなくて直接Writer/Readerのプリミティブ型を呼ぶことで高速化できますが、まぁそれは次の機会に。このコードを発展化させた、MessagePack for C#におけるSourceGenerator対応については12/19の記事で詳しく触れる予定です。</p>
<p>データベースに関しても UnitGenerateOptions.DapperTypeHandler, UnitGenerateOptions.EntityFrameworkValueConverter でDapperとEF Coreの対応コードを生成します。ただしこちらは自動利用のシステムがないので、手動で取り出して登録する必要があります。</p>
<h2>.Value is dead</h2>
<p>UnitGeneratorはpublicプロパティを一つも生成しません。つまり、.Valueはありません。私は.Valueによる値の取り出しが悪いプラクティスだと思っていて、カジュアルに使おうという気持ちを起こさないようにしています。演算子の生成なども用意してあるし、あとは専用のメソッドを自前で書いたりしていくなどで解決できるといいよね、と。</p>
<p>とはいえさすがに取り出せないのは不便というか実用的ではないので、<code>.AsPrimitive()</code> で取れます。プロパティではなくメソッドというだけで、心理的に少し抵抗感出るんじゃないでしょうか？制約なんてそのぐらいでいいでしょう。あんまりキツくやるのも好きではないので。</p>
<h2>Unityで使う</h2>
<p>Source Generatorは C# 9.0 の機能です。というわけで、2020年現在のUnityはどのバージョンもそれをサポートしていません。じゃあ使えないじゃんって話なのですが、幸いファイルとして生成する機能も用意されているので、外部コマンドを実行したら自動生成する、ぐらいの雰囲気でならUnityでも使うことができます。</p>
<p>まずはコンフィグとなるcsprojを用意します。例えばUnitSourceGen.csprojとして、以下のような内容のものを作ります。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;

        &lt;!-- add this two lines and configure output path --&gt;
        &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
        &lt;CompilerGeneratedFilesOutputPath&gt;$(ProjectDir)..\Generated&lt;/CompilerGeneratedFilesOutputPath&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;!-- reference UnitGenerator --&gt;
        &lt;PackageReference Include=&quot;UnitGenerator&quot; Version=&quot;1.0.0&quot; /&gt;

        &lt;!-- add target sources path from Unity --&gt;
        &lt;Compile Include=&quot;..\MyUnity\Assets\Scripts\Models\**\*.cs&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとは <a href="https://dotnet.microsoft.com/download">.NET SDK</a>を入れて、コマンドを叩きましょう。</p>
<pre><code>dotnet build UnitSourceGen.csproj
</code></pre>
<p>これで UnitGenerator\UnitGenerator.SourceGenerator*.Generated.cs がOutputPathに指定したところに生成されています。UnitGeneratorは、UnitOfAttributeやUnitGenerateOptionsも自動生成コードの中に含まれる仕様（ランタイムレス）なので、一回空の状態で実行すれば、それらのコードが生成されて利用可能になります。</p>
<h2>SourceGenerator実装の方法</h2>
<p>netstandard2.0のライブラリプロジェクトとして（いまのところnet5.0だとうまくいかない、これはVisual Studioが .NET Frameworkで動いているせいだから、らしい）Microsoft.CodeAnalysis.CSharpを参照します。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; PrivateAssets=&quot;all&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>また、合わせてテスト用のプロジェクトを用意して、ライブラリプロジェクトを参照するようにしておくといいでしょう。プロジェクト参照を、OutputItemType=&quot;Analyzer&quot;にしておきます。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;ProjectReference Include=&quot;..\..\src\UnitGenerator\UnitGenerator.csproj&quot;
                          OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとはISourceGeneratorを実装するだけ。</p>
<pre><code class="language-csharp">[Generator]
public class SourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            // System.Diagnostics.Debugger.Launch();
        }
#endif 

        context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
    }

    // 実装しなくてもいいけど、この段階で対象になるファイルを引っ掛けておくとワンパスで処理できる
    class SyntaxReceiver : ISyntaxReceiver
    {
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
        }
    }
}
</code></pre>
<p>System.Diagnostics.Debugger.Launch() を入れておくと、デバッガでアタッチできて実装が捗ります。ただしVisual Studioがインクリメンタルコンパイル的にかなりの頻度でキックしてくるので、不要なときはコメントアウトしておくのが吉。また、SourceGeneratorの実装コードの変更にたいしてVisual Studioのキャッシュがうまく追随してくれなくて、実装中は挙動が腐ることがよくあるので、困ったときの再起動でやり過ごしましょう。</p>
<p>RegisterForSyntaxNotificationsは使っても使わなくてもどちらでもいいのですが(ExecuteのところでSyntaxTreeの全てが手に入るので探索し放題)、ここで大雑把でも引っ掛けておいたほうが、その後の処理が軽量になるので、使ったほうが基本的にはヨシ。</p>
<p>SourceGeneratorでユーザーが使う属性は、参照DLL内に含めておいてそれを使う場合と、参照DLLは完全に空にして、ソースジェネレーター自身が生成するパターンがあります。後者のパターンを使うと、ソースジェネレーターのためだけに参照DLLが増えることを避けれるので、今回のUnitGeneratorのような、生成コードが全ての処理を行うタイプのものは、そちらのパターンを使ったほうが良いでしょう。</p>
<p>やりかたは単純に最初に必要な属性を突っ込んでしまうという、ただそれだけなのですが一点注意なのは、この生成は絶対死守しましょう。Execute内で例外が発生したりすると、ここでAddSourceした属性の追加はキャンセルされます。</p>
<pre><code class="language-csharp">public void Execute(GeneratorExecutionContext context)
{
    context.AddSource(&quot;UnitOfAttribute.cs&quot;, &quot;internal class UnitOfAttribute...);

    try
    {
        // manipulate syntax...
    }
    catch (Exception ex)
    {
        System.Diagnostics.Trace.WriteLine(ex.ToString());
    }
}
</code></pre>
<p>特にIDEのインクリメンタルコンパイルが稼働している状態だと、入力途中の「不完全なコード」が頻繁に飛んできます。こうした不完全なコードによる不正な構文木を正しくハンドリングするのはかなり難しく、例外を飛ばしてしまうのは正直避けられません。しかし、何があっても最初に生成する属性のAddSourceだけは維持しないと、「入力途中の不完全コード→例外発生で属性が吹っ飛ぶ→属性が吹っ飛ぶので入力補完が効かないどころか書いてるものが全てエラーになる」という負のループが発生します。なので、これに関してはtry-catchで握り潰しOKです。</p>
<p>コード生成のためのテンプレートですが、サンプルだとみんなstring interpolationでさっくり処理してますが、やめときましょう。複雑なコードを生成しようとすると破綻するので、よほど単純な生成じゃないならちゃんとテンプレートエンジン使いましょう。</p>
<p>じゃあ何を使えばいいのか、というとT4 Templateです。以前に<a href="http://neue.cc/2019/12/06_585.html">.NET Core時代のT4によるC#のテキストテンプレート術</a>という記事を書いたので、それを読んでくださいな。これの「実行時テキスト生成(TextTemplatingFilePreprocessor)」を使います。具体的なUnitGeneratorのテンプレートは<a href="https://github.com/Cysharp/UnitGenerator/blob/939e6d54d68dbb102d2986de5fe442b8780d4216/src/UnitGenerator/CodeTemplate.tt">UnitGenerator/CodeTemplate.tt</a>にあるので参考にどうぞ。ただたんにOptionによってifがちょろちょろある程度ですが、それでもこれをstring interpolationとStringBuilderで処理するのは無理があります。</p>
<p>ユニットテストに関しては <code>CSharpGeneratorDriver</code> というものが用意されているので、それで小さいCompilationを作って渡せばOK。ってどういうこっちゃという感じですが、<a href="https://gist.github.com/chsienki/2955ed9336d7eb22bcb246840bfeb05c">chsienki/GeneratorTests.cs</a>のコードをまんま使えばOKですね。中身は単純です。</p>
<pre><code class="language-csharp">var comp = CreateCompilation(/* ソースジェネレーターの対象コード */);
var newComp = RunGenerators(comp, out var generatorDiags, new SimpleGenerator());

// あとはnewCompから生成コードを引っ張ってきて、それが意図通りの正しさかどうか見たり
Assert.Empty(newComp.GetDiagnostics()); // エラーなくちゃんと生成できてるかどうか
</code></pre>
<p>ただし、参照DLLを増やすと面倒くさい挙動したり、そもそも生成されたコードの挙動が正しいかどうかを見たい(UnitGeneratorでいうと算術演算子が正しいかとか、シリアライザの実装が正しいかとか）ほうが多いんじゃないかなーと思うので、普通にユニットテストプロジェクトにSourceGenerator参照して、それが生成されたコードを動かして普通にAssert書く、みたいなのでいいかな。私は実際そんなわけで、CSharpGeneratorDriver経由のテストはやめました。（というかそもそも普通のユニットテストもたいして書いてない説はある）</p>
<p>最後にNuGetへのパブリッシュについて。SourceGeneratorはAnalyerとして登録したいので、ひと手間いります。具体的には以下のように処理します。</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
    &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
    &lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
&lt;/PropertyGroup&gt;

&lt;ItemGroup&gt;
    &lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>IncludeBuildOutputで、自身のDLLを参照用として含めないようにします、これは前述の「参照DLLは完全に空にして、ソースジェネレーター自身が必要な属性を生成するパターン」を使う場合には自身の参照は不要だからですね。SuppressDependenciesWhenPackingは、これ設定しとかないとpack時に空なんだけど、という警告が出てくるので黙らせます。空なのは知っとるがな。</p>
<p>Analyzerとしてpackするにはanalyzers/dotnet/cs以下に配置すればいいだけ、ということで、そういう設定をしておきます。</p>
<p>一手間と言ってもこれだけです。昔はAnalyzerはPowerShell動かして小細工しなきゃいけないとか色々あって超絶面倒くさかったんですが、.NET 5時代の今は、だいぶ簡単になりました。</p>
<h2>まとめ</h2>
<p>ずっとF#の<a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure">Units of Measure</a>のようなものが欲しいと思っていたのですよね。プリミティブなのだけど型がついてる。コンパイル時には型が消えてプリミティブそのものになるのでオーバーヘッドがない。そのままでも色々な演算ができる。</p>
<p>UnitGeneratorはお洒落なsuffixで生成とかはできないし組み込みの単位の変換関係（グラムとキログラムとかインチとフィーととか）があるわけじゃないので、同じものかといったら全然別物ではありますが、しかしValue Objectパターンの実装としては必要十分で、雰囲気も近づけられたのではないかと思います。</p>
<p>C#において、1要素のstructはメモリレイアウト的にはプリミティブ型と同一なので、完全に消せるわけではないですが、オーバーヘッドも減らしていける余地があります(演算のたびにnewで包み直していたりするのも、Unsafe.Asを活用していけばなくせるので、だいぶ近づけはするかな、と）。</p>
<p>実際ちゃんと型がついているのは良い状態で最終的に捗るのは間違いないので、このUnitGeneratorのアプローチが役に立てば何よりですね、是非試してみてください。あと、SourceGeneratorも是非作っていきましょう！</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
