<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2019-12-06" data-pagefind-meta="published:2019-12-06"><a href="https://neue.cc/2019/12/06_585.html">.NET Core時代のT4によるC#のテキストテンプレート術</a></h1>
<ul class="date"><li>2019-12-06</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2019/c-sharp">C# Advent Calendar 2019</a>用の記事となります。<a href="https://qiita.com/advent-calendar/2019/c-sharp-2">C# Advent Calendar 2019はその2</a>もあって、そちらも埋まってるので大変めでたい。</p>
<p>さて、今回のテーマはT4で、この場合にやりたいのはソースコードジェネレートです。つまるところC#でC#を作る、ということをやりたい！そのためのツールがテンプレートエンジンです。.NETにおいてメジャーなテンプレートエンジンといえばRazorなわけですが、アレはASP.NET MVCのHTML用のViewのためのテンプレートエンジンなため、文法が全くソースコード生成に向いていません、完全にHTML特化なのです。また、利用のためのパイプラインもソースコード生成に全く向いていない（無理やりなんとか使おうとするRazorEngineといったプロジェクトもありますが……)ので、やめておいたほうが無難です。</p>
<p>では何を使えばいいのか、の答えがT4(Text Template Transfomration Toolkit)です。過去には<a href="http://neue.cc/2013/06/30_411.html">Micro-ORMとテーブルのクラス定義自動生成について</a>という記事で、データベースのテーブル定義からマッピング用のC#コードを生成する方法を紹介しました。テーブル定義は、実際にDB通信してもいいし、あるいは何らかの定義ファイルを解析して生成、とかでもいいですね。また、最近の私の作っているライブラリには(UnityのIL2CPP対策で)コードジェネレーターがついていますが(<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>, <a href="https://github.com/Cysharp/MasterMemory/">MasterMemory</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack-CSharp</a>など)、それらの生成テンプレートは全てT4で作っています。</p>
<p>元々はVisual Studioべったりでしたし、実際べったりなのですが、Mac環境ではVisual Studio for Macで、あるいは（一手間入りますが）VS Codeで使用したり、最近だとRiderが2019.3 EAP 5からばっちしサポートされたようなので、MacやRider派の人も安心です。RiderのT4サポートは曰く</p>
<pre data-pagefind-ignore="all"><code class="language-txt">You asked us to support T4, and we’ve answered! T4 support is here, based on our own generator and available as a pre-installed plugin.
The plugin is open-sourced (https://github.com/JetBrains/ForTea) and your contributions are very welcome.
Feature-rich C# support in code blocks includes highlighting, navigation, code completion, typing assistance, refactorings, context actions, inspections, formatting, and more.
T4-specific features include inspections, typing assistance, folding, brace matching, etc.
Extensive support is offered for includes to make the resolve in C# code as correct as possible.
You can execute T4 templates.
You can also debug T4 templates.
All these features work across Windows, macOS, and Linux.
</code></pre>
<p>だそうで、なかなかイケてるじゃないですか。Visual Studioも、Riderもそうですが、テンプレートエンジンでデバッガ動かしてステップ実行できたりするのが地味に便利です。VS Codeだと設定に一手間が必要なので(Qiitaにて<a href="https://qiita.com/nogic1008/items/2c4049d43a11e83df15b">.NET Core+VS CodeでもT4 テンプレートエンジンでコード生成したい！</a>といった紹介もありますが)、VS2019, VS for Mac, Riderを使ったほうが楽そうです。</p>
<p>T4には2種類の生成パターン、<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates?view=vs-2019">デザイン時コード生成(TextTemplatingFileGenerator)</a>と、<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/run-time-text-generation-with-t4-text-templates?view=vs-2019">実行時テキスト生成(TextTemplatingFilePreprocessor)</a>の2種類がありますが、両方紹介します。</p>
<p>また、詳細なドキュメントが<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2019">コード生成と T4 テキスト テンプレート</a>にあり、実際かなり複雑な機能も搭載してはいますが、テキストテンプレートで複雑なことはやるべきではない（テキストテンプレートなんてあまり使わないような機能で使い倒した複雑なことやられても解読に困るだけ）ので、シンプルに使いましょう。シンプルに使う分には、全く難しくないです。</p>
<h2>デザイン時コード生成</h2>
<p>デザイン時コード生成とは、テンプレート単体でテキストを出力するタイプです。出力されたコードが、そのまま自身のプロジェクトのコンパイル対象になるイメージ。使い道としては、手書きだと面倒くさい単純な繰り返しのあるソースコードを一気に量産するパターンがあります。例えばジェネレクスのT1~T16までの似たようなコードを作るのに、一個雛形をテンプレートとして用意して for(1..16) で生成すれば一発、というわけです。他に、プリミティブの型(intとかdoubleとか)に対してのコード生成などもよくやりますね。またマークダウンで書かれた表（別の人がドキュメントとして書いているもの）から、enumを生成する、なんてこともやったりしますね。違うようで違わないようで実際微妙に違う退屈なユニットテストコードの生成、なんかにも使えます。</p>
<p>例としてMessagePackのカスタムシリアライザとして、以下のようなものを作りたいとします（単純な繰り返しの例としてちょうどよかったというだけなので、MessagePackの細かいAPIの部分は見なくてもいいです）。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Buffers;

namespace MessagePack.Formatters
{
    public sealed class ForceInt16BlockFormatter : IMessagePackFormatter&lt;Int16&gt;
    {
        public static readonly ForceInt16BlockFormatter Instance = new ForceInt16BlockFormatter();

        private ForceInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16 value, MessagePackSerializerOptions options)
        {
            writer.WriteInt16(value);
        }

        public Int16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt16();
        }
    }

    // 以下、Int16の部分がInt32だったりDoubleだったりするのを用意したい。
}
</code></pre>
<p>Int16になっている部分を、Int32やDoubleなど全てのプリミティブにあてはめて作りたい、と。手書きでも気合でなんとかなりますが、そもそも面倒くさいうえに、修正の時は更に面倒くさい。なので、これはT4を使うのが最適な案件といえます。</p>
<p>例はVisual Studio 2019(for Windows)で説明していきますが、T4の中身自体は他のツールを使っても一緒なのと、最後にRiderでの使用方法を解説するので、安心してください。</p>
<p>まずは新しい項目の追加で、「テキスト テンプレート」を選びます。</p>
<p class="noindent">
    <img src="https://user-images.githubusercontent.com/46207/70261367-9f852f00-17d5-11ea-87a2-bb7e00ff2ebe.png" width=640 />
</p>
<p>すると、以下のような空のテンプレートが生成されたんじゃないかと思われます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template debug=&quot;false&quot; hostspecific=&quot;false&quot; language=&quot;C#&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.txt&quot; #&gt;
</code></pre>
<p>csprojには以下のような追加のされ方をしています。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;ItemGroup&gt;
    &lt;None Update=&quot;ForceSizePrimitiveFormatter.tt&quot;&gt;
        &lt;Generator&gt;TextTemplatingFileGenerator&lt;/Generator&gt;
        &lt;LastGenOutput&gt;ForceSizePrimitiveFormatter.txt&lt;/LastGenOutput&gt;
    &lt;/None&gt;
    &lt;None Update=&quot;ForceSizePrimitiveFormatter.txt&quot;&gt;
        &lt;DesignTime&gt;True&lt;/DesignTime&gt;
        &lt;AutoGen&gt;True&lt;/AutoGen&gt;
        &lt;DependentUpon&gt;ForceSizePrimitiveFormatter.tt&lt;/DependentUpon&gt;
    &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>2個のItemが追加されているのは、T4本体と、生成物の2つ分です。<code>&lt;Generator&gt;TextTemplatingFileGenerator&lt;/Generator&gt;</code>というのがT4をこれで処理しますよ、という話で、DependentUponはソリューションエクスプローラーでの見た目上、ネストする親を指定、ということになっています。Visual Studioの不正終了なので、たまに***1.csなどといった末尾にインクリメントされたファイルしか生成されなくなってムカつく！という状況にたまによく陥るのですが、その場合はLastGenOutputあたりを手書きで修正してけば直ります。</p>
<p>さて、まず思うのはシンタックスハイライトが効いていない！ということなので、しょうがないのでVS拡張を入れます。私がよく使うのは<a href="https://t4-editor.tangible-engineering.com/T4-Editor-Visual-T4-Editing.html">tangible T4 Editor 2.5.0 plus
UML modeling tools</a>というやつで、インストール時にmodeling Toolsとかいういらないやつはチェック外してT4 Editorだけ入れておきましょう。なお、Visual Studioは閉じておかないとインストールできません。他のT4用拡張も幾つかあるのですが、コードフォーマッタがキモいとかキモいとか色々な問題があるので、私はこれがお気に入りです（そもそもコードフォーマットがついてない！変な整形されるぐらいなら、ないほうが百億倍マシです）。</p>
<p>さて、<code>&lt;#@ ... #&gt;</code>が基本的な設定部分で、必要な何かがあればここに足していくことになります。assembly nameは参照アセンブリ、基本的なアセンブリも最小限しか参照されていないので、必要に応じて足しておきましょう。ちなみにRiderだと何も参照されていない空テンプレートが生成されるので、デフォだとLINQすら使えなくてハァァァ？となるので要注意。System.Coreぐらい入れておけよ……。</p>
<p>import namespaceはまんま、名前空間のusingです。output extensionは、フツーは.csを吐きたいと思うので.csにしておきましょう。場合によってはcsvとかjsonを吐きたい場合もあるかもしれないですが。</p>
<p>次に、&lt;# ... #&gt; を使って、テンプレートに使う変数群を用意します。この中ではC#コードが書けて、別に先頭じゃなくてもいいんですが、あまりテンプレート中にC#コードが散らかっても読みづらいので、用意できるものはここで全部用意しておきましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#
    var types = new[]
    {
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(byte), 
        typeof(sbyte),
    };

    Func&lt;Type, string&gt; GetSuffix = t =&gt;
    {
        return t.Name == nameof(Byte) ? &quot;UInt8&quot; : (t.Name == nameof(SByte)) ? &quot;Int8&quot; : t.Name;
    };
#&gt;
</code></pre>
<p>今回は生成したいプリミティブ型を並べた配列を用意しておきます。また、ここではローカル関数を定義して、くり返し使う処理をまとめることもできるんですが(テンプレート中に式を書くと見にくくなるので、引数を受け取ってstringを返す関数を用意しておくと見やすくなります)、tangible T4 Editorがショボくてローカル関数に対してシンタックスエラー扱いしてくるので（動作はする）、Funcを使うことでお茶を濁します。</p>
<p>ここから先は本体ですが、短いので↑で見せた部分も含めてフルコードが以下になります。Visual Studioの場合は保存時、Riderの場合は右クリックから手動で実行した場合に、ちゃんとファイルが生成されていることが確認できるはずです！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template debug=&quot;false&quot; hostspecific=&quot;false&quot; language=&quot;C#&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
&lt;#
    var types = new[]
    {
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(byte), 
        typeof(sbyte),
    };

    Func&lt;Type, string&gt; GetSuffix = t =&gt;
    {
        return t.Name == nameof(Byte) ? &quot;UInt8&quot; : (t.Name == nameof(SByte)) ? &quot;Int8&quot; : t.Name;
    };
#&gt;
// &lt;auto-generated&gt;
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// &lt;/auto-generated&gt;

using System;

namespace MessagePack.Formatters
{
&lt;# foreach(var t in types) { #&gt;
    public sealed class Force&lt;#= t.Name #&gt;BlockFormatter : IMessagePackFormatter&lt;&lt;#= t.Name #&gt;&gt;
    {
        public static readonly Force&lt;#= t.Name #&gt;BlockFormatter Instance = new Force&lt;#= t.Name #&gt;BlockFormatter();

        private Force&lt;#= t.Name #&gt;BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, &lt;#= t.Name #&gt; value, MessagePackSerializerOptions options)
        {
            writer.Write&lt;#= GetSuffix(t) #&gt;(value);
        }

        public &lt;#= t.Name #&gt; Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.Read&lt;#= t.Name #&gt;();
        }
    }

&lt;# } #&gt;
}
</code></pre>
<p>記法の基本的なルールは&lt;# ... #&gt;で括っている部分以外は平文で出力されます。そして、&lt;#= ... #&gt;が式で、そこが文字列として展開されます。</p>
<p>なお、テンプレートを書くにあたって、長年の経験から得たおすすめのお作法があります。</p>
<ul>
<li>計算式はなるべくテンプレート中で書くのを避ける、ために事前に関数として定義しておく</li>
<li><code>&lt;auto-generated&gt;</code>を冒頭に書く、これはlintによる解析対象から外れる効果があるのと、このファイルがどこから来ているのかを伝えるために有用</li>
<li>foreachやifなどはなるべく一文で書く、複数行に渡っているとテンプレート中のノイズになって見難くなる。また、あまり</li>
<li><code>&lt;#</code>の開始行はインデントつけずに先頭で、というのもインデントつけてると平文のテンプレート生成対象になるため生成コードのインデントがズレやすい</li>
</ul>
<p>この辺を守ると、割と綺麗に書けると思います。テンプレートはどうしてもコード埋め込みがあって汚くなりやすいので、なるべく綺麗にしておくのは大事です。それでもどうしても避けられないifだらけで、読みにくくなったりはしてしまいますが、そこはしょうがない。</p>
<h2>実行時テキスト生成</h2>
<p>実行時テキスト生成は、いわゆるふつーに想像するテンプレートエンジンの動作をするもので、プログラム実行時に、変数を渡したらテンプレートにあてはめてstringを返してくれるクラスを生成します。データベースのテーブル定義からマッピング用のC#コードを生成するツール、であったり、私がよくやってるのはRoslyn(C# Compiler)でC#コードを解析して、それをもとにして更にC#コードを生成するツールであったり、というかむしろC#コードを解析してKotlinコードを生成したりなど、やれることはいっぱいあります。リフレクションでアセンブリを舐めて、条件に一致した型、メソッドから何かを作る、みたいなのも全然よくありますね。</p>
<p>これの作り方は、追加→新しい項目から「ランタイム テキスト テンプレート」を選ぶと、悲しいことに別に普通の「テキスト テンプレート」とほぼ同じものが生成されてます（VS2019/.NET Coreプロジェクトの場合）。なぜかというと、csprojを開くとGeneratorがTextTemplatingFileGenerator、つまり普通のテキストテンプレートと同じ指定になっているからです。これは、多分バグですね、でもなんか昔から全然直されてないのでそういうもんだと思って諦めましょう。</p>
<p>しょーがないので手書きで直します。GeneratorのTextTemplatingFileGeneratorをTextTemplatingFilePreprocessorに変えてください。そうすると以下のようなファイルが生成されています(Visual Studioの場合は保存時、Riderの場合は右クリックから手動で実行した場合)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">    #line 1 &quot;C:\Users\neuecc\Source\Repos\ConsoleApp14\ConsoleApp14\MyCodeGenerator.tt&quot;
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.VisualStudio.TextTemplating&quot;, &quot;16.0.0.0&quot;)]
    public partial class MyCodeGenerator : MyCodeGeneratorBase
    {
        /// &lt;summary&gt;
        /// Create the template output
        /// &lt;/summary&gt;
        public virtual string TransformText()
        {
            return this.GenerationEnvironment.ToString();
        }
    }
</code></pre>
<p>ファイル名で作られたパーシャルクラスと、TransformTextメソッドがあるのが分かると思います。これで何となく使い方は想像つくと思いますが、<code>new MyCodeGenerator().TransformText()</code>でテンプレート結果が実行時に得られる、という寸法です。</p>
<p>さて、しかしきっとコンパイルエラーが出ているはずです！これはNuGetで「System.CodeDom」を参照に追加することで解決されます。別にCodeDomなんて使ってなくて、CompilerErrorとCompilerErrorCollectionというExceptionを処理する生成コードが吐かれてるから、というだけなので、自分でその辺のクラスを定義しちゃってもいいんですが、まぁ面倒くさいんでCodeDom参照するのが楽ちんです。この辺ねー、昔の名残って感じでめっちゃイケてないんですがしょーがない。</p>
<p>それと行番号がフルパスで書かれててめっちゃ嫌、というかフルパスが書かれたのをバージョン管理に突っ込めねーよ、って感じなので、これも消しましょう。linePragmas=&quot;false&quot;をテンプレート冒頭に書いておけば消えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; linePragmas=&quot;false&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
</code></pre>
<p>この対応はほとんど必須ですね、ていうかデフォでfalseにしといてくれよ……。</p>
<p>さて、テンプレートにパラメーターを渡す方法ですが、これは生成されたクラス名と同じpartial classを定義すればOK。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace ConsoleApp14
{
    // 名前空間/クラス名(ファイル名)を合わせる(親クラスの継承部分は書かなくてOK)
    public partial class MyCodeGenerator
    {
        public GenerationContext Context { get; }

        // とりあえずコンストラクタで受け取る
        public MyCodeGenerator(GenerationContext context)
        {
            this.Context = context;
        }
    }

    // 生成に使うパラメーターはクラス一個にまとめておいたほうが取り回しは良い
    public class GenerationContext
    {
        public string NamespaceName { get; set; }
        public string TypeSuffix { get; set; }
        public int RepeatCount { get; set; }
    }
}
</code></pre>
<p>これでテンプレート中でContextが変数として使えりょうになります。テンプレートの例として、面白みゼロのサンプルコードを出すと……(Roslynとか使うともっと意味のあるコード例になるのですが、本題と違うところがかさばってしまうので、すみません……)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; linePragmas=&quot;false&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
// &lt;auto-generated&gt;
// THIS (.cs) FILE IS GENERATED BY ConsoleApp14.exe. DO NOT CHANGE IT.
// &lt;/auto-generated&gt;
namespace &lt;#= Context.NamespaceName #&gt;
{
&lt;# foreach(var i in Enumerable.Range(0, Context.RepeatCount)) { #&gt;
    public class Foo&lt;#= Context.TypeSuffix #&gt;&lt;#= i #&gt;
    {
    }

&lt;# } #&gt;
}
</code></pre>
<p>RepeatCountの回数で中身空のクラスを作るというしょっぱい例でした。これの注意事項は、普通のテキストテンプレートと特に変わりはないのですが、auto-generatedのところに、生成ツール名を入れておいたほうがいいです。外部ツールでコード生成するという形になるため、ファイルだけ見てもなにで生成されたかわからないんですね。あとから、何かで作られたであろう何で作られたかわからない自動生成ファイルを解析する羽目になると、ツールの特定から始めなくちゃいけなくてイライラするので、この辺をヘッダにちゃんと書いといてあげましょう。ただたんに「これは自動生成されたコードです」と書いてあるだけよりも親切で良い。</p>
<p>記述におけるコツは、やはりテンプレート中に式を書いて文字列を生成するよりかは、この場合だとContext側にメソッドを作って、引数をもらってstringを返すようにすると見通しが良いものが作りやすいでしょう。ちなみに<code>this.Context</code>のContextのIntelliSenseは効きません、そっちの解析までしてくれないので。テンプレートファイルにおける入力補完は甘え、おまけみたいなもんなので、基本的には頼らず書きましょう。もちろん、そのせいでばんばんTypoしてエラーもらいます。これが動的型付け言語の世界だ！をC#をやりながら体感できるので、いやあ、やっぱ静的型付け言語はいいですねえ、という気持ちに浸れます。</p>
<p>さて、こうして出来たクラスは、ただのパラメーターを受け取ってstringを返すだけのクラスなので、何に使っても良いのですが、9割はシンプルなコマンドラインツールになるのではないでしょうか。</p>
<p>C#でコマンドラインツールといったら！私の作ってる<a href="https://github.com/Cysharp/MicroBatchFramework">MicroBatchFramework</a>が当然ながらオススメなので、それを使ってツールに仕立ててみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using MicroBatchFramework;
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp14
{
    class Program : BatchBase
    {
        static async Task Main(string[] args)
        {
            await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync&lt;Program&gt;(args);
        }

        public void Run(
            [Option(&quot;o&quot;, &quot;output file path&quot;)]string outputPath,
            [Option(&quot;n&quot;, &quot;namespace name&quot;)]string namespaceName,
            [Option(&quot;t&quot;, &quot;type name suffix&quot;)]string typeSuffix = &quot;Foo&quot;,
            [Option(&quot;c&quot;, &quot;type generate count&quot;)]int repeatCount = 10
            )
        {
            // パラメータを作って
            var context = new GenerationContext
            {
                NamespaceName = namespaceName,
                TypeSuffix = typeSuffix,
                RepeatCount = repeatCount
            };

            // テキストを生成して
            var text = new MyCodeGenerator(context).TransformText();

            // UTF8(BOMなし)で出力
            File.WriteAllText(outputPath, text, new UTF8Encoding(false));

            Console.WriteLine(&quot;Success generate:&quot; + outputPath);
        }
    }
}
</code></pre>
<p>これで <code>ConsoleApp14.exe -o &quot;foo.cs&quot; -n &quot;HogeHoge&quot; -t &quot;Bar&quot; -c 99</code> というしょっぱいコマンドでfoo.csが吐かれるツールが完成しました！</p>
<h2>RiderにおけるT4</h2>
<p>RiderでのT4は、Visual Studioが使っている生成ツールとは違う、T4の記法として互換性のあるJet Brains独自のツールを実行している気配があります（そのため、場合によっては互換性がないところもあるかもしれません、というか実際linePragms=falseで行番号が消えなかった……)</p>
<p>実行自体は簡単で、ttに対して右クリックしてRunを選べばデザイン時コード生成、Preprocessを選べば実行時テキスト生成の出力結果が得られます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/70267774-74eda300-17e2-11ea-9121-a760d2db38ba.png" alt="image" /></p>
<p>現時点ではEAP、つまりプレビュー版ですが、まぁ他にもいっぱい良い機能が追加されてるっぽいので、Riderユーザーは積極的にEAPを使っていけばいいんじゃないかしら。</p>
<h2>T4にできないこと</h2>
<p>T4は、基本的に.ttで書かれたファイルを事前に(VSだと保存時、Riderだと任意に、あるいは設定次第でビルド時に)外部ツールが叩いて、テキスト(.csだったり色々)を生成します。いいところはC#プロジェクトと一体化して埋め込まれるので、パフォーマンスもいいし、そもそもT4生成時に型が合わなければエラーが出てくれる（動的の塊であるテンプレートファイルにとって、書き間違えは日常茶飯事なので、これは結構嬉しい）。実行効率も良いです、ファイル読んでパースして必要があればキャッシュして云々というのがないので。</p>
<p>が、しかし、プログラムが実行時に動的にテンプレートを読み込んでなにかする、みたいなことはできません。ツールのビルド時にテンプレートが出来上がってないといけないので、プラグイン的に足すのは無理です。それは成約になる場合もある、でしょうし、私的には型もわからないようなのを動的に合わせてテンプレート作るとか苦痛なので（←最近なんかそういうのやる機会が多くて、その度にシンドイ思いをしてる）、パラメータ渡しだけでなんとかして済むようにして諦めて作り込んだほうが百億倍マシ、ぐらいには思っていますが、まぁそういうのがしたいというシチュエーション自体は否定できません。その場合は、他のテンプレートエンジンライブラリを選んで組み込めば良いでしょう、T4がやや特殊なだけで、他のテンプレートエンジンライブラリは、むしろそういう挙動だけをサポートしているので。</p>
<h2>まとめ</h2>
<p>T4は十分使い物になります。微妙にメンテされてるのかされてないのか不安なところもありますが、そもそもMicrosoftもバリバリ使っているので(GitHubに公開されているcorefxのコードとかはT4で生成されているものもかなりあります、最近追加されたようなコードでも)、全く問題ないでしょう。実際、記法も必要十分揃っているし、特に極端に見にくいということもないと思います、ていうかテンプレートエンジンとしてフツーなシンタックスですしね。</p>
<p>仮に複雑なことやりたければ、例えばテンプレートをパーツ化して使い回すために分割して、都度インポートとか、というのもできます(<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/t4-include-directive?view=vs-2019">T4 インクルード ディレクティブ</a>では.t4という拡張子が紹介されていますが(拡張子はなんでもいい)、一般的には.ttincludeという拡張子が使われています)。他いろいろな機能がありますが、あらためて、テキストテンプレートごときで複雑なことやられると、追いかける気が失せるので、なるべく単純に保ちましょう。やるとしてもせいぜいincludeまで。それ以上はやらない。</p>
<p>というわけで、どうでしょう。MicroBatchFrameworkとも合わせて、C#のこの辺の環境は割といいほうだと思ってます。コード生成覚えるとやれることも広がるので、ぜひぜひ、コード生成生活を楽しんでください！</p>
<p>また、Unityでも普通に便利に使えると思います。Editor拡張でソースコード生成するものを用意するパターンは多いと思いますが（なにかリソースを読み込んで生成したり、あるいはそのままAssembly.GetExecutingAssembly().GetTypes()して型から生成したり)、その時のテンプレートとして、普通にstringの連結で作ってるケースも少なくなさそうですが、「デザイン時コード生成」も「実行時テキスト生成」も、どっちも全然いけます。「T4にできないこと」セクションに書いたとおり、よくも悪くも外部ツールで実行環境への依存がないので。</p>
</div>
<h1 data-pagefind-sort="date:2019-09-30" data-pagefind-meta="published:2019-09-30"><a href="https://neue.cc/2019/09/30_584.html">Unite Tokyo 2019でC# Structの進化の話をしてきました</a></h1>
<ul class="date"><li>2019-09-30</li></ul>
<div class="entry_body"><p><a href="https://events.unity3d.jp/unitetokyo/">Unite Tokyo 2019</a>にて、「Understanding C# Struct All Things」と題して登壇してきました！動画は後日<a href="https://learning.unity3d.jp/3305/">Unity Learning Materials</a>に公開される予定です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/h7l40rS3W9o3dI" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2019understanding-c-struct-all-things" title="【Unite Tokyo 2019】Understanding C# Struct All Things" target="_blank">【Unite Tokyo 2019】Understanding C# Struct All Things</a> </strong> from <strong><a href="https://www.slideshare.net/UnityTechnologiesJapan002" target="_blank">UnityTechnologiesJapan002</a></strong> </div>
<p>C#成分強めなので、Unityに馴染みのない人でも読んで楽しめる内容になっていると思います。とはいえ勿論、Uniteでのセッションであるということに納得してもらえるようUnity成分もきちんと取り入れています。というわけで、どちらの属性の人にも楽しんでいただければ！</p>
<p>structに関する機能強化、実際めっちゃ多いんですが、それをカタログ的に延々と紹介してもつまらないので、そうしたカタログ紹介っぽさが出ないように気を配ってます。あと、あんましそういうのでは脳みそに入ってこないというのもあるので。</p>
<p>応用例的なところのものは、ないとつまらないよねーということで色々持ってきたのですが、もう少し説明厚くしても良かったかなー感はありました。セッション内でも雰囲気で流した感じありますしね。とはいえ尺とか尺とか。まぁ雰囲気を分かってもらえれば（structは色々遊べるよ、という）いい、と割り切った面もあるにはあります。詳しくは資料を熟読してください！</p>
<p>Span/NativeArrayの説明も厚くしたくはあったんですが、structそのものの本題からは若干外れるので見送り。あと尺とか尺とか。</p>
<p>今年のUnite、もの凄くいいイベントでした。神運営とはこのことか……。そしてDOTSが熱い。めっちゃやるやる詐欺なので、いい加減本当にそろそろDOTSに手を出して楽しみたいですます！</p>
<p>あと、MessagePack-CSharp v2はいい加減そろそろ出るはず予定です、ちなみにSystem.Memoryとかにめっちゃ依存しているので、MessagePack-CSharpを入れるとSpanとかSystem.Runtime.CompilerServices.Unsafeとかが解禁されます（依存ライブラリとして同梱する予定なので）。いいのかわるいのか。まあ、いいでしょふ。未来未来。</p>
</div>
<h1 data-pagefind-sort="date:2019-09-09" data-pagefind-meta="published:2019-09-09"><a href="https://neue.cc/2019/09/09_583.html">CEDEC 2019にてMagicOnion、或いは他言語とC#の協調について話しました</a></h1>
<ul class="date"><li>2019-09-09</li></ul>
<div class="entry_body"><p>セッション名は<a href="https://cedec.cesa.or.jp/2019/session/detail/s5c9dede391631">Unity C# × gRPC × サーバーサイドKotlinによる次世代のサーバー/クライアント通信 〜ハイパフォーマンスな通信基盤の開発とMagicOnionによるリアルタイム通信の実現〜</a>(長い！）ということで二部構成になっていて、私は後半部分を担当しました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/3bVZiQOrtqFUqt" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/unity-cnet-coremagiconion-c-kotlin" title="Unity C#と.NET Core(MagicOnion) C# そしてKotlinによるハーモニー" target="_blank">Unity C#と.NET Core(MagicOnion) C# そしてKotlinによるハーモニー</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p><a href="https://cysharp.co.jp">Cysharp</a>は他社さんのお仕事も（ボリューム次第で、今はちょっとしたコンサルティングぐらいしか空きがないんですが）受けたりも可能です、ということで<a href="https://www.applibot.co.jp">アプリボット</a>さんのお手伝いをちょいちょいしています。リアルなMagicOnionの採用の話として、どんな風にやってるんですかねーというところの一環をエモ成分強めで語ってみました。リリースどころかタイトルもまだ未発表なので技術的な部分が弱めなので、次はリアルな実例として色々詰めたいところですね！</p>
<p>前半部、というかがっちゃんこされている資料は<a href="https://speakerdeck.com/n_takehata/kuraiantotong-xin-haipahuomansunatong-xin-ji-pan-falsekai-fa-tomagiconionniyoruriarutaimutong-xin-falseshi-xian">こちら</a>で公開されています。前半でgRPCいいぞ！という話をしているのに、こちらは冒頭でprotoは嫌だお！という展開で繋げるアレゲさでしたが、まあジョークの一環です。多分。はい。protoのいいところは中間形式であり言語agnosticなところで、protoのよくないところは中間形式であること、ですね。これが何を言っているかを理解できれば100点満点です！是非の議論は、このことを理解してから進めましょう。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>は、ちょうど今日Ver 2.4.0をリリースしまして、やる気満々です。次の展開もいろいろ考えているので、というか積みタスクがんがんがんが。まぁ、順次やってきます。</p>
<p>さて、9月はもう一つ、「Understanding C# Struct All Things」と第して<a href="https://events.unity3d.jp/unitetokyo/">Unite Tokyo 2019</a>でセッションします。
Day 2のRoom A、13:30からでライブ配信もあるので、そちらも見ていただければ！</p>
</div>
<h1 data-pagefind-sort="date:2019-08-26" data-pagefind-meta="published:2019-08-26"><a href="https://neue.cc/2019/08/26_582.html">TaskとValueTaskの使い分け、或いはValueTaskSupplementによる福音</a></h1>
<ul class="date"><li>2019-08-26</li></ul>
<div class="entry_body"><p>ValueTaskSupplementというライブラリを新しく作って公開しました！</p>
<ul>
<li><a href="https://github.com/Cysharp/ValueTaskSupplement">Cysharp/ValueTaskSupplement</a></li>
</ul>
<p>これは、ValueTaskにWhenAny, WhenAll, Lazyを追加するという代物で、それだけだとヘーそーなんだー、としか思えないと思われます。しかし、ValueTaskを使っていくと、めっちゃくちゃ欲しくなる機能になってます。ないと死ぬレベルで。</p>
<p>と、いうわけで、なんでこれが必要なのか、っていうところから説明します。</p>
<h2>TaskとValueTask</h2>
<p>C# 5.0にasync/awaitが導入された当初はTaskしか存在しませんでした。標準APIのあらゆるメソッドにasyncメソッドを生やすなど、Microsoftの多大な努力により、C#はいち早く非同期時代を迎え、async/awaitは多用（濫用とも言う）されるようになりました。しかし、多用された結果、当初思ってたよりもTaskのオーバーヘッド多くね？同期をラップするだけのシチュエーションも少なくなくね？ということに気付き、C# 7.0から登場したのがValueTaskです。</p>
<p>登場当時のValueTaskは <code>T | Task[T]</code> という、もし中身が同期の場合はTを、非同期の場合はTaskをラップしたものとして存在しました。なので、TaskとValueTaskの使い分けは、中身が非同期の場合が確定している場合はラップが不要で、かつ（当時）スタンダードな定義に沿うTaskを基本に考えていくのが良いでしょう。と、されていました。</p>
<p>が、しかし、実際にアプリケーションを作っていくと、都度使い分けなんて考えられるものじゃないし、ValueTaskのオーバーヘッドといってもstructでラップするだけの話でそこまで大きいわけじゃない(同期のものをTaskで定義したほうがよほど大きい)ので、普通にアプリケーションで定義する場合のルールは全部ValueTaskでいーんじゃね？と思っていたりは、私の個人的な見解どまりでありました。</p>
<p>そして、更にパフォーマンスを追求する中で、ValueTask-&gt;Task変換のオーバーヘッドをなくし、中身をそれぞれに特化したコードを挟み込めるように IValueTaskSource というものが導入されました。これによりValueTaskは <code>T | Task[T] | IValueTaskSource</code> のどれかの状態を持つという共用体となり、個別に実装されたシナリオでは中身がTask[T]の場合よりもIValueTaskSourceの場合のほうがパフォーマンスが高いということで、名実ともにValueTaskの天下の時代が始まりました。</p>
<p>大々的にパブリックAPIにも露出してくるのは.NET Core 3以降だと思われますが、今でも問題なく使える状態＆KestrelやSystem.IO.PipelinesにはValueTaskによるAPIが既に露出しています。<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>のフィルターもValueTaskだったりしたりしましたり。</p>
<p>なお、別の世界線では<a href="https://github.com/Cysharp/UniTask">UniTask</a>というものも存在しますが、これは ValueTask + IValueTaskSource に近い代物です。つまり別にTaskなんていらなかったんや……。</p>
<h2>ValueTaskの欠点</h2>
<p>そんなValueTask最大の欠点は、ユーティリティの欠如。つまり、WhenAllやWhenAnyができない。それらが必要な際はAsTaskでTaskに変換する必要がありました。が、Taskに変換する時点でオーバーヘッドじゃーん。しかもいちいちAsTaskするのはクソ面倒くさい！せっかく IValueTaskSource があるなら、IValueTaskSourceを使ってネイティブなValueTask用のWhenAllやWhenAnyを作ればハイパフォーマンスじゃん！というわけで、それらを提供するのがValueTaskSupplementです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using ValueTaskSupplement; // namespace

async ValueTask Demo()
{
    // `ValueTaskEx`が使う唯一の型です

    // こんな風な別々の型のValueTaskがあったとしても
    ValueTask&lt;int&gt; task1 = LoadAsyncA();
    ValueTask&lt;string&gt; task2 = LoadAsyncB();
    ValueTask&lt;bool&gt; task3 = LoadAsyncC();

    // awaitできて、タプル記法でサクッと分解できて便利！
    var (a, b, c) = await ValueTaskEx.WhenAll(task1, task2, task3);

    // WhenAnyでは int winIndexでどれが最初に値を返したか判定できます
    var (winIndex, a, b, c) = await ValueTaskEx.WhenAny(task1, task2, task2);

    // Timeoutみたいなものの実装はこんな風に
    var (hasLeftResult, value) = await ValueTaskEx.WhenAny(task1, Task.Delay(TimeSpan.FromSeconds(1)));
    if (!hasLeftResult) throw new TimeoutException();

    // Lazyも用意されています！
    // awaitを呼ぶまで遅延＆値がキャッシュされるAsyncLazyのような代物ですが
    // 型がValueTask&lt;T&gt;そのものなので、フィールドに保持したまま、WhenAllなどがそのまま書けて便利
    ValueTask&lt;int&gt; asyncLazy = ValueTaskEx.Lazy(async () =&gt; 9999);
}
</code></pre>
<p>と、いったように、ただのTask.Xxxよりも更に便利になった機能が追加されていて、もう全部ValueTaskで統一でいいっしょ、って気になれます（特に var (a, b, c) = await ....)が便利ですよ！</p>
<h2>まとめ</h2>
<p>時代はValueTask。Taskのことは忘れて全部ValueTaskで良いのですー、良いのですー。そして、ValueTaskで統一したら、すぐに標準のまんまじゃしんどいのですー、ってことに気づくでしょふ。そこでValueTaskSupplementですよ、っという流れです。絶対そうなります。というわけで諦めて（？）使いましょう。</p>
<p>ところで、最近よく<a href="http://tech.cygames.co.jp/">Cygames Engineers' Blog</a>に寄稿しているのですが、なんとなくの私の中の使い分けは、Unityに関する成分が含まれる（新規）ライブラリはCygamesのブログのほうに、そうじゃないものはここに、みたいな気持ちではいます。まぁ、どっちも見ていただければればですです。</p>
<p>また、直近イベントでは9月4日に<a href="http://cedec.cesa.or.jp/2019/">CEDEC 2019</a>で「Unity C# × gRPC × サーバーサイドKotlinによる次世代のサーバー/クライアント通信 〜ハイパフォーマンスな通信基盤の開発とMagicOnionによるリアルタイム通信の実現〜」、9月26日に<a href="https://events.unity3d.jp/unitetokyo/">Unite Tokyo 2019</a>で「Understanding C# Struct All Things」というセッションを行うので、是非是非見に来てください！</p>
</div>
<h1 data-pagefind-sort="date:2019-07-02" data-pagefind-meta="published:2019-07-02"><a href="https://neue.cc/2019/07/02_581.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2019-07-02</li></ul>
<div class="entry_body"><p>しました。カテゴリ名が毎回ちょくちょく変わってるんですが、今の状態はDeveloper Technologiesだそうです。つまりC#です。一年ごとに再審査があって、今回も通りました。</p>
<p>去年は<a href="https://cysharp.co.jp/">Cysharp</a>の設立もあり、よりC#に対して直接的に世の中に作用させていくよ！という意思を示しました。まだ活動は始まったばかりですが、ともあれC#を引っ張っていきたいという心持ちがあります。黙ってても別にC#は絶対死にはしないと思ってるんですが、もう少し表に立って光り輝いて欲しいよね、そこが足りないと思うんで、その辺をうまく補完できればなというところです。</p>
<p>去年の宣言は</p>
<blockquote>
<p>去年よりも上を、去年よりも上を、とハードルは無限に高くなっていくので、個人にせよ会社にせよ、世界にインパクトを残していける何かをやっていこう、というのが目標ですね。</p>
</blockquote>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>のリブートは比較的成功していると思いますし、<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>は、より強力なライブラリになるよう画策中です。<a href="https://github.com/Cysharp/UniTask">UniTask</a>は唯一無二でしょう。ワールドスタンダードをここから作っていくんだという気概でやっていますし、ある程度はやれているんじゃあないかしらん。ともあれ、まだ全然足りないので、より気合い入れてやっていこうかと。</p>
<p>引き続き主戦場はC#とUnityです。今はちょうど時代の変わり目で、多くの会社で、旧来のフレームワークから新しいフレームワークに移し替えるという話をよく聞きます。そこで.NET Coreですよ？と差し込める最後のチャンス（テクノロジースタックが固定されたら、また次の5年は入れ替えないですからねえ）、というぐらいに思ってるので(黙ってるとGoになっちゃいますしね！)、C#, .NET Core, それとUnityが価値あるものですよ、というところを多くの人に実感してもらえるように、やっていきます。そして困ったことがあればCysharpのお問い合わせフォームに投げてもらえればチャリンチャリンでウィンウィン。</p>
<p>MVPもメンツがだいぶ入れ替わってる感じで、それは非常に良いと思ってます。新陳代謝大事。そんな中で、私は古い方の人間に入るわけなので、居座ってる勢はただ単なる昔の成果の惰性で受賞続いているとかではなく、常に新しい成果でねじ伏せれるべきなんじゃあないでしょーか。私はしっかりやってると思ってましてよ。</p>
<p>そんなわけで引き続き、今年もよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2019-06-28" data-pagefind-meta="published:2019-06-28"><a href="https://neue.cc/2019/06/28_580.html">C#のOpenTelemetry事情とCollectorをMagicOnionに実装した話</a></h1>
<ul class="date"><li>2019-06-28</li></ul>
<div class="entry_body"><p>を、してきました。昨日。<a href="https://opencensus.connpass.com/event/132588/">OpenCensus/OpenTelemetry meetup vol.2</a>にて。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/hteXIJfIHC3Ikt" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/implements-opentelemetry-collector-in-dotnet" title="Implements OpenTelemetry Collector in DotNet" target="_blank">Implements OpenTelemetry Collector in DotNet</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>もともとトレースとかメトリクスの標準化として、OpenCensus(Google)陣営とOpenTracing(CNCF)陣営がいて、正直どっちも流行ってる気配を感じなかったのですが、合流して<a href="https://opentelemetry.io/">OpenTelemetry</a>が爆誕！これは本当に今年の頭に発表されたばかりで、仕様策定が完了するのが今年9月(予定)といった感じで、まだ練ってる最中というところです。ただ全体的にはOpenCensusベースでSDKが組まれているので、OpenCensusの時点で完成度がある程度高かったSDKは、割とそのままでも使えそうな雰囲気はあります。</p>
<p>個人的な意義とかはスライドにも書きましたが、まあ、流行って欲しいですね。概念はめっちゃ良いと思うので、きっちり浸透して使われるようになって欲しい。ぎっはぶスターだけが尺度ではないとはいえ、リファレンス実装のJava版の125が最大スター数とか、ワールドワイドで注目度弱すぎないか！？みたいな気は、あります。大丈夫かな。大丈夫ですよね……。一応、参画企業は名だたるところも多いし仕様分裂してるわけでもないので、乗っかる価値はあるんじゃないかと、思います。</p>
<h2>.NET SDKの事情</h2>
<p><a href="https://github.com/open-telemetry/opentelemetry-dotnet">opentelemetry-dotnet</a>で、メインに開発してるのはMicrosoftの人間が一人やってますね。<a href="https://github.com/SergeyKanzhelev">GitHubの草で見ても</a>毎日張り付いてopentelemetry系のなにかでなにかやってるので、仕事として専任で頑張ってるんじゃないでしょうか、多分。クオリティ的には高くもなく低くもなくというところで、過度に期待しなきゃあそんなもんでしょーということで受け入れられそうです。もともとJavaがリファレンス実装になってて、他の言語は、まず基本的なAPIはそれを踏襲すること、というところもあるので、あまりブーブー言ってもしょうがないかもしれません。</p>
<p>Collectorの実装がちょっと面白くて、<a href="https://github.com/open-telemetry/opentelemetry-dotnet/tree/master/src/OpenTelemetry.Collector.AspNetCore">AspNetCoreのCollector</a>や<a href="https://github.com/open-telemetry/opentelemetry-dotnet/tree/master/src/OpenTelemetry.Collector.Dependencies">HttpClientのCollector</a>は、
<a href="https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md">DiagnosticSource</a>という比較的新しい仕組みから情報を取るようになっています。これによって、プロファイラAPIによるAuto Instrumentによるパフォーマンス低下などもなく、しかし特にユーザーはなにもせずに、メトリクスが取得できるようになっています。</p>
<p>ADO.NETのCollectorがないのでDB系が取れないんですが、多分まだADO.NETがDiagnosticSourceに対応していないので、それが対応するまではやらないみたいなつもりなんだと思います。さすがにADO.NETのCollectorがないと話にならないでしょー。</p>
<h2>まとめ</h2>
<p>MagicOnionの事情としては<a href="https://github.com/Cysharp/MagicOnion/pull/161">実装のPR</a>は用意してますが、まだMergeしてません。ただまぁ、スライドに書いたのですが、結構これらを入れるだけで、撮って出しでもいい感じのダッシュボードが作れるんじゃないかと思います。このへんは前職でリリースしたゲームのダッシュボードを作り込んだ経験が生きてるかな、ってのはありますね。いやほんと。</p>
<p>ともあれというわけで、私はOpenTelemetryにベットするんで、みんなも是非やっていきましょう！ね！流行らせないと未来はない！</p>
</div>
<h1 data-pagefind-sort="date:2019-06-14" data-pagefind-meta="published:2019-06-14"><a href="https://neue.cc/2019/06/14_579.html">MagicOnion勉強会を開催しました</a></h1>
<ul class="date"><li>2019-06-14</li></ul>
<div class="entry_body"><p><a href="https://connpass.com/event/127369/">【Unity / .NET Core】 MagicOnion勉強会</a>。正確には開催してもらいました、ですが！<a href="https://virtualcast.jp/">バーチャルキャスト</a>さん、ありがとうございました！</p>
<p>こちらは私のスライド、 <a href="https://www.slideshare.net/neuecc/the-usage-and-patterns-of-magiconion">The Usage and Patterns of MagicOnion</a> になります。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/N4e3rLCF5EVuI1" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/the-usage-and-patterns-of-magiconion" title="The Usage and Patterns of MagicOnion" target="_blank">The Usage and Patterns of MagicOnion</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>実際何に使えるの、というところについて（妄想の）繋ぎ方を紹介したりしました。まぁ、ようするになんでも使えます、ということですね。</p>
<p><a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>はGitHub Starも1000超えたので、野良ぽっと出謎ライブラリからは、少し脱却したんじゃないかと思います。まだメジャー級とは言い難いですが。アングラ級？</p>
<p>私はP2P推すのどうかなーって思ってるわけなんですが、その理由はポジショントーク、じゃなくて自分がサーバー書けるから、ってのは勿論あるんですが、本当にP2Pでいいんすかねー、というのがあり。実際真面目に。リレーサーバー用意するんだったらもう自前でやる領域を秒速で超えちゃうし、P2P→Dedicated Serverだと、機能制限されたサーバーモデル(サーバーがリレーとしてしか機能できなくてロジック積んだりモロモロができない）になっちゃうので微妙に感じたり、結局自前でやるならP2Pでもマッチングどうすんねんであったり、まぁもろもろ色々と。信頼できるクライアント -&gt; サーバーのRPCが一つあるだけで、色々すっきり解決できるんじゃないのかなー、ってのはずっと思っているところで。</p>
<p>MagicOnionに問題がないとは言わないんですが、特にネイティブDLLは問題の塊なのでPure C#実装に変えたいねえ、そうすればプラットフォームの制限もなくなるしねえ、とかもあったりはあったりはあったりはしますが、まぁそのうちなんとかします:) コード生成に関しては肯定的なんですが（リフレクション拒否した非コードジェネレーションのモデルは、やれることにかなり制約入りますですのです）、現状のヘボジェネレーターはよろしくないのでそれも早急に直しまうす。インフラ系はドキュメントとかの拡充でカバーですかね、知識がいるのは事実なので。</p>
<h2>発表一覧</h2>
<p><a href="https://raspberly.hateblo.jp/entry/MagicOnionMeetup">勉強会レポ : 【Unity / .NET Core】 MagicOnion勉強会</a>さんのところにまとまっているのですが、こちらでも改めてリンク集で。</p>
<ul>
<li><a href="https://twitter.com/mitchydeath">@mitchydeath</a> - <a href="https://docs.google.com/presentation/d/1pFebnU8Rx7I8zEVJauKVGINUKcA4IznKRq9Wv1ziApk/edit?usp=sharing">MagicOnion ライブコーディング+α</a></li>
<li><a href="https://twitter.com/kimika127">@kimika127</a> - <a href="https://ykimisaki-my.sharepoint.com/:p:/g/personal/y_kimisaki_kimisaki_jp/EX9J_lb_fj1GptYDZ4tX_ZcBanQZ_FfNDIpQDT4wOrZueQ?rtime=tEjRcrXw1kg">明日から使えるMagicOnion</a></li>
<li><a href="https://twitter.com/p_a_sta">@p_a_sta</a> - <a href="https://speakerdeck.com/p_a_sta/magiconiondefalsegong-tong-chu-li-falsexie-mifang">MagicOnionでの共通処理の挟み方</a></li>
<li><a href="https://twitter.com/tanaka_733">@tanaka_733</a> - <a href="https://www.slideshare.net/tanakata/20190604-containerized-magiconion-on-kubernetes-with-observability-with-new-relic">MagicOnionをContainer化してkubernetesで動かしてNew Relicで監視する</a></li>
<li><a href="https://twitter.com/gsino_">gsino_</a> - <a href="https://www.slideshare.net/GoichiShinohara/using-or-not-using-magic-onion-148852440">MagicOnionを使う場合と使わない場合</a></li>
<li><a href="https://twitter.com/_y_minami">_y_minami</a> - <a href="https://www.slideshare.net/YutoNishine/ss-148924074">リアルタイムなゲームの開発でコンテナを使ってみたら簡単便利で激安だったのでオススメしたい！</a></li>
</ul>
<p>これだけトークが集まって、大感謝です。</p>
<p>第二回の開催、は（あるとしても）当面先だとは思いますが、実際MagicOnionを使用した開発に入っているプロジェクトは割とないわけではない（？）という感じですので、ご安心を（？）。一応<a href="https://www.slideshare.net/neuecc/grpchttp2-api-streaming">歴史的にはかなりの負荷を捌いている実績もある</a>ので……！<a href="https://cysharp.co.jp/">Cysharp</a>としても、「会社として」力を入れているところがあるので、その辺も安心材料に含めていただければと思っています。最悪、本当に困ったら<a href="https://cysharp.co.jp/contact/">お問い合わせ</a>下されば色々解決のお手伝いもできるかもしれません。</p>
<p>また、CEDEC 2019では<a href="https://cedec.cesa.or.jp/2019/session/detail/s5c9dede391631">Unity C# × gRPC × サーバーサイドKotlinによる次世代のサーバー/クライアント通信 〜ハイパフォーマンスな通信基盤の開発とMagicOnionによるリアルタイム通信の実現〜</a>と第して、<a href="https://www.applibot.co.jp/">アプリボット</a>さんと共同でセッションを行うので、そちらも是非是非。</p>
</div>
<h1 data-pagefind-sort="date:2019-05-27" data-pagefind-meta="published:2019-05-27"><a href="https://neue.cc/2019/05/27_578.html">LitJWTに見るモダンなC#のbyte[]とSpan操作法</a></h1>
<ul class="date"><li>2019-05-27</li></ul>
<div class="entry_body"><p>LitJWT、という超高速な認証ライブラリを作りました。</p>
<ul>
<li><a href="https://github.com/Cysharp/LitJWT">github.com/Cysharp/LitJWT</a></li>
</ul>
<p>なんと今回はUnity用が、ない！どころか.NET Standardですら、ない！.NET Core専用になってます（今のとこ）。理由はパフォーマンス都合で現状.NET CoreにしかないAPIを使いすぎたので修正が面倒ということなので、そのうちなんとかするかもしれませんかもしれません。</p>
<h2>5倍高速</h2>
<p><img src="https://user-images.githubusercontent.com/46207/58414904-c4c31300-80b7-11e9-9bd2-12f794518494.png" alt="" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/58415891-d823ad80-80ba-11e9-9182-8d8ce339e1c9.png" alt="image" /></p>
<p>そもそも認証ライブラリでパフォーマンス追求しているものなんてない！ので！まぁそりゃそうだという感じではある。実際、そこまで認証で必要か？というと疑問符が付くところなので、ただのオーバーエンジニアリングなのですが、とはいえ速いというのは良いことです。シンプルに。</p>
<p><a href="https://jwt.io/">JWT</a>に関しては特に説明することもないので（セッションにでも何にでも使えばいいんじゃないかしら、実際、私は<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>のステートレスセッションのために必要なので用意しました）、ここから先は実装の話をします。</p>
<h2>モダンBase64(Url)</h2>
<p>JWTは大雑把にはJSONをBase64Urlでエンコードして署名を引っ付けたもの、です。Base64UrlというのはBase64の亜種で、URLセーフになるように、使う文字列が少し異なります。性質上、GETでURLにトークンが引っ付いたりするかもですしね。なるほど。</p>
<p>さて、しかしそんなマイナーなBase64Urlをエンコードするメソッドは用意されていないので、普通はこんな風に書いてます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Convert.ToBase64String(input)
    .TrimEnd('=')      // 新しいstringを作る
    .Replace('+', '-') // 新しいstringを作る
    .Replace('/', '_') // 新しいstringを作る
</code></pre>
<p>改めてBase64Urlは、ようするにパディング（4の倍数に収まらない場合に末尾につく)の=が不要で、+が-、/が_なBase64なので、置換！ただたんに置換！する、すなわち新規文字列を無駄に作成！無駄に検索して無駄に作成！なわけです。</p>
<p>実際、別にこの<a href="https://ja.wikipedia.org/wiki/Base64">Base64の変換表</a>の一部を差し替えるだけの話なのに。</p>
<p>無駄すぎて発狂しちゃうので、ここは普通に自前で<a href="https://github.com/Cysharp/LitJWT/blob/master/src/LitJWT/Base64.cs">Base64を実装</a>することで大解決しましょう。実際それしか方法はない、しょうがない。</p>
<p>せっかく作るので、今風のAPIにしましょう。例えばデコードのAPIはこんな感じに。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static bool TryFromBase64UrlString(string s, Span&lt;byte&gt; bytes, out int bytesWritten)
public static bool TryFromBase64UrlChars(ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, out int bytesWritten)
public static bool TryFromBase64UrlUtf8(ReadOnlySpan&lt;byte&gt; utf8, Span&lt;byte&gt; bytes, out int bytesWritten)
</code></pre>
<p>stringだけ受け入れるのではなくて、<code>ReadOnlySpan&lt;char&gt;</code>と、UTF8を直接受け入れられるように<code>ReadOnlySpan&lt;byte&gt;</code>のオーバーロードを用意しましょう（面倒くせえ……）。中身の実装はcharとbyteで似てるようで若干違うので今回は雑にコピペコードで済ませてます。コピペ最強。</p>
<p>ともあれこれでゼロアロケーションなデコードです。</p>
<p>ちなみにSystem.Security.Cryptographyも、こうしたSpan対応のAPIが(.NET Core 2.1なら)あります。.NET Standard 2.0にはありません。2.1から、なのでまだ先です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">bool TryComputeHash(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, out int bytesWritten)
bool TrySignData(ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, out int bytesWritten)
bool VerifyData(ReadOnlySpan&lt;byte&gt; data, ReadOnlySpan&lt;byte&gt; signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
</code></pre>
<p>今回の最初のリリースが.NETCore Appのみなのは、主にこの辺が理由です。迂回できないこともないんですけどねえ。</p>
<h2>stackallocとArrayPoolをめっちゃ使う</h2>
<p>先のBase64のデコード繋がりで説明すると、デコード先のbyte[]をどう用意するか、という話であり。headerのBase64とかsignatureのBase64とか、あまり大きくないのが確定しているので、stackallocをSpanで受けて、デコード先を作ります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Span&lt;byte&gt; bytes = stackalloc byte[Base64.GetMaxBase64UrlDecodeLength(header.Length)];
if (!Base64.TryFromBase64UrlUtf8(header, bytes, out var bytesWritten))
</code></pre>
<p>Payloadは長さがわからない（そこそこ大きい可能性もある）ので、stackallocで受けるのは不安があるので、ArrayPoolを使いましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var rentBytes = ArrayPool&lt;byte&gt;.Shared.Rent(Base64.GetMaxBase64UrlDecodeLength(payload.Length));
try
{
    Span&lt;byte&gt; bytes = rentBytes.AsSpan();
    if (!Base64.TryFromBase64UrlUtf8(payload, bytes, out var bytesWritten))
    {
        return DecodeResult.InvalidBase64UrlPayload;
    }
    bytes = bytes.Slice(0, bytesWritten);

    // ....
}
finally
{
    ArrayPool&lt;byte&gt;.Shared.Return(rentBytes);
}
</code></pre>
<p>ようするに、今どきnew byte[]なんてしたら殺されるぞ！</p>
<h2>ReadOnlySpanの辞書を作る</h2>
<p><code>ReadOnlySpan&lt;byte&gt;</code>はref struct！つまりDictionaryのKeyにはできない！けどルックアップはしたい！</p>
<p>どーいうことかというと、例えば</p>
<p><img src="https://user-images.githubusercontent.com/46207/58417809-ef659980-80c0-11e9-8de3-79b7d21174b1.png" alt="image" /></p>
<p>HeaderのJSONを舐めて、デコードに使うアルゴリズムが何であるかあるかチェックしたいわけですが、まず、今どきはJSONをstringで検索したりはしません。UTF8のままやります(System.Text.Json(preview)や<a href="https://github.com/neuecc/Utf8Json/">Utf8Json</a>を使いましょう)。特に、今回はBase64Urlからデコードしてきたバイナリなので、更にstringにデコードしてしまうのは無駄の極みなので、絶対避けたいわけです。</p>
<p>そうして、algのvalue部分に相当するReadOnlySpan<byte>が切り出せたとしましょう。さて、じゃあこれが何であるか。HS256なのかRS512なのか、そして、それをキーにしてIJwtAlgorithmを取り出したいわけです。必要なデータ構造は<code>Dictionary&lt;ReadOnlySpan&lt;byte&gt;, IJwtAlgorithm&gt;&gt;</code>なわけです。が、それは無理。C#の言語仕様がそれを許してくれないのです。困ったねえ。</p>
<p>もちろん、答えは自作しましょう。今回は<a href="https://github.com/Cysharp/LitJWT/blob/master/src/LitJWT/ReadOnlyUtf8StringDictionary.cs">ReadOnlyUtf8StringDictionary</a>というものを用意しました。Dictionary内部で持っておくキーは別にSpanである必要はないので、普通にbyte[]で確保しておきます。ルックアップだけ</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public bool TryGetValue(ReadOnlySpan&lt;byte&gt; key, out TValue value)
</code></pre>
<p>というAPIを用意すればOKという寸法です。</p>
<p>実装において、byte[]の一致比較はSpanのSequenceEqualを使えば良いんですが、GetHashCodeの実装だけはどうにもなりません（Utf8Stringも控えてることだし、標準でいい感じのがそろそろ入るといいんですけどねえ）。私は延々と使いまわせいている<a href="https://github.com/Cysharp/LitJWT/blob/master/src/LitJWT/FarmHash.cs">FarmHash</a>の実装をコピペで用意していますが、適当にxxHashを実装したり何かするといいと思います。適当に拾ってきたものを使うとパフォーマンス的に意味のないクソ実装の可能性もあるので、その辺は適当に気をつけましょう。</p>
<h2>最後まで配列の切り出しをしない実装を作る</h2>
<p>jwtEncoderのEncodeメソッドは、3つのオーバーロード(名前違い含む)を持ってます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">string Encode&lt;T&gt;(...)
byte[] EncodeAsUtf8Bytes&lt;T&gt;(...)
void Encode&lt;T&gt;(IBufferWriter&lt;byte&gt; writer, ...)
</code></pre>
<p>一番使うのは、stringだとは思います。Httpのヘッダーとかに埋めたりするケースが多いと思うので、stringが要求されるのでしょーがない。でも、byte[]を返すもののほうが高速です。内部的には全てUtf8 byte[]で処理しているので、stringへのエンコード処理をバイパスできるからです。例えばgRPCは(<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>も)、バイナリヘッダーを許容しているので、stringヘッダーよりも高速に処理できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// gRPC Header
var metadata = new Metadata();
metadata.Add(&quot;auth-token-bin&quot;, encoder.EncodeAsUtf8Bytes());
</code></pre>
<p>さて、じゃあ最後の <code>IBufferWriter&lt;byte&gt;</code> はなにかというと、直接これに書き込みます。まぁ、<code>Span&lt;byte&gt;,int bytesWritten</code>みたいなものですが、<code>Span&lt;byte&gt;</code>を渡すのが使えるのって、処理後の長さが概ね分かっているときで、JwtのエンコードはPayloadの処理とかあるので、基本的には処理が完了するまで分かりません。ので、bytesWritten形式のAPIは向いてません。</p>
<p>IBufferWriterはStreamみたいなもので、これに直接書き込みます。新しいI/O APIである System.IO.Pipelines で使われているAPIで、つまりは、一応それに対応しているということで。<a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack-CSharp</a>のv2(現在絶賛制作中)も、IBufferWriterが主役になっています。時代はダイレクトライト。</p>
<h2>System.IdentityModel.Tokens.Jwtは最低</h2>
<p>JWTの話は特にするつもりはなかったんですが、とにかくSystem.IdentityModel.Tokens.Jwtが最低だということは言っておきたい！とにかくAPIがヤバい！まぁ、これ、他の認証系も統合された抽象化の上に乗っているので、JWT的に不要で意味不明なものがいっぱいついているうえに、その抽象化がエンタープライズグレード（笑）の重厚長大な酷いもので、Microsoftの認証が難しいと感じるとしたら（実際難しい）、ただたんにライブラリのAPIが腐ってるから難しいだけですからね。</p>
<p>何かのフレームワークと統合されてて、ワンポチで導入される、とかだったらまだいいんですが、直接は触りたくないですねえ。誰が作ってんだかって感じですが(お、公開されてる先はAzure配下かな……)</p>
<h2>まとめ</h2>
<p>MagicOnionで――というのもありますが、認証系はJWT中心に、ちょっと色々考えてます。あとまぁ、さすがにパフォーマンスだけが差別化要因というのはしょっぱいので、Unity対応しよ。</p>
</div>
<h1 data-pagefind-sort="date:2019-05-14" data-pagefind-meta="published:2019-05-14"><a href="https://neue.cc/2019/05/14_577.html">MagicOnion Ver 2.1.0</a></h1>
<ul class="date"><li>2019-05-14</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>のVer 2.1.0を出しました。前回が2月28日なので、3ヶ月ぶりで少し間が空いてしまった感じもありますが、色々良くなったので紹介していきまうまう。</p>
<h2>StramingHubClientでメッセージが詰まるバグの修正</h2>
<p>いきなり致命的な話なんですが、StreamingHubClientが1フレにつき1メッセージしか送信されないという、しょうもないバグが存在していました。このバグの原因が面白くて（？）、元はこんな感じのコードだったんですよ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// readerはIAsyncEnumeratorというMoveNext, Currentでデータを取ってくる非同期イテレーター
while (await reader.MoveNext())
{
    var message = reader.Current; // byte[]
    OnBroadcastEvent(message);    // messageは実際にはヘッダ解析したり色々してます
}
</code></pre>
<p>gRPCはIAsyncEnumeratorというかっこつけたインターフェイスを採用しているので、awaitでサーバーからデータが届くのを非同期で待機できる。</p>
<p>で、このawaitが問題で、UnityだとUnitySynchronizationContext経由してawaitの先が実行されます。なので安全にメインスレッドでOnBroadcastEvent(これは最終的にユーザーが実装したインターフェイス定義のメソッドが呼ばれる)が呼ばれて嬉しい。のですが、reader自体は別スレッドで動いているので、awaitの度にメインスレッドへの同期を待っているのです。</p>
<p>正確には<a href="https://github.com/Unity-Technologies/UnityCsReference/blob/9c7b88327d1b48000ea94dc52a405068a140980f/Runtime/Export/Scripting/UnitySynchronizationContext.cs#L53-L60%5D(https://github.com/Unity-Technologies/UnityCsReference/blob/9c7b88327d1b48000ea94dc52a405068a140980f/Runtime/Export/Scripting/UnitySynchronizationContext.cs#L53-L60)">UnitySynchronizationContext</a>がawaitの度にメインスレッド上だろうがなんだろうが問答無用で次フレームに叩き込む仕様だから、なのですけれど。</p>
<p>何れにせよ、そんなわけで、サーバーから同一フレームで沢山のデータが送られてきたとしても、クライアント側は1フレームに1メッセージしか捌けないので、どんどん詰まっていくわけです。もちろん、バグです。仕様じゃなく。普通に。バグ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var syncContext = SynchronizationContext.Current;

// ConfigureAwait(false)でSyncContextを外して、このループはずっと別スレッドで動かす
while (await reader.MoveNext().ConfigureAwait(false))
{
    var message = reader.Current;
    if (syncContext != null)
    {
        // 手動でPostする（待たない）
        syncContext.Post(() =&gt; OnBroadcastEvent(message));
    }
    else
    {
        OnBroadcastEvent(message);
    }
}
</code></pre>
<p>と、いうわけで、こんな具合に半手動でPostするコードに書き換えました(Postでラムダ式のキャプチャが発生する問題がありますがshoganai。正確にはobject stateが渡せるのですが、実際のデータでは複数の値が必要になるのでTupleを作る必要があって、余計なオブジェクトが必要という点で変わらない)。ConfigureAwait(false)をつけないことは意識して、意図してやったこと(同期コンテキストを維持してメインスレッド上でコールバックを飛ばす)だったんですが、そこまで意識しといてこういうバグにつなげちゃうのは完全に甘かった、ということで反省しきりです。</p>
<p>ともあれこれで詰まり問題は大解決です。</p>
<h2>MagicOnion.Hosting</h2>
<p>最初のサンプルがConsole.ReadLineで待っているコードなのでアレなのですが、普通に実開発ではMagicOnion.Hostingというプロジェクトを使って欲しいと思っています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using MagicOnion.Hosting
static async Task Main(string[] args)
{
    await MagicOnionHost.CreateDefaultBuilder()
        .UseMagicOnion(
            new MagicOnionOptions(isReturnExceptionStackTraceInErrorDetail: true),
            new ServerPort(&quot;localhost&quot;, 12345, ServerCredentials.Insecure))
        .RunConsoleAsync();
}
</code></pre>
<p>Hostingとは何かと言うと、<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.2">Genric Host</a>という.NET Core時代の基盤フレームワークの上に乗っかっています。これは、こないだ作った <a href="http://tech.cygames.co.jp/archives/3241/">MicroBatchFramework – クラウドネイティブ時代のC#バッチフレームワーク</a> と同じ仕組みです。</p>
<blockquote>
<p>.NET Generic Hostは、標準的な仕組みとしてロギング／コンフィグ読み込み／DIをサポートしています。これによりコンフィグのマッピング、ロギングなどを標準的な作法でフルサポートしています。</p>
</blockquote>
<p>というわけで、何が嬉しいかと言うと、↑の件をフルサポートしてくれていることです。コンフィグとか何をどう読み込めばいいんですかー？という話は、Generic Hostの仕組みを使ってください、というのが答えになります。ドキュメントもMicrosoftのドキュメントサイトで沢山解説されていて、それがそっくりそのまま使えるので、良いことしかない！</p>
<p>また、これによってコンストラクタインジェクションでのDIも使えるようになりました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task Main(string[] args)
{
    await MagicOnionHost.CreateDefaultBuilder()
        .ConfigureServices((hostContext, services) =&gt;
        {
            // DI, you can register types on this section.

            // mapping config json to IOption&lt;MyConfig&gt;
            // requires &quot;Microsoft.Extensions.Options.ConfigurationExtensions&quot; package
            services.Configure&lt;MyConfig&gt;(hostContext.Configuration);
        })
        .RunConsoleAsync();
}

public class MyFirstService : ServiceBase&lt;IMyFirstService&gt;, IMyFirstService
{
    IOptions&lt;MyConfig&gt; config;
    ILogger&lt;MyFirstService&gt; logger;

    public MyFirstService(IOptions&lt;MyConfig&gt; config, ILogger&lt;MyFirstService&gt; logger)
    {
        this.config = config;
        this.logger = logger;
    }

    // ...
}
</code></pre>
<p>好きな型を、ConfigureServicesのとこで追加してもらえれば、コンストラクタで設定されたのが入ってきます。</p>
<h2>今後</h2>
<p>v2のリリース告知から半年経って、かなり注目度が上がっているというのが肌感としてあります。GitHub Starも962まで来ていますし、海外からの問い合わせも国内からも来ていて、盛り上がりありますよ！時代はC#！かもしれない！</p>
<p>というわけかで、来月の6月4日に初の<a href="https://connpass.com/event/127369/">MagicOnion勉強会</a>が開催されます。私も登壇しますので、ぜひぜひ来てください（今はもうキャンセル待ちですが……！）</p>
<p>開発的には、サーバーサイドゲームループ（まだ未サポート）などの追加を挟みつつ、もう少し野心的なものも狙っていますので、是非是非楽しみにしていただければと思います。コードジェネレーターの使い勝手が悪いのも、(MessagePack-CSharpともども)改善の最優先タスクの一つになってますので、なんとかします。</p>
<p>また、フィードバック超大事！なので、ぜひ使ってみて、Twitterでつぶやくなり(捕捉してます)、Qiitaに書いてくれるなり（やったー！）、Issueで報告してもらったりなどなどしてくれると嬉しいです。</p>
</div>
<h1 data-pagefind-sort="date:2019-05-06" data-pagefind-meta="published:2019-05-06"><a href="https://neue.cc/2019/05/06_576.html">CIや実機でUnityのユニットテストを実行してSlackに通知するなどする</a></h1>
<ul class="date"><li>2019-05-06</li></ul>
<div class="entry_body"><p>前回（？）<a href="http://neue.cc/2019/04/08_574.html">CircleCIでUnityをテスト/ビルドする、或いは.unitypackageを作るまで</a>では、ユニットテストに関する部分がうまく行ってなくて放置でした。放置でいっかな、と思ってたんですが、改めてユニットテストをCIでがっつり実行したい、というかIL2CPPのテストをがっつしやりたい。という切実な要望が私の中で発生したので（N回目）、改めて取り組んでみました。</p>
<p>さて、オフィシャルな（？）ユニットテストのコマンドラインの実行の口は、<a href="https://docs.unity3d.com/Manual/PlaymodeTestFramework.html">Writing and executing tests in Unity Test Runner</a>の最後の方のRunning from the command lineの節に書いてありました(コマンドライン引数のほうのマニュアルにはリンクすら張ってなかったので気づかなかった……！)。つまり、こんなふうにやればいい、と。</p>
<pre data-pagefind-ignore="all"><code class="language-text">Unity.exe -runTests -testResults C:\temp\results.xml -testPlatform StandaloneWindows64
</code></pre>
<p>そうすると、テストが失敗しても正常終了して（？） results.xml に結果が入ってるからそっち見ればOK、と。んー、いや、何か違うような。「Run all in player」で出てくるGUI画面も意味不明だし、Editor上のTest Runnerはいい感じなのだけれど、ビルドしてのテストだとイマイチ感がめっちゃ否めない。</p>
<p>と、いうわけで、なんとなく見えてきたのは、テストはUnity Test Runnerでそのまま書きたいしエディタ上でPlay Modeテストもしたい。それをそのままCIや実機でテストできるように、表示やパイプラインだけをいい具合に処理するビルドを作る何かを用意すればいいんじゃないか、と。</p>
<h2>RuntimeUnitTestToolkit v2</h2>
<p>ちょうどUnity Test Runnerがイマイチだった頃に作った俺々テストフレームワークがありました。ので、それを元にして、Unity Test RunnerのCLI/GUIのフロントエンドとして機能するようにリニューアルしました。コード的には全面書き換えですね……！</p>
<ul>
<li><a href="https://github.com/Cysharp/RuntimeUnitTestToolkit">Cysharp/RuntimeUnitTestToolkit</a></li>
</ul>
<p>Unity Test RunnerのPlayModeで動くテストがあれば、それだけで他に何もする必要はありません。例えばこんなやつがあるとして</p>
<p><img src="https://user-images.githubusercontent.com/46207/57200806-27e6eb80-6fcb-11e9-9d86-dfe6c7a854c6.png" alt="image" /></p>
<p>メニューのほうで適当にターゲットフレームワークとかIL2CPPがどうのとかを設定してもらって</p>
<p><img src="https://user-images.githubusercontent.com/46207/57200330-a04aae00-6fc5-11e9-82fa-39006fef583e.png" alt="image" /></p>
<p>BuildUnitTestを押すと、こんなような結果が得られます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/57200618-29afaf80-6fc9-11e9-8515-167076b2f4d8.png" alt="image" /></p>
<p>比較的ヒューマンリーダブルなログ！WindowsでもIL2CPPビルドができるようになったのがとっても捗るところで、検証用の小さめプロジェクトなら1分あればコード編集からチェックまで行けるので、リフレクションのキワイ部分をごりごり突いてもなんとかなる！昔のiOSでビルドして動かしてをやってたのは本当に死ぬほど辛かった……。</p>
<p>これはHeadless(CUI)でビルドしたものですが、GUIでのビルドも可能です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/57200784-d2aada00-6fca-11e9-8182-944abb963316.png" alt="image" /></p>
<p>イケてる画面かどうかでは微妙ですが、機能的には十二分です。Headlessだと上から下まで全部のテストを実行しちゃいますが、GUIだとピンポイントで実行するテストを選べるので（ただしメソッド単位ではなくクラス単位）、テストプロジェクトが大きくなっている場合はこっちのほうが便利ですね。</p>
<p>さて、Headlessでビルドしたものは、もちろんCIでそのまま実行できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/57200862-d12de180-6fcb-11e9-8353-5a897dd2c952.png" alt="image" /></p>
<p>これはNGが出ている例ですが、ちゃんと真っ赤にCIのパイプラインが止まるようになってます。止まればもちろんCIの通知設定で、Slackでもなんでもどこにでもサクッと飛ばせます。実に正しい普通で普遍なやり方でいいじゃないですか。はい。というわけでやりたかったことが完璧にできてるのでめでたしめでたし。</p>
<h2>Linux ContainerとUnity</h2>
<p>相変わらずCircleCIで色々トライしているのですが、Linuxコンテナ + Unityでの限界、というかUnityのLinux対応が後手に回ってる影響をくらってビミョーという現実がやっと見えてきました。まず、そもそもにLinux + IL2CPPはまだサポートされてないので、CI上でIL2CPPビルドしたものを実行してテスト、みたいなのはその時点でできない。残念。しゃーないのでWindows + IL2CPPビルドを作って、実行だけ手元でやるのでもいっか、と思ったらそもそもLinuxでIL2CPPビルドができない。なるほど、そりゃそうか、って気もしますが悲しみはある。</p>
<p>と、いうわけで、コンテナベースでやるとどうしてもLinuxの上でのパターンが中心になってしまうので、Unityだと結構厳しいところはありますよねえ、という。</p>
<p>さて、CircleCIの場合は(有料プランでは)Mac VMも使えるので、多少コンフィグの書き方も変わってきますが（マシンセットアップ部分が面倒くさくなる！）、動かせなくもないんちゃうんちゃうんといったところです。或いはAzure DevOpsなどを使えばWindowsマシンが使えるので、こちらもUnityのインストールなどのセットアップは必要ですが、安心感はありますね。どちらにせよWindowsでしかビルドできないもの(Hololensとか)もあるので、ちょっとちゃんと考えてみるのはいいのかなあ、と思ってます。</p>
<p>何れにせよ、VMでやるんだったらそりゃ普通にできますよね、という当たり前の結論に戻ってくるのが世の中きびすぃ。とりあえず私的にはIL2CPPビルドが実行できればいいので、Linux + IL2CPP対応をどうかどうか……。</p>
<h2>RandomFixtureKit</h2>
<p>ユニットテスト用にもう一個、RandomFixtureKitというライブラリを作りました。こちらは .NET Core用とUnity用の両対応です。</p>
<ul>
<li><a href="https://github.com/Cysharp/RandomFixtureKit">Cysharp/RandomFixtureKit</a></li>
</ul>
<p>なにかというと、オブジェクトにランダムで適当な値を自動で詰め込むという代物です。当然リフレクションの塊で、これのIL2CPP対応に、先のRuntimeUnitTestToolkitが役に立ちました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/56805033-abce0480-6862-11e9-91d0-7ca9c08aa688.png" alt="" /></p>
<p>APIも単純でFixtureFactory.Createで取り出すだけ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// get single value
var value = FixtureFactory.Create&lt;Foo&gt;();

// get array
var values = FixtureFactory.CreateMany&lt;Bar&gt;();

// get temporal value(you can use this values to use invoke target method)
var (x, y, z) = FixtureFactory.Create&lt;(int, string, short)&gt;();
</code></pre>
<p>テスト書いていてダミーのデータを延々と書くの面倒くせー、という局面はめっちゃあって、別に賢い名前なんて必要なくて（例えばAddressにはそれっぽい住所、Nameにはそれっぽい人名を入れてくれるとか）、全然ランダム英数でもいいから詰めてくれればそれでいいの！というところにピッタリはまります。</p>
<p>実用的には、私はシリアライザの入れ替えとか（なぜか）よくやるんですが、旧シリアライザと新シリアライザで互換性なくて壊れたりしないように、相互に値を詰めたりとかして、同一の結果が得られることを確認したりします。そのときに、dllをなめて対象になる数百の型を取って、RandomFixtureKitを使って、適当な値を詰めた上で、一致を比較するユニットテストを用意するとかやったりします。</p>
<p>面白い機能としては、ランダムな値ではなくて、エッジケースになり得る値だけを詰めるモードを用意しています。</p>
<p><img src="https://user-images.githubusercontent.com/46207/56805214-44fd1b00-6863-11e9-9541-b8ff30b7599a.png" alt="" /></p>
<p>たとえばintだったらint.MinValue, MaxValue, 0, -1, 1を。コレクションだったらnull, 長さ0, 長さ1, 長さ9の中からランダムで詰める、といったものですね。</p>
<p>こういうキワいデータが入ったときにー、みたいなことは想定しなきゃいけないし、テストも書いておかなきゃなのは分かってるけれど、毎回データ変えて流すのクソ面倒くさいんですよね（私はシリアライザを（なぜか）よく書くので、本当にこういうデータをいっぱい用意する必要が実際ある）。ので、CreateManyで1000個ぐらい作って流し込んでチェックすれば、多少はケースが埋まった状態になるでしょうというあれそれです。使ってみると意外と便利ですよ。</p>
<h2>ところで</h2>
<p>ゴールデンウィークの最終日なのですが、ほとんど何もやってない！始まる前は、MessagePack-CSharpやMagicOnionのタスクを潰しつつ、Pure C#のHTTP/2 Clientを作ってMagicOnionを強化するぜ、とか息巻いていたのですが全然できてない。副産物というか横道にそれたユニットテスト関連を仕上げて終わりとか、なんと虚しい……。</p>
<p>できなかった理由の半分はSwitchで<a href="http://www.celestegame.com/">Celeste</a>を遊び始めたらめちゃくちゃハマって延々とやり続けちゃったせいなのですが、まぁそれはそれで面白いゲームをたっぷり楽しめたということで有意義なのでよしということにしておきます。</p>
<p><a href="https://connpass.com/event/127369/">MagicOnionは6月4日に勉強会をやります</a>。というわけで、やる気もかなりあるし、アップデートネタも溜まっているんですが、実際にアップデートはできてないので（Issueのヘンジはちゃんとやってます！）、GWでガッと手を入れておきたかったんですが、うーん、まぁ明けてからやりまうす。色々良い感じになっていると思います。いやほんと。</p>
</div>
<h1 data-pagefind-sort="date:2019-04-24" data-pagefind-meta="published:2019-04-24"><a href="https://neue.cc/2019/04/24_575.html">True Cloud Native Batch Workflow for .NET with MicroBatchFramework</a></h1>
<ul class="date"><li>2019-04-24</li></ul>
<div class="entry_body"><p><a href="https://jaws-dotnet.connpass.com/event/122981/">AWS .NET Developer User Group 勉強会 #1</a>にて、先日リリースした<a href="https://github.com/Cysharp/MicroBatchFramework">MicroBatchFramework</a>について、話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/LIa5Ht82wbd7Oe" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/true-cloud-native-batch-workflow-for-net-with-microbatchframework" title="True Cloud Native Batch Workflow for .NET with MicroBatchFramework" target="_blank">True Cloud Native Batch Workflow for .NET with MicroBatchFramework</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>タイトルが英語的に怪しいですが、まぁいいでしょう（よくない）</p>
<p>MicroBatchFrameworkの概要については、リリース時にCygames Engineers' Blogにて<a href="http://tech.cygames.co.jp/archives/3241/">MicroBatchFramework – クラウドネイティブ時代のC#バッチフレームワーク</a>として書かせていただきました。そう、最近はそっち（どっち）に書いてしまうのでこっち（あっち）に書かれなくなる傾向が！リポジトリの置き場としても、Cysharpオーガナイゼーション中心になってきています。これは会社としてメンテナンス体制とかもしっかり整えていくぞ、の現れなので基本的にはいいことです。</p>
<p>ちなみに<a href="https://cysharp.co.jp/">Cysharp</a>、ページ下段にお問い合わせフォームが（ついに）付きました。興味ある方は応募していただいてもよろしくてよ？ビジネスのお問い合わせも歓迎です。別にゲームに限らずで.NET Coreの支援とかでもいいですよ。ただしオールドレガシーWindows案件はやりません。</p>
<h2>クラウドネイティブ</h2>
<p>これはセッションで口頭で言いましたが、バズワードだから付けてます。という側面は大いにあります。世の中マーケティングなのでしょーがないね。そもそも私はそういうのに乗っかるの、好きです。</p>
<p>そんな中身のないクラウドネイティブですが（真面目な定義は<a href="https://github.com/cncf/toc/blob/master/DEFINITION.md">CNCFのDefinition</a>にちゃんとあります)、まぁコンテナ化です。ベンダー中立な。というのをコンテナ化ビリティの高さという表現に落としました。.NET Coreは結構いい線言ってると思いますよ。実際。</p>
<p>さて、そんなクラウドネイティブなふいんきのところでの、理想のバッチ処理ってなんやねん。というのを考えて、逆算でアプリケーション側で埋めるべきものを埋めるために作ったのがMicroBatchFrameworkです。インフラ側の欠けてるところはそのうちクラウド事業者が埋めてくれるか、現状でも全然実用レベルで回避はどうとでもなるでしょう。</p>
<p>私としてはC#が快適にかければなんだっていいんですが、なんだっていいというだけではなくC#としての自由の追求に関しては相当ラディカルなのですが、でも、それって割とクラウドネイティブの定義（ちゃんとしたほうの）通りなんですよね。別にコンテナに夢見てるわけじゃなくて、意外と堅実に正しく定義どおりのことやってるわけです。まー、FaaSのオーケストレーターは私の理想からベクトル真逆だし、FaaSのランタイムの重さ（実行が遅いという意味ではなくてシステムとしてのヘヴィさ）も受け入れ難いんで、世の中の正しい進化について正面から向かい合うのが結局一番ということで。</p>
<p>ところでMicroBatchFrameworkのウェブホスティング機能(MicroBatchFramework.WebHosting)はSwaggerによる実行可能なドキュメント生成、のほかに、HTTPをトリガーにする待ち受けという側面もあります。GCP Cloud Runの実行のためにはそういうの必要ですからね。毎回コンテナ起動みたいな夢見たモデルだけじゃなくて、割とちゃんと現実に即して機能は用意してます。意外と。割とちゃんと。そもそも、その辺は実用主義なので。</p>
<p>MicroBatchFrameworkはいい具合のバランス感覚で作れていると思うので、実際良いと思います。というわけで、是非試していただければですね。</p>
</div>
<h1 data-pagefind-sort="date:2019-04-08" data-pagefind-meta="published:2019-04-08"><a href="https://neue.cc/2019/04/08_574.html">CircleCIでUnityをテスト/ビルドする、或いは.unitypackageを作るまで</a></h1>
<ul class="date"><li>2019-04-08</li></ul>
<div class="entry_body"><p>死ぬほどお久しぶりです！別にインターネット的には沈黙してるわけじゃなく<a href="https://twitter.com/neuecc">Twitter</a>にもいるし、<a href="https://cysharp.co.jp/">会社(Cysharp)関連</a>で露出あるかもないかもというわけで、決して沈黙していたわけでもないはずですが、しかしブログは完全に放置していました、あらあら。</p>
<p>C#的にも色々やっていて、<a href="https://github.com/neuecc/CloudStructures">CloudStructures</a>のv2を<a href="https://twitter.com/xin9le">@xin9le</a>さんとともにリリースしたり、多分、今日に詳細を書くつもりですが<a href="https://github.com/Cysharp/MicroBatchFramework/">MicroBatchFramework</a>というライブラリをリリースしたり、<a href="https://github.com/Cysharp/Ulid/">Ulid</a>というライブラリをリリースしてたり、まぁ色々やってます。ちゃんと。実際。今月はそのMicroBatchFramework関連で、<a href="https://jaws-dotnet.connpass.com/event/122981/">AWS .NET Developer User Group 勉強会 #1</a>に登壇しますし。リブートした<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>も来月勉強会開催予定だったりで、めっちゃやる気です。</p>
<p>さて、そんなやる気に満ち溢れている私なのですが（実際Cysharpもいい感じに動き出せているので！お問い合わせフォームないけどお問い合わせ絶賛募集中！）、ブログは放置。よくないね。というわけで表題の件について。</p>
<h2>目的と目標</h2>
<p>CIの有効性について未だに言う必要なんてなにもないわけですが、しかし、.unitypackageを手作業で作っていたのです。今まで。私は。<a href="https://github.com/neuecc/UniRx">UniRx</a>とか<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack-CSharp</a>の。そして死ぬほど面倒くさいがゆえに更新もリリースも億劫になるという泥沼にハマったのです。やる気が満ち溢れている時は手作業でもやれるけれど、やる気が低下している時でも継続してリリースできなければならないし、そのためにCIはきっちりセットアップしておかなければならないのです。という真理にようやく至りました。なんで今さらなのかというと、私がアプリケーション書くマンであることと、CIとかそういうのは全部、部下に丸投げして自分は一切手を付けてこなかったマンだからです。しかし会社のこともあるので、いい加減にそれで済まなくなってきたので（今更やっとようやく）真面目に勉強しだしたのですね……！</p>
<p>で、CIには<a href="https://circleci.com/">CircleCI</a>を使います。なんでCircleCIなのかというと、一つはUnity Cloud Buildだとunitypackageを作れない（多分）というのが一つ。もう一つは、私が.NET CoreのCIもCircleCIに寄せているので、統一して扱えるといいよねというところです。また、Linuxの他にMacでのビルドもできるので（有料プラン）、iOSに、とかも可能になってくるかもしれませんしね。あと、単純にCircleCIが昨今のCIサービスで王者なので、長いものに巻かれろ理論でもある。でも私自身も最近使っていてかなり気に入ってるので、実際良いかと良いかと。コンテナベースで記述するのがとても小気味よいわけです、モダンっぽいし。</p>
<p>ゴールは</p>
<ul>
<li>リポジトリの一部ソース郡から.unitypackageを作る</li>
<li>EditorでUnitTestを行う</li>
<li>IL2CPP/Windowsでビルドする(↑のUnitTestのIL2CPP版を吐く)</li>
</ul>
<p>となります。普通はAndroidやiOSビルドがしたいって話だと思うのですが、私はライブラリAuthorなので、まずそっちの要求のほうが先ということで（そのうちやりたいですけどね！）。Editorテストだけじゃなくて、IL2CPPで動作するか不安度もあるので、そっちのexeも吐ければ嬉しい。できればIL2CPPビルドのものも、ヘッドレスで起動して結果レポーティングまでやれればいいん＆ちょっと作りこめばそこまで行けそうですが、とりあえずのゴールはビルドして生成物を保存するところまでにしておきましょう。そこまで書いてると記事長くなるし。</p>
<h2>認証を通してUnityをCircleCI上で動かす</h2>
<p>CircleCIということでコンテナで動かすんですが、まぁUnityのイメージを持ってきてbatchmodeで起動して成果を取り出すという、それだけの話です。適当に<a href="https://docs.unity3d.com/ja/2018.1/Manual/CommandLineArguments.html">Unityのコマンドライン引数</a>とにらめっこすれば良い、と。</p>
<p>コンテナイメージに関しては、幸い誰か(gablerouxさん)が<a href="https://hub.docker.com/r/gableroux/unity3d/tags">gableroux/unity3d/tags</a>に公開してくれていて、綺麗にタグを振ってくれています。コンテナの良いところっていっぱいあると思いますが、コンテナレジストリが良い具合に抽象化されたファイル置き場として機能するのも素敵なとこですねえ。また、こうして公開してくれていれば、社内CIのUnityインストール管理とかしないで済むのも良いところです。大変よろしい。</p>
<p>で、Unityの実態は <code>/opt/Unity/Editor/Unity</code> にあるので、それを適当に <code>-batchmode</code> で叩けばいいんでしょって話ですが、しかし最大の関門はライセンス認証。それに関してはイメージを公開してくれているgablerouxさんの<a href="https://github.com/GabLeRoux/unity3d-ci-example">GabLeRoux/unity3d-ci-example</a>や、そして日本語では<a href="https://qiita.com/MizoTake/items/2d822e85d33bee359f98">CircleCIでUnityのTest&amp;Buildを雰囲気理解で走らせた</a>に、手取り足取り乗っているので、基本的にはその通りに動かせば大丈夫です。</p>
<p>ただ、ちょっと情報が古いっぽくて、今のUnityだともう少し手順を簡単にできるので（というのを試行錯誤してたら苦戦してしまった！）、少しシンプルになったものを以下に載せます。</p>
<p>まず、ローカル上でライセンスファイルを作る必要があります。これはdockerイメージ上で行います。また、ここで使うイメージはCIで実際に使うイメージと同じバージョンでなければなりません。バージョン変わったらライセンス作り直しってことですね、しょーがない。そのうちここも自動化したくなるかもですが、今は手動でやりましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-txt">docker run -it gableroux/unity3d:2018.3.11f1 bash
cd /opt/Unity/Editor
./Unity -quit -batchmode -nographics -logFile -createManualActivationFile
cat Unity_v2018.3.11f1.alf
</code></pre>
<p>イメージを落としてきて、 <code>-quit -batchmode -nographics -logFile -createManualActivationFile</code> でUnityを叩くと <code>Unity_v***.alf</code> という中身はXMLの、ライセンスファイルの元（まだuseridもpasswordも入力してないので、テンプレみたいなものです)が生成されます。こいつを、とりあえず手元（ホスト側）に持ってきます。<code>docker cp</code>でコンテナ-&gt;ホストにファイルを移動させてもいいんですが、まぁ1ファイルだけなのでcatしてコピペして適当に保存でもOK。</p>
<p>次に<a href="https://license.unity3d.com/manual">https://license.unity3d.com/manual</a>を開いて、上記のalfファイルを上げると <code>Unity_v2018.x.ulf</code> ファイルがもらえます。これが実体です。生成過程でUnityのサイトにログインしているはずで、そのuserid/passwordが元になって、ライセンスファイルの実体が生成されました。中身はXMLです。</p>
<p>で、これは大事な情報なのでCircleCI上のEnvironment Variablesで秘匿しよう、という話になるんですが、改行の入った長いXMLなので、そのまんま中身をコピペるとファイルが、たいていどこか壊れて認証通らなくなります（散々通らないでなんでかなぁ、と悩みました！）。とはいえファイルそのものをリポジトリに上げるのはよろしくないので、<a href="https://qiita.com/MizoTake/items/2d822e85d33bee359f98">CircleCIでUnityのTest&amp;Buildを雰囲気理解で走らせた</a>にあるとおり、暗号化したものをリポジトリに追加して、Environment VariablesにはKeyを追加しましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-txt">openssl aes-256-cbc -e -in ./Unity_v2018.x.ulf -out ./Unity_v2018.x.ulf-cipher -k ${CIPHER_KEY}
</code></pre>
<p>${CIPHER_KEY}は、適当な文字列に置き換えてもらって、そしてこれをCircleCI上のEnvironment Variablesにも設定します。ファイルの置き場所は、とりあえず私は <code>.circleci/Unity_v2018.x.ulf-cipher</code> に置きました、CIでしか使わないものなので。</p>
<blockquote>
<p>またはマルチラインキーの場合は base64を使うことが推奨されているようです =&gt; <a href="https://circleci.com/docs/2.0/env-vars/#encoding-multi-line-environment-variables">Encoding Multi-Line Environment Variables</a>。こちらのほうが良さそうですね。</p>
</blockquote>
<p>あとは <code>.circleci/config.yml</code>を書くだけ、ということで、最小の構成はこんな感じになります。</p>
<pre data-pagefind-ignore="all"><code class="language-yaml">version: 2.1
executors:
  unity:
    docker:
      # https://hub.docker.com/r/gableroux/unity3d/tags
      - image: gableroux/unity3d:2018.3.11f1
jobs:
  build-test:
    executor: unity
    steps:
      - checkout
      - run: openssl aes-256-cbc -d -in .circleci/Unity_v2018.x.ulf-cipher -k ${CIPHER_KEY} &gt;&gt; .circleci/Unity_v2018.x.ulf
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .circleci/Unity_v2018.x.ulf || exit 0
workflows:
  version: 2
  build:
    jobs:
      - build-test
</code></pre>
<p><code>-nographics</code>にすることでそのまま叩けるのと、<code>-manualLicenseFile</code>でライセンスファイルを渡してやるだけです。 認証する際の <code>|| exit 0</code> がお洒落ポイントで、認証が正常に済んでもexit code 1が返ってくるという謎仕様なので、とりあえずこのステップは強制的に正常終了扱いにしてあげることで、なんとかなります。なんか変ですが、まぁそんなものです。世の中。</p>
<p>まぁしかし<code>GabLeRoux/unity3d-ci-example</code>の（無駄に）複雑な例に比べれば随分すっきりしたのではないでしょうか。いやまぁ、Unityのイメージ作ってもらってるので感謝ではあるのですけれど、しかしサンプルが複雑なのは頂けないかなあ。私はサンプルは限りなくシンプルにすべき主義者なので。</p>
<h2>.unitypackageを作る</h2>
<p>バッチモードでは <code>-executeMethod</code> により特定のstatic methodが叩けるので、それでunitypackageを作るコードを用意します。 今回は <code>Editor/PackageExport.cs</code> に以下のようなファイルを。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

// namespaceがあると動かなさそうなので、グローバル名前空間に置く
public static class PackageExport
{
    // メソッドはstaticでなければならない
    [MenuItem(&quot;Tools/Export Unitypackage&quot;)]
    public static void Export()
    {
        // configure
        var root = &quot;Scripts/CISample&quot;;
        var exportPath = &quot;./CISample.unitypackage&quot;;

        var path = Path.Combine(Application.dataPath, root);
        var assets = Directory.EnumerateFiles(path, &quot;*&quot;, SearchOption.AllDirectories)
            .Where(x =&gt; Path.GetExtension(x) == &quot;.cs&quot;)
            .Select(x =&gt; &quot;Assets&quot; + x.Replace(Application.dataPath, &quot;&quot;).Replace(@&quot;\&quot;, &quot;/&quot;))
            .ToArray();

        UnityEngine.Debug.Log(&quot;Export below files&quot; + Environment.NewLine + string.Join(Environment.NewLine, assets));

        AssetDatabase.ExportPackage(
            assets,
            exportPath,
            ExportPackageOptions.Default);

        UnityEngine.Debug.Log(&quot;Export complete: &quot; + Path.GetFullPath(exportPath));
    }
}
</code></pre>
<p>ちょっとassetsを取るところが長くなってしまっているのですが、.cs以外をフィルタするコードを入れています。たまに割と入れたくないものが混ざっていたりするので。あとは、CIではライセンス認証のあとに、これを叩くコマンドと、artifactに保存するコマンドを載せれば良いでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-yml">version: 2.1
executors:
  unity:
    docker:
      # https://hub.docker.com/r/gableroux/unity3d/tags
      - image: gableroux/unity3d:2018.3.11f1
jobs:
  build-test:
    executor: unity
    steps:
      - checkout
      - run: openssl aes-256-cbc -d -in .circleci/Unity_v2018.x.ulf-cipher -k ${CIPHER_KEY} &gt;&gt; .circleci/Unity_v2018.x.ulf
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .circleci/Unity_v2018.x.ulf || exit 0
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -executeMethod PackageExport.Export
      - store_artifacts:
          path: ./CISample.unitypackage
          destination: ./CISample.unitypackage
workflows:
  version: 2
  build:
    jobs:
      - build-test
</code></pre>
<p>完璧です！</p>
<p>コマンドに関しては普通にWindowsのUnity.exeで試してから挑むのがいいわけですが、一つWindowsには難点があって、ログが標準出力ではなく %USERPROFILE%\AppData\Local\Unity\Editor\Editor.log にしか吐かれないということです。というわけで、Editor.logを開いてにらめっこしながらコマンドを作り込みましょう。めんどくせ。</p>
<h2>EditorでUnitTestを行う</h2>
<p>基本的に <code>-runEditorTests</code> をつけるだけなのですが、注意点としては <code>-quit</code> は外しましょう。ついてると正常に動きません（はまった）。</p>
<pre data-pagefind-ignore="all"><code class="language-yml">version: 2.1
executors:
  unity:
    docker:
      # https://hub.docker.com/r/gableroux/unity3d/tags
      - image: gableroux/unity3d:2018.3.11f1
jobs:
  build-test:
    executor: unity
    steps:
      - checkout
      - run: openssl aes-256-cbc -d -in .circleci/Unity_v2018.x.ulf-cipher -k ${CIPHER_KEY} &gt;&gt; .circleci/Unity_v2018.x.ulf
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .circleci/Unity_v2018.x.ulf || exit 0
      
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -executeMethod PackageExport.Export
      - store_artifacts:
          path: ./CISample.unitypackage
          destination: ./CISample.unitypackage

      - run: /opt/Unity/Editor/Unity -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -runEditorTests -editorTestsResultFile ./test-results/results.xml
      - store_test_results:
          path: test_results
workflows:
  version: 2
  build:
    jobs:
      - build-test
</code></pre>
<p><code>editorTestsResultFile</code> で指定し、store_test_resultsに格納することでCircleCI上でテスト結果を見ることができます。</p>
<p>と、思ったんですが、なんかテスト周りは全体的にうまく動かせてないんで後でまた調べて修正します……。或いは教えてくださいです。</p>
<h2>IL2CPP/Windowsでビルドする</h2>
<p>なぜWindowsかというと、私がWindowsを使っているからというだけなので、その他のビルドが欲しい場合はそれぞれのビルドをしてあげると良いんじゃないかと思います！</p>
<p>いい加減コンフィグも長くなってきましたが、<code>-buildWindows64Player</code>でビルドして、zipで固めてぽんということです。</p>
<pre data-pagefind-ignore="all"><code class="language-yml">version: 2.1
executors:
  unity:
    docker:
      # https://hub.docker.com/r/gableroux/unity3d/tags
      - image: gableroux/unity3d:2018.3.11f1
jobs:
  build-test:
    executor: unity
    steps:
      - checkout
      - run: openssl aes-256-cbc -d -in .circleci/Unity_v2018.x.ulf-cipher -k ${CIPHER_KEY} &gt;&gt; .circleci/Unity_v2018.x.ulf
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .circleci/Unity_v2018.x.ulf || exit 0
      
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -executeMethod PackageExport.Export
      - store_artifacts:
          path: ./CISample.unitypackage
          destination: ./CISample.unitypackage

      - run: /opt/Unity/Editor/Unity -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -runEditorTests -editorTestsResultFile ./test-results/results.xml
      - store_test_results:
          path: test_results

      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -noUpm -logFile -projectPath . -buildWindows64Player ./bin-win64/CISample.exe
      - run: apt-get update
      - run: apt-get install zip -y
      - run: zip -r CISampleWin64Binary.zip ./bin-win64
      - store_artifacts:
          path: ./CISampleWin64Binary.zip
          destination: ./CISampleWin64Binary.zip
workflows:
  version: 2
  build:
    jobs:
      - build-test
</code></pre>
<p>これで一旦は希望のものは全てできました！</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/55688013-c3764380-59ae-11e9-8ab8-0219a2f5183e.png" width=640 />
</p>
<p>以上な感じが最終結果になります。</p>
<h2>CircleCIでUnityビルドはプロダクトで使えるか</h2>
<p>今回の例のようなライブラリ程度だと、リソースもほとんどないしリポジトリも全然小さいんでいいんですが、実プロダクトで使えるかというと、どうでしょう。まずリポジトリのサイズの問題で、次にビルド時間の問題で。クソデカい＆高級マシンでも焼き上がり1時間は普通とか、そういう世界ですものね。常識的に考えてこれをクラウドでやるのは難しそう。オンプレのCircleCI Enterpriseだったら行けそうな気もしますが、どうでしょうねえ。しかしJenkinsマンやるよりは、こちらのほうが夢があるのと、実際うまくクラスタを組めば、ばかばかコンテナ立ち上げて同時並列でー、というビルドキュー長蛇列で待ちぼうけも軽減できたりで、良い未来は感じます。試してみたさはあります、あまりJenkinsに戻りたくもないし。</p>
<p>一回構築してみれば、ymlもそこそこシンプルだし、（ライセンス認証以外は）ymlコピペで済むので、Unity Cloud Build使わなくてもいいかなー、色々自由にできるし。っていうのはあります。というわけで、是非一緒にUnityでCircleCI道を突き進んでみましょう:) 今回はAndroidビルドやiOSビルドという面倒くさいところには一切手を付けてませんが、まぁほとんどビルドできてるわけで、やりゃあできるでしょう。いや、でもiOSとか死ぬほど面倒くさ（そう）なので、そのへんよしなにやってくれつつマシンパワーもそこそこ用意してくれるUnity Cloud Buildは偉い。</p>
<p>ところでこのブログ、ymlのシンタックスハイライトがない模様。やべー。このブログのメンテこそが一番最重要な気がしてきた。</p>
</div>
<h1 data-pagefind-sort="date:2018-12-30" data-pagefind-meta="published:2018-12-30"><a href="https://neue.cc/2018/12/30_573.html">2018年を振り返る</a></h1>
<ul class="date"><li>2018-12-30</li></ul>
<div class="entry_body"><p>毎年恒例ということで、今年も振り返ります。だいたい30日に書いてるのですが、理由は12月30日は私の誕生日なので色々ちょうどよいかな、と。いよいよ35歳なので、例のあれ、35年定年説になりました。そのへんどうでもいい外れ値をひた走ってるので一般論はあんま関係ないんですが、体力は落ちてる実感ありますね！肥ったし。文章はどんどんてきとーになってくし。</p>
<p>と、いうわけで、今年は客観的には激動の年です。会社辞めて会社作って会社作って。私生活でも色々あり、イベントが多くて中々どうして落ち着かなかった年です。そのため成果という点では不完全燃焼が否めないですね、どうしても集中しきれないし時間も上手く捻出できないし。GitHubの草生やしで考えれば、もう全然すっかすっか。その中でUniRx.AsyncやMagicOnion2など、今年もちゃんと大きめの成果を出せたのは、意地です。特にUniRx.Asyncの開発はしんどかった……(MagicOnion2のほうはCysharpとしての時間を使えたので良かったんですが、UniRx.Asyncの開発のための時間捻出はめっちゃ厳しかった）。まぁ、ダラダラ草生やすことをKPIにするよりは、一発ホームランをKPIにしたほうがエンジニアの脳トレ的にも随分かいいんじゃないでしょーか？</p>
<p>ここ数年は毎年、C#を書く技量が向上してていいわー、と言い続けてるんですが、今年も随分と向上しました！特に大きかったのはUniRx.Asyncの開発で、これのためにasync/awaitやTask周りの生態系を全部自前実装したので、曖昧な理解だった、ということに気づいてすらいなかったものも、全て完全に理解したので、私自身の能力の向上としてかなり大きいですね。車輪の再発明は良いものです。</p>
<p>きちんと最前線のC#を書けている自信がありますし、対外的な証明もできているので、能力的な意味では老害とはまだ遠そうでいいんじゃないでしょーか。色々な言語に手を出して成長、ってのも悪くはないでしょうが、一つの言語を集中的に深掘りするというのもまた成長の道かと思います。中途半端な深掘りだと言語固有の話になって応用がー、みたいなところがなくもないのですが、徹底的に深掘りすりゃあ、逆に言語固有じゃなくなって、応用が効いてくる領域に入るのです。もしなんとなく成長の限界を感じて他の言語やったほうがいいかな、とか思うのだとしたら、多分、全然深掘りが足りないじゃないかしら？と、思ったりね、します。実に上から目線ですが！</p>
<h2>お仕事</h2>
<p>先に仕事の話を考えると、<a href="http://neue.cc/2018/04/02_563.html">株式会社グラニを退任しま</a>した。私だけではなく皆バラバラになっているので（もちろんマイネットさんのほうで引き続きタイトル開発にあたっているメンバーもいます）、グラニという会社の始まりから終わりまで、ですね。結末として、悪くはない（退職時の未払いなどももちろんありませんし、エンジニアメンバーは他社に転職した人も、みな良いところに移れているので、グラニという会社が経験としてもキャリアとしても、良いものを提供できたのではないかなー、と思ってます、まぁ役員としてはこれが最後の仕事の成果という形になるのでそう思わせてください……！）ですが、もちろん、最良ではない、です。</p>
<p>CTOとしてどうだったかというと、会社として一点突破な凡百じゃない他にない個性を作れたし、悪くないところまで突き進めた、という点ではよくやれてはいますが（別に「素で」やってるわけじゃなくて割としっかり戦略組んでやっての結果なのでそれなりに大変なんですよ！）、最良のエンディングではないという結果をもって、ベストじゃあないでしょうね。実際反省点はめちゃくちゃ多いです。世の中、結果が全てで、一般論のハンマーを叩き返すには結果を出していかなきゃいけないので、今回の5年間の結果では一般論に反逆はできないんで、次はもっとうまくやる。という決意もあります。</p>
<p>退任後には<a href="http://new-world.co/">New World, Inc.</a>を設立しました。設立じゃない道も模索していたのですが、うまくまとまらなかったので、とりあえずやったことないしやってみっか、と。なんで株式会社なのかというと、とりあえず作ってみたかったから、以外の理由はない、です。次の会社のスタートまでの間(4ヶ月ぐらい)は、この会社名義、といってもほぼ個人事業主として仕事していました。一応会社としてのビジネスプランも考えてはいたのですが、時間的なものもあって結局ほとんど個人事業主的な働き方に終始しました。</p>
<p>こちらは死ぬほど反省点ありますね……。あまり表明するのもアレですが、多分、まぁ、請負で作業するの自分には向いてないんだとは思います……。それ以外にも単純にスキル不足があって、自分が組んできた環境ではなく自由度もそう高くない中でのパフォーマンスチューニング、みたいなことをするための手札があんまなかったですね。こういうスキルって、多分テクニカルサポート（それも高額なプレミア契約の）の人が持つスキルなんでしょうけれど、明らかに自分の手札にはなかったのを自覚しました。ここはもう能力不足だし、あったほうがいいのは間違いないんで、来年は伸ばしていこうかな、とは思ってます。</p>
<p>グラニでのトラブルシューティングは、徹夜で張り付いて空いてそうな時間にサーバー一時的に止まるの強行でダンプ取ったり、本番環境データベース相当のをコピーして好きに実験したり、既に豊富に用意しているモニタリング系システムにクエリ書いたり追加したり、そもそも根本からライブラリを自作のものを開発して取り替えたりと、権限に甘えきったことやってたんで、まぁ世の中そんなイージーモードなわけないぞ、と。そりゃそうだ。会社としてはイージーモードな世界を作るのが大事で、個人スキルとしてはハードモードな世界でやりきれる能力をつけるのが大事。両面から頑張っていきたい。</p>
<p>そして、<a href="http://neue.cc/2018/10/31_570.html">株式会社Cysharpを設立しました</a>。設立に関する話は←の記事と、<a href="https://gamebiz.jp/?p=225825">Social Game Infoでのインタビュー</a>を読んでいただければなのですが、まず、この座組のインパクトはめっちゃあったかな、と！社名もそうですが！大きなことがやれそうな予感があります。来年はそうした予感を実現していくという、チャレンジの年です。会社としてもそれなりな規模にはしていきたいと思っているので、そのへんもやっていければ。</p>
<p>引き続きゲーム関連で勝負をかけるわけですけれど、ゲーム関連から攻めるのがC#にとって一番、あるいは唯一芽があるから、というのも大きくて。私はインターネットで育ってきたので、ウェブに話題が少ない言語や環境って嫌なんですよね、だからエンタープライズで採用伸びてるとか世界的には数字は良いんだとか、そういうの興味なくて。目の前のインターネットの世界で話題になり誰もが使う言語、であって欲しい。C#が。誰もが使い、話題にし、エコシステムが形成され、若い人がどんどん使う。そこへ向かうには、ゲームやUnityと絡めていくことが唯一の道だと思っています（個人的にはXamarinでは無理でしょう、と思ってるので）。そしてそこに対して貢献したいのです。それはMicrosoftやUnityの「外の人」だからこそできることでもある。</p>
<h2>C#</h2>
<p><a href="http://neue.cc/2018/07/12_567.html">UniTask(UniRx.Async)のリリースによるコンセプト実証</a>と<a href="http://neue.cc/2018/12/25_571.html">大規模アップデートによる真の実用化</a>。これはNew Worldとして動き出してちょい過ぎぐらいから作成に着手しました。私の中でこれのリリースには大きな意味があって、New World, Incとしての名刺、つまるところ私自身の自信が欲しかったのです。特にUnity関連においてUniRxは前の世代の話なので、今の世代で絶対の自信を持って薦められるものが欲しかった。そういうものがあると自分にも自信ができるんで、交渉も強気に迫れますからね。</p>
<p>UniTaskはUnityに最適化したasync/await生態系の再発明です。これやりきれる人って世の中いないんで、成果として世の中に存在するのはめっちゃレアなんじゃないでしょーか。と思える程度にはいい感じだと思います。しかし例によってまだバグや機能改善がかなり残っているのに、いったん放置が始まっていて、これは本当に私の悪癖ですね……。来年の抱負は放置しない、です。ほんと。ほんと。</p>
<p>もう一個が<a href="http://neue.cc/2018/12/28_572.html">MagicOnion v2のリリース</a>で、これはグラニでのやり残したことの一つの消化、という意味合いもあります（技術的にはもう一つやり残したことありますけれど、「まともな」UIライブラリの作成とプラクティスの構築とか）。そして、Cysharpで掲げる「C#大統一理論」のキーパーツですね。応用事例をどんどん作っていきたいます。</p>
<p>また、MagicOnionはリポジトリを<a href="https://github.com/Cysharp/MagicOnion/">Cysharp/MagicOnion</a>に移しています。これはメンテしっかりやっていくぞ、の現れですね！他にUniRxやMessagePack for C#などもorgnaization(Cysharpじゃなくて中立的組織）に移したいなあ、とは思ってます。そうした継続的メンテナンス体制を作って、永く行き続けていくものになっていければいいなあ、と。まあカウボーイエンジニアから会社経営者になったわけで、そのへんも世の中によりよい形を、ということで。</p>
<p>パフォーマンスの追求は引き続きやっていきたいテーマで、一旦のまとめをCEDEC 2018で<a href="http://neue.cc/2018/08/25_568.html">最速のC#の書き方 - C#大統一理論へ向けて性能的課題を払拭する</a>と題して講演しました。こういうのってどのへんまでDeepでDopeに書けばいいのか難しくて、浅瀬ちゃぷちゃぷなんちゃうんちゃうんな思いと戦いつつ、実体験ベースってのもあり良いちゃあ良かったんじゃないでしょうか。</p>
<p>Unity ECSはもっと力入れてやりたかったんですが、ほとんど出来なかったですね。LTドリブン開発だー、と思ったけれどロクにできず<a href="http://neue.cc/2018/10/23_569.html">Memory Management of C# with Unity Native Collections</a>でお茶濁しした程度だったので……。物理エンジンと絡めて、やりたいネタが2年ぐらい前からあって、ECSの登場でまさに最適なプラットフォーム！これでちゃりんちゃりんする！と考えてたのに何も実装できず一年が終わるとは……。来年こそリベンジします。</p>
<h2>漫画/音楽/ゲーム/その他…</h2>
<p>今年感動したゲームは<a href="https://www.jp.playstation.com/games/detroit-become-human/">Detroit: Become Human</a>一択ですねえ、もう全く悩まず。映像も音楽もシナリオもシステムも、あらゆる点で監督(デヴィッド・ケイジ)の神経質そうな（ほんと！）目が行き届いていて、完璧。ただの雰囲気ゲーにならずゲームとしてもちゃんと面白く仕上がっているので、非の打ち所がない（リプレイが面倒くさくてエンディングコンプがダルい問題はありますが、一周＋αの体験だけで十分価値あるんで良いんじゃないでしょーか）。</p>
<p>漫画は<a href="https://www.amazon.co.jp/dp/B07H29J6F1/">うめざわしゅん - えれほん</a>がとても良くて、三話(+1)入った短編集で<a href="http://denshi-birz.com/erewhon/">二話目は無料で読めます</a>。とにかくまぁ漫画が上手い。まぁあと古いですが今年読んだんで<a href="https://www.amazon.co.jp/dp/B01D1Q520C/">内田 春菊 - 目を閉じて抱いて</a>も。全然古くないというかむしろ今の時代のほうが共感できるんちゃうんちゃうん、と(といっても1994-2000だとそこまで古くもないのかー、いや、古いかー)。</p>
<p>音楽は、今年まぁまぁケンドリック・ラマーの記事を目にしたから（来日で一悶着あったからかしらん）、というわけでもないですが最新作のDAMN、ではなくてその前の<a href="https://www.amazon.co.jp/dp/B00UDDM7K0">To Pimp A butterfly</a>をよく聞いてました。特に一曲目のWesley's Theory。もともとこれ作曲してるFlying Lotusが好きというのもありますが、Flying Lotusの手掛けた中でも傑作と思ふ。アルバム全編を貫くストーリーも重たく、比喩も強烈で、言葉の強さを心底叩き込んでくる。そりゃ心震えますよ！</p>
<p>映画は、これも古いですがNetflixで見た<a href="https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B4">ニコラス・ウィンディング・レフン - ドライヴ</a>が良かった。映像美とバイオレンス！まぁーもうとにかく最高に格好良い。こりゃすげえ、と思わず監督の大ファンになって初期作のプッシャー三部作、これはまぁまぁだったんですが、最新作の<a href="http://gaga.ne.jp/neondemon/">ネオン・デーモン</a>が……。設定も良い。映像も良い。プロットも悪くない。映画としてはつまらない。というしょっぱい代物に……。脚本と構成が悪いんかなー、もう少しうまくやりゃあ、めっちゃ良くなったはずなのに感で超もったいない……。設定と映像は本当に好みなだけに、あうあうって感じ。何れにせよ次回作あったら見るよ！と思ったら、来年(2019)にAmazon Prime Videoのシリーズとして<a href="https://www.youtube.com/watch?v=_ZHMbh_GTkY">Too Old to Die Young</a>というドラマを撮ってるそうで。日本に来るのかな、Netflixだったら絶対来るはずだけどAmazon Prime Videoだとどうなんでしょ。</p>
<p><a href="http://shibari.jp/red/index.html">Hajime Kinoko写真集「Perfect Red」</a>は、写真集はもちろん、個展とショーも見に行きましたが、圧倒的な空間で。ショーだと、人間の表現として、静と動の中間のような世界なんですよね。例えば、静が彫刻、動がバレエのようなものだったりだとすると、その間。ほとんど止まっているのだけれど、手の動き、顔の表情、そして縄が皮膚に言葉を与えていて。表現としては未成熟というかアングラ感が拭えないですが（決して悪いことではなくそれはそれでいいんですが）、もっと表に出れば出るほど洗練されていくのでは、というわけで来年も見たいですね。</p>
<h2>来年は</h2>
<p>とにもかくにもCysharpをしっかり始動させます。会社の理念がC#とOSSを中心に、というのもあるので、技術のコミュニティ貢献も引き続き、ですね。そしてメンテやIssueを放置しないという抱負は、ただの意気込みじゃなくて組織的な解決となるよう、具体的に動いていきます。</p>
<p>技術的には、今年は色々な言い訳がありますが、チャレンジがなかったなー、というのは否めないです。UniRx.AsyncもMagicOnion2も延長線上ですから。時間がない中で一定の成果を出すことが必須という状況下だったのでしゃーなし、という言い訳もありますが、来年こそは今までの延長線上にない別のことも手掛けたい、と毎年言ってますが、今年も思います。とりあえずとにかくUnity ECSは絶対やりますから……！</p>
<p>ともあれ、<a href="https://cysharp.co.jp/">Cysharp</a>の活動にご期待下さい。人も募集ちゅ（します、そろそろ）。です。そろそろお問い合わせフォームぐらいはつけたい。</p>
</div>
<h1 data-pagefind-sort="date:2018-12-28" data-pagefind-meta="published:2018-12-28"><a href="https://neue.cc/2018/12/28_572.html">MagicOnion v1 -> v2リブート, gRPCによる.NET Core/Unity用ネットワークエンジン</a></h1>
<ul class="date"><li>2018-12-28</li></ul>
<div class="entry_body"><p>先にCygames Engineers' Blogで<a href="http://tech.cygames.co.jp/archives/3181/">MagicOnion – C#による .NET Core/Unity 用のリアルタイム通信フレームワーク</a>としてリリースを出しましたが、改めまして、MagicOnionというフレームワークを正式公開しました。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">GitHub - Cysharp/MagicOnion</a></p>
<p>MagicOnionはAPI通信系とリアルタイム通信系を一つのフレームワークで賄う、というコンセプトを元に、前職のグラニで「黒騎士と白の魔王」の開発において必要に迫られて捻り出されたものでした。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/LrPbFMPfMXWJKj" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/grpchttp2-api-streaming" title="「黒騎士と白の魔王」gRPCによるHTTP/2 - API, Streamingの実践" target="_blank">「黒騎士と白の魔王」gRPCによるHTTP/2 - API, Streamingの実践</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>で、今更気づいたのがMagicOnionって正式リリースしてなかったんですよね、このブログでも↑のような形でしか触れていなくて、公式ドキュメントも貧弱な謎フレームワークだったという。今回Ver2って言ってますが、その前はVer0.5でしたし。まぁここでは便宜的にv1と呼びます。</p>
<p>何故に正式リリースまで行かなかったかというと、リアルタイム通信部分が微妙だったから。↑のp.39-40で説明していますが、Unary + ServerStreamingという構成で組んだのが、かなり開発的に辛かったんですね。時間的問題もあり強行するしかなかったんですが、ちゃんと自分が納得いく代案を出せない限りは、大々的には出していけないなあ、と。</p>
<p>その後すったもんだがあったりなかったりで、プレーンなgRPCでリアルタイム通信を組む機会があって、↑の時に考えていたDuplexStreaming一本で、コマンドの違いをProtobufのoneofで吸収する、という案でやってみたのですが、すぐに気づきましたね、これ無理だと。UnaryはRPCなのですが、Duplex一本はRPCじゃないんで、ただたんにoneofをswitchしてメソッド呼び出す、だけじゃ全然機能足りてない、と。</p>
<p>ただまぁコネクション的にはDuplex一本案は間違ってなさそうだったので、その中で手触りの良いRPCを組むにはどうすればいいか……。と、そこでMagicOnionをリブートさせるのが一番手っ取り早いじゃん、というわけで着手したりしなかったりしたりしたのでした。その間に<a href="https://cysharp.co.jp/">Cysharpの設立</a>の話とかもあり、事業の中心に据えるものとしても丁度良かったという思惑もあります。</p>
<p>早速（？）Qiitaでも何件か紹介記事書いてもらいました。</p>
<ul>
<li><a href="https://qiita.com/mitchydeath/items/cecf01493d1efeb4ae55">Unity+MagicOnionで超絶手軽にリアルタイム通信を実装してみた</a></li>
<li><a href="https://qiita.com/yKimisaki/items/1d55b08f3e7bcae46585">MagicOnion v2を使ってUnity IL2CPPでgRPC通信をする</a></li>
<li><a href="https://qiita.com/shigezo/items/66220c611be4d014463a">Docker を利用して MagicOnion &amp; .Net Core の開発環境を整える</a></li>
</ul>
<h2>v1 -&gt; v2</h2>
<p>Unary系(API通信系)はほとんど変わっていません。それは、v1の時点で十分に高い完成度があって、あんま手を加える余地はなかったからですね。ただしフィルターだけ戻り値をTaskからValueTaskに変えています。これはフィルターの実行はメソッド実行前に同期的にフック(ヘッダから値取り出してみるとか)するだけ、みたいなものも多いので、TaskよりValueTaskのほうが効率的に実行できるからですね。</p>
<p>元々フィルターを重ねることによるオーバーヘッドを極小にするため、純粋にメソッド呼び出しが一個増えるだけになるように構成してあったのですが、更により効率的に動作するようになったと思います。</p>
<p>SwaggerのUIを更新するのと、HttpGatewayの処理を効率化するのが課題として残っているので、それは次のアップデートでやっていきます。</p>
<p>また、Unity向けにはコードジェネレート時にインターフェイス定義でTaskをIObservableに変換していたのですが、今のUnityは.NET 4.xも使えるということで、インターフェイスはそのまま使ってもらうようにしています。Taskのままで。</p>
<h2>StreamingHub</h2>
<p>の、導入に伴って、v1でリアルタイム通信系をやるための補助機構である StreamingContextRepository を廃止しました。StreamingContextRepositoryは、まぁ、正直微妙と思っていたのでなくせて良かったかな。決して機能してないわけではないのですけれど。</p>
<p>代わりのコネクションを束ねる仕組みはGroupという概念を持ってきました。これはASP.NETのWebsocketライブラリである<a href="https://github.com/aspnet/AspNetCore/tree/master/src/SignalR">ASP.NET Core SignalR</a>にあるものを、再解釈して実装しています。</p>
<p>MagicOnionのGroupの面白いところは、裏側の実装を変えられることで、デフォルトはImmutableArrayGroupという、MORPGのようなルームに入って少人数で頻繁にやり取りするようなグルーピングに最適化された実装になっています。もう一種類はConcurrentDictionaryGroupという、こちらはMMORPGやグローバルチャットのような、多人数が頻繁に出入りするようなグルーピングのための実装です。更に、RedisGroupというバックエンドにRedisのPubSubを置いて複数サーバー間でグループを共有するシステムも用意しています、これはチャットや、全体通知などに有効でしょう。</p>
<p>また、GroupにはInMemoryStorage[T]というプロパティが用意されていて、グループ内各メンバーに紐付いた値をセットできるようにしています。これは、通信のブロードキャスト用グループの他に、値の管理のためにConcurrentDictionary[ConnectionId, T]のようなものを用意してデータを保持したりが手間で面倒くさいんで、いっそグループ自体にその機能持ってたほうが便利で最高に楽じゃん、という話で、実際多分これめちゃくちゃ便利です。</p>
<h2>まとめ</h2>
<p>というわけで、リブートしました！最初チョロいと思ってたんですが、割とそんなことはなくて、この形にまとめあげるまではそれなりに大変でした……。の甲斐もあって、今回のMagicOnionはかなり自信を持って推進できます。以前はそもそもgRPC本体をフォークして魔改造したり、というのもあったのですが、今は公式ビルドを使えるようになったのでUnity向けにも良い具合になってきています。</p>
<p>MagicOnion2の内容は、(v1を)実際に使ってリリースした後の反省点が盛り込まれているので、そういう点で二周目の強みがあります。最初からこの形で出すのは絶対にできないであろうものなので、しっかりと経験が活かされています。実プロダクトで使って初めて見えるものっていっぱいありますからねー。とはいえv1はv1で大きな役割を果たしたと思いますし、まぁあと自分で言うのもアレですが「黒騎士と白の魔王」が証明したこと(gRPCがUnityでいけるんだぞ、という)ってメチャクチャ大きかったなあ、と。</p>
<p>CysharpとしてもMagicOnion、使っていきますし、ほんと是非是非使ってみてもらえると嬉しいです。コードジェネレーターもついにWin/Mac/Linux対応しましたので（まだ微妙にバグいのですが年内か、年明け早々にはなんとかします）、ガッツリと使っていけるのではないかとです。</p>
</div>
<h1 data-pagefind-sort="date:2018-12-25" data-pagefind-meta="published:2018-12-25"><a href="https://neue.cc/2018/12/25_571.html">UniTask(UniRx.Async)から見るasync/awaitの未来</a></h1>
<ul class="date"><li>2018-12-25</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2018/c-sharp">C# Advent Calendar 2018</a>大遅刻会です。間に合った。間に合ってない。ごめんなさい……。今回ネタとして、改めてコード生成に関して、<a href="http://neue.cc/2017/12/04_560.html">去年は「動的」な手法を解説した - Introduction to the pragmatic IL via C#</a>ので、現代的な「静的」な手法について説明してみよう、と考えていたのですが、そういえばもう一つ大遅刻がありました。</p>
<p>7月に<a href="http://neue.cc/2018/07/12_567.html">UniTask - Unity + async/awaitの完全でハイパフォーマンスな統合</a>という記事を出して、リリースしたUniTaskですが、その後もちょこちょこと更新をしていて、内部実装含め当初よりもかなり機能強化されています。といった諸々を含めて、<a href="https://connpass.com/event/95696/">Unity 非同期完全に理解した勉強会</a>で話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/BtNztL3wrlBCWN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/deep-dive-asyncawait-in-unity-with-unitaskunirxasync" title="Deep Dive async/await in Unity with UniTask(UniRx.Async)" target="_blank">Deep Dive async/await in Unity with UniTask(UniRx.Async)</a> </strong> </div>
<p>9月！更新内容の告知もしてなければ、この発表のフォローアップもしてない！最近はこうした文章仕事がめっちゃ遅延するようになってしまいました、めっちゃよくない傾向です。来年はこの辺もなんとかしていきたい。</p>
<p>と、いうわけで、予定を変えてUniRx.Asyncについて、というか、それだとUnity Advent Calendarに書けよって話になるので、UniRx.Asyncは独自のTask生態系を作っている、これは.NET Core 2.1からのValueTaskの拡張であるIValueTaskSourceに繋がる話なので、その辺を絡めながら見ていってもらえると思います。</p>
<h2>Incremental Compilerが不要に</h2>
<p>告知が遅延しまくっている間にUnity 2018.3が本格リリースされて、標準でC# 7.xに対応したため、最初のリリース時の注釈のような別途Incremental Compiler(preview)を入れる必要がなくなりました。Incremental Compiler、悪くはないのですが、やっぱpreviewで怪しい動きもしていたため、標準まんまで行けるのは相当嬉しいです。というわけで今まで敬遠していた人も早速試しましょう。</p>
<h2>new Progress[T] is Evil</h2>
<p>これは普通の.NETにも言える話なのですが、C#のasync/awaitの世界観では進捗状況はIProgress[T]で通知していくということになっています(別にAction[T]でよくね？そっちのほうが速いし、説はある)。進捗はReport(T value)メソッドで通知していくことになりますが、こいつは<a href="https://referencesource.microsoft.com/#mscorlib/system/progress.cs,92">必ずSynchronizationContext.Post経由で値を送ります</a>。これがどういうことかというと、Unityだとfloatを使う、つまりIProgress[float]で表現する場合が多いはずですが、なんと、ボックス化します。(If T is a value type, it will get boxed here.)じゃねーよボケが。アホか。これはオプションで回避不能なので、new Progress[T]は地雷だと思って「絶対に」使わないようにしましょう。</p>
<p>代わりにUniRx.AsyncではProgress.Createを用意しました。これはSynchronizationContextを使いません。もしSyncContext経由で同期したいならマニュアルでやってくれ。Unityの場合、進捗が取れるシチュエーションはメインスレッド上のはずなので、ほとんどのケースでは不要なはずです。</p>
<p>こういった、あらゆる箇所での.NET標準の余計なお世話を観察し、Unityに適した形に置き直していくことをUniRx.Asyncではやってるので、async/await使うならUniRx.Asyncを使ったほうがいいのです。標準のも、今の時代で設計するならこうはなってないと思うんですけどね、まぁ時代が時代なのでshoganai。</p>
<h2>コルーチンの置き換えとして</h2>
<p>コルーチン、或いはRxでできた処理は、改めて全部精査して、全てasync/awaitで実装できるようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-txt">Add UniTask.WaitUntil
Add UniTask.WaitWhile
Add UniTask.WaitUntilValueChanged
Add UniTask.WaitUntilValueChangedWithIsDestroyed
Add UniTask.SwitchToThreadPool
Add UniTask.SwitchToTaskPool
Add UniTask.SwitchToMainThread
Add UniTask.SwitchToSynchronizationContext
Add UniTask.Yield
Add UniTask.Run
Add UniTask.Lazy
Add UniTask.Void
Add UniTask.ConfigureAwait
Add UniTask.DelayFrame
Add UniTask.Delay(..., bool ignoreTimeScale = false, ...) parameter
</code></pre>
<p>概ね名前からイメージ付くでしょう、イメージ通りの挙動をします。こんだけ用意しておきゃほとんど困らないはず（逆に言えば、標準のasync/awaitには何もありません）</p>
<p>ちなみにSwitchTo***は、最初のVisual Studio Async CTP(お試しエディション)に搭載されていたメソッドで、すぐに廃止されました。というのも、async/awaitが自動でスレッド(SynchronizationContext)をコントロールするというデザインになったからですね。あまりにも最初期すぎる話なのでこの辺の話が残っているものも少ないのですが、ちゃんと<a href="https://ufcpp.wordpress.com/2011/04/13/async-ctp-refresh/">岩永さんのブログには残っていた</a>ので大変素晴らしい。</p>
<p>UniRx.Asyncでは不要なオーバーヘッドを避けるため（そもそも特にUnityだとメインスレッド張り付きの場合のほうが多い）、自動でSynchronizationContextを切り替えることはせず、必要な場合に手動で変更してもらうというデザインを取っています。というか、今からasync/await作り直すなら絶対こうなったと思うんだけどなぁ、どうなんでしょうねぇ。ちょっとSynchronizationContextに夢見すぎだった時代＆Windows Phone 7（うわー）とかの要請が強すぎたせいっていう時代背景は感じます。</p>
<h2>Everything is awaitable</h2>
<p>考えられるありとあらゆるものをawait可能にしました。AsyncOperationだけじゃなくてWWWやJobHandle（そう、C# Job Systemもawaitできます！）、そしてReactivePropertyやReactiveCommand、uGUI Events(button.OnClickAsyncなど)からMonoBehaviour Eventsまで。</p>
<p>さて、AsyncOpeartionなど長さ1の非同期処理がawait可能なら、そらそーだ、って話なのですが、イベントがawait可能ってどういうこっちゃ、というところはあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ようするところこんな風に待てる
async UniTask TripleClick(CancellationToken token)
{
    await button.OnClickAsync(token);
    await button.OnClickAsync(token);
    await button.OnClickAsync(token);
    Debug.Log(&quot;Three times clicked&quot;);
}
</code></pre>
<p>コレに関してはスライドに書いておきましたが、「複雑なイベントの合成」をする際に、Rxよりも可読性良く書ける可能性があります。</p>
<p>Rxは「複雑なイベントハンドリング」を簡単にするものじゃなかったの！？という答えは、YesでもありNoでもありで、複雑なものは複雑で、難しいものは難しいままです。イベントハンドリングは手続き的に記述出来ない（イベントコールバックが飛び飛びになる)ため、コールバックを集約させて合成できるRxが、素のままでやるより効果的だったわけですが、async/awaitはイベントコールバックを手続き的に記述できるため、C#のネイティブのコントロールフロー(for, if, whileなど)や自然な変数の保持が可能になります。これは関数合成で無理やり実現するよりも、可読性良く実現できる可能性が高いです。</p>
<p>単純なものをasync/awaitで記述するのは、それはそれで効率やキャンセルに関する対応を考慮しなければならなくて、正しく処理するのは地味に難易度が高かったりするので、基本的にはRxで、困ったときの必殺技として手段を知っている、ぐらいの心持ちが良いでしょう</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async UniTask TripleClick(CancellationToken token)
{
    // 都度OnClick/token渡しするよりも最初にHandlerを取得するほうが高効率
    using (var handler = button.GetAsyncClickEventHandler(token))
    {
        await handler.OnClickAsync();
        await handler.OnClickAsync();
        await handler.OnClickAsync();
        Debug.Log(&quot;Three times clicked&quot;);
    }
}
</code></pre>
<p>↑こういう色々なことを考えるのが面倒くさい。</p>
<h2>Exception/Cancellationの扱いをより強固に</h2>
<p>UniTaskでは未処理の例外はUniTaskScheduler.UnobservedTaskExceptionによって設定されている未処理例外ハンドラによって処理されます（デフォルトはロギング）。これは、UniTaskVoid、或いはUniTask.Forgetを呼び出している場合は即時に、そうでない場合はUniTaskがGCされた時に未処理例外ハンドラを呼びます。</p>
<p>async/awaitが持つべきステータスは「正常な場合」「エラーの場合」「キャンセルの場合」の3つがあります。しかし、async/awaitならびにC#の伝搬システムは、正常系は戻り値、異常系は例外の二択しかないため、「キャンセルの場合」の表現としてawaitされた元にはOperationCanceledExceptionが投げられます。よって、例外の中で、OperationCanceledExceptionは「特別な例外」です。デフォルトではこの例外が検出されて未処理の場合は、未処理例外ハンドラを無視します。何もしません。キャンセルは定形の処理だと判断して、無視します。</p>
<p>また、例外を使うためパフォーマンス上の懸念もあります。そこで、UniTask.SuppressCancellationThrowを使うことで、対象のUniTaskが例外の発生源であれば（throw済みで上の階層に伝搬されたものではない)、例外の送出ではなく、Tupleでの戻り値としてキャンセルを受け取り、例外発生のコストを抑えることができます。これはイベントハンドリングなどの場合に有用です、が、正しく使うことは内部をかなりのレベルで理解していないといけないため、ぶっちゃけムズい。ただたんにSuppressCancellationThrowを使うだけでパフォーマンスOKというわけにはいかんのだ。というわけで、どうしてもパフォーマンス的に困ったときのための逃げ道、ぐらいに思っておいてください。</p>
<h2>UniTaskTracker</h2>
<p>とはいえなんのかんのでTaskがリークしてしまったり、想像以上に多く起動してしまっていたりもあるでしょう。UnityのEditor拡張でトラッキングウィンドウを用意したので、すべて追跡できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/50421527-abf1cf80-0883-11e9-928a-ffcd47b8c454.png" alt="image" /></p>
<p>こういうのRxにも欲しいわー。そうですね、なんか実装方法は考えてみようかとは思いますが一ミリも期待しないで待たないでください。</p>
<h2>IValueTaskSourceでWhenAllを進化させる</h2>
<p>.NET CoreのC#はTaskとValueTaskに分かれているわけですが、面倒くせーから全てValueTaskでいーじゃん、というわけにはいきません(なお、私の意見は全部ValueTaskでいいと思ってます、というのも使い分けなんて実アプリ開発でできるわけないから）。そうはいかない一番大きな理由はWhenAllで、このTaskで最も使われる演算子であろうWhenAllは、Taskしか受け取らないので、Taskへの変換が必要になってきます。せっかくValueTaskなのにモッタイナイ。じゃあValueTask用のWhenAllを作ればいいじゃん、というとそれも無理で、Task.WhenAllはTaskのinternalなメソッドに依存して最適化が施されているので、外部からはどうしても非効率的なWhenAllしか作れない仕様になっています（クソですね！）。</p>
<p>が、しかし、そもそもWhenAllってあんま効率的じゃなくないっすか？というのがある。と、いうのも、<a href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,6055">配列を受け取るAPI</a>でも、まず保守的にコピーしてるんですよね。可変長引数でWhenAll(new[]{ foo, bar, baz })みたいに渡してもコピーされてるとか馬鹿らしい！あと、WhenAllの利用シーンでもう一つ多いのが WhenAll(source.Select(x =&gt; x.FooAsync()))のような、元ソース起点に非同期メソッドを呼んで、それを全部待つ、みたいなシチュエーション。なんかねー、別に配列作んなくてもいいじゃん、みたいな気になるんですよね。</p>
<p>と、そこでIValueTaskSourceの出番で、Task(ValueTaskですが)の中身を完全に自分の実装に置き換えることができるようになった、のがIValueTaskSourceです。よって、真に効率的なValueTaskに最適化されたうえで↑のような事情を鑑みたWhenAll作れるじゃん、って。思ったわけですよ。</p>
<p>そこでMagicOnionでは(UniRx.Asyncじゃないのかよって、IValueTaskSourceはUnityの話じゃないですから！)<a href="https://github.com/Cysharp/MagicOnion/blob/master/src/MagicOnion/Utils/ReservedWhenAllPromise.cs">ReservedWhenAllPromise</a>というカスタムなWhenAllを用意してみました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var promise = new WhenAllPromise(source.Length);
foreach (var item in source)
{
    promise.Add(item.FooAsync());
}
await promise.AsValueTask();
</code></pre>
<p>のように書けます。つまり何かと言うと、WhenAllに必要なのは「個数」で、個数が最初から確定しているなら、それを渡せばいいし、WhenAll自体の駆動に配列は必要ないので、随時Addしてあげてもいいわけです。これで、一切配列を使わない効率的なWhenAllが実装できました。めでたし。</p>
<p>他にも型が異なるTaskをawaitするのにValueTupleで受け取りたい、というのをTask.WhenAllを介さずにその個数に最適化したWhenAllを用意するとか、やりたい放題にめっちゃ最適化できるわけです。</p>
<p>と、いうのも踏まえて、(サーバーサイドC#における)アプリケーションのTaskの定義はValueTaskで統一しちゃっていいと思うし、そのかわりに幾つかの最適化したValueTask用のWhenAllを用意しましょう。というのが良い未来なんじゃないかなー、って思ってます。(このValueTask用のWhenAllのバリエーションはCysharpとして作ったらOSSで公開するので、こちらは期待して待っててください！）</p>
<h2>まとめ</h2>
<p>UniRx.AsyncナシでUnityにasync/awaitを持ち込んで使いこなすのはかなりの無理ゲーなので、よほどUnity以外で使い込んできた経験がある、とかでなければ、素直に使って頂ければと思います。また、そうでなくてもUnity向けに完全に作り直しているUniTaskの存在価値というのは、スライドのほうで十分理解してもらえてるのではとも思っています。</p>
<p>別にCLRの実装は至高のものだ！ってこたぁ全然なくて、時代とかもあるんで、後の世に作り直されるこたぁ往々にめっちゃある。Microsoftのハイパーエンジニアが練りに練ったものだろうがなんだろうが、永遠に輝き続けるコードなんてあんまなく、時代が経ちゃあどれだけ丁寧に作られたものでも滅びるんです。人間もプログラムも老化には逆らえない（WPFなんて何年前のUIフレームワークなんでしょう!)。というわけで、あんまり脳みそ固くせず、自分の意志で時々に見直して考えてみるといいんじゃないでしょうか。(古の)Microsoftよりも(現代の観点では)私のほうが正しい、とか自信持って言っておきましょう。</p>
<p>さて、UniRx.Asyncは(UniRxも)まだまだ完成しきってるとは言えない、のにドキュメント放置、更新放置で例によって半年ぐらい来てしまったのですが、その間は<a href="http://neue.cc/2018/10/31_570.html">株式会社Cysharpを設立しました</a>であったり、<a href="http://tech.cygames.co.jp/archives/3181/">MagicOnionのリブート</a>であったり、結構わたわたしてしまったところがありなのですが、ようやく諸々落ち着いてきたので、また腰据えて改善に取り組んでいきたいと思います。まぁドキュメントが全然足りないんですけど(UniRx.Asyncの機能は、かなり膨大なのです……)。</p>
<p>C#的にも、自分でTaskの全域を見つめ直して作り直すという経験を通して得られたものも多かったので、今回の記事もそうですが、Unity関係なくasync/awaitを使っていく上で使える話は色々出せていければというところですね。ではまた次回の更新の時まで！次こそはすぐブログ書きますから！</p>
</div>
<a href="https://neue.cc/4">Prev |</a>
<a href="https://neue.cc/6">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2026<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2025/07/">2025-07</a>
<li><a href="https://neue.cc/2025/05/">2025-05</a>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
