<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2012-03-18" data-pagefind-meta="published:2012-03-18"><a href="https://neue.cc/2012/03/18_368.html">Visual Studio 11の非同期("C#, ASP.NET, Web Forms, MVC")</a></h1>
<ul class="date"><li>2012-03-18</li></ul>
<div class="entry_body"><p>世の中ひどぅーきひどぅーきと騒ぐばかりで、猫も杓子もNode.js。でもですね、<a href="http://codezine.jp/article/detail/6461">【デブサミ2012】16-A-5 レポート　ソーシャルアプリケーションにおけるNode.jsの活かし方（1/2）：CodeZine</a>なんかを見ても、そこで独自に作りこんでる例外処理だの非同期フロー管理だのは、そりゃあ必要ですよね、まずはそこから始めるのは当然ですよね、と思いつつC#は最初から備えているんですよね。むしろ色々とC#のほうが、とか思ったりするわけですが（勿論Node.jsのほうがGoodなものもありますが）、こんなところで嘆いていても始まらないのでC#流の非同期の活かし方を見ていきましょうか。</p>
<h2>HttpTaskAsyncHandler</h2>
<p>ASP.NETの非同期ハンドラはIHttpAsyncHandlerなわけですが、VS11ではそれをTask(つまりC# 5.0 async/await)で扱いやすくした基底クラス、<a href="http://msdn.microsoft.com/ja-jp/library/system.web.httptaskasynchandler(v=vs.110).aspx">HttpTaskAsyncHandler</a>が用意されています。例えばTwitterの検索を叩いて返すだけどのものは以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TwitterSearchHandler : HttpTaskAsyncHandler
{
    public async override Task ProcessRequestAsync(HttpContext context)
    {
        var term = context.Request.QueryString[&quot;q&quot;];
        var json = await new HttpClient().GetStringAsync(&quot;http://search.twitter.com/search.json?q=&quot; + term);

        context.Response.ContentType = &quot;application/json&quot;;
        context.Response.Write(json);
    }
}
</code></pre>
<p>普通と違うのはasyncとawaitだけなので、特に混乱もなく同期→非同期に乗り換えられると思います。非常に簡単。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/library/system.net.http.httpclient(v=vs.110).aspx">HttpClient</a>も.NET 4.5からの新顔で、WebClientの後継的な位置付けでしょうか。細かいコントロールも可能で、かつ、WebRequestよりも簡単で、非同期にもきっちりマッチしている。というかHttpClientには同期的なメソッドは用意されていません。これからの非同期世代に完全準拠した新しいクラスということですね。</p>
<p>そして、テスト用のサーバー立てるのも非常に簡単で。Visual Studioで新規で空のASP.NETサイトプロジェクトを作って、↑のハンドラ足して、Ctrl + F5すればIIS Expressが立ち上がって、もうそれだけでOKなわけですよ。超簡単なわけですよ、マジでマジで。</p>
<p>こないだ、<a href="http://atnd.org/events/24951">RIA アーキテクチャー研究会　第3回</a>でのセッションではそうして作ったHttpTaskAsyncHandlerで、 context.Response.StatusCode = 404 にしてエラーを返した状態を再現したりしながらデモしていました。</p>
<div style="width:595px" id="__ss_11947538"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/asynchronous-rx-andtask" title="C#次世代非同期処理概観 - Task vs Reactive Extensions" target="_blank">C#次世代非同期処理概観 - Task vs Reactive Extensions</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/11947538?rel=0" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>今回はTaskを中心にしましたが、Rxを中心にしたものを<a href="http://silverlightsquare.com/index.php/tokyo06.html">Silverlightを囲む会in東京#6</a>で3/31に話す予定なので、まだ募集中なので是非来て下さい。また、Rx v2.0に関しては<a href="http://blogs.msdn.com/b/rxteam/archive/2012/03/12/reactive-extensions-v2-0-beta-available-now.aspx">Reactive Extensions v2.0 Beta available now! - Reactive Extensions Team Blog - Site Home - MSDN Blogs</a>で超詳細に書かれていますね。私もちょいちょいと書きたいことは溜まってるのですが中々にぐぬぬぬ。</p>
<h2>非同期ページ</h2>
<p>今更Web Formsとか超どうでもいいって感じが世界全体に漂ってるし真面目に色々と腐ってると本気で思うしDataSetとWeb Formsは今となっては.NET三大汚点の筆頭かなとか思ったり思わなかったり適当に言ったり呪詛を吐いたり、もう色々アレなのですが、それでも現実とは戦わなければならないのです！</p>
<p>というわけでVS11のASP.NET Web Formsの非同期の強化でも見てみましょう。C# 5.0でasync/awaitが入るのでASP.NET MVCのほうは非同期コントローラーでﾋｬｯﾎｲなのですがWeb Formsも一応対応してきました、一応ね、一応。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">// Web.config
&lt;appSettings&gt;
  &lt;add key=&quot;aspnet:UseTaskFriendlySynchronizationContext&quot; value=&quot;true&quot; /&gt;
&lt;/appSettings&gt; 
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;~/WebForm1.aspx.cs&quot; Inherits=&quot;WebApplication8.WebForm1&quot;
　　　　Async=&quot;true&quot; ViewStateMode=&quot;Disabled&quot; %&gt;

&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head runat=&quot;server&quot;&gt;
    &lt;title&gt;Async Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
    &lt;asp:TextBox ID=&quot;WordTextBox&quot; runat=&quot;server&quot; /&gt;
    &lt;asp:Button ID=&quot;SearchButton&quot; runat=&quot;server&quot; Text=&quot;Button&quot; OnClick=&quot;SearchButton_Click&quot; /&gt;
    &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;TwitterStatuses&quot; ItemType=&quot;dynamic&quot;&gt;
        &lt;ItemTemplate&gt;
            &lt;p&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.from_user %&gt;&quot; /&gt;&lt;br /&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.text %&gt;&quot; /&gt;
            &lt;/p&gt;
        &lt;/ItemTemplate&gt;
    &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// namespace WebApplication8
public partial class WebForm1 : System.Web.UI.Page
{
    protected void SearchButton_Click(object sender, EventArgs e)
    {
        var task = new PageAsyncTask(async () =&gt;
        {
            var word = WordTextBox.Text;
            using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
            {
                var json = System.Json.JsonObject.Load(stream);
                TwitterStatuses.DataSource = json[&quot;results&quot;];
            }
            DataBind();
        });

        RegisterAsyncTask(task);
    }
}
</code></pre>
<p>非同期ページの利用には Async=&quot;true&quot; 属性をつける必要があります。.NET 4.0まではつけていない場合は、同期的に動作するようになっていたのですが、.NET 4.5からはエラーになるように挙動が変更されています。また、PageAsyncTaskを利用する場合はWeb.configにUseTaskFriendlySynchronizationContext = true する必要もあるっぽいです。</p>
<p>これ自体はテキストボックスに検索語を入れてボタンを押すとひどぅーきでTwitter検索して表示する、というだけのDoudemoii代物です。PageAsyncTaskが引数にTaskを受け入れるようになったので、そこでasyncなラムダ式を突っ込んでやればいい、というわけで、まあまあ簡単と言えなくもなく仕上がっています。理想的には/直感的にはasync void SearchButton_Clickと書けるようになるべきなのですが、そうはいかないようです、残念。</p>
<p>JSONは.NET 4.5からお目見えの<a href="http://msdn.microsoft.com/ja-jp/library/system.json(v=vs.110).aspx">System.Json</a>を使いました。これ、AsDynamic()とするとdynamicで扱えるのでサクサクッと使えて便利です。また、そのdynamicとして使える性質を活かして、dynamicのままバインドしてみました(AsDynamicはコード上dynamicにキャストするというだけで、JsonValueはそのもの自身がdynamic = IDynamicMetaObjectProviderなのです)。System.Jsonは<a href="http://nuget.org/packages/System.Json">NuGet - System.Json</a>にもあるので、.NET 4ではそれを使えばいいでしょう。<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>はお払い箱で。</p>
<p>それとRepeaterのItemType=&quot;dynamic&quot;。これでItem.from_userといったように、dynamicに使えるようになっています。匿名型をバインドしたい時なんかも、同じようにItemType=&quot;dynamic&quot;にしてしまうといいかな、と思ったんですが、それは出来ませんでした。あともう一歩、気を利かせてくれても良かったですねえ。</p>
<p>まあ、VS11からは、念願のバインディング式の中でIntelliSenseが効くようになっていて、それはRepeaterのItemTypeも例外ではないので、ちゃんと型作ってあげるのも良いとは思います。あと%:でHtmlEncodeもしてくれますのも良いところ。</p>
<p>ViewStateMode=&quot;Disabled&quot;で無駄なViewStateは生成しないようにするのも大事。これは.NET 4.0からですね。EnableViewStateとは別物という紛らわしさが残っているのも、まあなんともかんとも。ところでPageのViewStateModeをDisableにしてしまうと、this.ViewState[]が使えなくなってしまうので、マスターページからの、asp:Contentにしかけたほうがいいかもです。</p>
<h2>EventHandlerTaskAsyncHelper</h2>
<p>ASP.NETの非同期関連はMSDNマガジンの<a href="http://msdn.microsoft.com/ja-jp/magazine/cc163463.aspx">WickedCode: ASP.NET の非同期プログラミングを使ったスケール変換可能なアプリケーション</a>にまとまっていますが、そこにあるとおり非同期ページの実現方法にはもうひとつ、AddOnPreRenderCompleteAsyncを使う方法があります。それにもTask用のやり方がありますので、見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var helper = new EventHandlerTaskAsyncHelper(async (_, __) =&gt;
{
    var word = WordTextBox.Text;
    using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
    {
        var json = System.Json.JsonObject.Load(stream);
        TwitterStatuses.DataSource = json[&quot;results&quot;];
    }
    DataBind();
});

AddOnPreRenderCompleteAsync(helper.BeginEventHandler, helper.EndEventHandler);
</code></pre>
<p>EventHandlerTaskAsyncHelperを作り、それのBeginとEndをAddOnPreRenderCompleteAsyncに渡してあげます。ちょっとPageAsyncTaskより面倒ですね。まあ、でも、どちらでもいいでしょう。大した違いはありません。二つやり方があるとどちらにすればいいのかと迷ってしまうのが良くないところなんですよねえ、しかもどちらも似たようなものだと……。</p>
<h2>非同期モジュール</h2>
<p>Moduleについても見てみましょう。感覚的にはAddOnPreRenderCompleteAsyncと一緒で、EventHandlerTaskAsyncHelperを作り、追加したいイベントにBeginとEndを渡します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MyModule : IHttpModule
{
    public void Init(HttpApplication application)
    {
        var helper = new EventHandlerTaskAsyncHelper(async (sender, e) =&gt;
        {
            var app = (HttpApplication)sender;
            var path = app.Server.MapPath(&quot;~/log.txt&quot;);

            using (var fs = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.Read, 4096, useAsync: true))
            using (var sw = new StreamWriter(fs, Encoding.UTF8))
            {
                await sw.WriteLineAsync(&quot;Request:&quot; + DateTime.Now);
            }
        });

        application.AddOnBeginRequestAsync(helper.BeginEventHandler, helper.EndEventHandler);
    }

    public void Dispose() { }
}
</code></pre>
<p>AddOnXxxAsyncは沢山あるので、追加したいイベントを選べばいいでしょう。また、非同期でファイルを扱いたい時は、useAsync: trueにするのが大事です。デフォルトはfalseになっているので、Begin-Endをしても非同期にならない（というかスレッドプールを使った挙動になってしまう）そうです（と、プログラミング.NET Frameworkに書いてあった）。</p>
<h2>非同期コントローラー</h2>
<p>一応ASP.NET MVCでも見てみましょうか。TwitterのPublicTimelineを表示するだけのものを（テキストボックスすら作るのが面倒になってきた）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class PublicTimelineController : AsyncController
{
    public async Task&lt;ActionResult&gt; Index()
    {
        using (var stream = await new HttpClient().GetStreamAsync(&quot;https://twitter.com/statuses/public_timeline.json&quot;))
        {
            var json = System.Json.JsonObject.Load(stream);
            return View(json);
        }
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    @foreach (var item in Model)
    {
        &lt;p&gt;
            @item.user.screen_name
            &lt;br /&gt;
            @item.text
        &lt;/p&gt;
    }
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>AsyncControllerの自然さと、きゃーRazor最高ー抱いてー。</p>
<h2>まとめ</h2>
<p>HttpTaskAsyncHandlerにせよEventHandlerTaskAsyncHelperにせよ、中身は割とシンプルにTaskでラップしただけなので、それを自前で用意すればTask自体は.NET 4.0に存在するので、async/awaitは使えませんがそれなりに簡単に書けるようにはなります。とりあえず私はWeb Forms用のものを仕事で使うために用意しました。コードは会社で書いたものなので上げられませんが！というほど大したものでもないので上げちゃってもいいんですが上げません！Web Formsにはとっととお亡くなりになってもらいたいので。延命措置禁止。</p>
<p>Web Formsだって悪くないものだ、全力で頑張ればほら、こんなに出来るじゃないか、ということは容易い、ことはまったくなく全力なわけですが、しかし可能ではあるんですね、モバイル対応だろうがハイパフォーマンスサイトだろうが。きっとたぶん。でもね、なんかもうIE6にも対応しつつHTML5サイトです、とかやるぐらいに不毛感漂ってるし、その労力は別のとこに向けたいですよね、っていうか別のとこに向けばどれだけ幸せになれるだろうか、と思ってしまうのです。</p>
<p>考えてみると、こうもうぇぶけーな話を書くのも初めてな気がする。近頃はお仕事がそっち方面なので、出せる範囲でちょいちょい出してこうかと思います。とにかく結論としてはWeb Formsちゃんは、もう沢山頑張ったと思うのでそろそろ逝ってもらって構いません。</p>
</div>
<h1 data-pagefind-sort="date:2012-03-08" data-pagefind-meta="published:2012-03-08"><a href="https://neue.cc/2012/03/08_367.html">LINQのWhereやSelect連打のパフォーマンス最適化について</a></h1>
<ul class="date"><li>2012-03-08</li></ul>
<div class="entry_body"><p>Where連打していますか？それともパフォーマンスの悪化を心配して&amp;&amp;連結にしていますか？<a href="http://www.atmarkit.co.jp/fdotnet/chushin/greatblogentry_06/greatblogentry_06_01.html">LINQの仕組み＆遅延評価の正しい基礎知識 － ＠IT</a>ではWhere+Selectに対して</p>
<blockquote>
<p>「WhereSelectEnumerableIterator」となっていて、名前のとおり、WhereとSelectが統合されていることです。これは、「Where」-&gt;「Select」が頻出パターンなので、それらを統合することでパフォーマンスを向上させるためでしょう。</p>
</blockquote>
<p>と書きましたが、では連打の場合はどうなっているでしょうか。見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var seq1 = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where(x =&gt; x % 3 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqwherewhere.jpg">
</p>
<p>// どうでもいいんですが、これは<a href="http://www.microsoft.com/visualstudio/11/ja-jp">Visual Studio 11 Beta</a>です。VS11最高ですよ！</p>
<p>@ITの記事では、sourceに格納されて内包した形の連鎖となっている、と書きました。しかしseq1のsourceはRangeIteratorで、Where連打のはずなのに、すぐ上の階層が元ソースとなっています。そして、predicateの名前がCombinePredicates。はい、その通りで、2つの条件式が連結されています。確認してみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var pred = (Func&lt;int, bool&gt;)seq1.GetType().GetField(&quot;predicate&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(seq1);

Console.WriteLine(pred(2)); // false
Console.WriteLine(pred(3)); // false
Console.WriteLine(pred(6)); // true
</code></pre>
<p>というわけで、Where連打はpredicateが連結されて一つのWhereに最適化されることが確認できました。<a href="http://neue.cc/2009/07/21_178.html">LinqとCountの効率</a>でICollectionやIListの場合の特別扱いなケースがあることを紹介しましたが、Whereに関しても同様な特別扱いが発生するというわけです。</p>
<h2>Selectの場合</h2>
<p>Whereの他にSelectの場合も、同じような最適化を行ってくれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var seq2 = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Select(x =&gt; x + 10);

var selector = (Func&lt;int, int&gt;)seq2.GetType().GetField(&quot;selector&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(seq2);

Console.WriteLine(selector(2)); // 2 * 2 + 10 = 14
Console.WriteLine(selector(5)); // 5 * 2 + 10 = 20
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqselectselect.jpg">
</p>
<p>sourceのすぐ上がRangeIteratorで、selectorにCombineSelectorsとして格納されていました。なお、型名であるWhereSelectEnumerableIteratorのとおり、現在はpredicateはnullですが、前段にWhereを書けばpredicateに格納されて、やはりWhere+Selectの最適化となります。では、後段にWhereを書いた場合は……？</p>
<h2>最適化されない場合</h2>
<p>Where+SelectとSelect+Whereは異なるものです。見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var whereSelect = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Select(x =&gt; x * 2);

var selectWhere = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Where(x =&gt; x % 2 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqwhereselectselectwhere.jpg">
</p>
<p>Where+SelectはWhereSelectEnumerableIteratorのpredicateとselectorにそれぞれデリゲートが格納され、ひとまとめに最適化されていますが、Select+WhereはsourceがRangeIteratorではなくWhereSelectEnumerableIteratorであるように、普通に階層の内包構造となっています。Selectの後にWhereは最適化されません。まあ、そりゃ値が変形されているのだからpredicateがひとまとまりになるわけがなく、当たり前ではあります。</p>
<p>次にインデックスが使えるオーバーロードのケースを見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var whereIndex = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where((x, i) =&gt; i % 2 == 0);

var selectIndex = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Select((x, i) =&gt; i * 2);

// GetEnumeratorしないとpredicate/selectorとsourceがnullです
// これはyield returnによる生成なためです
whereIndex.GetEnumerator();
selectIndex.GetEnumerator();
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqehereindexselectindex.jpg">
</p>
<p>これもひとまとめにしようにも、しようがないので、当然といえば当然ですね。</p>
<h2>IQueryableの場合</h2>
<p>IQueryableだとどうなのか、というと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// LINQ to SQL - AdventureWorks sample
var ctx = new AdventureWorksDataContext();
var query = from model in ctx.ProductModel
            where model.Name == &quot;hoge&quot;
            where model.ProductModelID == 100
            select model.Instructions;

Console.WriteLine(query);
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-txt">// 結果
SELECT [t0].[Instructions]
FROM [Production].[ProductModel] AS [t0]
WHERE ([t0].[ProductModelID] = @p0) AND ([t0].[Name] = @p1)
</code></pre>
<p>というわけで、LINQ to SQLはand連結されますね。ここで注意なのが、どういう挙動を取るのかは全てクエリプロバイダの解釈次第です。例えば<a href="http://linqtotwitter.codeplex.com/">LINQ to Twitter</a>はwhere連打ではダメで、&amp;&amp;で連結しなければなりません。</p>
<h2>Reactive Extensionsの場合</h2>
<p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の場合も見てみましょうか。Rx-Main(1.0.11226)では、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var rx = Observable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where(x =&gt; x % 3 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxstable.jpg">
</p>
<p>さっぱりワケワカメですが、とりあえずひとまとめになってないのでは感でしょうか。それにしても本当にワケワカメ。次にRx_Experimental-Main(1.1.11111)は、というと</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxexperimental.jpg">
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var pred = (Func&lt;int, bool&gt;)rx.GetType().GetField(&quot;_predicate&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(rx);

Console.WriteLine(pred(2)); // false
Console.WriteLine(pred(3)); // false
Console.WriteLine(pred(6)); // true
</code></pre>
<p>_predicate発見！Experimental版では挙動が改善され、ひとまとめにされているようです。IDisposable&lt;Generate&gt;は、Rangeの生成がGenerateメソッドによってなされているからですね。しかし、やはり読み取りにくい。</p>
<h2>Rx v2</h2>
<p>3/5に<a href="http://www.microsoft.com/download/en/details.aspx?id=29058">Reactive Extensions (Rx) v2.0 Beta</a>の配布がスタートしています。NuGetでは<a href="http://nuget.org/packages/Rx-Main">Install-Package Rx-Main -Pre</a>で配布されていますね。改善内容は後日詳しくということでまだ詳しくは出てないのですが、v2というだけあって中身はガラッと変わっています。とりあえず、見てみましょう。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxv2.jpg">
</p>
<p>もちろん、predicateはひとまとめにされているのですが、それだけじゃなくて、とにかく見やすい、分かりやすい。しかし、ところどころ変ですね、Observαble(aがアルファ)だのΩだの。v2はソースのキチガイ度が跳ね上がっているのでILSpyとかで覗いちゃえる人は一度見ちゃうといいと思います、頭おかしい。あと、C#でのプログラミング的な小技も効いてたりして、テクニックの学習にもとても良い。</p>
<h2>スタックトレースへの影響</h2>
<p>このコードのクリアさはスタックトレースにも良い影響を与えています。まず、Rx v1で見てみると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">try
{
    Observable.Range(1, 10)
        .Where(x =&gt; x % 2 == 0)
        .Take(10)
        .Timestamp()
        .Subscribe(_ =&gt; { throw new Exception(); });
}
catch (Exception ex)
{
    Console.WriteLine(ex.StackTrace);
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-txt">場所 ConsoleApplication9.Program.&lt;Main&gt;b__1(Timestamped`1 _) 場所 c:\Users\ne
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.AnonymousObservable`1.AutoDetachObserver.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.Linq.Observable.&lt;&gt;c__DisplayClass408`2.&lt;&gt;c__DisplayClass40a.&lt;Select&gt;b__407(TSource x)
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.AnonymousObservable`1.AutoDetachObserver.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.Linq.Observable.&lt;&gt;c__DisplayClass43e`1.&lt;&gt;c__DisplayClass440.&lt;Take_&gt;b__43d(TSource x)
// 以下略
</code></pre>
<p>これは酷い。こんなの見ても何一つ分かりはしません。では、Rx v2で試してみると</p>
<pre data-pagefind-ignore="all"><code class="language-txt">場所 ConsoleApplication10.Program.&lt;Main&gt;b__1(Timestamped`1 _) 場所 c:\Users\n
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.ObserverBase`1.OnNext(T value)
場所 System.Reactive.Linq.Observαble.Timestamp`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Take`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Where`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Range._.LoopRec(Int32 i, Action`1 recurse)
場所 System.Reactive.Concurrency.Scheduler.&lt;&gt;c__DisplayClass3a`1.&lt;InvokeRec1&gt;b__37(TState state1)
// 以下略
</code></pre>
<p>めっちゃよく分かる。Timestamp-&gt;Take-&gt;Where-&gt;Rangeという遡りがしっかり見える。何て素晴らしいんだ！</p>
<h2>匿名 vs 有名</h2>
<p>さて、どういうことかというと、これ、<a href="http://neue.cc/2010/07/05_265.html">neue cc - Rx(Reactive Extensions)を自前簡易再実装する</a>で紹介したような、ラムダ式をぶん投げてその場で匿名のクラスを作るAnonymousパターンをやめたんですね。で、代わりに名前付きのクラスを立ててる。だから分かりやすい。</p>
<p>これ、uupaaさんが仰ってる<a href="http://blog.7kai.org/2011/03/markdown-binder-js-navi/">ナビ子記法</a>←ググッた先の本人のスライドが、Handsoutがサービス終了で見れないので、紹介のある記事にリンクします-などにも近いところがあるかなあ、と。</p>
<p>ただやっぱ書くのにはコスト高というか匿名で書けることの良さを殺してしまうので、ライブラリサイドだったら検討する、アプリケーションサイドだったらやらない、になってしまうかなあ。ライブラリサイドであってもかなり手間なので、よほど余裕あるとかでないとやらない、かなあ。JavaScriptならともかくC#では、特に……。</p>
<h2>Rx v2についてもう少し</h2>
<p>詳しい話は詳細が出てから、と思いますが（と言いながらRxJSの話も結局書いてないので、あうあう）、とりあえずObservableへの拡張メソッド郡はExperimentalから変化は特にありません。ただ、Experimentalは既にStableとはかなり違っているので、Stableしか追っかけてない人は、かなり目新しいものを見かけることができると思います。</p>
<p>内部実装は見たとおりガラッと変わって、スタックトレースも見やすくなった、などなどなわけですが、それとあわせてパフォーマンスも相当上がっています。v1で基本的な部分を固めたので、v2ではそういった周辺部分に本気で取り組みだした、ということですね。</p>
<h2>まとめ</h2>
<p>LINQは細かいところまで配慮が行き届いていて本当に素晴らしいですね。というわけで平然とWhereの連打かましましょう。私もつい昨日にWhere6連打かましたりしてました。</p>
<p><a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>はさすがにここまではやってないんですが、いずれかはやりたいですね。その前にやらなきゃならないことがありすぎて当面はないですけれど。うーん、なんかもう色々やることありすぎて、かつそれなりに忙しくて、頭が爆発しそうです。はっきしいってヤバい。で、こうしてヤバくなると、硬直しちゃって余計に何もできなくなったり、唐突にこうして息抜き記事を書き出したり、うみみぅ。まあともかく、がんばろふ。</p>
</div>
<h1 data-pagefind-sort="date:2012-02-23" data-pagefind-meta="published:2012-02-23"><a href="https://neue.cc/2012/02/23_366.html">とあるRoslynではないC# Parser、NRefactoryの紹介</a></h1>
<ul class="date"><li>2012-02-23</li></ul>
<div class="entry_body"><p>ﾛｯｽﾞﾘｰﾝ、はっじまらないよ～。というわけで<a href="http://msdn.microsoft.com/ja-jp/roslyn">Microsoft “Roslyn” CTP</a>、Compiler as a Service。<a href="http://nuget.org/packages/Roslyn">NuGet - Roslyn</a>でも手に入るので、サンプル類やC# Interactiveとかはなしで、とりあえずScriptingやCompilerを触ってみたい、ということなら、お手軽です。しかし、まあ未実装も少なくなく、まだまだ先は長そうな雰囲気ではある。今すぐ欲しいのに！切実にC# Parserが！というわけで、今日はその良き代替となる（かもしれない）<a href="https://github.com/icsharpcode/NRefactory">NRefactory</a>を紹介します。</p>
<p>NRefactoryは<a href="https://packages.nuget.org/packages/ICSharpCode.NRefactory/">NuGet - NRefactory</a>からも入ります。verは5.0.0.4、「This is an alpha release. Expect bugs and breaking changes in the future.」とのことで、こちらもまだまだこれからのよう(MonoDevelopの新しいC#エディタで使われる予定、だそうです)。とりあえずNuGetで参照してみませう。</p>
<p>参照するとMono.Cecilが入ったり名前空間にMono.CSharpがあったりと、全体的に<a href="http://www.mono-project.com/CSharp_Compiler">MonoのCSharp Compiler</a>やその周辺が使われているふいんき。Mono.CSharpは単体でもついこないだ<a href="https://nuget.org/packages/Mono.CSharp">NuGet - Mono.CSharp</a>で入れられるようになりましたが、そのまんまだと、なんというかどう使っていいか分からないというか、はいEvalできた、さて、はて？みたいになってしまって。そのへん、NRefactoryはゆるふわで、結構すぐに使い方分かります。とりあえず使ってみませう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.IO;
using System.Linq;
using ICSharpCode.NRefactory.CSharp;

class Program
{
    static void Main(string[] args)
    {
        var code = File.ReadAllText(@&quot;../../Program.cs&quot;);
        var parser = new CSharpParser();

        var root = parser.Parse(code, &quot;&quot;);

        var program = root.Descendants.OfType&lt;ICSharpCode.NRefactory.CSharp.TypeDeclaration&gt;().First();
        program.Name = &quot;Hogegram&quot;;

        Console.WriteLine(root.ToSourceString());
    }
}

public static class CompilationUnitExtensions
{
    static readonly CSharpFormattingOptions DefaultOptions = new CSharpFormattingOptions()
    {
        // TODO:130のboolを自分の気にいるようなOption（というかVSのデフォ）に近づける
    };

    public static string ToSourceString(this CompilationUnit compilationUnit, int indentation = 4, string indentationString = &quot; &quot;)
    {
        return ToSourceString(compilationUnit, DefaultOptions, indentation, indentationString);
    }

    public static string ToSourceString(this CompilationUnit compilationUnit, CSharpFormattingOptions options, int indentation = 4, string indentationString = &quot; &quot;)
    {
        using (var sw = new StringWriter())
        {
            var formatter = new TextWriterOutputFormatter(sw)
            {
                Indentation = indentation,
                IndentationString = indentationString
            };

            var visitor = new CSharpOutputVisitor(formatter, options);
            compilationUnit.AcceptVisitor(visitor);
            return sw.ToString();
        }
    }
}
</code></pre>
<p>Program.csを読み込んで、クラス名をHogegramに変更したのを出力する、というだけのものです。今のところ整形した文字列化にはCSharpOutputVisitorを作って、AcceptVisitorしなきゃならないようで面倒ぃので、とりあえず拡張メソッドにしました。デフォルトの整形オプションが気に食わないのですが、フォーマット設定が超細かくて100個以上のboolをON/OFFしなきゃいけないのでとりあえず放置。</p>
<p>構文木の取得自体は超単純で、new CSharpParser()してParse。そしてツリーを辿るのはLINQ to Xmlと同じ感覚でDescendantsやAncestors、Childrenなどなどが用意されているので、一発で分かりますね！そしてOfTypeで自分の欲しいのにフィルタリング、と。この辺は超簡単。そして名前を変えたければ、プロパティに代入するだけ。非常に楽ちんです、素晴らしい……！</p>
<h2>vs Roslyn</h2>
<p>さて、じゃあRoslynでも同じことをやってみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Roslyn.Compilers.CSharp;

class Program
{
    static void Main(string[] args)
    {
        var code = File.ReadAllText(@&quot;../../Program.cs&quot;);
        var tree = SyntaxTree.ParseCompilationUnit(code);

        var program = tree.Root.DescendentNodes().OfType&lt;ClassDeclarationSyntax&gt;().First();

        var newNode = new ClassNameRewriter(new Dictionary&lt;ClassDeclarationSyntax, string&gt; { { program, &quot;Hogegram&quot; } })
            .Visit(tree.Root);

        Console.WriteLine(newNode.ToString());
    }
}

public class ClassNameRewriter : SyntaxRewriter
{
    readonly IDictionary&lt;ClassDeclarationSyntax, string&gt; replaceNames;

    public ClassNameRewriter(IDictionary&lt;ClassDeclarationSyntax, string&gt; replaceNames)
    {
        this.replaceNames = replaceNames;
    }

    protected override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        var oldIdentifierToken = node.Identifier;

        if (replaceNames.ContainsKey(node))
        {
            var newNode = node.Update(node.Attributes,
               node.Modifiers, node.Keyword,
               Syntax.Identifier(
                   oldIdentifierToken.LeadingTrivia,
                   replaceNames[node], // ここだけ！
                   oldIdentifierToken.TrailingTrivia),
               node.TypeParameterListOpt, node.BaseListOpt,
               node.ConstraintClauses, node.OpenBraceToken,
               node.Members, node.CloseBraceToken,
               node.SemicolonTokenOpt);

            return newNode;
        }
        else
        {
            return base.VisitClassDeclaration(node);
        }
    }
}
</code></pre>
<p>構文木の取得はこちらも簡単です、SyntaxTree.ParseCompilationUnitだけ。ツリーの辿り方も似ていて、DescendentNodes、ChildNodes、Ancestors、と、戸惑うことなく使える感じです。OfTypeでフィルタして絞り込みも同じ。書き換えたコードの出力は、こちらはToStringだけでOK、しかもフォーマットルールは何の設定もいらずVS標準と同じ状態になっているので楽ちん。</p>
<p>が、しかし、こちらはクラス名の書き換えが面倒。Expression Treeと同じく基本的にイミュータブルになっているので、書き換えはプロパティに代入するだけ、とはいかず、大掛かりな仕掛けが必要です。というかこの程度のためだけにVisitorとか……。一応ReplaceNodeとかUpdateとかもあるんですが、うーん、まあ、何というか、よくわかってないので深く突っ込まれると窮します:)</p>
<h2>まとめ</h2>
<p>提供する機能は同じでも、使い心地とかは、両者、結構違くなるのではという印象。どちらも発展途上なのですが、ライセンス的にRoslynは今は使えないのに比べると、NRefactoryはMITライセンスで、アルファ版なのを留意しておけば使えるのではというのが、私的には大きいかなあ。割と切迫してC# Parserが必要なところなので、ここはちょっとNRefactoryを使い込んでみたいなあ、なんて思っています。いや、そこまでDeepに使い倒すというより簡単なコード解析と置換程度なので、しっかり使ってバグ報告、とかの貢献は出来なさそうですんがー。</p>
</div>
<h1 data-pagefind-sort="date:2012-02-18" data-pagefind-meta="published:2012-02-18"><a href="https://neue.cc/2012/02/18_365.html">ImplicitQueryString - 暗黙的変換を活用したC#用のクエリストリング変換ライブラリ</a></h1>
<ul class="date"><li>2012-02-18</li></ul>
<div class="entry_body"><ul>
<li><a href="http://implicitquerystring.codeplex.com/">ImplicitQueryString - CodePlex</a></li>
</ul>
<p>QueryStringかったるいですね、変換するのが。intに。boolに。それ以外に。そのままじゃどうしようもなくストレスフル。そこで、以下のように書けるライブラリを作りました。勿論<a href="http://nuget.org/packages/ImplicitQueryString">NuGet</a>でのインストールも可能です。あと、ライブラリといっても例によって.csファイル一個だけなので、導入は超お手軽。</p>
<p>以下はASP.NETの例ですが、NameValueCollectionを使っているものは全て対象になります。QueryStringだけじゃなくてRequest.Formなどにも使えますね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Web;

int count;
string query;
bool? isOrdered; // support nullable

protected void Page_Load(object sender, EventArgs e)
{
    count = Request.QueryString.ParseValue(&quot;c&quot;);
    query = Request.QueryString.ParseValue(&quot;q&quot;);
    isOrdered = Request.QueryString.ParseValue(&quot;ord&quot;);
}
</code></pre>
<p>NameValueCollectionへの拡張メソッドとして実装しているので、using Codeplex.Webを忘れないように。ポイントは「型の明示が不要」というところです。クエリストリングを解析したい時って、通常はフィールドで既に変数自体は作っているのではないかと思います。なら、代入時に左から型を推論させてしまえばいいわけです、モダンなC#はわざわざ明示的に型なんて書かない、書きたくない。なのでこのライブラリ、ImplicitQueryStringではParseValueだけで全ての基本型(int, long, bool, string, DateTimeなど)へと型指定不要で代入可能となっています。代入先の型がNullableである場合は、キーが見つからなかったりパースに失敗した場合はnullにすることもサポートしてます。</p>
<p>また、よくあるクエリストリングはUrlEncodeされているのでデコードしたかったりするケースにも簡単に対応しています、UrlDecodeを渡すだけ！他にもEnumへの変換も出来ますし、キーが見つからなかったり変換不可能だったりした場合は指定したデフォルト値を返すParseValueOrDefault/ParseEnumOrDefaultも用意してあります。キーがあるかチェックするContainsKeyも。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">enum Sex
{
    Unknown = 0, Male = 1, Female = 2
}

enum BloodType
{
    Unknown, A, B, AB, O
}

int age;
string name;
DateTime? requestTime;  // nullableやDateTimeもサポート
bool hasChild;
Sex sex;               // enumもいけます
BloodType bloodType;

protected void Page_Load(object sender, EventArgs e)
{
     // こんなQueryStringがあるとして
    // a=20&amp;n=John%3dJohn+Ab&amp;s=1&amp;bt=AB

    // ageは左から推論してintを返します
    age = Request.QueryString.ParseValue(&quot;a&quot;); // 20

    // UrlDecodeしたstringが欲しい時は第二引数にメソッドそのものを渡すだけ
    name = Request.QueryString.ParseValue(&quot;n&quot;, HttpUtility.UrlDecode); // John=John Ab

    // 代入先の型がnullableの場合は、もしキーが見つからなかったりパースに失敗したらnullにしてくれます
    requestTime = Request.QueryString.ParseValue(&quot;t&quot;, HttpUtility.UrlDecode); // null

    // キーが見つからなかったりパースに失敗したら指定した値を返してくれます
    hasChild = Request.QueryString.ParseValueOrDefault(&quot;cld&quot;, false); // false
    
    // Enumの変換は数字の場合でも文字列の場合でも、どちらでも変換可能です
    sex = Request.QueryString.ParseEnum&lt;Sex&gt;(&quot;s&quot;); // Sex.Male
    bloodType = Request.QueryString.ParseEnumOrDefault&lt;BloodType&gt;(&quot;bt&quot;, BloodType.Unknown); // BloodType.AB

    // ContainsKeyはキーの有無をチェックします
    var hasFlag = qs.ContainsKey(&quot;flg&quot;); // false
}
</code></pre>
<p>これで、あらゆるケースでサクッと変換することが可能なのではかと思います。ちなみに、ParseValue/ParseEnumでキーが見つからなかった場合はKeyNotFoundExceptionを返します。ParseValueで失敗したらFormatException、ParseEnumで失敗したらArgumentExceptionです。この二つが分かれているのは、int.Parseとかに渡しているだけなので、そちらの都合です。</p>
<h2>仕組み</h2>
<p>ImplicitQueryStringという名前がネタバレなのですが、単純に暗黙的変換をしているだけです。左から推論とか、ただのハッタリです。<a href="http://neue.cc/2012/02/14_364.html">neue cc - dynamicとQueryString、或いは無限に不確定なオプション引数について</a>を書いたときに、わざわざdynamicを持ち出さなくても、暗黙的変換で十分じゃないの？そのほうが利便性も上じゃないの？と思ったのでやってみたら、やはりドンピシャでした。</p>
<p>暗黙的変換は、あまり使う機能じゃあないと思いますし、実際、乱用すべきでない機能であることには違いないのですが、たまに活用する分には中々刺激的で創造性に満ちています。大昔からあるけれど普段使わない機能だなんて、ロストテクノロジーっぽくて浪漫に溢れています。</p>
<p>さて、ただし活用するにはコード中に型を並べなければならないので、汎用的というわけではないのもそうなのですが、人力で書くのもシンドイところ。勿論人力でやる気はしないので<a href="http://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Template</a>を使いました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; #&gt;
&lt;#@ output extension=&quot;cs&quot; #&gt;
&lt;#@ assembly Name=&quot;System.Core.dll&quot; #&gt;
&lt;#@ import namespace=&quot;System&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text.RegularExpressions&quot; #&gt;
&lt;#@ import namespace=&quot;System.Reflection&quot; #&gt;
&lt;#
    var methods = typeof(Convert).GetMethods(BindingFlags.Static | BindingFlags.Public);

    var converters = methods.Where(x =&gt; x.Name.StartsWith(&quot;To&quot;))
        .Select(x =&gt; Regex.Replace(x.Name, &quot;^To&quot;, &quot;&quot;))
        .Where(x =&gt; !x.StartsWith(&quot;Base64&quot;) &amp;&amp; x != &quot;String&quot;)
        .Distinct()
        .ToArray();
#&gt;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;

namespace Codeplex.Web
{
    public static class NameValueCollectionExtensions
    {
        public static ConvertableString ParseValue(this NameValueCollection source, string key)
        {
            return ParseValue(source, key, null);
        }

        public static ConvertableString ParseValue(this NameValueCollection source, string key, Func&lt;string, string&gt; converter)
        {
            var values = source.GetValues(key);
            if (values == null) return new ConvertableString(null);

            var value = values[0];
            return new ConvertableString(converter == null ? value : converter(value));
        }
        
        // 中略
    }

    public struct ConvertableString
    {
        public readonly string Value;

        public ConvertableString(string value)
        {
            this.Value = value;
        }

&lt;# foreach (var converter in converters) { #&gt;
        public static implicit operator &lt;#= converter #&gt;(ConvertableString self)
        {
            if (self.Value == null) throw new KeyNotFoundException();
            return &lt;#= converter #&gt;.Parse(self.Value);
        }

        public static implicit operator &lt;#= converter #&gt;?(ConvertableString self)
        {
            &lt;#= converter #&gt; value;
            return (self.Value != null &amp;&amp; &lt;#= converter #&gt;.TryParse(self.Value, out value))
                ? new Nullable&lt;&lt;#= converter #&gt;&gt;(value)
                : null;
        }

&lt;# } #&gt;
        public static implicit operator String(ConvertableString self)
        {
            return self.Value;
        }

        public override string ToString()
        {
            return Value;
        }
    }
}
</code></pre>
<p>以上のコードから、T4生成部分を取り出すと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static implicit operator Boolean(ConvertableString self)
{
    if (self.Value == null) throw new KeyNotFoundException();
    return Boolean.Parse(self.Value);
}

public static implicit operator Boolean?(ConvertableString self)
{
    Boolean value;
    return (self.Value != null &amp;&amp; Boolean.TryParse(self.Value, out value))
        ? new Nullable&lt;Boolean&gt;(value)
        : null;
}

public static implicit operator Char(ConvertableString self)
{
    if (self.Value == null) throw new KeyNotFoundException();
    return Char.Parse(self.Value);
}

public static implicit operator Char?(ConvertableString self)
{
    Char value;
    return (self.Value != null &amp;&amp; Char.TryParse(self.Value, out value))
        ? new Nullable&lt;Char&gt;(value)
        : null;
}

// 以下SByte, Byte, Int16, Int32, Int64, ..., DateTimeと繰り返し
</code></pre>
<p>といったコードがジェネレートされます。清々しいまでのゴリ押しっぷり。一周回ってむしろエレガント。ConvertableStringのほうでKeyNotFoundExceptionを出すのがイケてないのですが、まあそこはShoganaiかなー、ということで。さて、それはそれとして、やっぱVisual Studioに組み込みで、こういった自動生成のテンプレートエンジンが用意されているというのは非常に嬉しいところです。</p>
<h2>まとめ</h2>
<p>特にASP.NETを使っている方々にどうぞ。ASP.NET MVCの人はしらにゃい。なのでいつもの私だったら.NET 4.0専用にするところが、今回は.NET 3.5でも大丈夫！Visual Studio 2008でも動作確認取りました！</p>
<p>それにしても実際ASP.NETを使いこなしてる人はクエリストリングの取得はどんな風にやっていたものなのでしょうかー。何かしらの手法がないとシンドすぎやしませんか？そう思って検索してみたんですが、どうにも見つからず。さすがに ParseValueAsInt() とかって拡張メソッドぐらい作ってやり繰りは私も大昔していたし、それでintに対応しておけばほぼほぼOKではありますが（拡張メソッドがなかった時代はさすがに想像したくない！）。そう考えると、ちょっとこれはやりすぎ感も若干。でも、一度できあがればずっと使えますしね。というわけで<a href="http://implicitquerystring.codeplex.com/">ImplicitQueryString</a>、是非是非使ってみてください。本当に楽になれると思います。</p>
</div>
<h1 data-pagefind-sort="date:2012-02-14" data-pagefind-meta="published:2012-02-14"><a href="https://neue.cc/2012/02/14_364.html">dynamicとQueryString、或いは無限に不確定なオプション引数について</a></h1>
<ul class="date"><li>2012-02-14</li></ul>
<div class="entry_body"><p>どうもこんばんわ、30時間も寝てないわー。まあ、お陰で真昼間の就業中にうつらうつらしてましたが！ちなみに<a href="http://www.jp.playstation.com/scej/title/gravitydaze/">GRAVITY DAZE</a>にはまって延々とプレイしてたから寝てないだけです。PS陣営にくだるなんて！さて、それはそれとしてBlog更新頻度の低下っぷりはお察し下さい。そんなこんなで最近の仕事（仕事ですって！仕事してるんですって！？）はASP.NETなんですが、色々アレですね。ふふふ。ソウルジェムは真っ黒と真っ白を行ったり来たりしてて楽しいです。まあ、ようするに楽しいです。楽しいのはいいとしてBlogが停滞するのはいくないので、電車でGRAVITY DAZEやりながらQueryStringうぜえええええ、とか悶々としたので帰り道に殺害する算段を整えていました。</p>
<p>QueryStringって、qとかnumとかiとかsとか、それそのものだけじゃ何を指してるかイミフなので、C#的にはちゃんと名前をつけてやりたいよね。だから、ただシンプルに触れるというだけじゃダメで。あと、コンバートもしたいよね。数字はintにしたいしboolは当然boolなわけで。さて、そんな時に私たちが持つツールと言ったら、dynamicです。C#とスキーマレスな世界を繋ぐ素敵な道具。今日も活躍してもらうことにしましょう。たまにしか出番ないですからね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">private int id;
private int? count;
private string keyword;
private bool isOrdered;

protected void Page_Load(object sender, EventArgs e)
{
    // id=10&amp;c=100&amp;q=hogehoge&amp;od=true というクエリストリングが来る場合

    // dynamicに変換！
    var query = this.Request.QueryString.AsDynamic();

    id = query.id; // キャストは不要、書くの楽ですね！(キーが存在しないと例外)
    count = query.c; // 型がnullableならば、存在しなければnull
    keyword = query.q; // stringの場合も存在しない場合はnull
    isOrdered = query.od(false); // メソッドのように値を渡すと、キーが存在しない場合のデフォルト値になる
}
</code></pre>
<p>ASP.NETの例ですが、どうでしょう、まぁまぁ良い感じじゃあなくて？ちなみに最初はnull合体演算子(??)を使いたかったのですが、DynamicObjectでラップした時点で、そもそも存在がnullじゃないということで、何をどうやってもうまく活用できなくて泣いた。しょうがないのでメソッド形式でデフォルト値を渡すことでそれっぽいような雰囲気に誤魔化すことにしました、とほほほ。</p>
<h2>dynamicとオプション引数</h2>
<p>クエリストリングを生成することも出来ます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 戻り値はdynamicで空のDynamicQueryStringを生成
var query = DynamicQueryString.Create();

// オプション引数の形式で書くと……？
query(id: 100, c: 100, q: &quot;hogehoge&quot;, od: true);

Console.WriteLine(query.ToString()); // id=10&amp;c=100&amp;q=hogehoge&amp;od=true
</code></pre>
<p>といった感じで、面白いのがオプション引数の使い方。匿名型渡しのように、スマートにKey:Valueを渡すことを実現しています。dynamicなので引数名は完全自由。個数も完全自由。非常にC#らしくなくC#らしいところが最高にCOOL。匿名型とどちらがいいの？というと何とも言えないところですが、面白いには違いないし、面白いは正義。C#も工夫次第でまだまだ色々なやり方が模索できるんですよー、ってところです。</p>
<h2>実装など</h2>
<p>眠いのでコードの解説はしません（ぉ。DynamicObjectの実装方法は<a href="http://neue.cc/2010/05/06_257.html">neue cc - C# DynamicObjectの基本と細かい部分について</a>でどーぞ。overrideしていくだけなので、別に難しくもなんともないので是非是非やってみてください。ちなみに無限のオプション引数を実現している箇所は binder.CallInfo.ArgumentNames.Zip(args, (key, value) =&gt; new { key, value }) です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class NameValueCollectionExtensions
{
    public static dynamic AsDynamic(this NameValueCollection queryString)
    {
        return new DynamicQueryString(queryString);
    }
}

public class DynamicQueryString : DynamicObject
{
    NameValueCollection source;

    public DynamicQueryString()
    {
        this.source = new NameValueCollection();
    }

    public DynamicQueryString(NameValueCollection queryString)
    {
        this.source = queryString;
    }

    public static dynamic Create()
    {
        return new DynamicQueryString();
    }

    public override bool TryGetMember(GetMemberBinder binder, out object result)
    {
        var value = source[binder.Name];
        result = new StringMember((value == null) ? value : value.Split(',').FirstOrDefault());
        return true;
    }

    public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
    {
        foreach (var item in binder.CallInfo.ArgumentNames.Zip(args, (key, value) =&gt; new { key, value }))
        {
            source.Add(item.key, item.value.ToString());
        }

        result = this.ToString();
        return true;
    }

    public override bool TryConvert(ConvertBinder binder, out object result)
    {
        if (binder.Type != typeof(string))
        {
            result = null;
            return false;
        }
        else
        {
            result = this.ToString();
            return true;
        }
    }

    public override string ToString()
    {
        return string.Join(&quot;&amp;&quot;, source.Cast&lt;string&gt;().Select(key =&gt; key + &quot;=&quot; + source[key]));
    }

    public override IEnumerable&lt;string&gt; GetDynamicMemberNames()
    {
        return source.Cast&lt;string&gt;();
    }

    class StringMember : DynamicObject
    {
        readonly string value;

        public StringMember(string value)
        {
            this.value = value;
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            var defaultValue = args.First();

            try
            {
                result = (value == null)
                    ? defaultValue
                    : Convert.ChangeType(value, defaultValue.GetType());
            }
            catch (FormatException) // 真面目にやるならType.GetTypeCodeでTypeを分けて、例外キャッチじゃなくてTryParseのほうがいいかな？
            {
                result = defaultValue;
            }

            return true;
        }

        public override bool TryConvert(ConvertBinder binder, out object result)
        {
            try
            {
                var type = (binder.Type.IsGenericType &amp;&amp; binder.Type.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;))
                    ? binder.Type.GetGenericArguments().First()
                    : binder.Type;

                result = (value == null)
                    ? null
                    : Convert.ChangeType(value, binder.Type);
            }
            catch (FormatException)
            {
                result = null;
            }

            return true;
        }

        public override string ToString()
        {
            return value ?? &quot;&quot;;
        }
    }
}
</code></pre>
<p>コンバートに対応させるために、要素一つだけのDynamicObjectを中で用意しちゃってます。そこがポイント、といえばポイント、かしら。GetDynamicMemberNamesはデバッガの「動的ビュー」に表示されるので、Visual Studioに優しいコードを書くなら必須ですね。</p>
<h2>まとめ</h2>
<p>dynamicはC#と外の世界を繋ぐためのもの。今日もまた一つ繋いでしまった。それはともかくとして、一番最初、<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を実装した頃にも言ったのですが、dynamicはDSL的な側面もあって、普通に楽しめますので、ちょっと頭をひねって活用してみると、また一つ、素敵な世界が待っています。</p>
<p>今回はコード書くのに2時間、この記事を書くのに1時間、でしたー。</p>
</div>
<h1 data-pagefind-sort="date:2012-01-17" data-pagefind-meta="published:2012-01-17"><a href="https://neue.cc/2012/01/17_363.html">C#のO/Rマッパーのパフォーマンス測定 Part2</a></h1>
<ul class="date"><li>2012-01-17</li></ul>
<div class="entry_body"><p>以前に<a href="http://neue.cc/2011/06/03_326.html">neue cc - C#のMicro-ORM(Dapper, Massive, PetaPoco)について</a>で計測したのですが、<a href="https://twitter.com/shibayan">@shibayan</a>先生が<a href="http://blogs.msdn.com/b/adonet/archive/2011/02/04/using-dbcontext-in-ef-feature-ctp5-part-10-raw-sql-queries.aspx">EF 4.1のDbContextのRaw SQL Queries</a>はどうなの？とTwitterで言ってたのを見かけたので、再度測ってみました。ていうか私はDbContextとObjectContextの違いすら分かってないんですが、DbContextは軽量な感じっぽいそうです、はい。</p>
<p>ベンチマークは前回と引き続き<a href="http://code.google.com/p/dapper-dot-net/">dapper-dot-net</a>のリポジトリにあるベンチを使用しました。それにEFのバージョンを4.2に上げて、DbContextのSqlQueryを追加。また、<a href="http://d.hatena.ne.jp/taedium/">id:taedium</a>さんの作られている<a href="http://soma.codeplex.com/">Soma</a>は最新バージョンの1.6にしておきました。そして私の作成しているMicro-ORMである<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>のベンチも引き続き載せています。Visual Studio 2005時代のデータアクセステクノロジである型付きDataSetも加えてあります。</p>
<blockquote>
<p>Mapper Query (non-buffered) took 55ms<br />
Dynamic Mapper Query (buffered) took 56ms<br />
Dynamic Mapper Query (non-buffered) took 56ms<br />
hand coded took 57ms<br />
<strong>DbExecutor ExecuteReader(Hand Coded) took 59ms</strong><br />
Dapper.Cotrib took 60ms<br />
OrmLite QueryById took 60ms<br />
<strong>DbExecutor Select took 60ms</strong><br />
Mapper Query (buffered) took 61ms<br />
PetaPoco (Fast) took 62ms<br />
PetaPoco (Normal) took 63ms<br />
<strong>DbExecutor SelectDynamic took 63ms</strong><br />
Dynamic Massive ORM Query took 64ms<br />
<strong>DbExecutor ExecuteReaderDynamic(Hand Coded) took 64ms</strong><br />
BLToolkit took 82ms<br />
Simple.Data took 87ms<br />
Linq 2 SQL Compiled took 96ms<br />
DataSet took 108ms<br />
SubSonic Coding Horror took 116ms<br />
Entity framework CompiledQuery took 120ms<br />
NHibernate SQL took 125ms<br />
NHibernate Session.Get took 128ms<br />
NHibernate HQL took 135ms<br />
Soma Find took 164ms<br />
NHibernate Criteria took 170ms<br />
Linq 2 SQL ExecuteQuery took 207ms<br />
Linq 2 SQL took 597ms<br />
NHibernate LINQ took 610ms<br />
Entity framework ExecuteStoreQuery took 634ms<br />
Entity framework DbContext SqlQuery took 670ms<br />
Entity framework ESQL took 725ms<br />
Entity framework took 900ms<br />
Entity framework No Tracking took 903ms<br />
SubSonic ActiveRecord.SingleOrDefault took 3736ms</p>
</blockquote>
<p>hand codedがExecuteReaderを手で回した手書き、「Mapper Query」はDapperのことです。複数種類があるのはオプション違い。DbExecutor(太字にしています)も同様に4種類で測っています。上位陣は何回も測ると適当に入れ替わりますし、速度的にも500回ブン回して数msとか、ほとんど誤差範囲でいいのではかと思います。</p>
<p>というわけで、ええと、EntityFrameworkの遅さが目立ちますね、CompiledQueryは割といいのですが、むしろそうしないと絶望的。特に、文字列で生SQLを書くはずのExecuteStoreQueryやSqlQueryがクソみたいに遅いのはどういうことなのかと問いつめたい。更に、軽量なはずのDbContextのSqlQueryよりもObjectContextのExecuteStoreQueryのほうが速いとか、頭痛くなります。オマケ機能だと思ってテキトーなのではかと思われる気がかなりします、MSもっと本気出せ。</p>
<p>DataSetが割と健闘しちゃってるのが、DataSet嫌いな私としては何とも言い難い感じです(笑)</p>
<p>まぁ、DbExecutorが速さと使い勝手を両立しているので、Micro-ORMでいいならDbExecutor使うといいですよ、はい。メンテしてないって？はい、そうですね……。割と真面目な話、色々機能拡張したいというかしなければならない必然性とかが迫っていたりしたりしなかったりするので、近いうちに再度動き出すつもりではいます。なので使ってみるといいと思います。</p>
</div>
<h1 data-pagefind-sort="date:2012-01-16" data-pagefind-meta="published:2012-01-16"><a href="https://neue.cc/2012/01/16_362.html">XboxInfoTwit - ver.2.4.0.2</a></h1>
<ul class="date"><li>2012-01-16</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comがリニューアルしたので、それに対応しました。今回は3日ほど本気で気づいていなくて対応が遅れてごめんなさい。最近はコメントやリクエストも放置気味で、大変反省しています。転職して少し忙しくなって、あまり気が回らなくて、という言い訳カッコワルイ。もう少し頑張ります。例によって全くテストしてないので、こいつ放置気味だしどうせ反応してくれないしいいかー、とか思わず、どうか変なところあったら報告お願いいたします。</p>
<p>あ、あと、今回からエラー時に前回の状態をリセットしないように変更しました。どういうことかというと、何らかのエラー(Xbox.comが不調だったり←よくある、Twitterが不調だったり)によって状態がリセットされた結果として、Power Onの投稿が連投されたりしてナンジャコリャー、といったような状態になることが防げます。多分。恐らく。きっと。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-30" data-pagefind-meta="published:2011-12-30"><a href="https://neue.cc/2011/12/30_361.html">2011年を振り返る</a></h1>
<ul class="date"><li>2011-12-30</li></ul>
<div class="entry_body"><p>一年、ありがとうございました。何とか生き延びれました。ブログも冬眠せず続けられましたし、よきかなよきかな。</p>
<p>今年は色々ありました。やはり一番大きかったのは<a href="http://neue.cc/2011/04/02_313.html">Microsoft MVP for Visual C#</a>の受賞ですね。と、いっても、今まで通りブログを書いてライブラリを書いて、というわけで、別に今までと何が変わったわけでもありません。ただ、肩書きとして威力があったりなかったり、というのはあります。あと、出す情報に関してはある程度は責任というか、適当すぎることは書けないかな、という意識は持ちました。</p>
<p>良くも悪くもといえば、やはりラベルが貼られると、ラベルに沿って動いてしまうというのが人の性かもしれません。少しC#贔屓が強くなりすぎたかもねー、とか。ちょっと反省。それと、他の言語を全然学べなかったなあ、というのもよくなかった。今年はちょっと色々なことに追われすぎたというかRx-WP7-Async-Roslynと、C#だけでいっぱいいっぱいだったのです……。結局Roslynはあまり追えてないし。</p>
<p>@ITでの連載 <a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a> がスタートしたり、C#ユーザー会で<a href="http://www.slideshare.net/neuecc/code-contracts-8069150">基礎からのCode Contracts</a>、すまべんで<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>、Silverlight Squareで<a href="http://www.slideshare.net/neuecc/reactiveproperty-slintokyo4">ReactiveProperty - slintokyo4</a>といった、幾つかの勉強会で発表させて頂いたりなど、結構動き出した年でもありました。</p>
<h2>ゲーム</h2>
<p>死ぬほどプレイ、しなかった……。積みゲーどころか買ったけど封すら開けなかったり。こんな私は想像できなかったなあ。しかも別に時間がないわけじゃなくてさあ、だらだらとネット見てTwitter見てるだけなんですよ。ただ無駄に時間を捨てているだけで。楽しみだったはずのSkyrimにすら手を出していない。ふぅー、来年はちゃんとメリハリつけて付き合いたいものです。ねえ、だらだらネット見てるだけって、だらだらTV見てるだけと何も違わないぢゃあないか。</p>
<h2>C#</h2>
<p>ライブラリも色々作りました。その時の関心ごとに応じて、徹底的に調べて、不満をライブラリ作って解消する、というのが基本的なスタイルでした。ユニットテストの書き方が気に入らないから<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>を作り、DBへの生クエリ周りが気に入らないから<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>を作り、INotifyPropertyChangedが気に入らないから<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty</a>を作った。関心ごとが見つかったら、深くダイブして、新しいやり方を見つけ出す。なんていうとご立派ですが、本当に新しいこと、なんてないのですよね。既存の断片は幾らでも見つかる。だから、それらもまた徹底的に調査して、そして、自分の気にいるように融和させていく。</p>
<p>ずっと<a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>をlowerCamelCaseに変更する！と思ってたのですが未だにできてはいなくて。よくないですね。ちょうど今日、新しい<a href="http://nuget.org/packages/RxJS-All">Reactive Extensions for JavaScript</a>が出ました。詳しくは年明け早々に紹介したいと思いますが、これはちゃんとlowerCamelCaseになってます。いつまでも遅れていちゃマズい。</p>
<h2>来年</h2>
<p>ここで言うことか？という話ではありますが、12月で会社を退職し(て)ました。1月からは新しい会社で働くことになります。次の会社でもC#をメインにやっていきます（ということで雇われるわけでもありますので）。しっかり成果を出していきたいし、事例やコードなんかも、出せるならガシガシ出したいと思っています。その辺のことは追々。</p>
<p>来年は、MVP絡みで米MS本社でのMVP Global Summitもあり、新しい会社で働く（初めての転職です）ことにもなるしで、私としてもかなり転機な年になるのではという予感がしています。不安もありますが、同時に楽しみでもあります。<a href="http://neue.cc/2010/12/31_294.html">2010年を振り返る</a>で、来年には更なる成長のために動き出したい、などと言っていましたが、一応はしっかりとスタートを踏み出せたようです。</p>
<p>そんな感じですが、来年もよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-21" data-pagefind-meta="published:2011-12-21"><a href="https://neue.cc/2011/12/21_360.html">RxとパフォーマンスとユニットテストとMoles再び</a></h1>
<ul class="date"><li>2011-12-21</li></ul>
<div class="entry_body"><p><a href="http://atnd.org/events/21988">C# Advent Calendar 2011</a>、順調に進んでいますね。どのエントリも力作で大変素晴らしいです。私はこないだ<a href="http://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a>というものを書きました。はてブ数は現段階で45、うーん、あまり振るわない……。私の力不足はともかくとしても、他の言語だったらもっと伸びてるだろうに、と思うと、日本のC#の現状はそんなものかなあ、はぁ、という感じではあります。はてブが全てではない（むしろ斜陽？）とはいえ、Twitterでの言及数などを見ても、やっぱまだまだまだまだまだまだ厳しいかなあ、といったところ。Unityなどもあって、見ている限りだと人口自体は着実に増えている感じではありますけれど、もっともっと、関心持ってくれる人が増えるといいな。私も微力ながら尽力したいところです。</p>
<p>ところで、<a href="http://d.hatena.ne.jp/ZOETROPE/">id:ZOETROPE</a>さんのAdvent Calendarの記事、<a href="http://d.hatena.ne.jp/ZOETROPE/20111220#1324392149">Reactive Extensionsでセンサプログラミング</a>が大変素晴らしい！センサー、というと私だとWindows Phone 7から引っ張ってくるぐらいしか浮かばないのですが（最近だとKinectもHotですか、私は全然触れてませんが……）おお、USB接続のレンジセンサ！完全に門外漢な私としては、そういうのもあるのか！といったぐらいなわけですが、こうしてコード見させていただくと、実践的に使うRxといった感じでとてもいいです。</p>
<p>記事中で扱われているトピックも幅広いわけですが、まず、パフォーマンスに関しては少し補足を。@okazukiさんの<a href="http://d.hatena.ne.jp/okazuki/20111214/1323828027">見せてもらおうじゃないかReactive Extensionsの性能とやらを！ その２</a>のコメント欄でもちょっと言及したのですが、この測り方の場合、Observable.Rangeに引っ張られているので、ベンチマークの値はちょっと不正確かな、と思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 1000回イベントが発火(発火の度に長さ3000のbyte配列が得られる)を模写
static IObservable&lt;byte[]&gt; DummyEventsRaised()
{
    return Observable.Repeat(new byte[3000], 1000, Scheduler.Immediate);
}

// 配列をバラす処理にObservable.Rangeを用いた場合
static IObservable&lt;byte&gt; TestObservableRange()
{
    return Observable.Create&lt;byte&gt;(observer =&gt;
    {
        return DummyEventsRaised()
            .Subscribe(xs =&gt;
            {
                Observable.Range(0, xs.Length, Scheduler.Immediate).ForEach(x =&gt; observer.OnNext(xs[x]));
            });
    });
}

// 配列をバラす処理にEnumerable.Rangeを用いた場合(ForEachはIxのもの)
static IObservable&lt;byte&gt; TestEnumerableRange()
{
    return Observable.Create&lt;byte&gt;(observer =&gt;
    {
        return DummyEventsRaised()
            .Subscribe(xs =&gt;
            {
                Enumerable.Range(0, xs.Length).ForEach(x =&gt; observer.OnNext(xs[x]));
            });
    });
}

// SelectManyでバラす場合
static IObservable&lt;byte&gt; TestSelectMany()
{
    return DummyEventsRaised().SelectMany(xs =&gt; xs);
}

static void Main(string[] args)
{
    // ベンチマーク補助関数
    Action&lt;Action, string&gt; bench = (action, label) =&gt;
    {
        var sw = Stopwatch.StartNew();
        action();
        Console.WriteLine(&quot;{0,-12}{1}&quot;, label, sw.Elapsed);
    };

    // 配列をばらすケースは再度連結する(ToList)
    bench(() =&gt; TestObservableRange().ToList().Subscribe(), &quot;Ob.Range&quot;);
    bench(() =&gt; TestEnumerableRange().ToList().Subscribe(), &quot;En.Range&quot;);
    bench(() =&gt; TestSelectMany().ToList().Subscribe(), &quot;SelectMany&quot;);
    // 配列をばらして連結せず直接処理する場合
    bench(() =&gt; TestSelectMany().Subscribe(), &quot;DirectRx&quot;);
    // byte[]をばらさず直接処理する場合
    bench(() =&gt; DummyEventsRaised().Subscribe(xs =&gt; { foreach (var x in xs);}), &quot;DirectLoop&quot;);

    // 実行結果
    // Ob.Range    00:00:02.2619670
    // En.Range    00:00:00.2600460
    // SelectMany  00:00:00.2701137
    // DirectRx    00:00:00.0852836
    // DirectLoop  00:00:00.0152816
}
</code></pre>
<p>得られる配列をダイレクトに処理するとして、Observable.Rangeで配列のループを回すと論外なほど遅い。のですが、しかし、この場合ですとEnumerable.Rangeで十分なわけで、そうすれば速度は全然変わってきます（もっと言えば、ここではEnumerable.Rangeではなくforeachを使えば更に若干速くなります）。更に、これは配列を平坦化している処理とみなすことができるので、observerを直に触らず、SelectManyを使うこともできますね。そうすれば速度はほとんど変わらず、コードはよりすっきり仕上がります。</p>
<p>と、いうわけで、遅さの原因はObservable.Rangeです。Rangeが遅いということはRepeatやGenerateなども同様に遅いです。遅い理由は、値の一つ一つをISchedulerを通して流しているから。スケジューラ経由であることは大きな柔軟性をもたらしていますが、直にforeachするよりもずっとずっと遅くなる。なので、Enumerableで処理出来る局面ならば、Enumerableを使わなければなりません。これは、使うほうがいい、とかではなくて、圧倒的な速度差となるので、絶対に、Enumerableのほうを使いましょう。</p>
<p>また、一旦配列をバラして、再度連結というのは、無駄極まりなく、大きな速度差にも現れてきます。もし再度連結しないでそのまま利用(ベンチ結果：DirectRx)すれば直接ループを回す(ベンチ結果：DirectLoop)よりも5倍程度の遅さで済んでいます。このぐらいなら許容範囲と言えないでしょうか？とはいえ、それでも、遅さには違いないわけで、避けれるのならば避けたほうがよいでしょう。</p>
<p>ZOETROPEさんの記事にあるように、ここはばらさないほうが良い、というのが結論かなあ、と思います。正しくは上流ではばらさない。一旦バラしたものは復元不可能です。LINQで、パイプラインで処理を接続することが可能という性質を活かすのならば、なるべく後続で自由の効く形で流してあげたほうがいい。アプリケーション側でバラす必要があるなら、それこそSelectMany一発でばらせるのだから。</p>
<p>例えばWebRequestで配列状態のXMLを取ってくるとします。要素は20個あるとしましょう。最初の文字列状態だけを送られてもあまり意味はないので、XElement.Parseして、実際のクラスへのマッピングまではやります。例えばここではPersonにマッピングするとして、長さ1のIObservable&lt;Person[]&gt;です。しかし、それをSelectManyして長さ20のIObservable&lt;Person&gt;にはしないほうがいい。ここでバラしてしまうと長さという情報は消滅してしまうし、一回のリクエスト単位ではなくなるのも不都合が生じやすい。もしアプリケーション的にフラットになっていたほうが都合が良いのなら、それはまたそれで別のメソッドとして切り分けましょう。</p>
<h2>成功と失敗の一本化</h2>
<p>ZOETROPEさんの記事の素晴らしいのは、通常のルート(DataReceived)と失敗のルート(ErrorReceived)を混ぜあわせているところ！これもまたイベントの合成の一つの形なわけなんですねー。こういう事例はWebClientのDownloadStringAsyncのような、EAP(Eventbased Asynchronous Programming)をTaskCompletionSourceでラップしてTaskに変換する <a href="http://msdn.microsoft.com/ja-jp/library/ee622454.aspx">方法: タスクに EAP パターンをラップする</a>←なんかゴチャゴチャしていますが、TrySetCanceled, TrySetException, TrySetResultで結果を包んでいます、というのと似た話だと見なせます。</p>
<p>WebClientではEventArgsがCancelledやErrorといったステータスを持っているのでずっと単純ですが、SerialPortではエラーは別のイベントでやってくるのですね。というわけで、私もラップしてみました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class SerialPortExtensions
{
    // 面倒くさいけれど単純なFromEventでのイベントのRx化
    public static IObservable&lt;SerialDataReceivedEventArgs&gt; DataReceivedAsObservable(this SerialPort serialPort)
    {
        return Observable.FromEvent&lt;SerialDataReceivedEventHandler, SerialDataReceivedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; serialPort.DataReceived += h, h =&gt; serialPort.DataReceived -= h);
    }

    public static IObservable&lt;SerialErrorReceivedEventArgs&gt; ErrorReceivedAsObservable(this SerialPort serialPort)
    {
        return Observable.FromEvent&lt;SerialErrorReceivedEventHandler, SerialErrorReceivedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; serialPort.ErrorReceived += h, h =&gt; serialPort.ErrorReceived -= h);
    }

    // DataReceived(プラスbyte[]化)とErrorReceivedを合成する
    public static IObservable&lt;byte[]&gt; ObserveReceiveBytes(this SerialPort serialPort)
    {
        var received = serialPort.DataReceivedAsObservable()
            .TakeWhile(e =&gt; e.EventType != SerialData.Eof) // これでOnCompletedを出す
            .Select(e =&gt;
            {
                var buf = new byte[serialPort.BytesToRead];
                serialPort.Read(buf, 0, buf.Length);
                return buf;
            });

        var error = serialPort.ErrorReceivedAsObservable()
            .Take(1) // 届いたらすぐに例外だすので長さ1として扱う（どうせthrowするなら関係ないけど一応）
            .Do(x =&gt; { throw new Exception(x.EventType.ToString()); });

        return received.TakeUntil(error); // receivedが完了した時に同時にerrorをデタッチする必要があるのでMergeではダメ
    }
}
</code></pre>
<p>成功例と失敗例を合成して一本のストリーム化。また、DataReceivedはそのままじゃデータすっからかんなので、Selectでbyte[]に変換してあげています。これで、ObserveReceiveBytes拡張メソッドを呼び出すだけで、かなり扱いやすい形になっている、と言えるでしょう。パフォーマンスも、これなら全く問題ありません。</p>
<h2>MolesとRx</h2>
<p>と、ドヤ顔しながら書いていたのですが、とーぜんセンサーの実物なんて持ってませんので動作確認しようにもできないし。ま、まあ、そういう時はモックとか用意して、ってSerialDataReceivedEventArgsはパブリックなコンストラクタないし、ああもうどうすればー。と、そこで出てくるのが<a href="http://research.microsoft.com/en-us/projects/moles/">Moles - Isolation framework</a>。以前に<a href="http://neue.cc/2011/03/10_309.html">Rx + MolesによるC#での次世代非同期モックテスト考察</a>という記事で紹介したのですが、めちゃくちゃ強力なモックライブラリです。パブリックなコンストラクタがないとか関係なくダミーのインスタンスを生成可能だし、センサーのイベントだから作り出せないし、なんてこともなく自由にダミーのイベントを発行しまくれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestClass]
public class SerialPortExtensionsTest : ReactiveTest
{
    [TestMethod, HostType(&quot;Moles&quot;)]
    public void ObserveReceiveBytesOnCompleted()
    {
        // EventArgsを捏造！
        var chars = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Chars };
        var eof = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Eof };
        // SerialPort::BytesToRead/SerialPort::Readで何もしない
        MSerialPort.AllInstances.BytesToReadGet = (self) =&gt; 0;
        MSerialPort.AllInstances.ReadByteArrayInt32Int32 = (self, buffer, offset, count) =&gt; 0;

        var scheduler = new TestScheduler();

        // 時間10, 20, 30, 40でSerialData.Charsのイベントを、時間50でEofのイベントを発行
        MSerialPortExtensions.DataReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
                OnNext(10, chars),
                OnNext(20, chars),
                OnNext(30, chars),
                OnNext(40, chars),
                OnNext(50, eof))
            .Select(x =&gt; (SerialDataReceivedEventArgs)x);

        // 走らせる(戻り値のbyte[]はどうでもいいので無視するためUnitに変換)
        var result = scheduler.Start(() =&gt; new SerialPort().ObserveReceiveBytes().Select(_ =&gt; Unit.Default), 0, 0, 100);

        result.Messages.Is(
            OnNext(10, Unit.Default),
            OnNext(20, Unit.Default),
            OnNext(30, Unit.Default),
            OnNext(40, Unit.Default),
            OnCompleted&lt;Unit&gt;(50));
    }

    [TestMethod, HostType(&quot;Moles&quot;)]
    public void ObserveReceiveBytesOnError()
    {
        // EventArgsを捏造！
        var chars = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Chars };
        var eof = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Eof };
        // SerialPort::BytesToRead/SerialPort::Readで何もしない
        MSerialPort.AllInstances.BytesToReadGet = (self) =&gt; 0;
        MSerialPort.AllInstances.ReadByteArrayInt32Int32 = (self, buffer, offset, count) =&gt; 0;

        var scheduler = new TestScheduler();

        // 時間10, 20, 30, 40でSerialData.Charsのイベントを、時間50でEofのイベントを発行
        MSerialPortExtensions.DataReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
                OnNext(10, chars),
                OnNext(20, chars),
                OnNext(30, chars),
                OnNext(40, chars),
                OnNext(50, eof))
            .Select(x =&gt; (SerialDataReceivedEventArgs)x);

        /* ↑までOnCompletedのものと共通 */

        // 時間35でErrorのイベントを発行
        MSerialPortExtensions.ErrorReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
            OnNext&lt;SerialErrorReceivedEventArgs&gt;(35, new MSerialErrorReceivedEventArgs()));

        // 走らせる(戻り値のbyte[]はどうでもいいので無視するためUnitに変換)
        var result = scheduler.Start(() =&gt; new SerialPort().ObserveReceiveBytes().Select(_ =&gt; Unit.Default), 0, 0, 100);

        // Exceptionの等値比較ができないので、バラしてAssertする
        result.Messages.Count.Is(4);

        result.Messages[0].Is(OnNext(10, Unit.Default));
        result.Messages[1].Is(OnNext(20, Unit.Default));
        result.Messages[2].Is(OnNext(30, Unit.Default));

        result.Messages[3].Value.Kind.Is(NotificationKind.OnError);
        result.Messages[3].Time.Is(35);
    }
}
</code></pre>
<p>アサーションに使っているIsメソッドは、いつも通り<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>です。</p>
<p>Molesがいくら強力だとは言っても、イベントをそのまま乗っ取るのはデリゲートの差し替えなどで、割と面倒だったりします。しかし、FromEventでラップしただけのIObservable&lt;T&gt;を用意しておくと…… それを差し替えるだけで済むので超簡単になります。イベント発行については、TestScheduler(Rx-Testingを参照しておく)で、仮想時間で発行する値を作ってしまうと楽です。こういう、任意の時間で任意の値、というダミーの用意もFromEventでラップしただけのIObservable&lt;T&gt;があると、非常に簡単になります。</p>
<p>あとは、scheduler.Startで走らせると(3つの引数はそれぞれcreated, subscribed, disposedの仮想時間、何も指定しないと…… 実は0始まり「ではない」ことに注意。100,200,1000がデフォなので、0はすっ飛ばされています)、その戻り値で結果を受け取って、Messagesに記録されているので、それにたいしてアサートメソッドをしかける。</p>
<p>実に簡単ですね！Molesの力とRxの力が組み合わさると、イベントのテストが恐ろしく簡単になります。素敵じゃないでしょうか？</p>
<h2>まとめ</h2>
<p>テストなしで書いてたコードは、Molesでテスト走らせたら間違ってました。TakeWhileの条件が==だったのと、Mergeで結合していたり……。はっはっは、ちゃんとユニットテストは書かないとダメですね！そして、Molesのお陰でちゃんと動作するコードが書けたので恥を欠かなくてすみました、やったね。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-16" data-pagefind-meta="published:2011-12-16"><a href="https://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a></h1>
<ul class="date"><li>2011-12-16</li></ul>
<div class="entry_body"><p><a href="http://atnd.org/events/21988">C# Advent Calendar 2011</a>、ということで、C# 4.0時代のプログラミングスタイルについて説明してみます。モダン、というけれど、某書のように変態的なことじゃなくて、むしろ基本的な話のほうです。こういったものはナマモノなので、5.0になればまた変わる、6.0になればまた変わる。変わります。古い話を間に受けすぎないこと(歴史を知るのは大事だけど、そのまま信じるのは別の話)、常に知識をリフレッシュするようにすること。そういうのが大事よね。でも、だからってモダンに書けなきゃダメ！なんてことはありません。ただ、知ること、少しずつ変えていくこと、そういうのは大事よね、って。</p>
<p>ところでしかし、私の主観がかなり入っているので、その辺は差っ引いてください。</p>
<ol>
<li>varを使う</li>
</ol>
<hr />
<p>C# 3.0から搭載された型推論での宣言。出た当初には散々議論があって、今もたまに否の意見が出てきたりもしますが、varは使いましょう。積極的に。何にでも。国内的にも世界的にもMicrosoft的にも、var積極利用の方向で傾いているように見えます。また、最近流行りの関数型言語(Haskell, Scala, F#)は、少なくともC#のvarで可能な範囲は全て推論を使いますね←C#のvarはそれらに比べれば遥かに貧弱ですからね。そういったこともあるので、使わない理由もないでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var person = new Person();
var dict = new Dictionary&lt;string, Tuple&lt;int, Person&gt;&gt;();
var query = Enumerable.Range(1, 10).Select(x =&gt; x * 10);
</code></pre>
<p>varの利点は、何といっても書いていて楽なことです。はい、圧倒的に楽です。そして、型宣言の長さが一致するので「実は見やすい」というのもポイント高し。たった3文字の短さと相まって、ソースコードが綺麗になります。また、必ず変数の初期化を伴う、というのも良いことです。</p>
<p>欠点は「メソッドの戻り値などは宣言を見ても型が分からない」「インターフェイスで宣言できない」の二つが代表的でしょうか。前者は、Visual Studioを使えばマウスオーバーで型が表示されるので、コーディング上では支障はない。メールやBlogやWikiなど、Visual Studioのサポートのない完全にコードのみの状態だとサッパリなのは確かに難点ではありますが、逆にその程度の部分的な範囲なら、括り出されている目的が明確なわけなので、適切な変数名がついているのなら、正確な型名とまではいかずとも何に使うもののか大体分かるのではないでしょうか？なので、大きな問題だとは私は思いません。もし変数名がテキトーで型名ぐらいしかヒントが得られないんだよ！ということならば、varよりも前にまともな変数名をつけるようにしたほうがいいです。</p>
<p>インターフェイスで宣言できないことは、私は何の問題もないと思っています。具象型やメソッドの返す型でそのまま受けることに何の不都合が？むしろインターフェイスで宣言すると、アップキャスト可能という怪しい状態を作り出しているだけです。</p>
<p>ちなみにintやstring、配列などの基本的なものぐらいは型を書くという流儀もなくはないようですが、それは意味無いのでやめたほうがいいでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var num = 100;
var text = &quot;hogehoge&quot;;
var array = new[] { 1, 2, 3, 4, 5 };
</code></pre>
<p>だって、こういうのこそ、見れば一発で分かるほど自明なので。</p>
<ol start="2">
<li>オプション引数を使う(使いすぎない)</li>
</ol>
<hr />
<p>害悪もあるわけですが、割と積極的に使ってもいいような気がします。実際Roslyn CTPなどでは結構派手に使われていますし、オーバーロード地獄よりはIntelliSense的にも分かりやすいかな、って。思います。enumなど使うと、明確に何が使われるか見えるんですね、これはとても嬉しくて。やっぱC#としてはIntelliSenseで分かりやすい、というのはとても大事かと。</p>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/csadvent_1.jpg">
</p>
<p>さて、分かりやすく使いすぎに注意な点としては、引数なしコンストラクタが消滅してしまう可能性があげられます。引数なしコンストラクタがないと、色々なところで弊害が起こります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなオプション引数なコンストラクタしかないクラスがあるとして
public class ToaruClass
{
    public ToaruClass(int defaultValue = -1)
    {

    }
}

class Program
{
    static T New&lt;T&gt;() where T : new()
    {
        return new T();
    }

    static void Main(string[] args)
    {
        // 使うときは引数なしでnewできるけど
        var _ = new ToaruClass();

        // 実態は違うので、ジェネリックのnew制約が不可能になる
        New&lt;ToaruClass&gt;(); // コンパイル通らない

        // 引数なしコンストラクタを要求するシリアライザの利用も不可能に
        new XmlSerializer(typeof(ToaruClass)).Serialize();
    }
}
</code></pre>
<p>シリアライズできなかったりジェネリックのnew制約がきかなくなってしまったり。ご利用は計画的に。シリアライズに関しては、DataContractSerializerならばコンストラクタを無視するので使えはしますが……。その辺の話は<a href="http://neue.cc/2011/12/10_357.html">neue cc - .NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a>で。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/roslyn">Roslyn CTP</a>のAPIはオプション引数が激しく使われているのですが、中でもこれは面白いと思いました。<a href="http://www.mindscapehq.com/blog/index.php/2011/10/20/in-bed-with-roslyn/">Mindscape Blog » Blog Archive » In bed with Roslyn</a>から引用します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">PropertyDeclarationSyntax newProperty = Syntax.PropertyDeclaration(
    modifiers: Syntax.TokenList(Syntax.Token(SyntaxKind.PublicKeyword)),
    type: node.Type,
    identifier: node.Identifier,
    accessorList: Syntax.AccessorList(
        accessors: Syntax.List(
            Syntax.AccessorDeclaration(
                kind: SyntaxKind.GetAccessorDeclaration,
                bodyOpt: Syntax.Block(
                    statements: Syntax.List(
                        getter
                    )
                )
            ),
            Syntax.AccessorDeclaration(
                kind: SyntaxKind.SetAccessorDeclaration,
                bodyOpt: Syntax.Block(
                    statements: Syntax.List(
                        setter
                    )
                )
            )
        )
    )
);
</code></pre>
<p>そう、名前付き引数でツリー作ってるんですね。<a href="http://msdn.microsoft.com/ja-jp/library/bb387019.aspx">LINQ to XMLの関数型構築</a>も面白いやり方だと思いましたが、この名前付き引数を使った構築も、かなり素敵です。流行るかも！</p>
<ol start="3">
<li>ジェネリックを使う</li>
</ol>
<hr />
<p>もしお持ちの本がArrayListやHashTableを使っているコードが例示されていたら、窓から投げ捨てましょう。Silverlightでは廃止されていますし、WinRT(Windows 8)でも、勿論そんな産廃はありません。もはやどこにもそんなものを使う理由はありません。どうしても何でも入れられるListが欲しければ、List&lt;object&gt;を使えばいいぢゃない。</p>
<ol start="4">
<li>ジェネリックデリゲート(Func, Action)を使う</li>
</ol>
<hr />
<p>これも賛否両論ではあるのですが、私は断然ジェネリックデリゲート派です。ちなみにその反対は野良デリゲート量産派でしょうか（悪意のある言い方！）。ジェネリックデリゲートを使うと良い点は、デリゲートの型違い（同じ引数・戻り値のデリゲートでも型が違うとキャストが必要）に悩まされなくてすむ、定義しなくていいので楽、そして、なにより分かりやすい。例えば、「MatchEvaluator」というだけじゃ、何なのかさっぱり分かりません。正規表現のReplaceで使われるデリゲートなのですけどね。Func&lt;Match, string&gt;のほうが、ずっと分かりやすい。</p>
<p>では良くない点は、というと、引数に変数名で意味をつけられない。例えばLINQのSelectメソッドのFunc&lt;TSource, int, TResult&gt;。このintはインデックスですが、そのことはドキュメントコメントからしか分かりません。その点、野良デリゲートを作れば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public delegate TR ConverterWithIndex&lt;T, TR&gt;(T value, int index);
</code></pre>
<p>という形で、明示できます。なんて素晴らしい？そう？実のところそんなでもなくて、これ、IntelliSenseからじゃあ分からないんですよね。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/csadvent_2.jpg">
</p>
<p>F12なりなんなりで型定義まで飛ばないと見えないのです、デリゲートの変数名は。その点Func&lt;Match, string&gt;なら引数の型、戻り値の型がIntelliSenseで見えるわけでして。C#的にはIntelliSenseで見えないと価値は9割減です。というわけで、天秤にかければ、圧倒的にFuncの大勝利。引数ずらずらでイミフになるならドキュメントコメントに書くことで補う、でもいいぢゃない。</p>
<p>ちなみにoutやrefのジェネリックデリゲートは存在しないので、その場合のみ自作デリゲートを立てる必要があります。それ以外、つまるところ99%ぐらいはFunc, Action, EventHandler&lt;T&gt;でいいと思います。LINQだってPredicateじゃなくてFunc&lt;T, bool&gt;だしね。</p>
<ol start="5">
<li>ラムダ式を使う</li>
</ol>
<hr />
<p>ラムダ式(C# 3.0)を使わなければ何を使うのって話ですが、ラムダ式の登場により割を食った匿名メソッド(C# 2.0)は産廃です。唯一の利点は、匿名メソッドは引数を使わない場合は省略して書けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 引数省略して書けるぞ！
button.Click += delegate { MessageBox.Show(&quot;hoge&quot;); };
// ラムダ式の場合は省略できないんだ(棒)
button.Click += (_, __) =&gt; MessageBox.Show(&quot;hoge&quot;);
</code></pre>
<p>こんなことは実にどうでもいいので、匿名メソッドを使うのはやめましょう。もしラムダ式が先にあれば、匿名メソッドはなかったと思います。ジェネリックが最初からあれば非ジェネリックコレクションクラスがなかっただろう、ということな程度には。あとジェネリックが先にあれば野良デリゲートもなかった気がする。なので、多少どうでもいい利点があったとしても、素直に使わないのが一番。</p>
<p>ところでラムダ式の引数の名前ですが、どうしていますか？私は、昔は型名から取っていました、例えばintだったらi、stringだったらs。でも最近は全てxにしています。理由は、面倒くさいし適切な名前が出てこない場合もあるし修正漏れが起こったりする（ハンガリアンみたいなもんですしねえ）などなどで、メリットを感じなかったので。</p>
<p>ちなみに、ラムダ式で長い名前を使うのは反対です。「名前はしっかりつけなきゃダメ！」が原則論のはずなのにxってなんだよそれって感じですが、逆に、小さい範囲のものは小さいほうがいいのです。名前をつけないことで、他の名前のついているものを強調します。なんでもかんでも名前をつけていると五月蝿くて、木を森に隠す、のようになってしまいます。LINQやRxでラムダ式だらけになると、なおそうです。勿論、ラムダ式だからって全てxにするわけではありません。中でネストしてネスト内でも使われたり、式ではなく文になってスコープが長くなっている場合などは、ちゃんと名前をつけます。また、（分かりやすさのため）強く意味を持たせたい場合も名前をつけます。型名以上の意味を持たせられないのなら、あえて名前をつける必要性を感じないのでxです。</p>
<p>そういうわけで、多少崩すこともありますが、原則的に私の命名規則は「ただの変数 = x, 配列などコレクション = xs, 引数を使わない = アンダースコア」としています。xのかわりにアンダースコアを使う流儀もあるようですが、私は嫌いですね……。Scalaのアンダースコアとは意味が違う感じもあるし、同じ.NETファミリーならばF#が引数を使わないという意味でアンダースコアを使っているので、それに合わせたほうがいいと思っています。xだと座標のxと被る、という場合は座標のxにつける変数名をpointXだかpxだかに変えます。</p>
<p>Exceptionはexにしたり、イベントの場合は(sender, e)にしたりはしますけれど、このへんは慣習ですし、わざわざ崩すほうが変かな。あとLINQでのGroupingはgを使ったりしますね。</p>
<ol start="6">
<li>LINQを使う（主にメソッド構文を使う、クエリ構文もたまには使う）</li>
</ol>
<hr />
<p>LINQはデータベースのためだけじゃなく、むしろ通常のコレクションへの適用(LINQ to Objects)のほうが多い。そんなにコレクション操作することなんてない、わけがない、はず。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 配列の中のYから始まるものの名前(スペースできった最後のもの)を取り出す
new[] { &quot;Yamada Tarou&quot;, &quot;Yamamoto Jirou&quot;, &quot;Suzuki Saburou&quot; }
    .Where(x =&gt; x.StartsWith(&quot;Y&quot;))
    .Select(x =&gt; x.Split(' ').Last());
</code></pre>
<p>上の例のような、Where（フィルタリング）+ Select（射影）は特に良く使うパターンです。Pythonなどでもリスト内包表記としてパッケージされるぐらいには。やはり、この手の処理を持っていないと、重苦しい。しかし、C# 3.0はLINQを手にしたので、お陰で軽快に飛び回れるようになりました。しかもただのフィルタ＋射影だけではなく、ありとあらゆる汎用コレクション処理を、チェーンで組み合わせることで、無限のパターンを手にしました。</p>
<p>LINQにはメソッド構文とクエリ構文があり、どちらも同じですがメソッド構文のほうが機能豊富だし、分かりやすいです。なのでメソッド構文でメソッドチェーンﾊｧﾊｧしましょう。<a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>で同様の記法でJavaScriptでも使えますし！</p>
<p>じゃあクエリ構文に利点はないのかというと当然そんなことはなく、多重from(SelectManyに変換される)が多く出現する場合はクエリ構文のほうがいいですね。また、Joinなどもクエリ構文のほうが書きやすいし、GroupJoinと合わせた左外部結合を記述したりなど複雑化する場合はクエリ構文じゃないと手に負えません（書けなくはないんですけどねえ）</p>
<p>それと、LINQ to SQLなどExpression Treeをそれぞれの独自プロパイダが解釈するタイプのものは、メソッド構文の豊富な記述可能性が逆に、プロパイダの解釈不能外に飛び出しがちなので、適度に制約の効いたクエリ構文だけで書いたほうがスムーズにいく可能性があります。</p>
<p>また、XMLはC#ではXmlReader/Writer, XmlDocument(DOM), XDocument(LINQ to XML)がありますが、そのうちDOMのXmlDocumentは産廃です。DOMって使いづらいのよね、それにSilverlightにはないし。メモリ内にツリーを持つタイプではXDocument(XElement)でLINQでﾊｧﾊｧするのが主流です。ちなみにXmlReader/Writerはストリーミング型なので別枠、ただ、生で使うことはあまりないと思います。特にWriterは、<a href="http://msdn.microsoft.com/ja-jp/library/system.xml.linq.xstreamingelement.aspx">XStreamingElement</a>を使えば省メモリなストリーミングで、Writeできる、しかもずっと簡単に。なので、使うことはないかと思います。</p>
<ol start="7">
<li>Taskを使う(生スレッドを使わない)</li>
</ol>
<hr />
<p>マルチスレッドプログラミングしなきゃ！Threadを使おう？デリゲートのBeginInvokeがある？それともThreadPool？BackgroundWorkerもあるぞ！古い記事はこれらの使用方法が解説されてきました。そうです、今まではそれらしかなかったので。けれど、全部ゴミ箱に投げ捨てましょう。.NET 4.0からは基本的原則的にTaskを使うべきです。豊富な待ち合わせ処理・継続・例外処理・キャンセルなどをサポートしつつ、同じスレッドを使いまわそうとするなど実行効率も配慮されています。もはや生スレッドを使う理由はないし、デリゲートのBeginInvokeなどともさよなら。BackgroundWorkerは、もう少しは出番あるかも(UIへの通知周りが今のTaskだけだと少し面倒、RxやC# 5.0のAsyncなら簡単にこなせるのですが)。</p>
<p>CPUを使う処理を並列に実行をしたいのなら、PLINQやParallel.ForEachなどが手軽かつ超強力です。</p>
<p>また、C# 5.0からはTaskの言語サポートが入り、awaitキーワードによりコード上では待機したように見せかけ同期的のように書けつつ中身は非同期で動く、といったことが可能になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async Task&lt;string&gt; GetBingHtml()
{
    var wc = new WebClient();
    var html = await wc.DownloadStringTaskAsync(new Uri(&quot;http://bing.com/&quot;));
    return html;
}
</code></pre>
<p>awaitするだけで同期的のように非同期が書けるなんて魔法のよう！</p>
<p>また、非同期といっても二つあります。CPUを沢山使って重たい処理と、I/O待ち（ネットワークやファイルアクセス）が重たい処理。これらへの対処は、別です。I/O待ちにスレッドを立てて対処することも可能ではありますが、あまり褒められた話ではありません。と、C#たんが<a href="http://csharptan.wordpress.com/2011/12/10/%e9%9d%9e%e5%90%8c%e6%9c%9fio%e5%be%85%e3%81%a1/">非同期I/O待ち</a>で言ってました。非同期I/Oは優れているのは分かったとしても、記述が面倒なのがネックだったのですね。しかし、C# 5.0からならばawaitが入るのでかなりサクッと書ける。非同期だって、node.jsにばかりは負けてられない！</p>
<p>なお、現在SilverlightやWindows Phone 7にはTaskがない(Silverlight 5にはTask入りました)ですが、将来的には間違いなく入るので、期待して待ちましょう。そして、分かりやすく書けるC# 5.0もwktkして待ちましょう。待ちきればければ<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360">Async CTP</a>として公開されているので、試すことが可能です。</p>
<ol start="8">
<li>Rxを使う</li>
</ol>
<hr />
<p>C# 5.0はCTPだし、現実問題として非同期に困ってるんだよ！という場合は、変化球としてReactive Extensionsが使えます。詳しくは<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a>で連載しているので読んでね！第二回がいつまでたっても始まらないのは何故なのでしょう、はい、私が原稿を送っていないからです、ごめんなさい……。これ書いてないで原稿書けやｺﾞﾙｧという感じですはい。いえ、もうすぐもう少しなので、ちょっと待ってください。</p>
<p>RxはTaskとは全く別の次元からやってきつつ、機能的にはある程度代替可能です。C# 5.0が来た時に共存できるのか、というと、非同期面ではTaskに譲るでしょう。けれど、非同期の生成をTaskで行なって、コントロールをawaitも使いつつRxでメインに使うとかも可能です。基本的に、コントロール周りはawaitサポートを除けばRxのほうが強力で柔軟です(代償として効率を若干犠牲にしているけれど)。ただまあ、基本的には非同期処理はTaskに絞られていくだろうと考えています。少し寂しいけど、全体としてより美しく書けるなら全然いいです、むしろ大歓迎なので早くC#5.0来ないかなあ。</p>
<p>ちなみに、Rxは別に非同期のためだけじゃなくて、イベントと、そしてあらゆるソースを合成するという点も見逃せないわけなので、決してAsync来たからRxさようなら、ではないです。その辺のことも連載であうあう。</p>
<ol start="9">
<li>Expressionを使う(そしてEmitしない)</li>
</ol>
<hr />
<p>Expressionの簡単な基本ですが、Expressionとして宣言します。Funcとほとんど同じで、違うのは型宣言だけです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 同じラムダ式だけれど
Expression&lt;Func&lt;int, int&gt;&gt; expr = x =&gt; x * x;
Func&lt;int, int&gt; func = x =&gt; x * x;

// Expressionで宣言すると実態は以下のものになる(コンパイラが自動生成する)
var paramX = Expression.Parameter(typeof(int), &quot;x&quot;);
var expr = Expression.Lambda&lt;Func&lt;int, int&gt;&gt;(
    Expression.Multiply(paramX, paramX),
    new[] { paramX });
</code></pre>
<p>Expressionで宣言するとコンパイラがコンパイル時に式木生成コードに変換してくれるのですね。自分で宣言しなくても、メソッドの引数の型がExpressionならば同じです。例えばQueryable.SelectのselectorはExpression型の引数なので、Queryableで連鎖を書いているということは同様に↑のようなコードが吐かれています。</p>
<p>Expressionの仕事は色々ありますが、概ね二つ。式がデータとして取り出せること。簡単な所ではINotifyPropertyChangedの実装なので話題沸騰したりしなかったりした、文字列ではなくプロパティを渡して、そこから引数名を取り出すことができること。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MyClass
{
    public string MyProperty { get; set; }
}

// これ
public static string GetPropertyName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; propertyExpression)
{
    return (propertyExpression.Body as MemberExpression).Member.Name;
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var propName = GetPropertyName(() =&gt; mc.MyProperty);
}
</code></pre>
<p>こんな形で推し進めたのが、LINQ to SQLなど、式木の塊を解釈してSQLに変換するといった、QueryProviderですね。</p>
<p>そしてもう一つはILビルダー。式木はCompileすることでFuncに変換することが可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// (object target, object value) =&gt; ((T)target).memberName = (U)value
static Action&lt;object, object&gt; CreateSetDelegate(Type type, string memberName)
{
    var target = Expression.Parameter(typeof(object), &quot;target&quot;);
    var value = Expression.Parameter(typeof(object), &quot;value&quot;);
 
    var left =
        Expression.PropertyOrField(
            Expression.Convert(target, type), memberName);
 
    var right = Expression.Convert(value, left.Type);
 
    var lambda = Expression.Lambda&lt;Action&lt;object, object&gt;&gt;(
        Expression.Assign(left, right),
        target, value);
 
    return lambda.Compile();
}
 
// Test
static void Main(string[] args)
{
    var target = new MyClass { MyProperty = 200 };
    var accessor = CreateSetDelegate(typeof(MyClass), &quot;MyProperty&quot;);
 
    accessor(target, 1000); // set
    Console.WriteLine(target.MyProperty); // 1000
}
</code></pre>
<p>少なくとも、自前でILを書くよりは圧倒的に簡単に、動的コード生成を可能にしました。動的コード生成はCompileは重いものの、一度生成したデリゲートをキャッシュすることで二度目以降は超高速になります。単純なリフレクションよりはずっと速く。といったようなことを<a href="http://neue.cc/2011/04/20_317.html">neue cc - Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化</a>で書いたので読んでね！</p>
<ol start="10">
<li>dynamicを使わない（部分的に使う）</li>
</ol>
<hr />
<p>一時期、LLブームで動的言語が持て囃されましたが、今は（静的型付けの）関数型言語ブームで、静的型付けへ寄り戻しが来ています。なので、C#もdynamicあって動的だよねひゃっほーい、なんてことはなく、むしろvarで型推論です(ｷﾘｯ のほうが正しくて。そんなわけで、dynamicはあまり使いません。ですが、使うとより素敵な場所も幾つかあります。それは、本質的に動的なところに対して。動的なのってどこ？というと、アプリケーションの管理範囲外。</p>
<p>例えばJSONはスキーマレス。DBも、自動生成しなければアプリケーションの外側で見えない。.NETはDLRがあるのでIronPythonなどスクリプト言語との連携などもそう。<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を例にだすと、スキーマレスなJSONに対して、そのまま、JSONをJavaScriptで扱うのと同じように使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var json = DynamicJson.Parse(@&quot;{&quot;&quot;foo&quot;&quot;:&quot;&quot;json&quot;&quot;, &quot;&quot;bar&quot;&quot;:100, &quot;&quot;nest&quot;&quot;:{ &quot;&quot;foobar&quot;&quot;:true } }&quot;);

var r1 = json.foo; // &quot;json&quot; - dynamic(string)
var r2 = json.bar; // 100 - dynamic(double)
var r3 = json.nest.foobar; // true - dynamic(bool)
</code></pre>
<p>また、動的な存在であるDBへのIDataRecordも、<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>を例に出すと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var products = DbExecutor.ExecuteReaderDynamic(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .Select(d =&gt; new Product
    {
        ProductName = d.ProductName,
        QuantityPerUnit = d.QuantityPerUnit
    })
    .ToArray();
</code></pre>
<p>ドットで自然に参照可能なことと、また、dynamicが自動でキャストしてくれるので明示的なキャストが不要なため、取り回しの面倒な手動DBアクセスが随分と簡単になります。（が、DBのアクセス結果を決まったクラスにマッピングするのなら、9で紹介している動的コード生成でアクセサを作ったほうが更に楽々になるのでそこまで出番はないかも。DbExecutorは両方を搭載しているので、必要に応じて選ぶことが可能です）</p>
<ol start="11">
<li>自動プロパティを使う</li>
</ol>
<hr />
<p>自動プロパティ vs パブリックフィールド。同じです。はい、同じです。じゃあパブリックフィールドでいいぢゃん？という話が度々ありますが、いえ、そんなことはありません。プロパティにするとカプセル化が云々、変更した場合に云々、などは割とどうでもいいのですが、重要な違いはちゃんとあります。</p>
<p>WPFとかASP.NETとかのバインディングがプロパティ大前提だったりしてパブリックフィールドだと動かないことがある。</p>
<p>なので、黙って自動プロパティにしておきましょう。それに関連してですが、リフレクションでの扱い易さがプロパティとフィールドでは全然違って、プロパティだと断然楽だったりします。そういう面でサードパーティのライブラリでも、プロパティだけをサポート、なものも割とあるのではかと思います。具体例はあげられませんが私は自分で作るちょろっとリフレクションもにょもにょ系の小粒なライブラリは面倒なのでプロパティだけサポート、にすることが結構あります。</p>
<p>あと自動プロパティの定義はコードスニペットを使って一行でやりましょう。prop-&gt;Tab-&gt;Tabです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public int MyProperty { get; set; }
</code></pre>
<p>get, setで改行して5行使ったりするのはコードの可読性が落ちるので、好きじゃありません。コードスニペットで一行のものが生成されるわけなので、それに従うという意味でも、一行で書くのがベストと思います。</p>
<h2>まとめ</h2>
<p>C#は言語がちゃんと進化を続けてきた。進化って無用な複雑化！ではなくて、基本的には今までよくなかった、やりづらいことを改善するために進化するんですよね。だから、素直にその良さを甘受したい。そしてまた、進化するということは、歴史の都合上で廃棄物が出てきてしまうというのもまた隣合わせ。C#は巧妙に、多量の廃棄物が出現するのを避けてきていると思います。ヘジたんの手腕が光ります。しかし、やはりどうしても幾つかの廃棄物に関しては致し方ないところです。それに関しては、ノウハウとして、自分で避けるしかなくて。</p>
<p>この手の話だったら、.NETのクラスライブラリ設計が良いです。もしお持ちでなければ、今すぐ買いましょう！いますぐ！超おすすめです。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4891006765" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>また、この手の本だったらEffective C# 4.0もかしら。第一版は（翻訳が出たのが既にC# 4.0の頃で1.0の内容）古くてう～ん、といった感だったのですが、第二版(C# 4.0対応)はかなり良かったです。More Effective C#のほうはLINQ前夜といった感じの内容で若干微妙なのですが、LINQ的な考えが必要な理由を抑える、という点では悪くないかもしれません。また、決定版的な内容を求めるならば、読み通す必要はなく気になるところつまみ読みで良いので、プログラミング.NET Frameworkがお薦めです。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4798122513" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4822294161" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>これらに加えて、自分のやりたいことの対象フレームワークの本(ASP.NET/ASP.NET MVC/Win Forms/WPF/WCF/Silverlight/Windows Phone 7/Unity)を一冊用意すれば、導入としては準備万端で素敵ではないかしらん。まあ、今時フレームワークとかの先端の部分だと、フレームワークの進化の速度が速すぎて本だと情報の鮮度が落ちる(特に日本だと)ので、基本は本でサッと抑えて、深い部分はネットの記事を見たほうが良いのではかと思います。ソースコードが公開されていたりフレームワークの制作陣や第一人者が情報出していたりしますしね。本こそが情報の基本にして全て、という時代でもないのだなぁ、と。学習の仕方というのも、時代で変わっていくものだと思います。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-13" data-pagefind-meta="published:2011-12-13"><a href="https://neue.cc/2011/12/13_358.html">Voidインスタンスの作り方、或いはシリアライザとコンストラクタについて</a></h1>
<ul class="date"><li>2011-12-13</li></ul>
<div class="entry_body"><p>voidといったら、特別扱いされる構造体です。default(void)なんてない。インスタンスは絶対作れない。作れない。本当に？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var v = System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof(void));

Console.WriteLine(v); // System.Void
</code></pre>
<p>作れました。というわけで、GetUninitializedObjectはその名前のとおり、コンストラクタをスルーしてオブジェクトを生成します。そのため、voidですら生成できてしまうわけです、恐ろしい。こないだ<a href="http://neue.cc/2011/12/10_357.html">.NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a>という記事でシリアライザ特集をして少し触れましたが、DataContractSerializerで激しく使われています。よって、シリアライズ対象のクラスがコンストラクタ内で激しく色々なところで作用しているようならば、それが呼び出されることはないので注意が必要です。</p>
<p>ただし、DataContractSerializerを使ったからって、必ずしも呼ばれるわけではないです。DataContract属性がついていなければ普通にコンストラクタを呼ぶ。DataContract属性がついていれば、引数のないコンストラクタがあったとしても、コンストラクタを無視する。という挙動になっているようです。ちょっと紛らわしいので、以下のコードは（参照設定があれば）そのままペーストして動くので、是非試してみてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.IO;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Text;
using System.Xml.Serialization;

public class EmptyClass
{
    public EmptyClass()
    {
        Console.WriteLine(&quot;BANG!&quot;);
    }
}

[DataContract]
public class ContractEmptyClass
{
    public ContractEmptyClass()
    {
        Console.WriteLine(&quot;BANG!BANG!&quot;);
    }
}

[DataContract]
public class NoEmptyConstructorClass
{
    public NoEmptyConstructorClass(int dummy)
    {
        Console.WriteLine(&quot;BANG!BANG!BANG!&quot;);
    }
}

class Program
{
    static void Main(string[] args)
    {
        // 普通にnewするとBANG!
        Console.WriteLine(&quot;New:&quot;);
        var e1 = new EmptyClass();

        // Activator.CreateInstanceでnewするのもBANG!
        Console.WriteLine(&quot;Activator.CreateInstance:&quot;);
        var e2 = Activator.CreateInstance&lt;EmptyClass&gt;();

        // ExpressionTreeでCompileしてもBANG!
        Console.WriteLine(&quot;Expression.New&quot;);
        var e3 = Expression.Lambda&lt;Func&lt;EmptyClass&gt;&gt;(Expression.New(typeof(EmptyClass))).Compile().Invoke();

        // 何も起こらない（コンストラクタを無視するのでね）
        Console.WriteLine(&quot;GetUninitializedObject:&quot;);
        var e4 = System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof(EmptyClass));

        // XmlSerializerでのデシリアライズはBANG!
        Console.WriteLine(&quot;XmlSerializer:&quot;);
        var e5 = new XmlSerializer(typeof(EmptyClass)).Deserialize(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;EmptyClass /&gt;&quot;)));

        // DataContractSerializerでもBANGって起こるよ！
        Console.WriteLine(&quot;DataContractSerializer:&quot;);
        var e6 = new DataContractSerializer(typeof(EmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;EmptyClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // DataContractJsonSerializerでも起こるんだ！
        Console.WriteLine(&quot;DataContractJsonSerializer:&quot;);
        var e7 = new DataContractJsonSerializer(typeof(EmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));

        // DataContract属性をつけたクラスだと何も起こらない
        Console.WriteLine(&quot;DataContract + DataContractSerializer:&quot;);
        var e8 = new DataContractSerializer(typeof(ContractEmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;ContractEmptyClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // DataContract属性をつけたクラスだとJsonSerializerのほうも当然何も起こらない
        Console.WriteLine(&quot;DataContract + DataContractJsonSerializer:&quot;);
        var e9 = new DataContractJsonSerializer(typeof(ContractEmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));

        // 空コンストラクタのないもの+DataContractSerializerだと何も起こらない
        Console.WriteLine(&quot;NoEmptyConstructor + DataContractSerializer:&quot;);
        var e10 = new DataContractSerializer(typeof(NoEmptyConstructorClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;NoEmptyConstructorClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // 空コンストラクタのないもの+DataContractJsonSerializerでも何も起こらない
        Console.WriteLine(&quot;NoEmptyConstructor + DataContractJsonSerializer:&quot;);
        var e11 = new DataContractJsonSerializer(typeof(NoEmptyConstructorClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/constuctorvoid.jpg">
</p>
<p>.NET 4でもSilverlightでも共通です。この挙動は妥当だと思います。DataContract属性を付けた時点で、そのクラスはシリアライズに関して特別な意識を持つ必要がある。コンストラクタ内でシリアライズで復元できない副作用のある処理をすべきではない。逆に、何も付いていない場合は特に意識しなくても大丈夫。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-10" data-pagefind-meta="published:2011-12-10"><a href="https://neue.cc/2011/12/10_357.html">.NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a></h1>
<ul class="date"><li>2011-12-10</li></ul>
<div class="entry_body"><p>今年もAdvent Calendarの季節がやってきましたね。去年は私はC#とJavaScriptで書きましたが、今年はC#とSilverlightでやります。というわけで、この記事は<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>用のエントリです。前日は<a href="https://twitter.com/#!/Posaune">@posaune</a>さんの<a href="http://d.hatena.ne.jp/posaunehm/20111209/1323443047">SilverlightのListBoxでつくるいんちきHorizontalTextBlock </a>でした。</p>
<p>今回の記事中のサンプルはSilverlight 4で書いています。が、Silverlight用という体裁を持つためにDebug.WriteLineで書いているというだけで、Silverlightらしさは皆無です！えー。.NET 4でもWindows Phone 7でも関係なく通じる話ですねん。</p>
<h2>シリアライザを使う場面</h2>
<p>概ね3つではないでしょうか。外部で公開されているデータ(APIをネット経由で叩くとか)をクラスに変換する。これは 自分の管理外→プログラム での片方向です。内部で持っているデータ(クラスのインスタンス)を保存用・復元用に相互変換する。これは プログラム←→自分の管理内 での双方向です。最後に、内部で持っているデータを公開用に変換する。これは プログラム→外部 での片方向。</p>
<p>目的に応じてベストな選択は変わってきます。こっから延々と長ったらしいので、まず先に結論のほうを。</p>
<ul>
<li>外部APIを叩く→XML/XmlSerializer, JSON/DataContractJsonSerializer</li>
<li>オブジェクトの保存・復元用→DataContractSerializer</li>
<li>外部公開→さあ？</li>
</ul>
<p>外部公開のは、Silverlightの話じゃないので今回はスルーだ！<a href="http://msdn.microsoft.com/ja-jp/library/system.xml.linq.xstreamingelement.aspx">XStreamingElement</a>で組み上げてもいいし、何でもいいよ！WCFのテンプレにでも従えばいいんぢゃないでしょーか。</p>
<h2>XmlSerializer</h2>
<p>古くからあるので、シリアライザといったらこれ！という印象な方も多いのではないでしょうか。その名の通り、素直にXMLの相互変換をしてくれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなクラスがあるとして
// (以降、断り書きなくPersonが出てきたらこいつを使ってると思ってください)
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new XmlSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.Deserialize(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">// 出力結果のXML
﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
  &lt;Age&gt;99&lt;/Age&gt;
&lt;/Person&gt;
</code></pre>
<p>素直な使い勝手、素直な出力。いいですね。さて、しかし特に外部APIを叩いて手に入るXMLは名前PascalCaseじゃねーよ、とか属性の場合どうすんだよ、という場合も多いでしょう。細かい制御にはXmlAttributeを使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[XmlRoot(&quot;people&quot;)]
public class People
{
    [XmlElement(&quot;count&quot;)]
    public int Count { get; set; }
    [XmlArray(&quot;persons&quot;)]
    [XmlArrayItem(&quot;person&quot;)]
    public Person[] Persons { get; set; }
}

[XmlRoot(&quot;person&quot;)]
public class Person
{
    [XmlElement(&quot;name&quot;)]
    public string Name { get; set; }
    [XmlAttribute(&quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new People
{
    Count = 2,
    Persons = new[]
{
    new Person { Name = &quot;山本山&quot;, Age = 99 },
    new Person { Name = &quot;トマト&quot;, Age = 19 }
}
};
var xml = @&quot;
    &lt;people&gt;
        &lt;count&gt;2&lt;/count&gt;
        &lt;persons&gt;
            &lt;person age=&quot;&quot;14&quot;&quot;&gt;
                &lt;name&gt;ほむ&lt;/name&gt;
            &lt;/person&gt;
            &lt;person age=&quot;&quot;999&quot;&quot;&gt;
                &lt;name&gt;いか&lt;/name&gt;
            &lt;/person&gt;
        &lt;/persons&gt;
    &lt;/people&gt;&quot;;

var serializer = new XmlSerializer(typeof(People));

// シリアライズ
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data);
    Debug.WriteLine(Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length));
}

// デシリアライズ
using (var sr = new StringReader(xml))
{
    var value = (People)serializer.Deserialize(sr);
    foreach (var item in value.Persons)
    {
        Debug.WriteLine(item.Name + &quot;:&quot; + item.Age);
    }
}

// 出力結果のXMLは↑に書いたXMLと同じようなものなので割愛
</code></pre>
<p>ちょっと属性制御が面倒ですが、それなりに分かりやすく書けます。他によく使うのは無視して欲しいプロパティを指定するXmlIgnoreかしら。さて、そんな便利なXmlSerializerですが、XML化するクラスに制限があります。有名所ではDictionaryがシリアライズできねえええええ！とか。小細工して回避することは一応可能ですが、そんな無理するぐらいなら使うのやめたほうがいいでしょう、シリアライザは別にXmlSerializerだけじゃないのだから。</p>
<p>というわけで、XmlSerializerの利用シーンのお薦めは、ネットワークから外部APIを叩いて手に入るXMLをクラスにマッピングするところです。柔軟な属性制御により、マッピングできないケースは(多分)ないでしょう。いや、分かりませんが。まあ、ほとんどのケースでは大丈夫でしょう！しかし、LINQ to XMLの登場により、手書きで変換するのも十分お手軽なってしまったので、こうして分かりにくい属性制御するぐらいならXElement使うよ、というケースのほうが多いかもしれません。結局、XML構造をそのまま映すことしかできないので、より細かく変換できたほうが良い場合もずっとあって。</p>
<p>実際、私はもう長いことXmlSerializer使ってない感じ。LINQ to XMLは偉大。</p>
<h2>DataContractSerializer</h2>
<p>割と新顔ですが、もう十分古株と言ってよいでしょう(どっちだよ)。XmlSerializerと同じくオブジェクトをXMLに変換するのですが、その機能はずっと強力です。Dictionaryだってなんだってシリアライズできますよ、というわけで、現在では.NETの標準シリアライザはこいつです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;&lt;Age&gt;99&lt;/Age&gt;&lt;Name&gt;山本山&lt;/Name&gt;&lt;/Person&gt;
</code></pre>
<p>とまあ、使い勝手はXmlSerializerと似たようなものです。おお、出力されるXMLは整形されていません。整形して出力したい場合は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 出力を整形したい場合はXmlWriter/XmlWriterSettingsを挟む
using (var ms = new MemoryStream())
using (var xw = XmlWriter.Create(ms, new XmlWriterSettings { Indent = true }))
{
    serializer.WriteObject(xw, data);

    xw.Flush();
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;
  &lt;Age&gt;99&lt;/Age&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
&lt;/Person&gt;
</code></pre>
<p>さて、結果をXmlSerializerと見比べてみるとどうでしょう。名前空間が違います。SilverlightApplication34ってありますね。これは、私がこのXMLを出力するのに使ったSilverlightプロジェクトの名前空間です。ワシのConsoleApplicationは221まであるぞ（整理しろ）。さて、ではこのXMLをデシリアライズするのに、別のアプリケーション・別のクラスで使ってみるとどうでしょう？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace TestSilverlightApp
{
    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();

            var xml = @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
            &lt;Person xmlns:i=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot; xmlns=&quot;&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&quot;&gt;
                &lt;Age&gt;99&lt;/Age&gt;
                &lt;Name&gt;山本山&lt;/Name&gt;
            &lt;/Person&gt;&quot;;

            var serializer = new DataContractSerializer(typeof(Person));
            using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
            {
                // System.Runtime.Serialization.SerializationExceptionが起こってデシリアライズできない
                // 名前空間 'http://schemas.datacontract.org/2004/07/TestSilverlightApp' の要素 'Person' が必要です。
                // 名前が 'Person' で名前空間が 'http://schemas.datacontract.org/2004/07/SilverlightApplication34' の 'Element' が検出されました。
                var value = (Person)serializer.ReadObject(ms);
            }
        }
    }
}
</code></pre>
<p>デシリアライズ出来ません。対象オブジェクトが名前空間によって厳密に区別されるからです。じゃあどうするのよ！というと、属性で名前空間を空、という指示を与えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// DataContract属性をクラスにつけた場合は
// そのクラス内のDataMember属性をつけていないプロパティは無視される
[DataContract(Namespace = &quot;&quot;, Name = &quot;person&quot;)]
public class Person
{
    [DataMember(Name = &quot;name&quot;)]
    public string Name { get; set; }
    [DataMember(Name = &quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなプレーンなXMLも読み込める
var xml = @&quot;
    &lt;person&gt;
        &lt;age&gt;99&lt;/age&gt;
        &lt;name&gt;山本山&lt;/name&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age);
}
</code></pre>
<p>属性面倒くせー、ですけれど、まあしょうがない。そうすれば外部からのXMLも読み込めるし、と思っていた時もありました。以下のようなケースではどうなるでしょうか？Personクラスは↑のものを使うとして。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなさっきと少しだけ違うXMLがあるとして
var xml = @&quot;
    &lt;person&gt;
        &lt;name&gt;山本山&lt;/name&gt;
        &lt;age&gt;99&lt;/age&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 結果は？？？
}
</code></pre>
<p>これは出力結果は「山本山:0」になります。Ageが0、つまり復元されませんでした。なぜかというと、XMLを見てください。nameが先で、ageが、後。DataContractSerializerは規程された順序に強く従います。DataMember属性のOrderプロパティで順序を与えるか、与えない場合はアルファベット順(つまりAgeが先でNameが後)となります。この辺は<a href="http://msdn.microsoft.com/ja-jp/library/ms729813.aspx">データ メンバーの順序</a>に書かれています。</p>
<p>と、いうような事情から、DataContractSerializerを外部XMLからの受け取りに使うのはお薦めしません。XmlSerializerなら順序無視なので大丈夫です。いや、普通は順序が変わったりなどしないだろう！と思わなくもなくもないけれど、意外とデタラメなのじゃないか、基本的にはお外からのデータが何もかも信用できるわけなどないのだ、とうがってしまい(TwitterのAPIとか胡散臭さいのを日常的に触っていると！)、厳しいかなって、思ってしまうのです。</p>
<p>しかし、オブジェクトの保存・復元用にはDataContractSerializerは無類の強さを発揮します。例えば設定用のクラスを丸ごとシリアライズ・デシリアライズとかね。iniにして、じゃなくてフツーはXMLにすると思いますが、それです、それ。Dictionaryだってシリアライズできるし、引数なしコントラクタがないクラスだってシリアライズできちゃうんですよ？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// とある引数なしコンストラクタがないクラス
[DataContract]
public class ToaruClass
{
    [DataMember]
    public string Name { get; set; }

    public ToaruClass(string name)
    {
        Name = name;
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var toaru = new ToaruClass(&quot;たこやき&quot;);

var serializer = new DataContractSerializer(typeof(ToaruClass));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, toaru); // シリアライズできるし

    ms.Position = 0;
    var value = (ToaruClass)serializer.ReadObject(ms); // デシリアライズできる

    Debug.WriteLine(value.Name); // たこやき
}
</code></pre>
<p>ただし、対象クラスにDataContract属性をつけてあげる必要はあります。つけてないとシリアライズもデシリアライズもできません。</p>
<p>ちなみに何でコンストラクタがないのにインスタンス化出来るんだよ！というと、<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.formatterservices.getuninitializedobject.aspx">System.Runtime.Serialization.FormatterServices.GetUninitializedObject</a>を使ってインスタンス化しているからです（Silverlightの場合はアクセス不可能）。こいつはコンストラクタをスルーしてオブジェクトを生成する反則スレスレな存在です、というか反則です。チートであるがゆえに、対象クラスにはDataContract属性をつける必要があります。コンストラクタ無視してもいいよ、ということを保証してあげないとおっかない、というわけです。(GetUninitializedObjectメソッド自体は別に属性は不要で何でもインスタンス化できます、typeof(void)ですらインスタンス化できます、無茶苦茶である)</p>
<p>なお、このGetUninitializedObjectが使われるのはDataContract属性がついているクラスのみです。DataContract属性がついていなければ、普通のコンストラクタが呼ばれるし、逆にDataContract属性がついていると、例え引数をうけないコンストラクタがあったとしても、GetUninitializedObject経由となりコンストラクタは無視されます。DataContract属性を付ける時はコンストラクタ内でシリアライズで復元できない副作用のある処理をすべきではない。ということに注意してください。</p>
<p>また、.NET 4版ではprivateプロパティの値も復元できるのですが、Silverlightの場合は無理のようです。ということでフル.NETなら不変オブジェクトでもサクサク大勝利、と思ってたのですが、Silverlightでの不変オブジェクトのシリアライズ・デシリアライズは不可能のようです。保存したいなら、保存専用の代理のオブジェクトを立ててやるしかない感じでしょうかね。</p>
<p>そんなわけで微妙な点も若干残りはしますが、オブジェクトを保存するのにはDataContractSerializerがお薦めです。</p>
<h2>DataContractとSerializable</h2>
<p>シリアライズ可能なクラス、の意味でDataContract属性をつけているわけですが、じゃあSerializable属性は？というと、えーと、SerializableはSilverlightでは入っていなかったりするとおり、過去の遺物ですね。なかったということで気にしないようにしましょう。</p>
<h2>DataContractJsonSerializer</h2>
<p>今時の言語はJSONが簡単に扱えなきゃダメです。XMLだけ扱えればいい、なんて時代は過ぎ去りました。しかしC#は悲しいことに標準では……。いや、いや、Silverlightには<a href="http://msdn.microsoft.com/ja-jp/library/system.json.aspx">System.Json</a>がありますね。しかし.NET 4にはありません(.NET 4.5とWinRTには入ります)。いや、しかし.NET 4には<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>があります(それ出していいならJSON.NETがあるよ、で終わりなんですけどね)。が、Windows Phone 7には何もありません。ああ……。</p>
<p>とはいえ、シリアライザならば用意されています。DataContractJsonSerializerです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml); // {&quot;Age&quot;:99,&quot;Name&quot;:&quot;山本山&quot;}

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<p>使い勝手はDataContractSerializerと完全に一緒です。ただし、違う点が幾つか。名前空間が（そもそもJSONで表現不可能なので）なくなったのと、順序も関係なく復元可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var json1 = @&quot;{&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;,&quot;&quot;Age&quot;&quot;:99}&quot;;
var json2 = @&quot;{&quot;&quot;Age&quot;&quot;:99,&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;}&quot;;

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms1 = new MemoryStream(Encoding.UTF8.GetBytes(json1)))
using (var ms2 = new MemoryStream(Encoding.UTF8.GetBytes(json2)))
{
    var value1 = (Person)serializer.ReadObject(ms1);
    var value2 = (Person)serializer.ReadObject(ms2);

    Debug.WriteLine(value1.Name + &quot;:&quot; + value2.Age);
    Debug.WriteLine(value2.Name + &quot;:&quot; + value2.Age);
}
</code></pre>
<p>というわけで、随分とDataContractSerializerよりも使い勝手が良い模様。いい話だなー。さて、難点は出力されるJSONの整形が不可能です。DataContractSerializerではXmlWriterSettingsで行えましたが、DataContractJsonSerializerではそれに相当するものがありません。というわけでヒューマンリーダブルな形で出力、とはならず、一行にドバーっとまとめて吐かれるのでかなり苦しい。</p>
<p>もう一つ、これは本当に大したことない差なのでどうでもいいのですが、DataContractSerializerのほうが速いです。理由は単純でDataContractSerializerに一枚被せる形でDataContractJsonSerializerが実装されているから。その辺の絡みで.NET 4には<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.json.jsonreaderwriterfactory.aspx">JsonReaderWriterFactory</a>などがあって、これを直に触ってJSON→XML変換をするとLINQ to XMLを通したJSONの直接操作が標準ライブラリのみで可能なのですが、Silverlight/Windows Phone 7では残念なことに触ることができません。</p>
<p>外部APIを叩いて変換する際に、シリアライズはお手軽で便利であると同時に、完全に同一の形のオブジェクトを用意しなければならなくて、かったるい側面もあります。LINQ to XML慣れしていると特に。そういった形でJSONを扱いたい場合、WP7では<a href="http://json.codeplex.com/">Json.NET</a>を使う、しかありません。使えばいいんぢゃないかな、どうせNuGetでサクッと入れられるのだし。</p>
<p>とはいえまあ、そう言うほど使いづらいわけでもないので、標準のみでJSONを扱いたいという場合は、DataContractJsonSerializerが第一にして唯一の選択肢になります。</p>
<h2>JavaScriptSerializer</h2>
<p>.NET Framework 4.0 Client Profileでは使えないのですが、FullならばSystem.Web.Extensionを参照することでJavaScriptSerializerが使えます。もはや完全にSilverlightと関係ないのでアレですが、少し見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var serializer = new JavaScriptSerializer();

var target = new { Name = &quot;ほむほむ&quot;, Age = 14 };
var json = serializer.Serialize(target); // stringを返す
</code></pre>
<p>Serializeで文字列としてのJSONを返す、というのがポイントです。それと、シリアライザ作成時にtypeを指定しません。また、匿名型もJSON化することが可能です（これはDataContractSerializerでは絶対無理）。ただし、コンストラクタのないクラスのデシリアライズは不可能です。</p>
<p>中々使い勝手がいいですね！で、これは、リフレクションベースの非常に素朴な実装です。だから匿名型でもOKなんですねー。ちょっとした用途には非常に楽なのですが、Client Profileでは使えないこともありますし(ASP.NETで使うために用意されてる)、あまり積極的に使うべきものではないと思います。ちなみに、一時期ではObsoleteになっていてDataContractJsonSerializer使え、と出ていたのですが、またObsoleteが外され普通に使えるようになりました。やはり標準シリアライザとしてはDataContractJsonSerializerだけだと重すぎる、ということでしょうか。</p>
<h2>バイナリとか</h2>
<p>別にシリアライズってXMLやJSONだけじゃあないのですね。サードパーティ製に目を向ければ、色々なものがあります。特に私がお薦めなのは<a href="http://code.google.com/p/protobuf-net/">protobuf-net</a>。これはGoogleが公開しているProtocol Buffersという仕様を.NETで実装したものなのですが、とにかく速い。めちゃくちゃ速い。稀代のILマスターが書いているだけある恐ろしい出来栄えです。SilverlightやWP7版もあるので、Protocol Buffersの本来の用途というだけなく、幅広く使えるのではかとも思います。</p>
<p>もう一つは国内だと最近目にすることの多い<a href="http://msgpack.org/">MessagePack</a>。以前に<a href="http://neue.cc/2010/05/29_261.html">.NET(C#)におけるシリアライザのパフォーマンス比較</a>を書いたときは振るわないスコアでしたが、最近別のC#実装が公開されまして、それは作者によるベンチ<a href="https://oikw.org/memo/2011/04/23/0">MessagePack for .NET (C#) を書いた</a>によると、protobuf-netよりも速いそうです。</p>
<h2>Next</h2>
<p>というわけでSilverlight枠でいいのか怪しかったですが、シリアライザの話でした。次は<a href="https://twitter.com/#!/ugaya40">@ugaya40</a>さんのWeakEventの話です。引き続きチェックを。あ、あと、Silverlight Advent Calendarはまだ埋まってない（！）ので、是非是非参加して、埋めてやってください。申し込みは<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>から。皆さんのエントリ、待ってます。どうやらちょうど今日Silverlight 5がリリースされたようなので、SL5の新機能ネタとかいいんじゃないでしょうか。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-09" data-pagefind-meta="published:2011-12-09"><a href="https://neue.cc/2011/12/09_356.html">自家製拡張メソッド制作のすすめ だいx回 BufferWithPadding</a></h1>
<ul class="date"><li>2011-12-09</li></ul>
<div class="entry_body"><p><a href="http://nuget.org/packages/Ix_Experimental-Main">Ix(Interactive Extensions)</a>は使っていますか？Rxから逆移植されてきている(IxのNuGet上のアイコンはRxのアイコンの逆向きなのですね)、LINQ to Objectsを更に拡張するメソッド群です。みんな大好きForEachなど、色々入っています。その中でも、私はBufferというものをよく使っています。Ixが参照できない場合は何度も何度も自作するぐらいに使いどころいっぱいあって、便利です。こんなの。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 指定個数分をまとめたIList&lt;T&gt;を返します
// 第二引数を使うとずらす個数を指定することもできます
// これの結果は
// 0123
// 4567
// 89
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>標準でこういうのできないのー？というと、できないんですよねえ、残念なことに。</p>
<p>さて、ところで、この場合、指定個数に足りなかった場合はその分縮められたものが帰ってきます。上の例だと返ってくるListの長さは4, 4, 2でした。でも、埋めて欲しい場合ってあります。足りない分は0で埋めて長さは4, 4, 4であって欲しい、と。そこはLINQなので、創意工夫で頑張りましょう。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// EnumerableEx.Repeatは指定の値の無限リピート
// それと結合して、Takeで詰めることで足りない場合だけ右を埋めることが出来る
// 0123
// 4567
// 8900
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.Concat(EnumerableEx.Repeat(0)).Take(4).ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>EnumerableEx.RepeatはIxにある無限リピート。Ixを参照しない場合は Enumerable.Repeat(value, int.MaxValue) で代用することも一応可能です。</p>
<p>さて、しかしこれも面倒なので、自家製拡張メソッドを作りましょう。拡張メソッドはばんばん作るべきなのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 指定した値で埋めるように。これの結果は
// 0123
// 4567
// 89-1-1
foreach (var xs in Enumerable.Range(0, 10).BufferWithPadding(4, -1))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}

public static class EnumerableExtensions
{
    public static IEnumerable&lt;T[]&gt; BufferWithPadding&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue = default(T))
    {
        if (source == null) throw new ArgumentNullException(&quot;source&quot;);
        if (count &lt;= 0) throw new ArgumentOutOfRangeException(&quot;count&quot;);

        return BufferWithPaddingCore(source, count, paddingValue);
    }

    static IEnumerable&lt;T[]&gt; BufferWithPaddingCore&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue)
    {
        var buffer = new T[count];
        var index = 0;
        foreach (var item in source)
        {
            buffer[index++] = item;
            if (index == count)
            {
                yield return buffer;
                index = 0;
                buffer = new T[count];
            }
        }

        if (index != 0)
        {
            for (; index &lt; count; index++)
            {
                buffer[index] = paddingValue;
            }
            yield return buffer;
        }
    }
}
</code></pre>
<p>すっきりしますね！Emptyの時は何も列挙しないようにしていますが、Emptyの時は埋めたのを一つ欲しい、と思う場合は最後のifの囲みを外せばOK。あと、最後のif...for...yieldの部分を var dest = new T[index]; Array.Copy(buffer, dest, index); yield return dest; に変えればパディングしないBufferになります。Ix参照したくないけどBuffer欲しいなあ、と思ったときにコピペってどうぞ。</p>
<p>本体のコードと引数チェックを分けているのは、yield returnは本体が丸ごと遅延評価されるため、引数チェックのタイミング的によろしくないからです。少し面倒ですが、分割するのが良い書き方。詳しくは<a href="http://neue.cc/2011/08/15_338.html">neue cc - 詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)</a>で書いていますので見てください。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-30" data-pagefind-meta="published:2011-11-30"><a href="https://neue.cc/2011/11/30_355.html">Reactive Extensionsとスレッドのlock</a></h1>
<ul class="date"><li>2011-11-30</li></ul>
<div class="entry_body"><p>ぱられるぱられる。もしパラレルにイベントが飛んできたら、どうする？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TestParallel
{
    public event Action&lt;int&gt; Log = _ =&gt; { }; // nullチェック面倒ぃので

    public void Raise()
    {
        // デュアルコア以上のマシンで試してね！
        Parallel.For(0, 10000000, x =&gt;
        {
            Log(x);
        });
    }
}

class Program
{
    static void Main(string[] args)
    {
        var list = new List&lt;int&gt;();
        var tes = new TestParallel();

        // イベント登録して
        tes.Log += x =&gt; list.Add(x);

        // 実行
        tes.Raise();
    }
}
</code></pre>
<p>これは、十中八九、例外が出ます。list.Addはスレッドセーフじゃないので、まあそうだよね、と。では、Rxを使ってみるとどうなるでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var list = new List&lt;int&gt;();
var tes = new TestParallel();

// イベント登録して
Observable.FromEvent&lt;int&gt;(h =&gt; tes.Log += h, h =&gt; tes.Log -= h)
    .Subscribe(list.Add);

// 実行
tes.Raise();
</code></pre>
<p>やはり変わりません。例外出ます。FromEventを中継しているだけですから……。さて、しかし一々Addの手前でlockするのは面倒だ、と、そこでSynchronizeメソッドが使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.FromEvent&lt;int&gt;(h =&gt; tes.Log += h, h =&gt; tes.Log -= h)
    .Synchronize()
    .Subscribe(list.Add);

// ようするにこんな感じになってる

var gate = new Object();
//....
lock(gate)
{
    OnNext();
}
</code></pre>
<p>これで、list.Addを問題なく動作させられます。Listとか適度にデリケートなので適当に注意してあげましょう。</p>
<h2>Subjectの場合</h2>
<p>さて、上のはイベントでしたが、ではSubjectの場合はどうなるでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TestParallel
{
    Subject&lt;int&gt; logMessenger = new Subject&lt;int&gt;();
    public IObservable&lt;int&gt; Log { get { return logMessenger.AsObservable(); } }

    public void Raise()
    {
        // デュアルコア以上のマシンで試してね！
        Parallel.For(0, 10000000, x =&gt;
        {
            logMessenger.OnNext(x);
        });
    }
}

class Program
{
    static void Main(string[] args)
    {
        var list = new List&lt;int&gt;();
        var tes = new TestParallel();

        // イベント登録して
        tes.Log.Subscribe(list.Add);

        // 実行
        tes.Raise();
    }
}
</code></pre>
<p>たまーに例外起こらず処理できることもあるんですが、まあ大体は例外起こるんじゃないかと思います。初期のRxのSubjectは割とガチガチにlockされてたのですが、現在はパフォーマンスが優先されているため挙動が変更され、ゆるゆるです。回避策は同様にSynchronizeを足すことです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">tes.Log.Synchronize().Subscribe(list.Add);
</code></pre>
<p>これで問題なし。</p>
<h2>余談</h2>
<p>手元に残っていた大昔のRxを使って実行してみたら、死ぬほど遅かったり。確実に現在のものはパフォーマンス上がっていますねえ。あと、なんかもう最近面倒でeventだからってEventArgs使わなきゃならないなんて誰が言ったー、とActionばかり使うという手抜きをしてます。だってsenderいらないもん、大抵のばやい。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-20" data-pagefind-meta="published:2011-11-20"><a href="https://neue.cc/2011/11/20_354.html">ReactiveProperty ver 0.3.0.0 - MとVMのバインディングという捉え方</a></h1>
<ul class="date"><li>2011-11-20</li></ul>
<div class="entry_body"><p>今回の更新よりアイコンが付きました。専用のアイコンがあると、とっても本格的な感じがしますねー。色はRxにあわせて紫-赤紫。デザインは私の好みな幾何学的な感じです。@ocazucoさんに作って頂きました、ありがとうございます！色々ワガママ言ってお手数かけました。</p>
<p class="noindent">
	<img src="http://neue.cc/ReactivePropertyIcon_100x100.png">
<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Rx - ver 0.3.0.0</a>
</p>
<p>Rxとは何か、というとIObservable&lt;T&gt;と「見なせる」ものを合成するためのライブラリです。だから、見なせるものさえ見つかれば、活躍の幅は広がっていく。ReactivePropertyは色々なものを、そのように「見なして」いくことで、RxでOrchestrateできる幅をドラスティックに広げます。土台にさえ乗せてしまえば、あとはRxにお任せ。その場合に大切なのは、土台に乗せられるよう、閉じないことです。しかし、もし閉じているのなら、開くための鍵を提供します。</p>
<h2>デフォルトモード変更</h2>
<p>ReactivePropertyのデフォルトモードが DistinctUntilChanged|RaiseLatestValueOnSubscribe になりました。今まではRaise...が入ってなかったのですが、思うところあって変わりました。例えばCombineLatestは、全てが一度は発火していないと動き出しません。ReactiveCommandの条件に使うなどの場合にRaiseしてくれないと不都合極まりなく、かつ、Subscribeと同時にRaiseすることによる不都合なシーンは逆に少ない。ことを考えると、必然的にデフォルトをどちらに振るべきかは、分かりきった話でした。</p>
<p>そのことは0.1の時、サンプル作りながら思ってたんですが悩んだ末に、省いちゃったんですねえ。RaiseLatestValueOnSubscribeが入ると不便なシーンもある(initialValueを設定しないとまず最初にnullが飛んでいくとか)ので、どちらを取るかは悩ましいところではあるんですが、シチュエーションに応じて最適なほうを選んでください、としか言いようがないところです。</p>
<h2>ToReactivePropertyAsSynchronized</h2>
<p>長い。メソッド名が。</p>
<p>これは何かというとINotifyPropertyChanged-&gt;ReactiveProperty変換です。今までもObservePropertyメソッド経由で変換できましたが、それは一度IObservable&lt;T&gt;に変換するため、Model→ReactivePropertyという一方向のPushでしかありませんでした。Two-wayでのバインドで値の同期を取りたい場合は、今回から搭載されたToReactivePropertyAsSynchronizedを使ってください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな通知付きモデルがあるとして
public class ObservableObject : INotifyPropertyChanged
{
    private string name;
    public string Name
    {
        get { return name; }
        set
        {
            name = value;
            PropertyChanged(this, new PropertyChangedEventArgs(&quot;Name&quot;));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}

// それを使ったViewModelを作るなら
public class TwoWayViewModel
{
    public ReactiveProperty&lt;string&gt; OneWay { get; private set; }
    public ReactiveProperty&lt;string&gt; TwoWay { get; private set; }

    public TwoWayViewModel()
    {
        var inpc = new ObservableObject { Name = &quot;ヤマダ&quot; };

        // ObservePropertyを使うとIObservable&lt;T&gt;に変換できます
        // ラムダ式でプロパティを指定するので、完全にタイプセーフです
        // それをToReactivePropertyすればOneWayで同期したReactivePropertyになります
        OneWay = inpc.ObserveProperty(x =&gt; x.Name).ToReactiveProperty();

        // ToReactivePropertyAsSynchronizedで双方向に同期することができます
        TwoWay = inpc.ToReactivePropertyAsSynchronized(x =&gt; x.Name);
    }
}
</code></pre>
<p>INotifyProeprtyChangedなModelをReactivePropertyなViewModelに持っていきたい時などに、使いやすいのではと思います。また、同期する型が異なっていても対応することができます。コンバーターのようにconvertとconvertBackを指定してください。</p>
<h2>ReactiveProperty.FromObject</h2>
<p>こちらもToReactivePropertyの亜種ですが、ReactiveProperty→Modelというソース方向への片方向の同期を取ります。ModelはINotifyPropertyChangedである必要はありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなただのクラスがあったとして
public class PlainObject
{
    public string Name { get; set; }
}

// それと同期させたいとき
public class OneWayToSourceViewModel
{
    public ReactiveProperty&lt;string&gt; OneWayToSource { get; private set; }

    public OneWayToSourceViewModel()
    {
        var poco = new PlainObject { Name = &quot;ヤマダ&quot; };

        // ReactiveProperty.FromObjectで変換することができます
        // この場合、ReactiveProperty -&gt; Objectの方向のみ値が流れます
        OneWayToSource = ReactiveProperty.FromObject(poco, x =&gt; x.Name);
    }
}
</code></pre>
<p>片方向の同期が定型的な局面、例えば設定クラスなんかは通知は必要ないと思うのですが、それをUIから一方向で値を投影したい場合に、これを使うことで楽になると思います。</p>
<p>また、Sampleにこれら3つの解説を追加しましたので、実際にどう反映されるのか、動きを確認したい場合はそちらを見てください。</p>
<h2>CombineLatestValuesAreAllTrue</h2>
<p>長い。メソッド名が。これは<a href="http://d.hatena.ne.jp/okazuki/20111027/1319722680">Reactive Extensionsお題 - かずきのBlog@Hatena</a>に書かれているもので、使うシーンよくありそうな頻出パターンになりそうだと思ったので、お借りすることにしました。ありがとうございます。使い方を見てもらったほうが速いので、まず例を。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyComibineLatestAllTrue.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedA.Value, Mode=TwoWay}&quot;&gt;Check A&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedB.Value, Mode=TwoWay}&quot;&gt;Check B&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedC.Value, Mode=TwoWay}&quot;&gt;Check C&lt;/CheckBox&gt;
    &lt;/StackPanel&gt;
    &lt;Button Command=&quot;{Binding ExecCommand}&quot;&gt;全部チェックで押せる&lt;/Button&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Reactive.Extensions; (これを忘れないように)

public class MainPageViewModel
{
    public ReactiveProperty&lt;bool&gt; IsCheckedA { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsCheckedB { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsCheckedC { get; private set; }
    public ReactiveCommand ExecCommand { get; private set; }

    public MainPageViewModel()
    {
        IsCheckedA = new ReactiveProperty&lt;bool&gt;();
        IsCheckedB = new ReactiveProperty&lt;bool&gt;();
        IsCheckedC = new ReactiveProperty&lt;bool&gt;();

        ExecCommand = new[] { IsCheckedA, IsCheckedB, IsCheckedC }
            .CombineLatestValuesAreAllTrue()
            .ToReactiveCommand();

        ExecCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;しんぷる！&quot;));
    }
}
</code></pre>
<p>3つのチェックボックスが全てONなら実行可能なコマンドを作る、です。こんな風に、全てがtrueの時、といった集約をしたい場合に便利に使うことができます。プレゼンテーションロジック、に該当する部分だと思いますが、ここでもRxは十分以上に活躍できます。また、外部からCanExecuteChangedをぶっ叩くようなカオティックなこともしません、ReactiveCommandならね。</p>
<h2>ReactiveTimer</h2>
<p>Timerです。.NETはTimerが山のようにあります。Threading.Timer, Timers.Timer, Forms.Timer, DispatcherTimer, Observable.Timer。ここにまたReactiveTimerという新たなるTimerが誕生し、人類を混乱の淵に陥れようとしていた……。まさにカオス。</p>
<p>ちょっと整理しましょう。まず、Threading.Timerは一番ネイティブなTimerと捉えられます。そのままだと少しつかいづらいので、軽くラップしてイベントベースにしたのがTimers.Timer。Forms.TimerとDispatcherTimerは、それぞれのアプリケーション基盤で時間を計って伝達してくれるというもの、UI系でのInvokeが不要になるので便利。と、それなりに役割の違いはあります。微妙な差ですが。</p>
<p>最後のObservable.TimerはIObservableで通達してくれるのでRxと非常に相性が良いタイマー。また、タイマーを行う場所もISchedulerで任意に指定できるので、ThreadPoolでもDispatcherでもCurrentThread(この場合はSleepで止まるので固まりますけどね)でも、もしくは仮想スケジューラ(任意に時間を動かせるのでテストが簡単になる)でも良いという柔軟さが素敵で、Rx以降のプログラミングではタイマーなんてObseravble.Timer一択だろ常識的に考えて。という勢い。(精度は若干落ちるので、よほど精度を求める時はThreading．Timerを使いましょう)。だと思っていた時もありました。</p>
<p>一時停止出来ないんですよ、Observable.Timer。発動したらしっぱなし。Stopはできる(Disposeする)けど、そうしたら再開は出来ない。それじゃあ困る場合があります！はい。結構あります。そういう場合はTimers.TimerをFromEventでラップする。それはそれで良いのですが、Observable.TimerのISchedulerを指定可能という柔軟さを捨てるのは勿体無いなあ、と思ったのでした。</p>
<p>そこで、今回ReactiveTimerを作りました。機能は、Observable.TimerのStop/Start出来る版です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestClass]
public class ReactiveTimerTest : ReactiveTest
{
    [TestMethod]
    public void TimerTest()
    {
        // テスト用の自由に時間を動かせるスケジューラ
        var testScheduler = new TestScheduler();
        var recorder = testScheduler.CreateObserver&lt;long&gt;();

        // 作成時点では動き出さない
        var timer = new ReactiveTimer(TimeSpan.FromSeconds(1), testScheduler);
        timer.Subscribe(recorder); // Subscribeしても動き出さない

        timer.Start(TimeSpan.FromSeconds(3)); // ここで開始。初期値を与えるとその時間後にスタート

        // 時間を絶対時間10秒のポイントまで進める(AdvanceTo)
        testScheduler.AdvanceTo(TimeSpan.FromSeconds(5).Ticks);

        // MessagesにSubscribeに届いた時間と値が記録されているので、Assertする
        recorder.Messages.Is(
            OnNext(TimeSpan.FromSeconds(3).Ticks, 0L),
            OnNext(TimeSpan.FromSeconds(4).Ticks, 1L),
            OnNext(TimeSpan.FromSeconds(5).Ticks, 2L));
        
        timer.Stop(); // timerを止める
        recorder.Messages.Clear(); // 記録をクリア

        // 時間を現在時間から5秒だけ進める(AdvanceBy)
        testScheduler.AdvanceBy(TimeSpan.FromSeconds(5).Ticks);

        // timerは止まっているので値は届いてないことが確認できる
        recorder.Messages.Count.Is(0);
    }
}
</code></pre>
<p>そう、単体テストしたい場合は、TestSchedulerに差し替えれば、AdvancedBy/Toによって、時間を自由に進めることが可能になります。Assertに使っているIs拡張メソッドは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>です。Testing周りの詳しい解説は<a href="http://d.hatena.ne.jp/ZOETROPE/20111031#1320077799">Rx-Testingの使い方 - ZOETROPEの日記</a>に書かれています。</p>
<h2>CountNotifier/BooleanNotifier</h2>
<p>SignalNotifierという名前はよく分からないので、今回よりCountNotifierに変更しました。また、名前空間をNotifiersに変更しました。更に、二値での通知を行うBooleanNotifierを新規追加しました。どちらも、IObservable経由での通知を行うフラグです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Reactive.Notifiers;

// 通知可能(IObservable)なboolean flag
var boolFlag = new BooleanNotifier(initialValue: false);
boolFlag.Subscribe(b =&gt; Console.WriteLine(b));

boolFlag.TurnOn(); // trueにする, trueの状態だったら何もしない
boolFlag.Value = false; // .Valueで変更、既にfalseの状態でも通知する
boolFlag.SwitchValue(); // 値を反転させる

// 通知可能(IObservable)なcount flag
var countFlag = new CountNotifier();
countFlag.Subscribe(x =&gt; Console.WriteLine(x));

countFlag.Increment(); // incしたり
countFlag.Decrement(); // decしたりの状態が通知される

// Empty(0になった状態)という判定でフィルタして状態監視したりできる
countFlag.Where(x =&gt; x == CountChangedStatus.Empty);
</code></pre>
<p>例えば非同期処理を行う際などの、状態の管理に使うことができます。</p>
<h2>Pairwise</h2>
<p><a href="http://neue.cc/2011/11/09_352.html">neue cc - Reactive Extensionsで前後の値を利用する</a>で書いた、前後の値をまとめる拡張メソッドです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// { Old = 1, New = 2 }
// { Old = 2, New = 3 }
// { Old = 3, New = 4 }
// { Old = 4, New = 5 }
Observable.Range(1, 5)
    .Pairwise()
    .Subscribe(Console.WriteLine);
</code></pre>
<p>古い値と新しい値を使って何かしたい場合などにどうぞ。</p>
<h2>CatchIgnore</h2>
<p>例外処理用に、OnErrorRetryというものを用意していましたが、今回それ以外にCatchIgnoreを追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 1, 2
Observable.Range(1, 5)
    .Do(x =&gt; { if (x == 3) throw new Exception(); })
    .CatchIgnore()
    .Subscribe(Console.WriteLine);
</code></pre>
<p>ようするに、CatchしてEmptyを返す手間を省くためのものです。onErrorにe =&gt; {}と書くのと似てますが、シーケンスの途中で捕まえれるので、メソッドチェーンの繋ぎ方によっては全然異なる役割を持つ可能性があります。</p>
<h2>その他の削除やバグ修正や見送ったものなど</h2>
<p>RxのExperimental版が更新されてたので、それに合わせました。Rxの更新内容はZipとCombineLatestに大量のオーバーロード+配列を受け入れるようになったので、何でも結合できるようになりました。それにともないReactivePropertyでは独自拡張としてCombineLatestのオーバーロードを用意していたのですが、Experimental版のみ削除しました。パフォーマンスもExperimentalのもののほうがずっと良いので、早くStableにも降りてきて欲しいです。</p>
<p>WebRequestのUploadValuesで、値が&amp;で連結されていないという致命的なバグがあったので修正しました。本当にすみません……。また、Silverlightでデザイン画面がプレビューできなくなる不具合を修正しました。デザインモード怖い。</p>
<p>バリデーション周りは、ちょっと大きめに(といっても内部だけの話で外部的には変わらない予定)変更入れようと思ってたのですが、それは次回で。あと、同期系メソッドもバリデーションの成否によって同期するかしないかを決定しようかなあ、とか思うんですが、ちょっと大変なので後になりそう。</p>
<h2>まとめ</h2>
<p>今回はデータリンクを主眼に置きました。デフォルトモードの変更もその一環です。直接的に意味を見るのなら、厚めのMをスマートにVMとシンクロナイズさせる、ということになります。冒頭の台詞、閉じた世界を開けるための道具です。ObserveProperty(OneWay)、ToReactivePropertyAsSynchronized(TwoWay)、ReactiveProperty.FromObject(OneWayToSource)。</p>
<p>OneWayとかTwoWayとかOneWayToSourceというとおり、VMとMの間のバインディングエンジンだと見ることができます。VとVMの間をWPFなりのフレームワークが担い吸収するように、ReactivePropertyはVMとMの間を吸収します。手書きでバインディングだと、ボイラープレートでは手間だし見通しも悪くなる。このほうが、ずっと、楽だし自然に書けます。</p>
<p>ReactivePropertyはV-VM間の接続も担うため、結果として全てがV-VM-M-VM-Vとして一つに繋がる。何をどう組もうと自然に一つに繋がっていく。わくわくしませんか？むしろカオスの予感がする？けれど、カオスの先に本当の光がある、……かもしれない。</p>
<p>ちなみに同期系のものはみんなプロパティ指定だけでGetとかSetとか自動でやっていますが、動的コード生成(＆キャッシュ)によりハイパー高速化されているので、パフォーマンス上の問題はありません。そこは安心してください。というと何か凄そうなことやってる気がしますが、勿論そんなことはなくて、偉大なるExpressionTreeに全面的にお任せしているだけだったり。</p>
</div>
<a href="https://neue.cc/14">Prev |</a>
<a href="https://neue.cc/16">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
