<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2012-10</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="./pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2012-10-24" data-pagefind-meta="published:2012-10-24"><a href="https://neue.cc/2012/10/24_386.html">ltxml.js - LINQ to XML for JavaScript</a></h1>
<ul class="date"><li>2012-10-24</li></ul>
<div class="entry_body"><p>以前、<a href="http://www.slideshare.net/neuecc/linqjs-ver3-and-visual-studio-2012-in-javascript">linq.js ver.3</a>のセッションの時に、ちょびっとだけ触れたLINQ to XML for JavaScriptが公開されました！</p>
<ul>
<li><a href="http://openxmldeveloper.org/blog/b/openxmldeveloper/archive/2012/10/23/new-open-source-project-linq-to-xml-for-javascript.aspx">New Open Source Project: LINQ to XML for JavaScript</a></li>
</ul>
<p>作者は私ではなく、Eric White氏です。誰？ってことですが、元Microsoftの人です。氏の<a href="http://blogs.msdn.com/b/ericwhite/archive/tags/linq+to+xml/">MS時代のMSDNブログのLINQ to XMLタグ</a>には超DEEPなLINQ to XMLの使いこなしが書いてあって必見。というわけで、非常にLINQ to XMLに詳しい、というか、MSDNの<a href="http://msdn.microsoft.com/ja-jp/library/bb387098.aspx">LINQ to XMLの解説ドキュメント</a>を書いたのは氏だそうです。なので、詳しいとかそういう次元じゃなく、普通に中の人ということですね。</p>
<h2>概要</h2>
<p>そんなわけで、ltxml.jsとは、C#のXML操作ライブラリであるLINQ to XMLのJavaScript移植です。C#のLINQ to XMLがLINQ to Objectsの上に構築されている（ElementsやDescendantsの戻り値がIEnumerableとなり、LINQベースのクエリ操作となる）ように、ltxml.jsはLINQ to ObjectsのJavaScript移植である<a href="http://linqjs.codeplex.com/">linq.js</a>の上に構築されています。ltxml.jsのelementsやdescendantsは、linq.jsのwhereやselectなどのクエリ操作によってXMLを展開できます。</p>
<p>C#版と構造はほとんど一緒です。ただし、JavaScriptの慣習に則りメソッド名がlowerCamelCaseであることと、プロパティが.getHoge()であること(ただしECMAScript 5に対応しているならば.hogeといったようにプロパティでアクセスできます)、オペレーターオーバーロードが存在しないことによる挙動の違い程度です。また、C#版よりも機能向上している面もあります。それは、私がlinq.jsにおいてC#のLINQ to Objectsで物足りないと思った機能を追加していたようなもの、でしょうか、多分ね、きっと。</p>
<p>また、パフォーマンス上の考慮により、descendantsなどは、デフォルトは即時実行で配列（をEnumerableでラップしたもの）を返します。.lazy = trueをXElementなどに投下することで、完全な遅延実行になります。もし巨大なXMLを扱うのならば、遅延実行が効果を発揮するでしょう。通常考えられるサイズのXMLならば、デフォルトのとおり即時実行のほうが良好だと思われます。</p>
<h2>使い方</h2>
<p>ぶっきらぼうにも、ドキュメントがほとんどないですね！まあ、それは追々紹介されていくことでしょう。ともあれ現状は、ファイルをダウンロードするとltxmlTest.htmlというファイルがあって、それがユニットテスト兼サンプルになっているので、とりあえずそれを読みましょう。また、JavaScript特有の違いはあるものの、基本的にはC#のそれと等しいので、MSDNの<a href="http://msdn.microsoft.com/ja-jp/library/bb387098.aspx">LINQ to XMLの解説ドキュメント</a>がまんま使えないこともないです。</p>
<p>ともあれ、まずは簡単なXMLをパースしてみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var xml =
    &quot;&lt;Contacts&gt;\
        &lt;Contact&gt;\
            &lt;Name&gt;Peter Hage&lt;/Name&gt;\
            &lt;Phone&gt;206-555-0144&lt;/Phone&gt;\
        &lt;/Contact&gt;\
        &lt;Contact&gt;\
            &lt;Name&gt;John Hoge&lt;/Name&gt;\
            &lt;Phone&gt;106-333-2222&lt;/Phone&gt;\
        &lt;/Contact&gt;\
        &lt;/Contacts&gt;&quot;;

// parseでただの文字列からLINQ to XMLのXElementに変換
var xElem = Ltxml.XElement.parse(xml);

// 子孫ノードのNameを選択し、値だけ抽出
var names = xElem.descendants(&quot;Name&quot;)
    .select(function (x) { return x.getValue(); })
    .toArray();

alert(names); // Peter Hage, John Hoge
</code></pre>
<p>descendants.selectといったように、LINQです！完全に！これをLINQと言わずして何をLINQと言うか！</p>
<h2>名前空間</h2>
<p>ltxml.jsの全てのクラスはLtxmlオブジェクトの下に格納されています。グローバルを汚さない。しかし、いちいちLtxml.XElementなどと呼ぶのは面倒くさい話です。以下のようなショートカットを先頭に用意するのをお薦めします。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var XAttribute = Ltxml.XAttribute;
var XCData = Ltxml.XCData;
var XComment = Ltxml.XComment;
var XContainer = Ltxml.XContainer;
var XDeclaration = Ltxml.XDeclaration;
var XDocument = Ltxml.XDocument;
var XElement = Ltxml.XElement;
var XName = Ltxml.XName;
var XNamespace = Ltxml.XNamespace;
var XNode = Ltxml.XNode;
var XObject = Ltxml.XObject;
var XProcessingInstruction = Ltxml.XProcessingInstruction;
var XText = Ltxml.XText;
var XEntity = Ltxml.XEntity;
var XEnumerable = Ltxml.XEnumerable;
</code></pre>
<p>また、C#版ではEnumerableへの拡張メソッドとして用意されていた幾つかのメソッドは、ltxml.jsではEnumerableに追加されているasXEnumerableを呼び、XEnumerableへと変換することで、呼び出すことができます。しかし、もしそれを手間だと思う場合は、linq.jsのEnumerableを拡張することで、よりスムーズに接続することが可能です。ただし、C#版ではジェネリックによって区別されていましたが、JavaScriptではジェネリックが存在しないので、汎用性のないシーケンスの要素がltxml.jsに固有でなければならないメソッドをEnumerableに追加することとなります。また、removeなどは、他の人の拡張と名前が衝突する可能性が高いことなどにも注意。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">Enumerable.prototype.elements = Ltxml.XEnumerable.prototype.elements;
Enumerable.prototype.ancestors = Ltxml.XEnumerable.prototype.ancestors;
Enumerable.prototype.ancestorsAndSelf = Ltxml.XEnumerable.prototype.ancestorsAndSelf;
Enumerable.prototype.attributes = Ltxml.XEnumerable.prototype.attributes;
Enumerable.prototype.descendantNodes = Ltxml.XEnumerable.prototype.descendantNodes;
Enumerable.prototype.descendantNodesAndSelf = Ltxml.XEnumerable.prototype.descendantNodesAndSelf;
Enumerable.prototype.descendants = Ltxml.XEnumerable.prototype.descendants;
Enumerable.prototype.descendantsAndSelf = Ltxml.XEnumerable.prototype.descendantsAndSelf;
Enumerable.prototype.elements = Ltxml.XEnumerable.prototype.elements;
Enumerable.prototype.nodes = Ltxml.XEnumerable.prototype.nodes;
Enumerable.prototype.remove = Ltxml.XEnumerable.prototype.remove;
</code></pre>
<p>私個人としては、Enumerableへの拡張はそんなに薦められないかな、という感じですが、ヘヴィにXMLを処理する局面では、拡張したほうがサクサク書けて良いのではかとも思います。この辺は好みでどうぞ。</p>
<h2>関数型構築</h2>
<p>XMLを作るときは、コンストラクタで可変長引数として連鎖させます。これをLINQ to XMLでは<a href="http://msdn.microsoft.com/ja-jp/library/bb387019.aspx">関数型構築</a>と呼んでいます。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var xml =
    new XElement(&quot;root&quot;,
        new XElement(&quot;user&quot;, new XAttribute(&quot;id&quot;, 1),
            new XElement(&quot;age&quot;, 100)));

// &lt;root&gt;&lt;user id = '1'&gt;&lt;age&gt;100&lt;/age&gt;&lt;/user&gt;&lt;/root&gt;
alert(xml.toString()); // toStringで文字列化
</code></pre>
<p>閉じタグが不要であったり、安全であったり(JavaScriptだってカッコ閉じ忘れとかは警告入るからね）と、生文字列で組み立てるのに比べて、遥かに利点があります。また、要素がlinq.jsのEnumerableである場合も、きちんと展開されます。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// C#と同様にEnumerable&lt;XElement&gt;は展開される
var users = Enumerable.range(1, 10)
    .select(function (x) {
        return new XElement(&quot;user&quot;, new XAttribute(&quot;id&quot;, x),
                   new XElement(&quot;age&quot;, x * x));
    });

var xml = new XElement(&quot;root&quot;, users);

// &lt;root&gt;
//   &lt;user id = '1'&gt;
//     &lt;age&gt;1&lt;/age&gt;
//   &lt;/user&gt;
//   &lt;user id = '2'&gt;
//     &lt;age&gt;4&lt;/age&gt;
//   &lt;/user&gt;
//   (略)
// &lt;/root&gt;
alert(xml.toString(true)); // 引数にtrueを渡すとインデントつけて整形
</code></pre>
<p>どうでしょう、イメージつきます？</p>
<h2>用途</h2>
<p>Eric White氏が<a href="http://ja.wikipedia.org/wiki/Office_Open_XML">OpenXML</a>(Officeのxlsxとかがそれ)の専門家ということで、JavaScript上でOfficeファイルを容易に扱うことが可能になるでしょう。つまり、サーバーサイドでのコンバート処理など不要に、JavaScriptだけでビューワーであたり要素抽出であったりが、完結する未来があります。なんて興奮する話でしょう！</p>
<p>とはいえ、それはあまりにも専門的すぎて、実に面白いし役立つでしょうけれど、実際にそれでもって作り上げる側に周るのは極少数の人に違いありません。では、他にXMLを使う局面なんてあるのか？ふむ……。恐らく、ブラウザ上で動くアプリケーションにとって機会はないでしょう、どこもかしこもJSONに集約される！AJAXのXはXMLのX！だった時もありました。いや、今もそうでしょうけれど。</p>
<p>では、どこに？というと、Node.jsはどうだろう？結局、未だにXMLのサービスなどは多いのだ。RSSはJSONにならないでしょう。サーバーサイドで行うならXMLは無視できないのだ。またはクライアントアプリでも、TitaniumやPhoneGapはどうだ？またはWindows 8のアプリケーションはJavaScriptで作ることができる。そこではまだまだXMLは現役に違いない。JavaScriptの活躍範囲がブラウザを超えていけばいくほど、残り続けるXMLに遭遇する機会は増える。</p>
<p>AtomPub(ああ！今はもうあまり名前を聞かない！)の構築に、LINQ to XMLの関数型構築は役に立つことでしょう。とにかく言えることは、XMLは決して死んでいないし、望まれるか望まれないかはともかくとして、生き残り続けるでしょう。そのために、私達には強力な武器が必要なのです、LINQ to XMLという。</p>
<p>もしくは、単純にHTMLビルダーとして使ったっていいかもしれない。HTMLはXMLなのだもの、ええ、大丈夫、そのようにも使えます。文字列連結してHTMLを組み立てるなんてしなくていい。また、もちろん、HTMLのDOM操作にだって、ね（でもDOMの操作ならば、きっとjQuery使いますね）</p>
<h2>未来</h2>
<p>ところでしかし現状ltxml.jsはベータです。何故か。linq.jsがまだベータだからです。ver.3.0.3-Beta4ってなんだよクソが。すみませんすみません、なるべく早く正式リリース出来るよう鋭意努力します。NEETなので暇、じゃあないんですよねえ、残念ながら。でも急ぎます。さすがに！いやほんと私の作業ペースの遅さには我ながらどうかと思う感じですが、もうさすがに猶予ないですね！</p>
<p>ちなみに7月31日に作ってるよー、ってメール貰って、そこから何度かやり取りしてました。ltxml.jsのコード自体、かなりパワフルにlinq.jsを使いこなしているので（私のアドバイスの賜物です！）そういう意味でも面白いですね。ちなみに、その時には8月中にlinq.jsリリースするって言ってたかなあ、今もう10月末ですねえ、どうなってるんでしょうねえ、ごめんなさいごめんなさい。</p>
</div>
<h1 data-pagefind-sort="date:2012-10-21" data-pagefind-meta="published:2012-10-21"><a href="https://neue.cc/2012/10/21_385.html">既存JavaScriptをTypeScriptとして修正する方法</a></h1>
<ul class="date"><li>2012-10-21</li></ul>
<div class="entry_body"><p>JavaScriptはTypeScriptです。ほぼほぼ。.jsを.tsとして変更すれば動きます。というほど世の中甘くなくて、まあ、大抵は動きません。えー、なにそれ、欠陥品じゃないの？と思われるかもですが、いえ、結構単純な話です。例えばですが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var x = 0;
x = &quot;hogehoge&quot;;
</code></pre>
<p>このコード、JavaScriptとしては正しいですが、TypeScriptとしては間違っていてコンパイル通りません。xがnumberとして推論されるので、&quot;hogehoge&quot;が代入できないからです。じゃあどうするの？というと、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var x: any = 0;
x = &quot;hogehoge&quot;;
</code></pre>
<p>anyとして型定義してやればいいんですね。もしくは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var x = &lt;any&gt;0;
x = &quot;hogehoge&quot;;
</code></pre>
<p>でもいいですが。&lt;&gt;はキャストみたいなものです。ちなみに、こういったことの実例はTypeScriptのソースをダウンロードしてきて、\src\harness\external\json2.ts に、<a href="http://www.json.org/js.html">json2.js</a>をtsに変換した例が見れます。ほんの2, 3箇所anyの注釈を入れているだけで、ほぼほぼそのままですね。実際のところ、↑みたいなゆるふわキャストなんて、たとえJSといえど多用してるわけがないので、作業的な手間はあまりありません。やることは、コンパイルエラーの出た箇所をポチポチとモグラたたきするだけなので、楽ちん。</p>
<h2>実際にやってみる</h2>
<p>理屈上はそうですが、実際やってみるとどうなんでしょうねえ、ということで、linq.jsでやってみました。(なお、linq.jsの型定義自体は<a href="http://neue.cc/2012/10/12_382.html">linq.jsのTypeScript対応とTypeScript雑感</a>で手付けですでにやってあります)。まず.tsにしてコンパイルかけてみると、赤波線が全体に出てきてわけわからんオワタ！エラー90件！</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/ts_linq_red.jpg" />
</p>
<p>で、まあ、こういう場合は問題は基底部分にあります。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">(function (root, undefined) {
// 中略
})(this);
</code></pre>
<p>問題なのはundefinedです。function(root, undefined) として定義しているのに、(this)ということで、呼んでないから。冷静に見てみれば、ただたんにメソッド呼ぶ引数が足りないぜ、って言ってるだけですな。ちなみにこのコード自体は、undefinedは代入可能な代物で破壊されている可能性があるから（あるわけないけど！）、安全なundefinedを作ろう、という古臭いイディオムです。</p>
<p>エラーが90件もあってわけわかりませんが、一番最初のエラーが「Supplied parameters do not match any signature of call target」なので、やっぱり冷静に見てみれば、ちゃんと教えてくれていた、と。TypeScript優しいのね。</p>
<p>なのでundefinedを抜けば真っ赤っ赤はなくなります。OK。だがまだエラーは続く。というかエラー件数は89件になっただけである。</p>
<p>お次はEnumeratorがないぞ！というエラー。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">if (typeof Enumerator !== Types.Undefined) {
if (typeof Windows === Types.Object &amp;&amp; typeof obj.first === Types.Function) {
</code></pre>
<p>このEnumeratorはIEのみに存在するオブジェクトで、Windows Script Hostで列挙するのに使ったり使わなかったりする、今では知らない人のほうが遥かに多いであろう謎オブジェクトです。Windowsのほうも同様に、Windows8用アプリケーションにしか存在しません。さて、これへの対処は、定義ファイルのない外部ライブラリを使う際と同じで、anyでdeclareします。ファイルの先頭に</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">declare var Enumerator;
declare var Windows
</code></pre>
<p>と書いておけばOK。しかしまだまだエラーは続くよ！該当箇所はここ。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var Enumerable = function (getEnumerator) {
    this.getEnumerator = getEnumerator;
};

// このUtilsで赤線
Enumerable.Utils = {}; // container
</code></pre>
<p>このEnumerableが意図するところはコンストラクタです。new Enumerable()するためのものです。で、JavaScriptでは関数にもオブジェクトを生やせますが、TypeScriptでは生やせません。対処方法はまあ、面倒くさいのでEnumerableをanyにしましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var Enumerable: any = function (getEnumerator) {
    this.getEnumerator = getEnumerator;
};
</code></pre>
<p>これだけで割と一気に解決します！89件あったエラーが残りほんの数件に！any最強！dynamic！
で、linq.jsでは同じようにOrderedEnumerableとArrayEnumerableというものが存在するので、同様にanyにしておきます。</p>
<p>そんなわけで、なんとなくわかったと思いますが、ようするにエラーの出てるところを片っ端からanyにしていくだけです。ただしルート階層に近いものを優先的にany化すると、その下にぶら下がってるものは全部解決するので、意外とそんな手間じゃありません。</p>
<p>あとは一番下にAMD対応もどきのとこがあるのですが、これはそもそも微妙なのでまるごと削除して解決（てきとー）。で、対応はほんとこれだけです。あっという間だし簡単ですなあ。TypeScriptのJavaScriptとの互換性は本物だ！</p>
<h2>declarationsオプション</h2>
<p>で、ここからが本題であって本題ではないのですが、TypeScriptはtsc -declarationsとオプションをつけてコンパイルすると、d.tsを吐いてくれます。ちゃんと型定義されたtsファイルならちゃんとしあd.tsを吐いてくれます。役立ちです。</p>
<p>で、人間欲が出るもので、もしこれを、↑のように修正した.tsにかませてやるとどうなる？もし、たとえanyであっても定義テンプレを吐いてくれたら、そこから注釈入れてくだけですむわけで、随分と楽になりますよね？面倒くさい型定義よさようなら。</p>
<p>というわけで、こいつをdeclarationsオプションをつけてコンパイルしましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-text">tsc linq.js.ts -declarations
</code></pre>
<p>期待のlinq.js.d.tsの結果は</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var Enumerator;
var Windows;
</code></pre>
<p>になります（笑）。はい、関数で丸ごと括った部分が消滅してしまいました。クソが。今回は定義ファイルが欲しいだけなので、関数で括る部分を除去して再度コンパイルすると</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var Enumerator;
var Windows;
var Functions: { Identity: (x: any) =&gt; any; True: () =&gt; bool; Blank: () =&gt; void; };
var Types: { Boolean: string; Number: string; String: string; Object: string; Undefined: string; Function: string; };
var Utils: { createLambda: (expression: any) =&gt; any; isIEnumerable: (obj: any) =&gt; bool; defineProperty: (target: any,methodName: any,value: any) =&gt; void; compare: (a: any,b: any) =&gt; number; dispose: (obj: any) =&gt; void; };
var State: { Before: number; Running: number; After: number; };
var IEnumerator: (initialize: any,tryGetNext: any,dispose: any) =&gt; void;
var Yielder: () =&gt; void;
var Enumerable: any;
var OrderedEnumerable: any;
var SortContext: any;
var DisposableEnumerable: (getEnumerator: any,dispose: any) =&gt; void;
var ArrayEnumerable: any;
var WhereEnumerable: (source: any,predicate: any) =&gt; void;
var WhereSelectEnumerable: (source: any,predicate: any,selector: any) =&gt; void;
var Dictionary;
var Lookup: (dictionary: any) =&gt; void;
var Grouping: (groupKey: any,elements: any) =&gt; void;
</code></pre>
<p>外に出したくないもの(Yielderとか)は、まあ、あとで別途削除すればいいんですが、しかしそもそも肝心のEnumerableメソッドが全部出てないぞ！
理由としては、ようするにanyつけちゃったから。うーん、これじゃ実用度ゼロですね。</p>
<p>そもそもfunctionで定義したクラス（をコンストラクタとして使いたい）というのを、それがコンストラクタなのか関数なのかをどうやって区別するんだ？って話ですし、無理ですなー。(ファイル全てをなめてthis.してるのはクラスとか.prototype = hogehogeしてるのはクラスとか、曖昧な判定はできるでしょうけれど、それは危険ですしね)。</p>
<p>夢は見ちゃダメ。でもMicrosoftならきっといつかはやってくれるはず！（実際、GWT用に空気読んでJavaScriptからJavaの定義を吐いてくれるものは存在するとか）</p>
<h2>まとめ</h2>
<p>プレーンなJavaScriptはほぼほぼTypeScriptになります。素晴らしい互換性です！一方、型定義自動生成のほうは無理でした。地道に頑張りましょう。</p>
<p>あ、そうそう、今回の記事で言いたいのは別に表題通りの話じゃあないです。既存JSは既存JSとして使えばいいので、わざわざTypeScript化する必要なんて全然ありません。いえ、あります、ちゃんと型付けするならば。でも、今回のようにanyを付けて回る程度の話は全くの無意味です。じゃあどうでもいいかといえば、やっぱりそうじゃなくて、TypeScriptとJavaScriptの互換性というのはどういうものなのか、というとこは位置づけ的には大事ですからね、漠然とじゃあなく抑えておきたいところ。</p>
</div>
<h1 data-pagefind-sort="date:2012-10-20" data-pagefind-meta="published:2012-10-20"><a href="https://neue.cc/2012/10/20_384.html">gloopsを退職しました。</a></h1>
<ul class="date"><li>2012-10-20</li></ul>
<div class="entry_body"><p>今日というか昨日というか、金曜が最終出社日となりました。</p>
<p>今年の1月1日に入社してから10ヶ月。非常に濃密だったのであっという間でしたね。良い経験ができたし、私の方からも十分に貢献できたとは自負しています(LINQの布教とかね！)。とはいえ、まだまだやり残していることは山のようにあり、時期的にも、まさにこれから！というタイミングなので、心残りは非常にあります。gloops自体は非常に良い会社ですし、これからますます技術的にも力強く、面白くなっていくところです。なので、その点は安心してください。ですが、個人的により大きな飛躍を目指したく決断と相成りました。</p>
<p>円満、です。最後に社内勉強会でThe Patterns of LINQというセッションをやりまして、それが置き土産です。そんなこんなで温かく送っていただいて、本当にgloopsの皆様へ感謝！</p>
<p>ちなみに日本にずっといます。いつぞやかにはシンガポールが、とかって話もありましたが、あれは種々諸々で爆散しました。それは凄く残念でしたね……、、海外への挑戦というのは、またいつか機会があればやりたいです。ともあれ今は、当面は地下に潜伏していますが、必ず浮上しますのでしばしお待ちくだしあ。</p>
</div>
<h1 data-pagefind-sort="date:2012-10-16" data-pagefind-meta="published:2012-10-16"><a href="https://neue.cc/2012/10/16_383.html">非同期WebRequestとTimeout処理の今昔</a></h1>
<ul class="date"><li>2012-10-16</li></ul>
<div class="entry_body"><p>最近はTypeScriptにお熱ですが、とはいえ、C#も大好きな私です。むしろC#は大好きです。今日はすっかり飽き飽きな非同期のTimeout処理について、おさらいすることにしましょう！題材はいつもどーりWebRequestでいいですよね。</p>
<p>まず、都合のいいTimeoutをシミュレートできるAPIは探せば多分あるでしょうが、面倒なので自分で作りましょう。いえ、簡単です。「空のASP.NET WebApplication」を立ち上げてジェネリックハンドラを追加。とりあえずレスポンスを返すのに3秒かかるということにしときましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Timeout : HttpTaskAsyncHandler
{
    public override async Task ProcessRequestAsync(HttpContext context)
    {
        await Task.Delay(TimeSpan.FromSeconds(3)); // 3秒かかるってことにする
        context.Response.ContentType = &quot;text/plain&quot;;
        context.Response.Write(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>で、そのまま実行してIIS Expressで動いてもらってれば準備できあがり。</p>
<h2>同期の場合</h2>
<p>さて、そしてConsoleApplicationを立ちあげて、まずは同期でやる場合でも見ましょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://localhost:18018/Timeout.ashx&quot;);
req.Timeout = 1000; // 1秒でタイムアウト

req.GetResponse();
</code></pre>
<p>これはちゃんとタイムアウトでWebExceptionを返してくれます。そりゃそーだ。</p>
<h2>古き良き非同期の場合</h2>
<p>じゃあBegin-Endパターンの非同期でやってみましょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://localhost:18018/Timeout.ashx&quot;);
req.Timeout = 1000; // 1秒でタイムアウトのつもり

req.BeginGetResponse(ar =&gt;
{
    var res = req.EndGetResponse(ar);
    Console.WriteLine(new StreamReader(res.GetResponseStream()).ReadLine());
}, null);

Console.ReadLine(); // 適当に待つ
</code></pre>
<p>この結果はなんと、普通にHello Worldと表示されてしまいます。はい、Timeout機能していません、全く。そう、WebRequestのTimeoutプロパティによる設定は同期限定なのだよ、なんだってー。このことはMSDNの<a href="http://msdn.microsoft.com/ja-jp/library/system.net.httpwebrequest.begingetresponse.aspx">BeginGetResponse</a>のとこにも書いてあって、「非同期要求の場合は、クライアント側のアプリケーションが独自のタイムアウト機構を実装する必要があります」ということになっています。</p>
<h2>ThreadPool.RegisterWaitForSingleObject</h2>
<p>なので、そこに書いてあるとおり、ThreadPool.RegisterWaitForSingleObjectで実装してみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://localhost:18018/Timeout.ashx&quot;);
// req.Timeout = 1000; このTimeoutはイミナイのでイラナイ

var result = req.BeginGetResponse(ar =&gt;
{
    var res = req.EndGetResponse(ar);
    Console.WriteLine(new StreamReader(res.GetResponseStream()).ReadLine());
}, null);

ThreadPool.RegisterWaitForSingleObject(result.AsyncWaitHandle, (state, timeout) =&gt;
{
    // 引数で指定した時間の後にここの部分が発火する。
    // そのとき非同期処理が完了していなければ(Timeoutしていれば)timeoutがtrue, 普通に終了してればfalse
    if (timeout)
    {
        Console.WriteLine(&quot;TIMEOUT!!&quot;);

        var _req = (WebRequest)state;
        if (_req != null) _req.Abort(); // あぼーんでキャンセルというか打ち切る
    }
}, req, timeout: TimeSpan.FromSeconds(1), executeOnlyOnce: true);

Console.ReadLine(); // 適当に待つ
</code></pre>
<p>うん、ややこしいですね。ウンザリです。しかし昔はこれぐらいしか手段がなかったのだからShoganai！</p>
<h2>C# 5.0で救われよう</h2>
<p>そんなこんなで一気に時代が進んで、C# 5.0です。GetResponseAsyncですね！GetResponseAsyncなら、GetResponseAsync先生ならやってくれる、と思っていた時がありました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task Run()
{
    var req = WebRequest.Create(&quot;http://localhost:18018/Timeout.ashx&quot;);
    req.Timeout = 1000; // ま、このTimeoutはイミナイですよ

    var res = await req.GetResponseAsync();

    Console.WriteLine(new StreamReader(res.GetResponseStream()).ReadLine());
}

static void Main(string[] args)
{
    Run().Wait();
}
</code></pre>
<p>結果はBegin-Endの時と同じでTimeout指定は無視されます。はい残念残念。所詮別にBegin-Endと何も変わってはいないわけです。とはいえ、Taskならば、この辺、柔軟に処理を仕込めます。</p>
<h2>Timeoutという拡張メソッドを作る</h2>
<p>async/awaitやTaskといった道具立てはあるのですが、細かい色々なものはない(<a href="http://blogs.msdn.com/b/pfxteam/archive/2012/10/05/how-do-i-cancel-non-cancelable-async-operations.aspx">Cancelを足す</a>とかTimeoutを足すとかRetryを足すとか、この辺はよく使うであろうシチュエーションだと思うので、自分の道具箱に仕込んでおくと幸せになれます)ので、作りましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static async Task Timeout(this Task task, TimeSpan timeout)
{
    var delay = Task.Delay(timeout);
    if (await Task.WhenAny(task, delay) == delay)
    {
        throw new TimeoutException();
    }
}

public static async Task&lt;T&gt; Timeout&lt;T&gt;(this Task&lt;T&gt; task, TimeSpan timeout)
{
    await ((Task)task).Timeout(timeout);
    return await task;
}
</code></pre>
<p>単純ですね。ポイントはTask.WhenAnyで、これは特殊なやり方ではなくて、イディオムです。C# 5.0を使っていくなら覚えておきましょう、絶対に。</p>
<p>さて、これを使えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task Run()
{
    var req = WebRequest.Create(&quot;http://localhost:18018/Timeout.ashx&quot;);
    var res = await req.GetResponseAsync().Timeout(TimeSpan.FromSeconds(1));

    Console.WriteLine(new StreamReader(res.GetResponseStream()).ReadLine());
}

static void Main(string[] args)
{
    Run().Wait();
}
</code></pre>
<p>超シンプルになりました。やったね！</p>
<h2>HttpClient</h2>
<p>ちなみに.NET 4.5から入ったHttpClientは、非同期操作しか提供していない、だけに、ちゃんとTimeoutプロパティが非同期でも対応していますので、フツーはこっちを使うと良いでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task Run()
{
    var client = new System.Net.Http.HttpClient() { Timeout = TimeSpan.FromSeconds(1) };
    var s = await client.GetStringAsync(&quot;http://localhost:18018/Timeout.ashx&quot;);

    Console.WriteLine(s);
}

static void Main(string[] args)
{
    Run().Wait();
}
</code></pre>
<p>吐いてくる例外はSystem.Threading.Tasks.TaskCanceledExceptionです。これは、中でCancellationTokenSource.CreateLinkedTokenSourceとリンクさせた上で、CancellationTokenSourceのCancelAfterによってTimeoutを処理しているからです。HttpClientも、最終的にネットワークとやり取りしている部分はWebRequestですから。</p>
<h2>まとめ</h2>
<p>まあ、今までは細かい罠があってクソが、となる局面も少なからず多かったわけですが、ようやく整理された、感があります。しょっぱいことは考えないで、甘受していきたいですねー。</p>
</div>
<h1 data-pagefind-sort="date:2012-10-12" data-pagefind-meta="published:2012-10-12"><a href="https://neue.cc/2012/10/12_382.html">linq.jsのTypeScript対応とTypeScript雑感</a></h1>
<ul class="date"><li>2012-10-12</li></ul>
<div class="entry_body"><p>Microsoftから<a href="http://www.typescriptlang.org/">TypeScript</a>という新言語が発表されました。驚くべきは、あのC#のAnders Hejlsbergが関わっている！これはもう触るしかない。そしてこれはコンパイル後にJavaScriptになる言語(CoffeeとかJSXとかみたいな)なわけで、じゃあlinq.jsを対応させるしかない！というわけで、させました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// TypeScript
Enumerable.range(1, 10)
    .where(x =&gt; x % 2 == 0)
    .select(x =&gt; x * x)
    .writeLine();

// コンパイル後
Enumerable.range(1, 10).where(function (x) {
    return x % 2 == 0;
}).select(function (x) {
    return x * x;
}).writeLine();
</code></pre>
<p>ひゃっはー、もうfunction() { return }とはオサラバだ！そしてこの記述性と最強のコレクション操作であるLINQが合わさると最強に見える。</p>
<ul>
<li><a href="http://linqjs.codeplex.com/releases/view/91395">linq.js ver.3.0.3-Beta4</a></li>
</ul>
<p>に型定義ファイルは同梱してありますので、是非是非お試しを。NuGetのlinq.js -Preでも入ります。NPMは予定はありますが、まだです、すみません。</p>
<h2>TypeScriptについて</h2>
<p>型安全なCoffee Script、といった印象ですね。基本的にはCoffee Scriptに近いと思います。JavaScriptにプラスアルファな構文を採用することで、既存のJSライブラリとの繋がりを良くすることと、綺麗なJavaScriptを吐くことに重きが置かれている。TypeScriptは、比較的素直にJavaScriptに読み解くことが出来て、独自のコード生成は、現状はほぼほぼ無いし、意図的に省かれているようです（例えば非同期にたいしてasync構文を入れたりすると、大量のコード生成が入り、出力されるJavaScriptが機械的に汚れがち）。</p>
<p>そういった点、機能面では、TypeScriptには物足りなさを感じるところが多いかもしれません。じゃあJavaScriptに対する強みってどこなんだよ！といったら、一つはJavaScriptの冗長な記述性の補正(class,module, arrow function, Object.create/definePropertyとかも最低だしね)。もう一つは、無理なく自然に馴染んだ型付け。</p>
<p>型はないよりあったほうがいい。でも、型を付けるのがあまりにも苦痛だったら？ちょっとしたコードを書くのにも型！型！型！と押し付けられたら？そりゃあ、嫌だ。というわけで、型推論によって、比較的スムースに書けるようになっています。</p>
<p>型推論の性質というか範囲というか強さというかは、C#と非常に近いというかC#とまるで一緒なので、C#erならサクッと馴染めます。もっと強力な型推論のある言語に馴染んでいる人だと、え、ここで効かないの？みたいな違和感はあるかもですが。</p>
<p>また、さすがはMicrosoftというかAnders Hejlsbergというか、入力補完のことを念頭に置いた言語設計になっているので、IDEとの相性が非常に良い。そして最初からVisual StudioによるIDE環境が用意されていることで、型のある利点の一つであるリアルタイムエラー通知や入力補完をたっぷり満喫できます。さらに、それは<a href="http://www.typescriptlang.org/Playground/">TypeScript Playground</a>によってWeb上でも体感できます。というか、もはやPlaygroundはWeb IDEとでも言うべき驚異的な動き！</p>
<p>また、Windowsだけではなく、最初から<a href="http://blogs.msdn.com/b/interoperability/archive/2012/10/01/sublime-text-vi-emacs-typescript-enabled.aspx">Sublime, Vim, Emacs</a>の対応ファイルが用意されているというところからも、Windowsに限らず幅広く請求したい、という表れだと思います。そして実際、言語はプラットフォーム中立なわけです(最終的にはJavaScriptだしね！)。</p>
<h2>Structural Subtyping</h2>
<p>TypeScriptの最も面白いところは、ここです。C#とかのインターフェイスとLLのダックタイピングの中間、みたいな。実にゆるふわなJavaScriptと絶妙に合っててイイ！というかそもそも私はStructural Subtypingって名前だけでぜーんぜん分かってなかったのですが、TypeScriptだと自然と馴染めます。ほむ、どういうことか、というと、一例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">union(second: any[], compareSelector?: (element: any) =&gt; any): Enumerable;
union(second: Enumerable, compareSelector?: (element: any) =&gt; any): Enumerable;
union(second: { length: number;[index: number]: any; }, compareSelector?: (element: any) =&gt; any): Enumerable;
</code></pre>
<p>これはlinq.jsの型定義の一つでunion、和集合を生成するためのメソッドです。なので、元シーケンスと、対象シーケンス(second)が対象になるわけですが、じゃあシーケンスって何？と。列挙できればいいので、配列もそうだし、Enumerableもそう。そして、JavaScriptに特有の存在として、配列みたいだけど配列じゃあないもの(lengthを持っていてインデクサでアクセスできる)、例えばDOMのNodeListとか、もそう。</p>
<p>で、そういった「lengthを持っていてインデクサでアクセスできる」という型の定義が{ length: number;[index: number]: any; }。これにより、DOMのNodeListやjQuery([0]とかでHTMLElementが取れる)など、配列みたいだけど配列じゃないもの全てが型安全に定義されました。やったね！</p>
<p>もしC#だったら、対象はインターフェイスで指定するしかないので、IEnumerable&lt;T&gt;を実装していないクソコレクションクラスが存在したら、それは列挙不能になってしまいます。片っ端からオーバーロードを作るのは不可能だし、かといってdynamic secondなどとしてしまってはアレ。</p>
<p>とはいえ、基本的にC#では最初から全てのシーケンスはIEnumerable&lt;T&gt;を実装している、という前提が成り立っているので、問題はおこらない。でも、JavaScriptは違う。配列みたいだけど配列じゃあないもの、が跋扈してる。でも、そこをanyとして何でも受け入れられるようにしたら型安全じゃあない。安全にしたい。そこをStructural Subtypingが華麗に解決してくれました！惚れた……。</p>
<h2>TypeScriptはJavaScriptか？</h2>
<p>JavaScriptコードはそのままTypeScriptだ！ということにYesと言えるかというと、イエスでもあり、しかし割とノーです。私がこの話を聞いて、最初に思ったのは、既存JSコード、つまりライブラリ類もそのままで動くのかな？と。答えはNOです。JS固有の、実行時に切った貼ったして構造作っていくの、ああいうのTypeScriptだと軒並みコンパイルエラーになるので、ダメです。ほとんどのライブラリが絶滅でしょう。</p>
<p>と、勘違いしていたのですが(yharaさん指摘ありがとうございます！)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">declare var $; // jQuery
declare var _; // underscore
declare var Enumerable; // linq.js
</code></pre>
<p>とかって定義すると、これはそれぞれ $:any, _:any, Enumerable:any という扱いになって、以降はどんなチェーンを繋げてもエラーが起こらない、つまりライブラリが正常に読み込めたかのようになります。</p>
<p>ただ、型チェックや入力補完が効かなくなるので、TypeScript用の型注釈ファイルはあったほうがいいですね。有名ライブラリはともあれ、無名プラグインとかは自前で型注釈書かなければならないかもり。手書きだとかったるいので、自動生成である程度テンプレート吐き出してくれないと、面倒くさい。この辺はMicrosoftだしやってくれるんじゃないかなあ、という淡い期待を抱いていますが……。</p>
<p>とはいえ、ちょっとしたコンパクトなプラグインを使ったり、ライブラリ使うとしても一部分だけだしー、などというのに、わざわざ型定義も馬鹿らしいわけで、さくっと動的な感じにdeclareできちゃう、というのは素晴らしい話。</p>
<p>そんなわけで、JavaScript→TypeScriptの相互運用性としては、繋がりはかなり良好。勿論、jQueryなどもスムースに扱うことができます。これは、文法がJavaScriptプラスアルファで構築されているがことの利点です。そしてTypeScript→JavaScriptは、というと、素直なJavaScriptを吐いてくれることもあり、良好です。TypeScriptで作られた生成物は、TypeScriptだけに閉じません。</p>
<p>JavaScriptを中間言語とする選択肢が増えた。JavaScriptを介することで他の言語とも自由に繋がる。ここには、Webの互換性、中立性を崩す要素は一切ありません。独自言語による囲い込みとかではありません。素直に歓迎できるはずです。ただし、言語としてはあくまでTypeScriptはTypeScriptです。そこだけは、誤解しないほうがいいと思います。文法的に、ES6を若干取り入れているとはいえ、違う言語です。将来的にもTypeScriptはEcmaScriptにならないでしょうし、EcmaScriptはTypeScriptにはならないでしょう。TypeScriptはEcmaScript6のただの代替なのではない、別の価値ある言語です。</p>
<p>変な期待をして、これJavaScriptじゃないじゃん、とかって難癖つけたりは、あまり良くないですね。</p>
<h2>TypeScriptとVisual Studio</h2>
<p>別にMicrosoft環境に閉じる言語ではないので、EmacsでもVimでもいいですが、やはりVisual Studioが第一な点は少なからずあります。LinuxでもIDEで書きたい？きっとJetBrainsがWebStormに搭載してくれるはずです！(実際、Voteはかなり集まってました)</p>
<p>ともあれ、Visual Studioです。専用拡張のインストールはTypeScriptのサイトから出来ます。プロジェクトテンプレートが何故かC#のところにあって気づきにくいことに注意！それともう一つ、<a href="http://visualstudiogallery.msdn.microsoft.com/07d54d12-7133-4e15-becb-6f451ea3bea6">Web Essentials</a>を入れましょう。元々Coffee ScriptとLESSに対応していたのですが、今回TypeScriptにも対応してくれました。Web Essentialsを入れることで、保存時のコンパイル（通常の拡張だとビルド時のみ）と、ウィンドウ分割での出力後のJS表示、それとSourceMapファイルの出力を行ってくれます。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_vs.jpg" />
</p>
<p>勿論、IntelliSenseはフルに効くしエラーはリアルタイムでがんがん通知してくれます。TypeScript Playgroundと違うのは、エラーがあるとJSに変換してくれないところですね。まあ、それは正しい挙動なのでいいです。Playgroundで中途半端なエラーのある状態でもガンガン変更表示してくれるのは、それはそれで便利なので、それもまたいいです。</p>
<p>ちなみに、TypeScript Playgroundでは赤波線が出ている状態は、一応、JSを出力してくれてますが、それはコンパイルエラーの状態で完全な出力がされていないと思って良いです。つまり、本来的には動いてないわけです。この動いていない出力を指して、(現状Firefoxにしか乗ってない)JavaScriptへの互換が不完全とかって難癖つけたりするのは、ほんと良くないですね……。</p>
<h2>SourceMap</h2>
<p>Web Essentialsの吐いてくれるSourceMapとは何ぞや、というと、これはTypeScriptのままデバッグができます。コンパイル時にJSを吐いてくれる系言語の欠点として、デバッガを使ったデバッグが困難、というのが挙げられますがSourceMapを使うとそれも解決、します。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_source.jpg" />
</p>
<p>現状、対応ブラウザはChromeと、まあ、他は知らないのですが、とりあえずChromeは対応しています。IE10(とVS2012内蔵デバッガ)も対応してくれると嬉しいなあ。Chromeのデバッガの不満点としては、ブレークポイントが行単位でしか貼れないことですね。ラムダ式の内側に貼れないと、特にLINQのような一行ラムダを多用するものではデバッグがとても不便でして。この辺、改善されていってくれると嬉しい話。</p>
<h2>vs JavaScript(のIntelliSense)</h2>
<p>実は、VisualStudio 2012のJavaScriptはかなりサポートが手厚く、裏で常にコードを実行して補完候補を出してくれたりします。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_js.jpg" />
</p>
<p>なので、純粋なIntelliSenseの効きだけでいうと、TypeScriptはJavaScriptに負けているかもしれない！如何せん、特にlinq.jsではシーケンスの要素がanyになってしまいますからね。JavaScript(を裏で動かして解釈する)ならば、ここも補完効いてしまうという。最近のJavaScript IDEは進化しすぎで恐ろしい……。</p>
<h2>ジェネリクス</h2>
<p>仕様書にも明言されていますが、正式リリースまでには搭載する予定があるそうです（ちなみに現在は0.8）。ジェネリクスが乗っかるとlinq.jsがすっごくパワフルになるんですよ。如何せん、今はシーケンスの要素の型が全てany扱いで補完が全く効かなくてTypeSafeでもなんでもないのですが、ここが型付けされると完璧なIntelliSense生活！C#並というかむしろC#超えるぐらいの勢いでパーフェクトなLINQ to Objects！なので、相当に待ち遠しいです。</p>
<h2>Compiler as a Serviceの未来</h2>
<p>TypeScriptのコンパイラはTypeScriptで書かれてます。これ、別にかっこつけとかでもなんでもなく、非常に重要な意味を持ちます。で、いきなり分かりやすく成果物として出してくれているのが<a href="http://www.typescriptlang.org/Playground/">TypeScript Playground</a>。構文解析がJavaScriptで可能だから、Web上で全て完結するIDEが作れる。C#も次のバージョンではC#コンパイラがC#で書かれるという計画があります。そのことがもたらす価値の一部分は、TypeScriptが教えてくれます。いや、むしろブラウザ上で全て完結というのは、C#以上の魅力がありますね、正直……。</p>
<h2>結論</h2>
<p>TypeScriptは、良い言語だと本当に本当に思います。私は、素のJavaScriptも別にそこまで嫌いではないのですけれど、やっぱ、違うなあ、と。なので今後は積極的に使っていきたいところです(CSSもLESSで！)。</p>
<p>言語設計者が同じということもありますが、特にC#erには絶対馴染むと思うので、(linq.jsとセットで)今までJavaScriptとは無縁だった人も手を出して欲しいですね。きっと気に入りますし、視点が変わります。勿論、ネイティブJSerも是非是非触ってみるといいと思います！というか触ってほしいです。</p>
<p>あ、あと、軽く流しましたがVisual StudioユーザーならWeb Essentialsも必ず入れておきましょう。これがあるのとないのとでは、TypeScriptの使い勝手全然違ってくるので、TypeScript試すならば必須です。</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
