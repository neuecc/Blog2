<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2012</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-twilight.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2012/06/30_376.html">DataSetについて</a></h1>
<ul class="date"><li>2012-06-30</li></ul>
<div class="entry_body"><p>けちょんけちょんに言ってるとか言ってないとかで言えば言ってるので、遅まきながらその理由などをつらつらと。正直なところDataSetなんて現代の観点から使ってみれば、一発でどれだけクソなのか自明だろう、ぐらいに思ってたので別に言うまでもないと思ってたので特に述べてなかったのですが、意外と支持の声も大きいのですね。困惑するぐらいです。</p>
<p>DataSetというと型付きと型無しがありますが、形無しのほうは、もういらないんじゃないかな。カジュアルな用途ならExpandoObjectを使ってくれという感じだし、そうでないなら、C#で型無しのヘヴィな入れ物とか利点を損ねるしかないわけで。せめてdynamicに合わせた作り直しが必要よね。</p>
<p>それでもADO.NETと密接に結びついていて、たとえばSqlBulkCopyはDataTableしか受け取らないなどがある。だから必要か、というと、そうじゃあなくて。そうじゃなくて、それは害悪なんだって。そのせいでストリームで流し込めないし。今時だったらIEnumerableに対応していて欲しいところだというのに（なお、専用のIDataReaderを手作りすればストリームで流し込めます）。腐った現状を肯定するんじゃなくて、どうあるべきなのかを認識しよう。</p>
<p>ちなみにLINQ to DataSetは型無しDataSetのためのキャスト要因でしかないので、ほとんど名前だけでドーデモイイ代物です。型付きDataSetのほうは一応IEnumerable&lt;TRow&gt;なので不要なんですよね。</p>
<p>さて、話の主題のStrongly Typed(笑) DataSetのほうは、死んでほしい。今すぐに跡形もなく消え去ってほしい。なんでそうも恨み言が多いのかと言ったら仕事で割とヘヴィに使い倒しているから、なのですけれど。</p>
<h2>Nullableに非対応</h2>
<p>分かりやすく最大の馬鹿げた点はここですね。マトモな神経ならどれだけ頭可笑しいのか分かるはずで。作られた年代が年代だからしょうがない？いや、今話しているのは現代のことで、そんなNullable非対応のまま更新されず、大昔に見捨てられた代物なんてどんな選ぶ理由あって？</p>
<p>なお、型付きDataSetを知らない人に説明すると、nullが入る可能性のある列に対してはIsHogeNullというメソッドが生成されているので、そちらで事前チェックすればいい、というシステムになっています。if(row.IsHogeNull()) row.Hoge; といった感じ。もしnullの状態でrow.Hogeにアクセスすると実行時例外。</p>
<p>これ、すごく気持ち良くないんですよね。型付き言語の良さって型がドキュメントなことであり、C#の良さってそれがIntelliSenseでコードを書いている最中からリアルタイムに立ち上がって教えてくれるところであって。なんでコード書いてIntelliSenseも出ているのに、それがnullが混じる可能性があるのかないのか分からないの？Hogeの型がNullableならば、そこから伝わるのに。こういうC#の利点を損なうような代物は全力で許さない。</p>
<h2>Enumに半分非対応</h2>
<p>データベースの数値とC#上のEnumを関連付けることは割とあるシチュエーションだと思うわけですが(EntityFrameworkでもずっと要望に上がっていて最近やっとようやく対応しましたね……)DataTableもプロパティに関してはDBの型ではなくEnumに変更できます。ただし、TableAdapterによるメソッドの引数のほうは変えられないんですねー、あははぁ、intだー、intだぁー、凄いね、キャストだね。クソが。</p>
<p>ただたんにキャストすればいいだけだから大したことないぢゃん、と思うかもですが、これは非常に大きなことなのです。タイプセーフ、というだけじゃなくて、引数の型がEnumだと、それに沿うようIntelliSenseの第一候補として優先的に表れてくれて、こういう些細な気配りがC#の気持ちのよいプログラミングを支えているのです。</p>
<p>これでどこがTypedなのか。ありえないレベル。</p>
<h2>使えないデザイナ</h2>
<p>デザイナ、重いんだよね、普通に。激しくストレスなぐらいに。そして位置の設定はすぐに吹き飛んで横一列に並びきった整列へ。重い状態でセーブするとDesginer1.cs, Designer2.csと数字が延々とインクリメント。そして、長大奇怪なXMLに保存されるのでコンフリクトが発生したらマージ不能。OK、DataSetは古の悪名高きVisual SourceShredder（ロック方式なのでコンフリクトは原理上一応発生しない）とセットで使うべきものなんだな、それならばしかたがない。つまり、現代で使うべきものではない。</p>
<p>そして、基本的にクエリはこのデザイナから書かせるものなのですが、うまくSQLを解釈してくれない。ちょっと凝ったクエリを書くだけで、機能しなくなる。例えばSQL Serverの共通テーブル式とかうまく作れない。生SQLを書かせるのに、シンプルなSQLしか書けない。whereのin句にパラメータを並べるとかもできない。それなら逐語的文字列で書かせてもらったほうが百億倍マシだわ。というか書かせろという感じですが。（できなくもないですけれどね、ただもうそれならそもそもDataSet使わなくていいぢゃん、ほかの余計な制約もあるのだから、といったところで）。</p>
<h2>お節介DataRowView</h2>
<p>私の今の主戦場はWebFormsなのですが、RepeaterにDataTableをバインドすると、あら不思議、DataRowがDataRowViewに化ける！わー、嬉しいー、死ね。余計なおせっかいとしか言いようがない。これ、まあ現代的なC#erならばDataTableをLINQ使って加工したのをバインドしたりもするわけで、IEnumerable&lt;DataRow&gt;の場合は、そのままのDataRowが来る。ええ、同じはずの型が、違う型でやってくるなんて、悪夢すぎる。狂ってる。</p>
<h2>文字列クエリ</h2>
<p>Selectメソッド！紛らわしいですが、DataTableのSelectはLINQにおけるWhereにあたります。「文字列」でクエリ書かせるものが存在します。おお、文字列、タイプセーフじゃあないねえ……。型付きDataTableであっても戻り値は型無しDataTable、なんだねえ……。すごい、すごいすごい。いらないね。現代的に強化するならExpressionに対応させてタイプセーフなクエリを発行するとか、やりようはあるはずですが2005年で更新止まってるのでそんな高尚な機能が追加されることは未来永劫ないでしょう。</p>
<p>おまけに型付きのDataTableはLINQ to Objectsで扱えるので、素直にLINQ to Objectsにまかせてしまったほうが遥かに良い。LINQ以前は、DataTableってインメモリDBとしてある程度のクエリが簡単に実装できる、というところがあったのですが、LINQ以後の世界では純粋なC#コードとして簡単にソートも射影もフィルタリングも可能、それどころか備え付きのクエリとは比較にならないほど柔軟で強力なクエリ能力を手にしているので、もはや中途半端なインメモリDBは不要で、純粋なコレクションだけで構わないぐらいなのですよね。</p>
<h2>モック作るのが面倒くさい</h2>
<p>専用のヘルパでも作りこまない限りは絶望的。</p>
<h2>じゃあどうするの？</h2>
<p>そうですね、ここの回答がない限りはDataSetから抜けられないのですしね。私としてはLINQ to SQLでいいぢゃん(EntityFrameworkじゃなくてね)、と思うのですけれど。MSのコンサルタント連中が2009年末にもなって<a href="http://www.atmarkit.co.jp/fdotnet/chushin/chushinmeeting_01/chushinmeeting_01_03.html">いま使うべき、学ぶべき.NETテクノロジはどれ？</a>という講演で「まずはデータセットやテーブルアダプタを活用できることが大事、とか」「更新系が弱い」とか言い続けているのが絶望的。なんでDataSetが基礎知識なんだよ、馬鹿じゃねーの。</p>
<p>オールドテクノロジーで縛り付けたいのかしらね。求められるのは、ある程度の弱さを知覚した上でのPOCO+DataContextでの使いこなしかたの説明が求めるわけで。まさか、2012年の現在でもEntityFrameworkは更新に弱くてDataSetがまずは基本ですね、とか言っていやあしないですよね、知らないけど。</p>
<p>何でも得手不得手があって使い分けが大事、とかいうのはすごく簡単な逃げ口上ですが、何にでもメリットデメリット、そして未来の潮流を踏まえたうえでの学習の投資で天秤にかけなければならない。DataSetに未来はどこにあるの？腐臭を放ってる資産の保守ぐらいでしょ。こういう影響力ある人らがどうしょうもないことを言うのには、猛烈に腹が立っていてずっと不信感しか持てない。今のところ最後の赤間本であるLINQ本も急いで作った感バリバリでとてもひどいしね（そのことが前説にも書いてあるしね！影響力があるのは分かっているのでしょうから、もう少し丁寧に書けなかったものなのか）。</p>
<p>まあ、WebFormsやWinFormsにはDataSetを前提においたコントロール資産が山のようにあるから……。というのは移れない理由にはなるでしょうね。その場合はプラットフォームごとサヨウナラするしかないんじゃないの？そこまでは知りませんよ。で、その完全に縛られたポトペタ成果物って、魅力的なの？公に出たときに競争力あるの？年々、競争力を失っていっていると思うんですよね。それが許される賞味期限はとうに過ぎていて、残っているのはガラクタだけ。</p>
<p>そして、これからは定型的な業務アプリへなら<a href="http://www.microsoft.com/japan/visualstudio/lightswitch">LightSwitch</a>も出てきましたしね(VS2012からは標準搭載で、出力先もSilverlightだけじゃなくHTML5が選べるので実用性高くなったと思う)</p>
<h2>じゃあEF使えばいいの？</h2>
<p>LINQ to SQLは更新されていなくて、今のMSが推してるデータアクセステクノロジはEntityFrameworkだからEF使おう、というと、うーん、私はEntityFrameworkあんま好きくないので、そんなに薦めないかなあ、とか言っちゃったりして。EntityFrameworkの思想に一ミリも魅力を感じないので。LINQ to SQLのほうがまだずっといいよ！更新されてないぢゃん、というならDataSetだって一緒だしさ！なんというか、DataSetといいEFといい、ADO.NETチームってとってもセンス悪いんじゃないか、と思ったり。（ちなみにLINQ to SQLはC#チーム側からの実装だそうで、さもありなん）。あと同じくセンス悪いなーって思うのはEnterprise Libraryとかですね！</p>
<p>ORMは信用ならねえがDataSetはクソだから、もはや生ADO.NETで、つまりDbConnectionからDbCommandでDbReaderで、というので手作業しかねえ！というのはあると思いますが、うーん、手作りはナシね、ナシ。生を生のまま扱うのはアレなので、ちょっとしたユーティリティ、独自マッパーっぽいものは作ると思うのですが、これがねえ。私は以前に、センスのない独自マッパーを使わされていたことがあったのですが、使いにくくて結構な不幸でした。</p>
<p>単純にマッピングする薄い代物だとはいえ、作るにはそれなりなセンスと技量が必要なのです。で、そういうのをMicro-ORMと称しています。生ADO.NETのちょこっとだけ上層にあって主にクエリ結果のマッピングを効率よく行う、程度な代物なので、実質的には生ADO.NETを扱ってると考えてもいいです。現在だと代表的なものに<a href="http://code.google.com/p/dapper-dot-net/">dapper</a>とか、色々と良いものがあるので、それらを選べばいいんじゃないですか。</p>
<p>フルORMにしたって、Microsoft純正以外にも<a href="http://www.mindscapehq.com/products/lightspeed">LightSpeed</a>とか良い選択肢がありますよ。NHibernateはどうかと思いますが。</p>
<p>ORMについてはLightSpeedの作者の語る<a href="http://www.infoq.com/jp/articles/optimizing-orm-performance">ORMのパフォーマンス最適化</a>という記事が良いと思います。特にDataSetからの移行を意識するのならば。LINQ to SQLの成り立ちについては<a href="http://d.hatena.ne.jp/NyaRuRu/20080101/p1">The Origin of LINQ to SQL を訳してみた - NyaRuRuの日記</a>を。</p>
<h2>Micro-ORMによるデータコンテキスト</h2>
<p>Micro-ORMは、当然ながらDataSetやORMが持つ作業単位の保持はないので、そういうのが必要だったら、ある程度は手作業で作りこむ必要はあります。</p>
<p>少し実例を挙げると私が作っているというか作ったものは、データ保存先がDBだけじゃなくてMemcached(キャッシュとしてだけじゃなくデータ保持にも使う)だったりRedis（ListやHashなどのデータ構造を持つKVS）だったりが、それぞれのパフォーマンス的に適していると思える箇所に挟み込まれたデータコンテキストをなしていて、一個のDBだけの世界を構築するORM系はどれも不適切でして。</p>
<p>かといってDapperなどの既存のMicro-ORMも若干、某弊社の事情に合わないところがあるので、自分で作ろうかなあ（上で作るな、と言ってたのに！）とはずっと思ってるところですね。ベースになるMicro-ORMは既にある→<a href="http://dbexecutor.codeplex.com/">DbExecutor - Simple and Lightweight Database Executor</a>のと、拡張のアイディアは沢山あるので、あとは実装時間ががが。</p>
<h2>まとめ</h2>
<p>DataSetは単純に言って古い。言語機能が年々強化されていく中で、2005年の時点でストップしている（しかも2005の時点の言語機能(Nullable)にすら非対応）なものを使うのは、プログラミングにおいて足枷でしかない。7年前ですよ、7年前。あんまり一般化して言うのもアレですが、ﾄﾞﾄﾈﾄの人って浦島太郎な雰囲気ありますよ、キャッチアップが遅すぎるというか枯れてるのが、とかかんとかって。エンタープライズだとどうだとか業務アプリだとどうだとかメンバーのレベルがどうだとか、そんな言い訳ばかりで、すごく格好悪い。</p>
<p>すっごくクールじゃないわけですよ。そんな言説が目立つところに、魅力を感じるのは難しい。せっかくC#や.NETは魅力的なのに。というわけで、私としては、資産がどうだとかこうだとかって言説は吐きたくないし、もっと活力ある感じになればいいな、って思います。2009年の<a href="http://www.atmarkit.co.jp/fdotnet/chushin/opinion_dotnetversion/opinion_dotnetversion.html">現実に最も使える.NETのバージョンはどれ？</a>→.NET 2.0が現時点でベスト、とか凄く絶望的じゃないですか。まあ、えんたーぷらいずの世界ではそれだししょうがないというのならそうなのでしょうが、なるべくそうじゃない世界を作りたい。</p>
<p>そのためにも、新しく、負の遺産を作るのだけはナシです。DataSetに別れを。</p>
</div>
<h1><a href="https://neue.cc/2012/06/02_375.html">控えめなViewStateによるハイパフォーマンスASP.NET Web Forms開発</a></h1>
<ul class="date"><li>2012-06-02</li></ul>
<div class="entry_body"><p>今どきのウェブ開発はMVCだよねー、な昨今を皆様どうお過ごしでしょうか。そんな中であっても、Web Formsでモバイル向けにハイパフォーマンスサイトを作らなきゃいけない時だってあるんです。さて、そんなWeb Fromsですが、とりあえずの敵はViewStateです。ViewStateをどのように活かし、どのように殺害するか、そこに全てがかかっています。幾つかの典型的なシチュエーションを取り出して、ViewStateを抹消していきましょう。</p>
<h2>ViewStateMode = &quot;Disabled&quot;</h2>
<p>下準備として、ViewStateModeをDisabledにします。ViewStateModeは.NET Framework 4から入った新機能で、「ようやく」ViewStateのオン・オフをルート階層から切り替えることが出来るようになりました。それまではEnableViewStateのみで、falseにすると、その階層の下のViewStateが全てオフになってしまうという使いにくいものでした。全部OFFで済ませられるほど世の中は甘くなく、Web Formsでは部分的にONにする必要性があります。ViewStateModeとEnableViewStateの両方が記述されているとEnableViewStateのほうが優先されて害悪となります。というわけで、.NET Framework 4以降ならばViewStateModeのみを使いましょう。</p>
<pre><code class="language-xml">&lt;%@ Master Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;Site1.master.cs&quot; Inherits=&quot;WebApplication3.Site1&quot; %&gt;

&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head runat=&quot;server&quot;&gt;
    &lt;title&gt;ViewState殺害教&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;asp:ContentPlaceHolder ID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot; ViewStateMode=&quot;Disabled&quot;&gt;
    &lt;/asp:ContentPlaceHolder&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>まずは、マスターページのContentPlaceHolderに対して、ViewStateModeをDisabledにしましょう。こうすることで全ページが強制的にデフォでViewStateオフが働きます。また、ページ単位でDisabledにしてしまうと、各Pageの this.ViewState[&quot;hogehoge&quot;] も無効になってしまって不便なので(PageのViewStateは便利なinput hiddenみたいなものですし、闇雲にすべてをオフにせず、便利なものは便利に使うのが大事です)、マスターページのContentPlaceHolderに仕込むのが最良だと私は考えています。</p>
<h2>テキストボックスやドロップダウンリストから値を取り出す</h2>
<p>そんなわけで、ViewStateを丸ごとオフにした状態からデータを取り出してみませう。</p>
<pre><code class="language-xml">&lt;%@ Page Title=&quot;&quot; Language=&quot;C#&quot; MasterPageFile=&quot;~/Site1.Master&quot; AutoEventWireup=&quot;true&quot;
    CodeBehind=&quot;WebForm1.aspx.cs&quot; Inherits=&quot;WebApplication3.WebForm1&quot; %&gt;

&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:TextBox runat=&quot;server&quot; ID=&quot;ToaruTextBox&quot; /&gt;
        &lt;asp:DropDownList runat=&quot;server&quot; ID=&quot;ToaruDropDownList&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; Text=&quot;ただのボタン&quot; OnClick=&quot;Button_Click&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_aiueo.jpg">
</p>
<p>こんなどうでもいい画面があるとして、コードビハインド側は</p>
<pre><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruTextBox.ToolTip = &quot;ほげほげ&quot;;
        var items = Enumerable.Range(1, 10)
            .Select(x =&gt; new ListItem
            {
                Text = x + &quot;点&quot;,
                Value = x.ToString(),
                Selected = x == 5
            })
            .ToArray();
        ToaruDropDownList.Items.AddRange(items);
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            Response.Write(&quot;TextBox.Text:&quot; + ToaruTextBox.Text + &quot;&lt;br /&gt;&quot;);
            Response.Write(&quot;TextBox.ToolTip:&quot; + ToaruTextBox.ToolTip + &quot;&lt;br /&gt;&quot;);
            Response.Write(&quot;DropDownList:&quot; + ToaruDropDownList.SelectedValue);
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p>こんな感じとします。ところでどーでもいーんですが、DropDownListに値を突っ込むときはLINQでListItemの配列を作って、それをAddRangeで流し込むほうがDataSourceに入れてDataBindするよりも楽です。というのも、DataBindだとSelectedを指定するのが非常に難しいというか不可能に近いようなので。こういう色々と中途半端なとこがWeb Formsは嫌ですね。</p>
<p>さて、このボタンを押した実行結果は、「TextBox.Text:あいうえお」「TextBox.ToolTip:」「DropDownList:」になります。TextBox.Textは取り出せてるけど、ToolTipは取り出せてない。DropDownListも全滅。つまるところ、ViewStateをオフにしていると、復元できる（イベントで取り出せる）プロパティと、そうでないプロパティがあります。挙動としては、Web Formsが復元出来るものは自動で復元してくれて、復元できないものは復元してくれない、といった感じです。そして、それだと困るわけです。ToolTipはどうでもいいのですが、DropDownListの値とか取れないと困る。ViewStateがオンなら、全部取得できているのに！やっぱりViewStateはオンにしよう！ではなくて、何とかしましょう。</p>
<p>「復元出来るものは自動で復元してくれる」というけれど、その情報はどこにあるのでしょう。これは、別にWeb Formsだからって特殊なわけでもなんでもなく、Request.Formにあります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_formasenum.jpg">
</p>
<pre><code class="language-csharp">public static class NameValueCollectionExtensions
{
    public static IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; AsEnumerable(this NameValueCollection collection)
    {
        return collection.Keys.Cast&lt;string&gt;().Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x, collection[x]));
    }
}
</code></pre>
<p>Button_Clickのところでブレークポイント張って、Request.Formの中身を覗きましょう。AsEnumerableは独自拡張メソッドです。Request.FormはNameValueCollectionというゴミに格納されていて、Keysは見れるけどValuesが見れないというクソ仕様なので、そこはLINQで何とかしましょうというか、これは多用するのでNameValueCollectionへの拡張メソッドとして定義しておくと捗りますというか、ないと死ぬレベル。</p>
<p>そんなわけで、Formに普通に格納されていることが分かりました。そうそう、ViewStateをオフにしてるはずなのに__VIEWSTATEに値が入ってるぞ！とお怒りかもですが、ほんの少し入ってくるのは仕様なので、そこは我慢しましょう。大した量じゃないので。</p>
<p>では、どうすれば値を取得できるのか、というと</p>
<pre><code class="language-csharp">protected void Button_Click(object sender, EventArgs e)
{
    try
    {
        Response.Write(&quot;TextBox.Text:&quot; + Request.Form[ToaruTextBox.UniqueID] + &quot;&lt;br /&gt;&quot;);
        Response.Write(&quot;DropDownList:&quot; + Request.Form[ToaruDropDownList.UniqueID]);
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>こうです。コントロールのUniqueIDをFormに渡せば良いわけですね。ToolTipとかいうどうでもいいものは取れないので、そういう、HTMLのinputに存在しないものに関しては、PageのViewStateに保存しておけば良いでしょう。私としては、Web Forms使うならinput hiddenよりもthis.ViewState[&quot;hoge&quot;]を使うべきだと思います。せっかくある道具ならば、嫌々ながらも有効活用したほうが良いでしょう。</p>
<h2>リピーターとチェックボックス</h2>
<p>お次は、繰り返しなシチュエーションを考えてみましょう。繰り返しといったらRepeater一択です。それ以外は存在しません。BulletedListすら存在しません。書き出すHTMLを完全にコントロールできるものはRepeater以外存在しません。Web Formsとはなんだったのか。ともかく、Repeaterです。</p>
<pre><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot;&gt;
            &lt;ItemTemplate&gt;
                &lt;input runat=&quot;server&quot; id=&quot;ToaruCheckBox&quot; type=&quot;checkbox&quot; value=&quot;&lt;%# Container.DataItem %&gt;&quot; /&gt;
                チェック 値:&lt;%# Container.DataItem %&gt;
                &lt;br /&gt;
            &lt;/ItemTemplate&gt;
        &lt;/asp:Repeater&gt;
        &lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruRepeater.DataSource = Enumerable.Range(1, 10);
        DataBind();
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            // CheckされたCheckBoxの値をどう取り出す？
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_repeater.jpg">
</p>
<p>こんな、まあ簡単な画面があるとします。チェックされたCheckBoxの値をどうやって取り出しましょうか？そうそう、ちなみにですがasp:CheckBoxはvalueが指定できないというゴミ仕様なのでやめておきましょう（Web Formsってそんなのばっか、もうやだよ……。ちなみにコード側のInputAttributesで渡すことは一応できます、一応）。</p>
<p>例によってRequest.Formから取り出すことになるので、まずはデバッガで値を見てやります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_check.jpg">
</p>
<p>チェックしたチェックボックスの値、ToaruCheckBox,3とToaruCheckBox,8が確認できます。では、どうやって取り出してやろうか。Repeaterの中のコントロールなのでUniqueIDを使うことはできません。ただ、コントロール階層順に$で連結されてる、という法則は見えるわけなので、単純に$でSplitして文字列一致で見てやりましょうか。</p>
<pre><code class="language-csharp">protected void Button_Click(object sender, EventArgs e)
{
    try
    {
        var checkedValues = Request.Form.AsEnumerable()
            .Where(x =&gt; x.Key.Split('$').Last() == &quot;ToaruCheckBox&quot;)
            .Select(x =&gt; x.Value);

        // Checked:3, Checked:8
        foreach (var item in checkedValues)
        {
            Response.Write(&quot;Checked:&quot; + item + &quot;&lt;br /&gt;&quot;);
        }
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>はい、これで完璧です！なお、ASP.NETのID生成ルールはそれなりに変更が聞くので、詳しくは<a href="http://www.amazon.co.jp/gp/product/4822294544/ref=as_li_ss_tl?ie=UTF8&tag=ilsgeometrati-22&linkCode=as2&camp=247&creative=7399&creativeASIN=4822294544">プログラミングMicrosoft ASP.NET 4 (マイクロソフト公式解説書)</a><img src="http://www.assoc-amazon.jp/e/ir?t=ilsgeometrati-22&l=as2&o=9&a=4822294544" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />でも読めばいいでしょう。</p>
<h2>ボタンとCommandArgument</h2>
<p>ボタンはOnClickではなくOnCommandを使うと、CommandArgument(とCommandName)を渡せて便利です。簡単な例としては</p>
<pre><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Grape %&gt;&quot; Text=&quot;ぶどう!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Apple %&gt;&quot; Text=&quot;りんご!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Orange %&gt;&quot; Text=&quot;みかん!&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    public enum Fruit
    {
        Grape,
        Apple,
        Orange
    }
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        DataBind();
    }

    protected void Button_Command(object sender, CommandEventArgs e)
    {
        Response.Write(&quot;Clicked:&quot; + (Fruit)int.Parse((string)e.CommandArgument));
    }
}
</code></pre>
<p>注意しなければならないのは、aspx上でCommandArgumentに渡すと文字列になるので、enumを渡すときはintにキャストしておくことと、イベント側のCommandEventArgsに渡ってくるときは文字列なのでintにParseしなければならないこと、です。クソ面倒くさいですね、もう少し気が利いてもいいと思うんですが、まあWeb Formsなのでしょうがないと思っておきましょう。</p>
<p>さて、ViewStateがオンならばこれでいいのですが、オフの場合はe.CommandArgumentは常に空文字列になってしまいます。何故か、というと、CommandArgumentはViewStateに乗ってやってくるからです。さて、どうしましょう、というと、解決策は部分的にオンにすることです。</p>
<pre><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Grape %&gt;&quot; Text=&quot;ぶどう!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Apple %&gt;&quot; Text=&quot;りんご!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Orange %&gt;&quot; Text=&quot;みかん!&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p>ButtonのViewStateModeだけを&quot;Enabled&quot;にすることで、最小限のViewStateで最大限の成果を発揮することができます。ViewStateを嫌うならば、そもそもCommandなんて使わない！になるでしょうけれど、そこまでやってしまうと勿体ない。縁あってWeb Formsを使うわけなのですから、「控えめに」「隠し味」として、ViewStateを有効活用していきましょう。</p>
<h2>リピーターとボタン</h2>
<p>最後に、リピーターの中にボタンが仕込まれているパターンを見てみましょう。</p>
<pre><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot; ViewStateMode=&quot;Enabled&quot;&gt;
            &lt;ItemTemplate&gt;
                &lt;%# Container.DataItem %&gt;:&lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん！&quot; /&gt;&lt;br /&gt;
            &lt;/ItemTemplate&gt;
        &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruRepeater.DataSource = Enumerable.Range(1, 10).Select(x =&gt; new string(Enumerable.Repeat('a', 10000).ToArray()));
        DataBind();
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            Response.Write(&quot;Clicked!&quot;);
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_aaa.jpg">
</p>
<p>a(x100000):ボタン という表示結果が得られます。ボタンをクリックするとClicked!と実行されて欲しいわけですが、ViewStateがオフだとうんともすんとも言いません。何故か、というと、イベントの選択もまたViewStateに乗ってくるからです。解決策はRepeaterのViewStateModeをEnabledにすること、です。</p>
<p>しかし、単純にRepeaterのViewStateModeをEnabledにしただけだと、それ以下の全てのViewStateがオンになってしまいます。どういうことかというと、ViewStateを見てみると、この場合の結果は「133656文字」もあります！どれだけデカいんだよ！なぜかというとaaaaaa...(x10000) x 10がViewStateに乗っかってしまったからです。ただたんにボタンクリックできればいいだけなのに！じゃあ、どうするか、というと、ViewStateのオンオフを入れ子にしてRepeaterだけをオンにします。</p>
<pre><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
    &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot; ViewStateMode=&quot;Enabled&quot;&gt;
        &lt;ItemTemplate&gt;
            &lt;asp:PlaceHolder runat=&quot;server&quot; ViewStateMode=&quot;Disabled&quot;&gt;
                &lt;%# Container.DataItem %&gt;:&lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん！&quot; /&gt;&lt;br /&gt;
            &lt;/asp:PlaceHolder&gt;
        &lt;/ItemTemplate&gt;
    &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p>これで解決。クソ面倒くさくて回りっくどくてイライラしますが、&quot;そういうもの&quot;だと思うしかないです。</p>
<h2>Web Formsの良さをスポイルしてまでWeb Forms使いたい？</h2>
<p>使いたくないです。それでもやらなきゃいけない時はあるんですDataSet死ね。</p>
<h2>(ところで関係なく)async event</h2>
<p><a href="http://www.microsoft.com/visualstudio/11/ja-jp">Visual Studio 2012 RC</a>出ました！<a href="http://neue.cc/2012/03/18_368.html">neue cc - Visual Studio 11の非同期(”C#, ASP.NET, Web Forms, MVC”)</a>で非同期系について特集しましたが、Web FormsではRegisterAsyncTask(new PageAsyncTask)しなきゃならなくて面倒くさい死ねという感じでしたが、ようやくイベントにasyncをつけるだけでよくなりました！</p>
<pre><code class="language-csharp">protected async void Button_Click(object sender, EventArgs e)
{
    await Task.Delay(TimeSpan.FromSeconds(3));
    try
    {
        Response.Write(&quot;hoge&quot;);
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>正式リリース前に対応してくれて本当に良かった。これでWeb Formsでももう少し戦える……、戦いたくないけど。</p>
<h2>まとめ</h2>
<p>世の中には<a href="http://en.wikipedia.org/wiki/Unobtrusive_JavaScript">Unobtrusive JavaScript</a>という言葉がありますが、そのように、私としてもUnobtrusive ViewStateを唱えたい。控えめに。とにかく控えめに。ほとんどないも同然なぐらいに。隠し味として使うのが、一番良いわけです。今までのWeb Formsはデフォルトオンで化学調味料をドバドバと投げ込んでいました。そんなものは食えたものじゃあありません。化学調味料を使うなら、超絶控えめに、ほんの少しでいいんです。そうすれば、革命的に美味しくなるのですから。それが正しい化学調味料の使い方。</p>
<p>そして、理想を言えば化学調味料はゼロがいいんですけれどね。ゼロにしたければWeb Formsはやめましょう。それ以外の答えはない。Web Formsを使う以上は正しく向き合うことが大事。</p>
<p>ViewStateをドバドバ使うことがWeb Formsの良さだというのも半分は事実ですが、半分はNOですね。ていうか馬鹿でしょ。そういう発想に未来はないし脳みそイカれてると思いますよ。DataSetを褒め称えていた狂った時代の発想なので、腐った部位はとっとと切り落としましょう。</p>
<p>さて、そうして控えめにしたWeb Formsですけれど、これはこれでそれなりに良いとは思います。最小限にしたとしても、依然としてパーツ配置してOnClickでほいほい、という楽ちんさは健在ですし、カスタムコントロールによるモジュール化というのは悪くない。絶賛はしませんが、悪くないとは思います、そこまで悪しざまにいうものでもない。でも、まあ、もはや時代じゃあないでしょうね。もう、さようなら。</p>
<p>と、まあ割とキツめにWeb Forms(やDataSet)にあたるのは日々苦しめられているからなので、罵詈雑言多いのは勘弁してね！別に現状がダメでも未来に良くなるとかならいいんですが、明らかに未来がないので、なんというかもうねえ、という。Web Formsも、これはこれで面白い仕組みだし、まっとうに進む道もあったとは思うんですが、舵取りにしくったと思います。結果的にこの閉塞感漂う現状と、明らかにリソース割かれてない感があるので、未来はないですね、残念ながら。しかし、最後の徒花としてやれるだけはやるのさぁ。</p>
</div>
<h1><a href="https://neue.cc/2012/05/29_374.html">配列とGetEnumetorのお話</a></h1>
<ul class="date"><li>2012-05-29</li></ul>
<div class="entry_body"><p>LINQ書いていますか？<a href="http://rikunabi-next.yahoo.co.jp/tech/docs/ct_s03600.jsp?p=002219">LINQでデータベース活用</a>とか見出しにありますが、データベース活用といいつつ、その内実は100% LINQ to Objectsです。じゃあデータベースに何で問い合わせやってるの？というと（禁則事項です）。さて、そんなわけで毎日LINQ書いているわけですが、それとは全く関係なく、配列が結構困ったちゃん。例えば以下のような、配列を包んだコレクションを提供したいとします。</p>
<pre><code class="language-csharp">public class WrappedCollection&lt;T&gt;
{
    T[] source;

    public WrappedCollection(T[] innerSource)
    {
        this.source = innerSource;
    }
}
</code></pre>
<p>で、T[]なsourceを元にメソッドを幾つか提供する、と。それ自体はないこともないと思われます。さて、Collectionを名乗っているので、IEnumerable&lt;T&gt;であってほしいですよね？</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/wrappedcollection_error.jpg">
</p>
<p>なぜだ、って、配列のGetEnumeratorの戻り値はIEnumeratorなのです。IEnumerator&lt;T&gt;ではなくて。マジで！マジで。さて、どうしようかしら、と。foreach(var item in source) yield return item; をすれば解決ですが、そんなダサいことはやりたくない。正解は、AsEnumerableです。</p>
<pre><code class="language-csharp">public class WrappedCollection&lt;T&gt; : IEnumerable&lt;T&gt;
{
    T[] source;

    public WrappedCollection(T[] innerSource)
    {
        this.source = innerSource;
    }

    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        return source.AsEnumerable().GetEnumerator();
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
</code></pre>
<p>これだけで解決。やったね、AsEnumerableは偉大で奥深いなあ。さて、以前に<a href="http://neue.cc/2011/07/27_335.html">Deep Dive AsEnumerable</a>で書きましたが、AsEnumerableの実態はただのキャストなので</p>
<pre><code class="language-csharp">return ((IEnumerable&lt;T&gt;)source).GetEnumerator();
</code></pre>
<p>でもOKです。</p>
<p>さて、それらの中身ですが</p>
<pre><code class="language-csharp">var source = Enumerable.Range(1, 10).ToArray();

var e1 = source.GetEnumerator();
var e2 = source.AsEnumerable().GetEnumerator();

// System.Array+SZArrayEnumerator
Console.WriteLine(e1.GetType());
// System.SZArrayHelper+SZGenericArrayEnumerator`1[System.Int32]
Console.WriteLine(e2.GetType());
</code></pre>
<p>といった具合に、型が違うと渡ってくるEnumeratorも違うようですね。これ自体は別にスペシャルな機能ではなく<a href="http://msdn.microsoft.com/ja-jp/library/ms173157.aspx">明示的なインターフェイスの実装</a>をした時の挙動、ではありますが、まあ配列周りはそもそもに色々とややこしいですからね。私みたいなゆとりなんて、SZって何だよクソが(single-dimension zero-baseの意味だそうで)とか思ってしまいます。</p>
<h2>まとめ</h2>
<p>IEnumerable&lt;T&gt;じゃないコレクションは逝ってよし。つまりMatchCollectionは何で.NET 4.5になっても手を加えてくれないんだよぅううううぅぅぅ。</p>
</div>
<h1><a href="https://neue.cc/2012/05/13_373.html">XboxInfoTwit - ver.2.4.0.3</a></h1>
<ul class="date"><li>2012-05-13</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comが内部的にちょっと変わっていて動かなくなっていたので、それに対応しました。前々から報告されている不具合などに関する修正などは一切入ってません、すみません。最近割と普通に忙しくて全く手をかけられない状態でして……。落ち着いたらその時には必ず。</p>
</div>
<h1><a href="https://neue.cc/2012/04/30_372.html">MetroStyleDeveloper #03の告知</a></h1>
<ul class="date"><li>2012-04-30</li></ul>
<div class="entry_body"><p>最近は告知ばかりで、まともにブログ記事書いてなくてすみませんすみません。Windows Developer Daysでのセッションはお陰様で立ち見が出るほどに大盛況で、うれしかったです。資料に関しては、公開できるように調整中です（いちおー会社身分で出てるので、公開するときは会社サイトのほうになるかしら、と思っています）。中々面白い感じに仕上がっているので、なるべく早いうちに出したいところです。</p>
<p>さて、WDDのキーノートで <a href="http://gloops.com/news/2012/04/425microsoft-windows-developer-days-windows8.html">4月25日に開催されたMicrosoft Windows Developer Days にて、Windows8ベースで開発したグループスの試作アプリが発表されました</a> ということで、シアトルクエストという試作アプリが公開されました。その詳細を、5/12に開催される<a href="http://metrostyledev.net/index.php/event/20120512/">MetroStyleDeveloper #03</a>で発表します！（予定）。会場、弊社ですお。</p>
<p>というわけで、気になった方はそちらも是非是非来ていただけたらと思います。</p>
</div>
<h1><a href="https://neue.cc/2012/04/17_371.html">Windows Developer Daysで登壇します</a></h1>
<ul class="date"><li>2012-04-17</li></ul>
<div class="entry_body"><p>4/24-25に開催される<a href="http://www.microsoft.com/ja-jp/events/wdd/program.aspx">Microsoft Windows Developer Days</a>で登壇します。<a href="https://www.event-marketing.jp/events/wdd/Register/Session.aspx">セッション一覧</a>より、Day 2の11:30-13:00、Room Fでタイトルは「LINQ to Everything : データソース・言語を超える LINQ の未来」です。</p>
<p>これなのですが、私の勤め先の<a href="http://gloops.com/">gloops</a>がWDDのプラチナスポンサーで、そのスポンサー用のセッション枠を私が頂いた、みたいな形です。スポンサー枠なのに完全に趣味のLINQの話しかしない気満々とか非常にアレ。そんなわけなので是非来てください。ランチセッションなのでお昼も出るので、ご飯食べながらゆるゆると聞いてもらえればと思ってます。</p>
<p>弊社からは、他にSQL Azure MVPの大和屋さんが<a href="http://sqlazure.jp/b/sqlazure/1079/">gloops提供人気ソーシャルゲームでトラフィック限界に挑戦！SQL Azure Federation検証結果公開</a>というタイトルで4/24に出ますので、そちらも是非是非どうぞ。</p>
</div>
<h1><a href="https://neue.cc/2012/04/02_370.html">Microsoft MVP for Visual C#を再受賞しました</a></h1>
<ul class="date"><li>2012-04-02</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2011/04/02_313.html">去年の報告</a>から一年、再受賞することができました。活動はあまり変わらずC#とLINQについてブログに書いて、小さめのライブラリを作って公開して、それと今回は少し、外での活動が増えましたね。つい一昨日もSilverlightを囲む会で<a href="http://www.slideshare.net/neuecc/reactive-extensions-v20">Reactive Extensions v2.0</a>としてお話しました。</p>
<p>日本の海外に比べて弱いところ、先端的な技術の紹介であったりディープに踏み込んだ使い方であったり、何かを作って公開することであったり。それらを埋めていきたいな、と思っています。そういったことを通してC#の良さを伝えられていければ何よりです。</p>
<h2>近況</h2>
<p>さて、しかし色々何かと停滞中です……。ライブラリは更新していない、ツールもバグ報告スルー中、Pull Requestすら放置、原稿……、などなどなどなど。はい、どうみてもダメ人間です。やりたいこと、はいっぱいあって、やらなければならないこと、もそれなりにあって、それらがかちあってどっちも出来ず仕舞いで時間を浪費してばかり。今年はその辺もしっかり整理して、より多くの何かを届けていきたいところです。実際のとこダラダラTwitterやってる時間が一番長くてマズいのは確定的に明らか。Twitterやってる時間をSkyrimに回したほうがよっぽど有意義ってものですよ！しかもなんと超絶楽しみにしていたSkyrimは未だ未開封という、もうアレ。悲しいですね。</p>
</div>
<h1><a href="https://neue.cc/2012/03/28_369.html">ソーシャルゲームとわたくし</a></h1>
<ul class="date"><li>2012-03-28</li></ul>
<div class="entry_body"><p>最近のWeb業界の風潮にならって、ちゃんとロクロ回しました！</p>
<ul>
<li><a href="http://rikunabi-next.yahoo.co.jp/tech/docs/ct_s03600.jsp?p=002099">gloopsがWindows環境でソーシャルゲームをつくる理由｜【Tech総研】</a></li>
</ul>
<p>猫も杓子もみんなソーシャルゲーム業界に行くんだなあ、とかﾎﾟｹｰｯと眺めていましたが、まさか私も行くとは全然思ってもいませんでした。というわけで、1月から転職したと書きましたけれど、<a href="http://gloops.com/">株式会社gloops</a>で働いています。転職理由とかは、インタビューの通りです。C#を世間（といっても、技術系の人に、ですね）に強くアピールするにはどうすればいいのか、といったら、一番大事なのはそれで書かれたメジャーなアプリケーションなのです。PerlではてなやMixi、livedoorなどを思い浮かべる、RubyでCookpadを、ScalaでFoursquareやTwitterを、そういった憧れにも似た気持ちを浮かべさせるようなアプリケーションがなければいけなくて。</p>
<p><a href="http://stackoverflow.com/">Stack Overflow</a>はC#, ASP.NET MVCだし、<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">TIOBEのプログラミング言語ランキング</a>では三位など、海外でのC#の地位は十分に高い。のですが、国内ではそれと比べれば全くもってない。日本で誰もが知る会社の誰もが知るアプリケーション、それがC#で書かれている。そういう状態にならなければ、日本で強く普及は無理だな、と。</p>
<p>ギョーム系アプリでは十分に強いじゃん、とかそうじゃなくて、私としてはもっと学生とかも憧れてガンガン使う感じであって欲しいんですよ。Visual Studioは無料版ありますし、学生向けの支援(<a href="http://msdn.microsoft.com/ja-jp/academic/hh455217">DreamSpark</a>など)もやってはいますが、あまりリーチできてないのではないかなあ、って。そういうのって内からやりたいって気持ちが湧いてきて初めて支援があって嬉しい！になるわけで。</p>
<p>まあその領域だったら、やっぱゲームですよゲーム！なんというか、Unityブームのほうがずっと請求してるかもなのですかねー。というわけで<a href="http://atnd.org/events/26442">第77回codeseek勉強会＆第17回日本C#ユーザー会 勉強会 : C#とゲーム</a>では、C#とゲーム全般を取り扱って、そのなかで弊社CTOの池田もソーシャルゲーム枠でセッション持ちますので、残席まだありますので是非是非どうぞ（宣伝）</p>
<p>ゲームもいいのですが、デスクトップアプリケーションもいいし（最近はあんまし流行らないですって？そうかもですがー）、モバイルアプリもいいし（Windows Phone 7よりも、MonoTouchやMono for Androidのほうが受けますな）、そして、ウェブアプリもいい。C#の持つ強みや範囲というのは、本当に、もっともっと知られて欲しいなって。</p>
<p>そんなようなことは入社初日にも言ったりなどしていて、今も当然変わってませんし、3ヶ月働いてきて、実現できる会社であると実感しています。<a href="http://event.yomiuri.co.jp/mlb/">2012 グループス MLB開幕戦</a>の冠協賛や、最近はCMも増えてきたりなど、露出も増えてきて、勢いありますね。その勢いを止めない、加速させるためにも、まだまだ人が必要というわけで、求人バナーもかなり見かけてるんじゃないかと思います。というわけで弊社ではエンジニアを絶賛募集中なのでC#で書きたい！という人は是非是非お願いします（宣伝）</p>
<p>あと、私自身の目的としてはもう一つあって、日本ローカルだけじゃなく世界にも通用する技術力を掲示したいという欲求があります。その面でも、世界に向けても前進している(<a href="http://game.watch.impress.co.jp/docs/interview/20120323_520639.html">gloops International CEO冨田由紀治氏インタビュー - GAME Watch</a>)のは、マッチしていました。とはいえ、まずは日本、です。そもそも全然半人前だと痛感する毎日で寝言は寝てから言え状態なので、日々鍛錬ですね。</p>
<h2>ソーシャルゲーム</h2>
<p>このサイトの前身はゲーム攻略サイト(Xbox系)で、2002年からです（このサイトのアレゲな配色はその頃から全く変わってないから、というのが大きな理由です）。また、特に好きな<a href="http://www.nicovideo.jp/watch/sm221184">Geometry Wars</a>なんて世界ランキングでもかなり上位だったりニコ動にプレイ動画を投稿したりする程度には、一応そこそこハードなゲーマーを自称していたのですが、最近はめっきりゲームとは遠ざかってしまいました。あうあう。完全にプログラミング系サイトですしねー。</p>
<p>というわけで、元ゲーマーとでもしませうか。で、ソーシャルゲーム。ゲーマーといったらソーシャルゲームは割と忌み嫌うという感じの！ふむ。まあでも、ほら、最近はアイドルマスター シンデレラガールズが（色々な意味で）話題だったり、それはそれで独特に面白さってのはあるんですね。いや、モゲマス面白いですよ、ガチャ地獄とか除いても普通に。必ず人と繋がり合う（それが衣装泥棒であっても）、それも緩やかに非同期に（MMORPGや対戦系は同期的ですから）というのは、独特なものがあると思います。</p>
<p>正直いって、まだ完全に面白さには繋がってないとは思いますが（特にゲーマー向けには）、このシンプルで非常に限られた中からゲーム性（と○○）を引き出すチャンスは転がっている、かもしれません。ずっとガラケー向けに貧相な画面とボタン連打だけで変わらない、わけでは、ない。スマートフォンの時代は来ているし、HTML5の流れだってあるし、それはソーシャルゲームだって同じなのです。</p>
<p>フロントエンドはモバイル向けというのを考慮しながらもリッチしなければならないし、バックエンドはハイパフォーマンスに耐えなければならない。課題は大量にありますが、だからこそ技術者としては挑戦しがいのある面白いテーマが山のように転がっています。例えばC# 5.0が非同期でハイパフォーマンスといったって、別にそんなのそこまで必要じゃないしなー、で終わってしまう状況もいっぱいあると思うのです。でも、弊社では、今すぐにでも必要なのだというぐらいに切羽詰ってる。C#の能力をフルに使いきることが求められる。これは楽しいですね？はい、楽しいです。</p>
<h2>会社員ですからー</h2>
<p>インタビュー記事が求人記事なので、会社員として宣伝しました！なので基本的にイイ事しか言いませんが、勿論イクナイ面もそれなりにあります。例えば最近の私の記事を見ると某テクノロジーをやたらDisってますが、なんでなんでしょうかねー、ふふり。とはいえ、不満に思うなら自分でぶち壊して再構築すればいいし、それが許される（勿論ちゃんと能力を証明したうえで）環境だとは思います。スキルある人が何の制約もなく存分に腕をふるえるのなら、素敵な話ではないでしょうか。</p>
<p>ちなみに私のスキルはC#/LINQに偏っていてウェブとかASP.NETの知識は並なので、毎日勉強です、人はそれを付け焼刃とも言う。</p>
</div>
<h1><a href="https://neue.cc/2012/03/18_368.html">Visual Studio 11の非同期("C#, ASP.NET, Web Forms, MVC")</a></h1>
<ul class="date"><li>2012-03-18</li></ul>
<div class="entry_body"><p>世の中ひどぅーきひどぅーきと騒ぐばかりで、猫も杓子もNode.js。でもですね、<a href="http://codezine.jp/article/detail/6461">【デブサミ2012】16-A-5 レポート　ソーシャルアプリケーションにおけるNode.jsの活かし方（1/2）：CodeZine</a>なんかを見ても、そこで独自に作りこんでる例外処理だの非同期フロー管理だのは、そりゃあ必要ですよね、まずはそこから始めるのは当然ですよね、と思いつつC#は最初から備えているんですよね。むしろ色々とC#のほうが、とか思ったりするわけですが（勿論Node.jsのほうがGoodなものもありますが）、こんなところで嘆いていても始まらないのでC#流の非同期の活かし方を見ていきましょうか。</p>
<h2>HttpTaskAsyncHandler</h2>
<p>ASP.NETの非同期ハンドラはIHttpAsyncHandlerなわけですが、VS11ではそれをTask(つまりC# 5.0 async/await)で扱いやすくした基底クラス、<a href="http://msdn.microsoft.com/ja-jp/library/system.web.httptaskasynchandler(v=vs.110).aspx">HttpTaskAsyncHandler</a>が用意されています。例えばTwitterの検索を叩いて返すだけどのものは以下のようになります。</p>
<pre><code class="language-csharp">public class TwitterSearchHandler : HttpTaskAsyncHandler
{
    public async override Task ProcessRequestAsync(HttpContext context)
    {
        var term = context.Request.QueryString[&quot;q&quot;];
        var json = await new HttpClient().GetStringAsync(&quot;http://search.twitter.com/search.json?q=&quot; + term);

        context.Response.ContentType = &quot;application/json&quot;;
        context.Response.Write(json);
    }
}
</code></pre>
<p>普通と違うのはasyncとawaitだけなので、特に混乱もなく同期→非同期に乗り換えられると思います。非常に簡単。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/library/system.net.http.httpclient(v=vs.110).aspx">HttpClient</a>も.NET 4.5からの新顔で、WebClientの後継的な位置付けでしょうか。細かいコントロールも可能で、かつ、WebRequestよりも簡単で、非同期にもきっちりマッチしている。というかHttpClientには同期的なメソッドは用意されていません。これからの非同期世代に完全準拠した新しいクラスということですね。</p>
<p>そして、テスト用のサーバー立てるのも非常に簡単で。Visual Studioで新規で空のASP.NETサイトプロジェクトを作って、↑のハンドラ足して、Ctrl + F5すればIIS Expressが立ち上がって、もうそれだけでOKなわけですよ。超簡単なわけですよ、マジでマジで。</p>
<p>こないだ、<a href="http://atnd.org/events/24951">RIA アーキテクチャー研究会　第3回</a>でのセッションではそうして作ったHttpTaskAsyncHandlerで、 context.Response.StatusCode = 404 にしてエラーを返した状態を再現したりしながらデモしていました。</p>
<div style="width:595px" id="__ss_11947538"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/asynchronous-rx-andtask" title="C#次世代非同期処理概観 - Task vs Reactive Extensions" target="_blank">C#次世代非同期処理概観 - Task vs Reactive Extensions</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/11947538?rel=0" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>今回はTaskを中心にしましたが、Rxを中心にしたものを<a href="http://silverlightsquare.com/index.php/tokyo06.html">Silverlightを囲む会in東京#6</a>で3/31に話す予定なので、まだ募集中なので是非来て下さい。また、Rx v2.0に関しては<a href="http://blogs.msdn.com/b/rxteam/archive/2012/03/12/reactive-extensions-v2-0-beta-available-now.aspx">Reactive Extensions v2.0 Beta available now! - Reactive Extensions Team Blog - Site Home - MSDN Blogs</a>で超詳細に書かれていますね。私もちょいちょいと書きたいことは溜まってるのですが中々にぐぬぬぬ。</p>
<h2>非同期ページ</h2>
<p>今更Web Formsとか超どうでもいいって感じが世界全体に漂ってるし真面目に色々と腐ってると本気で思うしDataSetとWeb Formsは今となっては.NET三大汚点の筆頭かなとか思ったり思わなかったり適当に言ったり呪詛を吐いたり、もう色々アレなのですが、それでも現実とは戦わなければならないのです！</p>
<p>というわけでVS11のASP.NET Web Formsの非同期の強化でも見てみましょう。C# 5.0でasync/awaitが入るのでASP.NET MVCのほうは非同期コントローラーでﾋｬｯﾎｲなのですがWeb Formsも一応対応してきました、一応ね、一応。</p>
<pre><code class="language-xml">// Web.config
&lt;appSettings&gt;
  &lt;add key=&quot;aspnet:UseTaskFriendlySynchronizationContext&quot; value=&quot;true&quot; /&gt;
&lt;/appSettings&gt; 
</code></pre>
<pre><code class="language-xml">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;~/WebForm1.aspx.cs&quot; Inherits=&quot;WebApplication8.WebForm1&quot;
　　　　Async=&quot;true&quot; ViewStateMode=&quot;Disabled&quot; %&gt;

&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head runat=&quot;server&quot;&gt;
    &lt;title&gt;Async Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
    &lt;asp:TextBox ID=&quot;WordTextBox&quot; runat=&quot;server&quot; /&gt;
    &lt;asp:Button ID=&quot;SearchButton&quot; runat=&quot;server&quot; Text=&quot;Button&quot; OnClick=&quot;SearchButton_Click&quot; /&gt;
    &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;TwitterStatuses&quot; ItemType=&quot;dynamic&quot;&gt;
        &lt;ItemTemplate&gt;
            &lt;p&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.from_user %&gt;&quot; /&gt;&lt;br /&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.text %&gt;&quot; /&gt;
            &lt;/p&gt;
        &lt;/ItemTemplate&gt;
    &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-csharp">// namespace WebApplication8
public partial class WebForm1 : System.Web.UI.Page
{
    protected void SearchButton_Click(object sender, EventArgs e)
    {
        var task = new PageAsyncTask(async () =&gt;
        {
            var word = WordTextBox.Text;
            using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
            {
                var json = System.Json.JsonObject.Load(stream);
                TwitterStatuses.DataSource = json[&quot;results&quot;];
            }
            DataBind();
        });

        RegisterAsyncTask(task);
    }
}
</code></pre>
<p>非同期ページの利用には Async=&quot;true&quot; 属性をつける必要があります。.NET 4.0まではつけていない場合は、同期的に動作するようになっていたのですが、.NET 4.5からはエラーになるように挙動が変更されています。また、PageAsyncTaskを利用する場合はWeb.configにUseTaskFriendlySynchronizationContext = true する必要もあるっぽいです。</p>
<p>これ自体はテキストボックスに検索語を入れてボタンを押すとひどぅーきでTwitter検索して表示する、というだけのDoudemoii代物です。PageAsyncTaskが引数にTaskを受け入れるようになったので、そこでasyncなラムダ式を突っ込んでやればいい、というわけで、まあまあ簡単と言えなくもなく仕上がっています。理想的には/直感的にはasync void SearchButton_Clickと書けるようになるべきなのですが、そうはいかないようです、残念。</p>
<p>JSONは.NET 4.5からお目見えの<a href="http://msdn.microsoft.com/ja-jp/library/system.json(v=vs.110).aspx">System.Json</a>を使いました。これ、AsDynamic()とするとdynamicで扱えるのでサクサクッと使えて便利です。また、そのdynamicとして使える性質を活かして、dynamicのままバインドしてみました(AsDynamicはコード上dynamicにキャストするというだけで、JsonValueはそのもの自身がdynamic = IDynamicMetaObjectProviderなのです)。System.Jsonは<a href="http://nuget.org/packages/System.Json">NuGet - System.Json</a>にもあるので、.NET 4ではそれを使えばいいでしょう。<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>はお払い箱で。</p>
<p>それとRepeaterのItemType=&quot;dynamic&quot;。これでItem.from_userといったように、dynamicに使えるようになっています。匿名型をバインドしたい時なんかも、同じようにItemType=&quot;dynamic&quot;にしてしまうといいかな、と思ったんですが、それは出来ませんでした。あともう一歩、気を利かせてくれても良かったですねえ。</p>
<p>まあ、VS11からは、念願のバインディング式の中でIntelliSenseが効くようになっていて、それはRepeaterのItemTypeも例外ではないので、ちゃんと型作ってあげるのも良いとは思います。あと%:でHtmlEncodeもしてくれますのも良いところ。</p>
<p>ViewStateMode=&quot;Disabled&quot;で無駄なViewStateは生成しないようにするのも大事。これは.NET 4.0からですね。EnableViewStateとは別物という紛らわしさが残っているのも、まあなんともかんとも。ところでPageのViewStateModeをDisableにしてしまうと、this.ViewState[]が使えなくなってしまうので、マスターページからの、asp:Contentにしかけたほうがいいかもです。</p>
<h2>EventHandlerTaskAsyncHelper</h2>
<p>ASP.NETの非同期関連はMSDNマガジンの<a href="http://msdn.microsoft.com/ja-jp/magazine/cc163463.aspx">WickedCode: ASP.NET の非同期プログラミングを使ったスケール変換可能なアプリケーション</a>にまとまっていますが、そこにあるとおり非同期ページの実現方法にはもうひとつ、AddOnPreRenderCompleteAsyncを使う方法があります。それにもTask用のやり方がありますので、見てみましょう。</p>
<pre><code class="language-csharp">var helper = new EventHandlerTaskAsyncHelper(async (_, __) =&gt;
{
    var word = WordTextBox.Text;
    using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
    {
        var json = System.Json.JsonObject.Load(stream);
        TwitterStatuses.DataSource = json[&quot;results&quot;];
    }
    DataBind();
});

AddOnPreRenderCompleteAsync(helper.BeginEventHandler, helper.EndEventHandler);
</code></pre>
<p>EventHandlerTaskAsyncHelperを作り、それのBeginとEndをAddOnPreRenderCompleteAsyncに渡してあげます。ちょっとPageAsyncTaskより面倒ですね。まあ、でも、どちらでもいいでしょう。大した違いはありません。二つやり方があるとどちらにすればいいのかと迷ってしまうのが良くないところなんですよねえ、しかもどちらも似たようなものだと……。</p>
<h2>非同期モジュール</h2>
<p>Moduleについても見てみましょう。感覚的にはAddOnPreRenderCompleteAsyncと一緒で、EventHandlerTaskAsyncHelperを作り、追加したいイベントにBeginとEndを渡します。</p>
<pre><code class="language-csharp">public class MyModule : IHttpModule
{
    public void Init(HttpApplication application)
    {
        var helper = new EventHandlerTaskAsyncHelper(async (sender, e) =&gt;
        {
            var app = (HttpApplication)sender;
            var path = app.Server.MapPath(&quot;~/log.txt&quot;);

            using (var fs = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.Read, 4096, useAsync: true))
            using (var sw = new StreamWriter(fs, Encoding.UTF8))
            {
                await sw.WriteLineAsync(&quot;Request:&quot; + DateTime.Now);
            }
        });

        application.AddOnBeginRequestAsync(helper.BeginEventHandler, helper.EndEventHandler);
    }

    public void Dispose() { }
}
</code></pre>
<p>AddOnXxxAsyncは沢山あるので、追加したいイベントを選べばいいでしょう。また、非同期でファイルを扱いたい時は、useAsync: trueにするのが大事です。デフォルトはfalseになっているので、Begin-Endをしても非同期にならない（というかスレッドプールを使った挙動になってしまう）そうです（と、プログラミング.NET Frameworkに書いてあった）。</p>
<h2>非同期コントローラー</h2>
<p>一応ASP.NET MVCでも見てみましょうか。TwitterのPublicTimelineを表示するだけのものを（テキストボックスすら作るのが面倒になってきた）</p>
<pre><code class="language-csharp">public class PublicTimelineController : AsyncController
{
    public async Task&lt;ActionResult&gt; Index()
    {
        using (var stream = await new HttpClient().GetStreamAsync(&quot;https://twitter.com/statuses/public_timeline.json&quot;))
        {
            var json = System.Json.JsonObject.Load(stream);
            return View(json);
        }
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    @foreach (var item in Model)
    {
        &lt;p&gt;
            @item.user.screen_name
            &lt;br /&gt;
            @item.text
        &lt;/p&gt;
    }
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>AsyncControllerの自然さと、きゃーRazor最高ー抱いてー。</p>
<h2>まとめ</h2>
<p>HttpTaskAsyncHandlerにせよEventHandlerTaskAsyncHelperにせよ、中身は割とシンプルにTaskでラップしただけなので、それを自前で用意すればTask自体は.NET 4.0に存在するので、async/awaitは使えませんがそれなりに簡単に書けるようにはなります。とりあえず私はWeb Forms用のものを仕事で使うために用意しました。コードは会社で書いたものなので上げられませんが！というほど大したものでもないので上げちゃってもいいんですが上げません！Web Formsにはとっととお亡くなりになってもらいたいので。延命措置禁止。</p>
<p>Web Formsだって悪くないものだ、全力で頑張ればほら、こんなに出来るじゃないか、ということは容易い、ことはまったくなく全力なわけですが、しかし可能ではあるんですね、モバイル対応だろうがハイパフォーマンスサイトだろうが。きっとたぶん。でもね、なんかもうIE6にも対応しつつHTML5サイトです、とかやるぐらいに不毛感漂ってるし、その労力は別のとこに向けたいですよね、っていうか別のとこに向けばどれだけ幸せになれるだろうか、と思ってしまうのです。</p>
<p>考えてみると、こうもうぇぶけーな話を書くのも初めてな気がする。近頃はお仕事がそっち方面なので、出せる範囲でちょいちょい出してこうかと思います。とにかく結論としてはWeb Formsちゃんは、もう沢山頑張ったと思うのでそろそろ逝ってもらって構いません。</p>
</div>
<h1><a href="https://neue.cc/2012/03/08_367.html">LINQのWhereやSelect連打のパフォーマンス最適化について</a></h1>
<ul class="date"><li>2012-03-08</li></ul>
<div class="entry_body"><p>Where連打していますか？それともパフォーマンスの悪化を心配して&amp;&amp;連結にしていますか？<a href="http://www.atmarkit.co.jp/fdotnet/chushin/greatblogentry_06/greatblogentry_06_01.html">LINQの仕組み＆遅延評価の正しい基礎知識 － ＠IT</a>ではWhere+Selectに対して</p>
<blockquote>
<p>「WhereSelectEnumerableIterator」となっていて、名前のとおり、WhereとSelectが統合されていることです。これは、「Where」-&gt;「Select」が頻出パターンなので、それらを統合することでパフォーマンスを向上させるためでしょう。</p>
</blockquote>
<p>と書きましたが、では連打の場合はどうなっているでしょうか。見てみましょう。</p>
<pre><code class="language-csharp">var seq1 = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where(x =&gt; x % 3 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqwherewhere.jpg">
</p>
<p>// どうでもいいんですが、これは<a href="http://www.microsoft.com/visualstudio/11/ja-jp">Visual Studio 11 Beta</a>です。VS11最高ですよ！</p>
<p>@ITの記事では、sourceに格納されて内包した形の連鎖となっている、と書きました。しかしseq1のsourceはRangeIteratorで、Where連打のはずなのに、すぐ上の階層が元ソースとなっています。そして、predicateの名前がCombinePredicates。はい、その通りで、2つの条件式が連結されています。確認してみましょう。</p>
<pre><code class="language-csharp">var pred = (Func&lt;int, bool&gt;)seq1.GetType().GetField(&quot;predicate&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(seq1);

Console.WriteLine(pred(2)); // false
Console.WriteLine(pred(3)); // false
Console.WriteLine(pred(6)); // true
</code></pre>
<p>というわけで、Where連打はpredicateが連結されて一つのWhereに最適化されることが確認できました。<a href="http://neue.cc/2009/07/21_178.html">LinqとCountの効率</a>でICollectionやIListの場合の特別扱いなケースがあることを紹介しましたが、Whereに関しても同様な特別扱いが発生するというわけです。</p>
<h2>Selectの場合</h2>
<p>Whereの他にSelectの場合も、同じような最適化を行ってくれます。</p>
<pre><code class="language-csharp">var seq2 = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Select(x =&gt; x + 10);

var selector = (Func&lt;int, int&gt;)seq2.GetType().GetField(&quot;selector&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(seq2);

Console.WriteLine(selector(2)); // 2 * 2 + 10 = 14
Console.WriteLine(selector(5)); // 5 * 2 + 10 = 20
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqselectselect.jpg">
</p>
<p>sourceのすぐ上がRangeIteratorで、selectorにCombineSelectorsとして格納されていました。なお、型名であるWhereSelectEnumerableIteratorのとおり、現在はpredicateはnullですが、前段にWhereを書けばpredicateに格納されて、やはりWhere+Selectの最適化となります。では、後段にWhereを書いた場合は……？</p>
<h2>最適化されない場合</h2>
<p>Where+SelectとSelect+Whereは異なるものです。見てみましょう。</p>
<pre><code class="language-csharp">var whereSelect = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Select(x =&gt; x * 2);

var selectWhere = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Where(x =&gt; x % 2 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqwhereselectselectwhere.jpg">
</p>
<p>Where+SelectはWhereSelectEnumerableIteratorのpredicateとselectorにそれぞれデリゲートが格納され、ひとまとめに最適化されていますが、Select+WhereはsourceがRangeIteratorではなくWhereSelectEnumerableIteratorであるように、普通に階層の内包構造となっています。Selectの後にWhereは最適化されません。まあ、そりゃ値が変形されているのだからpredicateがひとまとまりになるわけがなく、当たり前ではあります。</p>
<p>次にインデックスが使えるオーバーロードのケースを見てみましょう。</p>
<pre><code class="language-csharp">var whereIndex = Enumerable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where((x, i) =&gt; i % 2 == 0);

var selectIndex = Enumerable.Range(1, 10)
    .Select(x =&gt; x * 2)
    .Select((x, i) =&gt; i * 2);

// GetEnumeratorしないとpredicate/selectorとsourceがnullです
// これはyield returnによる生成なためです
whereIndex.GetEnumerator();
selectIndex.GetEnumerator();
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqehereindexselectindex.jpg">
</p>
<p>これもひとまとめにしようにも、しようがないので、当然といえば当然ですね。</p>
<h2>IQueryableの場合</h2>
<p>IQueryableだとどうなのか、というと……</p>
<pre><code class="language-csharp">// LINQ to SQL - AdventureWorks sample
var ctx = new AdventureWorksDataContext();
var query = from model in ctx.ProductModel
            where model.Name == &quot;hoge&quot;
            where model.ProductModelID == 100
            select model.Instructions;

Console.WriteLine(query);
</code></pre>
<pre><code class="language-txt">// 結果
SELECT [t0].[Instructions]
FROM [Production].[ProductModel] AS [t0]
WHERE ([t0].[ProductModelID] = @p0) AND ([t0].[Name] = @p1)
</code></pre>
<p>というわけで、LINQ to SQLはand連結されますね。ここで注意なのが、どういう挙動を取るのかは全てクエリプロバイダの解釈次第です。例えば<a href="http://linqtotwitter.codeplex.com/">LINQ to Twitter</a>はwhere連打ではダメで、&amp;&amp;で連結しなければなりません。</p>
<h2>Reactive Extensionsの場合</h2>
<p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の場合も見てみましょうか。Rx-Main(1.0.11226)では、というと</p>
<pre><code class="language-csharp">var rx = Observable.Range(1, 10)
    .Where(x =&gt; x % 2 == 0)
    .Where(x =&gt; x % 3 == 0);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxstable.jpg">
</p>
<p>さっぱりワケワカメですが、とりあえずひとまとめになってないのでは感でしょうか。それにしても本当にワケワカメ。次にRx_Experimental-Main(1.1.11111)は、というと</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxexperimental.jpg">
</p>
<pre><code class="language-csharp">var pred = (Func&lt;int, bool&gt;)rx.GetType().GetField(&quot;_predicate&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(rx);

Console.WriteLine(pred(2)); // false
Console.WriteLine(pred(3)); // false
Console.WriteLine(pred(6)); // true
</code></pre>
<p>_predicate発見！Experimental版では挙動が改善され、ひとまとめにされているようです。IDisposable&lt;Generate&gt;は、Rangeの生成がGenerateメソッドによってなされているからですね。しかし、やはり読み取りにくい。</p>
<h2>Rx v2</h2>
<p>3/5に<a href="http://www.microsoft.com/download/en/details.aspx?id=29058">Reactive Extensions (Rx) v2.0 Beta</a>の配布がスタートしています。NuGetでは<a href="http://nuget.org/packages/Rx-Main">Install-Package Rx-Main -Pre</a>で配布されていますね。改善内容は後日詳しくということでまだ詳しくは出てないのですが、v2というだけあって中身はガラッと変わっています。とりあえず、見てみましょう。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqrxv2.jpg">
</p>
<p>もちろん、predicateはひとまとめにされているのですが、それだけじゃなくて、とにかく見やすい、分かりやすい。しかし、ところどころ変ですね、Observαble(aがアルファ)だのΩだの。v2はソースのキチガイ度が跳ね上がっているのでILSpyとかで覗いちゃえる人は一度見ちゃうといいと思います、頭おかしい。あと、C#でのプログラミング的な小技も効いてたりして、テクニックの学習にもとても良い。</p>
<h2>スタックトレースへの影響</h2>
<p>このコードのクリアさはスタックトレースにも良い影響を与えています。まず、Rx v1で見てみると</p>
<pre><code class="language-csharp">try
{
    Observable.Range(1, 10)
        .Where(x =&gt; x % 2 == 0)
        .Take(10)
        .Timestamp()
        .Subscribe(_ =&gt; { throw new Exception(); });
}
catch (Exception ex)
{
    Console.WriteLine(ex.StackTrace);
}
</code></pre>
<pre><code class="language-txt">場所 ConsoleApplication9.Program.&lt;Main&gt;b__1(Timestamped`1 _) 場所 c:\Users\ne
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.AnonymousObservable`1.AutoDetachObserver.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.Linq.Observable.&lt;&gt;c__DisplayClass408`2.&lt;&gt;c__DisplayClass40a.&lt;Select&gt;b__407(TSource x)
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.AnonymousObservable`1.AutoDetachObserver.Next(T value)
場所 System.Reactive.AbstractObserver`1.OnNext(T value)
場所 System.Reactive.Linq.Observable.&lt;&gt;c__DisplayClass43e`1.&lt;&gt;c__DisplayClass440.&lt;Take_&gt;b__43d(TSource x)
// 以下略
</code></pre>
<p>これは酷い。こんなの見ても何一つ分かりはしません。では、Rx v2で試してみると</p>
<pre><code class="language-txt">場所 ConsoleApplication10.Program.&lt;Main&gt;b__1(Timestamped`1 _) 場所 c:\Users\n
場所 System.Reactive.AnonymousObserver`1.Next(T value)
場所 System.Reactive.ObserverBase`1.OnNext(T value)
場所 System.Reactive.Linq.Observαble.Timestamp`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Take`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Where`1._.OnNext(TSource value)
場所 System.Reactive.Linq.Observαble.Range._.LoopRec(Int32 i, Action`1 recurse)
場所 System.Reactive.Concurrency.Scheduler.&lt;&gt;c__DisplayClass3a`1.&lt;InvokeRec1&gt;b__37(TState state1)
// 以下略
</code></pre>
<p>めっちゃよく分かる。Timestamp-&gt;Take-&gt;Where-&gt;Rangeという遡りがしっかり見える。何て素晴らしいんだ！</p>
<h2>匿名 vs 有名</h2>
<p>さて、どういうことかというと、これ、<a href="http://neue.cc/2010/07/05_265.html">neue cc - Rx(Reactive Extensions)を自前簡易再実装する</a>で紹介したような、ラムダ式をぶん投げてその場で匿名のクラスを作るAnonymousパターンをやめたんですね。で、代わりに名前付きのクラスを立ててる。だから分かりやすい。</p>
<p>これ、uupaaさんが仰ってる<a href="http://blog.7kai.org/2011/03/markdown-binder-js-navi/">ナビ子記法</a>←ググッた先の本人のスライドが、Handsoutがサービス終了で見れないので、紹介のある記事にリンクします-などにも近いところがあるかなあ、と。</p>
<p>ただやっぱ書くのにはコスト高というか匿名で書けることの良さを殺してしまうので、ライブラリサイドだったら検討する、アプリケーションサイドだったらやらない、になってしまうかなあ。ライブラリサイドであってもかなり手間なので、よほど余裕あるとかでないとやらない、かなあ。JavaScriptならともかくC#では、特に……。</p>
<h2>Rx v2についてもう少し</h2>
<p>詳しい話は詳細が出てから、と思いますが（と言いながらRxJSの話も結局書いてないので、あうあう）、とりあえずObservableへの拡張メソッド郡はExperimentalから変化は特にありません。ただ、Experimentalは既にStableとはかなり違っているので、Stableしか追っかけてない人は、かなり目新しいものを見かけることができると思います。</p>
<p>内部実装は見たとおりガラッと変わって、スタックトレースも見やすくなった、などなどなわけですが、それとあわせてパフォーマンスも相当上がっています。v1で基本的な部分を固めたので、v2ではそういった周辺部分に本気で取り組みだした、ということですね。</p>
<h2>まとめ</h2>
<p>LINQは細かいところまで配慮が行き届いていて本当に素晴らしいですね。というわけで平然とWhereの連打かましましょう。私もつい昨日にWhere6連打かましたりしてました。</p>
<p><a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>はさすがにここまではやってないんですが、いずれかはやりたいですね。その前にやらなきゃならないことがありすぎて当面はないですけれど。うーん、なんかもう色々やることありすぎて、かつそれなりに忙しくて、頭が爆発しそうです。はっきしいってヤバい。で、こうしてヤバくなると、硬直しちゃって余計に何もできなくなったり、唐突にこうして息抜き記事を書き出したり、うみみぅ。まあともかく、がんばろふ。</p>
</div>
<h1><a href="https://neue.cc/2012/02/23_366.html">とあるRoslynではないC# Parser、NRefactoryの紹介</a></h1>
<ul class="date"><li>2012-02-23</li></ul>
<div class="entry_body"><p>ﾛｯｽﾞﾘｰﾝ、はっじまらないよ～。というわけで<a href="http://msdn.microsoft.com/ja-jp/roslyn">Microsoft “Roslyn” CTP</a>、Compiler as a Service。<a href="http://nuget.org/packages/Roslyn">NuGet - Roslyn</a>でも手に入るので、サンプル類やC# Interactiveとかはなしで、とりあえずScriptingやCompilerを触ってみたい、ということなら、お手軽です。しかし、まあ未実装も少なくなく、まだまだ先は長そうな雰囲気ではある。今すぐ欲しいのに！切実にC# Parserが！というわけで、今日はその良き代替となる（かもしれない）<a href="https://github.com/icsharpcode/NRefactory">NRefactory</a>を紹介します。</p>
<p>NRefactoryは<a href="https://packages.nuget.org/packages/ICSharpCode.NRefactory/">NuGet - NRefactory</a>からも入ります。verは5.0.0.4、「This is an alpha release. Expect bugs and breaking changes in the future.」とのことで、こちらもまだまだこれからのよう(MonoDevelopの新しいC#エディタで使われる予定、だそうです)。とりあえずNuGetで参照してみませう。</p>
<p>参照するとMono.Cecilが入ったり名前空間にMono.CSharpがあったりと、全体的に<a href="http://www.mono-project.com/CSharp_Compiler">MonoのCSharp Compiler</a>やその周辺が使われているふいんき。Mono.CSharpは単体でもついこないだ<a href="https://nuget.org/packages/Mono.CSharp">NuGet - Mono.CSharp</a>で入れられるようになりましたが、そのまんまだと、なんというかどう使っていいか分からないというか、はいEvalできた、さて、はて？みたいになってしまって。そのへん、NRefactoryはゆるふわで、結構すぐに使い方分かります。とりあえず使ってみませう。</p>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Linq;
using ICSharpCode.NRefactory.CSharp;

class Program
{
    static void Main(string[] args)
    {
        var code = File.ReadAllText(@&quot;../../Program.cs&quot;);
        var parser = new CSharpParser();

        var root = parser.Parse(code, &quot;&quot;);

        var program = root.Descendants.OfType&lt;ICSharpCode.NRefactory.CSharp.TypeDeclaration&gt;().First();
        program.Name = &quot;Hogegram&quot;;

        Console.WriteLine(root.ToSourceString());
    }
}

public static class CompilationUnitExtensions
{
    static readonly CSharpFormattingOptions DefaultOptions = new CSharpFormattingOptions()
    {
        // TODO:130のboolを自分の気にいるようなOption（というかVSのデフォ）に近づける
    };

    public static string ToSourceString(this CompilationUnit compilationUnit, int indentation = 4, string indentationString = &quot; &quot;)
    {
        return ToSourceString(compilationUnit, DefaultOptions, indentation, indentationString);
    }

    public static string ToSourceString(this CompilationUnit compilationUnit, CSharpFormattingOptions options, int indentation = 4, string indentationString = &quot; &quot;)
    {
        using (var sw = new StringWriter())
        {
            var formatter = new TextWriterOutputFormatter(sw)
            {
                Indentation = indentation,
                IndentationString = indentationString
            };

            var visitor = new CSharpOutputVisitor(formatter, options);
            compilationUnit.AcceptVisitor(visitor);
            return sw.ToString();
        }
    }
}
</code></pre>
<p>Program.csを読み込んで、クラス名をHogegramに変更したのを出力する、というだけのものです。今のところ整形した文字列化にはCSharpOutputVisitorを作って、AcceptVisitorしなきゃならないようで面倒ぃので、とりあえず拡張メソッドにしました。デフォルトの整形オプションが気に食わないのですが、フォーマット設定が超細かくて100個以上のboolをON/OFFしなきゃいけないのでとりあえず放置。</p>
<p>構文木の取得自体は超単純で、new CSharpParser()してParse。そしてツリーを辿るのはLINQ to Xmlと同じ感覚でDescendantsやAncestors、Childrenなどなどが用意されているので、一発で分かりますね！そしてOfTypeで自分の欲しいのにフィルタリング、と。この辺は超簡単。そして名前を変えたければ、プロパティに代入するだけ。非常に楽ちんです、素晴らしい……！</p>
<h2>vs Roslyn</h2>
<p>さて、じゃあRoslynでも同じことをやってみましょう。</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Roslyn.Compilers.CSharp;

class Program
{
    static void Main(string[] args)
    {
        var code = File.ReadAllText(@&quot;../../Program.cs&quot;);
        var tree = SyntaxTree.ParseCompilationUnit(code);

        var program = tree.Root.DescendentNodes().OfType&lt;ClassDeclarationSyntax&gt;().First();

        var newNode = new ClassNameRewriter(new Dictionary&lt;ClassDeclarationSyntax, string&gt; { { program, &quot;Hogegram&quot; } })
            .Visit(tree.Root);

        Console.WriteLine(newNode.ToString());
    }
}

public class ClassNameRewriter : SyntaxRewriter
{
    readonly IDictionary&lt;ClassDeclarationSyntax, string&gt; replaceNames;

    public ClassNameRewriter(IDictionary&lt;ClassDeclarationSyntax, string&gt; replaceNames)
    {
        this.replaceNames = replaceNames;
    }

    protected override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        var oldIdentifierToken = node.Identifier;

        if (replaceNames.ContainsKey(node))
        {
            var newNode = node.Update(node.Attributes,
               node.Modifiers, node.Keyword,
               Syntax.Identifier(
                   oldIdentifierToken.LeadingTrivia,
                   replaceNames[node], // ここだけ！
                   oldIdentifierToken.TrailingTrivia),
               node.TypeParameterListOpt, node.BaseListOpt,
               node.ConstraintClauses, node.OpenBraceToken,
               node.Members, node.CloseBraceToken,
               node.SemicolonTokenOpt);

            return newNode;
        }
        else
        {
            return base.VisitClassDeclaration(node);
        }
    }
}
</code></pre>
<p>構文木の取得はこちらも簡単です、SyntaxTree.ParseCompilationUnitだけ。ツリーの辿り方も似ていて、DescendentNodes、ChildNodes、Ancestors、と、戸惑うことなく使える感じです。OfTypeでフィルタして絞り込みも同じ。書き換えたコードの出力は、こちらはToStringだけでOK、しかもフォーマットルールは何の設定もいらずVS標準と同じ状態になっているので楽ちん。</p>
<p>が、しかし、こちらはクラス名の書き換えが面倒。Expression Treeと同じく基本的にイミュータブルになっているので、書き換えはプロパティに代入するだけ、とはいかず、大掛かりな仕掛けが必要です。というかこの程度のためだけにVisitorとか……。一応ReplaceNodeとかUpdateとかもあるんですが、うーん、まあ、何というか、よくわかってないので深く突っ込まれると窮します:)</p>
<h2>まとめ</h2>
<p>提供する機能は同じでも、使い心地とかは、両者、結構違くなるのではという印象。どちらも発展途上なのですが、ライセンス的にRoslynは今は使えないのに比べると、NRefactoryはMITライセンスで、アルファ版なのを留意しておけば使えるのではというのが、私的には大きいかなあ。割と切迫してC# Parserが必要なところなので、ここはちょっとNRefactoryを使い込んでみたいなあ、なんて思っています。いや、そこまでDeepに使い倒すというより簡単なコード解析と置換程度なので、しっかり使ってバグ報告、とかの貢献は出来なさそうですんがー。</p>
</div>
<h1><a href="https://neue.cc/2012/02/18_365.html">ImplicitQueryString - 暗黙的変換を活用したC#用のクエリストリング変換ライブラリ</a></h1>
<ul class="date"><li>2012-02-18</li></ul>
<div class="entry_body"><ul>
<li><a href="http://implicitquerystring.codeplex.com/">ImplicitQueryString - CodePlex</a></li>
</ul>
<p>QueryStringかったるいですね、変換するのが。intに。boolに。それ以外に。そのままじゃどうしようもなくストレスフル。そこで、以下のように書けるライブラリを作りました。勿論<a href="http://nuget.org/packages/ImplicitQueryString">NuGet</a>でのインストールも可能です。あと、ライブラリといっても例によって.csファイル一個だけなので、導入は超お手軽。</p>
<p>以下はASP.NETの例ですが、NameValueCollectionを使っているものは全て対象になります。QueryStringだけじゃなくてRequest.Formなどにも使えますね。</p>
<pre><code class="language-csharp">// using Codeplex.Web;

int count;
string query;
bool? isOrdered; // support nullable

protected void Page_Load(object sender, EventArgs e)
{
    count = Request.QueryString.ParseValue(&quot;c&quot;);
    query = Request.QueryString.ParseValue(&quot;q&quot;);
    isOrdered = Request.QueryString.ParseValue(&quot;ord&quot;);
}
</code></pre>
<p>NameValueCollectionへの拡張メソッドとして実装しているので、using Codeplex.Webを忘れないように。ポイントは「型の明示が不要」というところです。クエリストリングを解析したい時って、通常はフィールドで既に変数自体は作っているのではないかと思います。なら、代入時に左から型を推論させてしまえばいいわけです、モダンなC#はわざわざ明示的に型なんて書かない、書きたくない。なのでこのライブラリ、ImplicitQueryStringではParseValueだけで全ての基本型(int, long, bool, string, DateTimeなど)へと型指定不要で代入可能となっています。代入先の型がNullableである場合は、キーが見つからなかったりパースに失敗した場合はnullにすることもサポートしてます。</p>
<p>また、よくあるクエリストリングはUrlEncodeされているのでデコードしたかったりするケースにも簡単に対応しています、UrlDecodeを渡すだけ！他にもEnumへの変換も出来ますし、キーが見つからなかったり変換不可能だったりした場合は指定したデフォルト値を返すParseValueOrDefault/ParseEnumOrDefaultも用意してあります。キーがあるかチェックするContainsKeyも。</p>
<pre><code class="language-csharp">enum Sex
{
    Unknown = 0, Male = 1, Female = 2
}

enum BloodType
{
    Unknown, A, B, AB, O
}

int age;
string name;
DateTime? requestTime;  // nullableやDateTimeもサポート
bool hasChild;
Sex sex;               // enumもいけます
BloodType bloodType;

protected void Page_Load(object sender, EventArgs e)
{
     // こんなQueryStringがあるとして
    // a=20&amp;n=John%3dJohn+Ab&amp;s=1&amp;bt=AB

    // ageは左から推論してintを返します
    age = Request.QueryString.ParseValue(&quot;a&quot;); // 20

    // UrlDecodeしたstringが欲しい時は第二引数にメソッドそのものを渡すだけ
    name = Request.QueryString.ParseValue(&quot;n&quot;, HttpUtility.UrlDecode); // John=John Ab

    // 代入先の型がnullableの場合は、もしキーが見つからなかったりパースに失敗したらnullにしてくれます
    requestTime = Request.QueryString.ParseValue(&quot;t&quot;, HttpUtility.UrlDecode); // null

    // キーが見つからなかったりパースに失敗したら指定した値を返してくれます
    hasChild = Request.QueryString.ParseValueOrDefault(&quot;cld&quot;, false); // false
    
    // Enumの変換は数字の場合でも文字列の場合でも、どちらでも変換可能です
    sex = Request.QueryString.ParseEnum&lt;Sex&gt;(&quot;s&quot;); // Sex.Male
    bloodType = Request.QueryString.ParseEnumOrDefault&lt;BloodType&gt;(&quot;bt&quot;, BloodType.Unknown); // BloodType.AB

    // ContainsKeyはキーの有無をチェックします
    var hasFlag = qs.ContainsKey(&quot;flg&quot;); // false
}
</code></pre>
<p>これで、あらゆるケースでサクッと変換することが可能なのではかと思います。ちなみに、ParseValue/ParseEnumでキーが見つからなかった場合はKeyNotFoundExceptionを返します。ParseValueで失敗したらFormatException、ParseEnumで失敗したらArgumentExceptionです。この二つが分かれているのは、int.Parseとかに渡しているだけなので、そちらの都合です。</p>
<h2>仕組み</h2>
<p>ImplicitQueryStringという名前がネタバレなのですが、単純に暗黙的変換をしているだけです。左から推論とか、ただのハッタリです。<a href="http://neue.cc/2012/02/14_364.html">neue cc - dynamicとQueryString、或いは無限に不確定なオプション引数について</a>を書いたときに、わざわざdynamicを持ち出さなくても、暗黙的変換で十分じゃないの？そのほうが利便性も上じゃないの？と思ったのでやってみたら、やはりドンピシャでした。</p>
<p>暗黙的変換は、あまり使う機能じゃあないと思いますし、実際、乱用すべきでない機能であることには違いないのですが、たまに活用する分には中々刺激的で創造性に満ちています。大昔からあるけれど普段使わない機能だなんて、ロストテクノロジーっぽくて浪漫に溢れています。</p>
<p>さて、ただし活用するにはコード中に型を並べなければならないので、汎用的というわけではないのもそうなのですが、人力で書くのもシンドイところ。勿論人力でやる気はしないので<a href="http://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Template</a>を使いました。</p>
<pre><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; #&gt;
&lt;#@ output extension=&quot;cs&quot; #&gt;
&lt;#@ assembly Name=&quot;System.Core.dll&quot; #&gt;
&lt;#@ import namespace=&quot;System&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text.RegularExpressions&quot; #&gt;
&lt;#@ import namespace=&quot;System.Reflection&quot; #&gt;
&lt;#
    var methods = typeof(Convert).GetMethods(BindingFlags.Static | BindingFlags.Public);

    var converters = methods.Where(x =&gt; x.Name.StartsWith(&quot;To&quot;))
        .Select(x =&gt; Regex.Replace(x.Name, &quot;^To&quot;, &quot;&quot;))
        .Where(x =&gt; !x.StartsWith(&quot;Base64&quot;) &amp;&amp; x != &quot;String&quot;)
        .Distinct()
        .ToArray();
#&gt;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;

namespace Codeplex.Web
{
    public static class NameValueCollectionExtensions
    {
        public static ConvertableString ParseValue(this NameValueCollection source, string key)
        {
            return ParseValue(source, key, null);
        }

        public static ConvertableString ParseValue(this NameValueCollection source, string key, Func&lt;string, string&gt; converter)
        {
            var values = source.GetValues(key);
            if (values == null) return new ConvertableString(null);

            var value = values[0];
            return new ConvertableString(converter == null ? value : converter(value));
        }
        
        // 中略
    }

    public struct ConvertableString
    {
        public readonly string Value;

        public ConvertableString(string value)
        {
            this.Value = value;
        }

&lt;# foreach (var converter in converters) { #&gt;
        public static implicit operator &lt;#= converter #&gt;(ConvertableString self)
        {
            if (self.Value == null) throw new KeyNotFoundException();
            return &lt;#= converter #&gt;.Parse(self.Value);
        }

        public static implicit operator &lt;#= converter #&gt;?(ConvertableString self)
        {
            &lt;#= converter #&gt; value;
            return (self.Value != null &amp;&amp; &lt;#= converter #&gt;.TryParse(self.Value, out value))
                ? new Nullable&lt;&lt;#= converter #&gt;&gt;(value)
                : null;
        }

&lt;# } #&gt;
        public static implicit operator String(ConvertableString self)
        {
            return self.Value;
        }

        public override string ToString()
        {
            return Value;
        }
    }
}
</code></pre>
<p>以上のコードから、T4生成部分を取り出すと</p>
<pre><code class="language-csharp">public static implicit operator Boolean(ConvertableString self)
{
    if (self.Value == null) throw new KeyNotFoundException();
    return Boolean.Parse(self.Value);
}

public static implicit operator Boolean?(ConvertableString self)
{
    Boolean value;
    return (self.Value != null &amp;&amp; Boolean.TryParse(self.Value, out value))
        ? new Nullable&lt;Boolean&gt;(value)
        : null;
}

public static implicit operator Char(ConvertableString self)
{
    if (self.Value == null) throw new KeyNotFoundException();
    return Char.Parse(self.Value);
}

public static implicit operator Char?(ConvertableString self)
{
    Char value;
    return (self.Value != null &amp;&amp; Char.TryParse(self.Value, out value))
        ? new Nullable&lt;Char&gt;(value)
        : null;
}

// 以下SByte, Byte, Int16, Int32, Int64, ..., DateTimeと繰り返し
</code></pre>
<p>といったコードがジェネレートされます。清々しいまでのゴリ押しっぷり。一周回ってむしろエレガント。ConvertableStringのほうでKeyNotFoundExceptionを出すのがイケてないのですが、まあそこはShoganaiかなー、ということで。さて、それはそれとして、やっぱVisual Studioに組み込みで、こういった自動生成のテンプレートエンジンが用意されているというのは非常に嬉しいところです。</p>
<h2>まとめ</h2>
<p>特にASP.NETを使っている方々にどうぞ。ASP.NET MVCの人はしらにゃい。なのでいつもの私だったら.NET 4.0専用にするところが、今回は.NET 3.5でも大丈夫！Visual Studio 2008でも動作確認取りました！</p>
<p>それにしても実際ASP.NETを使いこなしてる人はクエリストリングの取得はどんな風にやっていたものなのでしょうかー。何かしらの手法がないとシンドすぎやしませんか？そう思って検索してみたんですが、どうにも見つからず。さすがに ParseValueAsInt() とかって拡張メソッドぐらい作ってやり繰りは私も大昔していたし、それでintに対応しておけばほぼほぼOKではありますが（拡張メソッドがなかった時代はさすがに想像したくない！）。そう考えると、ちょっとこれはやりすぎ感も若干。でも、一度できあがればずっと使えますしね。というわけで<a href="http://implicitquerystring.codeplex.com/">ImplicitQueryString</a>、是非是非使ってみてください。本当に楽になれると思います。</p>
</div>
<h1><a href="https://neue.cc/2012/02/14_364.html">dynamicとQueryString、或いは無限に不確定なオプション引数について</a></h1>
<ul class="date"><li>2012-02-14</li></ul>
<div class="entry_body"><p>どうもこんばんわ、30時間も寝てないわー。まあ、お陰で真昼間の就業中にうつらうつらしてましたが！ちなみに<a href="http://www.jp.playstation.com/scej/title/gravitydaze/">GRAVITY DAZE</a>にはまって延々とプレイしてたから寝てないだけです。PS陣営にくだるなんて！さて、それはそれとしてBlog更新頻度の低下っぷりはお察し下さい。そんなこんなで最近の仕事（仕事ですって！仕事してるんですって！？）はASP.NETなんですが、色々アレですね。ふふふ。ソウルジェムは真っ黒と真っ白を行ったり来たりしてて楽しいです。まあ、ようするに楽しいです。楽しいのはいいとしてBlogが停滞するのはいくないので、電車でGRAVITY DAZEやりながらQueryStringうぜえええええ、とか悶々としたので帰り道に殺害する算段を整えていました。</p>
<p>QueryStringって、qとかnumとかiとかsとか、それそのものだけじゃ何を指してるかイミフなので、C#的にはちゃんと名前をつけてやりたいよね。だから、ただシンプルに触れるというだけじゃダメで。あと、コンバートもしたいよね。数字はintにしたいしboolは当然boolなわけで。さて、そんな時に私たちが持つツールと言ったら、dynamicです。C#とスキーマレスな世界を繋ぐ素敵な道具。今日も活躍してもらうことにしましょう。たまにしか出番ないですからね。</p>
<pre><code class="language-csharp">private int id;
private int? count;
private string keyword;
private bool isOrdered;

protected void Page_Load(object sender, EventArgs e)
{
    // id=10&amp;c=100&amp;q=hogehoge&amp;od=true というクエリストリングが来る場合

    // dynamicに変換！
    var query = this.Request.QueryString.AsDynamic();

    id = query.id; // キャストは不要、書くの楽ですね！(キーが存在しないと例外)
    count = query.c; // 型がnullableならば、存在しなければnull
    keyword = query.q; // stringの場合も存在しない場合はnull
    isOrdered = query.od(false); // メソッドのように値を渡すと、キーが存在しない場合のデフォルト値になる
}
</code></pre>
<p>ASP.NETの例ですが、どうでしょう、まぁまぁ良い感じじゃあなくて？ちなみに最初はnull合体演算子(??)を使いたかったのですが、DynamicObjectでラップした時点で、そもそも存在がnullじゃないということで、何をどうやってもうまく活用できなくて泣いた。しょうがないのでメソッド形式でデフォルト値を渡すことでそれっぽいような雰囲気に誤魔化すことにしました、とほほほ。</p>
<h2>dynamicとオプション引数</h2>
<p>クエリストリングを生成することも出来ます。</p>
<pre><code class="language-csharp">// 戻り値はdynamicで空のDynamicQueryStringを生成
var query = DynamicQueryString.Create();

// オプション引数の形式で書くと……？
query(id: 100, c: 100, q: &quot;hogehoge&quot;, od: true);

Console.WriteLine(query.ToString()); // id=10&amp;c=100&amp;q=hogehoge&amp;od=true
</code></pre>
<p>といった感じで、面白いのがオプション引数の使い方。匿名型渡しのように、スマートにKey:Valueを渡すことを実現しています。dynamicなので引数名は完全自由。個数も完全自由。非常にC#らしくなくC#らしいところが最高にCOOL。匿名型とどちらがいいの？というと何とも言えないところですが、面白いには違いないし、面白いは正義。C#も工夫次第でまだまだ色々なやり方が模索できるんですよー、ってところです。</p>
<h2>実装など</h2>
<p>眠いのでコードの解説はしません（ぉ。DynamicObjectの実装方法は<a href="http://neue.cc/2010/05/06_257.html">neue cc - C# DynamicObjectの基本と細かい部分について</a>でどーぞ。overrideしていくだけなので、別に難しくもなんともないので是非是非やってみてください。ちなみに無限のオプション引数を実現している箇所は binder.CallInfo.ArgumentNames.Zip(args, (key, value) =&gt; new { key, value }) です。</p>
<pre><code class="language-csharp">public static class NameValueCollectionExtensions
{
    public static dynamic AsDynamic(this NameValueCollection queryString)
    {
        return new DynamicQueryString(queryString);
    }
}

public class DynamicQueryString : DynamicObject
{
    NameValueCollection source;

    public DynamicQueryString()
    {
        this.source = new NameValueCollection();
    }

    public DynamicQueryString(NameValueCollection queryString)
    {
        this.source = queryString;
    }

    public static dynamic Create()
    {
        return new DynamicQueryString();
    }

    public override bool TryGetMember(GetMemberBinder binder, out object result)
    {
        var value = source[binder.Name];
        result = new StringMember((value == null) ? value : value.Split(',').FirstOrDefault());
        return true;
    }

    public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
    {
        foreach (var item in binder.CallInfo.ArgumentNames.Zip(args, (key, value) =&gt; new { key, value }))
        {
            source.Add(item.key, item.value.ToString());
        }

        result = this.ToString();
        return true;
    }

    public override bool TryConvert(ConvertBinder binder, out object result)
    {
        if (binder.Type != typeof(string))
        {
            result = null;
            return false;
        }
        else
        {
            result = this.ToString();
            return true;
        }
    }

    public override string ToString()
    {
        return string.Join(&quot;&amp;&quot;, source.Cast&lt;string&gt;().Select(key =&gt; key + &quot;=&quot; + source[key]));
    }

    public override IEnumerable&lt;string&gt; GetDynamicMemberNames()
    {
        return source.Cast&lt;string&gt;();
    }

    class StringMember : DynamicObject
    {
        readonly string value;

        public StringMember(string value)
        {
            this.value = value;
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            var defaultValue = args.First();

            try
            {
                result = (value == null)
                    ? defaultValue
                    : Convert.ChangeType(value, defaultValue.GetType());
            }
            catch (FormatException) // 真面目にやるならType.GetTypeCodeでTypeを分けて、例外キャッチじゃなくてTryParseのほうがいいかな？
            {
                result = defaultValue;
            }

            return true;
        }

        public override bool TryConvert(ConvertBinder binder, out object result)
        {
            try
            {
                var type = (binder.Type.IsGenericType &amp;&amp; binder.Type.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;))
                    ? binder.Type.GetGenericArguments().First()
                    : binder.Type;

                result = (value == null)
                    ? null
                    : Convert.ChangeType(value, binder.Type);
            }
            catch (FormatException)
            {
                result = null;
            }

            return true;
        }

        public override string ToString()
        {
            return value ?? &quot;&quot;;
        }
    }
}
</code></pre>
<p>コンバートに対応させるために、要素一つだけのDynamicObjectを中で用意しちゃってます。そこがポイント、といえばポイント、かしら。GetDynamicMemberNamesはデバッガの「動的ビュー」に表示されるので、Visual Studioに優しいコードを書くなら必須ですね。</p>
<h2>まとめ</h2>
<p>dynamicはC#と外の世界を繋ぐためのもの。今日もまた一つ繋いでしまった。それはともかくとして、一番最初、<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を実装した頃にも言ったのですが、dynamicはDSL的な側面もあって、普通に楽しめますので、ちょっと頭をひねって活用してみると、また一つ、素敵な世界が待っています。</p>
<p>今回はコード書くのに2時間、この記事を書くのに1時間、でしたー。</p>
</div>
<h1><a href="https://neue.cc/2012/01/17_363.html">C#のO/Rマッパーのパフォーマンス測定 Part2</a></h1>
<ul class="date"><li>2012-01-17</li></ul>
<div class="entry_body"><p>以前に<a href="http://neue.cc/2011/06/03_326.html">neue cc - C#のMicro-ORM(Dapper, Massive, PetaPoco)について</a>で計測したのですが、<a href="https://twitter.com/shibayan">@shibayan</a>先生が<a href="http://blogs.msdn.com/b/adonet/archive/2011/02/04/using-dbcontext-in-ef-feature-ctp5-part-10-raw-sql-queries.aspx">EF 4.1のDbContextのRaw SQL Queries</a>はどうなの？とTwitterで言ってたのを見かけたので、再度測ってみました。ていうか私はDbContextとObjectContextの違いすら分かってないんですが、DbContextは軽量な感じっぽいそうです、はい。</p>
<p>ベンチマークは前回と引き続き<a href="http://code.google.com/p/dapper-dot-net/">dapper-dot-net</a>のリポジトリにあるベンチを使用しました。それにEFのバージョンを4.2に上げて、DbContextのSqlQueryを追加。また、<a href="http://d.hatena.ne.jp/taedium/">id:taedium</a>さんの作られている<a href="http://soma.codeplex.com/">Soma</a>は最新バージョンの1.6にしておきました。そして私の作成しているMicro-ORMである<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>のベンチも引き続き載せています。Visual Studio 2005時代のデータアクセステクノロジである型付きDataSetも加えてあります。</p>
<blockquote>
<p>Mapper Query (non-buffered) took 55ms<br />
Dynamic Mapper Query (buffered) took 56ms<br />
Dynamic Mapper Query (non-buffered) took 56ms<br />
hand coded took 57ms<br />
<strong>DbExecutor ExecuteReader(Hand Coded) took 59ms</strong><br />
Dapper.Cotrib took 60ms<br />
OrmLite QueryById took 60ms<br />
<strong>DbExecutor Select took 60ms</strong><br />
Mapper Query (buffered) took 61ms<br />
PetaPoco (Fast) took 62ms<br />
PetaPoco (Normal) took 63ms<br />
<strong>DbExecutor SelectDynamic took 63ms</strong><br />
Dynamic Massive ORM Query took 64ms<br />
<strong>DbExecutor ExecuteReaderDynamic(Hand Coded) took 64ms</strong><br />
BLToolkit took 82ms<br />
Simple.Data took 87ms<br />
Linq 2 SQL Compiled took 96ms<br />
DataSet took 108ms<br />
SubSonic Coding Horror took 116ms<br />
Entity framework CompiledQuery took 120ms<br />
NHibernate SQL took 125ms<br />
NHibernate Session.Get took 128ms<br />
NHibernate HQL took 135ms<br />
Soma Find took 164ms<br />
NHibernate Criteria took 170ms<br />
Linq 2 SQL ExecuteQuery took 207ms<br />
Linq 2 SQL took 597ms<br />
NHibernate LINQ took 610ms<br />
Entity framework ExecuteStoreQuery took 634ms<br />
Entity framework DbContext SqlQuery took 670ms<br />
Entity framework ESQL took 725ms<br />
Entity framework took 900ms<br />
Entity framework No Tracking took 903ms<br />
SubSonic ActiveRecord.SingleOrDefault took 3736ms</p>
</blockquote>
<p>hand codedがExecuteReaderを手で回した手書き、「Mapper Query」はDapperのことです。複数種類があるのはオプション違い。DbExecutor(太字にしています)も同様に4種類で測っています。上位陣は何回も測ると適当に入れ替わりますし、速度的にも500回ブン回して数msとか、ほとんど誤差範囲でいいのではかと思います。</p>
<p>というわけで、ええと、EntityFrameworkの遅さが目立ちますね、CompiledQueryは割といいのですが、むしろそうしないと絶望的。特に、文字列で生SQLを書くはずのExecuteStoreQueryやSqlQueryがクソみたいに遅いのはどういうことなのかと問いつめたい。更に、軽量なはずのDbContextのSqlQueryよりもObjectContextのExecuteStoreQueryのほうが速いとか、頭痛くなります。オマケ機能だと思ってテキトーなのではかと思われる気がかなりします、MSもっと本気出せ。</p>
<p>DataSetが割と健闘しちゃってるのが、DataSet嫌いな私としては何とも言い難い感じです(笑)</p>
<p>まぁ、DbExecutorが速さと使い勝手を両立しているので、Micro-ORMでいいならDbExecutor使うといいですよ、はい。メンテしてないって？はい、そうですね……。割と真面目な話、色々機能拡張したいというかしなければならない必然性とかが迫っていたりしたりしなかったりするので、近いうちに再度動き出すつもりではいます。なので使ってみるといいと思います。</p>
</div>
<h1><a href="https://neue.cc/2012/01/16_362.html">XboxInfoTwit - ver.2.4.0.2</a></h1>
<ul class="date"><li>2012-01-16</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comがリニューアルしたので、それに対応しました。今回は3日ほど本気で気づいていなくて対応が遅れてごめんなさい。最近はコメントやリクエストも放置気味で、大変反省しています。転職して少し忙しくなって、あまり気が回らなくて、という言い訳カッコワルイ。もう少し頑張ります。例によって全くテストしてないので、こいつ放置気味だしどうせ反応してくれないしいいかー、とか思わず、どうか変なところあったら報告お願いいたします。</p>
<p>あ、あと、今回からエラー時に前回の状態をリセットしないように変更しました。どういうことかというと、何らかのエラー(Xbox.comが不調だったり←よくある、Twitterが不調だったり)によって状態がリセットされた結果として、Power Onの投稿が連投されたりしてナンジャコリャー、といったような状態になることが防げます。多分。恐らく。きっと。</p>
</div>
<a href="https://neue.cc/2012">Prev |</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
