<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2012-11</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2012/11/28_388.html">Chaining Assertion 1.7.0.1 - 値比較の追加</a></h1>
<ul class="date"><li>2012-11-28</li></ul>
<div class="entry_body"><p>EqualsやGetHashCodeをオーバーライドするかと言ったら、そういう目的があるなら当然するし、そうでないならしない。という極当たり前なところに落ち着いたりはする。目的ってどういう時かといったら、LINQでDistinctの対象にしたい時とかですかね、まあ、よーするに値で比較したい！時です、まんまですね。</p>
<p>なので、逆にそれ以外の用途であえてこれらをオーバーライドすることはないです。特にテストのためにオーバーライドというのは、はっきしいって、良くないって思ってます。Equalsというのはクラスとして非常に重要な意味のあるところなので、そこにテスト都合が混じりこむのはNGです。</p>
<p>でも、テスト都合で値で比較したかったりは割とあるんですよね。じゃあどうするかって、まあ、ふつーにアサート側で構造比較したほうがいいでしょ、テスト都合なんだから。QUnitなんてdeepEqualが基本で、それが存外使いイイんですよ。</p>
<p>と、いうよくわからない前振りですが、つまるところChaining Assertionに値で比較できるIsStructuralEqualを足しました。</p>
<ul>
<li><a href="http://chainingassertion.codeplex.com/">Chaining Assertion - CodePlex</a></li>
</ul>
<p>いやあ、一年ぶりの更新です！というか、もう一年前ですかー、早いものだ。もうAssert.ThatをDisるのも忘れてたぐらいに昔の話ですねー、あ、今も当然Assert.ThatとかFluent何ちゃらは嫌いですよ、と、それはさておき。かなり前の話なのでChaining Assertionについておさらい。メソッドチェーンな感じにさらさらっとAssertを書けるテスト補助ライブラリです。詳しくは<a href="http://neue.cc/2011/02/24_306.html">メソッドチェーン形式のテスト記述ライブラリ</a>という1.0出した時の説明をどうぞー。主にMSTestやNUnitに対応しています。勿論NuGetでも入りますのでChainingAssertionで検索を。</p>
<p>今回追加したのはIsStructuralEqual(もしくはIsNotStructuralEqual)で、構造を再帰的に辿って値としての一致で比較します。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
class MyClass
{
    public int IntProperty { get; set; }
    public string StrField;
    public int[] IntArray { get; set; }
    public SubMyClass Sub { get; set; }
}

class SubMyClass
{
    public DateTime Date { get; set; }
}


[TestMethod]
public void TestMethod1()
{
    var mc1 = new MyClass
    {
        IntProperty = 100,
        StrField = &quot;hoge&quot;,
        IntArray = new[] { 1, 2, 3, 4, 5 },
        Sub = new SubMyClass
        {
            Date = new DateTime(1999, 12, 31)
        }
    };

    var mc2 = new MyClass
    {
        IntProperty = 100,
        StrField = &quot;hoge&quot;,
        IntArray = new[] { 1, 2, 3, 4, 5 },
        Sub = new SubMyClass
        {
            Date = new DateTime(1999, 12, 31)
        }
    };

    mc1.IsNot(mc2); // mc1とmc2は全て同じ値ですが、参照比較では当然違います

    mc1.IsStructuralEqual(mc2); // IsStructuralEqualでは全てのプロパティを再帰的に辿って比較します
}
</code></pre>
<p>なんのかんので便利で使っちゃいますね、多用しちゃいますね、きっと。ちなみに、ただたんに値比較したいだけなら、JSONにでもDumpして、文字列一致取ればいいだけなんですけれど。自前で辿ることによって、誤った箇所へのメッセージは割と親切かな、と思います。あとIEquatableの扱いとか型の扱いとか、ただのDumpとは色々若干と違うので、まあ、こちらのほうが望ましい具合な結果が得られると思います。</p>
<pre><code class="language-csharp">var mc1 = new MyClass
{
    IntProperty = 100,
    StrField = &quot;hoge&quot;,
    IntArray = new[] { 1, 2, 3, 4, 5 },
    Sub = new SubMyClass
    {
        Date = new DateTime(1999, 12, 31)
    }
};

// 間違い探し！
var mc2 = new MyClass
{
    IntProperty = 100,
    StrField = &quot;hoge&quot;,
    IntArray = new[] { 1, 2, 3, 100, 5 }, // 4番目が違う
    Sub = new SubMyClass
    {
        Date = new DateTime(1999, 12, 31)
    }
};

// 以下のようなエラーメッセージが出ます
// is not structural equal, failed at MyClass.IntArray.[3], actual = 4 expected = 5
mc1.IsStructuralEqual(mc2);

// こんどはStrFieldが違う
var mc3 = new MyClass
{
    IntProperty = 100,
    StrField = &quot;hage&quot;,
    IntArray = new[] { 1, 2, 3, 4, 5 },
    Sub = new SubMyClass
    {
        Date = new DateTime(1999, 12, 31)
    }
};

// 以下のようなエラーメッセージが出ます
// is not structural equal, failed at MyClass.StrField, actual = hoge expected = hage
mc1.IsStructuralEqual(mc3);

</code></pre>
<p>割と十分、分かりやすい。かな？</p>
<p>コードは結構好き勝手感です。PropertyInfoとFieldInfoは共にMemberInfoを継承してるが、GetValueは同じメソッドシグネチャだけど、MemberInfoに定義されてるわけじゃなくてPropertyInfo, FieldInfoにそれぞれあるから共通でまとめられないよー→dynamicで受ければGetValue使えて大解決。とか、まあふつーのコードではやらないようなことも、UnitTest用だから若干の効率低下は無視でなんでもありで行くよ！というのが割と楽しいですね。</p>
<h2>その他</h2>
<p>ついでにjsakamotoさんからPull Request来ていたIsInstanceOfでメソッドチェーンできるようになったり(Pull Requestの放置に定評のある私です！というか初めてacceptしたわー)、IsTrueとIsFalseを足した(いやあ、Is(true)ってやっぱ面倒くさかったよ、あはは)りなどしました。</p>
<p>さて、お次はWinRT対応とWindows Phone 8対応を、といったところなのですが、それはそのうち近いうちに！WinRT対応はねえ、リフレクション回りがドサッと変わってるので面倒といえば面倒なんですよねえ。まあ、勉強のためのちょうどいい題材ではあるので、手を付けたいとは思ってるのですけれど。</p>
<p>あとね、正直NUnitはいいとしてもMbUnitやxUnit、SLやWP7に対応させるの超面倒くさい。やりすぎた。これのせいでちょっとした修正ですら大仕事なわけですよ。このメンテコスト最悪すぎる状態がどうにもねえ、それでいてNUnitはともかく、その他なんてほとんど使われてないですからねえ。分かってはいたのですが、こうシンドイと結構限界。というわけで、WP7とSilverlightは削除しました。この二つはもういらないぢゃん？さようなら……。</p>
<p>ああ、あとFakes FrameworkのためのVerifierも入れたいしねえ、やりたいことは割と多いんですが、ニートもこれはこれでいて忙しくて手が回らないのですよー。</p>
</div>
<h1><a href="https://neue.cc/2012/11/03_387.html">Microsoft Fakes Frameworkの使い方</a></h1>
<ul class="date"><li>2012-11-03</li></ul>
<div class="entry_body"><p>Fakes FrameworkはVisual Studio 2012から搭載されたユニットテスト用のもっきゅっきゅライブラリです。いや、ライブラリというには大掛かりなので、やっぱFrameworkでしょうか。ともあれ、そんなもののようなものです。ドトネトだと競合で最も有名なのは<a href="http://code.google.com/p/moq/">Moq</a>ですね。競合との大きな違いは、通常のもっきゅっきゅライブラリがinterfaceやvirtualなメソッド類しか上書きできないのに対して、FakesはStaticメソッドやふつーの非virtualメソッドすらも上書き出来ちゃうところにあります。つまり、なんでもできます。</p>
<p>そして、Visual Studio Ultimateじゃないと使えません。……うぉーん。と、いうわけで、強力さはよーく分かるんですが、Ultimateでしか使えないところに萎えていたりしました。が、Visual Studioへの要望を出すForumで<a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2919309-provide-microsoft-fakes-with-all-visual-studio-edi">Provide Microsoft Fakes with all Visual Studio editions</a>といった投票が以前からあり(私もVote済みです)、そこでついに最近、全エディションに搭載するよう検討するから待っててね！というMSからの返答が！やったね！あ、まだVoteしてない人はVoteしましょう。</p>
<p>さて、Fakesは元々Molesという名前で、PexというMicrosoft Researchで開発されていた（今はメンテされてるのかなあ、怪しいなあ）自動テストツールの付属品みたいな感じで存在していました。できることは、既存のクラスの静的/インスタンスメソッドやプロパティの動作を、自由に置き換えることです。もうこれ本当に素晴らしくて、一度使うとMoles抜きのテストとか考えられないぐらいで、このサイトでも<a href="http://neue.cc/2011/03/10_309.html">Rx + MolesによるC#での次世代非同期モックテスト考察</a>とか<a href="http://neue.cc/2011/12/21_360.html">RxとパフォーマンスとユニットテストとMoles再び</a>といった記事で紹介してきました。どちらもRxとセットで書いていますが、Moles自体は別にRx関係ありません。</p>
<p>ちなみに同様のことができるライブラリには<a href="http://www.typemock.com/isolator-product-page">Typemock Isolator</a>や<a href="http://www.telerik.com/products/mocking.aspx">Just Mock</a>がありますが、何れも有償です（結構お高い、まぁVisual Studio Ultimateほどではないですが！）。Fakesとそれら(やMoq)の違いはもうひとつあって、Fakesは自動生成が基盤になっているので、メソッドやプロパティの置き換えが同様の定義をラムダ式で渡すだけという、非常にスムーズなやりかたで済みます。他のものは、基本的にはSetUp.Returnsとか、流れるようなインターフェースが基調になっていて、そんな書きやすいわけではないんですね。機能が強力だという他に、モック定義が超簡単、というのもFakesの大きな魅力です。</p>
<h2>使い方</h2>
<p>詳細な使い方とかガイドは<a href="http://msdn.microsoft.com/en-us/library/hh549175.aspx">Isolating Code under Test with Microsoft Fakes</a>にありますが、まあ簡単に見てきましょうか。ユニットテストプロジェクトの参照設定でSystemを右クリックしてFakesアセンブリに追加をクリック。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/msfakes1.jpg">
</p>
<p>するとFakesフォルダの下にmscorlib.fakesとSystem.fakesが作られます。そして、暫く待つとmscorlib.4.0.0.0.FakesとSystem.4.0.0.0.Fakesが追加されます。これ、バックグラウンドに必死に解析しているといった感じなので、割と待たされます（せめてステータスバーで通知してくれてれば分かりやすいのですが）。すぐにFakesが追加されなくてオカシイなー、とかドーナッテンダー、とか思うかもですが、まあゆるりと待ちましょう。待つといっても1分は待たないかな、さすがに、マシン性能にもよるでしょうが。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/msfakes2.jpg">
</p>
<p>これでとりあえず準備完了。</p>
<p>一番単純かつよく使うかつ有意義かつそこらじゅーで紹介されている例としては、DateTime.Nowの差し替えなので、まずそれを見ますか、定番お馴染みですけれど。Assertには別ライブラリの<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>を使います。Assert.AreEqual(25, Math.Pow(5, 2))がMath.Pow(5, 2).Is(25)といったようにメソッドチェーンでサクッと書けて可読性良くて実にいい(宣伝)。</p>
<pre><code class="language-csharp">[TestClass]
public class UnitTest1
{
    [TestMethod]
    public void TestMethod1()
    {
        // Shim&quot;s&quot;Contextで囲むとその中でShim使える(Stubだけ利用なら不要)
        using (ShimsContext.Create())
        {
            // DateTime.Nowを1999年12月31日に差し替え！
            ShimDateTime.NowGet = () =&gt; new DateTime(1999, 12, 31);

            // なのでDateTime.Nowは1999年です！
            DateTime.Now.Year.Is(1999);
        }
    }
}
</code></pre>
<p>どーでもいーんですがShimContextと間違えて、でてこないなあ、と悩んだりはよくしてました。正しくはShimsContextですねん。ともあれ、超簡単に難問であるDateTimeの差し替えに成功しました！素晴らしい！</p>
<p>さて、もっきゅっきゅライブラリによくある機能はもう一つ、差し替えたメソッドが呼ばれたかどうかの検証があります。これに関してはFakesは特にライブラリ側でサポートはしていません。自前でやります。例えば……</p>
<pre><code class="language-csharp">var calledCount = 0;
var stub = new StubIEnumerable&lt;int&gt;
{
    GetEnumerator = () =&gt; { calledCount++; return Enumerable.Range(1, 10).GetEnumerator(); }
};

stub.Count().Is(10); // LINQのCountを使ってGetEnumeratorを呼んだ

calledCount.Is(1); // 1回呼ばれた、という検証
</code></pre>
<p>StubはふつーのMoqライブラリで定義可能なのと同じで、interfaceかvirtualなメソッドを置き換えられます。ラムダ式で定義出来るのが、やっぱ簡単でイイですね。で、検証のやり方は、単純に外部に変数定義してそれ呼んでやって、という地味ーで原始的な手法が正解。手間といえば手間ですが、Moq定義がシンプルなので、違和感は全然ないです。</p>
<h2>Verify用拡張の実装</h2>
<p>とはいえ、定形パターンでラムダの外に変数置いてどうこう、というのも面倒くさいので、Verify用にちょっと作ってみました。例えばこんな風に使います。</p>
<pre><code class="language-csharp">[TestMethod]
public void IListUseCountByLINQ()
{
    var enumerator = Verifier.Zero(&quot;IList.GetEnumerator&quot;); // 文字列入れておくとエラー時にどの検証で失敗したのか判別できる。
    var count = Verifier.Once(); // 省略も可能だけどエラー時に不明になるので、メソッド内で検証は一個ののみとか限定で。

    IEnumerable&lt;int&gt; list = new StubIList&lt;int&gt;()
    {
        // 各メソッド先頭でCalledを呼ぶと内部のカウンターがIncrementされる
        GetEnumerator = () =&gt; { enumerator.Called(); return Enumerable.Empty&lt;int&gt;().GetEnumerator(); },
        CountGet = () =&gt; { count.Called(); return 10; },
    };

    list.Count(); // LINQのCount()メソッドを使う

    Verifier.VerifyAll(count, enumerator); // Countは一度呼ばれてGetEnumeratorは一度も呼ばれてないことの検証実行
}
</code></pre>
<p>もしこれでvar enumerator = Verifier.Once(&quot;IList.GetEnumerator&quot;) にすると、VerifyAllのところで「System.Exception: Verify Error - Key:IList.GetEnumerator, Condition:(x == 1), CalledCount:0」という例外が発生して、実行されたかの検証が行える、みたいな感じですん。エラーメッセージもそこそこ親切。</p>
<p>ちょっと面倒かなあ、いちいち変数定義するのダルいなあ、とかとも思いますが、まあ何もないよりは良いのではないでしょうか。以下はその実装。</p>
<pre><code class="language-csharp">public class Verifier
{
    public static Verifier Zero(string key = &quot;&quot;)
    {
        return new Verifier(key, x =&gt; x == 0);
    }

    public static Verifier Once(string key = &quot;&quot;)
    {
        return new Verifier(key, x =&gt; x == 1);
    }

    public static Verifier Create(Expression&lt;Func&lt;int, bool&gt;&gt; condition)
    {
        return new Verifier(&quot;&quot;, condition);
    }

    public static Verifier Create(string key, Expression&lt;Func&lt;int, bool&gt;&gt; condition)
    {
        return new Verifier(key, condition);
    }

    public static void VerifyAll(params Verifier[] verifier)
    {
        foreach (var item in verifier)
        {
            item.Verify();
        }
    }

    readonly Expression&lt;Func&lt;int, bool&gt;&gt; condition;
    int count;
    public int Count { get { return count; } }
    public string Key { get; private set; }

    private Verifier(string key, Expression&lt;Func&lt;int, bool&gt;&gt; condition)
    {
        this.Key = key;
        this.count = 0;
        this.condition = condition;
    }

    public void Called()
    {
        Interlocked.Increment(ref count);
    }

    public void Verify()
    {
        if (!condition.Compile().Invoke(count))
        {
            var msg = string.Format(&quot;Key:{0}, Condition:{1}, CalledCount:{2}&quot;, Key, condition.Body, count);
            throw new Exception(&quot;Verify Error - &quot; + msg); // 例外は最終的に独自例外を使う
        }
    }
}
</code></pre>
<p>複数回呼ばれることの検証はVerifier.Create(x =&gt; x == 10)とかVerifier.Create(x =&gt; x &gt;= 1)とかって書きます。ここをTimes.ExactlyだのTimes.AtMostOnceだのTimes.Betweenだのとメソッド名でやりくりさせる流れるようなインターフェース(笑)的なやり方は嫌いですねえ（Timesは別に流れてませんが）。ラムダ式あるんだからそれ使うべきでしょ常識的に考えて。</p>
<p>これはただのコンセプトですが、もう少し練りこんだらChaining Assertionに入れましょう。</p>
<h2>WebRequestのShimを作りたい場合</h2>
<p>ところで、mscorlibとSystemのFakeが標準で作られるわけですが、それの中身、少ないですよね？WebClientはないし、WebRequestもStubばかりでShimがないし。どうなってるの？</p>
<p>mscorlibとSystemは巨大なライブラリなため、全てのFakeを作っていると量が膨大すぎて処理に時間がかかります。だから、デフォルトでは生成されるものが限定的になっています。じゃあどうすればいいのか、というと、.fakesの中身(XML)を編集して、明示的に生成するものを指定してあげれば解決します。</p>
<pre><code class="language-xml">&lt;Fakes xmlns=&quot;http://schemas.microsoft.com/fakes/2011/&quot;&gt;
    &lt;Assembly Name=&quot;System&quot; Version=&quot;4.0.0.0&quot;/&gt;
    &lt;ShimGeneration&gt;
        &lt;Add FullName=&quot;System.Net.HttpWebRequest&quot; /&gt;
    &lt;/ShimGeneration&gt;
&lt;/Fakes&gt;
</code></pre>
<p>Visual Studioで編集すればIntelliSenseが効くので、迷いなくできるでしょう。StubGenerationに対するオプションがあったり、Disableのtrue/falseが指定できたりとか、IntelliSenseに従うだけで発見できます。書き換えたらビルドすれば、設定の反映されたDLLに置き換えられます。もし置き換わらなかったら、テストプロジェクトのFakesAssembliesフォルダの中身を全部消して再ビルドしてみましょう。それでも追加されていなかったら、.fakesの書き換えミスでしょうね。私はFullNameとTypeNameを間違って追加されねー、と悩んだりしたことあります。</p>
<p>さて、じゃあ実際に↑のHttpWebRequestへのShimを使って、例えばHttpClientは最終的にWebRequestで実行されてるんだー、というのを検証するには……</p>
<pre><code class="language-csharp">// 非同期メソッドをテスト対象にする時はTaskを戻り値にする
[TestMethod]
public async Task HttpClientIsWrapperOfHttpWebRequest()
{
    using (ShimsContext.Create())
    {
        var v = Verifier.Once();

        // どこかで生成される全てのInstanceを対象にするには.AllInstances経由で
        // 第一引数はそのインスタンスそのものがくる
        ShimHttpWebRequest.AllInstances.BeginGetResponseAsyncCallbackObject = (instance, callback, state) =&gt;
        {
            v.Called();
            // ExecuteWithoutShimsで差し替えていないオリジナルのものを呼べる
            return ShimsContext.ExecuteWithoutShims(() =&gt; instance.BeginGetResponse(callback, state));
        };

        await new HttpClient().GetAsync(&quot;http://google.co.jp/&quot;);

        v.Verify();
    }
}
</code></pre>
<p>といったように書けました。ExecuteWithoutShimsとか、色々配慮されてて良い感じですねー。</p>
<p>ところでWebRequestは、IWebRequestCreateのStubを作ってWebRequest.RegisterPrefixにそれを登録するとWebRequest.Createは乗っ取ることが可能です、実は何気に。</p>
<pre><code class="language-csharp">var webreq = new StubIWebRequestCreate { CreateUri = uri =&gt; { /* hogemoge */ } };
WebRequest.RegisterPrefix(&quot;http://&quot;, webreq);
</code></pre>
<p>そして、これで実際WebClientのDownloadStringとかのWebRequest生成はフックできます。でも、これだと.NET 4.0から追加されたWebRequest.CreateHttpは乗っ取れないし、HttpClientにいたってはinternalなコンストラクタを使ってnew HttpWebRequestしているので、もはやそんな手法は実質完全無意味だ！ほんと、このあたりグダグダなので何も考えないほうがいいです。色々と幻想すぎる。</p>
<h2>Shim vs Stub</h2>
<p>vsというか、まずInterfaceはStubしか作れません。ある意味当たり前ですね。具象型は、Shimで作れば何でも差し替えられる、Stubで作るとvirtualなもののみ差し替えられる。具象型に関してはShimはStubの完全なる上位互換です。じゃあStub要らないのか、というと、割とそうでもなくて、Stubは軽量です。Shimは書き換えが入るので重たいです。このことはアプリケーションの設計全体に通しても言えて、Shimで何でも差し替えられるから、全面的にShimに頼ろう！みたいなのはダウトです。ダメ。それなりにテスタビリティを考慮した設計(= Stubで差し替え可能な状態)を作ったほうが良いです。</p>
<p>ただ、理想的な形がShimがゼロな状態でもテスタビリティ100%にすること、だとは私は思ってません。テスト可能にするために、ある程度、素直な設計を犠牲にして、歪んだ形になることって往々にあるはずです。そういうところは素直にShim使ったほうが100億倍良いでしょう。まあ、そのバランスに関しては答えなんてないので、各自で適宜、線を引いていくしかないかなーって思ってます。</p>
<p>あ、どうでもいいんですが、私はリポジトリパターンって嫌いで、いや、リポジトリパターンというか、ほぼほぼ100%テストのためだけにIHogeRepositryとHogeRepositryという実態作るとかIHogeとHogeImplが必ずといっていいほどセットなJxxxみたいじゃんというか、本当に嫌ですね！大嫌いですね！じゃあどうするかっつったら割とどうにもならないところもあるし、それをShimでサクッと殺すのがいいとは全然思いませんが、しかし私はShimで殺すことを選びますね。</p>
<h2>まとめ</h2>
<p>Fakes Frameworkは半端無く強力なので、とっとと全エディションに搭載されるといいなあ。Visual Studio 2012 SP1(いつ？)とかで、ね。いや、それじゃ遅すぎる、もっと早く！もっと早くに！Molesの頃はちょっと挙動に不安定さを感じた時もありましたが、さすがにプロダクト正式搭載なFakesは安定感もあってすっごくイイ。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
