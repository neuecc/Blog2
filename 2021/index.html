<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2021</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-twilight.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a></h1>
<ul class="date"><li>2021-11-21</li></ul>
<div class="entry_body"><p>見た目はほとんど変わっていませんが(とはいえ横幅広くしたので印象は結構変わったかも)、このサイト、フルリニューアルしました。内部構造が。完全に。別物に。元々はWordPressだったのですが、今回から自作の静的サイトジェネレーターでhtmlを生成し、GitHub Pagesでホストするようにしました。元になるソース(<code>.md</code>)もGitHub上に置き、GitHub ActionsでビルドしてGitHub Pagesでホスティングされるという、完全GitHub完結ソリューション。また、記事を書くエディタも<a href="https://docs.github.com/ja/codespaces/the-githubdev-web-based-editor">GitHub web-based editor</a>(リポジトリのトップで<code>.</code>を打つと、VS Codeそのものが起動するやつ)を利用することで、非常に快適で、というかMarkdownエディタとしては最高品質のものが乗っかっていて、たかがブログ書くにしては面倒くさいPush/Pullもなくダイレクトコミットで反映出来てしまうというのがとても良い体験になっています。</p>
<ul>
<li><a href="https://github.com/neuecc/Blog2/">neuecc/Blog2</a></li>
</ul>
<p><code>.</code>でエディタを起動して、<a href="https://github.com/neuecc/Blog2/tree/master/articles">articles</a>配下に<code>YYYY-MM-DD.md</code>ファイルを新規作成。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737666-ec09db39-d517-4fb9-aa9f-b61bfb2cbfe7.png" alt="image" /></p>
<p>完全にVS Codeそのものでデスクトップアプリのものと全く区別が付かないレベルで、これを超える品質のエディタを普通のサイトに乗せることは不可能でしょう。当然もちろん画像のプレビューもできますし、なんだったら拡張すら入る。</p>
<p>GitHub管理だと画像置き場（アップロード）が面倒くさい問題があるのですが、これはIssueを画像アップローダーとして使うことで回避しています。Issueの入力フォームは、画像をCtrl+Vでそのままアップロードが可能です。そして嬉しいことに、マークダウンに変換してくれているのでコピペするだけでOK。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736683-d2b2acac-8523-4f54-a325-c1dbb12aa959.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/46207/142736700-18928390-e53b-4014-a931-9cd974afcf56.png" alt="image" /></p>
<p>上がった先の<code>user-images.githubusercontent</code>は別にIssueそのものと紐付いているわけではないので、 アップローダ用に使ったIssueはSubmitすることなくポイ、です。そうしてどこにも紐付いていない<code>user-images.githubusercontent</code>ですが、別にだからといって削除されることもなく永続的に上がり続けているので、遠慮なく使わせてもらうことにします。まぁちゃんとGitHub上に上げてるコンテンツ用に使っているので、許されるでしょう、きっと。多分。</p>
<p>そうして出来上がった記事は、そのままエディタ上のgit UIからコミットすると、自身が作業している領域は直接サーバー上のmaster(main)なので、プッシュ不要で反映されます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png" alt="image" /></p>
<p>こうなると、もうWordPressで投稿をポスト、するのと変わらないわけです。ブログ記事程度でcloneしてpullしてstagingしてpushしてというのは地味に重たいので、このぐらい身軽で行きたいですね。（実際、投稿後に編集ラッシュとかよくあるので、ちょっと手数が増えるだけで猛烈に嫌気がさす）</p>
<p>ジェネレートは<a href="https://github.com/neuecc/Blog2/blob/master/.github/workflows/build.yml">workflows/buildy.yml</a>で、このリポジトリ内に配置されてるC#プロジェクトを直接ビルド/実行することで生成処理をしています。<code>dotnet run</code>便利。</p>
<pre><code class="language-yaml">build-blog:
runs-on: ubuntu-latest
steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.x
    - run: dotnet run --project ./src/Blog2/Blog2.csproj -c Release -- ./articles ./publish
    - uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./publish
        keep_files: true
</code></pre>
<p>生成されたファイルは<a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a>を使って<code>gh-pages</code>ブランチと同期します。その際、デフォルトでは既に上がってるファイルを全削除してしまうので、今回はstyleやassetを、同期とは別に置いてあるので削除されると困るので、<code>keep_files: true</code>も指定しています。そうすると記事の削除がしづらくなるんですが、記事の削除はしない or どうしても削除しなかったら二重に(articlesとgh-pages)削除すればいいだけ、という運用で回避。</p>
<p>と、いうわけでシステム的には満足です。</p>
<p>C#でも<a href="https://www.statiq.dev/">Statiq</a>などといった静的サイトジェネレーターは存在するのですが、あえて自作した理由は、サイトのシステムをそっくり移行するという都合上、URLを前のものと完璧に合わせたかったというのがあります。<a href="https://github.com/neuecc/Blog2/tree/gh-pages">生成結果のファイル一覧</a>が若干変というかクドいというか、といったところがあるのですが、これは前のWordPressでやっていたルーティングをそのまんま再現するためということで。WordPressからのエクスポートも、DB直接見てC#でそのままテーブルダンプから作ったので、まぁ別に大したコードが必要なわけでもないので一気に作っちゃえという気になったというのもあります。</p>
<p>外部ライブラリとしてはMarkdownのHTML化に<a href="https://github.com/xoofx/markdig">Markdig</a>を採用しました。色々高機能ではあるのですが、今回は <code>Markdown.ToHtml(input)</code> しか使っていませんけれど、感触的にはとても良かったです。</p>
<p>シンタックスハイライトには<a href="https://prismjs.com/">Prism.js</a>を用いました。Markdigの出力する```csharpの変換を、特に何も意識せずとも対象にしてくれるのが良かったですね。プラグインはautoloaderとnormalize-whitespaceを合わせて投下しています。</p>
<pre><code class="language-html">&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js&quot;&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js&quot;&quot;&gt;&lt;/script&gt;
</code></pre>
<h2>まとめ</h2>
<p>最近ブログ投稿がだいぶ減ってしまっていたのですが、システムも一新したことでやる気が出てきたのでいいことです。まぁ見た目は本当にあんま全然変わってないんですが……！</p>
<p>なお、反映に必要な所要時間は30秒弱。</p>
<p><img src="https://user-images.githubusercontent.com/46207/142737556-eac40d7a-46c8-4534-96de-38895104d4cb.png" alt="image" /></p>
<p>遅いっちゃあ遅いですが、許容できるといえば許容できますね。サイトジェネレートプログラムの実行時間自体は1秒以下で、別に全然時間かかってないんで、CIセットアップとか、それ以外の時間が何かとかかっちゃってます。GitHub Actionsの仕組み的にしょうがないといえばしょうがないんですが、もう少しなんとかなってほしいかなあ。あとGitHub Pages自体が反映が若干遅い。遅い上に進捗が分からないのが地味にストレスフル。とはいえとはいえ、良いんじゃあないでしょうか。良さの殆どはGitHub web-based editorから来てますね、これは本当に革命的に良い。というわけで、このweb-based editorを活かすシステムを作っていくという手段と目的を逆転させた思考が最終的に実際良いんじゃないかと思ってます！</p>
</div>
<h1><a href="https://neue.cc/2021/08/23_602.html">C#でgoogle/zx風にシェルスクリプトを書く</a></h1>
<ul class="date"><li>2021-08-23</li></ul>
<div class="entry_body"><p>あまりシェルスクリプトを書かない私なのですが（小物でもなんでも書き捨てC#で書くスタイル）、CI だの .NET Core だのなんなので、全く書かないというわけにもいかない昨今です。まぁしかしcmdは嫌だし今更(？)PowerShellもなぁという感じもあり、bashねぇ、とかブツブツ言いながらしょっぱいスクリプトを書く羽目になるわけです。</p>
<p>そこに颯爽と現れたのが <a href="https://github.com/google/zx">google/zx</a>。素敵そうだなーと思いつつJavaScriptを日常的に書くわけでもないのでスルーしてたのですが、こないだも<a href="https://scrapbox.io/lacolaco-engineering/%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E8%A4%87%E9%9B%91%E3%81%AA%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92JavaScript%E3%81%A7%E6%9B%B8%E3%81%8F">ちょっと複雑なシェルスクリプトをJavaScriptで書く</a>で紹介されていて、なるほど色物じゃなくて便利なのか、そうだよね便利だよね！と思い、私は日常的にC#を書くので、C#だったら便利だな、同じ感じで書けるなら、と、思い至ったのでした。</p>
<p>というかまぁzx見て思ったのが、これぐらいの内部DSL、C#でもいけるよ、ということであり……。そして以下のようなものが誕生しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/130373766-0f16e9ad-57ba-446b-81ee-c255c7149035.png" alt="image" /></p>
<p>もともと<a href="http://neue.cc/2020/01/30_590.html">ProcessX - C#でProcessを C# 8.0非同期ストリームで簡単に扱うライブラリ</a>というものを公開していたので、更にそれをDSL風味に、zxっぽくシンタックスを弄りました。C# 5.0 async/awaitの拡張性、C# 6.0 using static、C# 6.0 String Interpolation、そしてC# 9.0のTop level statementsと、C#も内部DSLを容易にする構文がどんどん足されています。現在previewのC# 10.0でも、Improvement Interpolated Stringsとして、InterpolatedStringHandlerによって$&quot;&quot;の生成時の挙動そのものを生で弄ることが可能になり、よりますます表現のハックが可能になり、色々と期待が持てます。</p>
<p>さて、で、これが使いやすいかというと、見た通りで、使いやすい、です……！stringをawaitしていることに一瞬違和感はめちゃくちゃあるでしょうが、DSLだと思って慣れれば全然自然です（そうか？）。なんか言われてもgoogle/zxなもんです、で逃げれば説得力マシマシになった（そうか？）のが最高ですね。cmd/PowerShell/bashに対する利点は、google/zxの利点と同じように</p>
<ul>
<li>型が効いてる(C#なので)</li>
<li>async/awaitが便利(C#なので)</li>
<li>フォーマッタもある(C#なので)</li>
<li>エディタ支援が最高(C#なので)</li>
</ul>
<p>ということで、ぜひぜひお試しください。</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">https://github.com/Cysharp/ProcessX</a></li>
<li>PM&gt; Install-Package ProcessX</li>
</ul>
<h2>csx vs new csproj vs ConsoleAppFramework</h2>
<p>C#には.csxという失われしC#スクリプティングな構文が用意されていて、まさに1ファイルでC#の実行が完結するのでこうしたシェルスクリプト風味に最適、と思いきや、実行もエディッティング環境も貧弱で、まさに失われしテクノロジーになっているので、見なかったことにしておきましょう。実際、より良いC#スクリプティング的なシンプルC#の提案が <a href="https://github.com/dotnet/designs/pull/213">Add Simple C# Programs</a> として出ています(つまりcsxは完全に産廃、NO FUTURE……)。提案(<a href="https://github.com/dotnet/designs/blob/a27fd42a68370f315bc2293dc748145f4075697f/proposed/simple-csharp-programs.md">proposed/simple-csharp-pgorams.md</a>)読むと面白いですが、ちょっと少し時間かかりそうですね。</p>
<p>というわけで、csprojとProgram.csの2ファイル構成が良いんじゃないかと思います。ちょっと冗長ではあるけれど、しょーがないね。実行に関しては dotnet run でビルドと実行がその場でできるので、ビルドなしの直接スクリプト実行みたいな雰囲気にはできます。これは普通に便利で、CIとかでもgit pullしている状態のリポジトリ内のスクリプトに対して一行でdotnet run書くだけで動かせるので、非常に良い。こうした .NET Core以降のシンプルになったcsprojとdotnetコマンドの充実から、csxの価値がどんどん消えていったんですねえ。</p>
<p>さて、実際のプロジェクトなどでは、そもそもシェルスクリプト（に限らずバッチなんかも）は一つどころか大量にあったりすることもあるでしょう。そこでCysharpの提供している<a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a>を使うと、クラスを定義するだけで簡単に実行対象を増やしていけるので、大量のスクリプトの管理を1csprojでまかなうことが可能になります。実行は dotnet run -- foo/bar のようにすればいいだけです。非常におすすめ。シェルスクリプト的なものは、ConsoleAppFramework + ProcessX/zx で書いて回るのは、悪くない選択になると思います。</p>
</div>
<h1><a href="https://neue.cc/2021/07/02_601.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2021-07-02</li></ul>
<div class="entry_body"><p>11回目。一年ごとに再審査があって7月に一斉更新されるシステムになっていて、今年も継続しました。</p>
<p><a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C#</a>はprotobuf-netを抜いて、 .NET で最もGitHubのスター数の多いバイナリシリアライザになりそうな感じです（今はまだちょっと負けてるので、勢い的に8月か9月ぐらいには）。まぁ、たった3000ちょいがMost StarsというC#の狭さみたいなところがなきにしもあらずではありますが(JavaScriptだと桁が違うからなあ）、.NET の存在感というのは決して劣ってはいないと思います。</p>
<p>MessagePack for C#は<a href="https://github.com/neuecc/MessagePack-CSharp/pull/1272">v3を計画</a>しています。パフォーマンスの大幅な向上（特にUnityで！）や、より良い使い勝手、ゼロアロケーションを超えたゼロコピー、SourceGenerator対応によるAOT対応の強化などなどを、破壊的変更も含めた上で考えてます。改めて、 .NET 6時代の最高のシリアライザを目指しています。</p>
<p><a href="https://github.com/Cysharp">GitHub/Cysharp</a>で公開しているものも、新規には <a href="https://github.com/Cysharp/MessagePipe">MessagePipe</a>は結構良いと思いますし、引き続き <a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>や<a href="https://github.com/Cysharp/UniTask">UniTask</a>は開発進めています。</p>
<p>つまり全体的にとてもC#に貢献している。なるほどえらい。そりゃ更新も当然ですね（</p>
<p>今年は会社として、今ひとつ大きなプロダクトを仕込んでいる最中でして、それで大きなインパクトを Unity と .NET 、双方で引き起こせるはず、です……！乞うご期待。</p>
<p>というわけかで引き続きC#の最前線で戦っていきますので、今年もよろしくおねがいします。</p>
</div>
<h1><a href="https://neue.cc/2021/05/08_600.html">2021年のC# Roslyn Analyzerの開発手法、或いはUnityでの利用法</a></h1>
<ul class="date"><li>2021-05-08</li></ul>
<div class="entry_body"><p>C#のAnalyzer、.NET 5時代の現在では標準でも幾つか入ってきたり、<a href="https://github.com/dotnet/roslyn-analyzers">dotnet/roslyn-analyzers</a>として準標準なものも整備されてきたり（非同期関連だと他に<a href="https://github.com/microsoft/vs-threading/blob/main/doc/analyzers/index.md">microsoft/vs-threading</a>のAnalyzerも便利)、<a href="https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html">Unity 2020.2からはUnityもAnalyzer対応したり</a>、MicrosoftもUnity向けの<a href="https://github.com/microsoft/Microsoft.Unity.Analyzers">microsoft/Microsoft.Unity.Analyzers</a>という便利Analyzerが登場してきたりと、特に意識せずとも自然に使い始めている感じになってきました。</p>
<p>Analyzerって何？というと、まぁlintです。lintなのですが、Roslyn(C#で書かれたC# Compiler)から抽象構文木を取り出せるので、それによってユーザーが自由にルールを作って、警告にしたりエラーにしたりできる、というのがミソです。更に高度な機能として、CodeFix(コードを任意に修正)もついているのですが、それはそれとして。</p>
<p>このサイトでも幾つか書いてきましたが、初出の2014年-2015年辺りに固まってますね。もう6年前！</p>
<ul>
<li><a href="http://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a></li>
<li><a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a></li>
<li><a href="http://neue.cc/2015/05/11_512.html">UniRxでの空呼び出し検出、或いはRoslynによるCode Aware Libraries時代の到来について</a></li>
<li><a href="http://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a></li>
</ul>
<p>実用的という点では、<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>に同梱しているMessagePackAnalyzerは今も現役でしっかり便利に使える代物になっています。</p>
<p>と、いうわけで使う分にはいい感じになってきた、のですが、作る側はそうでもありません。初出の2015年辺りからテンプレートは変わってなくて、NuGetからすんなり入れれる時代になっても、VSIXがついてくるようなヘヴィなテンプレート。このクロスプラットフォームの時代に.NET Frameworkべったり、Visual Studioベッタリって……。Analyzerと似たようなシステムを使うSource Generator(<a href="http://neue.cc/2020/12/15_597.html">UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips
</a>)は、まぁまぁ今風のそこそこ作りやすい環境になってきたのに、Analyzerは取り残されている雰囲気があります。</p>
<p>AnalyzerはCodeFixまで作ると非常に面倒なのですが、Analyzer単体でも非常に有益なんですよね。そしてプロジェクト固有の柔軟なエラー処理というのは、あって然りであり、もっとカジュアルに作れるべきなのです。が、もはや私でも腰が重くなってしまうぐらいに、2021年に作りたくないVisual Studio 2019のAnalyzerテンプレート……。</p>
<p>どうしたものかなー、と思っていたのですが、非常に良い記事を見つけました、2つ！</p>
<ul>
<li><a href="https://qiita.com/ryuix/items/36dabbf3c7e4e395e49e">SourceGeneratorのデバッグ</a></li>
<li><a href="https://zenn.dev/naminodarie/articles/32973a36fcbe99">【C#】アナライザー・ソースジェネレーター開発のポイント</a></li>
</ul>
<p>前者の記事ではVS2019 16.10 preview2で ソースジェネレーターのデバッガーサポートが追加された、 <code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code> とすればいい。という話。なるほどめっちゃ便利そう、でもソースジェネレーターばっか便利になってくのはいいんですがAnalyzer置いてきぼりですかぁ？と思ったんですが、 <code>IsRoslynComponent</code> だし、なんか挙動的にも別にAnalyzerで動いても良さそうな雰囲気を醸し出してる。と、いうわけで試してみたら無事動いた！最高！VS2019 16.10はまだpreviewですが(現時点では16.9が安定版の最新)、これはもうこれだけでpreview入れる価値ありますよ（あと少し待てば普通に正式版になると思うので待っても別にいいですが）</p>
<p>後者の記事は .NET 5 時代のすっきりしたAnalyzerのcsprojの書き方を解説されています。つまり、この2つを合体させればシンプルにAnalyzerを開発できますね……？</p>
<p>というわけでやっていきましょう。中身は本当に上記2つの記事そのものなので、そちらのほうも参照してください。</p>
<h2>SuperSimpleAnalyzerをシンプル構成で作る</h2>
<p>まずは Visual Studio 2019 16.10 をインストールします。16.10はついこないだ正式版になったばかりなので、バージョンを確認して16.10未満の場合はアップデートしておきましょう。</p>
<p>Analyzerはnetstarndard2.0、Analyzerを参照するテスト用のConsoleAppプロジェクトをnet5.0で作成します。最終的には以下のようなソリューション構造にします。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117477060-7c494b00-af98-11eb-8b45-b52734713821.png" alt="image" /></p>
<p>さて、ではSuperSimpleAnalyzerのほうのcsprojをコピペ的に以下のものにしましょう。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;library&lt;/OutputType&gt;
        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
        &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;
        &lt;TargetsForTfmSpecificContentInPackage&gt;$(TargetsForTfmSpecificContentInPackage);PackBuildOutputs&lt;/TargetsForTfmSpecificContentInPackage&gt;
        &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
        &lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;
        &lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
        &lt;DevelopmentDependency&gt;true&lt;/DevelopmentDependency&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.2&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; /&gt;
    &lt;/ItemGroup&gt;

    &lt;Target Name=&quot;PackBuildOutputs&quot; DependsOnTargets=&quot;SatelliteDllsProjectOutputGroup;DebugSymbolsProjectOutputGroup&quot;&gt;
        &lt;ItemGroup&gt;
            &lt;TfmSpecificPackageFile Include=&quot;$(TargetDir)\*.dll&quot; PackagePath=&quot;analyzers\dotnet\cs&quot; /&gt;
            &lt;TfmSpecificPackageFile Include=&quot;@(SatelliteDllsProjectOutputGroupOutput-&gt;'%(FinalOutputPath)')&quot; PackagePath=&quot;analyzers\dotnet\cs\%(SatelliteDllsProjectOutputGroupOutput.Culture)\&quot; /&gt;
        &lt;/ItemGroup&gt;
    &lt;/Target&gt;
&lt;/Project&gt;
</code></pre>
<p>基本的に<a href="https://zenn.dev/naminodarie/articles/32973a36fcbe99">【C#】アナライザー・ソースジェネレーター開発のポイント</a>から丸コピペさせてもらっちゃっているので、それぞれの詳しい説明は参照先記事に譲ります……！幾つか重要な点を出すと、<code>Microsoft.CodeAnalysis.CSharp</code>のバージョンは新しすぎると詰みます。現在の最新は3.9.0ですが、3.9.0だと、今の正式版VS2019(16.9)だと動かない(動かなかったです、私の環境では、どうなんですかね？)ので、ちょっと古めの3.8.0にしておきます。</p>
<p>もう一つは、件の <code>&lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;</code> の追加です。</p>
<p>では、次にConsoleApp.csprojのほうに行きましょう。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;ProjectReference Include=&quot;..\AnalyzerDemo\SuperSimpleAnalyzer.csproj&quot;&gt;
            &lt;ReferenceOutputAssembly&gt;false&lt;/ReferenceOutputAssembly&gt;
            &lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;
        &lt;/ProjectReference&gt;
    &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>こちらは別に特段変わったことなく、Analyzerのcsprojを参照するだけです。その際に <code>&lt;OutputItemType&gt;Analyzer&lt;/OutputItemType&gt;</code>を欠かさずに。</p>
<p>では再び SuperSimpleAnalyzer に戻って、プロパティ→デバッグから、「起動」をRoslyn Componentに変更すると以下のような形にできます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478072-ab13f100-af99-11eb-9904-f7fae1b899a7.png" alt="image" /></p>
<p>（この時、Target Projectが真っ白で何も選択できなかったら、ConsoleAppのほうでAnalyzer参照をしてるか確認の後、とりあえずVisual Studioを再起動しましょう）</p>
<p>これで、SuperSimpleAnalyzerをF5するとAnalyzerがConsoleAppで動いてる状態でデバッガがアタッチされます！</p>
<p>のですが、最後にじゃあそのAnalyzerの実体をコピペできるように置いておきます。</p>
<pre><code class="language-csharp">#pragma warning disable RS2008

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Linq;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class SuperSimpleAnalyzer : DiagnosticAnalyzer
{
    // どうせローカライズなんてしないのでString直書きしてやりましょう
    private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(
        id: &quot;SuperSimpleAnalyzer&quot;,
        title: &quot;SuperSimpleAnalyzer&quot;,
        messageFormat: &quot;MyMessageFormat&quot;,
        category: &quot;Naming&quot;,
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: &quot;Nanika suru.&quot;);

    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }
    
    public override void Initialize(AnalysisContext context)
    {
        // お約束。
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // 解析起動させたい部分を選ぶ。あとRegisterなんとかかんとかの種類は他にもいっぱいある。
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
    }

    private static void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        // ここを適当に書き換える（これはサンプル通りの全部Lowerじゃないクラス名があった場合に警告を出す）
        var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

        if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
        {
            // Diagnosticを作ってReportDiagnosticに詰める。
            var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
</code></pre>
<p>Resourcesとか別に使う必要ないと思うので、ハイパーベタ書きの.csファイル一個に収めてあります。これでF5をすると……</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478737-7d7b7780-af9a-11eb-95cd-f1d970d2c22d.png" alt="image" /></p>
<p>もちろんConsoleAppのほうでは、実際に動いて警告出している様が確認できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117478595-558c1400-af9a-11eb-9516-47295823423c.png" alt="image" /></p>
<p>昔のVSIXの時は、別のVisual Studioを起動させていたりしたので重たくて面倒くさかったのですが、今回の IsRoslynComponent では、普通のデバッグの感覚で実行できるので、めちゃくちゃ楽です。最高に書きやすい、これが2021年……！</p>
<h2>ユニットテストもする</h2>
<p>ユニットテストのいいところは、テストをデバッグ実行すればコードの中身をダイレクトにステップ実行できるところにもあります。ある程度、上のように実コードでデバッグ実行して雰囲気を作れた後は、ユニットテスト上で再現コードを作っていくと、より捗るでしょう。</p>
<p>基本的にはxUnitのテンプレートでプロジェクトを作って、 <code>Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit</code> を参照に追加するだけ。ではあるのですが、net5でシンプルに作ったら連なってる依存関係のせいなのか .NET Frameworkのものの参照が入って警告されたりで鬱陶しいことになったので、とりあえず以下のが警告の出ないパターン（？）で作ったものになります。netcoreapp3.1で。</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
        &lt;IsPackable&gt;false&lt;/IsPackable&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.2&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; /&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;3.8.0&quot; /&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit&quot; Version=&quot;1.1.0&quot; /&gt;

        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;16.9.4&quot; /&gt;
        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.1&quot; /&gt;
        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.3&quot;&gt;
            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
        &lt;/PackageReference&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>このプロジェクトに作ったAnalyzerの参照を足して、以下のようなテストコードを書きます。</p>
<pre><code class="language-csharp">        [Fact]
        public async Task SimpleTest2()
        {
            var testCode = @&quot;
class Program
{
    static void Main()
    {
    }
}&quot;;

            await Microsoft.CodeAnalysis.CSharp.Testing.XUnit.AnalyzerVerifier&lt;SuperSimpleAnalyzer&gt;
                .VerifyAnalyzerAsync(testCode, new DiagnosticResult(&quot;SuperSimpleAnalyzer&quot;, DiagnosticSeverity.Warning).WithSpan(0, 0, 0, 0));
        }
</code></pre>
<p>やることはVerifyAnalyzerAsyncに、それによって発生するエラー部分をDianogsticResultで指定する、という感じです。</p>
<p>シンプルなケースはそれでいいのですが、テストコードにNuGetで外部ライブラリ参照があったり、プロジェクト参照があったりすると、これだけだとテストできません。そこで、そうしたケースが必要な場合は CSharpAnalyzerTest に追加の参照関係を指定してあげる必要があります( XUnit.AnalyzerVerifier は CSharpAnalyzerTest をxUnitのシンプルなケースに特化してラップしただけのものです）。</p>
<p>例えば<a href="https://github.com/Cysharp/MessagePipe/">MessagePipe</a>では以下のようなユーティリティを用意してテストしました。</p>
<pre><code class="language-csharp">static async Task VerifyAsync(string testCode, int startLine, int startColumn, int endLine, int endColumn)
{

    await new CSharpAnalyzerTest&lt;MessagePipeAnalyzer, XUnitVerifier&gt;
    {
        ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity(&quot;MessagePipe&quot;, &quot;1.4.0&quot;))),
        ExpectedDiagnostics = { new DiagnosticResult(&quot;MPA001&quot;, DiagnosticSeverity.Error).WithSpan(startLine, startColumn, endLine, endColumn) },
        TestCode = testCode
    }.RunAsync();
}

static async Task VerifyNoErrorAsync(string testCode)
{

    await new CSharpAnalyzerTest&lt;MessagePipeAnalyzer, XUnitVerifier&gt;
    {
        ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity(&quot;MessagePipe&quot;, &quot;1.4.0&quot;))),
        ExpectedDiagnostics = { },
        TestCode = testCode
    }.RunAsync();
}
</code></pre>
<p>これで</p>
<pre><code class="language-csharp">        [Fact]
        public async Task SimpleTest()
        {
            var testCode = @&quot;using MessagePipe;

class C
{
    public void M(ISubscriber&lt;int&gt; subscriber)
    {
        subscriber.Subscribe(x =&gt; { });
    }
}&quot;;

            await VerifyAsync(testCode, 7, 9, 7, 39);
        }

        [Fact]
        public async Task NoErrorReport()
        {
            var testCode = @&quot;using MessagePipe;

class C
{
    public void M(ISubscriber&lt;int&gt; subscriber)
    {
        var d = subscriber.Subscribe(x =&gt; { });
    }
}&quot;;

            await VerifyNoErrorAsync(testCode);
        }
</code></pre>
<p>のようにテストが書けました。</p>
<h2>まとめ</h2>
<p>というわけでAnalyzer書いていきましょう。今現在は結局Visual Studioだけかよ！みたいな気もしなくもないですが、そのうちVS CodeとかRiderでも出来るようになるんじゃないでしょうか、どうだろうね、そのへんはわかりません。</p>
<p>ところでUnity 2020.2からAnalyzerが使えると言いましたが、そのサポート状況はなんだかヘンテコで、ぶっちゃけあんま使えないんじゃ疑惑があります。特に問題は、Unity Editor側では有効になっているけどIDE側で有効にならない場合が割とあります。これはUnityの生成したcsprojに、カスタムで追加したAnalyzerの参照が適切に入ってなかったりするせいなのですが、それだと使いづらいですよね、というかAnalyzerってコード書いてる最中にリアルタイムに警告あるのがイケてるポイントなので。</p>
<p>そこでCysharpで<a href="https://github.com/Cysharp/CsprojModifier">CsprojModifier</a>というUnity用の拡張をオープンソースで公開しました。ついさっき。6時間ぐらい前に。</p>
<p><img src="https://github.com/Cysharp/CsprojModifier/raw/master/docs/images/Screen-01.png" alt="" /></p>
<p>これがあるとUnityでも正しくAnalyzerの参照の入ったcsprojを使える他に、例えば<a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">BannedApiAnalyzers</a>という、任意のクラスやメソッド、プロパティの呼び出しを禁止するという、かなり使えるAnalyzerがあるんですが（例えばUnityだとGameObject.Find絶対禁止マンとかが作れます）、これはどのメソッドの呼び出しを禁止するかをBannedSymbols.txtというファイルに書く必要があり、Unityのcsproj生成まんまだとこのBannedSymbols.txtへの参照が作れないんですね。で、CsprojModifierなら、参照を入れたcsprojが作れるので、問題なくUnityでBannedApiAnalyzersが使えるようになるというわけです。</p>
<p>というわけで改めて、Analyzer、書いていきましょう……！</p>
<p>実際こないだリリースした<a href="https://github.com/Cysharp/MessagePipe/">MessagePipe</a>用に、Subscribe放置を絶対に許さない（エラー化する）Analyzerを公開しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png" alt="" /></p>
<p>こういうの、必要だし、そしてちゃんと導入するととても強力なんですよね。せっかくのC#の強力な機能なので、やっていきましょう。</p>
</div>
<h1><a href="https://neue.cc/2021/02/26_599.html">C#のasync/await再考, タイムアウト処理のベストプラクティス, UniTask v2.2.0</a></h1>
<ul class="date"><li>2021-02-26</li></ul>
<div class="entry_body"><p>お題を3つ並べましたが、記事は逆順で書いていきます！というわけで、<a href="https://github.com/Cysharp/UniTask">UniTask v2.2.0</a>を出しました。改めてUniTask v2とは<a href="https://tech.cygames.co.jp/archives/3417/">Unityのためのゼロアロケーションasync/awaitと非同期LINQ</a>を実現するライブラリで、とv2リリース時の解説記事を貼っつけましたが、ちょいちょい細かい改善を続けてまして、今回v2.2.0になります。</p>
<h2>PlayerLoopへのループ挿入のカスタマイズ対応</h2>
<p>現状のUnityはPlayerLoop上で動いていて、<a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">Unity 2020.1のリストをここに置いておきました</a>が、デフォルトでは120個ぐらいのループがエンジンから駆動されています。Updateループだけでも<code>ScriptRunBehaviourUpdate</code>, <code>ScriptRunDelayedDynamicFrameRate</code>, <code>ScriptRunDelayedTasks</code>, <code>DirectorUpdate</code>と色々あります。UniTaskも基本的にはPlayerLoop上で動かしているのですが、自由に任意の実行箇所を選べるように、28個のループを挿入しています。これにより <code>UniTask.Yield(PlayerLoopTiming.PreLateUpdate)</code> などといったような指定を可能にしているわけですが、28個ってちょっと多いんじゃないか？という。デフォで120個あるうちのプラス28個、多いっちゃあ多いけど、ループの中身も空っぽに近いし、空UpdateのMonoBehaviourを10000個並べるみたいなのとは比較にならないほど小さい話だから許容範囲内ぢゃん、と思ってはいるんですが、例えばAndroidでDeep Profilingなんかすると、ちょとプロファイラのデータに出てきちゃったりなんかは指摘されたことがあります（Deep Profilingの影響があるので、実際のビルドではそうでもないんですが）。</p>
<p>何れにせよ、99.99%はUpdateしか使わねえよ、みたいなのはあると思います。というわけで、UniTaskのPlayerLoopの挿入量を任意に調整できるようにしました。</p>
<pre><code class="language-csharp">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
public static void InitUniTaskLoop()
{
    var loop = PlayerLoop.GetCurrentPlayerLoop();
    PlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum);
}
</code></pre>
<p>これで、<code>Update | FixedUpdate | LastPostLateUpdate</code> の3つしか挿入されなくなります。<code>InjectPlayerLoopTimings</code>は任意のLoopTimingの選択、例えば <code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code> のような指定と、3つのプリセット、 <code>All</code>(デフォルトです), <code>Standard</code>(Lastを抜いたもの、挿入量が半分になる(ただし一番最後のLastPostLateUpdateは挿入する))、<code>Minimum</code>(Update, FixedUpate, LastPostLateUpdate)が選べます。正直なところ9割の人はMinimumで十分だと思ってますが、まぁ状況に応じて任意に足したり引いたりしてもらえればいいんじゃないかと。</p>
<p>ところで、そうすると、挿入していないループタイミングを指定するとどうなるんですか？というと、実行時例外です。えー、それじゃー困るよーと思うので、そこで使えるのが<a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>というやつで、(<a href="https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html">Unity 2020.2からAnalyzerが何のハックもなくそのまま使えるようになった</a>のでAnalyzerは普通に使えますよ！)、例えばInjectPlayerLoopTimings.Minimum用に、このBannedApiAnalyzersの設定、BannedSymbols.txtを書くとこうなります。</p>
<pre><code class="language-txt">F:Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn't injected this PlayerLoop in this project.d
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn't injected this PlayerLoop in this project.
F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastTimeUpdate; Isn't injected this PlayerLoop in this project.
</code></pre>
<p>こうすると、例えば PlayerLoopTiming.LastUpdate をコード上に書くと RS0030 のWarningとなります。WarningじゃなくてErrorでいいので、そこはUnityのドキュメントの通りにwarn-&gt;errorに設定を入れてやれば、以下の画像のようになります。</p>
<img src="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png" width=600 />
<p>このぐらい出来ていれば、十分でしょう。ところでBannedApiAnalyzersはめっちゃ使えるやつなので、これの対応以外にも普通に入れておくと捗ります。どうしてもこのメソッドはプロジェクトでは使用禁止！といったようなものはあると思います、それを規約じゃなくてコンパイルエラー（警告）に変換できるわけです。例えばGameObject.Find(&quot;name&quot;) 絶対殺すマンとかがさくっと設定できるわけです。</p>
<p>（と思ったのですが、現状のUnity 2020.2のAnalyzer標準対応はかなりヘッポコのようで、そのままだとBannedApiAnalyzersはうまく使えなさそうです(BannedSymbols.txtの適用ができないとか、その他色々。csproj生成をフックして差し込むことはできるので、それによって差し込んでIDE側で利用する、ぐらいが妥協点になりそう)</p>
<h2>タイムアウト処理について</h2>
<p>タイムアウトはキャンセルのバリエーションと見なせます。つまり、CancellationTokenを渡すところに、時限発火のCancellationTokenを渡せばいいのです。そうすれば、タイムアウトの時間が来るとキャンセルが発動する。それがタイムアウト処理です。UniTaskでは <code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code> というのがあるので、それを使います。</p>
<pre><code class="language-csharp">var cts = new CancellationTokenSource();
cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.

try
{
    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(cts.Token);
}
catch (OperationCanceledException ex)
{
    if (ex.CancellationToken == cts.Token) // Tokenの比較をすることで厳密に発火元を調べることができますが、この場合100%タイムアウトなので比較しなくてもそれはそれでいい
    {
        UnityEngine.Debug.Log(&quot;Timeout&quot;);
    }
}
</code></pre>
<blockquote>
<p>CancellationTokenSource は.NET標準のクラスであり、CancelAfterというメソッドが標準にありますが、これは（例によって）使わないでください。標準で備え付けられているものは当然のようにスレッドタイマーを用いますが、これはUnityにおいては不都合な場合が多いでしょう。CancelAfterSlimはUniTaskが用意している拡張メソッドで、PlayerLoopベースでタイマー処理を行います。パフォーマンス上でも軽量です。</p>
</blockquote>
<p>タイムアウトによるキャンセル処理と、別のキャンセル処理を組み合わせたい場合も少なくないでしょう。その場合は <code>CancellationTokenSource.CreateLinkedTokenSource</code> を使ってCancellationTokenを合成します。</p>
<pre><code class="language-csharp">var cancelToken = new CancellationTokenSource();
cancelButton.onClick.AddListener(()=&gt;
{
    cancelToken.Cancel(); // cancel from button click.
});

var timeoutToken = new CancellationTokenSource();
timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.

try
{
    // combine token
    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);

    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(linkedTokenSource.Token);
}
catch (OperationCanceledException ex)
{
    if (timeoutToken.IsCancellationRequested)
    {
        UnityEngine.Debug.Log(&quot;Timeout.&quot;);
    }
    else if (cancelToken.IsCancellationRequested)
    {
        UnityEngine.Debug.Log(&quot;Cancel clicked.&quot;);
    }
}
</code></pre>
<p>これによってキャンセルボタンのクリックによるキャンセル発火と、タイムアウトによるキャンセル発火を合成することが出来ました。</p>
<h2>TimeoutController</h2>
<p>ここまでが王道パターンのキャンセル処理だったのですが、今回UniTask v2.2.0では新しくTimeoutControllerというクラスを追加しました。これはタイムアウトが発火しない場合はアロケーションがなく再利用可能なCancellationTokenSourceです。タイムアウトは例外的状況なはずなので、これによってほとんどの状況で、タイムアウト処理のためのアロケーションをゼロにすることができます。</p>
<pre><code class="language-csharp">TimeoutController timeoutController = new TimeoutController(); // setup to field for reuse.

async UniTask FooAsync()
{
    try
    {
        // you can pass timeoutController.Timeout(TimeSpan) to cancellationToken.
        await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest()
            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));
        timeoutController.Reset(); // call Reset(Stop timeout timer and ready for reuse) when succeed.
    }
    catch (OperationCanceledException ex)
    {
        if (timeoutController.IsTimeout())
        {
            UnityEngine.Debug.Log(&quot;timeout&quot;);
        }
    }
}
</code></pre>
<p>再利用（と、内部のタイマーの停止）のために、awaitが正常終了したらResetを手動で呼んでください、という一点だけ気をつけてください。</p>
<p>CreateLinkedTokenSource的な使い方をする場合は、コンストラクタの引数に別のCancellationTokenを渡せます。これによってTimeout(TimeSpan)で得られるCancellationTokenがリンクされたものとなります。</p>
<pre><code class="language-csharp">TimeoutController timeoutController;
CancellationTokenSource clickCancelSource;

void Start()
{
    this.clickCancelSource = new CancellationTokenSource();
    this.timeoutController = new TimeoutController(clickCancelSource);
}
</code></pre>
<p>ところでここで告知が幾つか有りまして、まず、UniTaskには標準で <code>.Timeout</code>, <code>.TimeoutWithoutException</code> というメソッドが生えているのですが、これらは可能であれば使わないでください。というのも、 <code>.Timeout</code>は外部からタイムアウト処理を行うもので、その場合に動いているタスク本体を停止することができないのです。タイムアウトが発火してもTask自体は動いていて、やってることは結果を無視するということです（世の中、AbortできないAPIも少なくなくて、そういうもののキャンセル処理ってこういうことなので、別にこれ自体は悪いわけではない）。かたやCancellationTokenをメソッドに渡す場合は、内部からのタイムアウト処理となるので、その場合TaskがAbort可能なものであれば、正しく処理がAbortされます。まとめると、CancellationTokenを渡すことができないメソッドに対して外付けでタイムアウト処理を行いたいときだけ、<code>.Timeout</code>を使いましょう、ということになります。正直名前ももう少し、あんま使わないで感を醸し出す名前に変更したいぐらいなのですが、まぁとりあえずは、ということで……。</p>
<p>もう一つ、UniTaskには <code>AsyncOperation.WithCancellation</code> とは別に <code>UniTask.WithCancellation</code> というメソッドが生えていたのですが、<code>UniTask.WithCancellation</code>のほうの名前を<code>AttachExternalCancellation</code>に変更しました。これもTimeoutの話と同じで、 <code>AsyncOperation.WithCancellation</code> が内部からのキャンセル処理で、 <code>UniTask.WithCancellation</code> は外部からのキャンセル処理となっていて、挙動は似ていても内部動作が全く違うからです。内部キャンセルのほうが望ましいんですが、コードを見ただけだと内部キャンセルなのか外部キャンセルなのか分からないのは非常に良くない。つーかマズい。ダメ。ので変えました。名前的にも、使いたくない雰囲気を漂わせてる名前であるとおり、あんま使わないでねという意図が込められています。</p>
<p>最後に微妙に細かいところなのですが、<code>AsyncOperation.WithCancellation</code>の挙動を<code>.ToUniTask(cancellationToken)</code>のただのショートカットにしました。Timeout処理で使うのに微妙に都合が悪かったからです。挙動はあんま変わらないんですが、細かく厳密なことを言うと少し違うんですが、まぁ、そういうことということで。</p>
<p>この手の初期のデザインミスの修正は、あんま破壊的変更祭り死ね、とはならない程度に、ちょいちょいやらなきゃなあとは思ってるので、すみませんが宜しくおねがいします。</p>
<h2>async/awaitは何故無限に分からないのか</h2>
<p>async/await自体は非同期処理を容易にするための仕組みであり、雰囲気としては誰でも同期処理と同じように書けることをゴールにしています。そして、実際のところそれは、達成できてます。同期と同じことしかしなければ。asyncと宣言してawaitと書けば、同期処理と同じです。それは全く嘘偽りなく正しい。別にラムダ式も出てこないし特殊なコールバックも実行順序もない。ちゃんとループも書けるしtry-catchもできる。そういうように作られてる。</p>
<p>じゃあなぜ難しいのかというと、同期処理よりも出来ることが増えているからです。</p>
<ul>
<li>直列にすべきか並行にすべきか</li>
<li>キャンセルにどう対応すべきか</li>
<li>伝搬の終点をどう扱うべきか</li>
<li>Task(UniTask)が伝搬するのをよしとすべきか</li>
<li>投げっぱなし処理にすべきか</li>
</ul>
<p>で、これらってそもそも同期処理だと出来ないことなんですよね、キャンセルって同期だと原則できないわけで。だからキャンセルなんて考えず黙ってawait、以上。とすればいいのです。別に並行(WhenAll)なんてしなくても直列で回してもいいのです、だって同期だったら黙って直列でやってた話じゃないですか。以上。</p>
<p>が、まぁ人間出来るとなると欲が出るし、そもそも実際そういうわけにはいかないので、同期処理と比べて、よりベターな処理にするために、考えることが増える。やるべきことが増える。そこが難しさのポイントです。でも出来ることが多いってのは良いアプリケーション作りのためには悪いことではない。ブロッキング処理がなくなればUIの体験は非常に良くなるし、並行処理で高速に読み込まれれば嬉しいし、きちんとキャンセル処理されたほうがいいに決まってる。だから、非同期は重要なのです。</p>
<p>というわけで、とりあえず一個一個考えていきましょうか。</p>
<h2>直列にすべきか並行にすべきか</h2>
<p>これ、JavaScriptの記事とかで、 Promise.all 使わないのは素人、バーカバーカ。みたいな記事がめちゃくちゃ良くありますが、んなこたーなくて使うかどうかはものによる。もちろん簡単に並行に束ねられるのは素晴らしいことなので、それはいいです。大いにやるべきだ。じゃあ直列処理は間違ってるかというと、別に間違っちゃあいないし、そうすべき局面だってそれなりにある。あと、allを使う必要があるからasync/awaitよりPromiseだ、みたいなのは意味不明なので無視していい。そもそも、そういう人たちってロクにコード書いたことないからなのか、thenとallぐらいしか用例を知らない説すらある。awaitはただのthenの糖衣構文「ではない」し、thenだけだと無理があるみたいなパターンもいっぱいあります。例えば非同期のミドルウェアパターンを<a href="http://neue.cc/2020/08/20_594.html">async decoratorパターンによるUnityWebRequestの拡張とUniTaskによる応用的設計例</a>で紹介しましたが、これなんかはasync/awaitだからこそ成立させられる、そして非常に強力な用例です。</p>
<p>と、脱線しましたが、とはいえこうした並行処理を簡単に書けるようになったのがasync/await（つまりはPromise/Future/Task/UniTask）のいいところです。同期処理の場合では書けないのは勿論、コールバックベースでも難しくて無理がある、のでやらないものだったのが、async/awaitの登場によって頻繁に出てくるパターン、そして誰でも比較的安全に処理できるパターンとなりました。ちなみにこれ、Promiseだけでも誰でも使えるパターンとはなり得なくて、async/awaitがあるからこそ、Promiseのコード上での出現頻度が上がり、それによって適用可能になるシチュエーションが増えるという側面があると思っています。</p>
<h2>Task(UniTask)が伝搬するのをよしとすべきか</h2>
<p>前の話から続けると、asyncのための型(Promise/Task/UniTask)が頻出するのは、いいことだと思ってます。そのお陰で、効果的に適用できるシチュエーションが増えるんですから。とはいえ面倒くせーしグチャグチャするし嫌だ、という気持ちは大いにわかる。はい。</p>
<p>と、ここで最新型のasync/await実装であるSwift 6から幾つか例を見てみましょう。日本語でわかりやすくまとまってる <a href="https://zenn.dev/koher/articles/swift6-concurrency">Swift 6で来たる並行処理の大型アップデート近況</a> と <a href="https://speakerdeck.com/koher/await">先取り！ Swift 6 の async/await</a> から引かせてもらいますが、まずメソッドの宣言。</p>
<pre><code class="language-csharp">func download(from url: URL) async -&gt; Data
</code></pre>
<p>Dataが戻り値なわけですが UniTask[Data] みたいになっていない、Promiseが出てこないやったー、かというと、別にそんなこたぁないかなあ、と思います。Swiftの場合、asyncで宣言したメソッドにはawaitが必須であり、awaitを使うにはasyncである必要がある、と、伝搬していっているわけなので、 <code>async -&gt; Data</code> の一塊で見れば、制約や機能は UniTask[Data] のようなものと大きな違いはありません（型として明示されない分だけ、より強い制約がかかってるのですが、そのへんは後述）。</p>
<p>そういうわけでasyncが伝搬している（悪いような言い方をすればコードを汚染している）わけですが、それに関してはどうでしょう。Swiftがいい対称性を持っているのは<a href="https://qiita.com/koher/items/e4c1d88981291c35d571">Swiftの検査例外</a>と似たような雰囲気で捉えられるところで、エラーの発生しうるメソッド(throws)の呼び出しにはawaitのようにtryが必要で、tryにはthrowかcatchが必要、と。</p>
<p>なので、最下層でエラーなしメソッドからエラーありメソッドに変えたら、呼び出し側はどんどんさかのぼってエラー処理を書く必要がある。別にこれはGoも一緒ですよね、戻り値が(value)から(value, error)に変わり、対応していく必要がある。そういう対応が面倒くさいので、そうしたエラーに関しては検査しない勢もいる（C#や非検査例外のJavaなんかはそうですよね、どちらかというとむしろそのほうが多数派）わけで、良し悪し、とは言いませんが、現代的にエラー処理を強制的に伝搬させることは絶対に忌避するもの、というほどの価値観ではなくなってるのではないかと思います。</p>
<p>で、async/awaitの話しに戻りますが、非同期もまた同様に最下層で同期から非同期に処理を変更したら伝搬していく。で、エラー処理をやったほうがいいのと同じように、同期から非同期へと性質が異なるものになったので、そしてそのことが型で明示されるのは当然いいことなので、伝搬していくのは当たり前じゃないですか？性質が変化したことを型(UniTask)なり宣言(async)なりで示し、上層側に性質が変化したことにより増えた出来ることの選択(並行処理/キャンセル/etc...)を与える。悪いことじゃないので受け入れるべきだし、async汚染とか言って喜んでるのはやめるべきですね。</p>
<p>全部非同期というか、そういうことを全く意識させないような言語としてデザインする、というアイディアも当然あって、Goは実際それに近くて、しかも圧倒的に少数派で独特なデザインなのに大成功を収めているのが凄い。まぁじゃあそれが理想的で全ての言語がそうなっていくべきかというとそうではないとは思います（例えばキャンセルやタイムアウト処理などは結局意識させなきゃいけないので、Contextを伝搬させる必要があるため、完全に透過的にできているかというとそうではない。また全体のシンプル化の結果WaitGroupのような他ではあまり出てこないプリミティブな処理や、Channelが頻出する、もちろんそれはトレードオフなのでデザインとしてナシではないですが）。みんな違ってみんないい、とは思いませんが、目の前のプロダクトのために現在の現実の時間で何を選ぶべきか、という話ですね。</p>
<p>伝搬はしょーがないとしても、書き味を良くするやり方はありますよね。Swiftの場合は、非同期で宣言している関数に同期関数を突っ込める。雑多なところでいうと、Task.FromResult()書いて回らなくていい、的な良さがありますね。ただまあ呼び出し側のawait, asyncの伝搬のほうが面倒くさ度というか、書くことはずっと多いので、あったほうがいいけど、なくても許容できるぐらいの感じかしら。</p>
<p>それと async -&gt; Data には UniTask[Data] のようなTask型が出てこない。これも一々ジェネリクスで書くの面倒くさいので、asyncって言ってるんだからイチイチ、そっちの型でまで書きたくない、と。めっちゃいいですね。はい、いいです。また、文法とタイトにくっついてるのでUniTaskのawait二度漬け禁止とか、フィールドには持たないで欲しいなぁみたいなのが文法レベルで制限かけられる。これもいいところです。</p>
<p>じゃあそれと比べたC#の良いところというか現状こうなってるという点では、asyncで宣言した戻り値の型によって実行する非同期ランタイム(AsyncMethodBuilder)が切り替えられます。asyncで宣言したメソッドを非同期ステートマシンに変換するのはコンパイラの仕事ですが、そのステートマシンの各ポイントでどう処理するかの実行機は型に紐付いています。Taskで宣言しているメソッドはTaskの非同期ランタイム、ValueTaskで宣言してるメソッドはValueTaskの非同期ランタイム、そしてUniTaskで宣言してるメソッドはUniTaskの非同期ランタイムで動きます。UniTaskがやっているように、この非同期ランタイムはユーザーがC#で実装できます。</p>
<p>世の中の99%は別に既定の非同期ランタイムで不自由しない、と思いきや、そうではなくて、完全にデフォルトの実装を無視して100%実行環境(Unity)に特化して最適化することの効果、意味みたいなことを実証したのがUniTaskで、ちゃんと成功しています。非同期実行ランタイムを切り替えられる言語は他にもありますが(Rustもそうですね)、C#のそれは私が自分で書いてそこそこうまく普及させたというのもありますが、現状よくできた仕組みになっているんじゃないかとは思います。</p>
<h2>伝搬の終点</h2>
<p>asyncは伝搬していきますが、一番根っこで何か処理しなきゃいけないのはC#もそうですし、別にSwiftも同様です。Swift 6の仕様を見る限り@asyncHandlerでマークされたメソッドは伝搬を打ち切った根っこのメソッドになるようですが、つまりようするにこれってC#でいうところの <code>async void</code> です。</p>
<p>伝搬をどういう風に打ち切ればいいのかというのは、実際初心者殺しなところがありますが、フレームワークがasync/await前提で作られている場合は意識させないことが可能です。例えばMVCウェブフレームワークのControllerで言ったら</p>
<pre><code class="language-csharp">public class FooController : Controller
{
    // Foo/Helloでアクセスできる
    public async Task Hello()
    {
        // Usercode...
    }
}
</code></pre>
<p>というようにすると、ユーザーのコード記述のエントリポイントは async Task Hello であり、非同期伝搬の最上位の処理(async void)はMVCフレームワークの中で隠蔽されています。</p>
<p>コンソールアプリケーションのMainもそうです</p>
<pre><code class="language-csharp">static async Task Main()
{
    // Usercode...
}
</code></pre>
<p>最上位がMainなので、伝搬の終点なんて考えなくていい。</p>
<p>じゃあUnityは、とかWinFormsやWPFは？というと、async/awaitなんて存在しない時代からのフレームワークであり、別にそれを前提としていないので、最上位を自分で作る必要があります。これが悩ましさを増させてしまうんですね。まぁ大抵はユーザーの入力が起点なので、Buttonのイベントハンドラーに対して UniTaskVoid(async void) を突っ込む、みたいな運用になってきますが……。あとはStartCoroutineと同じような雰囲気で、MonoBehaviourのどこかでFireAndForgetですね。何れにせよ、自分で最上位となるポイントを判断しなきゃいけないというのが、ひと手間感じるところで、難しいと言われてもしょうがない話です。async voidは使うんじゃねえ（正しくはある）、みたいな話もあるから余計分からなくなるという。使っても良いんですよ、最上位では……。</p>
<p>UniTaskの場合はUniTaskVoidという存在がまた面倒くささを増量しているのですが、上の方でC#は戻り値の型で非同期ランタイムを切り替えられると書きましたが、つまりvoidに対するC#既定のランタイムがあり、voidで宣言する以上、それは変えられないのです。そのためasync UniTaskVoid と書かせるのですが、voidは特殊な存在でありUniTaskVoidは普通の戻り値の型なので、C#コンパイラの都合上、最上位として使うためにはなんらかのハンドリング(空の警告を抑制するためだけの.Forget()呼び出し)が強いられるという……。</p>
<p>C# 10.0 だから C# 11.0 だかに向けての提案に<a href="https://github.com/dotnet/csharplang/blob/master/proposals/async-method-builders.md">AsyncMethodBuilder override</a>という仕様があって、メソッド単位で非同期ランタイムを選択できるようになる、可能性があります。そうしたら</p>
<pre><code class="language-csharp">[AsyncMethodBuilderOverride(typeof(UniTaskVoidMethodBuilder))]
async void FooAsync() { }
</code></pre>
<p>みたいに書けるようになるかもしれません。うーん、でも別にこれ全然書き味悪いですねぇ。</p>
<pre><code class="language-csharp">[UniTaskVoid]
async void FooAsync() { }
</code></pre>
<p>ぐらいまで縮められるようになって欲しい、まぁまだProposalなので今後に期待、あとどっか適当なタイミングで提案しておこう（そもそも C# で現実的に稼働してる 非同期ランタイム を実装してるのはMicrosoftのTask/ValueTask実装者(Stephen Toub)と私ぐらいしかいないのだ）</p>
<h2>キャンセルにどう対応すべきか</h2>
<p>C#において、asyncメソッドは引数の最後にCancellationTokenを受け入れるべきだというふんわりした規約があります。これが、ダセーしウゼーし面倒くせーと大不評で。なるほどね、そうだね！私もそう思う！</p>
<p>なんでこうなってるかというと、asyncに使うTask型って別にasyncで宣言したメソッドからしか作れないわけじゃなくて、手動で作れるんですよね。new Taskみたいな。Task.FromResultみたいな。それどころか別にawaitできる型もGetAwaiterという決め打ちな名前のメソッドを後付けで（拡張メソッドで）実装すればawaitできるようになりますからね。ゆるふわー。</p>
<p>それはそれで非常に拡張性があって、そもそもasync/awaitに全然対応していないもの(Unity)に対してもユーザー側(UniTask)が対応させることが出来たりして、とても良かったのです、が、awaitする型全体を通してコンパイラがChildTask的な、便利Contextを裏側で自動で伝搬してあげるみたいな仕組みを作りづらいわけです。</p>
<p>Swiftの場合は言語とタイトにくっついたasyncが用意されているので、<code>let handle = Task.runDetached { await ...}  handle.cancel()</code> みたいに書ける、つまりObservableをSubscribeしたのをDisposeすればCancelでこれがUniRxで良かったのにUniTaskは面倒くせえなおい、みたいなことが出来てハッピーっぽそうです。独立したCancellationTokenを持っているのは、それはそれで柔軟な取り回しができて悪くない場合もあるんですが、まぁ99.99%の状況で上位から伝搬するCancellationTokenだけで済むのは間違いないでしょう。</p>
<p>ともあれ現状のC#的にはどうにもなんないししょーがないかなぁ、と思ってます。（GoだってContext手動で取り回すわけだし、ね）。はい。実際にはExecutionContextというスロットをawaitの伝搬で共有していて、SynchronizationContext.Currentはそれ経由で格納されてるので、そこにCancellationToken.Currentみたいなものを仕込むこと自体はランタイム的には出来るんですけどね。でも、ExecutionContextのスロットを使うというオーバーヘッドも避けれるなら避けたほうがいいというのもあります（などもあって、Taskで自動的に行われているExecutionContextの伝搬をUniTaskでは切っています）。</p>
<p>一応、文化として「引数の最後にCancellationTokenを受け入れる」というルールが普及していること自体は良かったと思います。JavaScriptだとAbortControllerがCancellationTokenのような機能を果たしますが、これを使っていくのが一般的という雰囲気でもないので、キャンセルに対する統一的なやり方が作れてない感じがあるので。</p>
<h2>CPU資源の有効活用とスケジューラー</h2>
<p>まず、非同期とCPU使って並列処理だー、みたいなのは被るけど被らないんですね。そして、CPUをぶん回さない非同期に価値はないかというと、んなわきゃぁないんですね。まずI/Oの非同期について考えるのが大事で、JavaScriptがシングルスレッドだから全然使えないかと言ったらんなわきゃあねえだろ、であり(Node.jsで見事実証されてます)、Redisがアーキテクチャとしてシングルスレッドを選択しても価値ある性能を出せることを証明してます。</p>
<p>その上で使える資源は色々使えたほうがいいよーということであり、C#のasync/awaitの場合はTaskが、というかawaitからawaitの間が実行単位になってきます。Unityの場合はawaitの最中にゲームエンジン(C++)に処理を渡して、エンジンが処理結果をメインスレッドに戻してきたのをC#がawaitで受け取る流れになってます。エンジン側に処理をぶん投げまくってC#側のメインスレッドを空けるのが現状のUnityにおける非同期というかasync/awaitというわけですね（この辺はJavaScriptに非常に似ています）。</p>
<p>.NET の場合はasyncメソッドは最終的にどこかの非同期I/Oに叩き込まれて、awaitで戻ってくるときにスレッドプールを使います。async/awaitが言語に実装されて以降、C#はスレッドプールをめちゃくちゃ使うようになりました、というかawaitするとスレッドプールに行くので、本質的にもはやプログラムは全てスレッドプール上で動いているといっても過言ではない。のです。全てがGoルーチンみたいな世界観と同じです（言い過ぎ）。というわけで、スレッドプールのスケジューラーへの改善の投資は続いて、もちろんワークスティーリングもしますし、ただのスレッドのプール、ではない賢い動作をする、.NETの非同期処理の心臓部となっています。</p>
<p>.NET 6ではこのスレッドプールはPure C#実装になります。というのもC#が動くランタイムも複数あって（.NET Coreであったりmonoであったり）、それぞれが個別のネイティブ実装だと、一つのランタイムがアルゴリズム改善しても、他のランタイムに反映されなくなってしまうなどなど。.NET Core以降、C#上で低レベルなコードが書けるようになったこととランタイムの実行速度の改善が続いていることもあり、.NET 6においてはネイティブ実装→Pure C#実装への切り替えはパフォーマンス的な向上にも繋がったそうです。</p>
<h2>まとめ</h2>
<p>C#のasync/awaitが登場したのは2012年、preview辺りの頃から考えるともう10年前！実用言語での大規模投入は間違いなく初めてで、最初の実装(C# 5.0)が現在から見て良かったかというと、まずかった部分も少なからずあります。しかしまぁ、6.0, 7.0, 8.0と改良を進めて来た現在のC#のasync/awaitは別に他と比べて劣っているとは思えません。8.0 のasync streamsやAsync LINQは<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md">Swiftのasync seqeunceのproposal(つまりまだ先)</a>みたいなところもありますし。</p>
<p>Unity上でUniTaskみたいな独自非同期ランタイムを作るのも、別にC#で無理してやってるというわけでもなく、自分の中では自然なことです。現実にモバイルゲームを開発していこうというところで、まず動かせない要素を決める、つまりUnityというのは不動な要素。そしてそこに乗ってるC#も外れない言語。その中で、現在可能な技術(C# 8.0)の範囲で、最高の結果を引き出すための手法を選んで、手を動かす。</p>
<p>こないだ私の会社で出してるOSSの紹介をしたのですが、非現実的な理想ではなくて、今表現できる最高のものを生み出していく。というのをモットーにしてます。エンジニアなら評論家にならず手を動かして結果で示せ、ということですね。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/abifk9UuCO8pDc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/a-quick-tour-of-the-cysharp-oss" title="A quick tour of the Cysharp OSS" target="_blank">A quick tour of the Cysharp OSS</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>というわけでまぁUniTask v2.2.0もいい感じになっていると思うので、ぜひぜひ使っていただければです！</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
