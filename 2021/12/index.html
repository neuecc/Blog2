<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2021-12</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2021/12/22.html">NativeMemoryArray - .NET 6 APIをフル活用した2GB超えの巨大データを扱うライブラリ</a></h1>
<ul class="date"><li>2021-12-22</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/microsoft">.NET 6 Advent Calendar 2021</a>の12日の代理投稿となります。プレゼント付きですと！？<a href="https://www.balmuda.com/jp/brew/special-model">BALMUDA The Brew STARBUCKS RESERVE LIMITED EDITION</a>が欲しいです！</p>
<p>さて、先程NativeMemoryArrayという新しいライブラリを作成し、公開しました。.NET Standard 2.0でも動作しますが、全体的に .NET 6 の新API群(NativeMemory, Scatter/Gather I/O)を活かすための作りになっていますので、今回のAdvent Calendarにもピッタリ。実用性も、ある……！あります……！もちろんUnity版も用意してあります（NativeArrayと何が違うって？まぁ違うと言えば違います）。</p>
<ul>
<li><a href="https://github.com/Cysharp/NativeMemoryArray">GitHub - Cysharp/NativeMemoryArray</a></li>
</ul>
<p>C#には配列、特にbyte[]を扱う上で大きな制約が一つあります。それは、一次元配列の上限値が0x7FFFFFC7(2,147,483,591)ということ。int.MaxValueよりちょっと小さめに設定されていて、ようするにざっくり2GBちょいが限界値になっています。</p>
<blockquote>
<p>この限界値は、正確には .NET 6 でひっそり破壊的変更が行われましたので、.NET 6とそれ以外で少し異なります。詳しくは後で述べます。</p>
</blockquote>
<p>この2GBという値は、int Lengthの都合上しょうがない(intの限界値に引っ張られている)のですが、昨今は4K/8Kビデオや、ディープラーニングの大容量データセットや、3Dスキャンの巨大点群データなどで、大きな値を扱うことも決して少ないわけではないため、2GB制約は正直厳しいです。そして、この制約は<code>Span&lt;T&gt;</code>や<code>Memory&lt;T&gt;</code>であっても変わりません(Lengthがintのため)。</p>
<p>ちなみに<code>LongLength</code>は多次元配列における全次元の総数を返すためのAPIのため、一次元配列においては特に意味をなしません。.NET Frameworkの設定である<a href="https://docs.microsoft.com/ja-jp/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element">gcAllowVeryLargeObjects</a>も、構造体などを入れた場合の大きなサイズを許容するものであり(例えば4バイト構造体の配列ならば、2GB*4のサイズになる)、要素数の限界は超えられないため、byte[]としては2GBが限界であることに変わりはありません。</p>
<p>こうした限界に突き当たった場合は、ストリーミング処理に切り替えるか、またはポインタを使って扱うかになりますが、どちらもあまり処理しやすいとは言えませんし、必ずしもインメモリで行っていた操作が代替できるわけではありません（ポインタなら頑張れば最終的にはなんとでもなりますが）。</p>
<p>そこで、2GB制約を超えつつも、新しいAPI群(<code>Span&lt;T&gt;</code>, <code>IBufferWriter&lt;T&gt;</code>, <code>ReadOnlySequence&lt;T&gt;</code>, <code>RandomAccess.Write/Read</code>, <code>System.IO.Pipelines</code>など)と親和性の高いネイティブメモリを裏側に持つ配列（みたいな何か）を作りました。</p>
<p>これによって、例えば巨大データの読み込み/書き込みも、 .NET 6の新Scatter/Gather APIの<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>を用いると、簡単に処理できます。</p>
<pre><code class="language-csharp">// for example, load large file.
using var handle = File.OpenHandle(&quot;4GBfile.bin&quot;, FileMode.Open, FileAccess.Read, options: FileOptions.Asynchronous);
var size = RandomAccess.GetLength(handle);

// via .NET 6 Scatter/Gather API
using var array = new NativeMemoryArray&lt;byte&gt;(size);
await RandomAccess.ReadAsync(handle, array.AsMemoryList(), 0);

// iterate Span&lt;byte&gt; as chunk
foreach (var chunk in array)
{
    Console.WriteLine(chunk.Length);
}
</code></pre>
<p>Scatter/Gather APIに馴染みがなくても、<code>IBufferWriter&lt;T&gt;</code>や <code>IEnumerable&lt;Memory&lt;T&gt;&gt;</code> を経由してStreamで処理する手法も選べます。</p>
<pre><code class="language-csharp">public static async Task ReadFromAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    var writer = buffer.CreateBufferWriter();

    int read;
    while ((read = await stream.ReadAsync(writer.GetMemory(), cancellationToken).ConfigureAwait(false)) != 0)
    {
        writer.Advance(read);
    }
}

public static async Task WriteToAsync(NativeMemoryArray&lt;byte&gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    foreach (var item in buffer.AsMemorySequence())
    {
        await stream.WriteAsync(item, cancellationToken);
    }
}
</code></pre>
<p>あるいは<code>Span&lt;T&gt;</code>のSliceを取り出して処理してもいいし、<code>ref T this[long index]</code>によるインデクサアクセスやポインタの取り出しもできます。 .NET 6時代に完全にマッチしたAPIを揃えることで、標準の配列と同等、もしくはそれ以上の使い心地に仕上げることによって、C#の限界をまた一つ超える提供できたと思っています。</p>
<p>とはいえもちろん、 .NET Standard 2.0/2.1 にも対応しているので、非 .NET 6なAPIでも大丈夫です、というかScatter/Gather API以外は別に今までもありますし普通に使えますので。</p>
<p>普通の配列的にも使えます。GC避けには、こうした普通のAPIを使っていくのでも便利でしょう、</p>
<pre><code class="language-csharp">// call ctor with length, when Dispose free memory.
using var buffer = new NativeMemoryArray&lt;byte&gt;(10);

buffer[0] = 100;
buffer[1] = 100;

// T allows all unmanaged(struct that not includes reference type) type.
using var mesh = new NativeMemoryArray&lt;Vector3&gt;(100);

// AsSpan() can create Span view so you can use all Span APIs(CopyTo/From, Write/Read etc.).
var otherMeshArray = new Vector3[100];
otherMeshArray.CopyTo(mesh.AsSpan());
</code></pre>
<h2><code>NativeMemoryArray&lt;T&gt;</code></h2>
<p><code>NativeMemoryArray&lt;T&gt;</code>はwhere T : unmanagedです。つまり、参照型を含まない構造体にしか使えません。まぁ巨大配列なんて使う場合には参照型含めたものなんて含めてんじゃねーよなので、いいでしょうきっと。巨大配列で使えることを念頭においてはいますが、別に普通のサイズの配列として使っても構いません。ネイティブメモリに確保するので、ヒープを汚さないため、適切な管理が行える箇所では便利に使えるはずです。</p>
<p><code>Span&lt;T&gt;</code>との違いですが、<code>NativeMemoryArray&lt;T&gt;</code>そのものはクラスなので、フィールドに置けます。<code>Span&lt;T&gt;</code>と違って、ある程度の長寿命の確保が可能ということです。<code>Memory&lt;T&gt;</code>のSliceが作れるため、Async系のメソッドに投げ込むこともできます。また、もちろん、<code>Span&lt;T&gt;</code>の長さの限界はint.MaxValueまで(ざっくり2GB)なので、それ以上の大きさも確保できます。</p>
<p>Unityにおける<code>NativeArray&lt;T&gt;</code>との違いですが、<code>NativeArray&lt;T&gt;</code>はUnity Engine側との効率的なやりとりのための入れ物なので、あくまでC#側で使うための<code>NativeMemoryArray&lt;T&gt;</code>とは全然役割が異なります。まぁ、必要に思えない状況ならば、おそらく必要ではありません。</p>
<p>主な長所は、以下になります。</p>
<ul>
<li>ネイティブメモリから確保するためヒープを汚さない</li>
<li>2GBの制限がなく、メモリの許す限り無限大の長さを確保できる</li>
<li><code>IBufferWriter&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonWriter, System.IO.Pipelinesなどから直接読み込み可能</li>
<li><code>ReadOnlySequence&lt;T&gt;</code> 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonReaderなどへ直接データを渡すことが可能</li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt;</code>, <code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt;</code> 経由で <code>RandomAccess</code>(Scatter/Gather API)に巨大データを直接渡すことが可能</li>
</ul>
<p>あまりピンと来ない、かもしれませんが、使ってみてもらえれば分かる、かも。</p>
<p><code>NativeMemoryArray&lt;T&gt;</code>の全APIは以下のようになっています。</p>
<ul>
<li><code>NativeMemoryArray(long length, bool skipZeroClear = false, bool addMemoryPressure = false)</code></li>
<li><code>long Length</code></li>
<li><code>ref T this[long index]</code></li>
<li><code>ref T GetPinnableReference()</code></li>
<li><code>Span&lt;T&gt; AsSpan()</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start)</code></li>
<li><code>Span&lt;T&gt; AsSpan(long start, int length)</code></li>
<li><code>Memory&lt;T&gt; AsMemory()</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start)</code></li>
<li><code>Memory&lt;T&gt; AsMemory(long start, int length)</code></li>
<li><code>bool TryGetFullSpan(out Span&lt;T&gt; span)</code></li>
<li><code>IBufferWriter&lt;T&gt; CreateBufferWriter()</code></li>
<li><code>SpanSequence AsSpanSequence(int chunkSize = int.MaxValue)</code></li>
<li><code>MemorySequence AsMemorySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;Memory&lt;T&gt;&gt; AsMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>IReadOnlyList&lt;ReadOnlyMemory&lt;T&gt;&gt; AsReadOnlyMemoryList(int chunkSize = int.MaxValue)</code></li>
<li><code>ReadOnlySequence&lt;T&gt; AsReadOnlySequence(int chunkSize = int.MaxValue)</code></li>
<li><code>SpanSequence GetEnumerator()</code></li>
<li><code>void Dispose()</code></li>
</ul>
<p><code>AsSpan()</code>, <code>AsMemory()</code>はスライスのためのAPIです。取得したSpanやMemoryは書き込みも可能なため、 .NET 5以降に急増したSpan系のAPIに渡せます。SpanやMemoryには最大値(int.MaxValue)の限界があるため、lengthの指定がない場合は、例外が発生する可能性もあります。そこで<code>TryGetFullSpan()</code>を使うと、単一Spanでフル取得が可能かどうか判定できます。また、<code>AsSpanSequence()</code>, <code>AsMemorySequence()</code>でチャンク毎のforeachで全要素を列挙することが可能です。直接foreachした場合は、<code>AsSpanSequence()</code>と同様の結果となります。</p>
<pre><code class="language-csharp">long written = 0;
foreach (var chunk in array)
{
    // do anything
    written += chunk.Length;
}
</code></pre>
<p>ポインタの取得は、配列とほぼ同様に、そのまま渡せば0から(これは<code>GetPinnableReference()</code>の実装によって実現できます)、インデクサ付きで渡せばそこから取れます。</p>
<pre><code class="language-csharp">fixed (byte* p = buffer)
{
}

fixed (byte* p = &amp;buffer[42])
{
}
</code></pre>
<p><code>CreateBufferWriter()</code> によって <code>IBufferWriter&lt;T&gt;</code>を取得できます。これは<code>MessagePackSerializer.Serialize</code>などに直接渡すこともできるほかに、先の例でも出しましたがStreamからの読み込みのように、先頭からチャンク毎に取得して書き込んでいくようなケースで便利に使えるAPIとなっています。</p>
<p><code>AsReadOnlySequence()</code> で取得できる<code>ReadOnlySequence&lt;T&gt;</code>は、<code>MessagePackSerializer.Deserialize</code>などに直接渡すこともできるほかに .NET 5から登場した <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-6.0">SequenceReader</a>に通すことで、長大なデータのストリーミング処理をいい具合に行える余地があります。</p>
<p><code>AsMemoryList()</code>, <code>AsReadOnlySequence()</code>は .NET 6から登場した<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0">RandomAccess</a>の<code>Read/Write</code>に渡すのに都合の良いデータ構造です。プリミティブな処理なので使いにくいと思いきや、意外とすっきりと処理できるので、File経由の処理だったらStreamよりもいっそもうこちらのほうがいいかもしれません。</p>
<h2>NativeMemory</h2>
<p>.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.nativememory?view=net-6.0">NativeMemory</a>というクラスが新たに追加されました。その名の通り、ネイティブメモリを扱いやすくするものです。今までも<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=net-6.0">Marshal.AllocHGlobal</a>といったメソッド経由でネイティブメモリを確保することは可能であったので、何が違うのか、というと、何も違いません。実際NativeMemoryArrayの .NET 6以前版はMarshalを使ってますし。そして .NET 6 では Marshal.AllocHGlobal は NativeMemory.Alloc を呼ぶので、完全に同一です。</p>
<p>ただしもちろん .NET 6 実装時にいい感じに整理された、ということではあるので、NativeMemory、いいですよ。NativeMemory.Allocがmalloc、NativeMemory.AllocZeroedがcalloc、NativeMemory.Freeがfreeと対応。わかりやすいですし。</p>
<p>ちなみにゼロ初期化する NativeMemory.AllocZeroed に相当するものはMarshalにはないので、その点でも良くなったところです。<code>NativeMemoryArray&lt;T&gt;</code>では、コンストラクタのskipZeroClear(<code>public NativeMemoryArray(long length, bool skipZeroClear = false)</code>)によってゼロ初期化する/しないを選べます。デフォルトは（危ないので）初期化しています。非.NET 6版では、メモリ確保後に<code>Span&lt;T&gt;.Clear()</code>経由で初期化処理を入れています。</p>
<h2>真のArray.MaxValue</h2>
<p>.NET 6以前では、配列の要素数はバイト配列(1バイト構造体の配列)と、それ以外の配列で異なる値がリミットに設定されていました。例えば<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array?view=net-6.0">System.Arrayのドキュメント</a>を引いてくると</p>
<blockquote>
<p>配列のサイズは、合計で40億の要素に制限され、任意の次元の0X7FEFFFFF の最大インデックス (バイト配列の場合は0X7FFFFFC7、1バイト構造体の配列の場合) に制限されます。</p>
</blockquote>
<p>つまり、0X7FFFFFC7の場合と、0X7FEFFFFFの場合がある、と。</p>
<p>と、いうはずだったのですが、.NET 6から<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.maxlength">Array.MaxLength</a>というプロパティが新規に追加されて、これは単一の定数を返します。その値は、0X7FFFFFC7です。よって、いつのまにかひっそりと配列の限界値は(ちょびっと大きい方に)大統一されました。</p>
<p>この変更は意外とカジュアルに行われ、まず最大値を取得する、ただし単一じゃないため型によって結果の変わる <code>Array.GetMaxLength&lt;T&gt;()</code> を入れよう、<a href="https://github.com/dotnet/runtime/pull/43301">という実装があがってきました</a>。そうしたら、そのPR上での議論で、そもそも当初は最適化を期待したけど別にそんなことなかったし、統一しちゃってよくね？という話になり、そのまま限界値は統一されました。そして新規APIも無事、Array.MaxLengthという定数返しプロパティになりました。</p>
<p>まぁ、シンプルになって良いですけどね。大きい方で統一されたので実害も特にないでしょうし。前述のSystem.Arrayのドキュメントは更新されてないということで、正しくは、.NET 6からは0x7FFFFFC7が限界で、その値はArray.MaxLengthで取れる。ということになります。</p>
<p><code>Span&lt;T&gt;</code>の限界値はint.MaxValueなので、限界に詰め込んだ<code>Span&lt;T&gt;</code>をそのままToArray()すると死ぬ、という微妙な問題が発生することがあるんですが、まぁそこはしょうがないね。</p>
<h2>まとめ</h2>
<p>NativeArrayという名前にしたかったのですがUnityと被ってしまうので避けました。しょーがない。</p>
<p>着手当時はマネージド配列のチャンクベースで作っていたのですが(<a href="https://gist.github.com/neuecc/e6293b1d88244cf942753d6408b3e966">LargeArray.cs</a>)、Sliceが作りづらいし、ネイティブメモリでやったほうが出来ること多くて何もかもが圧倒的にいいじゃん、ということに作業進めている最中に気づいて、破棄しました。参照型の配列が作れるという点で利点はありますが、まぁ参照型で巨大配列なんて作らねーだろ、思うと、わざわざ実装増やして提供するメリットもないかな、とは。</p>
<p>配列はもう昔からあるのでint Lengthなのはしょうがないのですが、<code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>のLengthはlongであって欲しかったかなー、とは少し思っています。<a href="https://github.com/dotnet/apireviews/tree/main/2016/11-04-SpanOfT#spant-and-64-bit">2016年の段階でのSpanのAPIどうするかドキュメント</a>によると、候補は幾つかあったけど、結果的に配列踏襲のint Lengthになったそうで。2GBでも別に十分だろ、みたいなことも書いてありますが、いや、そうかなー？年にそこそこの回数でたまによく引っかかるんだけどねー？</p>
<p>そして2016年の議論時点ではなかった、C# 9.0で<a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/nint-nuint">nuint, nuint</a>が追加されたので、<code>nuint Span&lt;T&gt;/Memory&lt;T&gt;.Length</code>はありなんじゃないかな、と。</p>
<p>ただNativeMemoryArrayの開発当初は<code>nuint Length</code>で作っていたのですが、<code>AsSpan(nuint start, nuint length)</code>みたいなAPIは、カジュアルにintやlongを突っ込めなくて死ぬほど使いづらかったので、最終的にlongで統一することにしました。ので、<code>nuint Length</code>は、なしかな。つまり一周回って現状維持。そんなものかー、そんなもんですねー。</p>
</div>
<h1><a href="https://neue.cc/2021/12/04.html">.NET 6とAngleSharpによるC#でのスクレイピング技法</a></h1>
<ul class="date"><li>2021-12-04</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2021/csharplang">C# Advent Calendar 2021</a>の参加記事となっています。去年は2個エントリーしたあげく、1個すっぽかした（！）という有様だったので、今年は反省してちゃんと書きます。</p>
<p>スクレイピングに関しては10年前に<a href="https://neue.cc/2010/03/02_244.html">C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法</a>という記事でSGMLReaderを使ったやり方を紹介していたのですが、10年前ですよ、10年前！さすがにもう古臭くて、現在ではもっとずっと効率的に簡単にできるようになってます。</p>
<p>今回メインで使うのは<a href="https://anglesharp.github.io/">AngleSharp</a>というライブラリです。AngleSharp自体は2015年ぐらいからもう既に定番ライブラリとして、日本でも紹介記事が幾つかあります。が、いまいち踏み込んで書かれているものがない気がするので、今回はもう少しがっつりと紹介していきたいと思っています。それと直近Visual StudioのWatchウィンドウの使い方を知らん、みたいな話を聞いたりしたので、デバッグ方法の手順みたいなものを厚めに紹介したいなあ、という気持ちがあります！</p>
<p>AngleSharpの良いところは、まずはHTMLをパースしてCSSセレクターで抽出できるところです。以前はLINQ(to DOM)があればCSSセレクターじゃなくてもいいっす、WhereとSelectManyとDescendantsでやってきますよ、とか言ってましたが、そんなにきちんと構造化されてるわけじゃないHTMLを相手にするのにあたっては、CSSセレクターのほうが100億倍楽！CSSセレクターの文法なんて大したことないので、普通に覚えて使えってやつですね。SQLと正規表現とCSSセレクターは三大言語関係なく覚えておく教養、と。</p>
<p>もう一つは、それ自体でネットワークリクエストが可能なこと。FormへのSubmitなどもサポートして、Cookieも保持し続けるとかが出来るので、ログインして会員ページを弄る、といったようなクローラーが簡単に書けるんですね。この辺非常に良く出来ていて、もう自前クローラーなんて投げ捨てるしかないです。また、<a href="https://github.com/sebastienros/jint">Jint</a>というPure C#なJavaScriptインタプリタと統合したプラグインも用意されているので、JavaScriptがDOMをガリガリっと弄ってくる今風のサイトにも、すんなり対応できます。</p>
<p>AngleSharpの紹介記事では、よくHttpClientなどで別途HTMLを取ってきたから、それをAngleSharpのHtmlParserに読み込ませる、というやり方が書かれていることが多いのですが、取得も含めて全てAngleSharp上で行ったほうが基本的には良いでしょう。</p>
<p>ここまで来るとPure C#の軽量なヘッドレスブラウザとしても動作する、ということになるので、カジュアルなE2Eテストの実装基盤にもなり得ます。普通のユニットテストと並べて <code>dotnet test</code> だけでその辺もある程度まかなえたら、とても素敵なことですよね？がっつりとしたE2Eテストを書きたい場合は<a href="https://github.com/microsoft/playwright">Playwright</a>などを使わなければ、ということになってしまいますが、まずは軽い感じから始めたい、という時にうってつけです。C#で書けるし。いいことです。</p>
<h2>BrowingContextとQuerySelectorの基本</h2>
<p>まずはシンプルなHTMLのダウンロードと解析を。基本は <code>BrowsingContext</code> を作って、それをひたすら操作していくことになります。</p>
<pre><code class="language-csharp">// この辺で色々設定する
var config = Configuration.Default
    .WithDefaultLoader(); // LoaderはデフォではいないのでOpenAsyncする場合につける

// Headless Browser的なものを作る
using var context = BrowsingContext.New(config);

// とりあえずこのサイトの、右のArchivesのリンクを全部取ってみる
var doc = await context.OpenAsync(&quot;https://neue.cc&quot;);
</code></pre>
<p>OpenAsyncで取得できた <code>IDocument</code> をよしなにCSSセレクターで解析していくわけですが、ここで絞り込みクエリー作成に使うのがVisual StudioのWatchウィンドウ。（Chromeのデベロッパーツールなどで機械的に取得したい要素のCSSセレクターを取得できたりしますが、手セレクターのほうがブレなくルールは作りやすいかな、と）。</p>
<p>デバッガーを起動して、とりあえずウォッチウィンドウを開いておもむろに、Nameのところでコードを書きます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144583627-0c7982e4-4933-41f7-ba04-81836f10da8c.png" alt="image" /></p>
<p>ウォッチウィンドウは見たい変数を並べておく、お気に入り的な機能、と思いきや本質的にはそうじゃなくて、式を自由に書いて、結果を保持する、ついでに式自体も保持できるという、実質REPLなのです。代入もラムダ式もLINQも自由に書けるし、入力補完も普通に出てくる。Immediate Windowよりも結果が遥かに見やすいので、Immediate Windowは正直不要です。</p>
<p>デバッガー上で動いているので実データを自由に扱えるというところがいいですね。というわけで、ToHtml()でHTMLを見て、QuerySelectorAllをゆっくり評価しながら書いていきましょう。まずはサイドバーにあるので <code>.side_body</code> を出してみると、あれ、二個あるの？と。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144582934-371930f2-dbff-4341-9f92-87e27c56d477.png" alt="image" /></p>
<p>中開けてInnerHtml見ると、なるほどProfile部分とArchive部分、と。とりあえず後ろのほうで固定のはずなのでlast-childね、というところで一旦評価して大丈夫なのを確認した後に、あとはa、と。でここまでで期待通りの結果が取れていれば、コピペる。よし。</p>
<pre><code class="language-csharp">// 基本、QuerySelectorかQuerySelectorAllでDOMを絞り込む
var anchors = doc.QuerySelectorAll(&quot;.side_body:last-child a&quot;)
    .Cast&lt;IHtmlAnchorElement&gt;() // AngleSharp.Html.Dom
    .Select(x =&gt; x.Href)
    .ToArray();
</code></pre>
<p>単一の要素に絞り込んだ場合は、 <code>IHtml***</code> にキャストしてあげると扱いやすくなります(attributeのhrefのtextを取得、みたいにしなくていい)。頻出パターンなので、<code>QuerySelectorAll&lt;T&gt;</code>でCastもセットになってすっきり。</p>
<pre><code class="language-csharp">doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;)
</code></pre>
<p>せっかくなので、年に何本記事を書いていたかの集計を出してみたいと思います！URLから正規表現で年と月を取り出すので、とりあえずここでもウォッチウィンドウです。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144590970-34c3bff4-0f0b-4db3-a259-f37a6f1e5f40.png" alt="image" /></p>
<p>anchrosの[0]を確認して、これをデータソースとしてRegex.Matchを書いて、どのGroupに収まったのかを見ます。この程度だったら特にミスらないでしょー、と思いきや普通に割とミスったりするのが正規表現なので、こういうので確認しながらやっていけるのはいいですね。</p>
<p>後は普通の（？）LINQコード。グルーピングした後に、ひたすら全ページをOpenAsyncしていきます。記事の本数を数えるのはh1の数をチェックするだけなので、特に複雑なCSSセレクターは必要なし。本来はページングの考慮は必要ですが、一月単位だとページングが出てくるほどの記事量がないので、そこも考慮なしで。</p>
<pre><code class="language-csharp">var yearGrouped = anchors
    .Select(x =&gt;
    {
        var match = Regex.Match(x, @&quot;(\d+)/(\d+)&quot;);
        return new
        {
            Url = x,
            Year = int.Parse(match.Groups[1].Value),
            Month = int.Parse(match.Groups[2].Value)
        };
    })
    .GroupBy(x =&gt; x.Year);

foreach (var year in yearGrouped.OrderBy(x =&gt; x.Key))
{
    var postCount = 0;
    foreach (var month in year)
    {
        var html = await context.OpenAsync(month.Url);
        postCount += html.QuerySelectorAll(&quot;h1&quot;).Count(); // h1 == 記事ヘッダー
    }
    Console.WriteLine($&quot;{year.Key}年記事更新数: {postCount}&quot;);
}
</code></pre>
<p>結果は</p>
<pre><code>2009年記事更新数: 92
2010年記事更新数: 61
2011年記事更新数: 66
2012年記事更新数: 30
2013年記事更新数: 33
2014年記事更新数: 22
2015年記事更新数: 19
2016年記事更新数: 24
2017年記事更新数: 13
2018年記事更新数: 11
2019年記事更新数: 14
2020年記事更新数: 11
2021年記事更新数: 5
</code></pre>
<p>ということで右肩下がりでした、メデタシメデタシ。今年は特に書いてないなあ、せめて2ヶ月に1本は書きたいところ……。</p>
<p>なお、<a href="https://neue.cc/2021/11/21.html">C#による自家製静的サイトジェネレーターに移行した話</a>
で紹介しているのですが、このサイトは完全に<a href="https://github.com/neuecc/Blog2/tree/master/articles">GitHub上に.mdがフラットに並んで.mdが管理されている</a>ので、こういうの出すなら別にスクレイピングは不要です。</p>
<h2>UserAgentを変更する</h2>
<p>スクレイピングといったらログインしてごにょごにょする。というわけで、そうしたログイン処理をさくっとやってくれるのがAngleSharpの良いところです。ので紹介していきたいのですが、まずはやましいことをするので（？）、UserAgentを偽装しましょう。</p>
<p>AngleSharpが現在何を送っているのかを確認するために、とりあえずダミーのサーバーを立てます。その際には .NET 6 のASP .NET から搭載されたMinimal APIが非常に便利です！そしてそれを<a href="https://www.linqpad.net/">LINQPad</a>で動かすと、テスト用サーバーを立てるのにめっちゃ便利です！やってみましょう。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586706-aa067b51-d8d3-44ac-91b3-552c62e7ce6d.png" alt="image" /></p>
<p>たった三行でサーバーが立ちます。便利。</p>
<pre><code class="language-csharp">await context.OpenAsync(&quot;http://localhost:5000/headers&quot;);
</code></pre>
<p>でアクセスして、 <code>AngleSharp/1.0.0.0</code> で送られていることが確認できました。</p>
<p>なお、LINQPadでASP.NETのライブラリを使うには、Referene ASP.NET Core assembliesのチェックを入れておく必要があります。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144586956-fddb4821-59a3-4f37-9086-1624d471ed36.png" alt="image" /></p>
<p>他、よく使うNuGetライブラリや名前空間なども設定したうえで、<code>Set as default for new queries</code>しておくと非常に捗ります。</p>
<p>さて、で、このUser-Agentのカスタマイズの方法ですが、AngleSharpはServicesに機能が詰まっているようなDI、というかService Locatorパターンの設計になっているので、ロードされてるServicesを(Watch Windowで)一通り見ます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144601687-3ee78e1d-2f95-404f-b2f9-162deb8eeda0.png" alt="image" /></p>
<p>型に限らず全Serviceを取得するメソッドが用意されていない場合でも、<code>&lt;object&gt;</code>で取ってやると全部出てくるような実装は割と多い（ほんと）ので、とりあえずやってみるのはオススメです。今回も無事それで取れました。</p>
<p>で、型名を眺めてそれっぽそうなのを見ると <code>DefaultHttpRequester</code> というのがかなりそれっぽく、その中身を見るとHeadersという輩がいるので、これを書き換えればいいんじゃないだろうかと当たりがつきます。</p>
<p>ここはやましい気持ちがあるので（？）Chromeに偽装しておきましょう。</p>
<pre><code class="language-csharp">var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot;;
</code></pre>
<p>再びOpenAsyncしてLINQPadの表示を見て、変更されてること確認できました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/144602382-aba63413-2065-46ed-bd52-f4adf65bd30f.png" alt="image" /></p>
<p>ちなみに、DefaultじゃないHttpRequesterをConfigurationに登録しておく、ということも出来ますが、よほどカスタムでやりたいことがなければ、デフォルトのものをちょっと弄るぐらいの方向性でやっていったほうが楽です。</p>
<h2>FormにSubmitする</h2>
<p>クローラーと言ったらFormにSubmit、つまりログイン！そしてクッキーをいただく！認証！</p>
<p>さて、が、まぁ認証付きの何かを例にするのはアレなので、googleの検索フォームを例にさせていただきたいと思います。先にまずはコード全体像と結果を。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom; // 拡張メソッドとかで有効化されたりするのでusing大事
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies(); // login form的なものの場合これでクッキーを持ち歩く

using var context = BrowsingContext.New(config);

// お行儀悪いので（？）前述のこれやっておく
var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://google.com/&quot;);
var form = doc.Forms[0];
var result = await form.SubmitAsync(new { q = &quot;AngleSharp&quot; }); // name = valueは匿名型が使える

// とりあえず結果を表示しておく
var titles = result.QuerySelectorAll&lt;IHtmlHeadingElement&gt;(&quot;h3&quot;).Select(x =&gt; x.TextContent);
var i = 1;
foreach (var item in titles)
{
    Console.WriteLine($&quot;{i++:00}: {item}&quot;);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/46207/144704506-b0d7038f-ad26-42e4-b8dd-b63b250759c5.png" alt="image" /></p>
<p><code>WithDefaultLoader</code> と、そして認証クッキー持ち歩きのために <code>WithDefaultCookies</code> をコンフィギュレーションに足しておくことが事前準備として必須です。User-Agentの書き換えはご自由に、ただやましいこと、ではなくてUA判定をもとにして処理する、みたいなサイトも少なからずあるので、余計ないこと考えなくて済む対策としてはUAをChromeに偽装しておくのはアリです。</p>
<p>FormへのSubmit自体は3行というか2行です。ページをOpenしてFormに対してSubmitするだけ。超簡単。 <code>.Forms</code> で <code>IHtmlElementForms</code>がすっと取れるので、あとは単純にSubmitするだけです。渡す値は <code>{ name = value }</code>の匿名型で投げ込めばOK。</p>
<p>度々出てくるウォッチウィンドウの宣伝ですが、この何の値を投げればいいのか、を調べるのにHTMLとニラメッコではなく、ウォッチウィンドウで調査していきます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/146650708-d2f1beb1-c21b-4a0a-851b-d0e78628bc00.png" alt="image" /></p>
<p>まず(&quot;input&quot;)を拾うのですが、9個ある。多いね、で、まぁこれはほとんどtype = &quot;hidden&quot;なので無視して良い（AngleSharpがSubmitAsync時にちゃんと自動でつけて送信してくれる）。値を入れる必要があるのはhiddden以外のものなので、それをウォッチで普通にLINQで書けば、3件に絞れました。で、中身見ると必要っぽいのはqだけなので、 new { q = &quot;hogemoge&quot; } を投下、と。</p>
<p>認証が必要なサイトでは、これでBrowingContextに認証クッキーがセットされた状態になるので、以降のこのContextでのOpenや画像、動画リクエストは認証付きになります。</p>
<h2>画像や動画を拾う</h2>
<p>スクレイピングといったら画像集めマンです（？）。AngleSharpでのそうしたリソース取得のやり方には幾つかあるのですが、私が最も良いかな、と思っているのはIDocumentLoader経由でのフェッチです。</p>
<pre><code class="language-csharp">// BrowsingContextから引っ張る。Contextが認証クッキー取得済みなら認証が必要なものもダウンロードできる。
var loader = context.GetService&lt;IDocumentLoader&gt;();

// とりあえず適当にこのブログの画像を引っ張る
var response = await loader.FetchAsync(new DocumentRequest(new Url(&quot;https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png&quot;))).Task;

using var ms = new MemoryStream();
await response.Content.CopyToAsync(ms);

var bytes = ms.ToArray(); // あとは適当にFile.WriteAllBytesでもなんでもどうぞ
</code></pre>
<p>内部用なので少し引数やAPIが冗長なところもありますが、それは後述しますが別になんとでもなるところなので、どちらかというと生のStreamが取れたりといった柔軟性のところがプラスだと思っています。普通にHttpClientで自前で取るのと比べると、認証周りやってくれた状態で始められるのが楽ですね。</p>
<p>並列ダウンロードもいけます、例えば、このブログの全画像を引っ張るコードを、↑に書いた全ページ取得コードを発展させてやってみましょう。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://neue.cc/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

foreach (var arvhives in doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;.side_body:last-child a&quot;))
{
    var page = await context.OpenAsync(arvhives.Href);

    // content(ページ本体)下のimgを全部。
    // 今回はページ単位で5並列ダウンロードすることにする(粒度の考え方は色々ある)
    var imgs = page.QuerySelectorAll&lt;IHtmlImageElement&gt;(&quot;#content img&quot;);
    await Parallel.ForEachAsync(imgs, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (img, ct) =&gt;
     {
         var url = new Url(img.Source);
         var response = await loader.FetchAsync(new DocumentRequest(url)).Task;

         // とりあえず雑にFile書き出し。
         Console.WriteLine($&quot;Downloading {url.Path}&quot;);
         using (var fs = new FileStream(@$&quot;C:\temp\neuecc\{url.Path.Replace('/', '_')}&quot;, FileMode.Create))
         {
             await response.Content.CopyToAsync(fs, ct);
         }
     });
}
</code></pre>
<p>.NET 6から <a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.parallel.foreachasync">Parallel.ForEachAsync</a> が追加されたので、asyncコードを並列数(MaxDegreeOfParallelism)で制御した並列実行が容易に書けるようになりました。async/await以降、Parallel系の出番は圧倒的に減ったのは確かなのですが、Task.WhenAllだけだと並列に走りすぎてしまって逆に非効率となってしまって、そこを制御するコードを自前で用意する必要が出てきていたりと面倒なものも残っていました。それが、このParallel.ForEachAsyncで解消されたと思います。</p>
<h2>Kurukuru Progress</h2>
<p>数GBの動画をダウンロードする時などは、プログレスがないとちゃんと動いているのか確認できなくて不便です。しかし、ただ単にConsole.WriteLineするだけだとログが凄い勢いで流れていってしまって見辛くて困りものです。そこを解決するC#ライブラリが<a href="https://github.com/mayuki/Kurukuru">Kurukuru</a>で、見ればどんなものかすぐわかるので、まずは実行結果を見てもらいましょう（素の回線だと一瞬でダウンロード終わってしまったので回線の低速シミュレーションしてます）</p>
<p><img src="https://user-images.githubusercontent.com/46207/144711389-7fa99e14-3f77-4fef-a7e7-5d12724aacd1.gif" alt="guruguru" /></p>
<p>一行だけを随時書き換えていってくれるので、見た目も非常に分かりやすくて良い感じです。これはとても良い。Kurukuru、今すぐ使いましょう。ちなみに今回の記事で一番時間がかかったのは、Kurukuruの並列リクエスト対応だったりして（対応していなかったのでコード書いてPR上げて、今日リリースしてもらいましたできたてほやほやコード）。</p>
<p>AngleSharp側のコードですが、この例は<a href="https://file-examples.com/index.php/sample-video-files/sample-mp4-files/">File Examples
</a>のMP4を並列で全部取るというものです。</p>
<pre><code class="language-csharp">using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;
using Kurukuru;
using System.Text;

// Kurukuruを使う上で大事なおまじない
// え、デフォルトのEncodingがUTF8じゃないシェルがあるんです！？←Windows
Console.OutputEncoding = Encoding.UTF8;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&lt;DefaultHttpRequester&gt;();
requester.Headers[&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&quot;;

var doc = await context.OpenAsync(&quot;https://file-examples.com/index.php/sample-video-files/sample-mp4-files/&quot;);
var loader = context.GetService&lt;IDocumentLoader&gt;();

// ここから本体
var mp4s = doc.QuerySelectorAll&lt;IHtmlAnchorElement&gt;(&quot;a&quot;).Where(x =&gt; x.Href.EndsWith(&quot;.mp4&quot;));
Console.WriteLine(&quot;Download sample-mp4-files&quot;);
await Parallel.ForEachAsync(mp4s, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (mp4, ct) =&gt;
{
    var bin = await loader.FetchBytesAsync(mp4.Href);
    // あとはFile.WriteAllBytesするとか好きにして
});
</code></pre>
<p>ポイントは <code>var bin = await loader.FetchBytesAsync(mp4.Href);</code> で、これは拡張メソッドです。loaderにProgress付きでbyte[]返すメソッドを生やしたことで、随分シンプルに書けるようになりました。StreamのままFileStreamに書いたほうがメモリ節約的にはいいんですが、中途半端なところでコケたりした場合のケアが面倒くさいので、ガチガチなパフォーマンスが重視される場合ではないならbyte[]のまま受けちゃってもいいでしょう。1つ4GBの動画を5並列なんですが？という場合でも、たかがメモリ20GB程度なので普通にメモリ積んで処理すればいいっしょ。</p>
<p>FetchBytesAsyncの中身は以下のようなコードになります。</p>
<pre><code class="language-csharp">public static class DocumentLoaderExtensions
{
    public static async Task&lt;byte[]&gt; FetchBytesAsync(this IDocumentLoader loader, string address, CancellationToken cancellationToken = default)
    {
        var url = new AngleSharp.Url(address);
        var response = await loader.FetchAsync(new DocumentRequest(url)).Task;
        if (response.StatusCode != System.Net.HttpStatusCode.OK)
        {
            return Array.Empty&lt;byte&gt;(); // return empty instead of throws error(ここをどういう挙動させるかは好みで……。)
        }

        // Content-Lengthが取れない場合は死でいいということにする
        var contentLength = int.Parse(response.Headers[&quot;Content-Length&quot;]);

        using var progress = new ProgressSpinner(url.Path.Split('/').Last(), contentLength);
        try
        {
            return await ReadAllDataAsync(response.Content, contentLength, progress, cancellationToken);
        }
        catch
        {
            progress.Cancel();
            throw;
        }
    }

    static async Task&lt;byte[]&gt; ReadAllDataAsync(Stream stream, int contentLength, IProgress&lt;int&gt; progress, CancellationToken cancellationToken)
    {
        var buffer = new byte[contentLength];
        var readBuffer = buffer.AsMemory();
        var len = 0;
        while ((len = await stream.ReadAsync(readBuffer, cancellationToken)) &gt; 0)
        {
            progress.Report(len);
            readBuffer = readBuffer.Slice(len);
        }
        return buffer;
    }
}

public class ProgressSpinner : IProgress&lt;int&gt;, IDisposable
{
    readonly Spinner spinner;
    readonly string fileName;
    readonly int? totalBytes;
    int received = 0;

    public ProgressSpinner(string fileName, int? totalBytes)
    {
        this.totalBytes = totalBytes;
        this.fileName = fileName;
        this.spinner = new Spinner($&quot;Downloading {fileName}&quot;);
        this.spinner.Start();
    }

    public void Report(int value)
    {
        received += value;
        if (totalBytes != null)
        {
            var percent = (received / (double)totalBytes) * 100;
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)} / {ToHumanReadableBytes(totalBytes.Value)} ( {Math.Floor(percent)}% )&quot;;
        }
        else
        {
            spinner.Text = $&quot;Downloading {fileName} {ToHumanReadableBytes(received)}&quot;;
        }
    }

    public void Cancel()
    {
        spinner.Fail($&quot;Canceled {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    public void Dispose()
    {
        spinner.Succeed($&quot;Downloaded {fileName}: {ToHumanReadableBytes(received)}&quot;);
        spinner.Dispose();
    }

    static string ToHumanReadableBytes(int bytes)
    {
        var b = (double)bytes;
        if (b &lt; 1024) return $&quot;{b:0.00} B&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} KB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} MB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} GB&quot;;
        b /= 1024;

        if (b &lt; 1024) return $&quot;{b:0.00} TB&quot;;
        b /= 1024;

        return $&quot;{0:0.00} PB&quot;;
    }
}
</code></pre>
<p>KurukuruのSpinnerを内包した <code>IProgress&lt;T&gt;</code> を作ってあげて、その中でよしなにやってあげるということにしました。まぁちょっと長いですが、一回用意すれば後はコピペするだけなので全然いいでしょう。みなさんもこのProgressSpinner、使ってやってください。</p>
<h2>コマンド引数やロギング処理やオプション取得</h2>
<p>クローラーとしてガッツシやりたいなら、モードの切り替えとかロギングとか入れたいです、というか入れます。そこで私が定形として使っているのは<a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a>と<a href="https://github.com/Cysharp/ZLogger">ZLogger</a>。Cysharpの提供です。ワシが作った。それと今回のようなケースだと<a href="https://github.com/Cysharp/Kokuban">Kokuban</a>も便利なので入れます。やはりCysharpの提供です。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;AngleSharp&quot; Version=&quot;1.0.0-alpha-844&quot; /&gt;
    &lt;PackageReference Include=&quot;Kurukuru&quot; Version=&quot;1.4.0&quot; /&gt;
    &lt;PackageReference Include=&quot;ConsoleAppFramework&quot; Version=&quot;3.3.2&quot; /&gt;
    &lt;PackageReference Include=&quot;ZLogger&quot; Version=&quot;1.6.1&quot; /&gt;
    &lt;PackageReference Include=&quot;Kokuban&quot; Version=&quot;0.2.0&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>この場合Program.csは以下のような感じになります。割と短いですよ！</p>
<pre><code class="language-csharp">using ConsoleAppFramework;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Text;
using ZLogger;

Console.OutputEncoding = Encoding.UTF8;

await Host.CreateDefaultBuilder()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.AddZLoggerConsole();
        x.AddZLoggerFile($&quot;logs/{args[0]}-{DateTime.Now.ToString(&quot;yyyMMddHHmmss&quot;)}.log&quot;);
    })
    .ConfigureServices((hostContext, services) =&gt;
    {
        services.Configure&lt;NanikaOptions&gt;(hostContext.Configuration.GetSection(&quot;Nanika&quot;));
    })
    .RunConsoleAppFrameworkAsync(args);

public class NanikaOptions
{
    public string UserId { get; set; } = default!;
    public string Password { get; set; } = default!;
    public string SaveDirectory { get; set; } = default!;
}
</code></pre>
<p>コンソールログだけだとウィンドウ閉じちゃったときにチッとかなったりするので（？）、ファイルログあると安心します。ZLoggerは秘伝のxmlコンフィグなどを用意する必要なく、これだけで有効化されるのが楽でいいところです。それでいてパフォーマンスも抜群に良いので。</p>
<p>ConsoleAppFrameworkはGenericHostと統合されているので、コンフィグの読み込みもOptionsで行います。appsettings.jsonを用意して</p>
<pre><code class="language-json">{
  &quot;Nanika&quot;: {
    &quot;UserId&quot;: &quot;hugahuga&quot;,
    &quot;Password&quot;: &quot;takotako&quot;,
    &quot;SaveDirectory&quot;: &quot;C:\\temp\\dir&quot;,
  }
}
</code></pre>
<p>.csprojのほうに</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;None Update=&quot;appsettings.json&quot;&gt;
    &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>と書いてあげれば、自動で読み込まれるようになるという仕様です。そして本体のコードは</p>
<pre><code class="language-csharp">public class NanikaDownloader : ConsoleAppBase
{
    readonly ILogger&lt;NanikaDownloader&gt; logger;
    readonly NanikaOptions options;

    // コンストラクタインジェクションでOptionsを受け取る
    public NanikaDownloader(ILogger&lt;NanikaDownloader&gt; logger, IOptions&lt;NanikaOptions&gt; options)
    {
        this.logger = logger;
        this.options = options.Value;
    }

    public async Task DownloadAre()
    {
        // Context.CancellationTokenを渡すのを忘れないように！(Ctrl+Cのキャンセル対応に必須)
        await loader.FecthAsyncBytes(&quot;...&quot;, Context.CancellationToken)
    }

    public async Task DownloadSore(int initialPage)
    {
        // Kokubanを使うとConsoleに出す文字列の色分けが簡単にできる！( `Chalk.Color +` だけで色が付く)
        logger.LogInformation(Chalk.Green + $&quot;Download sore {initialPage} start&quot;);
    }
}
</code></pre>
<p>のように書きます。これの場合は、引数で <code>NanikaDownloader.DownloadAre</code>, <code>NanikaDownloader.DownloadSore -initialPage *</code> の実行切り替えができるようになるわけですね……！</p>
<p>また、文字色が一色だけだとコンソール上のログはかなり見づらいわけですが、Kokubanを使うことで色の出し分けが可能になります。これは、地味にめちゃくちゃ便利なのでおすすめ。別にバッチ系に限らず、コンソールログの色を調整するのってめっちゃ大事だと、最近実感しているところです。</p>
<p>ASP .NET Core(とかMagicOnionとか)で、ZLoggerでエラーを赤くしたい！とか、フレームワークが吐いてくる重要でない情報はグレーにして目立たなくしたい！とかの場合は、ZLoggerのPrefix/SuffixFormatterを使うのをオススメしてます(Kokubanのようにさっくり書けはしないのですが、まぁConfigurationのところで一回やるだけなので)</p>
<pre><code class="language-csharp">logging.AddZLoggerConsole(options =&gt;
{
#if DEBUG
    // \u001b[31m =&gt; Red(ANSI Escape Code)
    // \u001b[0m =&gt; Reset
    // \u001b[38;5;***m =&gt; 256 Colors(08 is Gray)
    options.PrefixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error)
        {
            ZString.Utf8Format(writer, &quot;\u001b[31m[{0}]&quot;, info.LogLevel);
        }
        else
        {
            if (!info.CategoryName.StartsWith(&quot;MyApp&quot;)) // your application namespace.
            {
                ZString.Utf8Format(writer, &quot;\u001b[38;5;08m[{0}]&quot;, info.LogLevel);
            }
            else
            {
                ZString.Utf8Format(writer, &quot;[{0}]&quot;, info.LogLevel);
            }
        }
    };
    options.SuffixFormatter = (writer, info) =&gt;
    {
        if (info.LogLevel == LogLevel.Error || !info.CategoryName.StartsWith(&quot;MyApp&quot;))
        {
            ZString.Utf8Format(writer, &quot;\u001b[0m&quot;, &quot;&quot;);
        }
    };
#endif

}, configureEnableAnsiEscapeCode: true); // configureEnableAnsiEscapeCode
</code></pre>
<p>こういうの、地味に開発効率に響くので超大事です。やっていきましょう。</p>
<h2>まとめ</h2>
<p>AngleSharpにかこつけてウォッチウィンドウをとにかく紹介したかったのです！ウォッチウィンドウ最強！値の変化があると赤くなってくれたりするのも便利ですね、使いこなしていきましょう。別にUnityとかでもクソ便利ですからね？</p>
<p>あ、で、AngleSharpはめっちゃいいと思います。他の言語のスクレピングライブラリ(Beautiful Soupとか)と比べても、全然張り合えるんじゃないかな。冒頭に書きましたがE2Eテストへの応用なども考えられるので、使いこなし覚えるのとてもいいんじゃないかと思います。ドキュメントが色々書いてあるようで実は別にほとんど大したこと書いてなくて役に立たないというのは若干問題アリなんですが、まぁ触って覚えるでもなんとかなるので、大丈夫大丈夫。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
