<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="./pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2009-08-23" data-pagefind-meta="published:2009-08-23"><a href="https://neue.cc/2009/08/23_192.html">簡易文字列置換</a></h1>
<ul class="date"><li>2009-08-23</li></ul>
<div class="entry_body"><pre data-pagefind-ignore="all"><code class="language-csharp">static void Main(string[] args)
{
    // {}で括った部分を(ラムダ式/匿名型)を使って置換する
    var input = &quot;食べ物は{tabemono}で飲み物は{nomimono}&quot;;
    var r1 = input.Replace(new { tabemono = &quot;たこ焼き&quot;, nomimono = &quot;コーラ&quot; });
    var r2 = input.Replace(tabemono =&gt; &quot;たこ焼き&quot;, nomimono =&gt; &quot;コーラ&quot;);
}
</code></pre>
<p>前も書いたというか<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">JavaScriptでやりました</a>が、それのC#移植。簡易テンプレート的な文字列置換。ラムダ式版と匿名型版の二つでやってみました。ラムダ式だと、見た目が少し短くて何となく格好良いのですが、変数名の入力時にIntelliSenseが動いてしまうので結構鬱陶しかったり。匿名型のほうはObjectを受け取る関数なので、危なっかしいのが嫌ですね……。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static class Extensions
{
    // 正規表現の|でキーを連結して辞書から置換
    private static string Replace(string input, Dictionary&lt;string, string&gt; dict)
    {
        var pattern = string.Format(&quot;{{({0})}}&quot;, dict.Select(kvp =&gt; Regex.Escape(kvp.Key)).ToJoinedString(&quot;|&quot;));
        return Regex.Replace(input, pattern, m =&gt; dict[m.Groups[1].Value]);
    }

    /// &lt;param name=&quot;anonymousType&quot;&gt;{pattern = &quot;replacement&quot;}&lt;/param&gt;
    public static string Replace(this string input, Object anonymousType)
    {
        var dict = anonymousType.GetType()
            .GetProperties()
            .ToDictionary(pi =&gt; pi.Name, pi =&gt; pi.GetValue(anonymousType, null).ToString());
        return Replace(input, dict);
    }

    /// &lt;param name=&quot;exprs&quot;&gt;pattern =&gt; &quot;replacement&quot;&lt;/param&gt;
    public static string Replace(this string input, params Expression&lt;Func&lt;Object, string&gt;&gt;[] exprs)
    {
        var dict = exprs.ToDictionary(e =&gt; e.Parameters[0].Name, e =&gt; e.Compile().Invoke(null));
        return Replace(input, dict);
    }

    // 文字列連結補助メソッド(これないとシンドイので)
    public static string ToJoinedString&lt;T&gt;(this IEnumerable&lt;T&gt; source, string separator)
    {
        var index = 0;
        return source.Aggregate(new StringBuilder(),
                (sb, o) =&gt; (index++ == 0) ? sb.Append(o) : sb.AppendFormat(&quot;{0}{1}&quot;, separator, o))
            .ToString();
    }
}
</code></pre>
<p>速度は、匿名型版のほうが圧倒的に速いです。100000回の繰り返しが匿名型だと2秒なのに対してラムダ式版は30秒かかった。Compile().Invokeがアレなんですかねえ。ちなみに、string.Formatでふつーにやった場合は0.03秒でした。まー、でも、メール雛型の置換に、とかちょっとしたことにそこそこ便利に使えるかなー、とは思いつつもっと効率考えてちゃんと組んだ方がいい気もする。</p>
<p>ラムダ式から取り出すのは<a href="http://d.hatena.ne.jp/NyaRuRu/20071211/p3">C# 3.0 における疑似 Map 生成リテラル - NyaRuRuの日記</a>から、匿名型はprototype.jsとかPHPのstrtrとか色々。あと<a href="http://d.hatena.ne.jp/NyaRuRu/20080706/p1">ややニッチな Anonymous Types の使い方をまとめてみる (C# 3.0) - NyaRuRuの日記</a>です。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-22" data-pagefind-meta="published:2009-08-22"><a href="https://neue.cc/2009/08/22_191.html">ver 0.0.0.3</a></h1>
<ul class="date"><li>2009-08-22</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>拡張子が大文字だとアップロード出来なかったので直しました。XboxInfoTwitの時も同じのやってたのにまたかよって感じです。拡張子判定部分は、ちゃんとIgnoreCaseにしたしあれえ？と思ってたんですがContentType作るところで漏れがあって、ウッカリ。てへ。</p>
<p>まあ、そんなこんなでちゃんと一眼レフも買いました。わざわざこのためだけに！<a href="http://f.hatena.ne.jp/neuecc/" title="neuecc's fotolife">neuecc's fotolife</a> 。それで、しかし撮るものが悲しいほど無いんですよね、やっぱり。とはいえ、自分で撮って自分で上げてかないと、何をどうすれば良くなるのか分からないので、室内写真で栄える何かを探し中です。現在は多肉植物でも育てようかな、と思ってるんですがどうでしょうかねえ。</p>
<p>ちなみに現在までのDL数は余裕で一桁。べ、別に悲しくないもん！ そういえばこの半自動ってぶっちゃけ機能的にいらなくね？むしろフォルダ監視で自動化したほうがよくね？とも思ってきたので、まあ、そのうち。そのうち。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-21" data-pagefind-meta="published:2009-08-21"><a href="https://neue.cc/2009/08/21_190.html">ネストした三項演算子の書き方</a></h1>
<ul class="date"><li>2009-08-21</li></ul>
<div class="entry_body"><p><a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1027163420" title="javaプログラムの組み方がわかりませんorz 無理な課題を学校で出されました(´･_･... - Yahoo!知恵袋">javaプログラムの組み方がわかりませんorz 無理な課題を学校で出されました(´･_･... - Yahoo!知恵袋</a></p>
<p>「小学生向けの四則演算の計算練習のプログラムを考える」……？ 回答のJavaコードが長くてよくわからにゃい。ぽりもふぃずむって何？</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/condoperator.jpg">
</p>
 
これでおｋ。最近、三項演算子の:は後置が普通だけど、前置にすると[F#のパターンマッチ](http://msdn.microsoft.com/en-us/library/dd233242(VS.100).aspx)みたいで格好良くね？とか思うので、開き直って前置にしたいです。これはコーディング規約に載せるべきですね(笑) あと三項演算子の、うにゃ、条件演算子の条件は必ずカッコで括る派。
</div>
<h1 data-pagefind-sort="date:2009-08-18" data-pagefind-meta="published:2009-08-18"><a href="https://neue.cc/2009/08/18_189.html">LINQ to XMLのNamespaceと書き出し時のEncodingについて</a></h1>
<ul class="date"><li>2009-08-18</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>ver 0.0.0.2に更新。アップロードするフォルダが指定出来るようになりました。アップロードツール名(FotolifeUploader)が利用されるようになりました。フォルダ指定は再設定が必要なので、前のバージョンを使っている方はsettings.xmlを削除して、再度設定し直してください。あとは間抜けだったUploadToFotolifeメソッドを手直ししたり。</p>
<p>私自身が、そもそもフォトライフのヘビーユーザーではないので、細かいところに気が利いてないかもですね……。そういうのは、よくない。というわけで、当分はFotolifeをちゃんと利用しようキャンペーンを張ることにします。なので、デジタル一眼を買う。と言いたいのだけど、何か微妙なのよねん。いや、そもそも引き籠って家から出ないので撮影するものがないので。かといって熱帯魚や食虫植物とかフィギュアとか、撮影に適した趣味があるわけでもなく。困った困った。まあ、考えます。食虫植物を育てる方向で(？) 部屋が殺風景なので何かは入れたいのだけど、手間はかけたくない。ううむ、難しい。</p>
<h2>LINQ to XML</h2>
<p>アップロードにはAtomAPIを利用しているので、XMLです。つまりLINQ to XMLの出番です。出力結果がこんな感じなので、そこから逆に考えると……</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;entry xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns=&quot;http://purl.org/atom/n
s#&quot;&gt;
  &lt;title&gt;タイトル&lt;/title&gt;
  &lt;content mode=&quot;base64&quot; type=&quot;image/jpeg&quot;&gt;画像BASE64&lt;/content&gt;
  &lt;generator&gt;FotolifeUploader&lt;/generator&gt;
  &lt;dc:subject&gt;フォルダ名&lt;/dc:subject&gt;
&lt;/entry&gt;
</code></pre>
<p>XElementは、Namespaceの利用が少しややこしいんですよね。最初引っかかりました。「XNamespace.Xmlns + &quot;接頭辞&quot;」で登録できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">XNamespace ns = &quot;http://purl.org/atom/ns#&quot;;
XNamespace dc = &quot;http://purl.org/dc/elements/1.1/&quot;;
var xml =
    new XDocument(new XDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, null),
    new XElement(ns + &quot;entry&quot;, new XAttribute(XNamespace.Xmlns + &quot;dc&quot;, dc),
        new XElement(ns + &quot;title&quot;, &quot;タイトル&quot;),
        new XElement(ns + &quot;content&quot;, new XAttribute(&quot;mode&quot;, &quot;base64&quot;), new XAttribute(&quot;type&quot;, &quot;image/jpeg&quot;), &quot;画像BASE64&quot;),
        new XElement(ns + &quot;generator&quot;, &quot;FotolifeUploader&quot;),
        new XElement(dc + &quot;subject&quot;, &quot;フォルダ名&quot;)
    ));
Console.WriteLine(xml); // 出力確認、DeclarationはToStringでは出力されない
</code></pre>
<p>少し独特ですが、ほとんど1:1で対応させられるので慣れるとサクサク書けます。非常に快適。個人的にはXMLリテラル的なものよりも好き。Linqがあってほんと良かった……。で、Declarationを出力したい場合の話に続く。<a href="http://d.hatena.ne.jp/Nobuhisa/20080914/1221326352">(hatena (diary ’Nobuhisa))</a>にもあるように、ToStringでは出力されないのでSaveを使う、と……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var sb = new StringBuilder();
var sw = new StringWriter(sb);
xml.Save(sw);
Console.WriteLine(sb); // UTF-16になる
</code></pre>
<p>これでencodingがUTF-16になるのは、Saveメソッド呼ぶとDeclarationは作りなおしているから。.Save(&quot;string fileName&quot;)ではXDeclarationのエンコーディングを見て、それで保存するけれど、それ以外の場合はXDeclaration無視で再構築される。XDocumentというかXmlWriterのほうの話でしょうか。実際にファイル出力してみると分かる。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var fs = new FileStream(@&quot;C:\text.xml&quot;, FileMode.Create);
var sw = new StreamWriter(fs, Encoding.GetEncoding(&quot;x-mac-turkish&quot;));
xml.Save(sw);
</code></pre>
<p>出力先のエンコードに合わせてくれる、のを便利と見るか、むしろ気が利かない、Writer部分もC#3.0に合わせて作りなおせ、なのかは不明。まあ、嘘エンコード宣言は許しませんよってことですかね。じゃあどうするか、って言ったら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// これで別に何も問題ないと思います、文字列として吐くんだからToStringでいいと思ふ
var xmlString = string.Format(&quot;{0}{1}{2}&quot;,
    xml.Declaration, Environment.NewLine, xml);
Console.WriteLine(xmlString);

// ToStringがどうしても嫌ならMemoryStream経由で、とか？
string result;
var encoding = Encoding.UTF8;
using (var ms = new MemoryStream())
using (var sw = new StreamWriter(ms, encoding))
{
    xml.Save(sw);
    result = encoding.GetString(ms.ToArray());
}
Console.WriteLine(result); // 望み通りのUTF-8で出力されてます
</code></pre>
<p>結論は、普通にToStringでいいんじゃないかな、と。ToStringメソッドだけではXmlWriterSettingsで言うところのOmitXmlDeclarationを設定出来ないから、デフォルトでは付加しないようにしてる。削除は無理だけど、追加なら簡単だから。XmlDeclarationを付加したい時は別途、自分でくっつければいい。というだけのお話かなー？ ToStringで一発で終わらせられないからStringBuilder使って組み立てるってのは、何でそうなるの？と、とても思った。ついでにもう一つ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなXElementがあるとして
var xElement = XElement.Parse(&quot;&lt;hoge&gt;3&lt;/hoge&gt;&quot;);
// intとして値を取り出す時は
var num1 = int.Parse(xElement.Value); // これダメ。
var num2 = (int)xElement; // こう書こう。
</code></pre>
<p>です。LINQ to XMLは既存のものを上手く使ってシンプルに書けるように作られてる。気がする。このキャストもそうだし、ToStringもそう。Parseは頻繁に行うから汚くなるよね→キャストでよくね？ 文字列化はよくやるけどSaveもXmlWriterSettingsも面倒くさいよね→ToStringでよくね？ といった感じ。関数型構築もそうだけど、今までのもの(XmlDocument)を踏まえて、よく練り直されているなー、と思います。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-17" data-pagefind-meta="published:2009-08-17"><a href="https://neue.cc/2009/08/17_187.html">半自動はてなフォトライフアップローダー ver 0.0.0.1</a></h1>
<ul class="date"><li>2009-08-17</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>はてなフォトライフに画像をワンクリックでアップロードするプログラムです。ワンクリックの手間があるので、半自動。主な機能は、実行すると設定したフォルダの最新の更新画像一枚をアップロード。利用例としてデジカメ接続時やメモリーカード内の画像フォルダを指定することを想定しています。写真撮る→PCに繋げる→プログラムを実行する→アップロード完了。みたいな流れです。Twitterに載せるための写真とか最新一枚で十分でしょう？ Blogに載せる場合でも、一枚で済む場合って結構多いよね。そんな感じに、サクサクッと写真と付き合えたらいいな、と。</p>
<h2>設定</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader2.jpg">
</p>
<p>まさかのCUI設定画面(笑) 初回起動時にこの画面になります。設定し直したい時は、生成されるsettings.xmlを削除してください。レトロでアナログで半自動を貫く感じがいいかなー、と思ったんですが、どうでしょう。</p>
<h2>最新画像一枚のアップロード</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader.jpg">
</p>
<p>設定終了後にexeファイルを実行すると、設定時に指定したフォルダの中の、拡張子が「jpg/jpeg/gif/png/bmp」で更新日時が最も新しいもの一枚をアップロードします。設定によってはアップロード後にブラウザでフォトライフのURLが開きます。なので、そこからそのままTwitterにURLをポストするなりBlog書くなりがシームレスに行えるわけです。キリッ。ちなみにリサイズ等はこちら側では一切しません、そのまま丸投げ。リサイズ処理もはてな任せ。</p>
<h2>任意画像複数枚のアップロード</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader3.jpg">
</p>
<p>フォルダ/画像をまとめてexeファイル(本体じゃなくてショートカットでもOKです)にドラッグアンドドロップすると、そのファイルをアップロードします。フォルダはサブディレクトリを含めて全てのファイルをアップロードします。拡張子が「jpg/jpeg/gif/png/bmp」以外のものはちゃんと無視しますので、多少適当でも大丈夫。また、いわゆる「送る」にショートカットを登録することで、このドラッグアンドドロップと同様の結果になります。Vistaの場合はエクスプローラー上で「%AppData%\Microsoft\Windows\SendTo」と入力するとSendToのフォルダに飛べますので、ここにショートカットを登録してみてください。</p>
<p>今回コンソールアプリにしたのは、実行にかかる手間を最小にしたかった、というのがあります。普通のアップロードアプリだと、「アプリを起動→画像フォルダを開く→ドラッグアンドドロップで画像を乗っける→アップロードボタンを押す→アプリを閉じる→Fotolifeにアップロードされた画像を確認しにいく」 これじゃあ工程多すぎであまりにも面倒くさい。というわけで、最新画像一枚ならば、アプリ起動だけで完了。複数毎でも画像フォルダ→ドラッグアンドドロップだけで完了という、考え得る限りの最短を目指しています。</p>
<h2>ソースコード</h2>
<p>ソースコードも同梱してあります。csファイル一つだけの、200行ちょいのちっぽいコンソールアプリです。好きに改変とか突っ込みとかディスとかしてください。しいていえば、Linqだらけです。個人的には</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">.SelectMany(s =&gt; (Directory.Exists(s))
  ? Directory.GetFiles(s, &quot;*&quot;, SearchOption.AllDirectories)
  : Enumerable.Repeat(s, 1))
.Select(s =&gt; new FileInfo(s))
.Where(fi =&gt; fi.Exists &amp;&amp; FotolifeExtensionPattern.IsMatch(fi.Extension))
</code></pre>
<p>この部分が気に入ってます。ドラッグアンドドロップで来る文字列配列からファイル抜き出しの部分。SelectManyでディレクトリをファイル名配列に、ディレクトリじゃない場合はEnumerable.Repeatで繰り返し回数が1回のファイル名配列にする。あとはまあ普通に、SelectしてWhereしてToArray。Linqがあって良かったーと本当に思う。逆にAtomPub APIでアップロードする部分はLinqでやる意味がなかったというか、当初予定と変わってあれ追加これ追加で肥大化してしまった結果でして……。</p>
<p>LLの人はこの手のちょっとしたスクリプトをほいほい公開しているわけだから、C#もコンソールアプリぐらいほいほい公開出来ないといかんのぅ、と思いつつもページ用意して云々かんぬんは面倒くさくて、そうホイホイってわけにもいかない感じ。もちっと軽くやれる環境作らないとね……。まあ、でも、このちょっとした重苦しさも悪くはないんだ。だってほら、Rubyでスクリプトがホイッって転がってても、普通の人は動かせもしないわけですよ。だから、少し面倒くさいなー、と思いつつ設定画面つけてexeの形式にして、それだけで幸せになれないかな、どうだろう。</p>
<p>私はプログラム書き始めたのがほんとつい最近で、利用するだけ人間の歴が何年も何年もあるので、その辺は極力優しくやりたいなあ、と思ってます。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-13" data-pagefind-meta="published:2009-08-13"><a href="https://neue.cc/2009/08/13_185.html">可変のLookup</a></h1>
<ul class="date"><li>2009-08-13</li></ul>
<div class="entry_body"><p><a href="http://d.hatena.ne.jp/griefworker/20090611/multi_dictionary" title="一対多の Dictionary が欲しい - present">一対多の Dictionary が欲しい - present</a></p>
<p>今だと、やっぱLookupがあるので、ILookupの実装という形で作った方が統一感取れていいのかな……？ 通常のLookupはToLookupでしか作成できず不変なので、追加したり削除したり出来るILookupの実装を作りました。MultiDictionaryとかMultiMapとか言われているもの、ですが名前をimmutableの反対なのでMutableLookupとしてみました。かなり、微妙。名前ってむつかしい。んで、中身はDictionary&lt;TKey, List&lt;TValue&gt;&gt;のゆるふわラッピング。コンストラクタでIEqualityComparerを突っ込めるので、大文字小文字無視とかも出来ます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな風に使います
var mutableLookup = new MutableLookup&lt;string, string&gt;();
mutableLookup.Add(&quot;食べ物&quot;, &quot;たこやき&quot;);
mutableLookup.AddRange(&quot;食べ物&quot;, new[] { &quot;いかやき&quot;, &quot;さかなやき&quot; });
mutableLookup.Add(&quot;飲み物&quot;, &quot;ぽかり&quot;);

IEnumerable&lt;string&gt; tabemono = mutableLookup[&quot;食べ物&quot;]; // インデクサでアクセス
foreach (var item in mutableLookup) // 列挙するとIGroupingが出てくる
{
    var key = item.Key; // キー(食べ物,飲み物)
    var array = item.ToArray(); // 配列
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MutableLookup&lt;TKey, TValue&gt; : ILookup&lt;TKey, TValue&gt;
{
    private readonly Dictionary&lt;TKey, List&lt;TValue&gt;&gt; dictionary;

    // Constructor

    public MutableLookup()
    {
        dictionary = new Dictionary&lt;TKey, List&lt;TValue&gt;&gt;();
    }

    public MutableLookup(IEqualityComparer&lt;TKey&gt; keyComparer)
    {
        dictionary = new Dictionary&lt;TKey, List&lt;TValue&gt;&gt;(keyComparer);
    }

    // Property

    public IEnumerable&lt;TKey&gt; Keys
    {
        get { return dictionary.Select(kvp =&gt; kvp.Key); }
    }

    public IEnumerable&lt;TValue&gt; Values
    {
        get { return dictionary.SelectMany(kvp =&gt; kvp.Value); }
    }

    // Methods

    public ILookup&lt;TKey, TValue&gt; AsReadOnly()
    {
        return dictionary.SelectMany(kvp =&gt; kvp.Value, (kvp, Value) =&gt; new { kvp.Key, Value })
            .ToLookup(t =&gt; t.Key, t =&gt; t.Value);
    }

    public void Add(TKey key, TValue value)
    {
        if (dictionary.ContainsKey(key)) dictionary[key].Add(value);
        else dictionary.Add(key, new List&lt;TValue&gt; { value });
    }

    public void AddRange(TKey key, IEnumerable&lt;TValue&gt; values)
    {
        if (dictionary.ContainsKey(key)) dictionary[key].AddRange(values);
        else dictionary.Add(key, new List&lt;TValue&gt;(values));
    }

    public void RemoveKey(TKey key)
    {
        dictionary.Remove(key);
    }

    public void RemoveValue(TKey key, TValue value)
    {
        if (!dictionary.ContainsKey(key)) return;

        var list = dictionary[key];
        list.Remove(value);
        if (!list.Any()) dictionary.Remove(key);

    }

    public void RemoveWhere(TKey key, Func&lt;TValue, bool&gt; predicate)
    {
        if (!dictionary.ContainsKey(key)) return;

        var list = dictionary[key];
        list.RemoveAll(new Predicate&lt;TValue&gt;(predicate));
        if (!list.Any()) dictionary.Remove(key);
    }

    public void Clear()
    {
        dictionary.Clear();
    }

    public bool Contains(TKey key, TValue value)
    {
        if (dictionary.ContainsKey(key))
        {
            return dictionary[key].Contains(value);
        }
        return false;
    }

    #region ILookup&lt;TKey,TValue&gt;

    public bool Contains(TKey key)
    {
        return dictionary.ContainsKey(key);
    }

    public int Count
    {
        get { return dictionary.Count; }
    }

    public IEnumerable&lt;TValue&gt; this[TKey key]
    {
        get
        {
            return (dictionary.ContainsKey(key))
                ? dictionary[key].AsEnumerable()
                : Enumerable.Empty&lt;TValue&gt;();
        }
    }

    #endregion

    #region IEnumerable&lt;IGrouping&lt;TKey,TValue&gt;&gt;

    public IEnumerator&lt;IGrouping&lt;TKey, TValue&gt;&gt; GetEnumerator()
    {
        return dictionary
            .Select(kvp =&gt; new Grouping(kvp.Key, kvp.Value))
            .Cast&lt;IGrouping&lt;TKey, TValue&gt;&gt;()
            .GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }

    #endregion

    // Nested Types

    private class Grouping : IGrouping&lt;TKey, TValue&gt;
    {
        private TKey key;
        private List&lt;TValue&gt; list;

        public Grouping(TKey key, List&lt;TValue&gt; list)
        {
            this.key = key;
            this.list = list;
        }

        #region IGrouping&lt;TKey,TValue&gt;

        public TKey Key
        {
            get { return key; }
        }

        #endregion

        #region IEnumerable&lt;TValue&gt;

        public IEnumerator&lt;TValue&gt; GetEnumerator()
        {
            return list.GetEnumerator();
        }

        #endregion

        #region IEnumerable

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        #endregion
    }
}
</code></pre>
<p>利用はご自由にどうぞ。パブリックドメイン、でいいのかな？ あー、AsReadOnlyは新しいのに作り替えちゃってるのでAsじゃないですねえ。まあ、放置。あと、new Predicate()が果てしなくダサい。これ何とかならないのかな。delegateはFuncとAction以外は消滅しちゃえばいいのに。ジェネリクス以前のコレクションクラスと同じで、3.0以前の負の遺産だと何となく思ってる。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-07" data-pagefind-meta="published:2009-08-07"><a href="https://neue.cc/2009/08/07_184.html">LinqとIEqualityComparerへの疑問</a></h1>
<ul class="date"><li>2009-08-07</li></ul>
<div class="entry_body"><p>Distinctの引数はラムダ式でのselectorを受け付けてくれない。IEqualityComparerだけなので、抽出のためにわざわざ外部にIEqualityComparerを実装したクラスを作る必要がある。それって、面倒くさいし分かり辛いし、何でここだけ古くさいような仕様なのだろう。C#3.0っぽくない。しょうがないので、単純ですけど汎用的に使えるようなものを作ってみた。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IEqualityComparer&lt;T&gt;の実装が面倒なのでセレクタ的なものはこれで賄う
public class CompareSelector&lt;T, TKey&gt; : IEqualityComparer&lt;T&gt;
{
    private Func&lt;T, TKey&gt; selector;

    public CompareSelector(Func&lt;T, TKey&gt; selector)
    {
        this.selector = selector;
    }

    public bool Equals(T x, T y)
    {
        return selector(x).Equals(selector(y));
    }

    public int GetHashCode(T obj)
    {
        return selector(obj).GetHashCode();
    }
}

class MyClass
{
    public int MyProperty { get; set; }
}

static void Main(string[] args)
{
    // このクラスのMyPropertyで重複除去したい
    var mc1 = new MyClass { MyProperty = 3 };
    var mc2 = new MyClass { MyProperty = 3 };
    var array = new[] { mc1, mc2 };

    var r1 = array.Distinct().Count();
    Console.WriteLine(r1); // 勿論2です
    // 比較用のIEqualityComparer&lt;T&gt;インスタンスを渡す
    var r2 = array
        .Distinct(new CompareSelector&lt;MyClass, int&gt;(mc =&gt; mc.MyProperty))
        .Count();
    Console.WriteLine(r2); // 1です
}
</code></pre>
<p>newするから、型を書かなければいけなくてね、記述量が多くて嫌だ。重たい重たい。C#3.0ってのは、もっとライトウェイトじゃなきゃダメなんだ。推論！型推論！しょうがないので、Distinctそのものに拡張メソッドを定義すれば……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ExtensionMethods
{
    public static IEnumerable&lt;T&gt; Distinct&lt;T, TKey&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, TKey&gt; selector)
    {
        return source.Distinct(new CompareSelector&lt;T, TKey&gt;(selector));
    }
}

var r3 = array.Distinct(mc =&gt; mc.MyProperty).Count();
Console.WriteLine(r3); // 1になる
</code></pre>
<p>ラムダ式で書けるようになる。この調子でIEqualityComparerを使ってるメソッドの全てに拡張メソッドを定義すれば問題なし。しかし準備が面倒。このことは、ForEachが搭載されないことと並ぶLinq最大の謎だと私は思っているのですけど、どうなんでしょうか。何か理由があるのかなあ。とても気になるのだけど……。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-05" data-pagefind-meta="published:2009-08-05"><a href="https://neue.cc/2009/08/05_183.html">どう書く。ドキュメントコメント。</a></h1>
<ul class="date"><li>2009-08-05</li></ul>
<div class="entry_body"><p><a href="http://d.hatena.ne.jp/bleis-tift/20090804/1249389793" title="オブジェクト倶楽部、コーディング規約の会の「C# コーディング標準」の駄目なところ - 予定は未定Blog版">オブジェクト倶楽部、コーディング規約の会の「C# コーディング標準」の駄目なところ - 予定は未定Blog版</a></p>
<p>全く持ってその通りで、このコーディング規約はねえ、害悪を撒き散らしてるだけだよね……。さて、ところでドキュメントコメント。私は、つけます。(プロパティにはつけないかも、メソッドにはつける)。IntelliSense大好きっ子なので。但しほとんどの場合summaryのみを一行。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">/// &lt;summary&gt;何たらメソッドです&lt;/summary&gt;
public int Method(string input)
{
    // 色々処理ってことで。
    return 0;
}
</code></pre>
<p>こんな感じ。何で一行にするかといったら、上にぐちゃぐちゃXMLで書かれてるのって汚いし読みづらいぢゃん、ということもあるんですが主な理由はアウトラインに折りたたんでも解説が見えるから。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/outline.jpg">
</p>
<p>ね？///で出てくるものをご丁寧に全部埋めると、アウトラインに畳んだ時に内容が読めなくて困るのです。自分のソースの時は構わないんですが、人のソースを読むときはアウトラインを閉じたり開いたりを多用するので、かなり困ります。というわけで一行summaryお薦め。問題があるとすれば、手書きが面倒(///は一発で出てくるので)ということですが、この程度はキーマクロで記録してショートカットに割り振れば一発なので是非。あと、///で同時に出てくるparamsやreturnsて、大抵は面倒くさいだけであまり必要ないよね。「そういうの、書かなくていいんだよ、summaryだけなら面倒くさくないでしょ？」という心理的な安心感を得られるのも良いです。</p>
<p>ついでに、もう一つ、コメントの飾り枠についても。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こういうコメントの入れ方は嫌！
class MyClass
{
    // -------------------------
    // Property
    // -------------------------

    public int MyProperty { get; set; }
}

// これでいいでしょ？
class MyClass
{
    // Property

    public int MyProperty { get; set; }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/commentoutline.jpg">
</p>
<p>領域を目立たせるために囲むんでしょうけど、アウトラインで折りたたむとコメントがばっさり畳まれて見えなくなるんです。無意味な飾りはほんとーに、止めて欲しい。こういうのは一行でいいんです。別に機械に頼ればいいじゃない、機械があるんだから、機械には頼るべき、だからこそソースは機械に優しく書いて欲しいと私は思います。</p>
<p>そういえば#regionの話も出てましたけど、私は#regionはあんまし使いません。かなり好きくない。フィールドとか短いモノを畳まれると、逆にいちいち展開しなきゃならなくて面倒くさいんですよねー。というわけで、よほど長ったらしい状態で任意のグループ分けがしたい時には使いますが、フィールド、プロパティ、メソッド、みたいな分け方のために#regionを使いたくはない。</p>
<p>まあしかし、つまりはアウトラインってあまり使わないのかなあ。「アウトラインの中止」と「定義に折りたたむ」の二つでバサバサと畳んだり開いたりを連発するなんて、しないのかなあ。しないのかも……。周りの人にキモ！このソースキモ！一行summaryキモ！と思われないためにも、むしろ一行summaryをスタンダードにしようの会。コーディング規約ってつまりそういうことでしょうか、なんて独善的な！</p>
<p>勿論、Sandcastleとか絡むんなら別のお話です。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-02" data-pagefind-meta="published:2009-08-02"><a href="https://neue.cc/2009/08/02_182.html">linq.js :: Next</a></h1>
<ul class="date"><li>2009-08-02</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://gyazo.com/a22fe0fb0363f453b3347229a89bbf4a.png">
</p>
<p class="noindent">
	<img src="http://gyazo.com/bfecd658e98080f91dd1fce9aa13e53e.png">
</p>
<p class="noindent">
	<img src="http://gyazo.com/0e0c32ba4c065c10ec27da30359e3b1a.png">
</p>
<p>音沙汰のない<a href="http://linqjs.codeplex.com/">linq.js</a>なんですが、現在はWindows Script Host対応を進めています。対応といっても数カ所書き換えるだけなんですけど、それに合わせてWSH用のラッパーライブラリを書いているので、それに時間を取られてる感じです。基本的にはほんと薄いラッパーで、列挙処理がlinq.jsに渡せるのでそっちで好きに処理してね、という方向なので機能面での補助は一切なく別にすぐ出来上がるというかもうほとんど出来てるんですが、IntelliSenseを聞かせるためのvs-doc書きに物凄く時間喰われています。とにかくIntelliSense命な私は、IntelliSenseが動かないものなんて書きたくない！なければ自分でIntelliSenseを書く！という意味不明な方向で頑張ってます。</p>
<p>画像の一枚目は一週間前のものなので、現在はW.ToLinqは廃止して、E.Fromで動くようになってます。何のこっちゃ。</p>
<p>このご時世、WSHなんて下火、これからはPowerShellだよねー、って感じですが、それでも私はWSHで頑張る！ WSHでLinq書けるのかゴルァ、を合い言葉に。JavaScript好きだし。まあ、素のJScriptだとEnumeratorを被せなきゃいけなくて列挙処理がゴミで使う気になれないのは確かなのですが、そこをlinq.jsがあれば何とか出来るわけなので、全然WSHは現役で行ける、Windows7時代でも全然行ける、と思います、思いたいです。まあ、あとWindowsサイドバーガジェット(デスクトップガジェット)にも使えるので、もうちっと踏ん張っていきたいな、というところ。Web系で頑張るのは無意味なのでニッチを狙いだしたとかそういうことではありま、す。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-01" data-pagefind-meta="published:2009-08-01"><a href="https://neue.cc/2009/08/01_181.html">ver 1.3.0.5 バグ修正とか動かない人用とか色々</a></h1>
<ul class="date"><li>2009-08-01</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>動かない－、という人にログを出して貰ったお陰で、幾つか問題を潰せました。本当にありがとうございます。自分の環境で再現出来るエラーを潰せるのは当たり前。再現しないエラーを潰せないのは三流。というわけで三流な私はさっぱり分かりませんでした。分かってみれば、ああ、確かに問題だなーって感じなんですけどねえ。</p>
<p>変更内容は「オフライン→オンライン時投稿のチェックを外していた場合、同期に失敗する不具合を修正」だそうです。えー、こんな初歩ミス埋め込んでたのー、っていうと、そうです、はい、埋め込んでました、はい。げふんげふん。これは酷い。そう、「実績解除」だけ利用できればいいや、って人が利用出来なかったのです、なんだってー。あともう一つ、「GamerTagの入力を大文字小文字を区別しないように変更」です。今まで区別していたので、例えばnEUEcCとか入力すると、同期出来てませんでした。これはいかんですね。いかんので、区別しないようにしました。</p>
<p>ていうか、自分の環境で再現しない問題、じゃなくてただたんに例外ケースの見積もりが甘すぎなだけですなあ。もうちっと気を引き締めて書かないとダメですね。</p>
<h2>追記</h2>
<p>ver 1.3.0.6になりました。1.3.0.4以降は「+記号」が使えなかったっぽいので、それを直しました。ダメダメすぎて涙。</p>
</div>
<h1 data-pagefind-sort="date:2009-07-31" data-pagefind-meta="published:2009-07-31"><a href="https://neue.cc/2009/07/31_180.html">MinBy</a></h1>
<ul class="date"><li>2009-07-31</li></ul>
<div class="entry_body"><pre data-pagefind-ignore="all"><code class="language-csharp">        var minBy = list.Aggregate((a, b) =&gt; a.Age &lt; b.Age ? a : b);
        Console.WriteLine(minBy);
</code></pre>
<p>お題は<a href="http://d.hatena.ne.jp/waritohutsu/20090729/1248892747">GroupBy、OrderByを使ってみる - waりとnaはてな日記</a>のもの。ただの例題だと思うので(例だとGroupByを使う意味がないし)突っ込むとかそういうつもりはなく、そういえばRubyでいうmin_byってないなあ、と思ったので。Aggregateはとても素敵メソッドだと思うけど、いざ使おうと思うとあまり使うシーンがなくてとても悲しい。</p>
</div>
<h1 data-pagefind-sort="date:2009-07-29" data-pagefind-meta="published:2009-07-29"><a href="https://neue.cc/2009/07/29_179.html">ver 1.3.0.4 動かなくなったのでちょっと書き換えた</a></h1>
<ul class="date"><li>2009-07-29</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>昨日の朝だか昼だかから動かなくなってたっぽいので、それを直しました。何で動かなかったのかよく分かってないんですが、ダメになった箇所だけは分かったので別のアプローチで、ということで。応急処置もいいとこで、まー情けないのですが、動けばいっか、ってことで。眠いし。ダメですかダメですねすみません。</p>
<p>今後だと、一応ダッシュボードのアップデートが8月に控えているらしいので、それでも引っかかってダメになるかもしれませんが、ダメっぽくなったのを捕捉次第、速やかに直したいとは思っているのでダラダラとお待ちください。</p>
</div>
<h1 data-pagefind-sort="date:2009-07-21" data-pagefind-meta="published:2009-07-21"><a href="https://neue.cc/2009/07/21_178.html">LinqとCountの効率</a></h1>
<ul class="date"><li>2009-07-21</li></ul>
<div class="entry_body"><p>IEnumerableを受け取ってのReverse(), Count(), ElementAt(), Last()は普通に考えると先頭から舐めるので効率がよろしくない。じゃあLinqの実装はどうなってるかというとSystem.Core.dllを眺めると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Reverse
ICollection&lt;TElement&gt; is2 = source as ICollection&lt;TElement&gt;;
// ElementAt
IList&lt;TSource&gt; list = source as IList&lt;TSource&gt;;
// Count
ICollection&lt;TSource&gt; is2 = source as ICollection&lt;TSource&gt;;
// Last
IList&lt;TSource&gt; list = source as IList&lt;TSource&gt;;
</code></pre>
<p>というわけで、IListを実装しているものなら、ちゃんと変換してくれているので大丈夫。Count()なんかは普通にLength/Countを使うから別にどうでもいいって話なのですが、Last()は[hoge.Length - 1]って書くのは嫌なので、こうして安心して使えると嬉しい話。まあ、こんなことは過去何回も話題に上っているのですが、一応自分で確認しておかないとね、ということで。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/library/bb338038.aspx">MSDNのCountの説明</a>にはICollectionを実装してるとそれ使う、って書いてあるけど、<a href="http://msdn.microsoft.com/ja-jp/library/bb358775.aspx">Lastのページ</a>には何も書いていなくて困ります。内部でisだのasだのやってゴニョゴニョしてるのなら、そのことも全部記載して欲しいなあ。</p>
<p>といったことを何故突然というと、<a href="http://d.hatena.ne.jp/eo-oe-aaaa/20090721/1248158740">C#にもほしい　～rubyのeach_with_index～ - SEの勉強日記</a>という記事を見かけたので。Count()のうえにElementAt()のラッシュというのは、IListだけならいいんですけどIEnumerableで拡張メソッドを作っているので、少しよろしくない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class Extension
{
    public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
    {
        foreach (var item in source)
        {
            action(item);
        }
    }

    public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T, int&gt; action)
    {
        var index = 0;
        foreach (var item in source)
        {
            action(item, index++);
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        Enumerable.Range(5, 6).ForEach((item, index) =&gt;
            Console.WriteLine(&quot;item={0} index={1}&quot;, item, index));
    }
}
</code></pre>
<p>という風にしたほうがいいと思われます。まあ、あと、new List()なんてやるぐらいなら.ToList()かしらん。</p>
</div>
<h1 data-pagefind-sort="date:2009-07-16" data-pagefind-meta="published:2009-07-16"><a href="https://neue.cc/2009/07/16_177.html">ver 1.3.0.3 / ちょっとした拡張メソッド群</a></h1>
<ul class="date"><li>2009-07-16</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Gears of War 2やCall of Duty : World at Warでステータスが取得出来なかった件を修正しました。GoW2は修正を確認出来ましたがCoD:WaWは持ってないので分からない。多分直ってると思うけど。あと、この修正の影響で他がダメになる可能性がなくもないです。ダメっぽいのを発見したら即直す、という方向で暴走さえしなければある程度はいっかー、的にゆるふわ気分でいるのですがダメでしょうかダメですね。</p>
<p>ところで、int.Parseが多くなって結構面倒くさいので文字列に拡張メソッド。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static int ToInt(this string value)
{
    return int.Parse(value);
}

public static int ToIntOrDefault(this string value)
{
    int result;
    int.TryParse(value, out result);
    return result;
}

public static string Remove(this string input, string pattern)
{
    return Regex.Replace(input, pattern, &quot;&quot;);
}

public static Match Match(this string input, string pattern)
{
    return Regex.Match(input, pattern);
}

public static string Replace(this string input, string pattern, MatchEvaluator evaluator)
{
    return Regex.Replace(input, pattern, evaluator);
}
</code></pre>
<p>RemoveとReplaceは既存のメソッド名のものに足してるので、別の名前のほうが良いかしらん。あと、Replaceは引数が被るので、ただの文字列置換は用意できなかった。まあ、_ =&gt; &quot;hogehoge&quot; といった具合に「_ =&gt; 」が増えるだけならそう手間でもないような十二分に手間のような。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">totalGamerScore = document
    .Descendants(&quot;div&quot;)
    .First(e =&gt; e.GetAttribute(&quot;className&quot;) == &quot;XbcProfileSubHead&quot;)
    .Descendants(&quot;strong&quot;)
    .Last()
    .InnerText
    .Match(@&quot;:\s*(\d+)/&quot;)
    .Groups[1]
    .Value
    .ToInt();
</code></pre>
<p>こんな風に書けます。これでスクレイピングも快適ー。ドット繋げまくれてバンザイしちゃう。ただまあ、デバッグはし辛いですね。ログ吐くメソッドを仕込んだりもいいんですが、もっと単純に、ラムダ式挟めばデバッガで止められるので</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class Ext
{
    public static TResult Tap&lt;T, TResult&gt;(this T self, Func&lt;T, TResult&gt; func)
    {
        return func(self);
    }

    public static T Tap&lt;T&gt;(this T self, Action&lt;T&gt; action)
    {
        action(self);
        return self;
    }
}
</code></pre>
<p>RubyのTapみたいな、ということで。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/tap.jpg">
</p>
<p>ダミー置いて、その場で止められるようになる。それで作って、出来あがったらTapの行をCtrl+Xでゴミ箱ぽい。IEnumerableの場合は、普通にダミーのSelect置けばいいだけでしたね！ 今、そのことに気付いた。うーん、あと.Groups.Cast&lt;Group&gt;().Skip(1).Select(g =&gt; g.Value) も、頻繁にあるあるなので、Matchに拡張メソッド埋めときますか。</p>
</div>
<h1 data-pagefind-sort="date:2009-07-12" data-pagefind-meta="published:2009-07-12"><a href="https://neue.cc/2009/07/12_175.html">ver 1.3.0.2 色々バグ修正</a></h1>
<ul class="date"><li>2009-07-12</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>バグフィックス祭り！ まずバグ報告があってそれを直して、つまりは普段と少し違う状態の時の処理が全く入ってなかったので、洗い出して処理を入れました。別に全く考えていなかったわけじゃないのですが、想定からの漏れが幾つか、というかたっぷりありまして……。具体的には「申請待ちのフレンドがいるとエラーになる」「ステータスが「退席中」の際にデータが正しく取得出来ない」「ステータスが「取り込み中」の際にエラーになる」です。不具合くせえええ、と思ったら遠慮無く言っていただけるととっても助かりますので、お願いします。</p>
</div>
<a href="https://neue.cc/25">Prev |</a>
<a href="https://neue.cc/27">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
