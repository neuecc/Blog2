<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2009</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2009/12/31_232.html">AssemblyInfoの取得</a></h1>
<ul class="date"><li>2009-12-31</li></ul>
<div class="entry_body"><pre><code class="language-csharp">public sealed class AssemblyInfo
{
    public string FileName { get; private set; }
    public string Version { get; private set; }
    public string FileVersion { get; private set; }
    public string Title { get; private set; }
    public string Description { get; private set; }
    public string Configuration { get; private set; }
    public string Company { get; private set; }
    public string Product { get; private set; }
    public string Copyright { get; private set; }
    public string Trademark { get; private set; }
    public string Culture { get; private set; }

    public AssemblyInfo(Assembly assembly)
    {
        FileName = assembly.GetName().Name;
        Version = assembly.GetName().Version.ToString();
        FileVersion = GetAttributeName&lt;AssemblyFileVersionAttribute&gt;(assembly, a =&gt; a.Version);
        Title = GetAttributeName&lt;AssemblyTitleAttribute&gt;(assembly, a =&gt; a.Title);
        Description = GetAttributeName&lt;AssemblyDescriptionAttribute&gt;(assembly, a =&gt; a.Description);
        Configuration = GetAttributeName&lt;AssemblyConfigurationAttribute&gt;(assembly, a =&gt; a.Configuration);
        Company = GetAttributeName&lt;AssemblyCompanyAttribute&gt;(assembly, a =&gt; a.Company);
        Product = GetAttributeName&lt;AssemblyProductAttribute&gt;(assembly, a =&gt; a.Product);
        Copyright = GetAttributeName&lt;AssemblyCopyrightAttribute&gt;(assembly, a =&gt; a.Copyright);
        Trademark = GetAttributeName&lt;AssemblyTrademarkAttribute&gt;(assembly, a =&gt; a.Trademark);
        Culture = GetAttributeName&lt;AssemblyCultureAttribute&gt;(assembly, a =&gt; a.Culture);
    }
    
    private string GetAttributeName&lt;T&gt;(Assembly assembly, Func&lt;T, string&gt; selector) where T : Attribute
    {
        var attr = assembly.GetCustomAttributes(typeof(T), true).Cast&lt;T&gt;().FirstOrDefault();
        return (attr == null) ? &quot;&quot; : selector(attr);
    }
}

// 利用例
class Program
{
    static void Main(string[] args)
    {
        var assembly = Assembly.GetEntryAssembly();
        var info = new AssemblyInfo(assembly); // こんな感じに。
        Console.WriteLine(info.Title);
    }
}
</code></pre>
<p>通常AssemblyInfo.csに記載する、タイトルとか説明とかバージョンの取得って、用いたいシーンも少なくないわりに存外面倒くさい。そんなわけで補助クラスを作ってみました。コンストラクタにAssemblyを投げ込むと、文字列にして返してくれます。</p>
<p>これと同じことをやるコードを一年ぐらい前に書いたのですが、今見たらどうしょうもなく酷かった……。(あまりにも酷いので見せられません！)。なので、今基準で書き直してみました。いかに型を書かないで済ませるか、いかに行数を少なく見た目をすっきりさせられるか。Func&lt;T, string&gt;という発想が一年前は出来なかったんだなあ。CastやFirstOrDefaultも知らなかったやも。</p>
<p>そんなわけで今年もありがとうございました。無事、閉鎖せずに一年を乗り越えられました。ただ、ある意味閉鎖してますけれどね、ゲサイト的な意味では。今年を振り返るとプログラミング、プログラミング、プログラミングでした。一年前とは見比べるまでもなく成長出来たと思います。ブログにコードを晒すこと、小さくてもいいのでソフトウェアを作って公開すること、というのが確実に貢献してくれました。よく言われる、コード晒せば他の人の添削が期待できるよ！ってのはそこまで期待できないと思うのですが(勿論、ありがたい指摘も幾つかありました、感謝です)、それよりも他の人が見る、という意識をもってコードに取り組むのが効いた気がします。カッコつけて書こうと、何度も練り直すのが結果的には良かったかな、と。</p>
<p>もう少し振り返れば、なんといってもC#、というかLinq。Linqの魅力に取りつかれて、そのままフルスロットルで加速した一年でした。C#や.NET Frameworkに詳しいか？ と言われるとまだまだモニョるのですが、Linq to Objectsなら詳しい、と言えるだけの自信はつきました。これは、<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library">linq.js</a>としてJavaScriptに移植したのが大きいです。動作が完全に一致するよう何度もチェックしたり、Monoのソース読んだり、リフレクタでSystem.Core.dll読んだりしたので、内部をきちんとイメージ出来るようになったので。</p>
<p>来年は、んー、とりあえずlinq.jsのWSH拡張の早期リリースを目指したいです。linq.jsは、個人的には非常に便利だと思っているのですが、ウェブ用のライブラリとしてアピールするのはどう考えても「無理」。パフォーマンス無視で、リスト処理がこんなに簡単に書けるんです、どうでしょう？ってんじゃあ請求力もないって話です。そもそもウェブ用JavaScriptで多用するDOM操作関連は未実装部分(linq.js Xml Extensions)多いし。とはいえ、せっかく作ったわけなので、真面目に布教させたいと思っています。今のところJavaScriptライブラリの隙間、WindowsScriptHost用やテキストエディタのマクロ用としての応用例を探っている、というか実装中。特に、WSH用に使うと物凄く便利なことが分かったので、とっとと実装を終えて、使ってみて欲しいところです。</p>
<p>実装中というか、途中で放置しちゃってるのがアレですが。<a href="http://neue.cc/2009/08/24_193.html" title="neue cc - WSH用にCOMのIntelliSenseを自動生成する">ちょろっと記事書いた</a>のが8月。今まで、それから全く進んでおりません。XboxInfoTwitのリリースに追われたり、Rxで遊んだりで放置ルートに入ってしまったのですねえ。やる気はめっちゃあるので、来年はまず一番に、linq.jsのWSH拡張のリリースを目指します。本気で本当に。</p>
<p>プログラミング以外だと、今年で一番影響が大きかったのがTwitterかなあ→<a href="https://twitter.com/neuecc" title="neuecc (neuecc) on Twitter">neuecc on Twitter</a>。今までチャットやネトゲなど、コミュニケーション系のウェブサービスを全く受けつけなかったコミュ不全の私が、唯一利用出来たサービスだという。一人で書き飛ばしていればよくて、無理に繋がらなくていいのが非常に楽。……。まあ、私はもう少し@飛ばしてもいいと思います。むしろ飛ばせ。これも来年の目標、ですかね。</p>
</div>
<h1><a href="https://neue.cc/2009/12/17_230.html">C#のWebRequestとWebClientでCookie認証をする方法(と、mixiボイスへの投稿)</a></h1>
<ul class="date"><li>2009-12-17</li></ul>
<div class="entry_body"><p>WebからHTMLをダウンロードするにはWebClientが便利です。が、そのまんまだとCookie認証で躓きます。せっかく便利にダウンロード出来るのに、認証を超えられないんじゃ意味が無いよ！というわけかで幾つかのやり方を紹介したいと思います。海外だと沢山情報が出回っているのですが、日本だと<a href="http://d.hatena.ne.jp/solis/20080930">WebClientはクッキーがとれない</a>が検索上位に出てくるので、WebClientの利用を諦めて面倒くさいWebRequestを使う羽目になっている人が多いんじゃないかしらん。WebRequestなら@ITの記事、<a href="http://www.atmarkit.co.jp/fdotnet/dotnettips/326cookie/cookie.html">＠IT：.NET TIPS クッキーを使ってWebページを取得するには？</a>が引っかかりますからね。</p>
<p>とりあえず、@ITのmixiへの認証を例題に、まずはWebRequestでのやり方を見てみます。</p>
<pre><code class="language-csharp">// WebRequestによるCookie認証
// POSTしてCookieContainerに書き込む
var data = Encoding.ASCII.GetBytes(string.Join(&quot;&amp;&quot;,
    new[] { &quot;next_url=/home.pl&quot;, &quot;email=めるあど&quot;, &quot;password=ぱすわど&quot; }));
var cookieContainer = new CookieContainer();
var req = (HttpWebRequest)WebRequest.Create(&quot;https://mixi.jp/login.pl&quot;);
req.CookieContainer = cookieContainer;
req.Method = &quot;POST&quot;;
req.ContentType = &quot;application/x-www-form-urlencoded&quot;;
req.ContentLength = data.Length;
using (var stream = req.GetRequestStream())
{
    stream.Write(data, 0, data.Length);
}
var res = req.GetResponse(); // ここでCookieContainerに書き込まれる

// 以下、そのCookieを使えばアクセスし放題
var reqLog = (HttpWebRequest)WebRequest.Create(&quot;https://mixi.jp/show_log.pl&quot;);
reqLog.CookieContainer = cookieContainer; // CookieContainerセット
var resLog = reqLog.GetResponse();
using (var stream = resLog.GetResponseStream())
using (var sr = new StreamReader(stream, Encoding.GetEncoding(&quot;euc-jp&quot;)))
{
    Console.WriteLine(sr.ReadToEnd()); // アクセスできてるのを確認
}
</code></pre>
<p>CookieContainerを設定すれば、Cookieのサーバーからの取得も送信も全部自動でやってくれる、というのがポイント。そこは楽です。楽なのですが、WebRequest自体が使いづらい。何をやるにも、いちいちStreamがどうだのこうだのなんてウンザリです。ていうか何だこのvarの多さ、変数乱れ打ち！ そうなるとついつい、よーしパパ、ラッパー作っちゃうぞー、とか言ってしまいますが、もう見てらんない。.NET FrameworkにはWebClientというMS謹製のラッパーがあるわけなので、それを使いましょう。認証？Cookie？自前で取ればいいんですよ、ヘッダーから。</p>
<pre><code class="language-csharp">// WebClientならポストは超簡単！
var wc = new WebClient { Encoding = Encoding.GetEncoding(&quot;euc-jp&quot;) };
wc.UploadValues(&quot;https://mixi.jp/login.pl&quot;, new NameValueCollection
{
    {&quot;next_url&quot;, &quot;/home.pl&quot;},
    {&quot;email&quot;, &quot;めるあど&quot;},
    {&quot;password&quot;, &quot;ぱすわど&quot;}
});
// じゃあCookieはどうするの？というと、ResponseHeaderから自前で抽出します
var setCookie = wc.ResponseHeaders[HttpResponseHeader.SetCookie];
var cookies = Regex.Split(setCookie, &quot;(?&lt;!expires=.{3}),&quot;)
    .Select(s =&gt; s.Split(';').First().Split('='))
    .Select(xs =&gt; new { Name = xs.First(), Value = string.Join(&quot;=&quot;, xs.Skip(1).ToArray()) })
    .Select(a =&gt; a.Name + &quot;=&quot; + a.Value)
    .ToArray();
var cookie = string.Join(&quot;;&quot;, cookies);
// 以降は取得したCookieをHeaderに設定しておけばOk
wc.Headers[HttpRequestHeader.Cookie] = cookie;
var result = wc.DownloadString(&quot;https://mixi.jp/show_log.pl&quot;);
Console.WriteLine(result); // アクセスできてるのを確認
</code></pre>
<p>そう、WebClientでも、ResponseHeaderからSetCookieは取れるのです。なので、ここからCookieにバラしてやれば、あとはHeaderに設定するだけなので簡単です。一見WebRequest並に行数がかかっているのですが、大変なのはCookie分解部分だけです。分解がちょっと面倒なのは否めませんが……。基本的にカンマ区切りとなっていますが、有効期限の設定されているものが含まれていると「expires=Fri, 16-Dec-2011」のようにカンマが入ってしまい、単純なSplit(',')では失敗します。なので正規表現の否定戻り読みでexpires=***,の場合は除外しています。あとは、バラしてクッツケテ、を繰り返して生成。そういえばSelect三連打ですが、これはもちろん複数行にすることでSelect一つで済ますこともできます。でも、そこはそれぞれ役割を切って3つに分けるのが、私の美意識、でしょうか。効率を考えれば匿名型なんて作らない方がいいぐらいなのですけどね、効率じゃない良さってのがあるんです。Linqには。</p>
<p>やり方はまだあります。WebClientは本当にただのWebRequestのラッパーで、中では普通にWebRequestを呼んで処理しています。よって、継承してoverrideしてGetWebRequestの辺りを書き換えて、CookieContainerを使うようにすれば非常に簡単です。</p>
<pre><code class="language-csharp">class CustomWebClient:WebClient
{
    private CookieContainer cookieContainer = new CookieContainer();

    // WebClientはWebRequestのラッパーにすぎないので、
    // GetWebRequestのところの動作をちょっと横取りして書き換える
    protected override WebRequest GetWebRequest(Uri address)
    {
        var request = base.GetWebRequest(address);
        if (request is HttpWebRequest)
        {
            (request as HttpWebRequest).CookieContainer = cookieContainer;
        }
        return request;
    }
}

// WebClientを継承してちょっと書き換えてやれば一番簡単
var cwc = new CustomWebClient { Encoding = Encoding.GetEncoding(&quot;euc-jp&quot;) };
cwc.UploadValues(&quot;https://mixi.jp/login.pl&quot;, new NameValueCollection
{
    {&quot;next_url&quot;, &quot;/home.pl&quot;},
    {&quot;email&quot;, &quot;める&quot;},
    {&quot;password&quot;, &quot;ぱす&quot;}
});
var result = cwc.DownloadString(&quot;https://mixi.jp/show_log.pl&quot;);
Console.WriteLine(result); // アクセスできてるのを確認
</code></pre>
<p>私的にはこれがお薦め。どうせWebRequestはそのまんまじゃ使い辛いので、多かれ少なかれラッパー作るでしょう。出来の悪いラッパーを作る/使うぐらいなら、WebClientの気の利かない部分だけ書き換えた方が良い。 ちなみにCookieの他にもWebClientの気の利かないところとしては、自動でリダイレクトするところが辛い、場合がある。普段はリダイレクトでいいんですが、リダイレクトされると困るシチュエーションもあります、たまに。そんな問題も、CookieContainerと同じくGetWebRequestの部分で、request.AllowAutoRedirectを設定すれば回避出来ます。</p>
<p>Web上のものをゴニョゴニョ処理するのに「Rubyなどのスクリプト言語の良さが目立つ。」というのは、ライブラリの問題にすぎない、ってことですな。XML処理には今やLinq to XMLがあるし、HTMLの取得にしてもちょっと工夫するだけで回避できるのでC#だから書きにくい、なんてことは無いと思っています。いやまあMechanize便利やん、とかありますがありますが。しかしC#には最終兵器、WebBrowserがあるので何とでもなる。HTML解析なら<a href="http://journal.mycom.co.jp/articles/2009/12/15/htmlagility/index.html">Html Agility Pack</a>を使えば、物凄く簡単に出来ます。</p>
<p>最後に、Twitterの自分の投稿最新20件をmixiボイスに投げ込む、というコードを例として出してみます。CustomWebClientクラスは上に乗っけた奴を使っています。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    var encoding = Encoding.GetEncoding(&quot;euc-jp&quot;);
    // ログイン
    var cwc = new CustomWebClient { Encoding = encoding };
    cwc.UploadValues(&quot;https://mixi.jp/login.pl&quot;, new NameValueCollection
    {
        {&quot;next_url&quot;, &quot;/home.pl&quot;},
        {&quot;email&quot;, &quot;めーる&quot;},
        {&quot;password&quot;, &quot;ぱすわど&quot;}
    });

    // 投稿に必要なpost_keyをhtmlから取り出す
    var echo = cwc.DownloadString(&quot;https://mixi.jp/recent_echo.pl&quot;);
    var postKey = Regex.Match(echo, &quot;id=\&quot;post_key\&quot; value=\&quot;(.+?)\&quot;&quot;).Groups[1].Value;

    // 例なので簡易化するため認証無しのTwitterステータスを取得します
    // HttpUtilityの利用にはSystem.Webの参照設定が別途必要
    var id = &quot;自分の(じゃなくてもいいけど)TwitterID&quot;;
    var texts = XDocument.Load(&quot;http://twitter.com/statuses/user_timeline/&quot; + id + &quot;.xml&quot;)
        .Descendants(&quot;status&quot;)
        .Select(x =&gt; HttpUtility.HtmlDecode(x.Element(&quot;text&quot;).Value))
        .Reverse();
    foreach (var text in texts)
    {
        // mixiボイスに投稿(UTF-8以外の日本語の投稿はUploadValuesが使えない(泣)
        cwc.Headers[HttpRequestHeader.ContentType] = &quot;application/x-www-form-urlencoded&quot;;
        cwc.UploadString(&quot;http://mixi.jp/add_echo.pl&quot;, string.Join(&quot;&amp;&quot;, new[]
        {
            &quot;body=&quot; + HttpUtility.UrlEncode(text,　encoding),
            &quot;post_key=&quot; + postKey,
            &quot;redirect=recent_echo&quot;
        }));
    }
}
</code></pre>
<p>差分を記録するようにしたり、@付きを除外したりするようにすれば、そこそこ使えるんじゃないかしらん。利用はご自由にどうぞ。</p>
</div>
<h1><a href="https://neue.cc/2009/12/13_229.html">Linqでコマンドラインオプション解析</a></h1>
<ul class="date"><li>2009-12-13</li></ul>
<div class="entry_body"><p>最近、Linqでの副作用について考えこむことが多くなりました。きっかけはSelectメソッド内で、外部のListに対してAddしたあげくreturn null -&gt; ToArrayとかいうForEach代わりに使うかのような超勘違いしたコードを見せられたことなのですが(自信満々にどうだ！って感じで出されたのでモニョるしかなかったという苦い記憶ががが) と、そんな私の愚痴はどうでもよくて、副作用。基本的には邪悪ですよね。個人的に嫌なのは、せっかくスコープが狭く、ラムダ式だけを見つめれば良い状態になっているのに、副作用が入ると広い範囲を意識しなければならないこと。この変数名はどこからきたの？ インスタンスの状態はどうなるの？ 考えごとが増えるのは嫌なものです。ミスも増えるでしょう。エラーの温床となってしまいます。</p>
<p>とはいえ、使いどころによっては強力な効果を発揮するのも事実。例えば、以前書いた<a href="http://neue.cc/2009/06/24_170.html" title="neue cc - IEnumerableに文字列連結">IEnumerableの文字列連結</a>なんて、カウント用変数を一つ用意するだけで、Aggregateでサクッと書けてしまいます。というわけで、無駄な多用は厳禁だけど、使いどころをちゃんとおさえて書きましょう、というイイコな結論を出しつつ本題というか例題。</p>
<p>コマンドラインオプション解析。シーケンスを前方から解析して、次のキーが現れるまでは以前のキーで分類する。という分かるような分からないようなお話です。コマンドラインオプションだけでなく、たとえば決まった形式のテキストファイルを解析するとかでよくありそうなパターンだと思います。これがXMLなら簡単に解析出来るのに、クッ…… みたいな。</p>
<p>さて、グループ分けとなると、じゃあLinqで出来るよね？ GroupByかなんかを使えばいいっしょー。と思い浮かぶわけなのですが、素の状態だと上手くいきません。GroupByを使うためのキーを列挙内部だけで保持することは出来ないからです。じゃあどうするか、というと、そうそう、副作用です副作用。はいはいクロージャクロージャ。というわけで列挙中にサクサクッとキーを書き換えてしまいましょう。</p>
<pre><code class="language-csharp">// こんな風に来るコマンドラインオプションを解析しよう
var args = new[] { &quot;-i&quot;, &quot;input.txt&quot;, &quot;-hoge&quot;, &quot;-huga&quot;, &quot;-o&quot;, &quot;output.txt&quot; };
// グループ分けといったらLinqだよね？
// ディクショナリに分解したい、dict[&quot;-i&quot;]で&quot;input.txt&quot;が取れる、というように

// コマンドラインオプションをHashSetに格納する
var options = new HashSet&lt;string&gt; { &quot;-i&quot;, &quot;-hoge&quot;, &quot;-huga&quot;, &quot;-o&quot; };

string key = null;
var result = args
    .GroupBy(s =&gt; options.Contains(s) ? key = s : key) // 副作用！
    .ToDictionary(g =&gt; g.Key, g =&gt; g.Skip(1).FirstOrDefault()); // 1番目はキーなのでSkip
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqgroupbydict.jpg">
</p>
<p>とまあ、こうなります。副作用便利！</p>
<p>そういえばコマンドラインオプションの解析は.NET Framework標準では用意されていないのですよねえ。外部ライブラリのものは、当然なのですがあらゆるものに対処するため、どれもこれもヘヴィーすぎです。別にそんな複雑なのいらないよー、-oを解析出来ればそれだけでいいんだよー、的な小さいシチュエーションなら、この程度でも問題ない、はずです、きっと。</p>
<p>例としてコマンドラインオプションの解析を出したのは、id:coma2nさんの<a href="http://d.hatena.ne.jp/coma2n/20091210/1260433596" title="NDesk.Options(Mono) - コマンドラインパーサー - Programmable Life">NDesk.Options(Mono) - コマンドラインパーサー - Programmable Life</a>という記事を見てのことです。このNDesk.Optionsは凄いですね！ まだ触ってないので実際の使いかっては分かりませんが、ラムダ式の使い方に驚きました。非常に上手いやり方だと思います。シンプルで。明快で。覚えやすく書きやすく。私もこういう発想が出来るようになりたいなあ。</p>
</div>
<h1><a href="https://neue.cc/2009/12/08_228.html">TwitterTLtoHTML ver.0.1.0.0</a></h1>
<ul class="date"><li>2009-12-08</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/notepc.jpg">
</p>
<p>ノートPCを買いました。完全デスクトップ至上主義者だったというのに！あれです、あんまり引きこもってばかりいるのもよろしくないので、ノートPCさえあれば勉強会とかも出れる！のかどうかは、そもそもなくても出れるよねえ、あっても出れないよねえ(私の非コミュ脳的に) などと思いつつも、まあそんなこんなで買いました。流行りのCULVノートって奴です。Visual Studio 2008が思っていたよりも遥かに実用的な速度で動いていて、そう、こんなんでいーんだよ、とか思ったりなどした。けれど、VS2010は絶望的に動かなかった。重過ぎる。世の中厳しい。</p>
<p>引きこもり解消目的の他にもう一つ、常時起動の半サーバー用途というのもあります。<a href="http://neue.cc/2009/11/05_213.html" title="neue cc - C#でTwitterのStreaming APIを使ってリスト自動追加">ストリームAPIを監視したxboxinfotwitusersリストへの追加プログラム</a>を常時デスクトップPCで振り回すのもカッタルイというか消費電力的に無駄なので、低消費電力なノートPCへ退避させよう、と思ったわけです。そもそも他にも、<a href="http://neue.cc/software/hatetwit" title="neue cc - はてなついったー同期ツール">はてなついったー同期ツール</a>だの<a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">XboxInfoTwit</a>だの、PC常時起動を前提のアプリを幾つか公開しているので、調度良いということで。</p>
<ul>
<li><a href="http://neue.cc/software/twittertltohtml" title="neue cc - TwitterTL to HTML">neue cc - TwitterTL to HTML</a></li>
</ul>
<p>んで、本題。常時起動PCがあるなら、過去ログも常時起動で定期的に取得して、差分をHTMLに残せばいいよね！それを<a href="https://www.dropbox.com/" title="Dropbox - Home - Secure backup, sync and sharing made easy.">Dropbox</a>なんかの共有フォルダに保存するようにすれば、取りこぼしもないし、何処からでもログを参照できるしで最高ぢゃん(そこで本当に自宅鯖にしてネットワークに公開する、というのは手間がかかりすぎるので超却下)。というわけで定期起動実行用のモードを追加しました。前回取得からの差分のみを、yyyy/MM/dd_HHmmssの形式(/はフォルダ)で保存します。今まで通り、過去800件取得モードも残してあります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/tasktltohtml.jpg">
</p>
<p>定期取得でやりたい場合は、タスクスケジューラに突っ込めばおk。タスクスケジューラは柔軟に設定出来る分、とっつきづらくて面倒くさいんですねえ。でも、例えば「バッテリ電源の時は実行しない」とか素敵オプションが色々用意されているので、使うといいと思います。トリガを大量に設定しておいて、18-24とかの流速の激しい時間帯は更新間隔短め、0-9とか静かな時間帯は更新間隔長め、12時のお昼休憩の前に一度まとめて読みたいので12時ジャストに設定。とか色々と考えられますので適当に気に入る設定を探ると良いんじゃないかと思われます。</p>
<p>あと一応、TinyUrlとかのデコード機能も入れておきました。実装は超手抜きで、Urlを片っぱしから WebRequest.Create(url).GetResponse().ResponseUri.AbsoluteUri; しているだけです。んま、問題ないでしょう、多分。普段Echofonで短縮Urlのまま表示されていただけに、こうして展開された形で見れると、いかに短縮Urlがイライラさせるものなのかよーく分かりますな。投稿時に必須なのはしょうがないのですけど……。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/tltohtmlset.jpg">
</p>
<p>それと、今回からは初回設定は対話式ウィザードで行うようにしてます。あと、パスワードはそのPCでのみ復元出来る、という形で暗号化されます。設定ファイル直書き換えで一番嫌なのは、パスワードを平文で置く、ということなので、それを避けるために、ですね。書き捨ての小さいコンソールアプリなのでいっかー、と最初思ったんですが、やっぱり気になりました。</p>
<p>最後に、バグフィックス。二重でHtmlエンコードしてた部分を直しました。TwitterからのXMLは既にHTMLエンコードされている状態なので、それをそのままXElementに流し込むと二重でエンコードされてしまいます。なので、一旦デコードしています。この辺は結構よくミスしてしまうんですよねー。取得したものがどんな状態なのか、利用するクラスがどういう動作をするのか、ともにちゃんと把握していないとハマリがちです。</p>
<p>ちなみにまるで利用者がいる風な口で紹介していますが、ダウンロード数は超絶少ないので利用者なんていませんよ！ 完全に自分用ですな。</p>
<h2>2009/12/09 追記</h2>
<p>ダウンロード先ファイルが古いバージョンのままでした……。今、直しました。ただでさえゼロに近いダウンロード数だったというのに、こうして使ってくれるかもしれない/コードを見てくれるかもしれない人を失ってしまう……。</p>
</div>
<h1><a href="https://neue.cc/2009/12/06_227.html">書評 : More Effective C#</a></h1>
<ul class="date"><li>2009-12-06</li></ul>
<div class="entry_body"><iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=4798119547" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>結論は「Linq to Objectsの本」です。全編に渡って例題がLinqの再実装となっていて驚きました。「作って学ぶLinq」のほうが題として正しいぐらい。冗談じゃなく本当に、7割ぐらいが実質Linq周りです。実質、と言ったのは本書中では特に明言されていないからですが、見ればすぐにこれLinq to Objects……と突っ込みたくなること請け合いの例が沢山収録されています。</p>
<p>以前からLinq to Objectsに絞った解説書が出るべきだ、と思っていました。Linq to Objectsはこれでいて結構深いのです。どうもLinqというとLinq to SQLとか、データベース周りの喧伝の印象が強いようで、Linq to Objectsの実態が正しく伝わっていない気がします。今時リスト処理に高階関数使うなんてどのLightweight Languageでも常識よねー、というお話でもあります。Rubyのメソッドチェイン＋ブロックなんて見た目だけで言えばLinqと丸っきり一緒ですし。昨今のモダンな言語の最も優れた部分を、最も優れた形で掲示しているのがLinqです。(優れた形、というのに異論はあると思いますが突っこまんで下さい)</p>
<p>そんなわけで褒め称えたいところだし、内容は結構良いと思っているのですが難点が一つ。対象範囲がC#3.0までのわりに、書き方が微妙に2.0っぽいこと。これはよろしくない。Linqに関しても再実装であることが本書中に明言がなく、書き方が2.0なので、「2.0でLinqをやるには」になっています。別に原理を知れればいいわけで、何も本書中の書き方を真似る必要はないのですが、それだと人に薦めづらいのですね。Linq知らない人に、これ見て学ぶといいよ、と素直に手渡したいのだけど手渡しにくい感が悔しいです。変にC#2.0と3.0を行ったり来たりするようなフワフワした構成じゃなく、Linqであることを明言した上で、その解説に徹してくれればよかったなあ、なんて思うんですね。</p>
<p>本の意義というか効用は、Linqや高階関数を多用してしまっても、この本が免罪符になるというのが一番大きいですね！ C#3.0というのはLinqを使いこなし、更にはLinq風に設計構築していくのがEffectiveなのです、と大手を振って言える、かも。でもまあ、実際Linq風に扱うのが基盤になっているのは確かなので、変に凝るよりはLinq to Xxxみたいになっているほうが嬉しいです＜ライブラリのような根幹部分での設計</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=4798119539" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>Moreが先に出ていて、無印の発刊はこれから先です。無印がMoreの後に出るのは、本国では無印はC# 4.0対応の第二版が出るのでそれを待つのかなー、と思ったのですがそういうわけでもないようで。というわけで恐らくC#1.0まで対応のものだと思うので残念のような、そうでもないような。私はC#3.0から入ったにわかC#使いなので、1.0の書き方を見れるというのも新鮮で面白いんじゃないかなー、なんて思ってます。</p>
</div>
<h1><a href="https://neue.cc/2009/11/29_226.html">Reactive Extensions for .NET (Rx) メソッド探訪第六回:exception handling</a></h1>
<ul class="date"><li>2009-11-29</li></ul>
<div class="entry_body"><p>.NET Reactive FrameworkからReactive Extensions for .NET (Rx)に名称が変わったようなので、タイトルも変更。長いね。というわけで久しぶりなのですが、今回はざっとexception handling operators、つまり「Catch, Finally, Retry, OnErrorResumeNext」を見てみることにします。それとRun(ForEachなので説明不要ですが)。Rxって何？という人は<a href="http://neue.cc/2009/11/24_222.html" title="neue cc - Hello, Reactive Extensions">Hello, Reactive Extensions</a>をまず参照下さい。</p>
<p>Rxの花形はイベント合流系のメソッドにあると思うので、ひたすら脇役ばかりを紹介してちっとも本流に入ろうとしないのはどうかと思うのですけど、EnumerableExのCatchを見て、あー、こりゃ便利だ、ヤバい、便利だ、用途すぐ浮かんでしまった、というわけでしてCatchを紹介します。まずは、その浮かんだ例であるTwitterのタイムライン取得をどうぞ。例はIEnumerableに対してのものですが、IObservableに対してのものも同じです。</p>
<pre><code class="language-csharp">class Twitter
{
    public string Text { get; set; }
    public DateTime CreatedAt { get; set; }
}

static IEnumerable&lt;Twitter&gt; EnumerateUserTimeline(string userName)
{
    // {0}はユーザー名、{1}はページ番号 公開ユーザーのものを取得なら認証不要
    var format = &quot;http://twitter.com/statuses/user_timeline/{0}.xml?page={1}&quot;;
    foreach (var page in Enumerable.Range(1, 1000))
    {
        var query = XDocument.Load(string.Format(format, userName, page))
            .Descendants(&quot;status&quot;)
            .Select(e =&gt; new Twitter
            {
                Text = e.Element(&quot;text&quot;).Value,
                CreatedAt = DateTime.ParseExact(e.Element(&quot;created_at&quot;).Value,
                    &quot;ddd MMM dd HH:mm:ss zzzz yyyy&quot;,
                    CultureInfo.InvariantCulture,
                    DateTimeStyles.AssumeUniversal)
            });
        foreach (var item in query) yield return item;
    }
}

static void Main(string[] args)
{
    // 2009/11/23から今日までの投稿を古い順に並べるというもの
    var test = EnumerateUserTimeline(&quot;neuecc&quot;)
        .TakeWhile(t =&gt; t.CreatedAt &gt;= new DateTime(2009, 11, 23))
        .OrderBy(t =&gt; t.CreatedAt)
        .ToArray();
    
    // これで基本的には問題ないわけですが、TwitterにはAPI制限があるので
    // ちゃんと全部取得出来るわけではなく、API制限発動 =&gt; 死亡になる可能性がある
    // 死んでもいいんだけど、せっかく取った死ぬ前のデータはがめておきたいよねえ
    // というわけで、そこで出番なのがRxのCatch！

    var test2 = EnumerateUserTimeline(&quot;neuecc&quot;)
        .TakeWhile(t =&gt; t.CreatedAt &gt;= new DateTime(2009, 11, 23))
        .Catch((Exception e) =&gt; Enumerable.Empty&lt;Twitter&gt;())
        .OrderBy(t =&gt; t.CreatedAt)
        .ToArray();

    // 例外が発生したら握りつぶして、代わりにEnumerable.Emptyを返します
    // なので、例外発生前のデータは全て取得出来ています、素晴らしい！
}
</code></pre>
<p>といった感じです。つまりCatchは、そのまんまCatchです。Linqで全部書くのも良いんだけど、例外処理が出来なくてなあ、という不満がこれで解消されます。残りのFinally, Retry, OnErrorResumeNextですが、全部Catchの派生みたいなものです。とりあえず簡単な例を。</p>
<pre><code class="language-csharp">static IEnumerable&lt;int&gt; Iterate1To5()
{
    yield return 1;
    yield return 2;
    throw new DivideByZeroException(); // 嘘例外でも投げておく
    yield return 4;
    yield return 5;
}

static void Main(string[] args)
{
    // 1,2
    Iterate1To5().Catch((Exception e) =&gt; Enumerable.Empty&lt;int&gt;()).Run(Console.WriteLine);
    // 1,2,100,200
    Iterate1To5().Catch((Exception e) =&gt; new[] { 100, 200 }).Run(Console.WriteLine);
    // 1,2 -&gt; 例外発生(ArgumentNullExceptionはDivideByZeroExceptionじゃないのでCatchしない)
    Iterate1To5().Catch((ArgumentNullException e) =&gt; new[] { 100, 200 }).Run(Console.WriteLine);
    // 1,2,100,200。つまりCatchの簡略版
    Iterate1To5().OnErrorResumeNext(new[] { 100, 200 }).Run(Console.WriteLine);
    // 1,2,Finally。これでtry-catch-finallyが出来あがる
    Iterate1To5()
        .Catch((Exception e) =&gt; Enumerable.Empty&lt;int&gt;())
        .Finally(() =&gt; Console.WriteLine(&quot;Finally&quot;))
        .Run(Console.WriteLine);
    // 1,2 -&gt; 1,2 -&gt; 例外発生。例外を検知したら最初から列挙し直しての再試行
    // EnumerableExのRetryはバグっぽくてObservableとは違う動きをする
    // 明らかにオカシイのでそのうち修正されるでしょう
    Iterate1To5().ToObservable().Retry(2).Subscribe(Console.WriteLine);
}
</code></pre>
<p>最後に、中身をちゃんと知るには自分で実装するに限る、ということでIEnumerableでの拡張メソッドで再現してみました。Catchは本当に便利なので、わざわざRx使うのも、と思う場合は以下のコードを是非コピペして使ってくださいな。</p>
<pre><code class="language-csharp">// ループをぶん回すだけ、というもの(linq.jsではForce()が同様の働き)
public static void Run&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)
{
    source.Run(_ =&gt; { });
}

// ようするにForEach
public static void Run&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; action)
{
    foreach (var item in source) action(item);
}

// try-catch句の中でyield returnが使えないので回りっくどいことに
public static IEnumerable&lt;TSource&gt; Catch&lt;TSource, TException&gt;(this IEnumerable&lt;TSource&gt; source,
    Func&lt;TException, IEnumerable&lt;TSource&gt;&gt; handler) where TException : Exception
{
    using (var enumerator = source.GetEnumerator())
    {
        while (true)
        {
            TException exception = null;
            var hasNext = false;
            try
            {
                hasNext = enumerator.MoveNext();
            }
            catch (Exception e)
            {
                exception = e as TException;
                if (exception == null) throw;
            }

            if (exception != null)
            {
                foreach (var item in handler(exception)) yield return item;
            }
            if (hasNext) yield return enumerator.Current;
            else yield break;
        }
    }
}

// Rxにはこういう、handlerがActionのオーバーロードが欲しいです
// わざわざ空のシーケンス投げるのは面倒くさいし、匿名型に対応できないじゃないか！
public static IEnumerable&lt;TSource&gt; Catch&lt;TSource, TException&gt;(this IEnumerable&lt;TSource&gt; source,
    Action&lt;TException&gt; handler) where TException : Exception
{
    return source.Catch((TException e) =&gt; { handler(e); return Enumerable.Empty&lt;TSource&gt;(); });
}

// OnErrorResumeNextはCatchの簡略版みたいなもんですね、別に必要ないような
public static IEnumerable&lt;TSource&gt; OnErrorResumeNext&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, IEnumerable&lt;TSource&gt; next)
{
    return source.Catch((Exception e) =&gt; next);

}

// ToList().ForEach()とRun()ではactionの出るタイミングが変わることに注意
public static IEnumerable&lt;TSource&gt; Finally&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Action action)
{
    try { foreach (var item in source) yield return item; }
    finally { action(); }
}

// 本当は無限でやるべきなんでしょうが、int.MaxValueで。
public static IEnumerable&lt;TSource&gt; Retry&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)
{
    return source.Retry(int.MaxValue);
}

// EnumerableExのRetryがバグ臭いのでObservable.Retryの挙動を採用しました
public static IEnumerable&lt;TSource&gt; Retry&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, int retryCount)
{
    var count = 0;
    Exception exception = null;
    while (count &lt; retryCount)
    {
        exception = null;
        foreach (var item in source.Catch((Exception e) =&gt; exception = e))
        {
            yield return item;
        }
        if (exception == null) yield break;
        count++;
    }
    throw exception;
}
</code></pre>
<p>どれもCatchの派生のようなものです、CatchイイよCatch。これは使いまくりたくなる。それにしてもtry-catchの中でyield returnが使えないのを、はじめて知りました。こんなことやろうとしたことがなかったので。あと、EnumerableEx.Retryはひっじょーにバグ臭いです。ちなみにEnumerableEx.Mergeもバグ臭い。全体的にEnumerableExはバグ臭さ全開です。明らかに(Observableから)適当に移植した感漂ってます。ヤバい。</p>
</div>
<h1><a href="https://neue.cc/2009/11/27_225.html">TwitterのTL過去ログをHTMLにするツール</a></h1>
<ul class="date"><li>2009-11-27</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/twittertltohtml.jpg">
</p>
<ul>
<li><a href="http://neue.cc/software/twittertltohtml" title="neue cc - TwitterTL to HTML">neue cc - TwitterTL to HTML</a></li>
</ul>
<p>Twitterの他の人のポストは全部読みたいと思っています。数千もフォローしてるアルファーツイッタッターでは無理でしょうけど、せいぜい百ちょいぐらいなら全然いけるわけです。と、思っていたのですが、たかだか200を超えたところで、ん、無理……？と思える感じになってきてしまいました。ツール的限界で。Webから過去ログを見ようとすると、限界点に到達してしまって未読があるのに過去ログが見れない状態になってしまって。ていうか、そもそもWebでログを見るというのはダルい。まあ、ないですよね。私がTwitterで使っているツールはEchofonで、これは過去ログ見るのに適さないし全然昔の見れないし、というわけでどうしたものかなー、と思っていたんですが、作ればいいわけですよね、過去ログ閲覧専用Twitterクライアント。</p>
<p>と、考えてはみたものの、そもそもわざわざツール作るまでもなく、ログをHTMLで吐けばいいんじゃね？と気付いた。YesYesYes。流し読みなら、むしろへっぽこ専用ツールよりもブラウザのほうが見やすいし。家でガッとHTML取得しといてモバイルに転送して電車でゆったり見る、とか出来るし。というわけで、可能な限り過去ログを掘ってHTMLに吐きだすプログラムを書きました。可能な限り、といってもAPI制限の都合上で最大800件まで、のようです。うーん、これじゃあ半日ぐらい前、程度ですよねえ。18-24時とかだと一瞬で吹っ飛びそうかも。3000件ぐらいまでは欲しいとこなのですが……。なお、API消費はたった4か5なので安心です。一回につき200件取れるので。</p>
<p>デザインはCSSで行えます。例えばimgのwidthとheightを0pxにすればアイコン表示を消せます。これで学校や会社で見る時にアニメアイコンが並んで恥ずかしい思いをしなくて済む！ あとまあ、デフォルトのCSSはショボい(私がCSSの知識ないので……。float良く分からん、高さ揃わない、50pxで決め打ち！とか)ので、適当に改良して使ってください。</p>
<p>あと、コード(C# 3.0)も同梱してあるので適当に見て突っ込んでくださいな。HTML組み立て部分はLINQ to XMLです。</p>
<pre><code class="language-csharp">var urlPattern = new Regex(&quot;(s?https?://[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,%#]+)&quot;);
var xhtml = new XElement(&quot;html&quot;,
    new XElement(&quot;head&quot;,
        new XElement(&quot;link&quot;, new XAttribute(&quot;rel&quot;, &quot;stylesheet&quot;), new XAttribute(&quot;href&quot;, &quot;style.css&quot;))),
    new XElement(&quot;body&quot;,
            new XElement(&quot;ul&quot;,
            EnumerateHomeTimeline(username, password).Select((t, i) =&gt;
                new XElement(&quot;li&quot;, new XAttribute(&quot;class&quot;, (i % 2 == 0 ? &quot;even&quot; : &quot;odd&quot;)),
                    new XElement(&quot;div&quot;,new XAttribute(&quot;class&quot;,&quot;name&quot;), t.ScreenName),
                    new XElement(&quot;div&quot;,new XAttribute(&quot;class&quot;,&quot;date&quot;),t.CreatedAt.ToString(&quot;G&quot;)),
                    new XElement(&quot;div&quot;,
                        new XAttribute(&quot;class&quot;,&quot;image&quot;),
                        new XElement(&quot;img&quot;,new XAttribute(&quot;src&quot;, t.ProfileImageUrl))),
                    new XElement(&quot;div&quot;,
                        new XAttribute(&quot;class&quot;,&quot;text&quot;),
                            urlPattern.Split(t.Text).Select(s=&gt;
                            {
                                var href = urlPattern.Match(s);
                                return (!href.Success) 
                                    ? (XNode)new XText(s)
                                    : new XElement(&quot;a&quot;,new XAttribute(&quot;href&quot;,href.Value),href.Value);
                            })))))));
</code></pre>
<p>えーと…… 汚い、ですね！それでも、このLINQ to XMLの関数型構築がなければどれだけ悲惨なことになっていたか！やはりLINQ to XMLは素晴らしい。さて、しかし困ったのがリンクのaタグ付け。文字列で扱っていれば普通に置換すれば済む話なのですが、XTextにそれを放り込むとタグはエスケープされます。最初驚いたのですが、考えてみると当然ですね、XMLとして不正なものは許されないので。しょうがないのでSplitしてXMLとして組み立ててやりました。</p>
<p>json/xmlを拾ってきてHTMLに整形するだけなのだから、JavaScriptで書いてうぇぶあぷり、的なものにしたほうが利便性とか何とかかんとかが良好なんじゃございませんこと？とか思わなくもなかったのですが、C#、楽なので、ほんと。良い言語なんですって。</p>
</div>
<h1><a href="https://neue.cc/2009/11/27_223.html">ver.2.1.0.0</a></h1>
<ul class="date"><li>2009-11-27</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>未知のエラーが発生する原因の一つを解消しました。私の確認出来た範囲では、フレンドの中にNetflixを使っている人がいると100%エラーが発生するようでした。原因はプレイ中状況が&lt;Translated text&gt;で、この&lt;がエスケープされてないせいでタグとして認識してたせいでパースに失敗してるせいでした。適当に検索したところTranslated textはちょっと特殊な状況表示？で他のゲームでも出現するようですね、何だろう、翻訳しようと思ったけどまだ出来てませんって感じでしょうか(笑)</p>
<p>で、えーと、これはXbox.comが悪いですよ、ほんと、Microsoftはもっとしっかりサイト作って欲しいなあ。いつぞやかの実績暴走の件だってそもそも……。と、言ってみたところでユーザーからはプログラムがタコなせいにしか見えないわけですし、Xbox.comはXbox.comで、イレギュラーなアクセスをしてる輩のことなんて別に考える必要はないわけで、やっぱり悪いのはプログラムですね、あはは。</p>
<p>さて、今回は&lt;Translated text&gt;を丸ごと置換するという頭悪すぎな方法での応急処置をしたのですが、今後も平然と&lt;がエスケープ抜きで登場するようなケースは、ありそうですね……。というわけで、何とかすべきところではあるのですが、汎用的な置換表現を作るのはほぼ不可能だし、全てに対応しようにも如何せん何処に出現するかも不定すぎて無理げ。別の問題が出た時にまた考えることにします。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xit_option.jpg">
</p>
<p>機能追加が一つ。指定文字列が含まれる場合には投稿しない、という機能を足しました。例えば「Xbox 360 ダッシュボード|Halo Waypoint」にすれば、ダッシュボードとHalo Waypoint再生時は投稿しないようになります。なお、大文字と小文字やスペースの有無を完全に区別しますので、利用するときは一度Twitterに投稿されたものをコピペすると良いと思います。なお、ver.1にあった「ダッシュボードは無視」機能に似ていますが、ver.2のものは起動時投稿設定にも適用されるため、100%、ver.1と同じというわけではありません。うーん、ver.1の起動時設定のみ特別扱いってのがどうかなー、と思っていたので今回の仕様に変更されたわけですが、どうなんでしょうねえ。</p>
</div>
<h1><a href="https://neue.cc/2009/11/24_222.html">Hello, Reactive Extensions</a></h1>
<ul class="date"><li>2009-11-24</li></ul>
<div class="entry_body"><p>Reactive Frameworkが<a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx" title="Reactive Extensions for .NET (Rx)">Reactive Extensions for .NET (Rx)</a>として、DevLabsで公開されました。紫のうなぎアイコンが可愛い。これは(消滅してしまった)Microsoft Voltaと同様のものなのですが、開発チームが同じだからだそうです。DevLabsには他にAxumやSTM.NETなど、興味深いプロジェクトがいっぱいありますが、日本語による情報がほとんど手に入らないので手を出しづらいところがあります。RxもDevLabsに登場したことでグッと情報が増えましたが、英語ソースによるものばかりなので、私の脳みそ的には相当シンドイことになっています。英語辛いよぅ。</p>
<p>とはいえ、小細工しなくても.NET3.5 SP1上で動かせるのは素敵なので是非試しましょう！ Silverlight Toolkitにこっそり収録版からも、かなりパワーアップしています。メソッド大増量、そしてToolkit版でバグい挙動していたのが本当にバグなのか私のやり方が悪いのか悩んでいた部分がサクッと修正されいてホッとしたり。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_inst.jpg">
</p>
<p>インストールディレクトリに置いてあるchmのヘルプを見ることも出来るし、IntelliSenseも動きますので、前に比べると触りやすくなりました。ただまあ、例ぐらいは入れてよって感じで、簡素極まりない一行説明から理解するのは、やっぱり難しい。</p>
<h2>System.Interactive.ｄll</h2>
<p>Rxには興味ないよ、という人にも大変役立ちなのがこのdll。デフォで参照設定に加えることは確定的に明らか。中のクラスはSystem.Linq.EnumerableExのみで、ようするに拡張メソッド集です。EnumerableExという名の通り、Linq.Enumerableに対する追加版となっています。基本的にはIObservableに用意されていたメソッドをIEnumerable用に持ってきたという感じです。Repeat(value)による無限リピートやReturn(value)による単体シーケンス作成、Generate(所謂Unfold)など、欲しかった生成メソッドが沢山用意されています。</p>
<p>更に当然のようにIEnumerableに対する拡張メソッドもたっぷり。Zip(.NET 4に搭載)やMemoize、それにDo(副作用専用のActionメソッド)、Run(ようはForEachです、そう、ForEachですよ！)が非常にうれしい。他、挙げればキリがない用途不明の拡張メソッドがテンコ盛りなので要研究ですね。</p>
<p>例えばフィボナッチ数列。</p>
<pre><code class="language-csharp">EnumerableEx.Generate(
    new { v1 = 0, v2 = 1 }, // initialState
    _ =&gt; true, // condition
    a =&gt; a.v1, // resultSelector
    a =&gt; new { v1 = a.v2, v2 = a.v1 + a.v2 } // iterate
)
.Take(30)
.Run(i =&gt; Console.WriteLine(i));

// conditionが無限ならこうも書ける(第二引数の戻り値がIEnumerable、だけど平たくされる？)
EnumerableEx.Generate(
    new { v1 = 0, v2 = 1 }, // initial
    a =&gt; EnumerableEx.Return(a.v1), // resultSelector
    a =&gt; new { v1 = a.v2, v2 = a.v1 + a.v2 }); // iterate
</code></pre>
<p>んね、素敵。</p>
<h2>System.CoreEx.dll/System.Threading.dll</h2>
<p>CoreEx.dllにはAction, FuncのT16まで版(.NET 4に搭載)やUnit(voidを表す型)が主なところ。他にIEventやNotificationがありますが、これらは主にRxで使うためのものですね。Threading.dllはLazy, Task, Parallelといった、.NET 4に搭載されるメソッドの先取りといった感じのものががが。真剣に追っかけると大変なのでスルー。</p>
<h2>System.Reactive.dll</h2>
<p>以前のに比べるとメソッドが増えているのは当然なのですが、目立つところではSystem.Joins.Patternクラスの追加が目新しいです。何に使うのかはまだ知りません。ふむ。自分でお題を探すのも大変なので、Forumで出てる内容を幾つか紹介します。</p>
<ul>
<li><a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/0663ac98-60b0-4b88-9c7e-3b2c75c971d8" title="Observable.Cons?">Observable.Consはどこにいったの？</a></li>
</ul>
<pre><code class="language-csharp">// 100,1,2,3,....,10
Observable.StartWith(Observable.Range(1, 10), 100);
// 順番が奇妙なのは拡張メソッドとして使えるようにしたため
Observable.Range(1, 10).StartWith(100);
</code></pre>
<p>ConsはStartWithに改名されました。ついでに順番がちょっと変わりました。先頭に付け足すのに、第二引数というのが違和感全開なのは否めない。これは、拡張メソッドとして利用できるようにしたためでしょうね。メソッドチェインを崩さずに、先頭に値を足すことが出来るようになりました。ObservableだけではなくEnumerableにもあります。</p>
<ul>
<li><a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/50d01578-9217-43d3-8ccb-e3f859040a68" title="Hit by CS1911 when trying to use non-generic overload of Observable.FromEvent">FromEventの使い方わかんね</a></li>
</ul>
<pre><code class="language-csharp">public static IObservable&lt;IEvent&lt;MouseEventArgs&gt;&gt; GetMouseDown(this Control control)
{
    return Observable.FromEvent&lt;MouseButtonEventHandler, MouseEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(sender, e),
        h =&gt; control.MouseDown += h,
        h =&gt; control.MouseDown -= h);
}
</code></pre>
<p>h =&gt; (sender, e) =&gt; h(sender, e)っていうのが混乱しますな。第一引数のhはEventHandler&lt;MouseEventArgs&gt;です。ここでhをMouseButtonEventHandlerに変換します。この辺も、ActionやFuncと同じく、EventHandler&lt;TEventArgs&gt;だけあればいいのに、その他のゴチャゴチャしたデリゲートは消滅してしまえばいいのに、とか思わなくもないのですがしょうがない。「sender,e =&gt; h(sender,e)」は引数がobject,MouseEventArgsで戻り値がvoidのよくあるイベント用のデリゲートです。素の状態でこのラムダ式を書くと型が決まらないので動作しませんが、FromEventの型宣言時にMouseButtonEventHandlerだと明示しているので、変換出来ます。ここで変換されるので、第二、第三引数のhはMouseButtonEventHandlerになります。</p>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">メソッド探訪の第一回</a>で警告が出る、とか書いてしまったのですが、こういう風に記述すれば警告も出ず、文字列メソッド名を使わずに利用できたようです。言われてみればなるほど、って感じなのですが、気付けなかったなあ……。</p>
<ul>
<li><a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/fe833566-fd54-4f19-80d4-79df5c85350b" title="What is the Amb extension?">Ambって何？</a></li>
</ul>
<p>ambはLISPのambを由来として、ambiguous(不明瞭)の略。だそうです。Rxでは、例えば……</p>
<pre><code class="language-csharp">var first = Observable.Range(1, 3).Delay(300);
var second = Observable.Range(4, 3).Delay(100);
var third = Observable.Range(7, 3).Delay(200);
Observable.Amb(first, second, third).Subscribe(s =&gt; Console.WriteLine(s));

Console.ReadLine();
</code></pre>
<p>Delayは発火を指定ミリ秒だけ遅らせるメソッドです。では、何が表示されるでしょうか。答えは、&quot;4,5,6&quot;です。んじゃあthirdをDelay(0)にしたら？ &quot;7,8,9&quot;が表示されます。なるほど、分かってきた。つまり最初に到達したものを採用する、というわけです。この例ではわざとらしくDelayを足したシーケンスを投げてみましたが、例えば幾つかのイベントを並べて、最初にイベントが発火したものを。みたいな用途が考えられなくもない。</p>
<pre><code class="language-csharp">EnumerableEx.Amb(
        new[] { 1, 2, 3 }
            .Select(i =&gt; i + i)
            .Select(i =&gt; i + i),
        new[] { 7, 8, 9 }
            .Select(i =&gt; i + i))
    .Run(i =&gt; Console.WriteLine(i));
</code></pre>
<p>IObservableは分かるとして、何故かIEnumerableにもAmbがあります。上の例は何が表示されるでしょうか？答えは、8割は14,16,18です。残り2割は4,8,12です。チェインを沢山繋いだ方が原則的には「時間がかかる」ため、チェイン数の少ない方が採用される場合が多い。ただし、内部ではThreadを立てているので、必ずしもそうなるわけじゃない。というわけで、結果は非常に不確定で不明瞭で、使い道は完全に謎。</p>
</div>
<h1><a href="https://neue.cc/2009/11/24_221.html">ver.2.0.1.0</a></h1>
<ul class="date"><li>2009-11-24</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>一部タイトル、例えばアジア版GoW2で実績が取得出来ないという不具合を修正しました。あと、今現在、私の方でもたまに「未知のエラー」が出るのは確認出来ているのですが、ちょっと原因が掴めていない状態なので修正にはもう少し時間がかかりそうです。それと、そもそもXbox.comへのログインに失敗するというのは全く分かってませんので、もう少しどころじゃなく時間がかかりそうです。</p>
<p>そういえば説明を忘れていたのですが、ver.2からver.1にあった「投稿の際ダッシュボードは無視」機能は削ってしまいました。これは、どうやっても綺麗に多言語対応と混ぜることが出来なかったので……。日本語だけに限定すれば決めうちで簡単なのですけどね。利便性的には多言語対応なんかよりもこっちのほうが遙かに上だろ！と突っ込みたい気持ちはとても分かりますが、そんなこんなな事情なので復活させることは恐らくありません。</p>
<p>もう一つ、ver.2からLiveのステータスが離席中になった際もオフライン扱いにしちゃっています。ver.1では中途半端な無視の仕方をしていて、潜在的なバグの危険性があったので、すっぱりとオフラインということにしてしまいました。本体を10分放置しているとスクリーンセーバーが動いて、Liveのステータスも自動的に離席中になるようなのですが、もし本体放置で離席中になるのを拒否したい場合はスクリーンセーバーをオフにすればLiveステータスもずっとオンラインのままになります。スクリーンセーバーの切り替えは本体設定から「システム設定→本体の設定→画面→スクリーンセーバー」で入れます。</p>
</div>
<h1><a href="https://neue.cc/2009/11/20_220.html">ver.2.0.0.0</a></h1>
<ul class="date"><li>2009-11-20</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>XboxInfoTwitの認証数が<a href="http://ja.wikipedia.org/wiki/%E5%B2%A1%E6%9C%AC%E5%90%89%E8%B5%B7" title="岡本吉起 - Wikipedia">岡本641本吉起</a>を超えた記念、というわけでもないのですが大幅に変更しました。例によって全然テストしてないので動かないとか色々あるかもなので、生暖かい目で見守ってください。というか、ボソッとTwitterでxxで動かねえ、とでも言って貰えると非常に助かります。</p>
<p>今回の更新の主な内容は、クローラーを刷新しIEを使用しなくなった。です。それによって「メモリ消費量激減」(というか前が多すぎた、というか完全にメモリリークしてた) 「スクリプトエラー消滅」「IEでのログイン状態に左右されない」「ページ遷移のクリック音UZEEと無縁」などなど、まあ、これで安心して使えるかと思います。環境依存的に動かなかった人も動くようになった、はず、きっと。そんなこんなで、今回から中身が全く別物になっているので、環境依存、もしくはバグによる動かないケースが(また)増えそうなので、その辺は見つかり次第早めに対処したいと思います。当面は不安定かもしれませんがご了承ください。</p>
<p>挙動の変更としては、実績解除の投稿が必ず行われるようにしました。今までは実績解除後、投稿されるまでの間にXbox360の電源を落としたり別のゲームに変えてしまったりすると解除の投稿を行わなかったのですが、今回からは、電源を落としても別のゲームに変えても実績解除の投稿を行います。ちなみにまだ一回も実績解除を試してないので(デバッグ用にデータをごそごそ弄って解除したフリ、ぐらいはやりましたが)本当に上手く動いてくれるのかは謎です。</p>
<p>あと、エラーメッセージが親切になりました(今まで一律に通信エラーで理解不能だったので) でもタイミング次第では平然と「未知のエラー」とかいう素っ気ない応答しか出しません。酷い。この辺は追々直していこうかな、とは思ってるのですが。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xit2_lang.jpg">
</p>
<p>機能追加その一、別言語からの取得が可能に！今まではja-JPだけでしたが、英語ならen-USを、台湾語(中国語？)ならzh-TWを指定することによって、他の言語のデータが投稿されます。別にja-JPしか使わないとは思いますが、将来的にアプリケーション自体を多言語対応にして海外版もリリースしたいなあ、と思っているので(そのタイミングでコードも公開しようと考えてます)そのための下準備の一つです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xit2_hash.jpg">
</p>
<p>機能追加その二、ハッシュタグの自動付加。新しくプレイしたタイトルはタイトル名が記録されて、設定画面のハッシュタグタブの一覧に自動的に追加されます(任意での追加は不可能です)。ここでリストに、例えば「モダン・ウォーフェア2」だったら「MW2」と入力すれば、モダン・ウォーフェア2をプレイ時の投稿全ての末尾に「 #MW2」が付加されます。#に関しては付けなくても自動的に付けます(なのでハッシュタグとしてではなく、フッタとしての利用は現状不可能です)</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xit2_tip.jpg">
</p>
<p>機能追加その三、バルーンによる投稿通知。私的にはどうでもいいと思ってごほごほ。</p>
<h2>2.0.0.1</h2>
<p>例によって不具合発覚。20-30分ぐらい使ってると未知のエラーで死ぬようです。あまりにもの未知のエラー祭りは酷すぎた、のでとりあえず様子見で暫定的に対処してみました。うまくいってるかは不明。たかだか10数分間連続利用のテストすらしていないという！すみませんすみません。とりあえず今日は発売日に買ったけど全然プレイしてない(実績数がそれを物語ってる)Fallout3(OBLIVIONは超はまったのにFallout3はさっぱり琴線に触れず)をじっくりプレイしながらテストします、はい。</p>
</div>
<h1><a href="https://neue.cc/2009/11/17_219.html">AutoHotKeyによるマウスカスタマイズとマルチディスプレイのためのスクリプト</a></h1>
<ul class="date"><li>2009-11-17</li></ul>
<div class="entry_body"><p>タイトルがAutoHotKeyによるカスタマイズ、なのですが、前置きが長かったり、一部設定が新しく購入したマウス前提になってる部分もあります。とはいえ基本的には汎用的に使える設定を書いているので、自分にはあまり関係ないな、と思う部分は適当に読み飛ばしてください。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/Steelseries_Xai.jpg">
</p>
<p>長年使ってきたロジクールのマウス、MX Revolutionが相当ガタがきていて(シングルクリックがダブルクリックになるとか、ドラッグアンドドロップ中にリリースされちゃうとか)、おまけに電池もヘタれて、その上に充電端子の接触が悪くて中々充電されないというイライラ。耐えられない。というわけで、マウスを買い替えました。MX-R自体は結構気に入っていたはずなのですが、如何せん晩年の状態が最悪すぎたので何だか印象が随分と悪くなってしまいました。SetPoint(ロジクールのマウスドライバ)クソだし。</p>
<p>新しいマウスはSteelSeries Xaiです。究極のゲーミングマウスとして突き詰められた性能は、確かにカッチリと動く。ただ、あまりPCでゲームしないのでそこまでは分からない。とりあえず<a href="http://www.4gamer.net/games/037/G003732/20090805053/" title="4Gamer.net ― SteelSeriesの偉い人，Kim Rom氏に聞く新型マウス「Xai」「Kinzu」――キーワードは「パーソナライゼーション」（SteelSeries）">インタビュー読んでたら</a>欲しくなったというだけでして(笑) 売り文句が上手いです。ゲーミングマウスにありがちな派手派手しい外観じゃないのも好印象。マウスパッドもメーカー推奨のセットで揃えちゃいました。握った印象やポインティング性能は申し分ない。ホイールだけはMX-Rは群を抜いて素晴らしかったかな、まあ、しょうがないか。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=B002J9G5B8" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=B002J9G5AO" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=B002J9G5AE" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>マウス変更は無線-&gt;有線への回帰でもあるのですが、無線マウスはダメです。省電力のために細かくスリープに入り、マウスを動かすとワンテンポ遅れて復帰する。このワンテンポの遅れがイライラしました。晩年の、MX-Rがヘタれてしまった状態だからそうなのかもしれませんが、とにかく無線への印象は最悪。何のかんのでマウス重いし。軽さは、大事、だよ。と、Xaiを触りながら思ったのでした。思えばXbox360も絶対有線コントローラー主義者なわけで(無線コンは窓から投げ捨てよう！) ほんと、NO WIRE, NO COMPUTING.</p>
<p>Xaiのアサイン可能ボタン数は7。一時は多ボタンキチガイだった私であり、MX-Rのアサイン可能ボタン数11から、Xaiの7へとの大減少は些かどうしたものか、と思いましたが、そんなに多用しない、マウスと独立してる操作、例えばウィンドウのモニタ移動系なんかはキーボードのほうにマクロ割り振ればいいぢゃん？という思想に変わってしまっているので、7へと減少したことはそこまで痛手、ではありません。何でもマウスでやる中二病から、バランスよく割り振る高二病へと進化したわけでさあ。</p>
<h2>マウスカスタマイズ</h2>
<p>Xaiはドライバレスで動作します。設定用ソフトウェアはありますが、これはただたんに設定項目をマウスに送るだけであり、キーカスタマイズにせよ移動速度にせよ、項目は全てマウス本体に記録されます。なので、Xai＋AutoHotKeyは究極のポータビリティを誇ります。いつでもどこでも自分のお気に入りの設定で扱える。OS再インストール時の設定作業等も不要。これは……嬉しいですね。再インストールの度にクソSetPointを触らなきゃいけないのは気が滅入る話だったので。</p>
<pre><code class="language-ini">MButton::Shift
;左手前
XButton1::BackSpace
;左奥
XButton2::Send,!{F4}
+XButton2::Send,^!{F4}
;右手前
Pause::SearchSelectedText()
;右奥
ScrollLock::WinMinimize, A
+ScrollLock::WinSet,AlwaysOnTop,TOGGLE,A

;選択したテキスト内容でぐぐる
SearchSelectedText()
{
    bk = %ClipboardAll%
    Clipboard=
    Send,^c
    ClipWait, 1
    if(Clipboard != &quot;&quot;)
        Run,http://www.google.com/search?q=%Clipboard%
    Clipboard = %bk%
}
</code></pre>
<p>Xaiの形状は左右対称で、カスタマイズ出来る箇所は7つ。左右クリック・ホイールクリック・サイドボタンが左右に二つずつ。カスタマイズはAutoHotKeyで行うので、Xaiでの設定はほとんどしません、ほとんどデフォルトで。但しWindowsの扱えるボタン数は5つなので、Windows管轄外のボタン二つ(右のサイドボタン)には普段キーボードで使わないキーを割り振って、それで代替しましょう。具体的には、私はScroolLockとPauseを割り振りました。ソフトウェアドライバで制御に自由の効くものなら、F13-F24といったキーボードに存在しないキーを使うのですが、XaiではF13を認識しなかったので、しょうがなくの対処でした。</p>
<p>ほとんどデフォルトと言いましたが、マウスの中央ボタンだけは潰して、Shiftにしました。マウスの中央ボタンって大して使わないでしょう。第一級の位置にゴミキーを置いておくなんて勿体ない。せいぜい、マウスジェスチャーの起動キーとして使うぐらい？私はジェスチャーが大嫌いなので、他のマウスボタンとの組み合わせ用としてShiftを選びました。Ctrlのほうが便利と言えば便利なのですが、ScrollLockやBreakと組み合わせると思ったような挙動をしないので、しょうがなく妥協しました。</p>
<p>サイドボタン左側、BackSpaceは言わずもがなに便利。「戻る」だけじゃなく、「削除」として利用できるのが高ポイント。奥側のAlt+F4も便利。もう右上の×ボタンをクリックしにいく必要なんてないんですよ！後で述べますが、AutoHotKeyのアプリケーション固有設定で、タブのあるアプリケーションに対してはタブを閉じる(Ctrl+W)を振っておくと楽。ついでにShift+XButton2をAlt+F4にすれば、タブ有りアプリでも右上の×を使う必要はなくなる。</p>
<p>サイドボタン右側、選択文字列のGoogle検索は問答無用に便利。Firefox内でのみ、とかIE内でのみ、ではなくあらゆるアプリケーションからワンクリックでキーワード検索出来るというのは非常に大事です。実行するのに手間がかかると、どうしても人は躊躇ってしまうものなんですね。たかだかツークリックであってもダメ。無意識に重たいコストになってる。ちょっと気になったらとりあえず検索する。その習慣を根付かせるためにも、ワンクリックで出来る必要があります。</p>
<p>サイド右奥の最小化ですが、私は何のかんので結構使ったりするので設定してます。Shiftとの組み合わせは最前面に固定で、これもやっぱり頻繁に使ってます。無いと、困る。</p>
<p>さて、Shift＋サイドボタン左右の手前はデフォルトでは何も割り振っていません。この二つを、各アプリケーション固有設定用ボタンとして使います。たった二つ！なのですけど、このぐらい潔く割り切った方が「覚えやすい」し、結局は「使いやすい」かな、と思っています。せっかく割り振ってもあまり使わなかったら、別にキーボードショートカットでいいぢゃん、ということになりますし。</p>
<pre><code class="language-ini">; Firefox
#IfWinActive,ahk_class MozillaUIWindowClass
XButton2::Send,^w
^XButton2::Send,!{F4}
+XButton1::Send,^{Left} ;タブを左に移動(Firefox側でキーカスタマイズ済み)
+Pause::Send,^{Right}

;Visual Studio
#IfWinActive,ahk_class wndclass_desked_gsk
^w::Send,^{F4} ;タブを閉じる
XButton2::Send,^{F4}
+XButton2::Send,!{F4}
+XButton1::Send,^- ;定義から戻る
+Pause::Send,{F12} ;定義へ移動
</code></pre>
<p>IfWinActive以下にアプリケーション固有設定を記述。例としてFirefoxとVisualStudioのものを。左右なので、直感的には「移動」系がそれっぽく扱えるかな、と思っています。(今現在の設定だとFirefoxでのタブ移動が今一つ思った感じに動いてくれなくて要改善だったりはする)</p>
<h2>マルチディスプレイのためのスクリプト</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/dispimage.jpg">
</p>
<p>```ini
; 無変換との組み合わせによる十字キー
vk1Dsc07B & e::Send,{Up}
vk1Dsc07B & s::Send,{Left}
vk1Dsc07B & d::Send,{Down}
vk1Dsc07B & f::Send,{Right}
;矢印キー(マルチディスプレイでのウィンドウ移動)
vk1Dsc07B & Left::SendToTargetMonitor(3)
vk1Dsc07B & Right::SendToTargetMonitor(1)
vk1Dsc07B & Up::SendToTargetMonitor(4)
vk1Dsc07B & Down::SendToTargetMonitor(2)
<p>; 指定番号のモニタサイズを取得する
GetMonitor(monitorNo, ByRef mX, ByRef mY, ByRef mW, ByRef mH)
{
SysGet, m, MonitorWorkArea, %monitorNo%
mX := mLeft
mY := mTop
mW := mRight - mLeft
mH := mBottom - mTop
}</p>
<p>;対象モニタにアクティブウィンドウを移動する(高さリサイズ)
SendToTargetMonitor(monitorNo)
{
WinGetPos, x, y, w, h, A
GetMonitor(monitorNo, mX, mY, mW, mH)
Random, rand, 50, 200
WinMove, A,, mX + rand, mY, w, mH
}</p>
<pre><code class="language-&lt;/p&gt;">
無変換なんて使わないでしょ？カタカナに変換したいならCtrl+Iがお薦め。というわけで、これを潰して無変換＋ESDFを十字キーにするのは、もはやないと死ぬ。右手をホームポジションから放して十字キーとか遠すぎるし！というわけで、問答無用でお薦め。hjkl なんかよりもずっと直感的ですし。FPSライクでもある。WASDでなくESDFなのは、ホームポジションを崩さない位置だから。上記コードには載せていませんが、他に無変換＋Q,AでのHome,Endや無変換+Z,CでのCtrl+←,Ctrl+→なんかを割り振っています。プログラミング時の文字移動が大分楽になります。

そして、ウィンドウの座標即時移動はマルチディスプレイ環境なら便利というか必需だと思います。私の環境は4画面なので、無変換 +  ←↑→↓で各対応するモニタにウィンドウ座標を移動させます。ディスプレイの縦サイズがそれぞれ異なるので、縦サイズは対象ディスプレイの高さいっぱいに引き延ばすようにしています。私はほとんどのアプリケーションを縦いっぱいに広げて使っているのでこの仕様で問題ないというか、むしろそれであって欲しいのですが、高さが変化すると困る人は適当に改良してください。WinMoveでmYを指定しているところyにすれば、高さは変えない、になります。X座標は、モニタの左端を基準に、50-200の範囲でランダムにバラつくようにしています。これは複数のウィンドウを送り飛ばした時に、完全に重なると扱いづらくなるのを避けるためです。

```ini
;Windowsキー
;アクティブモニタの半分サイズにして左右に寄せる
#Left::
    GetActiveMonitor(x, y, w, h)
    WinGet, id, ID, A
    WinMove, ahk_id %id%,,x, y, w / 2 , h
    return
#Right::
    GetActiveMonitor(x, y, w, h)
    WinGet, id, ID, A
    WinMove, ahk_id %id%,,x + w / 2, y, w / 2 , h
    return
;最小化と復元
#Up::RestoreAll()
#Down::#d

;全てのアプリケーションを元に戻す
RestoreAll()
{
    WinGet, id, list
    Loop, %id%
    {
        StringTrimRight, this_id, id%a_index%, 0
        WinRestore, ahk_id %this_id%
    }
}
</code></pre>
<p>Windowsキー＋十字キーも対応するようにカスタマイズ。Windows7からは、一応モニタ移動系が割り振られていますが無視して上書き。まず左右ですが、モニタの半分サイズにして右寄せ左寄せです。これは、2つのアプリケーションを並べて比較したい時に重宝します。</p>
<p>Win+下はお馴染みのデスクトップ表示。そして上は「全てのウィンドウを元に戻す」です。例えばデスクトップに置いてあるフォルダを開きたい場合、Win+Dを使ってデスクトップを表示してフォルダを開く。そこから先、作業を終えたら、全て復元したいはずです、が、素のWindowsだと出来ません。一度フォルダを開くと、状態保存がなくなってしまうので、再度Win+Dを使っても、元には戻らず再びデスクトップ表示になってしまう。こんな不満も、AutoHotKeyなら簡単に解決出来ます。今回は単純に、起動している全てのアプリケーションに対し「元に戻す」を実行するというものにしました。</p>
<p>無変換＋矢印といい、Win＋矢印といい、ウィンドウ移動操作を多用してるのですが、狭い領域を有効活用というよりも、モニタ領域が広すぎる(2560x1600+(2048x1152)x2+1920x1200)からこそ移動類を充実させざるを得なかった、という側面があったりして。センターディスプレイ(30インチ2560x1600)はマルチディスプレイの中でも、当然一番見やすいモニタになるので、長めの作業を行う際は、普段は別のモニタに置いてあるアプリケーションもセンターに寄せて使います。なので、ワンタッチでセンターに寄せたり、左右に並べたりしたいわけです。それと私はゲーム(Xbox360)もセンターディスプレイに繋いでいるのでゲーム中はセンターが潰れます。ブラウザで攻略サイトを見たい、と思った時にセンターにブラウザがあると(基本はセンターに置いているので)移動させるのが面倒くさいので、これもまたワンタッチでサイドディスプレイに寄せたい、となるわけです。ゲーム終えたら、またワンタッチでセンターへ戻す。</p>
<h2>AutoHotKey.ini</h2>
<p><a href="http://neue.cc/wp-content/uploads/file/AutoHotkey.ini">現時点で私の使っているiniファイル</a>を置いておきますので、ご自由に使ってやってください。環境依存の部分が少なからずあるので、その辺は適当に除去しといてください。</p>
</div>
<h1><a href="https://neue.cc/2009/11/16_218.html">ver.1.3.0.8</a></h1>
<ul class="date"><li>2009-11-16</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>暴走してしまいました。大変申し訳ありませんでした。Xbox.comが半メンテナンスで、壊れたデータを放出していたのですが(例えばFallout3の最大実績が620になったり)、それを取得して解析していた結果、実績を超連続投稿するということが発生しました。今回のものは暴走抑止用の暫定対策版となっています。しかし確実に防げる保証はないので、利用はXbox.comが安定してからにしてください。また、お願いなのですがXboxInfoTwitが不調な場合は、またXboxInfoTwitのクソが不安定だぜ、と思うのは当然なのですけど、少しだけXbox.comのほうも疑ってあげてください。そして、Xbox.comが怪しかったら、その日は利用を控えるという形でお願いします。これからは、データが怪しい場合は弾くような処理も増やしていこうとは思いますが、それでも全ての怪しいケースを弾けるわけではないので。</p>
<p>暴走抑止のほか、とりあえず実績連続投稿の最大数は10に設定しました。5だと、場合によっては少ないケースも出てきそうなのでとりあえず10で。それと、今回のアップデートは全くテストしていないので、そもそも正常動作するかも分かりません。その辺は、Xbox.comが落ち着いたら見ていきたいと思っています。</p>
<p>あと、責任はとても重く感じています……。公開停止しようとも思ったのですが、誰もがこのサイトを見に来ているわけでは当然ないので、まずは修正して新しく起動する人が、自動アップデートで最低限の回避をするのが第一だと思いました。今後の公開停止ですが、既に相当数の利用者がいる状態なので、公開停止にしてメンテ放置するよりは、問題が起こった際にちゃんと面倒を見る方が重要だと考え、当分は公開を続けることにします。</p>
<h2>ver.1.3.0.9</h2>
<p>連続ですがまた更新。1.3.0.8では実績解除自体が100%投稿できない状態になってました。風呂に入って頭冷やしてたら思い違いに気づいてああああああ、となりました、はは。それと、暴走の原因らしきものが見えたので(原因自体はXbox.comのデータ壊れなのですが、どの部分がどういう風に壊れていたのか、というのが私自体が遭遇してないので想像でしかないのですよー) とりあえずそれへの対策を重点的に追加してみました。原因が見込み違いだったり、他の原因だった場合は、まあ、しょうがない。そういえば今日ダッシュボード機能追加なんですね。毎回、機能追加前はXbox.comも合わせてドタバタしますが、しかし今回ほど酷いこともなかった。ちなみにもう一つの実績解除ツールも暴走していたので、今回のは本当に本当に不測の事態というかXbox.comのデータの壊れ方が誰にとっても想定外でした。天下のMSなのだから、メンテ時でもしっかりやってくれ、というのは贅沢ですかね。</p>
</div>
<h1><a href="https://neue.cc/2009/11/11_215.html">ver.1.3.0.7</a></h1>
<ul class="date"><li>2009-11-11</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>CoD4やMW2、L4Dなんかで顕著に見られるようですが、オンライン対戦時の他プレイヤーが「参加可能」時にデータの取得に失敗して、ゲーム名に参加可能が付いていたり実績が0/0になっていたりするような件を修正しました。実のところ、これver1.3.0.1の時に修正したはずだったんですが、いつのまにやらその時対策したはずのコードが元に戻ってました。あらららら……。</p>
<p>といったように、非常にいい加減な開発姿勢なので今回のリリースでも更にバグ埋め込んだりする可能性大です。バグ見つけたら怒ってやってください。Twitter検索でキーワード「XboxInfoTwit」を始終チェックしてますので、もし不具合があったらTwitterでの投稿時に「XboxInfoTwit」と文中に混ぜておけば、例えば「XboxInfoTwitクソ、***で動かねえ」とか言ってくれれば私の方で巡回して気づくと思いますので、気楽に苦情文句要望バグ報告してやってください。</p>
<p>そういえばというわけでもないのですけど、利用ユーザー数が500超えました。いやー、ビックリですね。当初は2桁台に行けばいいなあ、とか言ってたぐらいだったり、実際致命的な不具合があったのに3ヶ月放置してたり(誰も使わないので気づかなかった！)などだったはずが。嬉しいです。が、現在のコード品質は相当アレなので、なるべく早く、せめて今年中には全面的に書き換えたver2.0を出せるといいなあ、なんて思っています。</p>
<p>ちなみに、amazonアサマシゲイツポイントの購入者数はゼロに近かったりします(買ってくれた人は本当に本当にありがとうございます)。いやまあ、別にネタなのでいいんですけどね。はは。</p>
</div>
<h1><a href="https://neue.cc/2009/11/09_214.html">F# TutorialをC#と比較しながらでF#を学ぶ</a></h1>
<ul class="date"><li>2009-11-09</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fsharpTutorial.jpg">
</p>
<p>F#はMicrosoft発の関数型言語で、Visual Studio 2010に標準搭載されます。<a href="http://msdn.microsoft.com/ja-jp/vstudio/dd582936(en-us).aspx" title="Visual Studio 2010 and .NET Framework 4 Beta 2">Visual Studio 2010 Beta 2</a>も出たことだし、話題の？新言語を少し勉強してみることにします。F#の新規プロジェクト一覧にTutorialというのが用意されているので、これの中身を、C#と比較しながら見ていきたいと思います。追記：<a href="http://www.microsoft.com/japan/visualstudio/products/2010/default.mspx" title="Microsoft Visual Studio 2010 First Look">Microsoft Visual Studio 2010 First Look</a> Beta 2日本語版も公開されました。</p>
<h2>基本</h2>
<p>```fsharp
open System
let int1 = 1
let int2 = int1 + 3
```
<pre><code class="language-csharp">using System;
var int1 = 1;
var int2 = int1 + 3;
```&lt;/p&gt;

名前空間の利用の設定と基本的な変数の代入方法。といったところでしょうか。そのまんまだし、別にC#と違いは特にないっぽい。C#ではvar、F#ではlet。どちらも推論が効くのでほとんど同じ。末尾セミコロンはいらないようです。#lightがどうたらこうたら、というのは略。それともう一つ、F#はこのように定義したint1に再代入は出来ません。int1 = 100とすると、比較になります(==ではなく=が比較)。再代入的なint1 &lt;- 1000はコンパイルが通らない。不変(immutable)なのです。C#だとreadonly、はフィールドにしかつけられないので、同じことを再現するのは無理なよう。

Print
---
```fsharp
printfn &quot;peekResult = %d&quot; peekResult
printfn &quot;listC = %A&quot; listC
</code></pre>
<p>F# TutorialではPrintは最後にあるのですが、あのですね、出来ればprintは冒頭にしていただきたいです。なんというか、私がF#で一番戸惑ったのが、printfn int1ってのが出来ないことなんですね。いやほら、とりあえずlet int1 = 1って書いたじゃないですか、最初に。で、書いたらとりあえず表示して確認したいでしょ？Console.WriteLineにあたるのはprintfnか、って来るわけです。でも、書いても動かないの。で、まあ、つまるところstring.Format的なものであり書式指定が必要、というところまで行くわけですが、そこで書式って何を書けばいいの？ということになるわけです。&quot;%d&quot;とか予告なく言われても分からないし。もうブチ切れですよ。え、Cの書式指定と一緒だって？いやあ、Cの書式指定も全然覚えてられません、あれあんま良くないと思うんですが……(ついでに言えば私はC#の書式指定も全然覚えてない、必要な度にMSDN見に行ってる)。しかもF#のは書式も色々拡張されてない？より一層分からん！int1の出力で挫折する！</p>
<p>ということなので、もっと頭の方にprintfnのきちんとした解説を載せてくれないと辛いです。ただ、どうしてもアレならConsole.WriteLine int1とでも書けば動く。おお、いきなり.NET Frameworkがそのまま使えることの有難味が(笑) と、冗談はさておき、この「書式指定に何が使えるのか分からない」状態はひっじょーに気持ち悪いので、検索してすぐ分かるような場所に一覧が、欲しい、です。真面目にこれは挫折理由になってます。しょうがないので検索して出てきた
<a href="http://books.google.co.jp/books?id=NcrMkjVxahMC&amp;pg=PA91&amp;dq=F%23+using+printf&amp;as_brr=3&amp;ei=HAT4SpvrG5OilQTrx6nSBQ#v=onepage&amp;q=F%23%20using%20printf&amp;f=false" title="Expert F# - Google ブックス">Google BooksのExpert F#の解説</a>を見てようやくホッとできた。</p>
<p>%b(bool), %s(string), %d(10進), %f(float), %O (Object.ToString()) それと%A(Any)を覚えておけば問題ない、でしょーか。ほんと予告なく%Aとか言われても困るんですよ、泣きたいですよ。%Oとの違いは、人間が見た時に良い感じに整形してくれるのが%A、でしょうか。文字列は&quot;&quot;で囲まれ、配列は展開して出力してくれる。</p>
<p>C#ではcw-&gt;TabTab-&gt;変数名、といった感じにコードスニペットを活かして手早く記述出来たわけですが、それに比べるとF#は書式指定が必要な時点で、非常にカッタルイ。カッタルイのですが、かわりに、より型に厳格です。printfn &quot;%s&quot; trueとか書くとコンパイル通らない。良し悪し、でしょうか。でも学習用にやってる間は面倒くさいだけですね。どうしても嫌ならば「let p x = printfn &quot;%A&quot; x」とでも定義しておけば良いのでしょうけれど。</p>
<p>gdgd言う前に<a href="http://msdn.microsoft.com/en-us/library/dd233181(ja-jp,VS.100).aspx">F C# 言語リファレンス</a>を見ろ、って話なのかもしれない。私は情けないことにここから書式指定を記した部分を見つけられませんでしたが。あと、選択範囲で囲んでAlt+EnterでF# Interactiveに送られるのでそれ見て確認しろって話も少しはありそう。</p>
<h2>関数</h2>
<p>```fsharp
let f x = 2*x*x - 5*x + 3
let result = f (int2 + 4)
let rec factorial n = if n=0 then 1 else n * factorial (n-1)
```
<pre><code class="language-csharp">Func&lt;int, int&gt; f = x =&gt; 2 * x * x - 5 * x + 3;
var result = f(int2 + 4);
Func&lt;int, int&gt; factorial = null;
factorial = n =&gt; (n == 0) ? 1 : n * factorial(--n);
```&lt;/p&gt;

Tutorialには最大公約数を求めるものもありましたがfactorialと同じなので省略。F#は関数型言語ということで、やっぱ関数ですよね！キーワードはletのままで、ふつーの変数と区別なく定義できる。 C#では汎用デリゲートであるFuncとActionを使うことでそっくり再現できる。C#では型を書いてやらなければならないのだけど、F#ではより強力に推論が効くようで型の明示は不要、のようです。

再帰は、F#はlet recキーワードでそのまま書けるのに対し、C#では一度nullを代入して名前を事前に宣言しておかなければならない。というぐらいで、見た目はほとんど変わらない。そういえばifが式ですね。なのでelseは省略できないようです。else ifの連打はelifで。というわけで、このif式（？）はC#の三項演算子とほとんど同じような感じです。

```fsharp
let add1 x y = x + y
printfn &quot;%A&quot; (add1 1.0 2.0)
printfn &quot;%A&quot; (add1 1 2) // Compile Error
let add2 x y = x + y
printfn &quot;%A&quot; (add2 1 2)
printfn &quot;%A&quot; (add2 1.0 2.0) // Compile Error
</code></pre>
<p>少し脱線して型推論の話を。C#の推論は単純なだけ分かりやすくて、これは型書いてやらないといけないな、推論させるための材料を与えてあげないといけないな、というのが結構直感的だったんですが、F#だと強力な分だけ、どう推論されるのか難しい。今は漠然と、全体を見るんだなー、ぐらいにしか分かっていません。例のコードですが、add1はfloat-&gt;float-&gt;floatで、add2はint-&gt;int-&gt;intに推論されます。let add1 x y = x + yの時点ではxの型もyの型も分からないけれど、「最初に呼ばれた時に」引数の型は判明する、ということは戻り値の型も判明する。なので、その型で決定する。ということなのかなー、と。この部分はC#と全然違っていて、面白いし強力だなー、と。</p>
<h2>Tuple</h2>
<p>```fsharp
let data = (1, "fred", 3.1415)
let Swap (a, b) = (b, a)
```
<pre><code class="language-csharp">var data = Tuple.Create(1, &quot;hogehoge&quot;);
static Tuple&lt;T2,T1&gt; Swap&lt;T1,T2&gt;(Tuple&lt;T1,T2&gt; tuple)
{
    return Tuple.Create(tuple.Item2, tuple.Item1);
}
```&lt;/p&gt;

TupleはC#4.0から導入されます。F#は括弧で括るという専用記法があるので簡単に記述出来る。のに対して、C#ではふつーのclassなのでふつーにclassとして使うしかないのが残念。Swapですが、Tupleはimmutable(不変)なので、新しく生成する。だけ。です。temp用意して入れ替えて、などしない。潔く新しく作る。

Boolean, Strings
---
&lt;p&gt;```fsharp
let boolean1 = false
let boolean2 = not boolean1 &amp;&amp; (boolean1 || false)
let stringA  = &quot;Hello&quot;
let stringB  = stringA + &quot; world.&quot;
</code></pre>
<pre><code class="language-csharp">var boolean1 = false;
var boolean2 = !boolean1 &amp;&amp; (boolean1 || false);
var stringA = &quot;Hello&quot;;
var stringB = stringA + &quot;world.&quot;;
```&lt;/p&gt;

F#では否定が!ではなくnotなのですね。あとは一緒。

List
---
&lt;p&gt;```fsharp
let listA = [ ]
let listB = [ 1; 2; 3 ]
let listC = 1 :: [2; 3]
let oneToTen = [1..10]
let squaresOfOneToTen = [ for x in 0..10 -&gt; x*x ]
</code></pre>
<pre><code class="language-csharp">var listA = Enumerable.Empty&lt;object&gt;();
var listB = new[] { 1, 2, 3 }.ToList();
var listC = Enumerable.Repeat(1, 1).Concat(new[] { 2, 3 }).ToList();
var oneToTen = Enumerable.Range(1, 10 - 1 + 1).ToList();
var squaresOfOneToTen = Enumerable.Range(0, 10 - 0 + 1).Select(x =&gt; x * x).ToList();
```&lt;/p&gt;

リストを扱うとC#と大分差が出てきます。まず第一に、空リストは、C#だと該当するものは作れない。と思う。とりあえずobjectで代替することにしましたが、多分正しくありません。listBはただの整数リストなわけですが、F#だと;で区切るようです。一応、配列とリストは違うということで、C#側のコードはListにしていますがListとも違うので、まあ、気分だけ。listCの::はConsということで、一つの値とリストを連結するものです。C#に該当する関数はありません。しいていえばConcatが近いので、Repeat(value, 1)で長さ1のシーケンスを作って連結、という手を取ることにしました。

F#は[1..10]で最小値-最大値の連続したリストが作れるのですが、これはC#のEnumerable.Rangeとは、違います。Rangeの第二引数は最大値ではなく個数なので。正直言って、個数よりも最大値のほうが使いやすいと思うのだけどなー。というわけで、最大値-最小値+1 = 個数。ということにしています。最後のリスト内包表記は、うん、ええと、私は苦手です。値の動きが右行ったり左行ったりなのが嫌です。Linqのほうが好き。C#でイメージするなら、foreach (var x in [0..10]) yield return x * x; ってとこですかね。

パターンマッチ
---
&lt;p&gt;```fsharp
let rec SumList xs =
    match xs with
    | []    -&gt; 0
    | y::ys -&gt; y + SumList ys
let listD = SumList [1; 2; 3]  
</code></pre>
<pre><code class="language-csharp">Func&lt;IEnumerable&lt;int&gt;, int&gt; SumList = null;
SumList = xs =&gt; (!xs.Any())
    ? 0
    : xs.First() + SumList(xs.Skip(1));

var sum1 = SumList(new[] { 1, 2, 3 });
var sum2 = new [] { 1, 2, 3 }.Sum(); // こらこら
```&lt;/p&gt;

まず、listDとかF# Tutorialには書いてあるんですが、これintなのでlistじゃないでしょ！紛らわしい。さて、match with | -&gt;という目新しい記述がパターンマッチという奴ですね？ 引数のリストxs(リストは通常変数名にxsとかysとかを用いるようです)が空配列の時は0を、そうでない時はyとysに分解して、ysの方は再帰して足し合わせる。ふむぬん。C#に直すとif-else if-else ifの連打。値を返すから、三項演算子のネストですな。という程度の理解しかしていません。三項演算子ネストより綺麗に書けて素敵。という浅すぎる理解しか、今はしていません。まあ、そのうちそのうち。

y::ysという表記ですが、これは配列中の最初のものがy、それ以外がysになります。つまりLinqだとFirst()とSkip(1)ですね。let x::xs = [3..5]とすれば、xが3でxsが4,5になる。警告出ますが。基本はパターンマッチ時用ってことなのかしらん。この辺はちょっと良く分かりません。

C#のほうの、IEnumerableのままSkipをゴロゴロと繋げていくのは実行効率がアレな悪寒。かといってToArrayを毎回使うのもなあ、というわけで上手い落し所が見つからない。QuickSortのように一本の配列に対し、境界の数字を渡していくってのやるとゴチャゴチャするし。あ、でもF#のも結局ysってのはxsとは別の、新しい配列ですよね？C#で表すのならば、xs.Skip(1).ToArray()ということかしらん。だとしたら、この程度の「効率」なんて奴は、気にしたら負けだと思っている。でいいのかもしれない。よくないかもしれない。

配列・コレクション
---
&lt;p&gt;```fsharp
let arr = Array.create 4 &quot;hello&quot;
arr.[1] &lt;- &quot;world&quot;
arr.[3] &lt;- &quot;don&quot;
let arrLength = arr.Length        
let front = arr.[0..2]
let lookupTable = dict [ (1, &quot;One&quot;); (2, &quot;Two&quot;) ]
let oneString = lookupTable.[1]
</code></pre>
<pre><code class="language-csharp">var arr = Enumerable.Repeat(&quot;hello&quot;, 4).ToArray();
arr[1] = &quot;world&quot;;
arr[3] = &quot;don&quot;;
var arrLength = arr.Length;
var front = new string[3];
Array.Copy(arr, 0, front, 0, 3);
// もしくはSkip-&gt;Take. 実行効率は劣りますが、私はこちらの記述方法のほうが好き
var front2 = arr.Skip(0).Take(3).ToArray();
var lookupTable = new Dictionary&lt;int, string&gt; { { 1, &quot;One&quot; }, { 2, &quot;Two&quot; } };
var oneString = lookupTable[1];
```&lt;/p&gt;

配列とlistとの違い。listは不変(immutable)で、配列は可変(mutable)ということかしらん。あと配列なら.NET Frameworkのメソッド・プロパティが全部使える。mutableなものへの値の再代入は=ではなく&amp;lt;-で行う。あとは、Array.createは中身がnullな配列ではなく、初期値を指定して全部それで埋めるメソッドのようです。ふむ。あ、最後のslicing notationはいいですね。C#だとArray.Copyを使うのが等しいでしょうけど、記述が冗長すぎてねえ……。どうせ実行時間に対して差は出ないでしょ、と思う場合はLinqでSkip-&gt;Takeにしたほうがすっきり書けて良い。あ、あとインデクサは.[]が対応してるようです。ドット。ドット。

辞書の初期化は、タプルを放り投げるだけ。素晴らしい！見た目に分かりやすくスッキリするのがいいです。C#だとコレクション初期化子で近い形にはなりますが、{ {と、全て波括弧で記述するのはどうかなあ、と思うところがあるので。あとは一応、[C# 3.0 における疑似 Map 生成リテラル - NyaRuRuの日記](http://d.hatena.ne.jp/NyaRuRu/20071211/p3)なんてことも出来ますけれど、やりませんものね。

関数(その2)
---
&lt;p&gt;```fsharp
let Square x = x*x              
let squares1 = List.map Square [1; 2; 3; 4]
let squares2 = List.map (fun x -&gt; x*x) [1; 2; 3; 4]
let squares3 = [1; 2; 3; 4] |&gt; List.map (fun x -&gt; x*x) 
let SumOfSquaresUpTo n = 
  [1..n] 
  |&gt; List.map Square 
  |&gt; List.sum
</code></pre>
<pre><code class="language-csharp">public static IEnumerable&lt;TR&gt; Map&lt;T, TR&gt;(this Func&lt;T, TR&gt; selector, IEnumerable&lt;T&gt; source)
{
    return source.Select(selector);
}

// ↑という拡張メソッドを定義して

Func&lt;int, int&gt; Square = x =&gt; x * x;
var squares1 = Map(Square, new[] { 1, 2, 3, 4 });
var squares2 = new Func&lt;int, int&gt;(x =&gt; x * x).Map(new[] { 1, 2, 3, 4 });
var squares3 = new[] { 1, 2, 3, 4 }.Select(x =&gt; x * x).ToArray();
// もしくは Array.ConvertAll(new[] { 1, 2, 3, 4 }, x =&gt; x * x)
Func&lt;int, int&gt; SumOfSquaresUpTo = n =&gt;
    Enumerable.Range(1, n - 1)
        .Select(i =&gt; Square(i))
        .Sum();
```&lt;/p&gt;

関数が先で、それに適用する配列を渡す、という順序はC#ばかり触ってる身としては、新鮮な印象です。そういえば[Achiral](http://d.hatena.ne.jp/NyaRuRu/20080115/p1)にも同種のオーバーロードが沢山定義されているのですが、私は違和感から、IEnumerable始点のものばかり使っています。あとSelect-&gt;ToArrayはArray.ConvertAllで書けるのですが、私はLinqで書くほうが好き。というかArrayの静的メソッドは、基本Obsoleteなぐらいの気持ちでいたりいなかったりする。

ラムダ式は「fun 引数 -&gt; 本体」ですね。C#のほうがキーワードが必要ない分だけすっきりしてガガガ。でもnew Func&lt;型&gt;という不格好なものをつけなければならなかったりする悪夢。var hoge = (int x) =&gt; x * xもダメなんですよねえ。理由は、例えば「delegate int Func2(int i);」というのが定義出来るから。引数intで戻り値intだから、Func&lt;int, int&gt;とFunc2は同じ。でも型は違う。なので、見分けがつかず推論できないので、どのデリゲートを使うか、まで指定する必要がある。これは、悲しくウザい話です。ActionとFunc以外のデリゲート型なんて滅びてしまえばいいのに。

「|&gt;」という見慣れない演算子が、パイプライン演算子で、左から右に値を流す。C#だと、Listに対してはLinqで、値に対しては、そういえば前に書いたような……。[neue cc - ver 1.3.0.3 / ちょっとした拡張メソッド群](http://neue.cc/2009/07/16_177.html)のTapの一個目が近い感じでしょーか。いいですよね、こういうの。

Mutable
---
&lt;p&gt;```fsharp
let mutable sum = 0
for i in 0..10 do
  sum &lt;- sum + i
while sum &lt; 100 do
  sum &lt;- sum + 5
</code></pre>
<pre><code class="language-csharp">var sum = 0;
foreach (var i in Enumerable.Range(0, 10))
{
    sum += i;
}
while (sum &lt; 100)
{
    sum += 5;
}
```&lt;/p&gt;

最初にF#の値はimmutableだと書きましたが、mutableにしたい時は、mutableキーワードを足せばおｋ。再代入時は&amp;lt;-演算子を使う、と。C#だとデフォルトがmutableなので、まんまです。そして、このforは、foreachですね。インデントが波括弧代わりなので、doだけどendは要りません。普通のforは「for i = 1 to 10 do」ですが、これならforeachでいいやあ、という気はする。

Types: unions
---
&lt;p&gt;```fsharp
type Expr = 
  | Num of int
  | Add of Expr * Expr
  | Mul of Expr * Expr
  | Var of string
  
let rec Evaluate (env:Map&lt;string,int&gt;) exp = 
    match exp with
    | Num n -&gt; n
    | Add (x,y) -&gt; Evaluate env x + Evaluate env y
    | Mul (x,y) -&gt; Evaluate env x * Evaluate env y
    | Var id    -&gt; env.[id]
  
let envA = Map.of_list [ &quot;a&quot;,1 ;
                         &quot;b&quot;,2 ;
                         &quot;c&quot;,3 ]
             
let expT1 = Add(Var &quot;a&quot;,Mul(Num 2,Var &quot;b&quot;))
let resT1 = Evaluate envA expT1
```&lt;/p&gt;

F# Tutorialですが、ここで途端に説明が無くなって放り出されます。鬼すぎる。今までのわりとゆるふわなところから途端にコレです。意味分からないし。unionsとか言われても分けわからない。と、嘆いていても始まらないので理解するよう頑張ります。そういえば(env:Map&amp;lt;string,int&gt;)も初出なのよね。推論じゃなく明示的に型を与える時は、こうするそうです。型定義がC#とは逆で、コロン後の末尾。違和感がシンドい。ActionScriptなんかも同じで非常にシンドい。

unionはC#だとenumが近いかなー、と思うのですが、enumがintのみなのに対し、F#のunionはそれぞれが別の型を持てる。といった認識。更に値は外から定義可能。というわけでenumとは全然違いますな。むしろ普通にclassに近い。of intで型を定義している(Expr * ExprはTuple)し、値は外から与えているし(コンストラクタのように！) けれど、値は一個。

じゃあclassで作れるかと言ったら、どうだろー。戻り値の型がバラバラになるので、interfaceで一個に纏められるわけでもなく上手いやり方ってあるのかしらん。パターンマッチと同じく、C#には無い概念、と素直にとらえた方が良いかも。一応、interface、じゃなくてダミーに近い型の下にぶら下げて、Evaluateのところでisで派生型を判定して分岐、といった感じでやってみましたが、ゴミですね……。

```csharp
public class Expr
{
    // privateにしたいつもり(これは酷い)
    public class _Num : Expr
    {
        public int Value { get; set; }
    }
    public class _Add : Expr
    {
        public Expr E1 { get; set; }
        public Expr E2 { get; set; }
    }
    public class _Mul : Expr
    {
        public Expr E1 { get; set; }
        public Expr E2 { get; set; }
    }
    public class _Var : Expr
    {
        public string Value { get; set; }
    }

    private Expr() { }

    public static Expr Num(int value)
    {
        return new _Num { Value = value };
    }
    public static Expr Add(Expr e1, Expr e2)
    {
        return new _Add { E1 = e1, E2 = e2 };
    }
    public static Expr Mul(Expr e1, Expr e2)
    {
        return new _Mul { E1 = e1, E2 = e2 };
    }
    public static Expr Var(string value)
    {
        return new _Var { Value = value };
    }
}

static int Evaluate(IDictionary&lt;string, int&gt; env, Expr exp)
{
    return // どうしょうもなく酷い
          (exp is Expr._Num) ? ((Expr._Num)exp).Value
        : (exp is Expr._Add) ? Evaluate(env, ((Expr._Add)exp).E1) + Evaluate(env, ((Expr._Add)exp).E2)
        : (exp is Expr._Mul) ? Evaluate(env, ((Expr._Mul)exp).E1) + Evaluate(env, ((Expr._Mul)exp).E2)
        : (exp is Expr._Var) ? env[((Expr._Var)exp).Value]
        : 0;
}

static void Main(string[] args)
{
    var envA = new Dictionary&lt;string, int&gt; { { &quot;a&quot;, 1 }, { &quot;b&quot;, 2 }, { &quot;c&quot;, 3 } };
    var expT1 = Expr.Add(Expr.Var(&quot;a&quot;), Expr.Mul(Expr.Num(2), Expr.Var(&quot;b&quot;)));
    var resT1 = Evaluate(envA, expT1);
    Console.WriteLine(resT1); // 確認
}
</code></pre>
<p>見なかったことにしてください。私の脳みそなんてこんなもんです。</p>
<h2>Types: records</h2>
<p>```fsharp
type Card = { Name  : string;
              Phone : string;
              Ok    : bool }
              
let cardA = { Name = "Alf" ; Phone = "(206) 555-8257" ; Ok = false }
let cardB = { cardA with Phone = "(206) 555-4112"; Ok = true }
let ShowCard c = 
  c.Name + " Phone: " + c.Phone + (if not c.Ok then " (unchecked)" else "")
```
<pre><code class="language-csharp">class Card
{
    public string Name { get; set; }
    public string Phone { get; set; }
    public bool Ok { get; set; }

    public Card() { }

    public Card(Card with)
    {
        // structならthis=withで一発なのですが
        // F#のrecordはstructじゃないとのことなので
        this.Name = with.Name;
        this.Phone = with.Phone;
        this.Ok = with.Ok;
    }
}

var cardA = new Card { Name = &quot;Alf&quot;, Phone = &quot;(206) 555-8257&quot;, Ok = false };
var cardB = new Card(cardA) { Phone = &quot;(206) 555-4112&quot;, Ok = true };
Func&lt;Card, string&gt; ShowCard = c =&gt;
    c.Name + &quot; Phone: &quot; + c.Phone + (!c.Ok ? &quot; (unchecked)&quot; : &quot;&quot;);
```&lt;/p&gt;
    
こちらは割とすんなりと何なのか分かる。withでコピーが作れているところが面白い。ふーむ、C#だとむしろ匿名型のほうが近い感じに見えるかもしれない。

Types: classes
---
&lt;p&gt;```fsharp
type Vector2D(dx:float, dy:float) = 
    let length = sqrt(dx*dx + dy*dy)
    member v.DX = dx
    member v.DY = dy
    member v.Length = length
    member v.Scale(k) = Vector2D(k*dx, k*dy)
</code></pre>
<pre><code class="language-csharp">class Vector2D
{
    public float DX { get; private set; }
    public float DY { get; private set; }
    public float Length { get; private set; }
    public Func&lt;int, Vector2D&gt; Scale { get; private set; }

    public Vector2D(float dx, float dy)
    {
        var length = (float)Math.Sqrt(dx * dx + dy * dy);
        this.DX = dx;
        this.DY = dy;
        this.Length = length;
        this.Scale = new Func&lt;int, Vector2D&gt;(k =&gt; new Vector2D(k * dx, k * dy));
    }
}
```&lt;/p&gt;

コンストラクタと定義が一体化していて、随分とシンプルに記述出来るようです。JavaScriptっぽい、なんて思ってしまったりして。C#で再現するとプロパティでメソッドかいな、という違和感があったりなかったり。private変数で蓄える必要がないから、定義が楽といえば楽。ところで思うのは、F#のv.DXとかの、vって何処から来てるの……？ これ、別にhogehogeにしてもaaaaaaにしても動くので、何でもいいみたいですが……。

Types: interfaces
----
&lt;p&gt;```fsharp
type IPeekPoke = 
    abstract Peek: unit -&gt; int
    abstract Poke: int -&gt; unit

type Widget(initialState:int) = 
    let mutable state = initialState
    interface IPeekPoke with 
        member x.Poke(n) = state &lt;- state + n
        member x.Peek() = state 
    member x.HasBeenPoked = (state &lt;&gt; 0)

let widget = Widget(12) :&gt; IPeekPoke
widget.Poke(4)
let peekResult = widget.Peek()
</code></pre>
<pre><code class="language-csharp">interface IPeekPoke
{
    int Peek();
    void Poke(int n);
}

class Widget : IPeekPoke
{
    private int state;
    public bool HasBeenPoked { get { return state != 0; } }

    public Widget(int initialState)
    {
        state = initialState;
    }

    public int Peek()
    {
        return state;
    }

    public void Poke(int n)
    {
        state = state + n;
    }
}

static void Main(string[] args)
{
    var widget = (IPeekPoke)new Widget(12);
    widget.Poke(4);
    var peekResult = widget.Peek();
}
```&lt;/p&gt;

interfaceはabstractな型定義を並べる。ということらしい。定義方法は「メソッド名:引数-&gt;引数-&gt;戻り値」ですねん。unitはC#でいうところのvoidみたいなもの。で、interfaceの実装は、そのまま中に記述してしまえばいいらしい。これは楽ちん。見慣れない「:&gt;」はキャストの記号。とても、カッコイイです……。

結論
---

以上、複数回に分けようかとも思ったのですが一気にやってみました。最初F# Tutorialを開いて、少な！こんなんでチュートリアルになってるの？と思ったのですが、意外とギッシリ詰まってた感じです。しっかりチュートリアルになってました。ただ、やっぱチュートリアルなのでこれを覚えたぐらいじゃF#凄い！F#嬉しい！的にはなりません(比較対象がC#2.0だとなったかもしれませんが)でした。日常的に使って、手に馴染ませないと、良さの理解まではいけなさそうです。

あとまあ、やっぱほとんど説明のない、このTutorialのコードだけじゃ適当な理解になってそうで怖い。きちんと時間割いてMSDN見るなりしないと……。ただ、今のとこがっつし覚えよう！と思えてないところはある。本音として、C#でいいぢゃん、と思っているところがかなりあります。これがJava-&gt;Scalaの関係だったら違ったかもしれないんですが、うーん。まあ、あとVisualStudioの補完具合とかかな。IntelliSenseに乗ってゴリゴリ書けるような感触がF#にはないので。別に補完効いてないってわけじゃあないのですけど。
</code></pre>
</div>
<a href="https://neue.cc/2009/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
