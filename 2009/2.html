<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2009</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet" />
    <meta property="og:url" content="" />
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <div id="header"></div>
        <div id="content"><h1><a href="https://neue.cc/2009/11/05_213.html">C#でTwitterのStreaming APIを使ってリスト自動追加</a></h1>
<ul class="date"><li>2009-11-05</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">XboxInfoTwit</a>の認証数は現在450を越えて、近いうちに500には届きそうです。現在の実装はIEを裏で動かすという、しょーもないものになっていて、それに起因する不具合や、どうしょうもない点が幾つかあるため、クローラー部分は全面的に書き変えようと思っています。あと、エラーメッセージがド不親切とか至らない点だらけでした、すみません。そんな次期バージョンの作業は全然捗ってないのですが、せめて年内ぐらいには何とかしたいです。</p>
<h2>@のお話</h2>
<p>ゲーム名に@が含まれるものをポストする(例えばTHE IDOLM@STER)と、STERさんに@が飛んで迷惑。というお話を見たので検証してみました。@は行頭かスペース + @ + 数字/アルファベットのものがあると飛びます。つまり、@の前にアルファベットがあれば@は飛びません。なので、別にIDOLM@STERだからってSTERさんに@が飛びまくる、なんてことはありません。正規表現で表すと「(?&lt;=^| )@[a-zA-Z0-9_]+」になります。ついでに、ハッシュタグのほうも軽く検証してみました。基本的には@と同じですが、英単語以外にもリンクが張られるようなので、正規表現は「(?&lt;=^| )#[^ ]+」になるようです。</p>
<h2>List</h2>
<p>Twitterにリストが実装されました。そこで、<a href="https://twitter.com/neuecc/xboxinfotwitusers" title="Twitter / @neuecc/XboxInfoTwitUsers">XboxInfoTwitユーザーのリスト</a>を作ってみることにしました。手動で探して登録も大変なので、プログラムでクロールして追加していきましょう。パブリックイタイムラインからXboxInfoTwit利用者(Source=XboxInfoTwit)の人を片っ端からリスト登録するという方針で行きます。以下、C#でのTwitterストリーミングAPIの使用法と実際のコードになります。同じようなことをやりたい人は、適当に書き替えてどうぞ使ってください。突っ込みどころ多数なのでむしろ突っ込んで欲しい……。</p>
<p>2010/4/29 追記：このコードはストリームAPIの利用法にしては冗長すぎるので、書き直しました → <a href="http://neue.cc/2010/04/29_255.html" title="neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions">neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions</a> ストリームAPI取得コードを参考にする場合は、新しいほうを見てください。</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.Xml.Linq;
using System.Collections.Specialized;
using System.Threading;
using System.Xml;

static class Program
{
    // ザ・決めうち文字列s
    const string UserName = &quot;neuecc&quot;; // 自分のアカウントのユーザー名を
    const string Password = &quot;password&quot;; // 同じくパスワードを
    const string ListName = &quot;xboxinfotwitusers&quot;; // リストを、入力ですです
    const string StreamApi = &quot;http://stream.twitter.com/1/statuses/sample.xml&quot;;
    const string ListMembersApiFormat = &quot;http://twitter.com/{0}/{1}/members.xml&quot;;

    /// &lt;summary&gt;指定リストにメンバーを追加する&lt;/summary&gt;
    static void AddMemberToList(string userName, string listName, int id)
    {
        var url = string.Format(ListMembersApiFormat, userName, listName);
        var wc = new WebClient { Credentials = new NetworkCredential(UserName, Password) };
        wc.UploadValues(url, new NameValueCollection() { { &quot;id&quot;, id.ToString() } });
    }

    /// &lt;summary&gt;指定リストのメンバーIDを全て取得する&lt;/summary&gt;
    static IEnumerable&lt;int&gt; EnumerateListMemberID(string userName, string listName)
    {
        var format = string.Format(ListMembersApiFormat, userName, listName) + &quot;?cursor={0}&quot;;
        var cursor = -1L;
        var xmlReaderSettings = new XmlReaderSettings
        {
            XmlResolver = new XmlUrlResolver { Credentials = new NetworkCredential(UserName, Password) }
        };
        while (true)
        {
            using (var xr = XmlReader.Create(string.Format(format, cursor), xmlReaderSettings))
            {
                var xEle = XElement.Load(xr);
                foreach (var item in xEle.Descendants(&quot;user&quot;).Select(x =&gt; (int)x.Element(&quot;id&quot;)))
                {
                    yield return item;
                }
                cursor = long.Parse(xEle.Element(&quot;next_cursor&quot;).Value);
                if (cursor == 0) yield break;
            }
        }
    }

    /// &lt;summary&gt;ストリームAPIのパブリックタイムラインから無限に取得&lt;/summary&gt;
    static IEnumerable&lt;XElement&gt; EnumeratePublicTimeline(StreamReader reader)
    {
        while (true)
        {
            var xmlString = reader.EnumerateLines()
                .TakeWhile(s =&gt; s != &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;)
                .Join();
            if (xmlString == &quot;&quot;) continue;
            yield return XElement.Parse(xmlString);
        }
    }

    /// &lt;summary&gt;サーバーが死んでないか確認&lt;/summary&gt;
    static bool IsServerStatusOK()
    {
        var req = WebRequest.Create(&quot;http://twitter.com/help/test.xml&quot;);
        HttpWebResponse res = null;
        try
        {
            res = (HttpWebResponse)req.GetResponse();
            if (res.StatusCode == HttpStatusCode.OK) return true;
        }
        catch (WebException e) { Console.WriteLine(e); }
        finally { if (res != null) res.Close(); } // どうでもいいと思っていたり

        return false;
    }

    static void Main(string[] args)
    {
        ServicePointManager.Expect100Continue = false; // おまじない(笑)
        var count = 0; // モニタリング用のカウント変数(動作的には別に使わない)

        var following = new HashSet&lt;int&gt;(EnumerateListMemberID(UserName, ListName));
        var webRequest = (HttpWebRequest)HttpWebRequest.Create(StreamApi);
        webRequest.KeepAlive = true;
        webRequest.Credentials = new NetworkCredential(UserName, Password);

    LOOP:
        using (var res = webRequest.GetResponse())
        using (var stream = res.GetResponseStream())
        using (var reader = new StreamReader(stream))
        {
            try
            {
                // 例外が発生しなければ、無限リピートになっているのでこの部分を永久に続けます
                EnumeratePublicTimeline(reader)
                    .Do(_ =&gt; { if (++count % 100 == 0) Console.WriteLine(&quot;{0} : {1}&quot;, DateTime.Now, count); }) // 確認表示用
                    .Where(x =&gt; x.Name == &quot;status&quot;)
                    .Select(x =&gt; new
                    {
                        Source = x.Element(&quot;source&quot;).Value,
                        ID = (int)x.Element(&quot;user&quot;).Element(&quot;id&quot;),
                        Name = x.Element(&quot;user&quot;).Element(&quot;screen_name&quot;).Value
                    })
                    .Where(a =&gt; a.Source.Contains(&quot;XboxInfoTwit&quot;))
                    .Do(a =&gt; Console.WriteLine(&quot;Found:{0}&quot;, a.Name)) // ここでも確認表示用
                    .Where(a =&gt; following.Add(a.ID))
                    .ForEach(a =&gt;
                    {
                        AddMemberToList(UserName, ListName, a.ID);
                        Console.WriteLine(&quot;{0} : {1} : {2}&quot;, a.Name, DateTime.Now, count); // 確認表示用
                    });
            }
            catch (IOException e)
            {
                Console.WriteLine(e); // 接続が閉じられてたりするのでー。
                while (!IsServerStatusOK())
                {
                    Thread.Sleep(TimeSpan.FromMinutes(5)); // サーバー死んでたら5分間お休み
                }
            }
            finally
            {
                webRequest.Abort(); // これ呼ぶ前にCloseするとハング
            }
        }
        goto LOOP; // goto! goto!
    }

    // Extension Methods

    public static IEnumerable&lt;string&gt; EnumerateLines(this StreamReader streamReader)
    {
        while (!streamReader.EndOfStream)
        {
            yield return streamReader.ReadLine();
        }
    }

    public static string Join&lt;T&gt;(this IEnumerable&lt;T&gt; source)
    {
        return source.Aggregate(new StringBuilder(), (sb, s) =&gt; sb.Append(s)).ToString();
    }

    public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
    {
        foreach (var item in source)
        {
            action(item);
        }
    }

    public static IEnumerable&lt;T&gt; Do&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
    {
        foreach (var item in source)
        {
            action(item);
            yield return item;
        }
    }
}
</code></pre>
<p>ストリーミングAPIとは無関係のリスト関連の処理や、投げやりなtry-catch-gotoがあって、ちょっとゴチャゴチャしてますが、基本的にはusing三段重ねの部分だけです。無限にXMLが継ぎ足されてくるので、接続を切らさずひたすらReadLine。XMLの切れ目は、XML宣言部を使うことにしましたが、今一つスマートではないです。文字列にしてParseってのもあまり良い感じじゃなく。あ、あと例外処理は全然出来てませんので何かあると平然と死にます。</p>
<p>コードは、書き捨て感全開。例によって何でもLinq、何でもIEnumerable。コレクションになりそうな気配があると、すぐにじゃあyieldね、と考える癖がついてしまっていて。細かいことは後段に任せればいーんだよ、というのが楽ちんでして。リストメンバー全件取得の部分なんかは、わりとスマートに書けてるかと思うのですがどうでしょう。</p>
<p>なお、このストリーミングAPIは全件を漏れなく取得出来るわけではないので、それなり、というかかなり漏れが出ます。なのでXboxInfoTwit使ってるのに登録されねーぞ、という場合は、しょーがない。です。そのうち登録されると思います。あと、このプログラムはサーバー上で24時間動かしているわけじゃなく、私のローカルPC上で動かしているだけなので、私の気まぐれで動かしてたり動かしてなかったりします。私が寝てる間はPCがウルサイので動いてませんし、私が家に居ない時は省エネのために動いてません。なので、むしろ登録されるほうが珍しいです。レアです。効率的には20000件に1人登録出来るか出来ないか、って感じでした。一時間に一人見つかるかどうかも怪しいぐらいの頻度。とてもレア。ぶっちゃけgoogle経由で引っ張ってくるとかしたほうが遙かに効率良さそうですが、まあ、Streaming API使ってみたかったというだけなので。</p>
<p>そういえばですが、逆にリストに登録されてUZEEEE、という場合は、現状はリスト機能がベータのせいなのか拒否は出来ないようです。すみません。UZEEEE、と思っても我慢してください。どうしても嫌な場合は私の方にメッセージをくれれば、リストからの撤去と、プログラムから以後の追加をしないようなコードを入れたいと思っています。</p>
</div>
<h1><a href="https://neue.cc/2009/11/01_212.html">Replace, Intersperse, Init</a></h1>
<ul class="date"><li>2009-11-01</li></ul>
<div class="entry_body"><pre><code class="language-csharp">static void Main(string[] args)
{
    // 1,2,3,4,5,6,7,8,9,10
    var source = Enumerable.Range(1, 10);
    // 偶数を-1に置換する
    var replace = source.Replace(i =&gt; i % 2 == 0, -1);
    // 値を挟み込む(1,100,2,100,...9,100,10)
    var intersperse = source.Intersperse(100);
    // 末尾一個を省く(1..9)
    var init1 = source.Init();
    // 末尾三個を省く(1..7)
    var init2 = source.Init(3);
}

public static IEnumerable&lt;T&gt; Replace&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate, T replacement)
{
    foreach (var item in source)
    {
        if (predicate(item)) yield return replacement;
        else yield return item;
    }
}

public static IEnumerable&lt;T&gt; Intersperse&lt;T&gt;(this IEnumerable&lt;T&gt; source, T value)
{
    var isFirst = true;
    foreach (var item in source)
    {
        if (!isFirst) yield return value;
        yield return item;
        isFirst = false;
    }
}

public static IEnumerable&lt;T&gt; Init&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    return source.Init(1);
}

public static IEnumerable&lt;T&gt; Init&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count)
{
    if (count == 0)
    {
        foreach (var item in source) yield return item;
        yield break;
    }

    var q = new Queue&lt;T&gt;(count);
    foreach (var item in source)
    {
        if (q.Count == count) yield return q.Dequeue();
        q.Enqueue(item);
    }
}
</code></pre>
<p>という拡張メソッド。もういい加減いつになるのか分からなくなってしまって悲しいlinq.jsの次のリリースにはこれらを入れます。IntersperseとInitの元ネタは<a href="http://anonsvn.mono-project.com/viewvc/trunk/rocks/Mono.Rocks/" title="[Mono] Index of /trunk/rocks/Mono.Rocks">Mono.Rocks</a>から。それの更に元はHaskellのようですねん。</p>
<p>Initは何度となく欲しい！と思ったシーンがあるので、きっと便利。長さが不定で前から後ろに走るLinqでは、後ろから幾つ、というのは標準では出来ないんですね。ReverseしてSkipしてReverseするか、一度ToArrayしてから切り出したりしか手がなくて。最後の一個だけ省きたいとか、よくあります。しかしInitって関数名は意味不明で少々アレかも。Mono.RocksではExceptLastに改称されていました。そうですねえ、CarとかCdrを引き摺る必要はないように、ExceptLastのほうが良さそうですね。</p>
<p>実のところInitがあればIntersperseも標準Linq演算子で定義出来ます。</p>
<pre><code class="language-csharp">var intersperse = source
    .SelectMany(i =&gt; Enumerable.Repeat(i, 1).Concat(Enumerable.Repeat(100, 1)))
    .Init();
</code></pre>
<p>Initの便利さが分かる。そう、こういうのやると、どうしても末尾に一個ゴミが付いてきちゃて、それをスマートに除去するのは出来ないのですよね。あって良かったInit。そしてSelectManyの万能さは異常。Repeat(value, 1)とかRepeat(value, int.MaxValue)も超多用。記述があまりにも冗長になって泣けますが。</p>
<p>RxFrameworkにはObservable.Return(value)という、Repeat(value, 1)と同様のものが定義されていたりします。それとObservable.Cons(value,IObservable)というConcatの単体バージョンみたいなものもあります(lispのconsと同じイメージです)。だから、上のをRxでやるならば</p>
<pre><code class="language-csharp">var intersperse = Observable.Range(1, 10)
    .SelectMany(i =&gt; Observable.Cons(i, Observable.Return(100)))
    .ToEnumerable();
    .Init();
</code></pre>
<p>となります。あまりスッキリしてない？ まあ、そうかも。でも、決め打ちの1って書くの嫌なものなので、それが省けるってのは嬉しいものです。定数を使うなら(int)decimal.Oneという手もありますが、まあ、馬鹿らしい。私はstring.Emptyよりも&quot;&quot;を使う派なので、それはちょっとありえない。ちなみに、&quot;&quot;を選ぶ理由は、タイプ数が少ないという他に、文字列であることが色分けされて表示されるため、string.Emptyよりも遥かに視認性が良いからです。こういうのはIDEを含めて考えないとね。パフォーマンス云々の話は些細なことなので個人的にはどうでもいい。</p>
<p>Rxの記事は、細かいネタは溜まっているので、近いうちにまた書きたいと思います。VS2010 Beta2ではIObservableが標準搭載されていますし。</p>
</div>
<h1><a href="https://neue.cc/2009/10/29_211.html">AnonymousComparer - lambda compare selector for Linq</a></h1>
<ul class="date"><li>2009-10-29</li></ul>
<div class="entry_body"><pre><code class="language-csharp">class MyClass
{
    public int MyProperty { get; set; }
}

static void Main()
{
    // 例として、こんな配列があったとします
    var mc1 = new MyClass { MyProperty = 3 };
    var mc2 = new MyClass { MyProperty = 3 };
    var array = new[] { mc1, mc2 };
    // Distinctは重複を取り除く。でも結果として、これは、2です。
    var result = array.Distinct().Count();
    // 参照の比較なので当然です。では、MyPropertyの値で比較したかったら？
    // DistinctにはIEqualityComparerインスタンスを受け付けるオーバーロードもあります
    // しかしIEqualityComparerはわざわざ実装したクラスを作らないと使えない

    // そこで、キー比較のための匿名Comparerを作りました。
    // ラムダ式を渡すことで、その場だけで使うキー比較のIEqualityComparerが作れます。
    array.Distinct(AnonymousComparer.Create((MyClass mc) =&gt; mc.MyProperty));

    // でも、長いし、型推論が効かないから型を書く必要がある
    // Linqに流れているものが匿名型だったりしたら対応できないよ！
    // というわけで、本来のLinqメソッドのオーバーロードとして、記述出来るようにしました
    // ちゃんと全てのIEqualityComparerを実装しているLinq標準演算子に定義してあります
    array.Distinct(mc =&gt; mc.MyProperty);

    // 短いし、型推論もちゃんと効くしで素晴らしいー。
    // 匿名型でもいけます(VBの匿名型はC#(全ての値が一致)と違ってKey指定らしいですね)
    var anonymous = new[] 
    {
        new { Foo = &quot;A&quot;, Key = 10 },
        new { Foo = &quot;B&quot;, Key = 15 }
    };
    // true
    anonymous.Contains(new { Foo = &quot;dummy&quot;, Key = 10 }, a =&gt; a.Key);
}
</code></pre>
<ul>
<li><a href="http://linqcomparer.codeplex.com/" title="AnonymousComparer - lambda compare selector for Linq">AnonymousComparer - lambda compare selector for Linq</a></li>
</ul>
<p>と、いう内容のコードをCodePlexで公開しました。LinqのIEqualityComparerって使いにくいよね、を何とかするためのものです。DLLでも何でもなく、ただの100行のコードなのでコピペで使ってくださいな。メソッドはAnonymousComparer.Createしかありません。newを使わせないのは型推論のためです。メソッド経由なら引数の型を書くだけで済み、戻り値の型を書く手間が省けるので……。あとはLinq標準演算子でIEqualityComparerを使うオーバーロードの全てに、キー比較用ラムダ式を受けるオーバーロードが追加されています。使い方、使い道は、まあ、見た通りです。</p>
<p>わざわざzipをダウンロードするのも面倒、という人は<a href="http://linqcomparer.codeplex.com/SourceControl/changeset/view/33772#570653" title="AnonymousComparer - lambda compare selector for Linq">CodePlexのソース直接表示</a>でどーぞ。どうせ.txtと.csしか入ってないので。でもダウンロード数とかが増えてると少し嬉しいですね。<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library">linq.js</a>もようやく50超えましたよ、あまりの少なさに笑えない。</p>
<p>以前にも同様のものを書いてた
<a href="http://neue.cc/2009/08/07_184.html" title="neue cc - LinqとIEqualityComparerへの疑問">LinqとIEqualityComparerへの疑問</a> のですが、今回やっと重い腰を上げてまとめてみました。GroupJoinのオーバーロードとか手書きだと死ぬほどダルいですからねえ。と、いっても、やっぱ手書きでやってたら洒落にならないほど面倒くさいので、機械生成でサッと作りました。全然サッとしてないんですけどね。むしろ泥臭い。Linqネタなのでワンライナーで強引に仕上げてみましたよ！</p>
<pre><code class="language-csharp">static string data  = @&quot;ここに定義へ移動で出てくるEnumerableのデータを貼り付けてね、と(4000行ぐらい)&quot;;

static void Main(string[] args)
{
    var result = data
        .Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
        .Where(s =&gt; Regex.IsMatch(s, &quot;public static.+IEqualityComparer&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;(&lt;.+)(&gt;\(this)&quot;, &quot;$1,TCompareKey$2&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;IEqualityComparer&lt;(.+?)&gt;&quot;, &quot;Func&lt;$1,TCompareKey&gt;&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;comparer&quot;, &quot;compareKeySelector&quot;))
        .Select(s =&gt; s.Trim(' ', ';'))
        .Select(s =&gt; new { Signature = s, Groups = Regex.Match(s, @&quot;^(.+? ){3}(?&lt;method&gt;[^ ]+?)&lt;.+?&gt;\(this (?&lt;args&gt;.+)\)$&quot;).Groups })
        .Select(a =&gt; new
        {
            a.Signature,
            MethodName = a.Groups[&quot;method&quot;].Value,
            Args = a.Groups[&quot;args&quot;].Value
                .Split(new[] { &quot;, &quot; }, StringSplitOptions.None)
                .Select(s =&gt; s.Split(' ')).Where(ar =&gt; ar.Length == 2).Select(ar =&gt; ar.Last())
        })
        .Select(a =&gt; string.Format(&quot;{1} {0} {{ return {2}.{3}({4}{5}); {0}}}{0}{0}&quot;,
            Environment.NewLine,
            a.Signature,
            a.Args.First(),
            a.MethodName,
            string.Join(&quot;,&quot;, a.Args.Skip(1).TakeWhile(s =&gt; s != &quot;compareKeySelector&quot;).ToArray()),
            (a.Args.Count() == 2 ? &quot;&quot; : &quot;,&quot;) + &quot;AnonymousComparer.Create(compareKeySelector)&quot;))
        .Aggregate(new StringBuilder(), (sb, s) =&gt; sb.Append(s))
        .ToString();
}
</code></pre>
<p>string dataのところにEnumerable.Rangeなんかを右クリックして「定義へ移動」で出てくるメタデータから、のものを全部コピーしてペースト。あとは、それをLinqでゴリゴリ加工すれば出来上がり。です。Select7連打は悪ノリですね。別にRegexの部分は.Replaceを繋げればいいのにね。あと、かなり決めうち成分強めなのと、正規表現が苦手であんまり上手く書けてないところが多かったりとで全く褒められたコードではありません。正規表現は本当に何とかしたいなあ……。</p>
<p>ああ、あと英語が酷い(笑) CodePlexのちょっとしたプロジェクト説明みたいな部分だけですら破綻しまくってる、単語すら繋げられない、これは酷い。</p>
<p>そういえば作ってから気づいたんですが、普通にリフレクションで取得した方が……遙かに……楽！綺麗に……仕上がる！ と、気づいてしまったのだけど気づかなかったことにしようそうしよう。</p>
</div>
<h1><a href="https://neue.cc/2009/10/08_208.html">return IEnumerableとyield return</a></h1>
<ul class="date"><li>2009-10-08</li></ul>
<div class="entry_body"><pre><code class="language-csharp">static void Main(string[] args)
{
    var path = @&quot;C:\test.txt&quot;;
    var lines = EnumerateAllLines(path).ToArray();
}

static IEnumerable&lt;string&gt; EnumerateAllLines(string filePath)
{
    using (var sr = new StreamReader(filePath))
    {
        return Enumerable.Repeat(sr, int.MaxValue)
            .TakeWhile(s =&gt; !s.EndOfStream)
            .Select(s =&gt; s.ReadLine());
    }
}
</code></pre>
<p>これの実行結果はどうなるでしょうか。答えは、「閉じているTextReaderから読み取ることはできません。」という例外が発生します。当たり前ですか？ すみません。Linqばかり触っていると、ついついIEnumerableだから遅延評価だね！と単刀直入に思ってしまっていたりしたのですが、IEnumerableは決して必ずしも遅延評価であるということでは、ない。配列だってIEnumerableなんだよ！という。当然のようなことですが、すっかり頭から抜け落ちていました。反省。</p>
<p>何で例外が発生するかと言えば、EnumerateAllLines(path)の時点でメソッドが呼ばれ、returnで返した時点でusingを抜けてストリームが閉じられてしまう。ので、ToArray()で閉じられたストリームに対して読み込みを始めて、南無。というわけです。ではどうすればいいかというと……</p>
<pre><code class="language-csharp">static IEnumerable&lt;string&gt; EnumerateAllLines(string filePath)
{
    using (var streamReader = new StreamReader(filePath))
    {
        var seq = Enumerable.Repeat(streamReader, int.MaxValue)
            .TakeWhile(sr =&gt; !sr.EndOfStream)
            .Select(sr =&gt; sr.ReadLine());
        foreach (var item in seq) yield return item;
    }
}
</code></pre>
<p>yield returnを使ってやれば、コンパイラがイテレータを作るので、遅延実行される。EnumerateAllLines(path)の時点ではメソッド内部は一切通らない。MoveNextが呼ばれて初めてusingを通り、列挙が終わるかDisposeが呼ばれるまではusingを抜けない。という、なって欲しいであろう挙動を取ってくれるわけです。実行ファイルをReflectorで見ると、復元不可能なぐらいグチャグチャなものが出力されていて、あまりの難読化っぷりにビビりますが気にしないことにしませう。</p>
<p>そもそもEnumerable.Repeat(sr, int.MaxValue)のほうを改善して<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">RepeatWithUsing</a>作った方がいい、のではあるのですけど、まあ、それはそれということで。</p>
<h2>無限リピート + SQL</h2>
<p>上のはただの説明用の例でクソの役にもたたないので、もう少し実用的なものを一つ。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    var command = new SqlCommand();
    command.CommandText = @&quot;select hogehogehoge&quot;;
    var result = command.EnumerateAll(dr =&gt; new
    {
        AA = dr.GetString(0),
        BB = dr.GetInt32(1)
    });
}

static IEnumerable&lt;T&gt; EnumerateAll&lt;T&gt;(this IDbCommand command, Func&lt;IDataReader, T&gt; selector)
{
    using (var reader = command.ExecuteReader())
    {
        var seq = Enumerable.Repeat(reader, int.MaxValue)
            .TakeWhile(dr =&gt; dr.Read())
            .Select(selector);
        foreach (var item in seq) yield return item;
    }
}

static T[] ReadAll&lt;T&gt;(this IDbCommand command, Func&lt;IDataReader, T&gt; selector)
{
    return command.EnumerateAll(selector).ToArray();
}
</code></pre>
<p>シーケンス無限リピートをSQLの読み込みに応用してみるとかどうでしょう。Linq to Sqlのように、とまでは到底行きませんが、匿名型も使えるし、何となくそれっぽい雰囲気は出てるんじゃないかしらん。EnumerateAllの後段にTakeWhileを付けて条件で途中で止めるとか、Take(10)で10件のみ取得とか、それなりに自由に動かせます。</p>
</div>
<h1><a href="https://neue.cc/2009/10/05_207.html">ラムダ式の引数の名前</a></h1>
<ul class="date"><li>2009-10-05</li></ul>
<div class="entry_body"><p>Linqもそうですが、Linq意外でもFuncやActionのお陰様でラムダ式を渡しまくりな昨今。そうなるとちょろっとした引数の名前付けが面倒くさかったりします。ので、大抵は一文字で済ませるわけです。一文字ってどうなのよ、よくないんじゃないの？というと、ラムダ式のような極端にスコープが短いものは、しっかりした名前がついているもののほうが逆に見づらかったりするので、一文字でいいと思います。面倒くさいからって全て_だの__だので済ませると見づらいので一文字はなるべく死守します。但し引数を利用しない場合は_を使います。ネストしたり、式じゃなくて文になる場合はしっかりした名前を付けます。</p>
<pre><code class="language-csharp">a // AnonymousType
i // int
s // string
c // char
d // datetime
g // IGrouping
t // Type
e(ex) // exception
e(elem) // XElement
e(ev) // event
e(ie) // IEnumerable(あんま使わないですが)
ar // array(IEnumerableの時もこれ使ったりする(適当))
ar // IAsyncResult(うわ、被っとる)
fs // fileSystemとかラクダの頭文字を繋げる
x // 適当なのがない場合とか、x =&gt; xとか
xs // arrayやらIEnumerableやらどっちでもいー、とヤケクソな時
_ // 引数を式中で利用しない場合
</code></pre>
<p>大抵は型の頭文字一つです。AnonymousTypeは、前はtを使ってたんですが、IntelliSenseで出てくるのが'aだし、世間的にもaが主流だしTypeと紛らわしいので、最近はaで書くようにしています。Aggregateなんかは(a,b)=&gt;って昔は書いていたのですが、aが匿名型なので紛らわしいから、(x,y)=&gt;と書くようにしています。徹底はしてません。適当です。</p>
<p>それにしてもeの被りっぷりは酷い。こうなると、不人気頭文字を使いたい。というわけで、ライブラリからTypeの頭文字を取得してみる。アセンブリの取得部分は<a href="http://d.hatena.ne.jp/siokoshou/20090817#p1" title="2009-08-17 - 当面C#と.NETな記録">2009-08-17 - 当面C#と.NETな記録</a>のコードをお借りしました。</p>
<pre><code class="language-csharp">// asmNamesは http://d.hatena.ne.jp/siokoshou/20090817#p1 から
// Groupingをバラしているのは、デバッガで中身を見る時にかったるかったから
var list = asmNames
    .SelectMany(s =&gt; Assembly.LoadWithPartialName(s).GetExportedTypes())
    .Select(t =&gt; t.Name)
    .GroupBy(s =&gt; s.First())
    .OrderBy(g =&gt; g.Key)
    .Select(g =&gt; new { Key = g.Key, Types = g.ToArray() })
    .ToList();
list.ForEach(a =&gt; Console.WriteLine(&quot;{0} : {1}&quot;, a.Key, a.Types.Length));

A : 319
B : 252
C : 773
D : 715
E : 275
F : 263
G : 172
H : 264
I : 887
J : 14
K : 58
L : 249
M : 424
N : 140
O : 189
P : 526
Q : 31
R : 312
S : 1039
T : 644
U : 169
V : 118
W : 272
X : 372
Z : 7
_ : 32
</code></pre>
<p>IはInterfaceだから数が多いのはしょうがない。Zは当然としてJ, K, Qは不人気ワードなので狙いどころですね！そしてSは人気あり過ぎ、と。別に考察でも何でもないです、すみません。CamelCaseを短縮結合して、一文字の場合のみを取り上げたら</p>
<pre><code class="language-csharp">// SplitCamelWordはasmNamesと同じくsiokoshouさんのコードから
.Select(t =&gt; SplitCamelWord(t.Name).Aggregate(&quot;&quot;, (x, y) =&gt; x + y.First(), s =&gt; s.ToLower()))
.Where(s =&gt; s.Length == 1)
</code></pre>
<p>ちゃんと(?)、eが一番人気でした。</p>
</div>
<h1><a href="https://neue.cc/2009/09/30_206.html">C# Linqでクイックソート</a></h1>
<ul class="date"><li>2009-09-30</li></ul>
<div class="entry_body"><pre><code class="language-haskell">qsort []     = []
qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
                 where
                   elts_lt_x   = [y | y &lt;- xs, y &lt; x]
                   elts_greq_x = [y | y &lt;- xs, y &gt;= x]
</code></pre>
<p>これはHaskellのコードで、良く見かける定番のQuickSort。うん、短い。というわけでLinqでそれをやる。というネタは既出のン番煎じなのですが、気にせずやる。</p>
<pre><code class="language-csharp">// LinqでHaskell風のクイックソート
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    return source
        .GroupBy(x =&gt; x.CompareTo(pivot))
        .OrderBy(g =&gt; g.Key) // OrderBy使うのはどうかなー、というところはある
        .SelectMany(g =&gt; (g.Key == 0) ? g : QuickSort(g));
}
</code></pre>
<p>GroupBy-&gt;SelectManyと流れるように書けて美しいー。これならHaskellにも引けを取らないですね！但し問題なのは、OrderByを使用しているところ。CompareToの結果である-1, 0, 1を並べ替えるために使っているのだけど、OrderByの中身はシュワルツ変換の挟まったクイックソートそのものなので邪道な感は否めない。OrderBy使うなら、そもそもsource.OrderBy(x =&gt; x)でもいいぢゃん、って話になってしまう。</p>
<pre><code class="language-csharp">// 非GroupBy版。LookupはGroupByの即時評価版と考えていい。
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    var lookup = source.ToLookup(x =&gt; x.CompareTo(pivot));
    return QuickSort(lookup[-1]).Concat(lookup[0]).Concat(QuickSort(lookup[1]));
}
</code></pre>
<p>GroupByをToLookupに書き変えました。ToLookupはGroupByの即時評価版といった感じで、インデクサによるアクセスが可能。インデクサ使わないでそのままforeachで列挙する、なんて時はGroupByを使った方が良いです。今回はインデクサで順番を明示的に指定するため、ToLookupでパーティション切って、Concatで繋いでやれば出来あがり。やってることが非常に分かりやすくて良い。ソースの見た目も中々綺麗じゃないでしょうか。Haskellのものとも非常に近いです(ようするに++がConcatなので) ToLookupではなくWhereを使えば、見た目は更にHaskellに近づきますが、列挙が二回になるので、ここはToLookupで。</p>
<pre><code class="language-csharp">// 普通に？書いた場合。
public static void QuickSort&lt;T&gt;(IList&lt;T&gt; source, int lowerBound, int upperBound)
    where T : IComparable&lt;T&gt;
{
    var pivot = source[lowerBound + ((upperBound - lowerBound) &gt;&gt; 1)];
    var left = lowerBound - 1;
    var right = upperBound + 1;
    while (true)
    {
        while (source[++left].CompareTo(pivot) &lt; 0) ;
        while (source[--right].CompareTo(pivot) &gt; 0) ;
        if (left &gt;= right) break;
        var temp = source[left];
        source[left] = source[right];
        source[right] = temp;
    }
    if (lowerBound &lt; left - 1) QuickSort(source, lowerBound, left - 1);
    if (right + 1 &lt; upperBound) QuickSort(source, right + 1, upperBound);
}
</code></pre>
<p>今度は非Linqに一般的？な書き方で。あまりヘタな書き方するとアレだなあ、と思ったので<a href="http://blog.livedoor.jp/dankogai/archives/51182235.html">404 Blog Not Found:javascript - Array#sortはオレquicksortより遅い by Chrome</a>のコードをC#に移植しました。<a href="http://dic.nicovideo.jp/a/%E3%81%82%E3%81%9F%E3%81%97%E3%81%93%E3%81%AE%E3%83%91%E3%82%A4%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%82%88%E3%81%AD">あたしこの書き方嫌いなのよね</a>、という感じにゴチャゴチャした印象は否めないというか、まあ、嫌いなのよね。一本の配列で頑張るところが、ゆとりな私としてはしんどい。ビットシフトも嫌よね。</p>
<pre><code class="language-csharp">public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    var enumerator = source.GetEnumerator();
    if (!enumerator.MoveNext()) yield break;

    var pivot = enumerator.Current;
    var less = new List&lt;T&gt;();
    var equal = new List&lt;T&gt;();
    var greater = new List&lt;T&gt;();
    do
    {
        switch (enumerator.Current.CompareTo(pivot))
        {
            case -1: less.Add(enumerator.Current); break;
            case 0: equal.Add(enumerator.Current); break;
            case 1: greater.Add(enumerator.Current); break;
        }
    } while (enumerator.MoveNext());

    foreach (var item in QuickSort(less)) yield return item;
    foreach (var item in equal) yield return item;
    foreach (var item in QuickSort(greater)) yield return item;
}
</code></pre>
<p>最後に、非Linqで、ToLookup版を再現してみたものを。do-whileがToLookupでforeachの連発がConcat。ようするに富豪的にListを作りまくるってわけなんですね！書きやすいし分かりやすいので、一本配列版よりも遥かに好き度高い。現代人はListを贅沢に大量に好きなだけ使うのです。まあ、Linq版がない状態でこの書き方が浮かぶ or 実行に移せるかどうかといったら、かなり無理ですけど。</p>
</div>
<h1><a href="https://neue.cc/2009/09/28_205.html">.NET Reactive Framework メソッド探訪第五回:Scan</a></h1>
<ul class="date"><li>2009-09-28</li></ul>
<div class="entry_body"><p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">var random = new Random();
Func&lt;byte&gt; nextByte = () =&gt; (byte)random.Next(0, byte.MaxValue + 1);

// CenterEllipseは真ん中の円のこと。
// 1000秒以内に3回クリックするとランダムで色が変わる
// GetMultiClickScan関数が今回の主題で、解説は後で。
CenterEllipse.GetMultiClickScan(3, 1000).Subscribe(() =&gt;
    CenterEllipse.Fill = new SolidColorBrush(Color.FromArgb(255, nextByte(), nextByte(), nextByte())));
</code></pre>
<p>円を1秒以内にトリプルクリックすると色が変わります。右側のログ表示はミリセカンド単位でトリプルクリック時の経過時間を表しています。つまり、これが1000以内ならば色が変わり、1000より上ならば色は変わりません。このサンプルのテーマは、トリプルクリックの検出です。トリプルだけではなく、クアドラプルでもクインタプルでも、1秒以内じゃなくて5秒でも10秒でも応用できる形で書くとしたら、どう書く？ グローバル変数に、クリックイベントを格納する配列でも置くかしらん。それがきっと簡単で分かりやすくて、でも……。</p>
<p>今回はRx Frameworkの関数から、Scanを取り上げます。この例題は私が考えたわけではなく、<a href="http://blogs.msdn.com/jeffva/archive/2009/08/14/my-solutions-to-the-reactive-framework-tripple-click-puzzle.aspx">Ramblings of a Lazy Coder : My solutions to the Reactive Framework Tripple-click puzzle</a>という問題からです。URLリンク先は解答編、というわけで、この解答を解説します。</p>
<p>考え方としては、クリックイベントに「クリックされた時間」という情報を付加。更に、クリック回数分の「前のデータ」を参照して指定時間内で連続クリックかどうかを確認する。時間情報の付加は匿名型を作るだけなので簡単ですが、「前のデータ」を参照するのが厄介。Linqは前にしか進まないし、送られてくるデータは過去のものなど知らない。このことはReactive Frameworkだけの話ではなく、以前にも<a href="http://neue.cc/2009/03/06_138.html">LINQで左外部自己結合</a>や<a href="http://neue.cc/2009/03/16_141.html">Scan?</a>という記事で書きましたが、そこで出てくる解決策がScan。そうそう、ScanはAchiralにあるので(ということでlinq.jsにもあります)、動作は分かってます。ようするにAggregateの計算過程吐きだし版です。とりあえず<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>でE.Range(1,10).Scan(&quot;x,y=&gt;x+y&quot;)と打ってみてください(宣伝宣伝)</p>
<p>Scanならば「一個前」の情報が手に入る。しかし「複数個前」の情報はどうすれば？ 答えは配列使えばいいぢゃない。だそうです。過程のデータをとりあえず配列に入れて、次に送り出してやれば、そりゃ簡単に取り出せますね。何だか邪道な気がしますが、気にしない気にしない。URL先の解答例では生の配列を使って、インデックスをゴニャゴニャとしていて非常に正しいとは思いますが、あまり生の配列のインデックスは扱いたくないので、Queueを使ってみました。別にQueueのClear()のコストなんてたかが知れてるっしょ(中ではArray.Clearを呼んでいて、Array.Clearは……以下略)という割り切りで。</p>
<pre><code class="language-csharp">public static IObservable&lt;MouseButtonEventArgs&gt; GetMultiClickScan
    (this UIElement element, int count, int multiClickSpeedInMilliSeconds)
{
    return Observable.FromEvent&lt;MouseButtonEventArgs&gt;(element, &quot;MouseLeftButtonDown&quot;)
        .Select(e =&gt; e.EventArgs)
        .Scan(new
        {
            Times = new Queue&lt;DateTime&gt;(count),
            Hit = false,
            Event = (MouseButtonEventArgs)null // ダミーなのでnullをキャストするのが楽
        }, (a, e) =&gt;
        {
            var isHit = false;
            var now = DateTime.Now;
            a.Times.Enqueue(now);
            if (a.Times.Count == count)
            {
                var first = a.Times.Dequeue();
                Debug.WriteLine((now - first).TotalMilliseconds); // Debug
                if ((now - first).TotalMilliseconds &lt;= multiClickSpeedInMilliSeconds)
                {
                    isHit = true;
                    a.Times.Clear();
                }
            }

            return new
            {
                Times = a.Times,
                Hit = isHit,
                Event = e
            };
        })
        .Where(a =&gt; a.Hit)
        .Select(a =&gt; a.Event);
}
</code></pre>
<p>ScanはAggregateと全く同じで、accumlatorのみの実行の他に、第一引数でseedを渡すこともできます。Scanのseedで、変数と判定を行うためのフラグを保持するクラスを作り、accumlatorで判定と変数の持ち越しを行い、Whereで判定をフィルタリング。このコンボは非常に強力で、幾らでも応用が効きそう。LinqでのAggregateはほとんど使われませんが、RxにおけるScanはよく見かけることになるのではないかと思います。</p>
<p>で、理屈は分かったけれど、何だかゴチャゴチャとしてない？ という感想は否めない。ただ、グローバル領域に変数を置く必要なくフラグを閉じ込められていること、そして、応用の効きそうな柔らかさが見えたり見えなかったりしませんか？ 応用的なものも、追々考えていきたいです。</p>
<h2>次元の狭間へ</h2>
<p>Scanが出たので、Aggregateもついでにおさらい。これはLinq to ObjectsのAggregateと変わりません。ちなみにRx Frameworkでの内部実装はScan().Last()だったりするので、Scanとほんとーに丸っきり変わりません。じゃあ、無限リピートのFromEventにたいしてAggregateって、実行するとどうなるの？というのは気になるところですが、答えは次元の狭間に入ってしまって、その行からコードが一切進まなくなります。AggregateだけじゃなくCountやLast、ToEnumerableなど全てを列挙してから答えを返す系のメソッドは全て同じ結果になります。コンソールアプリの簡単なコードで試してみると、こうなる。</p>
<pre><code class="language-csharp">class MyClass
{
    public event EventHandler&lt;EventArgs&gt; Ev;

    public void Fire()
    {
        Ev(this, new EventArgs());
    }
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var count = Observable.FromEvent&lt;EventArgs&gt;(mc, &quot;Ev&quot;)
        .Count(); // ここで次元の狭間にダイブする

    mc.Fire(); // ここに到達することは未来永劫無い
}
</code></pre>
<p>恐ろしや。ただ、前段階でTakeやTakeWhileを挟めば、無限リストは有限リストとなるので、面白い感じに制限が出来ます。この辺も応用例として、そのうち紹介していければと思います。</p>
<h2>カウンター</h2>
<p>もう一度Scanを見ます。トリプルクリックの例題は捻りすぎな感が否めないので、もっとストレートに、Scanの「前の値を保持し続けることが出来る」という点を見せる例題を一つ。<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3" title="クロージャ - Wikipedia">クロージャの例</a>なんかでも定番のカウンターで。</p>
<p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="200px" height="50px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan_Counter.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">Observable.FromEvent&lt;RoutedEventArgs&gt;(CounterButton, &quot;Click&quot;)
    .Scan(0, (x, y) =&gt; ++x)
    .Subscribe(i =&gt; CounterButton.Content = i + &quot;Clicked&quot;);
</code></pre>
<p>とても簡潔で、変数が全て閉じ込められていて、綺麗……。</p>
</div>
<h1><a href="https://neue.cc/2009/09/25_204.html">Linqは美人</a></h1>
<ul class="date"><li>2009-09-25</li></ul>
<div class="entry_body"><pre><code class="language-csharp">public class Stamp
{
    public int Year { get; set; }
    public string Name { get; set; }
    public Stamp(int year, string name) { this.Year = year; this.Name = name; }
    public override string ToString() { return this.Year + &quot;:&quot; + this.Name; }
}

public class StampCollection : IEnumerable&lt;Stamp&gt;
{
    private Dictionary&lt;string, Stamp&gt; stamps = new Dictionary&lt;string, Stamp&gt;();

    public void Add(Stamp s) { stamps.Add(s.Name, s); }
    public void Add(int year, string name) { stamps.Add(name, new Stamp(year, name)); }

    // yield returnを通さなくてもそのままreturn可能
    public IEnumerator&lt;Stamp&gt; GetEnumerator()
    {
        return stamps.Values.OrderBy(s =&gt; s.Year).GetEnumerator();
    }

    // GetEnumeratorと名乗りながらGetEnumeratorじゃないのが少しアレですね
    public IEnumerable&lt;Stamp&gt; GetEnumerator2()
    {
        return stamps.Values.OrderByDescending(s =&gt; s.Year);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}

// 利用時例
static void Main(string[] args)
{
    // コレクション初期化子は、複数引数時は更に{}で囲む
    var stamps = new StampCollection()
    {
        {1998, &quot;hoge1&quot;},
        {1999, &quot;hoge2&quot;},
        {2000, &quot;hoge3&quot;}
    };
    
    // GenericsにしておくとCast&lt;T&gt;を使わずLinqでコンボ出来る
    stamps.GetEnumerator2().Select(s =&gt; s.Name).ToList().ForEach(Console.WriteLine);
}
</code></pre>
<p><a href="http://d.hatena.ne.jp/cast_everything/20090924/1253786494" title="memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋">memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋</a>のものを少し書き換えました。コレクション初期化子と、yield returnせずにそのまま投げ返すように変えただけですが。Linqは美人。ですです。</p>
</div>
<h1><a href="https://neue.cc/2009/09/18_203.html">JavaScriptでString.Format的な超簡易テンプレート置換</a></h1>
<ul class="date"><li>2009-09-18</li></ul>
<div class="entry_body"><pre><code class="language-javascript">// String.Format的な超簡易テンプレート置換関数
var Format = function(template, replacement)
{
    if (typeof replacement != &quot;object&quot;) // 可変長引数時はreplacementを詰め替え
    {
        replacement = Array.prototype.slice.call(arguments, 1);
    }
    return template.replace(/\{(.+?)\}/g, function(m, c)
    {
        return (replacement[c] != null) ? replacement[c] : m
    });
}

// 例。可変長引数渡しでも配列渡しでもオブジェクト渡しでも可。
var case1 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, &quot;あいでぃ&quot;, &quot;要素&quot;);
var case2 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, [&quot;あいでぃ&quot;, &quot;要素&quot;]);
var case3 = Format(&quot;&lt;div id={ID}&gt;{ELEM}&lt;/div&gt;&quot;, { ID: &quot;あいでぃ&quot;, ELEM: &quot;要素&quot; })
</code></pre>
<p>.NET FrameworkのString.Formatは文字を連結するのに、非常にお手軽で良いです。というわけでJavaScriptでもそれをやる。ついでにテンプレート置換風にオブジェクト渡しにも対応させる。単純な置換時は数字で、長ったらしい置換時はオブジェクトで。両方に対応させなければ、詰め替えが必要ないので正規表現でカカッと一行なんですねえ。詰め替えも別にslice.callで一発だし。<a href="http://neue.cc/2009/04/28_154.html" title="neue cc - JavaScriptでString.Format">以前にlinq.jsを絡めてgdgdとやってた</a>のですが、<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">二度もね！</a>、あんなにgdgdやらずとも、もんのすごーく単純明快に書ける。無理やり使おうとして、無駄に複雑になるのはイクない。</p>
<p>と、恥ずかしくなったので今回載せました。あと、JavaScriptは文字連結面倒くせー、って時にササッとコピペで取り出して使いたい時のために(笑) ちゃんとDateTime等も含めたフォーマット変換に対応させるとか、テンプレートだったらちゃんとテンプレートエンジンな感じでforやifも動くように、とかの話は知りません。</p>
<p>そういえば、置換部分の関数ですけど、最初は格好つけて「return replacement[c] || m」って書いたんですが、これだとマッチがハッシュ内に見つからなかった場合(undefinedになってる)だけでなく、 空文字列の場合もfalse扱いになってしまってダメなんですね。C#の??のように使いたいのですが、例えば数字だと「var i = 0 || 3」だったら3になるしで使いづらい。というわけで、結局==nullばかり使うことになる。===undefinedって書けって話でもありますが、まあ、==nullのほうが色々考えなくて済むから楽で。</p>
</div>
<h1><a href="https://neue.cc/2009/09/16_202.html">ログ吐き骨組み</a></h1>
<ul class="date"><li>2009-09-16</li></ul>
<div class="entry_body"><p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/LogBrowseBase.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>デモ大事。<a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">Subscribe</a>の時にConsole.WriteLine並べて、実行結果想像つきますよね、というのがいまひとつすぎたので、出力が見える骨組みを作りました。今後のReactive Frameworkの紹介時にソースコード上のDebug.WriteLineは、こーいうことなんですねー、と思ってください。毎回これ乗っけてると長ったらしいので、暗黙の、ということで。</p>
<pre><code class="language-xml">&lt;UserControl x:Class=&quot;SilverlightApplication4.MainPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; 
    mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;640&quot; d:DesignHeight=&quot;480&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition /&gt;
            &lt;ColumnDefinition Width=&quot;200&quot; /&gt;
        &lt;/Grid.ColumnDefinitions&gt;

        &lt;StackPanel Grid.Column=&quot;0&quot;&gt;
            &lt;Button Name=&quot;ExecuteButton&quot; Content=&quot;Execute&quot; /&gt;
            &lt;Button Name=&quot;ErrorButton&quot; Content=&quot;Error&quot; /&gt;
            &lt;Button Name=&quot;ObservableButton&quot; Content=&quot;Observable&quot; /&gt;
            &lt;Button Name=&quot;EnumerableButton&quot; Content=&quot;Enumerable&quot; /&gt;
        &lt;/StackPanel&gt;
        &lt;ScrollViewer Grid.Column=&quot;1&quot;&gt;
            &lt;TextBlock Name=&quot;LogBrowseTextBlock&quot;&gt;&lt;/TextBlock&gt;
        &lt;/ScrollViewer&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Reflection;

namespace SilverlightApplication4
{
    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();
            Debug.Set(LogBrowseTextBlock, Dispatcher);

            ExecuteButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10).Subscribe(
                    i =&gt; Debug.WriteLine(i),
                    e =&gt; Debug.WriteLine(e),
                    () =&gt; Debug.WriteLine(&quot;completed&quot;)
                )
            );

            ErrorButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10)
                    .Do(i =&gt; { if (i == 5) throw new Exception(); })
                    .Subscribe(
                        i =&gt; Debug.WriteLine(i),
                        e =&gt; Debug.WriteLine(&quot;onError&quot;),
                        () =&gt; Debug.WriteLine(&quot;onCompleted&quot;)
                    )
            );

            ObservableButton.GetClick().Subscribe(() =&gt;
                GetMethodNames(typeof(Observable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );

            EnumerableButton.GetClick().Subscribe(() =&gt;
                  GetMethodNames(typeof(Enumerable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );
        }

        IEnumerable&lt;string&gt; GetMethodNames(Type type)
        {
            return type.GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Select(mi =&gt; mi.Name)
                .OrderBy(s =&gt; s)
                .Distinct();
        }
    }

    public static class Debug
    {
        private static TextBlock textBlock;
        private static Dispatcher dispatcher;

        public static void Set(TextBlock textBlock, Dispatcher dispatcher)
        {
            Debug.textBlock = textBlock;
            Debug.dispatcher = dispatcher;
        }

        public static void WriteLine(object message)
        {
            if (textBlock != null)
            {
                dispatcher.BeginInvoke(() =&gt;
                    textBlock.Text = message.ToString() + Environment.NewLine + textBlock.Text);
            }
        }
    }

    public static class ControlExtensions
    {
        public static IObservable&lt;Event&lt;RoutedEventArgs&gt;&gt; GetClick(this ButtonBase button)
        {
            return Observable.FromEvent&lt;RoutedEventArgs&gt;(button, &quot;Click&quot;);
        }
    }
}
</code></pre>
<p>幾ら簡易的なものだから、という言い訳がましさを考えても、かなり微妙なコードな気がする。原型はWPFでTraceListenerにTextBlockに書きだすものを追加して、Trace.WriteLineで処理していたもの。SilverlightにはTraceがなかったので、そのまま静的クラス・メソッドに置き換えて、Silverlightにも本来あるDebugを塗り替えちゃうという……。ようするにそのままコピペしても動くよね！的な感じでやりたいな、というところなわけです。ダメ？</p>
<p>ついでにSubscribeの中でObservableって、汚い、ように見えるかも。でも実際これはなんてことなくて、ようはJavaScriptっぽいんですよね、ほんと。DOMContentLoadedにイベント登録のaddEventListener並べるのと一緒で。じゃあ実際こうしてグチャグチャ並べるかというとそうではないようで、実際は拡張メソッドへ記述する、という形で分散していくようですが、まだまだ分からず。Microsoft側の実例やドキュメントが整ってくれないと何とも言えない感じ。</p>
<h2>作業環境</h2>
<p class="noindent">
	<a href="http://neue.cc/wp-content/uploads/image/vsorig.jpg"><img src="http://neue.cc/wp-content/uploads/image/vsmin.jpg"></a>
</p>
<p>画像クリックで原寸サイズ。最近思うところあってVisual Studioの配置をごにょごにょと弄っています。今は、こんな感じに落ち着きました。左にエラー一覧・検索など。右にソリューションエクスプローラー・クラスビュー・スタートページなど。そして左右にそれぞれコードウィンドウを分割。原則的にメインウィンドウは左。コード定義ウィンドウを右ウィンドウに開いて常時表示。もしくはXAML編集と並列したり。といったところです。コード定義ウィンドウはデカい画面で常時表示で初めて効果を発揮しますね、素晴らしく便利。</p>
<p>30インチ 2560x1600の無駄遣いが火を吹く！というわけですが、やっぱ広いって便利、エディタウィンドウ2面同時表示って便利、です。30インチでなくても、横2560は19インチ1280x1024のデュアルで行けます。ただ、実際はこれに加えてデバッグ時のプログラム本体なりブラウザなりを置いておく場所が欲しいので、その場合はデュアルじゃ足りないですね……。グラフィックボードが一枚でトリプルをサポートしてくれれば、というか、するべき、ですよね。ATIの<a href="http://pc.watch.impress.co.jp/docs/news/20090911_315056.html" title="【PC Watch】 AMDが次世代GPUに搭載するマルチディスプレイ機能「Eyefinity」を披露">Eyefinity</a>にはとても期待してます。</p>
</div>
<h1><a href="https://neue.cc/2009/09/14_201.html">.NET Reactive Framework メソッド探訪第四回:メソッド一覧</a></h1>
<ul class="date"><li>2009-09-14</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">前回</a>が少し、明らかに説明不足でした……。Subscribeが原則としてIObserverを受ける(直接ラムダ式でonNextを記述するのはただの省略記法)ということは、IObserverを別に作っておける。もっと進めると、Subscribeで実行されるコード本体は自由に入れ替え可能。ということになります。ここが、イベント直記入に対するReactive Frameworkの強みの一つ。それ○○パターンだって？そうですね？その○○パターンがデフォルトで何も考えず使えるのならば、素晴らしいと思います。</p>
<p>では、ここからようやくメソッド探訪。の前に、全メソッド一覧を見てみます。IObservable&lt;T&gt;拡張メソッド一覧。そう、最初感動したのは、ドット打ってIntelliSenseに並んだこのメソッド名を見て、なのよね。いかにも素晴らしいことが出来そうな予感だったという。</p>
<pre><code class="language-text">Aggregate
Amb
AsObservable
Catch
CombineLatest
Concat
Cons
Contains
Count
Create
Defer
Delay
Dispatch
Do
Empty
Finally
First
FirstOrDefault
Flatten
ForkJoin
FromEvent
Generate
GetEnumerator
HoldUntilChanged
Interval
Last
LastOrDefault
Latest
Let
LetRec
LongCount
Merge
MostRecent
Never
Next
Post
Range
Reify
Repeat
Retry
Return
Sample
Scan
Select
SelectMany
Send
Single
SingleOrDefault
Skip
SkipWhile
Spawn
Start
Subscribe
Synchronize
Take
TakeWhile
Throttle
Throw
Timeout
ToAsync
ToBehavior
ToEnumerable
ToObservable
ToSubject
Until
WaitUntil
Where
Zip
</code></pre>
<p>かなり多い。68個ある。名前から想像つくのもあれば全くつかないものも。順番はどうしようかな、LinqではGenerating, Projection and Filtering, Join, Set, Ordering, Grouping, Aggregate, Paging, Convertで分けられたので、何らかの指針でもって分けた方が良いのは間違いないのですが、実際に中を突っつかないと何が何なのか全く分からない。</p>
<pre><code class="language-csharp">Func&lt;Type, IEnumerable&lt;string&gt;&gt; GetMethodNames = 
    type =&gt; type
        .GetMethods(BindingFlags.Static|BindingFlags.Public)
        .Select(mi =&gt; mi.Name)
        .OrderBy(s =&gt; s)
        .Distinct();

var enumerable = GetMethodNames(typeof(Enumerable));
var observable = GetMethodNames(typeof(Observable));

observable.Except(enumerable).ToList().ForEach(Console.WriteLine);
</code></pre>
<p>メソッド名一覧はobservableのみを吐いたもので、上のコードはEnumerableとの差分も取ってみたものです。Enumerableと重複しないものは47個でした。そんなに被ってる、というわけではないですね……。ちなみに、Enumerableは50個。覚えきれているので、もっと少ないと思ってたんですが、意外と多かった。Linq to Objectsもきちんと理解して使えるようになるのに半年ぐらいかかってしまっているので、今回も長期戦かなー。ちんたらやってる間にドキュメントが出てくるのを期待したい。</p>
</div>
<h1><a href="https://neue.cc/2009/09/13_200.html">.NET Reactive Framework メソッド探訪第三回:Subscribe</a></h1>
<ul class="date"><li>2009-09-13</li></ul>
<div class="entry_body"><p>メソッド探訪とか言いながら、ちっとも探訪してません。今回までが基礎知識で、Linq to Objectsで言ったらイテレータがどうこう、という段階。次回以降はメソッドを見ていきたいと思います。では、最後の予習ということで、Subscribe。SubscribeはIObservable&lt;T&gt;連鎖の終点となるもので(但し、別にSubscribeだけが終点というわけではない、FirstとかCountとか、終点になるものは他にもあります)ForEachのようなもの。戻り値はIDisposableで、イベント発生の監視を止めたい時はDisposeを呼ぶ。と、第一回の時に書きましたので、今回は別の方向から見ていきます。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    Observable.Range(1, 10).Subscribe(Observer.Create(
        (int i) =&gt; Console.WriteLine(i), // OnNext
        e =&gt; { throw e; }, // OnError
        () =&gt; Console.WriteLine(&quot;Completed&quot;) // OnCompleted
    ));

    Console.ReadLine();
}
</code></pre>
<p>今回はコンソールアプリで。結果は想像つくとおり、1から10、最後にCompletedを表示。Observable.RangeはEnumerable.Rangeと同じです。というか中身的にはEnumerable.Range.ToObservableで変換されているだけです。RepeatとEmptyも用意されているので、ちょっとしたメソッド確認用に便利に使えると思います。それにしてもコード、ゴチャゴチャしてますねえ、わけわかんない書き方してわざと難解にやってるんじゃないだろうかって感じですが、その通りです、ので、普通の書き方も下の方でちゃんと書きます。で、SubscribeはIObservable&lt;T&gt;のメソッドとして定義されています。IEnumerable&lt;T&gt;がGetEnumeratorを持つように、IObservableはSubscribeを持つ。そして、原則Subscribeの引数はIObserver&lt;T&gt;です。</p>
<pre><code class="language-csharp">public interface IObservable&lt;T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}

public interface IObserver&lt;T&gt;
{
    void OnCompleted();
    void OnError(Exception exception);
    void OnNext(T value);
}
</code></pre>
<p>インターフェイスなので直接生成することは出来ない。よってファクトリメソッドObserver.Createを用いて生成します。生成されるのは前回見たAnonymousEnumeratorと同じくinternalのジェネリッククラス「AnonymousObserver&lt;T&gt;」で、インターフェイスの各メソッドにデリゲートを直接放り込むだけの単純明快なものです。勿論、IObservable&lt;T&gt;を継承して自前の専用のものを用意しても構いませんが、クロージャを活かせば、自前で定義する意味など少しもありません。コンパイラの自動生成クラス任せでOK。</p>
<p>これの動作はメソッド名通りで、OnNextは値が来るたびに実行されるメソッド。OnCompletedは全て完了した時(FromEvent経由のものなど、実質無限リピート状態の場合は、Disposeが呼ばれた時)に実行されるメソッド。OnErrorは例外が発生した時に実行されるメソッド。発生した例外は原則catchされるので、再スローしたい時は、そのまんまですがthrow eの明示が必要です。</p>
<p>……それにしても面倒くさい。Observer.Createは。onNextだけが書ければいいんだよ！ってシーンにわざわざ空の式を書けとでも？（ちなみに空は()=&gt;{}です) 大体がして、推論出来ないから(int i)だとか、型を書かなければならないのもかったるい。というわけで、拡張メソッドが用意されています。</p>
<pre><code class="language-csharp">public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError, Action onCompleted);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError, Action onCompleted);
</code></pre>
<p>いっぱいありますけど、ようするに無視した部分は空のメソッドが代わりに埋められる、というだけの話。これを使えば、最初の例は、onNextだけにすると</p>
<pre><code class="language-csharp">Observable.Range(1, 10).Subscribe(i =&gt; Console.WriteLine(i));
</code></pre>
<p>と、簡潔明快に記述出来るわけです。メデタシメデタシ。</p>
<h2>過去記事</h2>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">.NET Reactive Framework メソッド探訪第一回:FromEvent</a><br />
<a href="http://neue.cc/2009/09/07_198.html" title="neue cc - .NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></p>
</div>
<h1><a href="https://neue.cc/2009/09/09_199.html">無限リピートの幸福</a></h1>
<ul class="date"><li>2009-09-09</li></ul>
<div class="entry_body"><p>Reactive Frameworkが、結構に無限リピートな感じなので、関連してC# Linqで<a href="http://ja.doukaku.org/197/lang/csharp/">どう書くにあった13日金曜日問題</a>を今更書いてみた。n番煎じ。</p>
<pre><code class="language-csharp">// 今日から2013年12月31日までの、13日の金曜日とその総数を表示してください。
// 「今日」を無限リピートという方針で書いてみたりして(総数は省略)
// 利点はTodayを変数として外側に定義する必要が無くLinq内に閉じ込められる
// Toを求めるのに足したり引いたりする必要がなく自然に書ける、の二つかしらん
// 「まで」という問いに対してTakeWhileで解答するのは自然で良いと思う

Enumerable.Repeat(DateTime.Now, int.MaxValue)
    .Select((d, i) =&gt; d.AddDays(i))
    .TakeWhile(d =&gt; d.Year &lt; 2014)
    .Where(d =&gt; (d.DayOfWeek == DayOfWeek.Friday) &amp;&amp; (d.Day == 13))
    .ToList()
    .ForEach(d =&gt; Console.WriteLine(d.ToShortDateString()));
</code></pre>
<p>TakeWhileが好きです。問題文に対して、自然に解答出来るような気がするので。「今日から(Repeat)」「2013年12月31日までの(TakeWhile)」「13日の金曜日(Where)」。実に自然に記述できる。いやまあ、Repeatが直感的かというと結構微妙なところではありますが。Rangeでfrom,toのほうが自然だろ常識的に考えて、というのも確かなんですけど、Rangeだとtoを作るのに計算式が必要ってのが、ちょっと違うかな、と。</p>
<p><a href="http://en.wikipedia.org/wiki/Pizza_(programming_language)">Pizza (programming language)</a>のexampleにもあるような、Streamを始めとして何かを無限リピートしてTakeWhileで終了条件を設定、というのはパターンとして結構幅広く使える、と思う。ある種のデザインパターン。イディオムイディオム。参考リンクは<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">C# 3.0 と while(true) と Iterator - NyaRuRuの日記</a>この辺り。</p>
<p>例えばVS2010から搭載されるEnumerable.Zipや、あとCycleを定義してみる。</p>
<pre><code class="language-csharp">// この二つを混ぜ合わす(VS2010で搭載されるZip関数)
var seq1 = Enumerable.Range(1, 10);
var seq2 = Enumerable.Range(10, 10);
Enumerable.Repeat(new { e1 = seq1.GetEnumerator(), e2 = seq2.GetEnumerator() }, int.MaxValue)
    .TakeWhile(t =&gt; t.e1.MoveNext() &amp;&amp; t.e2.MoveNext())
    .Select(t =&gt; t.e1.Current + t.e2.Current); // ここがZipのSelectorの部分
// foo,bar,hoge,foo,bar,hogeを無限に繰り返す
var elements = new[] { &quot;foo&quot;, &quot;bar&quot;, &quot;hoge&quot; };
var cycle = Enumerable.Repeat(elements, int.MaxValue).SelectMany(ar =&gt; ar);
</code></pre>
<p>Linqのお陰でかつてない勢いでint.MaxValueを使っているこの頃。Repeatも万能ですねえ。いやまあ、もう素直にAchiral使えよって話なんですが、標準メソッドのみで粘るのも面白くて。そういえばでついでなので<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>でもやってみた。</p>
<pre><code class="language-javascript">// JavaScriptはAddDaysがないので副作用全開でTodayを
// setHours(24)で翌日にしてしまう、という方針でやってみた

E.Repeat(new Date())
 .Do(&quot;$.setHours(24)&quot;)
 .TakeWhile(&quot;$.getFullYear() &lt; 2014&quot;)
 .Where(&quot;$.getDay() == 5 &amp;&amp; $.getDate() == 13&quot;)
 .ForEach(&quot;alert($)&quot;);
</code></pre>
<p>DoはReactive Frameworkにもありました。副作用を加えた上で素通しするメソッド。副作用は嫌なものです。汚いです。何が嫌かというと、動作を考えるのに見る範囲を広げなきゃいかんところかなあ。そしてLinqの何がいいかというと、見る範囲が物凄く限定される(ラムダ式一文だけを見ればいい)と思っている。だからLinq内でクロージャ(というか外部の変数をキャプチャして使う)もあんま好ましくないし、C#クエリ構文のletも好きじゃない。なるべくなら使いたくない。長文耐性なのは分かるけれど、カッコやインデントがなくてスマートだけれど、その分だけスコープが不明瞭になるという側面が否めない。まあ、letが必要なシチュエーションをSelectManyでやると、大抵はもっと奇怪になるのですけど。</p>
<p>んでまあ、この場合だとAddDaysのかわりにnew Date(year,month,day)で新しいのを作れば副作用なくSelectが使えるわけですが、ありきたりで面白くないと思ったので別な方向に走ってみた。というか、無限リピートは、無限リピートする何かに対して副作用全開で操作を加え続ける、という形の方が面白いというか実用的というか普通だとは思う。冒頭の例みたいなやつだと、別にRangeでよくね？って感じですし。Haskellじゃないんだから、潔癖症にならずに、副作用といかに楽しくお付き合いするかが大事なのですかね。</p>
<p>あ、ちなみに$は引数が一つの場合の省略記法です。こういった機能は<a href="http://ja.wikipedia.org/wiki/Scala">Scala</a>にもある。引数が一つのみの場合が大半なので、記述がグッと縮まるし、何よりも引数名を付ける必要がないのが嬉しい。C#でも使えるようになると嬉しいなあ、とずっと思ってるんですが中々どうして無理なんですかねえ、残念。</p>
</div>
<h1><a href="https://neue.cc/2009/09/07_198.html">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></h1>
<ul class="date"><li>2009-09-07</li></ul>
<div class="entry_body"><p>予定は常に変更されるもの、というわけで、今回はAnonymousEnumerableとAnonymousEnumeratorを見たいと思います。表に出てこない、internalのクラスな上に、内部でも全然使われていないので、見る必要はあんまりない。のですが、これと対になるAnonymousObservableとAnonymousObserverを見るにあたって、先に慣れ親しんだIEnumerable/Enumeratorで考えたほうが分かりやすかったので、これを先に考えます。</p>
<pre><code class="language-csharp">class AnonymousEnumerable&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator;
    public AnonymousEnumerable(Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator)
    {
        // 以下略
}

class AnonymousEnumerator&lt;T&gt; : IEnumerator&lt;T&gt;
{
    private Func&lt;T&gt; current;
    private Action dispose;
    private Func&lt;bool&gt; moveNext;

    public AnonymousEnumerator(Func&lt;bool&gt; moveNext, Func&lt;T&gt; current, Action dispose)
    {
        this.moveNext = moveNext;
        this.current = current;
        this.dispose = dispose;
    }

    public T Current
    {
        get { return this.current(); }
    }

    public bool MoveNext()
    {
        return this.moveNext();
    }
    
    // 以下略
}
</code></pre>
<p>Reflectorで見ちゃってるので、一部だけ(ライセンス！)。ただ、どれも一行なので見るまでもなく何をやってるのか想像付くと思います。 お馴染みのインターフェイスを実装しているだけですが、その実装を全てコンストラクタで受ける関数に任せています。ようするにこれはどういうことなのかというと、実例としてEnumerable.RepeatとSelectをAnonymousEnumerableで実装してみるとこうなります。</p>
<pre><code class="language-csharp">public static class Enumerable
{
    public static IEnumerable&lt;T&gt; Repeat&lt;T&gt;(T element, int count)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var index = 0;
            var current = default(T);
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; // MoveNext
                {
                    if (index == 0) current = element;
                    return (index++ &lt; count);
                },
                () =&gt; current, // Current
                () =&gt; { } // Dispose
            );
        });
    }
    
    // 実際のSelectは&lt;TSource,TResult&gt;ですが、都合により略
    public static IEnumerable&lt;T&gt; Select&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, T&gt; selector)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var enumerator = source.GetEnumerator();
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; enumerator.MoveNext(),
                () =&gt; selector(enumerator.Current),
                () =&gt; enumerator.Dispose()
            );
        });
    }
}
</code></pre>
<p>勿論、普通はyieldを使えばいいわけですが、もしyieldがなければ、こういう形で実装するのが簡潔でベスト、に見える。クロージャでコンパイラにクラス生成を任せているわけですねー。外部イテレータですが、外部のクラスに分割せず中に書けるため、すっきり分かりやすい。この発想はあったけどC#でやるという発想はなかったわ、というわけで結構感動しました。</p>
<p>そうそう、この仕組みは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>と丸っきり同じなのです。感動ってのは、私の基本方針は間違ってなかったんだ！の裏付けでの喜びなので不純です。そのJavaScriptでの実装はこんな感じ。</p>
<pre><code class="language-javascript">Linq.Object = function(getEnumerator)
{
    this.GetEnumerator = getEnumerator;
}

Linq.Enumerator = function(moveNext)
{
    this.Current = null;
    this.MoveNext = moveNext;
}

Repeat: function(element, count)
{
    return new Linq.Object(function()
    {
        var index = 0;
        return new Linq.Enumerator(function()
        {
            if (this.Current == null) this.Current = element;
            return (index++ &lt; count);
        });
    });
}

Select: function(selector)
{
    var source = this;
    selector = Linq.Utils.CreateFunctor(selector);

    return new Linq.Object(function()
    {
        var enumerator = source.GetEnumerator();
        var index = 0;

        return new Linq.Enumerator(function()
        {
            if (enumerator.MoveNext())
            {
                this.Current = selector(enumerator.Current, index++);
                return true;
            }
            else
            {
                return false;
            }
        });
    });
}
</code></pre>
<p>スコープが若干違うかなって感じですが、大体同じです。(Linq.ObjectはLinq.Enumerableに名前変えよう……)。JavaScriptだからこそ、yieldがなくてもスッキリ定義出来る！と思っていただけに、そっかあ、そういう手を使えば良かったのかと少しショックだったりして。ほんとC#は柔軟な言語で、むしろもうJavaScriptよりもLightWeightだよ！</p>
<p>さて、次回はAnonymousObservableとAnonymousObserverを見てみることにします。勿論、予定は未定です。ていうかSubscribeはどうした、というと、Subscribeの中身はAnonymousObserverなので全然横道にそれてません、大丈夫です、まだ一直線です。</p>
</div>
<h1><a href="https://neue.cc/2009/09/04_197.html">.NET Reactive Framework メソッド探訪第一回:FromEvent</a></h1>
<ul class="date"><li>2009-09-04</li></ul>
<div class="entry_body"><p>まず、リアクティブフレームワークとは何ぞや、ということなのですが今のところ<a href="http://www.infoq.com/jp/news/2009/07/Reactive-Framework-LINQ-Events">InfoQ: .NETリアクティブフレームワーク（Rx）がLINQ to Eventsを可能にする</a>の記事ぐらいしか情報はありません。.NET 4.0に含まれる(かもしれない)ということ、現在のところSilverlight Toolkitの単体テストのところにこっそりと配置されていること。それだけです。紹介も、記事中にもリンクされていますが<a href="http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html">unfold: Introducing Rx (Linq to Events)</a>の一連の記事ぐらいしかありません。これの前文が中々に素敵です。</p>
<blockquote>
<p>Buried deep in the bin folder of the Silverlight Toolkit Unit Tests is a hidden gem: The Rx Framework (System.Reactive.dll).  If you glanced quickly you’d miss it altogether but it’s one of the most exciting additions to the .NET framework since Linq.</p>
</blockquote>
<p>今のところ微妙にパッとしない(Parallelは簡単に使えるがゆえにインパクトが足らない)4.0の隠し玉はコレですね、間違いない。軽く触ってみたのですが、中々に感動的。Linq to Objects好きならば間違いなく琴線に触れます。C#3.0がコレクションの操作をforeachからLinqに変えてしまったように、.NET4.0はイベントもLinqに変わる。まさにLinq to Everywhere! Functional Reactive Programming!</p>
<h2>How to use</h2>
<p><a href="http://www.codeplex.com/Silverlight">Silverlight Toolkit</a>をダウンロードしてSource/Binaries/System.Reactive.dllを頂けば完了。ただし、これはそのままだとSilverlightのプロジェクトでしか動作しないので、その他ので利用したい場合は<a href="http://evain.net/blog/articles/2009/07/30/rebasing-system-reactive-to-the-net-clr">ここの記事</a>に示されているように、githubに公開されているコードを実行(Cecilのdllが必要、記事文中にリンクされています)して変換する必要があります。今回はとりあえず、Silverlightで試してみたいと思います。こちらはこちらで、<a href="http://www.microsoft.com/downloads/details.aspx?displaylang=ja&amp;FamilyID=9442b0f2-7465-417a-88f3-5e7b5409e9dd">Silverlight 3 Tools</a>のダウンロードが必要ですけれど。</p>
<h2>実例</h2>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication4.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>マウスの動きに円が追随する、という単純なものをSilverlightで作ってみました。移動は完全に追随するのではなく、座標が15で割り切れる位置の場合のみ移動としました。スナップすることをイメージしたつもりなのですが、動きがガクガクです。これは、マウス移動に完全に追随して全ての座標でイベントが発生するわけではない = 15で割り切れる座標を通過してもイベントが発生しない場合がある = 動きがガクガク。というわけで、スナップしたい場合はWhereで間引くのではなく、Selectで近傍座標に寄せるべきです、が、いやまあ、例なので……。</p>
<pre><code class="language-csharp">// XAMLではなく全部コード上に書いたのは両方を張るのが面倒だから……
// 内容はCanvasとEllipseを配置するというもので、本筋とは関係ありません
InitializeComponent();
var canvas = new Canvas { Background = new SolidColorBrush(new Color {A=255, R = 100, G = 100, B = 100 }) };
var ellipse = new Ellipse { Height = 30, Width = 30, Fill = new SolidColorBrush(Colors.Orange) };
canvas.Children.Add(ellipse);
this.Content = canvas;

// FromEventはイベント発火がトリガとなってLinq発動
// 後段に送られるのはEvent&lt;T&gt;というもので、
// SenderとEventArgsという読み取り専用プロパティを持つクラス
var canvasMove = Observable.FromEvent&lt;MouseEventArgs&gt;(canvas, &quot;MouseMove&quot;)
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Where(p =&gt; (p.X % 15 == 0) || (p.Y % 15 == 0))
    .Subscribe(p =&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    });

// Subscribeの戻り値の型はIDisposable
// Disposeを呼ぶと登録したイベントをデタッチすることが出来る
// デタッチしないなら取得する必要は特にはない
// canvasMove.Dispose();
</code></pre>
<p>MouseMoveでイベントが発火する度にLinqを通る。なるほど、イベントがリストに、見える。イベントを無限リスト生成として捉えることで、イベントに対してLinq操作が可能になった。ObserverパターンとIteratorパターンは同じだったんだよ！なんだってー！みたいなノリがある。もう少し丁寧に見ると、Observable.FromEventでイベントをPush型の無限リストに変換。戻り値はIObservable&lt;T&gt;。イベント発火時に後段に流れてくるのはEvent&lt;T&gt;。これは通常のイベント登録時に使うsenderとeventArgsをラップしただけの単純なもの。あとはIObservableに用意されているメソッド(Select, Where, TakeWhileなどお馴染みのものから、Delay, WaitUntilなどイベント用の目新しいメソッドなど多数)を繋げて、最後にSubscribe。このSubscribeは、つまり通常のイベント登録時のメソッド本文の役割を果たす。Linqで言ったらForEachのようなもの。Subscribeのオーバーロードも幾つかあるのですが、それはまた後日。</p>
<pre><code class="language-csharp">// つまるところ、以下のコードと同じだったりはする
// ただ、IObservable&lt;T&gt;は通常のイベント登録では無理な複雑な操作が簡単、
// そして何よりも、このような単純なコードでもそんなに複雑になっていない！
canvas.MouseMove += (sender, e) =&gt;
{
    var pos = e.GetPosition(canvas); // Select
    if (!(pos.X % 15 == 0 || pos.Y % 15 == 0)) return; // Where
    ellipse.SetValue(Canvas.LeftProperty, pos.X - ellipse.Width / 2);
    ellipse.SetValue(Canvas.TopProperty, pos.Y - ellipse.Height / 2);
};
</code></pre>
<p>通常のイベント登録と対比してみると分かりやすいかしらん。FromEventではMouseEventArgsという型を明示する必要があるのがカッタルイ。推論は偉大。が、しかし、IObservableが複雑な操作が可能なのに対し、イベントに追加では直球なものしか書けない。また、複雑な操作が可能なわりには、FromEventは驚くほどシンプルに書ける。シンプルな操作でも(記述するのに)重たくない、というのは特筆すべきことじゃあないでしょうか。</p>
<pre><code class="language-csharp">// stringを避けたこういう登録方法もあるけれど、面倒なうえに警告出る
Observable.FromEvent((EventHandler&lt;MouseEventArgs&gt; h) =&gt; new MouseEventHandler(h),
        h =&gt; canvas.MouseMove += h, // addHandler
        h =&gt; canvas.MouseMove -= h) // removeHandler
    .Subscribe(e =&gt; Debug.WriteLine(e.EventArgs.GetPosition(canvas)));
</code></pre>
<p>ところで、イベント名をstringで書くのはどうよ、ていうかJavaScriptのaddEventHandlerみたいで嫌だよね？ね？リファクタリング効かないわ、IntelliSenseも動かないわでロクなことがない。というわけで、FromEventのオーバーロードを見ると、ちゃんと普通に登録する方法も用意されてはいる。一応、用意、されては、いる。が、しかし、あんまりだー。あんまりすぎるー。流れてくるEventhandler&lt;MouseEventArgs&gt;をMouseMoveが受け取ってくれないので、第一引数でMouseEventHandlerに変換する(ところで警告が消せないのですが、警告無しで処理する方法ってあるのかしらん)。あとは、addとremoveの登録。長ったらすぎてこれはダメぽ。確かに、こんなんなら、stringでいいです……。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication3.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre><code class="language-csharp">// 普段あまり書かないMouseEventArgsとかいう型定義は書きにくいし
// メソッド名もstringで書くのはミスが出がち、ということで
// 拡張メソッドでイベント取り出し用のメソッドを予め作っておくと良い
public static IObservable&lt;Event&lt;MouseEventArgs&gt;&gt; GetMouseMove(this UIElement elem)
{
    return Observable.FromEvent&lt;MouseEventArgs&gt;(elem, &quot;MouseMove&quot;);
}

// マウスの軌跡を1秒後に描画します
canvas.GetMouseMove()
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Delay(1000)
    .Subscribe(p =&gt;Dispatcher.BeginInvoke(()=&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    }));
</code></pre>
<p>汚い部分は隔離！ということで、拡張メソッドに退避してやると、美しく書ける。いやまあ、この辺は全部<a href="http://themechanicalbride.blogspot.com/2009/07/developing-with-rx-part-1-extension.html">unfold: The Joy of Rx: Extension Events</a>に書いてあることなのですけど。んで、デモ的にもう少し面白げがあったほうがいいかな、と思ったのでDelayを足してみました。1秒後にマウス移動の軌跡を描画します。グルグルーっとマウス動かして止めてみてください。スムーズ、とは言い難いですね、しょんぼり。記述も、Delayを足すだけ。と言いたかったんですがBeginInvokeかあ、これどーにかなる方法ないかなあ。</p>
<h2>次回</h2>
<p>全10回ぐらいで、全部のメソッドを紹介するつもりです。私が理解できればの話ですが。ちょこちょこと実例的なものも交えていきたいと思います。私が使いこなせればの話ですが。というわけで、次回はSubscribeのオーバーロードの紹介にしたいと思います。Reactive Frameworkならではの魅力、に関してはもう少し先になってしまいそう。少し飛ばして、非同期連結の話なんかを先に持ってきた方が良いかなあ。</p>
</div>
<a href="https://neue.cc/2009">Prev |</a>
<a href="https://neue.cc/2009/3">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
