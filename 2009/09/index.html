<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2009-09</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/wp-content/themes/neuecc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <div id="header"></div>
        <div id="content"><h1><a href="https://neue.cc/2009/09/30_206.html">C# Linqでクイックソート</a></h1>
<ul class="date"><li>2009-09-30</li></ul>
<div class="entry_body"><pre><code class="language-haskell">qsort []     = []
qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
                 where
                   elts_lt_x   = [y | y &lt;- xs, y &lt; x]
                   elts_greq_x = [y | y &lt;- xs, y &gt;= x]
</code></pre>
<p>これはHaskellのコードで、良く見かける定番のQuickSort。うん、短い。というわけでLinqでそれをやる。というネタは既出のン番煎じなのですが、気にせずやる。</p>
<pre><code class="language-csharp">// LinqでHaskell風のクイックソート
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    return source
        .GroupBy(x =&gt; x.CompareTo(pivot))
        .OrderBy(g =&gt; g.Key) // OrderBy使うのはどうかなー、というところはある
        .SelectMany(g =&gt; (g.Key == 0) ? g : QuickSort(g));
}
</code></pre>
<p>GroupBy-&gt;SelectManyと流れるように書けて美しいー。これならHaskellにも引けを取らないですね！但し問題なのは、OrderByを使用しているところ。CompareToの結果である-1, 0, 1を並べ替えるために使っているのだけど、OrderByの中身はシュワルツ変換の挟まったクイックソートそのものなので邪道な感は否めない。OrderBy使うなら、そもそもsource.OrderBy(x =&gt; x)でもいいぢゃん、って話になってしまう。</p>
<pre><code class="language-csharp">// 非GroupBy版。LookupはGroupByの即時評価版と考えていい。
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    var lookup = source.ToLookup(x =&gt; x.CompareTo(pivot));
    return QuickSort(lookup[-1]).Concat(lookup[0]).Concat(QuickSort(lookup[1]));
}
</code></pre>
<p>GroupByをToLookupに書き変えました。ToLookupはGroupByの即時評価版といった感じで、インデクサによるアクセスが可能。インデクサ使わないでそのままforeachで列挙する、なんて時はGroupByを使った方が良いです。今回はインデクサで順番を明示的に指定するため、ToLookupでパーティション切って、Concatで繋いでやれば出来あがり。やってることが非常に分かりやすくて良い。ソースの見た目も中々綺麗じゃないでしょうか。Haskellのものとも非常に近いです(ようするに++がConcatなので) ToLookupではなくWhereを使えば、見た目は更にHaskellに近づきますが、列挙が二回になるので、ここはToLookupで。</p>
<pre><code class="language-csharp">// 普通に？書いた場合。
public static void QuickSort&lt;T&gt;(IList&lt;T&gt; source, int lowerBound, int upperBound)
    where T : IComparable&lt;T&gt;
{
    var pivot = source[lowerBound + ((upperBound - lowerBound) &gt;&gt; 1)];
    var left = lowerBound - 1;
    var right = upperBound + 1;
    while (true)
    {
        while (source[++left].CompareTo(pivot) &lt; 0) ;
        while (source[--right].CompareTo(pivot) &gt; 0) ;
        if (left &gt;= right) break;
        var temp = source[left];
        source[left] = source[right];
        source[right] = temp;
    }
    if (lowerBound &lt; left - 1) QuickSort(source, lowerBound, left - 1);
    if (right + 1 &lt; upperBound) QuickSort(source, right + 1, upperBound);
}
</code></pre>
<p>今度は非Linqに一般的？な書き方で。あまりヘタな書き方するとアレだなあ、と思ったので<a href="http://blog.livedoor.jp/dankogai/archives/51182235.html">404 Blog Not Found:javascript - Array#sortはオレquicksortより遅い by Chrome</a>のコードをC#に移植しました。<a href="http://dic.nicovideo.jp/a/%E3%81%82%E3%81%9F%E3%81%97%E3%81%93%E3%81%AE%E3%83%91%E3%82%A4%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%82%88%E3%81%AD">あたしこの書き方嫌いなのよね</a>、という感じにゴチャゴチャした印象は否めないというか、まあ、嫌いなのよね。一本の配列で頑張るところが、ゆとりな私としてはしんどい。ビットシフトも嫌よね。</p>
<pre><code class="language-csharp">public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    var enumerator = source.GetEnumerator();
    if (!enumerator.MoveNext()) yield break;

    var pivot = enumerator.Current;
    var less = new List&lt;T&gt;();
    var equal = new List&lt;T&gt;();
    var greater = new List&lt;T&gt;();
    do
    {
        switch (enumerator.Current.CompareTo(pivot))
        {
            case -1: less.Add(enumerator.Current); break;
            case 0: equal.Add(enumerator.Current); break;
            case 1: greater.Add(enumerator.Current); break;
        }
    } while (enumerator.MoveNext());

    foreach (var item in QuickSort(less)) yield return item;
    foreach (var item in equal) yield return item;
    foreach (var item in QuickSort(greater)) yield return item;
}
</code></pre>
<p>最後に、非Linqで、ToLookup版を再現してみたものを。do-whileがToLookupでforeachの連発がConcat。ようするに富豪的にListを作りまくるってわけなんですね！書きやすいし分かりやすいので、一本配列版よりも遥かに好き度高い。現代人はListを贅沢に大量に好きなだけ使うのです。まあ、Linq版がない状態でこの書き方が浮かぶ or 実行に移せるかどうかといったら、かなり無理ですけど。</p>
</div>
<h1><a href="https://neue.cc/2009/09/28_205.html">.NET Reactive Framework メソッド探訪第五回:Scan</a></h1>
<ul class="date"><li>2009-09-28</li></ul>
<div class="entry_body"><p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">var random = new Random();
Func&lt;byte&gt; nextByte = () =&gt; (byte)random.Next(0, byte.MaxValue + 1);

// CenterEllipseは真ん中の円のこと。
// 1000秒以内に3回クリックするとランダムで色が変わる
// GetMultiClickScan関数が今回の主題で、解説は後で。
CenterEllipse.GetMultiClickScan(3, 1000).Subscribe(() =&gt;
    CenterEllipse.Fill = new SolidColorBrush(Color.FromArgb(255, nextByte(), nextByte(), nextByte())));
</code></pre>
<p>円を1秒以内にトリプルクリックすると色が変わります。右側のログ表示はミリセカンド単位でトリプルクリック時の経過時間を表しています。つまり、これが1000以内ならば色が変わり、1000より上ならば色は変わりません。このサンプルのテーマは、トリプルクリックの検出です。トリプルだけではなく、クアドラプルでもクインタプルでも、1秒以内じゃなくて5秒でも10秒でも応用できる形で書くとしたら、どう書く？ グローバル変数に、クリックイベントを格納する配列でも置くかしらん。それがきっと簡単で分かりやすくて、でも……。</p>
<p>今回はRx Frameworkの関数から、Scanを取り上げます。この例題は私が考えたわけではなく、<a href="http://blogs.msdn.com/jeffva/archive/2009/08/14/my-solutions-to-the-reactive-framework-tripple-click-puzzle.aspx">Ramblings of a Lazy Coder : My solutions to the Reactive Framework Tripple-click puzzle</a>という問題からです。URLリンク先は解答編、というわけで、この解答を解説します。</p>
<p>考え方としては、クリックイベントに「クリックされた時間」という情報を付加。更に、クリック回数分の「前のデータ」を参照して指定時間内で連続クリックかどうかを確認する。時間情報の付加は匿名型を作るだけなので簡単ですが、「前のデータ」を参照するのが厄介。Linqは前にしか進まないし、送られてくるデータは過去のものなど知らない。このことはReactive Frameworkだけの話ではなく、以前にも<a href="http://neue.cc/2009/03/06_138.html">LINQで左外部自己結合</a>や<a href="http://neue.cc/2009/03/16_141.html">Scan?</a>という記事で書きましたが、そこで出てくる解決策がScan。そうそう、ScanはAchiralにあるので(ということでlinq.jsにもあります)、動作は分かってます。ようするにAggregateの計算過程吐きだし版です。とりあえず<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>でE.Range(1,10).Scan(&quot;x,y=&gt;x+y&quot;)と打ってみてください(宣伝宣伝)</p>
<p>Scanならば「一個前」の情報が手に入る。しかし「複数個前」の情報はどうすれば？ 答えは配列使えばいいぢゃない。だそうです。過程のデータをとりあえず配列に入れて、次に送り出してやれば、そりゃ簡単に取り出せますね。何だか邪道な気がしますが、気にしない気にしない。URL先の解答例では生の配列を使って、インデックスをゴニャゴニャとしていて非常に正しいとは思いますが、あまり生の配列のインデックスは扱いたくないので、Queueを使ってみました。別にQueueのClear()のコストなんてたかが知れてるっしょ(中ではArray.Clearを呼んでいて、Array.Clearは……以下略)という割り切りで。</p>
<pre><code class="language-csharp">public static IObservable&lt;MouseButtonEventArgs&gt; GetMultiClickScan
    (this UIElement element, int count, int multiClickSpeedInMilliSeconds)
{
    return Observable.FromEvent&lt;MouseButtonEventArgs&gt;(element, &quot;MouseLeftButtonDown&quot;)
        .Select(e =&gt; e.EventArgs)
        .Scan(new
        {
            Times = new Queue&lt;DateTime&gt;(count),
            Hit = false,
            Event = (MouseButtonEventArgs)null // ダミーなのでnullをキャストするのが楽
        }, (a, e) =&gt;
        {
            var isHit = false;
            var now = DateTime.Now;
            a.Times.Enqueue(now);
            if (a.Times.Count == count)
            {
                var first = a.Times.Dequeue();
                Debug.WriteLine((now - first).TotalMilliseconds); // Debug
                if ((now - first).TotalMilliseconds &lt;= multiClickSpeedInMilliSeconds)
                {
                    isHit = true;
                    a.Times.Clear();
                }
            }

            return new
            {
                Times = a.Times,
                Hit = isHit,
                Event = e
            };
        })
        .Where(a =&gt; a.Hit)
        .Select(a =&gt; a.Event);
}
</code></pre>
<p>ScanはAggregateと全く同じで、accumlatorのみの実行の他に、第一引数でseedを渡すこともできます。Scanのseedで、変数と判定を行うためのフラグを保持するクラスを作り、accumlatorで判定と変数の持ち越しを行い、Whereで判定をフィルタリング。このコンボは非常に強力で、幾らでも応用が効きそう。LinqでのAggregateはほとんど使われませんが、RxにおけるScanはよく見かけることになるのではないかと思います。</p>
<p>で、理屈は分かったけれど、何だかゴチャゴチャとしてない？ という感想は否めない。ただ、グローバル領域に変数を置く必要なくフラグを閉じ込められていること、そして、応用の効きそうな柔らかさが見えたり見えなかったりしませんか？ 応用的なものも、追々考えていきたいです。</p>
<h2>次元の狭間へ</h2>
<p>Scanが出たので、Aggregateもついでにおさらい。これはLinq to ObjectsのAggregateと変わりません。ちなみにRx Frameworkでの内部実装はScan().Last()だったりするので、Scanとほんとーに丸っきり変わりません。じゃあ、無限リピートのFromEventにたいしてAggregateって、実行するとどうなるの？というのは気になるところですが、答えは次元の狭間に入ってしまって、その行からコードが一切進まなくなります。AggregateだけじゃなくCountやLast、ToEnumerableなど全てを列挙してから答えを返す系のメソッドは全て同じ結果になります。コンソールアプリの簡単なコードで試してみると、こうなる。</p>
<pre><code class="language-csharp">class MyClass
{
    public event EventHandler&lt;EventArgs&gt; Ev;

    public void Fire()
    {
        Ev(this, new EventArgs());
    }
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var count = Observable.FromEvent&lt;EventArgs&gt;(mc, &quot;Ev&quot;)
        .Count(); // ここで次元の狭間にダイブする

    mc.Fire(); // ここに到達することは未来永劫無い
}
</code></pre>
<p>恐ろしや。ただ、前段階でTakeやTakeWhileを挟めば、無限リストは有限リストとなるので、面白い感じに制限が出来ます。この辺も応用例として、そのうち紹介していければと思います。</p>
<h2>カウンター</h2>
<p>もう一度Scanを見ます。トリプルクリックの例題は捻りすぎな感が否めないので、もっとストレートに、Scanの「前の値を保持し続けることが出来る」という点を見せる例題を一つ。<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3" title="クロージャ - Wikipedia">クロージャの例</a>なんかでも定番のカウンターで。</p>
<p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="200px" height="50px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan_Counter.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">Observable.FromEvent&lt;RoutedEventArgs&gt;(CounterButton, &quot;Click&quot;)
    .Scan(0, (x, y) =&gt; ++x)
    .Subscribe(i =&gt; CounterButton.Content = i + &quot;Clicked&quot;);
</code></pre>
<p>とても簡潔で、変数が全て閉じ込められていて、綺麗……。</p>
</div>
<h1><a href="https://neue.cc/2009/09/25_204.html">Linqは美人</a></h1>
<ul class="date"><li>2009-09-25</li></ul>
<div class="entry_body"><pre><code class="language-csharp">public class Stamp
{
    public int Year { get; set; }
    public string Name { get; set; }
    public Stamp(int year, string name) { this.Year = year; this.Name = name; }
    public override string ToString() { return this.Year + &quot;:&quot; + this.Name; }
}

public class StampCollection : IEnumerable&lt;Stamp&gt;
{
    private Dictionary&lt;string, Stamp&gt; stamps = new Dictionary&lt;string, Stamp&gt;();

    public void Add(Stamp s) { stamps.Add(s.Name, s); }
    public void Add(int year, string name) { stamps.Add(name, new Stamp(year, name)); }

    // yield returnを通さなくてもそのままreturn可能
    public IEnumerator&lt;Stamp&gt; GetEnumerator()
    {
        return stamps.Values.OrderBy(s =&gt; s.Year).GetEnumerator();
    }

    // GetEnumeratorと名乗りながらGetEnumeratorじゃないのが少しアレですね
    public IEnumerable&lt;Stamp&gt; GetEnumerator2()
    {
        return stamps.Values.OrderByDescending(s =&gt; s.Year);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}

// 利用時例
static void Main(string[] args)
{
    // コレクション初期化子は、複数引数時は更に{}で囲む
    var stamps = new StampCollection()
    {
        {1998, &quot;hoge1&quot;},
        {1999, &quot;hoge2&quot;},
        {2000, &quot;hoge3&quot;}
    };
    
    // GenericsにしておくとCast&lt;T&gt;を使わずLinqでコンボ出来る
    stamps.GetEnumerator2().Select(s =&gt; s.Name).ToList().ForEach(Console.WriteLine);
}
</code></pre>
<p><a href="http://d.hatena.ne.jp/cast_everything/20090924/1253786494" title="memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋">memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋</a>のものを少し書き換えました。コレクション初期化子と、yield returnせずにそのまま投げ返すように変えただけですが。Linqは美人。ですです。</p>
</div>
<h1><a href="https://neue.cc/2009/09/18_203.html">JavaScriptでString.Format的な超簡易テンプレート置換</a></h1>
<ul class="date"><li>2009-09-18</li></ul>
<div class="entry_body"><pre><code class="language-javascript">// String.Format的な超簡易テンプレート置換関数
var Format = function(template, replacement)
{
    if (typeof replacement != &quot;object&quot;) // 可変長引数時はreplacementを詰め替え
    {
        replacement = Array.prototype.slice.call(arguments, 1);
    }
    return template.replace(/\{(.+?)\}/g, function(m, c)
    {
        return (replacement[c] != null) ? replacement[c] : m
    });
}

// 例。可変長引数渡しでも配列渡しでもオブジェクト渡しでも可。
var case1 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, &quot;あいでぃ&quot;, &quot;要素&quot;);
var case2 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, [&quot;あいでぃ&quot;, &quot;要素&quot;]);
var case3 = Format(&quot;&lt;div id={ID}&gt;{ELEM}&lt;/div&gt;&quot;, { ID: &quot;あいでぃ&quot;, ELEM: &quot;要素&quot; })
</code></pre>
<p>.NET FrameworkのString.Formatは文字を連結するのに、非常にお手軽で良いです。というわけでJavaScriptでもそれをやる。ついでにテンプレート置換風にオブジェクト渡しにも対応させる。単純な置換時は数字で、長ったらしい置換時はオブジェクトで。両方に対応させなければ、詰め替えが必要ないので正規表現でカカッと一行なんですねえ。詰め替えも別にslice.callで一発だし。<a href="http://neue.cc/2009/04/28_154.html" title="neue cc - JavaScriptでString.Format">以前にlinq.jsを絡めてgdgdとやってた</a>のですが、<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">二度もね！</a>、あんなにgdgdやらずとも、もんのすごーく単純明快に書ける。無理やり使おうとして、無駄に複雑になるのはイクない。</p>
<p>と、恥ずかしくなったので今回載せました。あと、JavaScriptは文字連結面倒くせー、って時にササッとコピペで取り出して使いたい時のために(笑) ちゃんとDateTime等も含めたフォーマット変換に対応させるとか、テンプレートだったらちゃんとテンプレートエンジンな感じでforやifも動くように、とかの話は知りません。</p>
<p>そういえば、置換部分の関数ですけど、最初は格好つけて「return replacement[c] || m」って書いたんですが、これだとマッチがハッシュ内に見つからなかった場合(undefinedになってる)だけでなく、 空文字列の場合もfalse扱いになってしまってダメなんですね。C#の??のように使いたいのですが、例えば数字だと「var i = 0 || 3」だったら3になるしで使いづらい。というわけで、結局==nullばかり使うことになる。===undefinedって書けって話でもありますが、まあ、==nullのほうが色々考えなくて済むから楽で。</p>
</div>
<h1><a href="https://neue.cc/2009/09/16_202.html">ログ吐き骨組み</a></h1>
<ul class="date"><li>2009-09-16</li></ul>
<div class="entry_body"><p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/LogBrowseBase.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>デモ大事。<a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">Subscribe</a>の時にConsole.WriteLine並べて、実行結果想像つきますよね、というのがいまひとつすぎたので、出力が見える骨組みを作りました。今後のReactive Frameworkの紹介時にソースコード上のDebug.WriteLineは、こーいうことなんですねー、と思ってください。毎回これ乗っけてると長ったらしいので、暗黙の、ということで。</p>
<pre><code class="language-xml">&lt;UserControl x:Class=&quot;SilverlightApplication4.MainPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; 
    mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;640&quot; d:DesignHeight=&quot;480&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition /&gt;
            &lt;ColumnDefinition Width=&quot;200&quot; /&gt;
        &lt;/Grid.ColumnDefinitions&gt;

        &lt;StackPanel Grid.Column=&quot;0&quot;&gt;
            &lt;Button Name=&quot;ExecuteButton&quot; Content=&quot;Execute&quot; /&gt;
            &lt;Button Name=&quot;ErrorButton&quot; Content=&quot;Error&quot; /&gt;
            &lt;Button Name=&quot;ObservableButton&quot; Content=&quot;Observable&quot; /&gt;
            &lt;Button Name=&quot;EnumerableButton&quot; Content=&quot;Enumerable&quot; /&gt;
        &lt;/StackPanel&gt;
        &lt;ScrollViewer Grid.Column=&quot;1&quot;&gt;
            &lt;TextBlock Name=&quot;LogBrowseTextBlock&quot;&gt;&lt;/TextBlock&gt;
        &lt;/ScrollViewer&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Reflection;

namespace SilverlightApplication4
{
    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();
            Debug.Set(LogBrowseTextBlock, Dispatcher);

            ExecuteButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10).Subscribe(
                    i =&gt; Debug.WriteLine(i),
                    e =&gt; Debug.WriteLine(e),
                    () =&gt; Debug.WriteLine(&quot;completed&quot;)
                )
            );

            ErrorButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10)
                    .Do(i =&gt; { if (i == 5) throw new Exception(); })
                    .Subscribe(
                        i =&gt; Debug.WriteLine(i),
                        e =&gt; Debug.WriteLine(&quot;onError&quot;),
                        () =&gt; Debug.WriteLine(&quot;onCompleted&quot;)
                    )
            );

            ObservableButton.GetClick().Subscribe(() =&gt;
                GetMethodNames(typeof(Observable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );

            EnumerableButton.GetClick().Subscribe(() =&gt;
                  GetMethodNames(typeof(Enumerable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );
        }

        IEnumerable&lt;string&gt; GetMethodNames(Type type)
        {
            return type.GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Select(mi =&gt; mi.Name)
                .OrderBy(s =&gt; s)
                .Distinct();
        }
    }

    public static class Debug
    {
        private static TextBlock textBlock;
        private static Dispatcher dispatcher;

        public static void Set(TextBlock textBlock, Dispatcher dispatcher)
        {
            Debug.textBlock = textBlock;
            Debug.dispatcher = dispatcher;
        }

        public static void WriteLine(object message)
        {
            if (textBlock != null)
            {
                dispatcher.BeginInvoke(() =&gt;
                    textBlock.Text = message.ToString() + Environment.NewLine + textBlock.Text);
            }
        }
    }

    public static class ControlExtensions
    {
        public static IObservable&lt;Event&lt;RoutedEventArgs&gt;&gt; GetClick(this ButtonBase button)
        {
            return Observable.FromEvent&lt;RoutedEventArgs&gt;(button, &quot;Click&quot;);
        }
    }
}
</code></pre>
<p>幾ら簡易的なものだから、という言い訳がましさを考えても、かなり微妙なコードな気がする。原型はWPFでTraceListenerにTextBlockに書きだすものを追加して、Trace.WriteLineで処理していたもの。SilverlightにはTraceがなかったので、そのまま静的クラス・メソッドに置き換えて、Silverlightにも本来あるDebugを塗り替えちゃうという……。ようするにそのままコピペしても動くよね！的な感じでやりたいな、というところなわけです。ダメ？</p>
<p>ついでにSubscribeの中でObservableって、汚い、ように見えるかも。でも実際これはなんてことなくて、ようはJavaScriptっぽいんですよね、ほんと。DOMContentLoadedにイベント登録のaddEventListener並べるのと一緒で。じゃあ実際こうしてグチャグチャ並べるかというとそうではないようで、実際は拡張メソッドへ記述する、という形で分散していくようですが、まだまだ分からず。Microsoft側の実例やドキュメントが整ってくれないと何とも言えない感じ。</p>
<h2>作業環境</h2>
<p class="noindent">
	<a href="http://neue.cc/wp-content/uploads/image/vsorig.jpg"><img src="http://neue.cc/wp-content/uploads/image/vsmin.jpg"></a>
</p>
<p>画像クリックで原寸サイズ。最近思うところあってVisual Studioの配置をごにょごにょと弄っています。今は、こんな感じに落ち着きました。左にエラー一覧・検索など。右にソリューションエクスプローラー・クラスビュー・スタートページなど。そして左右にそれぞれコードウィンドウを分割。原則的にメインウィンドウは左。コード定義ウィンドウを右ウィンドウに開いて常時表示。もしくはXAML編集と並列したり。といったところです。コード定義ウィンドウはデカい画面で常時表示で初めて効果を発揮しますね、素晴らしく便利。</p>
<p>30インチ 2560x1600の無駄遣いが火を吹く！というわけですが、やっぱ広いって便利、エディタウィンドウ2面同時表示って便利、です。30インチでなくても、横2560は19インチ1280x1024のデュアルで行けます。ただ、実際はこれに加えてデバッグ時のプログラム本体なりブラウザなりを置いておく場所が欲しいので、その場合はデュアルじゃ足りないですね……。グラフィックボードが一枚でトリプルをサポートしてくれれば、というか、するべき、ですよね。ATIの<a href="http://pc.watch.impress.co.jp/docs/news/20090911_315056.html" title="【PC Watch】 AMDが次世代GPUに搭載するマルチディスプレイ機能「Eyefinity」を披露">Eyefinity</a>にはとても期待してます。</p>
</div>
<h1><a href="https://neue.cc/2009/09/14_201.html">.NET Reactive Framework メソッド探訪第四回:メソッド一覧</a></h1>
<ul class="date"><li>2009-09-14</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">前回</a>が少し、明らかに説明不足でした……。Subscribeが原則としてIObserverを受ける(直接ラムダ式でonNextを記述するのはただの省略記法)ということは、IObserverを別に作っておける。もっと進めると、Subscribeで実行されるコード本体は自由に入れ替え可能。ということになります。ここが、イベント直記入に対するReactive Frameworkの強みの一つ。それ○○パターンだって？そうですね？その○○パターンがデフォルトで何も考えず使えるのならば、素晴らしいと思います。</p>
<p>では、ここからようやくメソッド探訪。の前に、全メソッド一覧を見てみます。IObservable&lt;T&gt;拡張メソッド一覧。そう、最初感動したのは、ドット打ってIntelliSenseに並んだこのメソッド名を見て、なのよね。いかにも素晴らしいことが出来そうな予感だったという。</p>
<pre><code class="language-text">Aggregate
Amb
AsObservable
Catch
CombineLatest
Concat
Cons
Contains
Count
Create
Defer
Delay
Dispatch
Do
Empty
Finally
First
FirstOrDefault
Flatten
ForkJoin
FromEvent
Generate
GetEnumerator
HoldUntilChanged
Interval
Last
LastOrDefault
Latest
Let
LetRec
LongCount
Merge
MostRecent
Never
Next
Post
Range
Reify
Repeat
Retry
Return
Sample
Scan
Select
SelectMany
Send
Single
SingleOrDefault
Skip
SkipWhile
Spawn
Start
Subscribe
Synchronize
Take
TakeWhile
Throttle
Throw
Timeout
ToAsync
ToBehavior
ToEnumerable
ToObservable
ToSubject
Until
WaitUntil
Where
Zip
</code></pre>
<p>かなり多い。68個ある。名前から想像つくのもあれば全くつかないものも。順番はどうしようかな、LinqではGenerating, Projection and Filtering, Join, Set, Ordering, Grouping, Aggregate, Paging, Convertで分けられたので、何らかの指針でもって分けた方が良いのは間違いないのですが、実際に中を突っつかないと何が何なのか全く分からない。</p>
<pre><code class="language-csharp">Func&lt;Type, IEnumerable&lt;string&gt;&gt; GetMethodNames = 
    type =&gt; type
        .GetMethods(BindingFlags.Static|BindingFlags.Public)
        .Select(mi =&gt; mi.Name)
        .OrderBy(s =&gt; s)
        .Distinct();

var enumerable = GetMethodNames(typeof(Enumerable));
var observable = GetMethodNames(typeof(Observable));

observable.Except(enumerable).ToList().ForEach(Console.WriteLine);
</code></pre>
<p>メソッド名一覧はobservableのみを吐いたもので、上のコードはEnumerableとの差分も取ってみたものです。Enumerableと重複しないものは47個でした。そんなに被ってる、というわけではないですね……。ちなみに、Enumerableは50個。覚えきれているので、もっと少ないと思ってたんですが、意外と多かった。Linq to Objectsもきちんと理解して使えるようになるのに半年ぐらいかかってしまっているので、今回も長期戦かなー。ちんたらやってる間にドキュメントが出てくるのを期待したい。</p>
</div>
<h1><a href="https://neue.cc/2009/09/13_200.html">.NET Reactive Framework メソッド探訪第三回:Subscribe</a></h1>
<ul class="date"><li>2009-09-13</li></ul>
<div class="entry_body"><p>メソッド探訪とか言いながら、ちっとも探訪してません。今回までが基礎知識で、Linq to Objectsで言ったらイテレータがどうこう、という段階。次回以降はメソッドを見ていきたいと思います。では、最後の予習ということで、Subscribe。SubscribeはIObservable&lt;T&gt;連鎖の終点となるもので(但し、別にSubscribeだけが終点というわけではない、FirstとかCountとか、終点になるものは他にもあります)ForEachのようなもの。戻り値はIDisposableで、イベント発生の監視を止めたい時はDisposeを呼ぶ。と、第一回の時に書きましたので、今回は別の方向から見ていきます。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    Observable.Range(1, 10).Subscribe(Observer.Create(
        (int i) =&gt; Console.WriteLine(i), // OnNext
        e =&gt; { throw e; }, // OnError
        () =&gt; Console.WriteLine(&quot;Completed&quot;) // OnCompleted
    ));

    Console.ReadLine();
}
</code></pre>
<p>今回はコンソールアプリで。結果は想像つくとおり、1から10、最後にCompletedを表示。Observable.RangeはEnumerable.Rangeと同じです。というか中身的にはEnumerable.Range.ToObservableで変換されているだけです。RepeatとEmptyも用意されているので、ちょっとしたメソッド確認用に便利に使えると思います。それにしてもコード、ゴチャゴチャしてますねえ、わけわかんない書き方してわざと難解にやってるんじゃないだろうかって感じですが、その通りです、ので、普通の書き方も下の方でちゃんと書きます。で、SubscribeはIObservable&lt;T&gt;のメソッドとして定義されています。IEnumerable&lt;T&gt;がGetEnumeratorを持つように、IObservableはSubscribeを持つ。そして、原則Subscribeの引数はIObserver&lt;T&gt;です。</p>
<pre><code class="language-csharp">public interface IObservable&lt;T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}

public interface IObserver&lt;T&gt;
{
    void OnCompleted();
    void OnError(Exception exception);
    void OnNext(T value);
}
</code></pre>
<p>インターフェイスなので直接生成することは出来ない。よってファクトリメソッドObserver.Createを用いて生成します。生成されるのは前回見たAnonymousEnumeratorと同じくinternalのジェネリッククラス「AnonymousObserver&lt;T&gt;」で、インターフェイスの各メソッドにデリゲートを直接放り込むだけの単純明快なものです。勿論、IObservable&lt;T&gt;を継承して自前の専用のものを用意しても構いませんが、クロージャを活かせば、自前で定義する意味など少しもありません。コンパイラの自動生成クラス任せでOK。</p>
<p>これの動作はメソッド名通りで、OnNextは値が来るたびに実行されるメソッド。OnCompletedは全て完了した時(FromEvent経由のものなど、実質無限リピート状態の場合は、Disposeが呼ばれた時)に実行されるメソッド。OnErrorは例外が発生した時に実行されるメソッド。発生した例外は原則catchされるので、再スローしたい時は、そのまんまですがthrow eの明示が必要です。</p>
<p>……それにしても面倒くさい。Observer.Createは。onNextだけが書ければいいんだよ！ってシーンにわざわざ空の式を書けとでも？（ちなみに空は()=&gt;{}です) 大体がして、推論出来ないから(int i)だとか、型を書かなければならないのもかったるい。というわけで、拡張メソッドが用意されています。</p>
<pre><code class="language-csharp">public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError, Action onCompleted);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError, Action onCompleted);
</code></pre>
<p>いっぱいありますけど、ようするに無視した部分は空のメソッドが代わりに埋められる、というだけの話。これを使えば、最初の例は、onNextだけにすると</p>
<pre><code class="language-csharp">Observable.Range(1, 10).Subscribe(i =&gt; Console.WriteLine(i));
</code></pre>
<p>と、簡潔明快に記述出来るわけです。メデタシメデタシ。</p>
<h2>過去記事</h2>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">.NET Reactive Framework メソッド探訪第一回:FromEvent</a><br />
<a href="http://neue.cc/2009/09/07_198.html" title="neue cc - .NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></p>
</div>
<h1><a href="https://neue.cc/2009/09/09_199.html">無限リピートの幸福</a></h1>
<ul class="date"><li>2009-09-09</li></ul>
<div class="entry_body"><p>Reactive Frameworkが、結構に無限リピートな感じなので、関連してC# Linqで<a href="http://ja.doukaku.org/197/lang/csharp/">どう書くにあった13日金曜日問題</a>を今更書いてみた。n番煎じ。</p>
<pre><code class="language-csharp">// 今日から2013年12月31日までの、13日の金曜日とその総数を表示してください。
// 「今日」を無限リピートという方針で書いてみたりして(総数は省略)
// 利点はTodayを変数として外側に定義する必要が無くLinq内に閉じ込められる
// Toを求めるのに足したり引いたりする必要がなく自然に書ける、の二つかしらん
// 「まで」という問いに対してTakeWhileで解答するのは自然で良いと思う

Enumerable.Repeat(DateTime.Now, int.MaxValue)
    .Select((d, i) =&gt; d.AddDays(i))
    .TakeWhile(d =&gt; d.Year &lt; 2014)
    .Where(d =&gt; (d.DayOfWeek == DayOfWeek.Friday) &amp;&amp; (d.Day == 13))
    .ToList()
    .ForEach(d =&gt; Console.WriteLine(d.ToShortDateString()));
</code></pre>
<p>TakeWhileが好きです。問題文に対して、自然に解答出来るような気がするので。「今日から(Repeat)」「2013年12月31日までの(TakeWhile)」「13日の金曜日(Where)」。実に自然に記述できる。いやまあ、Repeatが直感的かというと結構微妙なところではありますが。Rangeでfrom,toのほうが自然だろ常識的に考えて、というのも確かなんですけど、Rangeだとtoを作るのに計算式が必要ってのが、ちょっと違うかな、と。</p>
<p><a href="http://en.wikipedia.org/wiki/Pizza_(programming_language)">Pizza (programming language)</a>のexampleにもあるような、Streamを始めとして何かを無限リピートしてTakeWhileで終了条件を設定、というのはパターンとして結構幅広く使える、と思う。ある種のデザインパターン。イディオムイディオム。参考リンクは<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">C# 3.0 と while(true) と Iterator - NyaRuRuの日記</a>この辺り。</p>
<p>例えばVS2010から搭載されるEnumerable.Zipや、あとCycleを定義してみる。</p>
<pre><code class="language-csharp">// この二つを混ぜ合わす(VS2010で搭載されるZip関数)
var seq1 = Enumerable.Range(1, 10);
var seq2 = Enumerable.Range(10, 10);
Enumerable.Repeat(new { e1 = seq1.GetEnumerator(), e2 = seq2.GetEnumerator() }, int.MaxValue)
    .TakeWhile(t =&gt; t.e1.MoveNext() &amp;&amp; t.e2.MoveNext())
    .Select(t =&gt; t.e1.Current + t.e2.Current); // ここがZipのSelectorの部分
// foo,bar,hoge,foo,bar,hogeを無限に繰り返す
var elements = new[] { &quot;foo&quot;, &quot;bar&quot;, &quot;hoge&quot; };
var cycle = Enumerable.Repeat(elements, int.MaxValue).SelectMany(ar =&gt; ar);
</code></pre>
<p>Linqのお陰でかつてない勢いでint.MaxValueを使っているこの頃。Repeatも万能ですねえ。いやまあ、もう素直にAchiral使えよって話なんですが、標準メソッドのみで粘るのも面白くて。そういえばでついでなので<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>でもやってみた。</p>
<pre><code class="language-javascript">// JavaScriptはAddDaysがないので副作用全開でTodayを
// setHours(24)で翌日にしてしまう、という方針でやってみた

E.Repeat(new Date())
 .Do(&quot;$.setHours(24)&quot;)
 .TakeWhile(&quot;$.getFullYear() &lt; 2014&quot;)
 .Where(&quot;$.getDay() == 5 &amp;&amp; $.getDate() == 13&quot;)
 .ForEach(&quot;alert($)&quot;);
</code></pre>
<p>DoはReactive Frameworkにもありました。副作用を加えた上で素通しするメソッド。副作用は嫌なものです。汚いです。何が嫌かというと、動作を考えるのに見る範囲を広げなきゃいかんところかなあ。そしてLinqの何がいいかというと、見る範囲が物凄く限定される(ラムダ式一文だけを見ればいい)と思っている。だからLinq内でクロージャ(というか外部の変数をキャプチャして使う)もあんま好ましくないし、C#クエリ構文のletも好きじゃない。なるべくなら使いたくない。長文耐性なのは分かるけれど、カッコやインデントがなくてスマートだけれど、その分だけスコープが不明瞭になるという側面が否めない。まあ、letが必要なシチュエーションをSelectManyでやると、大抵はもっと奇怪になるのですけど。</p>
<p>んでまあ、この場合だとAddDaysのかわりにnew Date(year,month,day)で新しいのを作れば副作用なくSelectが使えるわけですが、ありきたりで面白くないと思ったので別な方向に走ってみた。というか、無限リピートは、無限リピートする何かに対して副作用全開で操作を加え続ける、という形の方が面白いというか実用的というか普通だとは思う。冒頭の例みたいなやつだと、別にRangeでよくね？って感じですし。Haskellじゃないんだから、潔癖症にならずに、副作用といかに楽しくお付き合いするかが大事なのですかね。</p>
<p>あ、ちなみに$は引数が一つの場合の省略記法です。こういった機能は<a href="http://ja.wikipedia.org/wiki/Scala">Scala</a>にもある。引数が一つのみの場合が大半なので、記述がグッと縮まるし、何よりも引数名を付ける必要がないのが嬉しい。C#でも使えるようになると嬉しいなあ、とずっと思ってるんですが中々どうして無理なんですかねえ、残念。</p>
</div>
<h1><a href="https://neue.cc/2009/09/07_198.html">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></h1>
<ul class="date"><li>2009-09-07</li></ul>
<div class="entry_body"><p>予定は常に変更されるもの、というわけで、今回はAnonymousEnumerableとAnonymousEnumeratorを見たいと思います。表に出てこない、internalのクラスな上に、内部でも全然使われていないので、見る必要はあんまりない。のですが、これと対になるAnonymousObservableとAnonymousObserverを見るにあたって、先に慣れ親しんだIEnumerable/Enumeratorで考えたほうが分かりやすかったので、これを先に考えます。</p>
<pre><code class="language-csharp">class AnonymousEnumerable&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator;
    public AnonymousEnumerable(Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator)
    {
        // 以下略
}

class AnonymousEnumerator&lt;T&gt; : IEnumerator&lt;T&gt;
{
    private Func&lt;T&gt; current;
    private Action dispose;
    private Func&lt;bool&gt; moveNext;

    public AnonymousEnumerator(Func&lt;bool&gt; moveNext, Func&lt;T&gt; current, Action dispose)
    {
        this.moveNext = moveNext;
        this.current = current;
        this.dispose = dispose;
    }

    public T Current
    {
        get { return this.current(); }
    }

    public bool MoveNext()
    {
        return this.moveNext();
    }
    
    // 以下略
}
</code></pre>
<p>Reflectorで見ちゃってるので、一部だけ(ライセンス！)。ただ、どれも一行なので見るまでもなく何をやってるのか想像付くと思います。 お馴染みのインターフェイスを実装しているだけですが、その実装を全てコンストラクタで受ける関数に任せています。ようするにこれはどういうことなのかというと、実例としてEnumerable.RepeatとSelectをAnonymousEnumerableで実装してみるとこうなります。</p>
<pre><code class="language-csharp">public static class Enumerable
{
    public static IEnumerable&lt;T&gt; Repeat&lt;T&gt;(T element, int count)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var index = 0;
            var current = default(T);
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; // MoveNext
                {
                    if (index == 0) current = element;
                    return (index++ &lt; count);
                },
                () =&gt; current, // Current
                () =&gt; { } // Dispose
            );
        });
    }
    
    // 実際のSelectは&lt;TSource,TResult&gt;ですが、都合により略
    public static IEnumerable&lt;T&gt; Select&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, T&gt; selector)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var enumerator = source.GetEnumerator();
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; enumerator.MoveNext(),
                () =&gt; selector(enumerator.Current),
                () =&gt; enumerator.Dispose()
            );
        });
    }
}
</code></pre>
<p>勿論、普通はyieldを使えばいいわけですが、もしyieldがなければ、こういう形で実装するのが簡潔でベスト、に見える。クロージャでコンパイラにクラス生成を任せているわけですねー。外部イテレータですが、外部のクラスに分割せず中に書けるため、すっきり分かりやすい。この発想はあったけどC#でやるという発想はなかったわ、というわけで結構感動しました。</p>
<p>そうそう、この仕組みは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>と丸っきり同じなのです。感動ってのは、私の基本方針は間違ってなかったんだ！の裏付けでの喜びなので不純です。そのJavaScriptでの実装はこんな感じ。</p>
<pre><code class="language-javascript">Linq.Object = function(getEnumerator)
{
    this.GetEnumerator = getEnumerator;
}

Linq.Enumerator = function(moveNext)
{
    this.Current = null;
    this.MoveNext = moveNext;
}

Repeat: function(element, count)
{
    return new Linq.Object(function()
    {
        var index = 0;
        return new Linq.Enumerator(function()
        {
            if (this.Current == null) this.Current = element;
            return (index++ &lt; count);
        });
    });
}

Select: function(selector)
{
    var source = this;
    selector = Linq.Utils.CreateFunctor(selector);

    return new Linq.Object(function()
    {
        var enumerator = source.GetEnumerator();
        var index = 0;

        return new Linq.Enumerator(function()
        {
            if (enumerator.MoveNext())
            {
                this.Current = selector(enumerator.Current, index++);
                return true;
            }
            else
            {
                return false;
            }
        });
    });
}
</code></pre>
<p>スコープが若干違うかなって感じですが、大体同じです。(Linq.ObjectはLinq.Enumerableに名前変えよう……)。JavaScriptだからこそ、yieldがなくてもスッキリ定義出来る！と思っていただけに、そっかあ、そういう手を使えば良かったのかと少しショックだったりして。ほんとC#は柔軟な言語で、むしろもうJavaScriptよりもLightWeightだよ！</p>
<p>さて、次回はAnonymousObservableとAnonymousObserverを見てみることにします。勿論、予定は未定です。ていうかSubscribeはどうした、というと、Subscribeの中身はAnonymousObserverなので全然横道にそれてません、大丈夫です、まだ一直線です。</p>
</div>
<h1><a href="https://neue.cc/2009/09/04_197.html">.NET Reactive Framework メソッド探訪第一回:FromEvent</a></h1>
<ul class="date"><li>2009-09-04</li></ul>
<div class="entry_body"><p>まず、リアクティブフレームワークとは何ぞや、ということなのですが今のところ<a href="http://www.infoq.com/jp/news/2009/07/Reactive-Framework-LINQ-Events">InfoQ: .NETリアクティブフレームワーク（Rx）がLINQ to Eventsを可能にする</a>の記事ぐらいしか情報はありません。.NET 4.0に含まれる(かもしれない)ということ、現在のところSilverlight Toolkitの単体テストのところにこっそりと配置されていること。それだけです。紹介も、記事中にもリンクされていますが<a href="http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html">unfold: Introducing Rx (Linq to Events)</a>の一連の記事ぐらいしかありません。これの前文が中々に素敵です。</p>
<blockquote>
<p>Buried deep in the bin folder of the Silverlight Toolkit Unit Tests is a hidden gem: The Rx Framework (System.Reactive.dll).  If you glanced quickly you’d miss it altogether but it’s one of the most exciting additions to the .NET framework since Linq.</p>
</blockquote>
<p>今のところ微妙にパッとしない(Parallelは簡単に使えるがゆえにインパクトが足らない)4.0の隠し玉はコレですね、間違いない。軽く触ってみたのですが、中々に感動的。Linq to Objects好きならば間違いなく琴線に触れます。C#3.0がコレクションの操作をforeachからLinqに変えてしまったように、.NET4.0はイベントもLinqに変わる。まさにLinq to Everywhere! Functional Reactive Programming!</p>
<h2>How to use</h2>
<p><a href="http://www.codeplex.com/Silverlight">Silverlight Toolkit</a>をダウンロードしてSource/Binaries/System.Reactive.dllを頂けば完了。ただし、これはそのままだとSilverlightのプロジェクトでしか動作しないので、その他ので利用したい場合は<a href="http://evain.net/blog/articles/2009/07/30/rebasing-system-reactive-to-the-net-clr">ここの記事</a>に示されているように、githubに公開されているコードを実行(Cecilのdllが必要、記事文中にリンクされています)して変換する必要があります。今回はとりあえず、Silverlightで試してみたいと思います。こちらはこちらで、<a href="http://www.microsoft.com/downloads/details.aspx?displaylang=ja&amp;FamilyID=9442b0f2-7465-417a-88f3-5e7b5409e9dd">Silverlight 3 Tools</a>のダウンロードが必要ですけれど。</p>
<h2>実例</h2>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication4.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>マウスの動きに円が追随する、という単純なものをSilverlightで作ってみました。移動は完全に追随するのではなく、座標が15で割り切れる位置の場合のみ移動としました。スナップすることをイメージしたつもりなのですが、動きがガクガクです。これは、マウス移動に完全に追随して全ての座標でイベントが発生するわけではない = 15で割り切れる座標を通過してもイベントが発生しない場合がある = 動きがガクガク。というわけで、スナップしたい場合はWhereで間引くのではなく、Selectで近傍座標に寄せるべきです、が、いやまあ、例なので……。</p>
<pre><code class="language-csharp">// XAMLではなく全部コード上に書いたのは両方を張るのが面倒だから……
// 内容はCanvasとEllipseを配置するというもので、本筋とは関係ありません
InitializeComponent();
var canvas = new Canvas { Background = new SolidColorBrush(new Color {A=255, R = 100, G = 100, B = 100 }) };
var ellipse = new Ellipse { Height = 30, Width = 30, Fill = new SolidColorBrush(Colors.Orange) };
canvas.Children.Add(ellipse);
this.Content = canvas;

// FromEventはイベント発火がトリガとなってLinq発動
// 後段に送られるのはEvent&lt;T&gt;というもので、
// SenderとEventArgsという読み取り専用プロパティを持つクラス
var canvasMove = Observable.FromEvent&lt;MouseEventArgs&gt;(canvas, &quot;MouseMove&quot;)
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Where(p =&gt; (p.X % 15 == 0) || (p.Y % 15 == 0))
    .Subscribe(p =&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    });

// Subscribeの戻り値の型はIDisposable
// Disposeを呼ぶと登録したイベントをデタッチすることが出来る
// デタッチしないなら取得する必要は特にはない
// canvasMove.Dispose();
</code></pre>
<p>MouseMoveでイベントが発火する度にLinqを通る。なるほど、イベントがリストに、見える。イベントを無限リスト生成として捉えることで、イベントに対してLinq操作が可能になった。ObserverパターンとIteratorパターンは同じだったんだよ！なんだってー！みたいなノリがある。もう少し丁寧に見ると、Observable.FromEventでイベントをPush型の無限リストに変換。戻り値はIObservable&lt;T&gt;。イベント発火時に後段に流れてくるのはEvent&lt;T&gt;。これは通常のイベント登録時に使うsenderとeventArgsをラップしただけの単純なもの。あとはIObservableに用意されているメソッド(Select, Where, TakeWhileなどお馴染みのものから、Delay, WaitUntilなどイベント用の目新しいメソッドなど多数)を繋げて、最後にSubscribe。このSubscribeは、つまり通常のイベント登録時のメソッド本文の役割を果たす。Linqで言ったらForEachのようなもの。Subscribeのオーバーロードも幾つかあるのですが、それはまた後日。</p>
<pre><code class="language-csharp">// つまるところ、以下のコードと同じだったりはする
// ただ、IObservable&lt;T&gt;は通常のイベント登録では無理な複雑な操作が簡単、
// そして何よりも、このような単純なコードでもそんなに複雑になっていない！
canvas.MouseMove += (sender, e) =&gt;
{
    var pos = e.GetPosition(canvas); // Select
    if (!(pos.X % 15 == 0 || pos.Y % 15 == 0)) return; // Where
    ellipse.SetValue(Canvas.LeftProperty, pos.X - ellipse.Width / 2);
    ellipse.SetValue(Canvas.TopProperty, pos.Y - ellipse.Height / 2);
};
</code></pre>
<p>通常のイベント登録と対比してみると分かりやすいかしらん。FromEventではMouseEventArgsという型を明示する必要があるのがカッタルイ。推論は偉大。が、しかし、IObservableが複雑な操作が可能なのに対し、イベントに追加では直球なものしか書けない。また、複雑な操作が可能なわりには、FromEventは驚くほどシンプルに書ける。シンプルな操作でも(記述するのに)重たくない、というのは特筆すべきことじゃあないでしょうか。</p>
<pre><code class="language-csharp">// stringを避けたこういう登録方法もあるけれど、面倒なうえに警告出る
Observable.FromEvent((EventHandler&lt;MouseEventArgs&gt; h) =&gt; new MouseEventHandler(h),
        h =&gt; canvas.MouseMove += h, // addHandler
        h =&gt; canvas.MouseMove -= h) // removeHandler
    .Subscribe(e =&gt; Debug.WriteLine(e.EventArgs.GetPosition(canvas)));
</code></pre>
<p>ところで、イベント名をstringで書くのはどうよ、ていうかJavaScriptのaddEventHandlerみたいで嫌だよね？ね？リファクタリング効かないわ、IntelliSenseも動かないわでロクなことがない。というわけで、FromEventのオーバーロードを見ると、ちゃんと普通に登録する方法も用意されてはいる。一応、用意、されては、いる。が、しかし、あんまりだー。あんまりすぎるー。流れてくるEventhandler&lt;MouseEventArgs&gt;をMouseMoveが受け取ってくれないので、第一引数でMouseEventHandlerに変換する(ところで警告が消せないのですが、警告無しで処理する方法ってあるのかしらん)。あとは、addとremoveの登録。長ったらすぎてこれはダメぽ。確かに、こんなんなら、stringでいいです……。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication3.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre><code class="language-csharp">// 普段あまり書かないMouseEventArgsとかいう型定義は書きにくいし
// メソッド名もstringで書くのはミスが出がち、ということで
// 拡張メソッドでイベント取り出し用のメソッドを予め作っておくと良い
public static IObservable&lt;Event&lt;MouseEventArgs&gt;&gt; GetMouseMove(this UIElement elem)
{
    return Observable.FromEvent&lt;MouseEventArgs&gt;(elem, &quot;MouseMove&quot;);
}

// マウスの軌跡を1秒後に描画します
canvas.GetMouseMove()
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Delay(1000)
    .Subscribe(p =&gt;Dispatcher.BeginInvoke(()=&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    }));
</code></pre>
<p>汚い部分は隔離！ということで、拡張メソッドに退避してやると、美しく書ける。いやまあ、この辺は全部<a href="http://themechanicalbride.blogspot.com/2009/07/developing-with-rx-part-1-extension.html">unfold: The Joy of Rx: Extension Events</a>に書いてあることなのですけど。んで、デモ的にもう少し面白げがあったほうがいいかな、と思ったのでDelayを足してみました。1秒後にマウス移動の軌跡を描画します。グルグルーっとマウス動かして止めてみてください。スムーズ、とは言い難いですね、しょんぼり。記述も、Delayを足すだけ。と言いたかったんですがBeginInvokeかあ、これどーにかなる方法ないかなあ。</p>
<h2>次回</h2>
<p>全10回ぐらいで、全部のメソッドを紹介するつもりです。私が理解できればの話ですが。ちょこちょこと実例的なものも交えていきたいと思います。私が使いこなせればの話ですが。というわけで、次回はSubscribeのオーバーロードの紹介にしたいと思います。Reactive Frameworkならではの魅力、に関してはもう少し先になってしまいそう。少し飛ばして、非同期連結の話なんかを先に持ってきた方が良いかなあ。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul><li>Index: <a href="https://neue.cc">neue.cc</a><li></ul></div>
    </div>
</body>
