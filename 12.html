<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2013-07-10" data-pagefind-meta="published:2013-07-10"><a href="https://neue.cc/2013/07/10_414.html">C#で扱うRedisのLuaスクリプティング</a></h1>
<ul class="date"><li>2013-07-10</li></ul>
<div class="entry_body"><p>Redis 2.6からLuaスクリプティングが使えるようになりました。コマンドは<a href="http://redis.io/commands/eval">EVAL</a>です。というわけでC#のRedisライブラリ、<a href="https://code.google.com/p/booksleeve/">BookSleeve</a>で、試してみましょう。RedisやBookSleeveに関しては、以前に私がBuildInsiderで書いた<a href="http://www.buildinsider.net/small/rediscshap/01">C#のRedisライブラリ「BookSleeve」の利用法</a>を参照ください。</p>
<p>BookSleeveは当然NuGet経由で入れるとして、Windows版のRedisバイナリもNuGetで配布されています。手軽に試してみるなら、<a href="https://nuget.org/packages/Redis-64/">Install-Package Redis-64</a>が良いのではないでしょーか。現在の最新は2.6.12.1ということで、Evalにも対応しています。インストールするとpackages\Redis-64.2.6.12.1\toolsにredis-server.exeが転がっているので、それを起動すれば、とりあえず127.0.0.1:6379で動きます。</p>
<h2>多重アクセスの検出</h2>
<p>HelloWorld!ということで、多重アクセス検知のスクリプトでも書いてみます。ルールとしては、X秒以内にY回アクセスしてきた人間はZ秒アク禁にする。という感じですね。DOSアタック対策的な。LUAスクリプティングを使わないと、キーを2つ用意したりしなけりゃいけなかったり複数コマンド打ったりしたりとか、若干面倒だったり効率悪いのですが、スクリプティング使えば一発で済ませられます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">    public static class RedisExtensions
    {
        public static async Task&lt;bool&gt; DetectAttack(this RedisConnection redis, int db, string key, int limitCount = 10, int durationSecond = 1, int bannedSecond = 300)
        {
            var result = await redis.Scripting.Eval(db, @&quot;
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local count = redis.call('incr', key)
if(count &gt;= limit) then
    local banSec = tonumber(ARGV[3])
    redis.call('EXPIRE', key, banSec)
    return true
else
    local expireSec = tonumber(ARGV[2])
    redis.call('EXPIRE', key, expireSec)
    return false
end&quot;, new[] { key }, new object[] { limitCount, durationSecond, bannedSecond }).ConfigureAwait(false);

            // Lua-&gt;Redisはtrueの時に1を、falseの時にnullを返す
            return (result == null) ? false
                : ((long)result == 1) ? true
                : false;
        }
    }
</code></pre>
<p>こんな感じですね。基本的にはEvalメソッドでスクリプトを渡すだけです、あとKEYS配列とARGV配列を必要ならば。戻り値の扱いなどに若干のクセがありますので、その辺はRedisのEVALのドキュメントを読んでおくといいでしょう。</p>
<p>スクリプトは、まずincrを呼んでカウントを取る。そのカウントが指定数を超えてたらExpireの時間をBanの時間（デフォは300秒=5分）引き伸ばす。超えてなければ、Expireの時間を指定間隔(デフォは1秒)だけ伸ばす。もし1秒以内に連続でアクセスがあれば、Incrのカウントが増えていく。1秒以上経過すればExpireされているので、countは0スタートになる。といった感じです。</p>
<p>利用する場合はこんな具合。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var redis = new RedisConnection(&quot;127.0.0.1&quot;);
await redis.Open();

var v = await redis.DetectAttack(0, &quot;hogehoge&quot;);
Console.WriteLine(v); // false

for (int i = 0; i &lt; 15; i++)
{
    var v2 = await redis.DetectAttack(0, &quot;hogehoge&quot;);
    Console.WriteLine(v2); // false,false,...,true,true
}
</code></pre>
<p>いい具合ですにぇ？</p>
<h2>EVALSHA</h2>
<p>BookSleeveのEvalは、正確には<a href="http://redis.io/commands/evalsha">EVALSHA</a>です（更に正しくはデフォルトの、引数のuseCacheがtrueの場合）。</p>
<p>EVALSHAは、事前にスクリプトのSHA1を算出し、初回に登録しておくことで、コマンドの転送をSHA1の転送だけで済ませます。スクリプトを毎回投げていたらコマンド転送に時間がかかるので、それの節約です。この辺をBookSleeveは何も意識しなくても、やってくれるのが非常に楽ちん。素晴らしい。</p>
<h2>Increment/DecrementLimit</h2>
<p>せっかくなので、もう一つ例を。RedisのIncrementやDecrementはアトミックな操作で非常に使いやすいのですが、上限や下限を設けたい場合があります。例えば、HPは0以下になって欲しくないし、最大HPを超えて回復されても困る、みたいな。それも当然、Luaスクリプティングを使えば簡単に実現可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">        public static async Task&lt;long&gt; IncrementWithLimit(this RedisConnection redis, int db, string key, long value, long maxLimit)
        {
            var result = await redis.Scripting.Eval(db, @&quot;
local inc = tonumber(ARGV[1])
local max = tonumber(ARGV[2])
local x = redis.call('incrby', KEYS[1], inc)
if(x &gt; max) then
    redis.call('set', KEYS[1], max)
    x = max
end
return x&quot;, new[] { key }, new object[] { value, maxLimit }).ConfigureAwait(false);
            return (long)result;
        }
</code></pre>
<p>incrbyの結果が指定の値を超えていたら、setで固定する、といった感じです、単純単純。使うときはこんな具合。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var redis = new RedisConnection(&quot;127.0.0.1&quot;);
await redis.Open();

var v1 = await redis.IncrementWithLimit(0, &quot;hoge&quot;, 40, maxLimit: 100);
var v2 = await redis.IncrementWithLimit(0, &quot;hoge&quot;, 40, maxLimit: 100);
var v3 = await redis.IncrementWithLimit(0, &quot;hoge&quot;, 40, maxLimit: 100);

// 40-&gt;80-&gt;100
Console.WriteLine(v1 + &quot;-&gt;&quot; + v2 + &quot;-&gt;&quot; + v3);
</code></pre>
<p>楽ちん、これは捗る。</p>
<h2>まとめ</h2>
<p>というわけで、RedisいいよRedis。いやほんと色々な面で使ってて嬉しいことが多いです。RDBMSだけで頑張ると非常に辛ぽよ、Redisがあるだけで何かと楽になれますので、一家に一台は置いておきたい。</p>
<p>Luaスクリプティングは複数コマンド間で戻り値が扱えるため、利用範囲がグッと広がります。そしてスクリプティング中の動作もまたアトミックである、というのが嬉しい点です（C#コード上で複数コマンドを扱うと、そこの保証がないというのが大きな違い）。と同時に注意しなければならないのは、アトミックなので、スクリプト実行中は完全にブロックされてます。ので、あまりヘヴィなことをLuaスクリプティングでやるのは避けたほうがいいのではないかなー、と思われます。</p>
</div>
<h1 data-pagefind-sort="date:2013-07-02" data-pagefind-meta="published:2013-07-02"><a href="https://neue.cc/2013/07/02_412.html">asyncの落とし穴Part2, SynchronizationContextの向こう側</a></h1>
<ul class="date"><li>2013-07-02</li></ul>
<div class="entry_body"><p>非同期QUIZの時間がやってきました！前回はデッドロックについてでしたが、今回はヌルポについて扱いましょう。まずは以下のコードの何が問題なのかを当ててください。ASP.NET MVCです。あ、.NET 4.5ね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class HomeController : Controller
{
    async Task DoAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(3));
    }

    public ActionResult Index()
    {
        DoAsync();
        return View();
    }
}
</code></pre>
<p>どこがダメで、どうすれば改善されるのかはすぐ分かると思います。「なにが起こるのか」「なぜ起こるのか」について、考えてみてください。おわり。</p>
<p>さて、で、Ctrl+F5で実行すると、このコードは何の問題もなくふとぅーに動きます。一見何の問題もない。実際何の問題もない。オシマイ。</p>
<p>というのもアレなので、何が起こっているのか観測します。まず、Global.asax.csに以下のコードを。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">protected void Application_Start()
{
    // ルーターの登録とか標準のものがこの辺に

    Trace.Listeners.Add(new TextWriterTraceListener(@&quot;D:\log.txt&quot;));
    Trace.AutoFlush = true;

    System.Threading.Tasks.TaskScheduler.UnobservedTaskException += (sender, e) =&gt;
    {
        Trace.WriteLine(e.Exception);
    };
}
</code></pre>
<p>で、本体はこんな風に。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class HomeController : Controller
{
    async Task DoAsync()
    {
        Trace.WriteLine(&quot;start&quot;); // 何か開始処理があるのだとする

        await Task.Delay(TimeSpan.FromSeconds(3)); // 何か非同期処理してるとする

        Trace.WriteLine(&quot;end&quot;); // 何か後処理があるのだとする
    }

    public ActionResult Index()
    {
        GC.Collect(); // GC自然発生待ちダルいので発動しちゃう

        var _ = DoAsync(); // 非同期処理を&quot;待たない&quot;
        return View();
    }
}
</code></pre>
<p>D:\log.txtは、まぁどこに吐いてもいいんですが、ちゃんと書き込み権限があるところに。んでは、実行しましょう。log.txtは、初回はまず、「start」と書かれます。つまり、endまで到達してないことが確認できます。二回目のアクセスではGC.Collectが走り、それによりUnobservedTaskExceptionが実行されます。で、log.txtには以下のものが書き込まれます。</p>
<pre data-pagefind-ignore="all"><code class="language-text">System.AggregateException: タスクの例外が、タスクの待機によっても、タスクの Exception プロパティへのアクセスによっても監視されませんでした。その結果、監視されていない例外がファイナライザー スレッドによって再スローされました。 ---&gt; System.NullReferenceException: オブジェクト参照がオブジェクト インスタンスに設定されていません。
   場所 System.Web.ThreadContext.AssociateWithCurrentThread(Boolean setImpersonationContext)
   場所 System.Web.HttpApplication.OnThreadEnterPrivate(Boolean setImpersonationContext)
   場所 System.Web.HttpApplication.System.Web.Util.ISyncContext.Enter()
   場所 System.Web.Util.SynchronizationHelper.SafeWrapCallback(Action action)
   場所 System.Web.Util.SynchronizationHelper.&lt;&gt;c__DisplayClass9.&lt;QueueAsynchronous&gt;b__7(Task _)
   場所 System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()
   場所 System.Threading.Tasks.Task.Execute()
   --- 内部例外スタック トレースの終わり ---
---&gt; (内部例外 #0) System.NullReferenceException: オブジェクト参照がオブジェクト インスタンスに設定されていません。
   場所 System.Web.ThreadContext.AssociateWithCurrentThread(Boolean setImpersonationContext)
   場所 System.Web.HttpApplication.OnThreadEnterPrivate(Boolean setImpersonationContext)
   場所 System.Web.HttpApplication.System.Web.Util.ISyncContext.Enter()
   場所 System.Web.Util.SynchronizationHelper.SafeWrapCallback(Action action)
   場所 System.Web.Util.SynchronizationHelper.&lt;&gt;c__DisplayClass9.&lt;QueueAsynchronous&gt;b__7(Task _)
   場所 System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()
   場所 System.Threading.Tasks.Task.Execute()&lt;---
</code></pre>
<p>おぅ！例外が発生していた！ぬるり！ぬるり！</p>
<p>GC.Collectを実行している理由は、Taskに溜まった未処理例外は、GCが走ったタイミングでUnobservedTaskExceptionに渡されるので、それを待つ時間を短縮しているだけです。GC.Collectを明示的に実行しなくても、長く動かしてればそのうち発生します。</p>
<p>というわけで、何が起こるのか、というと、await Task.Delayのところでヌルリが発生します。↑の例外情報からは、どこで発生していたのかの情報が一切出てこないので(さすがにこれなんとかして欲しいですけどねぇ……)、いざ発生するとなると場所を突き止めるのに割と苦労します、というか虱潰ししかないので結構大変です。そもそもUnobservedTaskExceptionをモニタしてなければ、発生していたことにすら気づけません。</p>
<p>なぜ起こるのか、というと、awaitによってPOSTする先のContextが消滅しているからです。非同期処理を待たなかったことによって、Viewの表示まで全て完了してContextが消滅する。その後で、DoAsync内のawaitが完了し、続行しようとPOSTを開始する、と、しかしContextは消滅していてなにもなーい。ので、ぬるり。</p>
<p>では、解決方法は、というと、例によってasyncで統一するか</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class HomeController : Controller
{
    async Task DoAsync()
    {
        Trace.WriteLine(&quot;start&quot;); // 何か開始処理があるのだとする

        await Task.Delay(TimeSpan.FromSeconds(3)); // 何か非同期処理してるとする

        Trace.WriteLine(&quot;end&quot;); // 何か後処理があるのだとする
    }

    public async Task&lt;ActionResult&gt; Index()
    {
        GC.Collect();

        await DoAsync(); // awaitする
        return View();
    }
}
</code></pre>
<p>もしくはConfigureAwait(false)でContextを維持しないこと。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class HomeController : Controller
{
    async Task DoAsync()
    {
        Trace.WriteLine(&quot;start&quot;); // 何か開始処理があるのだとする

        await Task.Delay(TimeSpan.FromSeconds(3)).ConfigureAwait(false); // ConfigureAwait(false)する

        Trace.WriteLine(&quot;end&quot;); // 何か後処理があるのだとする
    }

    public ActionResult Index()
    {
        GC.Collect();

        var _ = DoAsync(); // 非同期処理を&quot;待たない&quot;
        return View();
    }
}
</code></pre>
<p>です。</p>
<p>そもそも、何故非同期処理を&quot;待たない&quot;のか。例えば、アクセスログを取るために記録するだけだとか、別に完了を待つ必要がないものだったりするなら、待たないことでレスポンスは速くなる。待つ必要ないのなら、待たなくてもいいぢゃない。それはそうです。</p>
<p>なので、待たないなら待たないでいいのですが、中身について用心しないと、ヌルりで死んでしまいます。これは、同期的に待つ時もそうですね。待つなら待つでいいですけれど、中身について用心しないと、デッドロックで死んでしまいます。待っても死亡、待たなくても死亡、ホント非同期は地獄だぜ！</p>
<p>まあ、変数で受けたりしない限りは警告は出してくれますので（ウザいと思っていたアナタ！実に有益な警告ではないですか！）、不注意による死亡はある程度は避けられはします。</p>
<h2>.NET 4.0 vs .NET 4.5</h2>
<p>.NET 4.5だと、↑のような挙動ですが、.NET 4.0だとちょっと事情が違ったりします。async/awaitは利用したままで、ターゲットフレームワークのバージョンだけ4.0にしましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;system.web&gt;
    &lt;httpRuntime targetFramework=&quot;4.0&quot; /&gt;
    &lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.0&quot; /&gt;
&lt;/system.web&gt;
</code></pre>
<p>で、Ctrl+F5で実行して、何度かブラウザをリロードしましょう。死んでます。IIS Expressが。完全に無反応になります。何故？Windowsのイベントビューアーを見ましょう。</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/2013/07/eventview_appeeror.jpg' />
</p>
<p>ハンドルされない例外のため、プロセスが中止されました。というわけで、未処理例外が突き抜けてアプリケーションエラーとして記録されていくためです。プロダクション環境でもIISの<a href="http://www.atmarkit.co.jp/fwin2k/dnsvrguide/iis02/iis2.html">ラピッドフェール保護</a>が発動して、デフォルトでは5分以内に5エラーでアプリケーションは停止します。これは実にクリティカル。</p>
<p>なんで.NET 4.0と4.5で挙動が違うのか、というと、Taskの未処理例外の扱いが4.0と4.5で変わったためです。この辺はPfxTeamの<a href="http://blogs.msdn.com/b/pfxteam/archive/2011/09/28/10217876.aspx">Task Exception Handling in .NET 4.5</a>を参照にどーぞ。4.5のほうが安全っちゃー安全ですね。いずれにせよ、UnobservedTaskExceptionの例外ロギングは欠かさずやっておきましょう。</p>
<h2>まとめ</h2>
<p>非同期もいいんですけど、実際にマジでフルに使い出すと結構なんだかんだでハマりどころは多いですねぇ。幸い、デバッガビリティに関しては<a href="http://blogs.msdn.com/b/dotnet/archive/2013/06/26/announcing-the-net-framework-4-5-1-preview.aspx">Windows 8.1 + Visual Studio 2013である程度改善</a>するようで、待ち遠しいです。とはいえデッドロックだったりコンテキスト場外でヌルりだとかは、注意するしかない。</p>
<p>ASP.NET MVCのフィルターはやく非同期に対応してくださいー。ASP.NET MVC 5でも予定に入ってないようでどうなってんだゴルァ。Resultで待つしかなくて非常にヒヤヒヤします。EF6も非同期対応とか、そもそもMVC 5では.NET 4.5からのみだとか、どんどん非同期使われてくにつれ、死亡率も間違いなく上がってきますにゃ。</p>
</div>
<h1 data-pagefind-sort="date:2013-06-30" data-pagefind-meta="published:2013-06-30"><a href="https://neue.cc/2013/06/30_411.html">Micro-ORMとテーブルのクラス定義自動生成について</a></h1>
<ul class="date"><li>2013-06-30</li></ul>
<div class="entry_body"><p>謎社のデータアクセスは<a href="http://neue.cc/2012/12/11_390.html">Micro-ORM</a>でやっています。生SQL書いて、シンプルなPOCOにマッピングするだけの。ですが、そこで困るのはPOCOの作成。データベースの写しなだけのクラスですが、手で作るには、ひじょーに面倒。Entity Frameworkならドラッグアンドドロップで！DataSetですらホイホイと作れるのに、100%手作業とか嫌だよー、200テーブルを延々とクラス作るだけの刺身たんぽぽなんてしてたら死んじゃうよー。</p>
<p>というわけで、Micro-ORM使うなら避けては通れない定義。EFのクラス定義だけ流用しちゃうとか色々と逃げ道も考えられなくもないですが、もしくは数によっては手動で頑張ってしまうのも手ですが、ここは自動生成しましょうの会。</p>
<h2>GetSchema</h2>
<p>普通にSQLのクエリを書いてデータベースの情報を取ってくることも可能ですが、各データベースでそれぞれバラバラだったりするので、ここはADO.NETで用意されている<a href="http://msdn.microsoft.com/ja-jp/library/kcax58fh.aspx">GetSchema</a>を使いましょう。情報取得の部分が抽象化されていて、型無しDataTableとして受け取ることが可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var conn = new MySqlConnection(&quot;接続文字列。MySQLでもなんでもいいよ。&quot;))
{
    conn.Open();

    var schema = conn.GetSchema();
}
</code></pre>
<p>さて、schemaとやらをデバッガで見てみるとですね……</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/dt_table_rows.jpg" />
</p>
<p>うおおお、これがDataTableか！な、なんだ、このデバッガビリティの低さは……。これはヤヴァい。マジキチ。RowsのKeyを辿るのも苦労するうえに、Valueが一覧で見れない。頑張ってもKeyだけ。なんだこりゃ。データの取得もLINQ to DataSet(笑)によって、普通に実に扱いづらい。話にならない。 クソが。というわけで、今時ならば型無しDataTableはdynamicで扱ったほうが楽です。ExpandoObjectに変換しましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class DataTableExtensions
{
    /// &lt;summary&gt;DataTableの各RowをExpandoObjectに変換します。&lt;/summary&gt;
    public static IEnumerable&lt;dynamic&gt; AsDynamic(this DataTable table)
    {
        return table.AsEnumerable().Select(x =&gt;
        {
            IDictionary&lt;string, object&gt; dict = new ExpandoObject();
            foreach (DataColumn column in x.Table.Columns)
            {
                var value = x[column];
                if (value is System.DBNull) value = null;
                dict.Add(column.ColumnName, value);
            }
            return (dynamic)dict;
        });
    }
}
</code></pre>
<p>こんなものを用意すると、 var schema = conn.GetSchema().AsDynamic() とするだけで</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/dt_dynamic_view.jpg">
</p>
<p>うおおおおおおお、超捗る！ちゃんと動的ビューでKeyとValueが見える！ExpandoObjectありがとう。DataTableは死ね。また、DBNullをフツーのnullに変換したりなどもしているので、データを触るのもかなり捗るといったところもあります。item.Field&lt;string&gt;(&quot;CollectionName&quot;)と書くよりも、item.CollectionNameって書きたいですから。</p>
<p>では、気を取り直してこれで解析していきましょう。まずは、件のCollectionNameを見てみますか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// MetaDataCollections
// DataSourceInformation
// DataTypes
// Restrictions
// ReservedWords
// Databases
// Tables
// Columns
// Users
// Foreign Keys
// IndexColumns
// Indexes
// Foreign Key Columns
// UDF
// Views
// ViewColumns
// Procedure Parameters
// Procedures
// Triggers
foreach (var item in conn.GetSchema().AsDynamic())
{
    Console.WriteLine(item.CollectionName);
}
</code></pre>
<p>MySQLでは以上のデータが取れるようです。この辺は使ってるデータベースによってかなり変わるので、適宜調べながら合わせてみてくださいな。というわけで、それっぽそうなTablesを見てみます。var tables = conn.GetSchema(&quot;Tables&quot;).AsDynamic(); とすれば</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/dt_table_schema.jpg" />
</p>
<p>テーブル一覧が取れるようです。で、しかし、今回必要なのはTablesではありません。TablesはほんとーにTableのデータだけなので。今回必要なのは、Columnsです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var columns = conn.GetSchema(&quot;Columns&quot;).AsDynamic()
    .GroupBy(x =&gt; x.TABLE_NAME) // 全てのカラムが平らに列挙されてくるのでテーブル名でグルーピング
    .Select(g =&gt; new
    {
        ClassName = g.Key, // クラス名はテーブル名(= グルーピングのキー)
        Properties = g
            .OrderBy(x =&gt; x.ORDINAL_POSITION) // どんな順序で来るか不明なので、カラム定義順にきちんと並び替え
            .Select(x =&gt; new
            {
                Name = x.COLUMN_NAME,
                Type = x.DATA_TYPE
            })
            .ToArray()
    });
</code></pre>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/dt_columns_def.jpg" />
</p>
<p>良い感じに作れてきました。さて、クラスを自動生成するのに必要なのは「クラス名」「プロパティ名」「プロパティの型」です。DATA_TYPEだとDBの生の型名、bigintとかvarcharとかC#のデータ型じゃないよー。なので、このまんまじゃダメです。</p>
<p>というわけで、マッピングを用意してあげます。といっても手動でやる必要はなくて、これはGetSchema(&quot;DataTypes&quot;)で取れます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 型名を決めるのに必要なのは
// TypeName(MySQLの型名), DataType(.NETの型名), IsUnsigned
var typeDictionary = conn.GetSchema(&quot;DataTypes&quot;).AsDynamic()
    .ToDictionary(x =&gt;
        Tuple.Create((string)x.TypeName.ToLower(), (bool?)x.IsUnsigned ?? false),
        x =&gt; (Type)Type.GetType(x.DataType));

// MySQLのtinyintはboolとして使われることが多いので、そちらにマッピングしちゃう（不要ならしなくていいです）
typeDictionary[Tuple.Create(&quot;tinyint&quot;, true)] = typeof(bool);
typeDictionary[Tuple.Create(&quot;tinyint&quot;, false)] = typeof(bool);

// nullableの場合を考慮する必要があるのでTypeDictionaryは生では使わない
Func&lt;string, bool, bool, string&gt; getTypeName = (dataType, isUnsigned, isNullable) =&gt;
{
    var type = typeDictionary[Tuple.Create(dataType.ToLower(), isUnsigned)];
    return (isNullable &amp;&amp; type.IsValueType)
        ? type.Name + &quot;?&quot; // 値型かつnull許可の時
        : type.Name;
};
</code></pre>
<p>TypeName(MySQLの型名), DataType(.NETの型名), IsUnsigned。それにNullableへの対応を組み合わせれば、マッピングできると考えられます。GetSchemaからの情報だけだとNullable対応が苦しくなるので、外にメソッド立てています。</p>
<p>さて、この型定義辞書を使って変換すると、以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var columns = conn.GetSchema(&quot;Columns&quot;).AsDynamic()
    .GroupBy(x =&gt; x.TABLE_NAME) // 全てのカラムが平らに列挙されてくるのでテーブル名でグルーピング
    .Select(g =&gt; new
    {
        ClassName = g.Key, // クラス名はテーブル名(= グルーピングのキー)
        Properties = g
            .OrderBy(x =&gt; x.ORDINAL_POSITION) // どんな順序で来るか不明なので、カラム定義順にきちんと並び替え
            .Select(x =&gt; new
            {
                Name = x.COLUMN_NAME,
                // unsignedの判定はCOLUMN_TYPEから、nullableの判定はYES/NOで行われる
                Type = getTypeName(x.DATA_TYPE, x.COLUMN_TYPE.Contains(&quot;unsigned&quot;), x.IS_NULLABLE == &quot;YES&quot;)
            })
            .ToArray()
    });
</code></pre>
<p>これで完璧！さて、定義の抽出はできたので、次はテンプレート作りにいきましょうか。</p>
<h2>T4</h2>
<p>（テキストとしての）C#コード生成は、C#コード上で文字列を切った貼ったする、わけは勿論ありません。この手の作業するときはテンプレートエンジンを使うのが良いでしょう。最近だとRazorを使った<a href="http://razorengine.codeplex.com/">RazorEngine</a>などもあるのですが、RazorはあくまでHTML/XMLを出力するのに向いている構文で、C#コードを出力するような用途で使うのは、あまり向いていません。ここは素直にVisual Studio標準の<a href="http://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Template</a>を使うのが良いでしょう。あえてStringTemplate.NETとか、他のを選ぶ理由は、ないかなぁ。T4でいいですよ。</p>
<p>T4にはVisual Studioと連携して保存時にテンプレートが当てはまったテキストを出力するタイプと、ふつーのクラスとして、実行時に任意の変数をあてて、テキストを生成するもののニタイプが選べます。このブログでも何度か紹介してきたのは、全て前者でしたが、今回は後者のパターンを使います。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/dt_runtime_template.jpg" />
</p>
<p>昔の名前は「前処理されたテキストテンプレート」でした。VS2012から名前変わって「ランタイムテキストテンプレート」になったようです。見つからなかったら検索ウィンドウにT4と入れると良いですよ。では、まず、TableGeneratorTemplate.ttとしてテンプレートを定義します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

public class &lt;#= ClassName #&gt;
{
&lt;# foreach(var x in Properties) {#&gt;
    public &lt;#= x.Type #&gt; &lt;#= x.Name #&gt; { get; set; }
&lt;# } #&gt;

    public override string ToString()
    {
        return &quot;&quot;
&lt;# foreach(var x in Properties) {#&gt;
            + &quot;&lt;#= x.Name #&gt; : &quot; + &lt;#= x.Name #&gt; + &quot;|&quot;
&lt;# } #&gt;
            ;
    }
}
</code></pre>
<p>テンプレートの記法としては、#=で囲むだけなので、まぁそう難しいものでもないです、読みづらさはかなりありますが。さて、このままだとClassNameとかPropertiesとかいうのは未定義でコンパイルもできないので、パーシャルクラスを作ります。クラス名はテンプレートと同名で。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public partial class TableGeneratorTemplate
{
    public string ClassName { get; set; }
    public IEnumerable&lt;dynamic&gt; Properties { get; set; }

    public TableGeneratorTemplate(string className, IEnumerable&lt;dynamic&gt; properties)
    {
        this.ClassName = className;
        this.Properties = properties;
    }
}
</code></pre>
<p>これで、パラメータを渡せるようになりました。コンパイルエラーも出ません。というわけで実際に出力しましょう。テンプレートをnewして、TransformTextを呼ぶだけです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// あ、ちなみにここまでのはConsoleApplicationでの話でした、はい。
// テーブル名.csにテンプレートを当てて全部出力
foreach (var item in columns)
{
    var tt = new TableGeneratorTemplate(item.ClassName, item.Properties);
    var text = tt.TransformText();
    File.WriteAllText(item.ClassName + &quot;.cs&quot;, text, Encoding.UTF8);
}
</code></pre>
<p>これで、以下の様なファイルがテーブル数だけ出力されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

public class aiueo_test_table
{
    public Int64 id { get; set; }
    public String name { get; set; }
    public Int32 age { get; set; }
    public DateTime? created { get; set; }
    public DateTime? modified { get; set; }

    public override string ToString()
    {
        return &quot;&quot;
            + &quot;id : &quot; + id + &quot;|&quot;
            + &quot;name : &quot; + name + &quot;|&quot;
            + &quot;age : &quot; + age + &quot;|&quot;
            + &quot;created : &quot; + created + &quot;|&quot;
            + &quot;modified : &quot; + modified + &quot;|&quot;
            ;
    }
}
</code></pre>
<p>やったね！刺身たんぽぽさようなら！ちなみにただのプロパティの塊というだけじゃなく、ToStringも生成しておいてやると、実アプリでのデバッグの時に割と便利ですねー。</p>
<h2>応用</h2>
<p>GetSchemaで得られる情報は他にも沢山ありますので、Diffを取るプログラムを書けたり、あと、Index, IndexColumnsでインデックスの情報が取れます。インデックスで貼られているものはselectクエリーをほぼほぼ発行するはず、とみなせるので、selectクエリを発行するメソッドを自動生成しちゃったりとかは、実際に謎社ではしています。</p>
<p>つまり作業手順としては、どちらかというデータベースファーストになります。結局、コードとデータベースは違うので、データベース優先の定義・作業のほうが、どこまでいっても自然かな、と。(EF)コードファーストは私は幻想だと思っています。別に、SQL Server Management StudioなりHeidiSQLなどのツールでぽちぽち定義作るのは、そう面倒なわけでもない。そこからC#側のクラス定義も自動で生成できるのなら、むしろ、無理のあるコードでのデータベース表現をして回るよりも、結局、楽じゃない？DB定義をC#側から発行されて、どーのこーとか、なんてのに気を使わなくてもいいので、ずっと楽ちんだと思うんだ。原始的で全然スマートじゃないようで、実利はこっちにある。</p>
<h2>まとめ</h2>
<p>コードの詳細はMySQLなので、SQL Serverとかじゃ100%そのままは動かないかもですが、その辺は適宜調整してください、きっと似たようなのはあるはずなので。</p>
<p>あと、GetSchemaのDataTableで何が取れるのか、どんなフィールドがあるのかって、特にMySQLだとドキュメントゼロなのですが、そこでAsDynamicは本当に死ぬほど役に立ちました。Visual Studio上でのデバッガビリティを高めるの超大事。その辺がクソなのがDataTableの嫌なところですねえ。今時DataSetを使いまくってるレガシー会社とかあると悲しいですねえ。</p>
<p>ともあれ、dynamicはかなりデバッガビリティ高いので、活用してあげると良いです。dynamic、最近だと忘れ去られているC#の機能らしいので（笑）まあ、メインには使いませんけれど、あるとやっぱ便利なので、あって良かったなって、思いますよん。</p>
</div>
<h1 data-pagefind-sort="date:2013-06-24" data-pagefind-meta="published:2013-06-24"><a href="https://neue.cc/2013/06/24_410.html">AsyncOAuth ver.0.7.0 - HttpClient正式版対応とバグ修正</a></h1>
<ul class="date"><li>2013-06-24</li></ul>
<div class="entry_body"><p>HttpClientが<a href="http://blogs.msdn.com/b/dotnet/archive/2013/05/29/get-httpclient-rtm-200-ok.aspx">RTMを迎えた</a>、と思ったら、<a href="http://blogs.msdn.com/b/dotnet/archive/2013/06/19/update-to-httpclient-and-automatic-decompression.aspx">次バージョンのベータ</a>が出た、と、展開早くて追いつけないよ～な感じですが、とりあえず正式版のほうを要求する形で、AsyncOAuthも今回からBetaじゃなくなりました。</p>
<ul>
<li><a href="https://github.com/neuecc/AsyncOAuth">AsyncOAuth - GitHub</a></li>
<li>PM&gt; Install-Package <a href="https://nuget.org/packages/AsyncOAuth/">AsyncOAuth</a></li>
</ul>
<p>AsyncOAuthについては<a href="http://neue.cc/2013/02/27_398.html">AsyncOAuth - C#用の全プラットフォーム対応の非同期OAuthライブラリ</a>を、HttpClientについては<a href="http://neue.cc/2013/05/27_405.html">HttpClient詳解、或いはAsyncOAuthのアップデートについて</a>を参照ください。</p>
<p>今回のアップデートなのですが、PCL版HttpClientのRTM対応という他に、バグ修正が二点ほどあります。バグ的には、結構痛いところですね……。</p>
<h2>OrderByと文字列について</h2>
<p>バグ修正その一として、OAuthの認証シグネチャを作るのにパラメータを並び替える必用があるのですが、その並び順が特定条件の時に狂っていました。狂っている結果、正しく認証できないので、実行が必ず失敗します。特定条件というのは、パラメータ名が大文字始まりと小文字始まりが混在するときです。例えばhogeとHugaとか。本当はHuga-hogeにならなければならないのに、hoge-Hugaの順序になってしまっていたのでした。</p>
<p>なぜそうなったか、というと、OrderByをデフォルトで使っていたからです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// charの配列をOrderByで並び替えると、ASCIIコード順 = 65:'A', 97:'a'
foreach (var item in new[] { 'a', 'A' }.OrderBy(x =&gt; x))
{
    Console.WriteLine((int)item + &quot;:&quot; + (char)item);
}

// stringの配列をOrderByで並び替えると、良い感じ順 = &quot;a&quot;, &quot;A&quot;
foreach (var item in new[] { &quot;a&quot;, &quot;A&quot; }.OrderBy(x =&gt; x))
{
    Console.WriteLine(item);
}
</code></pre>
<p>良い感じ順！というのはなにかというと、<a href="http://msdn.microsoft.com/ja-jp/library/system.stringcomparer.currentculture.aspx">StringComparison/Comparer.CurrentCulture</a>の順番です。ほぅ……。ありがたいような迷惑のような。で、今回はASCIIコードにきっちり従って欲しいので、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 実際のコード。
// ところでrealmのところは!x.Key.Equals(&quot;realm&quot;, StringComparison.OrdinalIgnoreCase) って書くべき、次のバージョンで直します
var stringParameter = parameters
    .Where(x =&gt; x.Key.ToLower() != &quot;realm&quot;)
    .Concat(queryParams)
    .OrderBy(p =&gt; p.Key, StringComparer.Ordinal)
    .ThenBy(p =&gt; p.Value, StringComparer.Ordinal)
    .Select(p =&gt; p.Key.UrlEncode() + &quot;=&quot; + p.Value.UrlEncode())
    .ToString(&quot;&amp;&quot;);
</code></pre>
<p>といったように、StringComparer.OrdinalをOrderBy/ThenByに渡してあげることで解決しました。メデタシメデタシ。文字列の比較とか、言われてみれば基本中の基本っっっ！なのですけれど、完全に失念してました。テストでも、パラメータ小文字ばっかだったりして問題が中々表面化しないんですね、言い訳ですけれど……。しかし、幾つかのライブラリ見てみると、ほとんどがこれの対応できてなかったので私だけじゃないもん！みたいな、うう、情けないのでやめておきましょう。OAuthBase.csもissueには上がってましたがマージされてないんで、同様の問題抱えてるのですねえ。さすがにDotNetOpenAuthはきっちりできていました。</p>
<h2>UriクラスとQueryとエスケープについて</h2>
<p>バグ修正その2。GETにパラメータをくっつける、つまりクエリストリングとして並べた時に、日本語などURLエンコードが必要な物が混ざっている時に必ず認証に失敗しました。エンコード周りということで、お察しの通り二重エンコードが原因です。</p>
<p>これに関しては、私のUriクラスへの認識が甘々だったのがマズかったです。ぶっちけ、ただのstringを包んだだけの面倒臭い代物とか思ってたりとかしたりとか……。いや、さすがにそこまでではないんですが、まぁしかし甘々でした。こっちは↑のに比べても本当に初歩ミスすぎて穴掘って埋まりたいですぅー。相当恥ずかしい。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// クエリストリングつけたものを投げるとして
var uri = new Uri(&quot;http://google.co.jp/serach?q=つくば&quot;);

// QueryはURLエンコードされてる =&gt; ?q=%E3%81%A4%E3%81%8F%E3%81%B0
Console.WriteLine(uri.Query);

// URLエンコードされてるのを渡したとして
uri = new Uri(&quot;http://google.co.jp/serach?q=%E3%81%A4%E3%81%8F%E3%81%B0&quot;);

// ToString結果はURLデコードされたものがでてくる =&gt; http://google.co.jp/serach?q=つくば
Console.WriteLine(uri.ToString());
</code></pre>
<p>というわけで、Queryは常にURLエンコードされるし、ToStringは常にURLデコードされてる。この辺の認識がフワフワッとしてると、エンコードやデコード結果が非常にアレになっちゃうんですね……。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 元データが欲しい時はOriginalString
Console.WriteLine(uri.OriginalString);

// エンコードされないで取るにはGetComponentsで指定してあげる
// ちなみにQueryは (UriComponents.Query | UriComponents.KeepDelimiter, UriFormat.Escaped) と等しい
var unescaped = uri.GetComponents(UriComponents.Query, UriFormat.Unescaped);
Console.WriteLine(unescaped); // q=つくば
</code></pre>
<p>GetComponents大事大事。</p>
<h2>Next</h2>
<p>今回からBetaを取ったということで、1.0に上げようかなあ、とか思ったんですが、↑のように手痛いバグが残っていたことが発覚したりなので、まだもう少し様子見といった感。さすがにもう大丈夫なはず！といくら思っても見つかっていくわけで、枯れてるって本当に大事ですねえ。AsyncOAuthも枯れたライブラリになるよう、頑張ります。今回のバグとかもユーザーが伝えてくれるお陰なので足を向けて寝られません。</p>
<p>私自身が使ってるのか？というと、答えは、使っています！こないだに<a href="http://neue.cc/2013/06/10_406.html">.NET最先端技術によるハイパフォーマンスウェブアプリケーション</a>というセッションを行ない、そこで言及したように、現在、某ソーシャルゲームをC#で再構築中です。で、GREEにせよMobageにせよ、ソーシャルゲームってOpenSocialの仕組みに乗っかっているのですが、その認証がOAuthなのです。というわけで、めっちゃくちゃヘヴィーに使っています。(認証の形態がちょっと違うので幾つかメソッドが足されているのと、Shift-JIS対応とかのためのカスタムバージョンだったりはしますが…… その辺はAsyncOAuth本体にも載せるか検討中)。実戦投下まであとちょっとってところですが、それできっちり動ききれば、十分に枯れた、といえるのではないかと思っています。その時までは0.xで。でも現状でもかなり大丈夫だとは思いますので、是非是非使ってください。</p>
</div>
<h1 data-pagefind-sort="date:2013-06-23" data-pagefind-meta="published:2013-06-23"><a href="https://neue.cc/2013/06/23_409.html">The History of LINQ</a></h1>
<ul class="date"><li>2013-06-23</li></ul>
<div class="entry_body"><p>という内容で、<a href="http://atnd.org/event/E0015958">つくばC#勉強会</a>で話してきました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/23314703" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/the-history-of-linq" title="The History of LINQ" target="_blank">The History of LINQ</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>初心者向け勉強会（？）ということで、歴史ですかにぇー。詳細よりは、全体的にあっさり、みたいな。多分ね！<a href="http://research.microsoft.com/en-us/um/cambridge/projects/comega/">Cω</a>とかもう10年前ですが、これだけ時間のたった今だからこそ、あらためてちょっと見てみると面白いね、みたいな。</p>
<p><a href="http://togetter.com/li/523153">第一回つくばC#勉強会 #tkbcsmt 当日の様子</a>ということで実にカオス、よかったね！面白かったです～。</p>
</div>
<h1 data-pagefind-sort="date:2013-06-20" data-pagefind-meta="published:2013-06-20"><a href="https://neue.cc/2013/06/20_408.html">TypeScript 0.9のジェネリクス対応でlinq.jsの型定義作って苦労した話</a></h1>
<ul class="date"><li>2013-06-20</li></ul>
<div class="entry_body"><p>久しぶりの<a href="http://www.typescriptlang.org/">TypeScript</a>。<a href="http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx">Announcing TypeScript 0.9</a>というわけで、ついに待望のジェネリクスが搭載されました。やったね！というわけで、ジェネリクス対応の<a href="https://linqjs.codeplex.com/">linq.js</a>の型定義を早速作りました、と。ver 3.0.4-Beta5です。まだまだBeta、すみませんすみません、色々忙しくて……。NuGetからもしくはサイトからのダウンロードで公開してます。</p>
<p>とりあえず例として使ってみた感じ。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// booleanしか受け入れないwhereにnumberを突っ込んだらちゃんと怒ってくれるよ！
// Call signatures of types '(x: any) =&gt; number' and '(element: number, index: number) =&gt; boolean' are incompatible.
var seq = Enumerable.from([1, 10, 100, 100]).where(x =&gt; x * 2);
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ts_generics_intellisense.jpg">
</p>
<p>やったー。これだよこれ！LINQはジェネリクスがあって本当の本当の真価を発揮するんです！！！</p>
<h2>面白げな型定義</h2>
<p>C#とちょっと違うところとしては、ジェネリクスの型変数のところにもオブジェクトを突っ込めるんですね。だから</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ts_generics_typearg.jpg">
</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// from(obj)の型定義はこんな感じ。
from(obj: any): IEnumerable&lt;{ key: string; value: any }&gt;;

// ちなみにfromのオーバーロードはいっぱいある
// linq.js自体はJScriptのIEnumerableとWinMDのIIterable&lt;T&gt;にも対応してるのですがTSで表現できないので、そこは未定義……。。。
from(): IEnumerable&lt;any&gt;; // empty
from&lt;T&gt;(obj: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
from(obj: number): IEnumerable&lt;number&gt;;
from(obj: boolean): IEnumerable&lt;boolean&gt;;
from(obj: string): IEnumerable&lt;string&gt;;
from&lt;T&gt;(obj: T[]): IEnumerable&lt;T&gt;;
from&lt;T&gt;(obj: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
</code></pre>
<p>このkey,valueはどこから出てきたんだよって感じでわかりづらかったので、こうして見えてくれると嬉しい度高い。</p>
<h2>型消去</h2>
<p>場合によってはIEnumerable&lt;any&gt;となるため、Tの型をつけてあげたかったり、もしくは強引に変換したかったり（例えば↑のIIterable&lt;T&gt;は{key,value}に解釈されてしまうので、明示的に変換してあげる必要がある）する場合のために、castメソッドを用意しました。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// any[]型で渡ってきたりする場合に
var seq: any[] = [1, 2, 3, 4, 5];

var result = Enumerable.from(seq)
    .cast&lt;number&gt;() // numberに変換
    .select(x =&gt; x * x) // x:number
    .toArray(); // result:number[]
</code></pre>
<p>さて、ところで、TypeScriptのジェネリクスは型消去(Type Erasure)式です。コンパイル結果のJSは以下のような感じで</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var result = Enumerable.from(seq)
    .cast()
    .select(function (x) { return x * x; })
    .toArray();
</code></pre>
<p>一切の型は消えています。なので、TypeScriptでTの型を取って実行時に扱ったりはできません。型が欲しければ型を渡せ方式。</p>
<p>linq.jsにはofTypeという、型でフィルタリングするメソッドがあるのですが</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// 混在した配列から、型でフィルタして取り出す
var mixed: any[] = [1, &quot;hoge&quot;, 100, true, &quot;nano&quot;];

// このままじゃ型が分からないのでresultはany[]
var result1 = Enumerable.from(mixed)
    .ofType(Number) // 数値型のみでフィルタ、つまり[1, 100]
    .toArray();

// ofTypeの後にcastするか、もしくはofTypeで型指定するか
var result2 = Enumerable.from(mixed)
    .ofType&lt;number&gt;(Number)
    .toArray();
</code></pre>
<p>というように、&lt;number&gt;(Number)と連続するのが非常に不恰好……。まあ、この辺はそういうものなのでしょうがないと諦めましょう。</p>
<h2>地雷ふんだり</h2>
<p>さて、そんな素敵なTypeScript 0.9なのですが、残念なお知らせ。現在の、というか、この0.9ですが、完成度はものすごーーーーーーーーく、低いです。はい、超低いです。Visual Studioと組み合わせて使う場合、半端無く動作も補完も遅いです。正直、ベータどころかアルファぐらいのクオリティで、何故に堂々と出してきたのか理解に苦しむ。遅いだけならまだしも、ジェネリクスの解釈が非常に怪しく、地雷を踏むと補完やエラー通知が消え去ります。いや、消え去るだけならまだよくて、Visual Studioと裏で動くTypeScript Compilerが大暴走をはじめてCPUが100%に張り付いたりします。もうヤヴァい。タスクマネージャー開きっぱにして警戒しながらじゃないと書けないです。linq.jsの型定義書くの超絶苦労した……。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">interface IEnumerable&lt;T&gt; {
    // 戻り値の型をIEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;にしたいのですが、
    // interface側で定義しているTをネストした型変数に使うとVSが大暴走して死ぬ
    // ので、今回のバージョンではanyにしてます
    groupBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, any&gt;&gt;;
}
</code></pre>
<p>具体的に踏んだのは↑ですねえ。最初原因が分かってなくてかなり時間食われちゃいました。んもー。最小セットで試してる限りでは、コンパイルエラーにはなるんですが(A generic type may not reference itself with a wrapped form of its own type parameters.)暴走はしない、んですがlinq.d.tsで弄ってると死ぬ。おうふ。もう定義の仕方が悪いのかコンパイラがアレなのか判断つかないのでしんどい。</p>
<p>そんなわけで、0.8の完成度からだいぶ退化して、実用性はゼロになってしまいました。私の環境だけ、じゃあないよねえ…‥？とりあえず0.9.1を待ちましょう。どうやらコンパイラをまるっと書き換えたそうですしねー、初物だからshoganaiと思うことにして。しかし泣きたい。</p>
<h2>linq.d.ts</h2>
<p>とりあえず、こんな感じになってます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Type Definition for linq.js, ver 3.0.4-Beta5

declare module linqjs {
    interface IEnumerator&lt;T&gt; {
        current(): T;
        moveNext(): boolean;
        dispose(): void;
    }

    interface Enumerable {
        Utils: {
            createLambda(expression: any): (...params: any[]) =&gt; any;
            createEnumerable&lt;T&gt;(getEnumerator: () =&gt; IEnumerator&lt;T&gt;): IEnumerable&lt;T&gt;;
            createEnumerator&lt;T&gt;(initialize: () =&gt; void , tryGetNext: () =&gt; boolean, dispose: () =&gt; void ): IEnumerator&lt;T&gt;;
            extendTo(type: any): void;
        };
        choice&lt;T&gt;(...params: T[]): IEnumerable&lt;T&gt;;
        cycle&lt;T&gt;(...params: T[]): IEnumerable&lt;T&gt;;
        empty&lt;T&gt;(): IEnumerable&lt;T&gt;;
        // from&lt;T&gt;, obj as JScript's IEnumerable or WinMD IIterable&lt;T&gt; is IEnumerable&lt;T&gt; but it can't define.
        from(): IEnumerable&lt;any&gt;; // empty
        from&lt;T&gt;(obj: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        from(obj: number): IEnumerable&lt;number&gt;;
        from(obj: boolean): IEnumerable&lt;boolean&gt;;
        from(obj: string): IEnumerable&lt;string&gt;;
        from&lt;T&gt;(obj: T[]): IEnumerable&lt;T&gt;;
        from&lt;T&gt;(obj: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        from(obj: any): IEnumerable&lt;{ key: string; value: any }&gt;;
        make&lt;T&gt;(element: T): IEnumerable&lt;T&gt;;
        matches&lt;T&gt;(input: string, pattern: RegExp): IEnumerable&lt;T&gt;;
        matches&lt;T&gt;(input: string, pattern: string, flags?: string): IEnumerable&lt;T&gt;;
        range(start: number, count: number, step?: number): IEnumerable&lt;number&gt;;
        rangeDown(start: number, count: number, step?: number): IEnumerable&lt;number&gt;;
        rangeTo(start: number, to: number, step?: number): IEnumerable&lt;number&gt;;
        repeat&lt;T&gt;(element: T, count?: number): IEnumerable&lt;T&gt;;
        repeatWithFinalize&lt;T&gt;(initializer: () =&gt; T, finalizer: (element) =&gt; void ): IEnumerable&lt;T&gt;;
        generate&lt;T&gt;(func: () =&gt; T, count?: number): IEnumerable&lt;T&gt;;
        toInfinity(start?: number, step?: number): IEnumerable&lt;number&gt;;
        toNegativeInfinity(start?: number, step?: number): IEnumerable&lt;number&gt;;
        unfold&lt;T&gt;(seed: T, func: (value: T) =&gt; T): IEnumerable&lt;T&gt;;
        defer&lt;T&gt;(enumerableFactory: () =&gt; IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
    }

    interface IEnumerable&lt;T&gt; {
        constructor(getEnumerator: () =&gt; IEnumerator&lt;T&gt;);
        getEnumerator(): IEnumerator&lt;T&gt;;

        // Extension Methods
        traverseBreadthFirst(func: (element: T) =&gt; IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        traverseBreadthFirst&lt;TResult&gt;(func: (element: T) =&gt; IEnumerable&lt;T&gt;, resultSelector: (element: T, nestLevel: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        traverseDepthFirst&lt;TResult&gt;(func: (element: T) =&gt; Enumerable): IEnumerable&lt;T&gt;;
        traverseDepthFirst&lt;TResult&gt;(func: (element: T) =&gt; Enumerable, resultSelector?: (element: T, nestLevel: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        flatten(): IEnumerable&lt;any&gt;;
        pairwise&lt;TResult&gt;(selector: (prev: T, current: T) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        scan(func: (prev: T, current: T) =&gt; T): IEnumerable&lt;T&gt;;
        scan&lt;TAccumulate&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate): IEnumerable&lt;TAccumulate&gt;;
        select&lt;TResult&gt;(selector: (element: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; IEnumerable&lt;TOther&gt;): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; IEnumerable&lt;TCollection&gt;, resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; TOther[]): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; TCollection[], resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        selectMany&lt;TOther&gt;(collectionSelector: (element: T, index: number) =&gt; { length: number;[x: number]: TOther; }): IEnumerable&lt;TOther&gt;;
        selectMany&lt;TCollection, TResult&gt;(collectionSelector: (element: T, index: number) =&gt; { length: number;[x: number]: TCollection; }, resultSelector: (outer: T, inner: TCollection) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        where(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        choose(selector: (element: T, index: number) =&gt; T): IEnumerable&lt;T&gt;;
        ofType&lt;TResult&gt;(type: any): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: IEnumerable&lt;T&gt;, resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: { length: number;[x: number]: T; }, resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(second: T[], resultSelector: (first: T, second: T, index: number) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        zip&lt;TResult&gt;(...params: any[]): IEnumerable&lt;TResult&gt;; // last one is selector
        merge&lt;TResult&gt;(...params: IEnumerable&lt;T&gt;[]): IEnumerable&lt;T&gt;;
        merge&lt;TResult&gt;(...params: { length: number;[x: number]: T; }[]): IEnumerable&lt;T&gt;;
        merge&lt;TResult&gt;(...params: T[][]): IEnumerable&lt;T&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: IEnumerable&lt;TInner&gt;, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        join&lt;TInner, TKey, TResult&gt;(inner: TInner[], outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: IEnumerable&lt;TInner&gt;, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        groupJoin&lt;TInner, TKey, TResult&gt;(inner: TInner[], outerKeySelector: (outer: T) =&gt; TKey, innerKeySelector: (inner: TInner) =&gt; TKey, resultSelector: (outer: T, inner: TKey) =&gt; TResult, compareSelector?: (obj: T) =&gt; TKey): IEnumerable&lt;TResult&gt;;
        all(predicate: (element: T) =&gt; boolean): boolean;
        any(predicate?: (element: T) =&gt; boolean): boolean;
        isEmpty(): boolean;
        concat(...sequences: IEnumerable&lt;T&gt;[]): IEnumerable&lt;T&gt;;
        concat(...sequences: { length: number;[x: number]: T; }[]): IEnumerable&lt;T&gt;;
        concat(...sequences: T[]): IEnumerable&lt;T&gt;;
        insert(index: number, second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        insert(index: number, second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        alternate(alternateValue: T): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        alternate(alternateSequence: T[]): IEnumerable&lt;T&gt;;
        contains(value: T): boolean;
        contains&lt;TCompare&gt;(value: T, compareSelector?: (element: T) =&gt; TCompare): boolean;
        defaultIfEmpty(defaultValue?: T): IEnumerable&lt;T&gt;;
        distinct(): IEnumerable&lt;T&gt;;
        distinct&lt;TCompare&gt;(compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        distinctUntilChanged(): IEnumerable&lt;T&gt;;
        distinctUntilChanged&lt;TCompare&gt;(compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        except(second: T[]): IEnumerable&lt;T&gt;;
        except&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        intersect(second: T[]): IEnumerable&lt;T&gt;;
        intersect&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: { length: number;[x: number]: T; }): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: IEnumerable&lt;T&gt;): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        union(second: T[]): IEnumerable&lt;T&gt;;
        union&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;T&gt;;
        sequenceEqual(second: { length: number;[x: number]: T; }): boolean;
        sequenceEqual&lt;TCompare&gt;(second: { length: number;[x: number]: T; }, compareSelector: (element: T) =&gt; TCompare): boolean;
        sequenceEqual(second: IEnumerable&lt;T&gt;): boolean;
        sequenceEqual&lt;TCompare&gt;(second: IEnumerable&lt;T&gt;, compareSelector: (element: T) =&gt; TCompare): boolean;
        sequenceEqual(second: T[]): boolean;
        sequenceEqual&lt;TCompare&gt;(second: T[], compareSelector: (element: T) =&gt; TCompare): boolean;
        orderBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        orderByDescending&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        reverse(): IEnumerable&lt;T&gt;;
        shuffle(): IEnumerable&lt;T&gt;;
        weightedSample(weightSelector: (element: T) =&gt; number): IEnumerable&lt;T&gt;;
        // truly, return type is IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt; but Visual Studio + TypeScript Compiler can't compile.
        groupBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;;
        groupBy&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
        groupBy&lt;TKey, TElement, TResult&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        groupBy&lt;TKey, TElement, TResult, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;TResult&gt;;
        // :IEnumerable&lt;IGrouping&lt;TKey, T&gt;&gt;
        partitionBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IEnumerable&lt;IGrouping&lt;TKey, any&gt;&gt;;
        // :IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;
        partitionBy&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
        partitionBy&lt;TKey, TElement, TResult&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult): IEnumerable&lt;TResult&gt;;
        partitionBy&lt;TKey, TElement, TResult, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, resultSelector: (key: TKey, element: IEnumerable&lt;TElement&gt;) =&gt; TResult, compareSelector: (element: T) =&gt; TCompare): IEnumerable&lt;TResult&gt;;
        buffer(count: number): IEnumerable&lt;T&gt;;
        aggregate(func: (prev: T, current: T) =&gt; T): T;
        aggregate&lt;TAccumulate&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate): TAccumulate;
        aggregate&lt;TAccumulate, TResult&gt;(seed: TAccumulate, func: (prev: TAccumulate, current: T) =&gt; TAccumulate, resultSelector: (last: TAccumulate) =&gt; TResult): TResult;
        average(selector?: (element: T) =&gt; number): number;
        count(predicate?: (element: T, index: number) =&gt; boolean): number;
        max(selector?: (element: T) =&gt; number): number;
        min(selector?: (element: T) =&gt; number): number;
        maxBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): T;
        minBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): T;
        sum(selector?: (element: T) =&gt; number): number;
        elementAt(index: number): T;
        elementAtOrDefault(index: number, defaultValue?: T): T;
        first(predicate?: (element: T, index: number) =&gt; boolean): T;
        firstOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        last(predicate?: (element: T, index: number) =&gt; boolean): T;
        lastOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        single(predicate?: (element: T, index: number) =&gt; boolean): T;
        singleOrDefault(predicate?: (element: T, index: number) =&gt; boolean, defaultValue?: T): T;
        skip(count: number): IEnumerable&lt;T&gt;;
        skipWhile(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        take(count: number): IEnumerable&lt;T&gt;;
        takeWhile(predicate: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        takeExceptLast(count?: number): IEnumerable&lt;T&gt;;
        takeFromLast(count: number): IEnumerable&lt;T&gt;;
        indexOf(item: T): number;
        indexOf(predicate: (element: T, index: number) =&gt; boolean): number;
        lastIndexOf(item: T): number;
        lastIndexOf(predicate: (element: T, index: number) =&gt; boolean): number;
        asEnumerable(): IEnumerable&lt;T&gt;;
        cast&lt;TResult&gt;(): IEnumerable&lt;TResult&gt;;
        toArray(): T[];
        // truly, return type is ILookup&lt;TKey, T&gt; but Visual Studio + TypeScript Compiler can't compile. 
        toLookup&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): ILookup&lt;TKey, any&gt;;
        toLookup&lt;TKey, TElement&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement): ILookup&lt;TKey, TElement&gt;;
        toLookup&lt;TKey, TElement, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TElement, compareSelector: (key: TKey) =&gt; TCompare): ILookup&lt;TKey, TElement&gt;;
        toObject(keySelector: (element: T) =&gt; any, elementSelector?: (element: T) =&gt; any): Object;
        // :IDictionary&lt;TKey, T&gt;
        toDictionary&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IDictionary&lt;TKey, any&gt;;
        toDictionary&lt;TKey, TValue&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TValue): IDictionary&lt;TKey, TValue&gt;;
        toDictionary&lt;TKey, TValue, TCompare&gt;(keySelector: (element: T) =&gt; TKey, elementSelector: (element: T) =&gt; TValue, compareSelector: (key: TKey) =&gt; TCompare): IDictionary&lt;TKey, TValue&gt;;
        toJSONString(replacer: (key: string, value: any) =&gt; any): string;
        toJSONString(replacer: any[]): string;
        toJSONString(replacer: (key: string, value: any) =&gt; any, space: any): string;
        toJSONString(replacer: any[], space: any): string;
        toJoinedString(separator?: string): string;
        toJoinedString&lt;TResult&gt;(separator: string, selector: (element: T, index: number) =&gt; TResult): string;
        doAction(action: (element: T, index: number) =&gt; void ): IEnumerable&lt;T&gt;;
        doAction(action: (element: T, index: number) =&gt; boolean): IEnumerable&lt;T&gt;;
        forEach(action: (element: T, index: number) =&gt; void ): void;
        forEach(action: (element: T, index: number) =&gt; boolean): void;
        write(separator?: string): void;
        write&lt;TResult&gt;(separator: string, selector: (element: T) =&gt; TResult): void;
        writeLine(): void;
        writeLine&lt;TResult&gt;(selector: (element: T) =&gt; TResult): void;
        force(): void;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; { length: number;[x: number]: TResult; }): IEnumerable&lt;TResult&gt;;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; TResult[]): IEnumerable&lt;TResult&gt;;
        letBind&lt;TResult&gt;(func: (source: IEnumerable&lt;T&gt;) =&gt; IEnumerable&lt;TResult&gt;): IEnumerable&lt;TResult&gt;;
        share(): IDisposableEnumerable&lt;T&gt;;
        memoize(): IDisposableEnumerable&lt;T&gt;;
        catchError(handler: (exception: any) =&gt; void ): IEnumerable&lt;T&gt;;
        finallyAction(finallyAction: () =&gt; void ): IEnumerable&lt;T&gt;;
        log(): IEnumerable&lt;T&gt;;
        log&lt;TValue&gt;(selector: (element: T) =&gt; TValue ): IEnumerable&lt;T&gt;;
        trace(message?: string): IEnumerable&lt;T&gt;;
        trace&lt;TValue&gt;(message: string, selector: (element: T) =&gt; TValue ): IEnumerable&lt;T&gt;;
    }

    interface IOrderedEnumerable&lt;T&gt; extends IEnumerable&lt;T&gt; {
        createOrderedEnumerable&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey, descending: boolean): IOrderedEnumerable&lt;T&gt;;
        thenBy&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
        thenByDescending&lt;TKey&gt;(keySelector: (element: T) =&gt; TKey): IOrderedEnumerable&lt;T&gt;;
    }

    interface IDisposableEnumerable&lt;T&gt; extends IEnumerable&lt;T&gt; {
        dispose(): void;
    }

    interface IDictionary&lt;TKey, TValue&gt; {
        add(key: TKey, value: TValue): void;
        get(key: TKey): TValue;
        set(key: TKey, value: TValue): boolean;
        contains(key: TKey): boolean;
        clear(): void;
        remove(key: TKey): void;
        count(): number;
        toEnumerable(): IEnumerable&lt;{ key: TKey; value: TValue }&gt;;
    }

    interface ILookup&lt;TKey, TElement&gt; {
        count(): number;
        get(key: TKey): IEnumerable&lt;TElement&gt;;
        contains(key: TKey): boolean;
        toEnumerable(): IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;;
    }

    interface IGrouping&lt;TKey, TElement&gt; extends IEnumerable&lt;TElement&gt; {
        key(): TKey;
    }
}

// export definition
declare var Enumerable: linqjs.Enumerable;
</code></pre>
<p>アップデートを全然追ってないので、初期に作った定義の仕方のまんまなので、大丈夫かな、まあ、大丈夫じゃないかな、きっと。</p>
<p>とりあえずとにかく面倒くさかった。しかし定義する人が苦労すれば、利用者はハッピーになれるから！！！なのではやくVS対応がまともになってください。ぶんぶんぶん回したいのだけれどねえ←その前にlinq.js ver.3がいつまでもBetaなのをなんとかしろ</p>
</div>
<h1 data-pagefind-sort="date:2013-06-14" data-pagefind-meta="published:2013-06-14"><a href="https://neue.cc/2013/06/14_407.html">C#の強み、或いは何故PHPから乗り換えるのか</a></h1>
<ul class="date"><li>2013-06-14</li></ul>
<div class="entry_body"><p>という内容で、C#ユーザー会で話してきました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/22979400" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/c-22979400" title="C#の強み、或いは何故PHPから乗り換えるのか" target="_blank">C#の強み、或いは何故PHPから乗り換えるのか</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>特にPHPディスりたいわけでは、あるのかないのかはともかく、やっぱり実際に使ってきて良いところというのも分からなくもない感じです。会場でも話したのは、短期的な開発速度には有利なのは間違いないのかな、と。デプロイとかも、とりあえずポン置きでいいし、開発も、なんかもう複雑なことやると面倒だし、どうせ文字列だらけになるしで、開き直ってハードコーディングでバカバカ作っていくから速い、とか。ただし勿論あとで苦労するわけですがそれはそれとして。けれどやっぱC#良いよね、って。</p>
<p>言語も色々なトレードオフで成り立つわけですが、その中でもC#は、バランス良くて好きだなーというのが私の個人的なところです。Visual Studio良いよねー、でもいいですしLINQ良いよねー、もいいですし、IntelliSenseがないと生きていけないですし。うん、そう、IntelliSense指向言語が好きなわけです。</p>
<p>ほとんどVisual Studioの話じゃねーか、というのは、まぁそうなのですけれど、大事なのはVisual Studioを前提においた言語構造になってるってとこです。強力すぎる型推論は、100%の入力補完を実現できなかったりする。強力すぎる動的さは100%の入力補完を実現できなかったりする。C#がVisual Studioとともに使って快適なのは、そういう言語設計になっているからです。コンパイルの速さも重要で。C#は他のコンパイル型言語に比べて速い部類に入ります。だから快適だし、エラー通知とかもリアルタイム。目に見えないところ、使ってみないと評価しにくい、ただの○×表だけの性能比較にはない部分、結構多いものです。</p>
</div>
<h1 data-pagefind-sort="date:2013-06-10" data-pagefind-meta="published:2013-06-10"><a href="https://neue.cc/2013/06/10_406.html">.NET最先端技術によるハイパフォーマンスウェブアプリケーション FAQ</a></h1>
<ul class="date"><li>2013-06-10</li></ul>
<div class="entry_body"><p>Build Insider Offlineにて、「.NET最先端技術によるハイパフォーマンスウェブアプリケーション」と題して、グラニのC#によるウェブアプリケーション作成の仕組みについて話してきました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/22662425" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/net-22662425" title=".NET最先端技術によるハイパフォーマンスウェブアプリケーション" target="_blank">.NET最先端技術によるハイパフォーマンスウェブアプリケーション</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>一日でViewsが1万、はてブが250と、ドトネト系にしては珍しく多くの人に見てもらえたようでなにより。</p>
<p>今までのC#関連って、MS純正ライブラリを使ったどうのこうの、というのはありましたが、外部ライブラリを組み合わせて、実践的にどうしているかっていうような話ってほとんどなかったんですよね。やってるところがない、ことはないのですが、しかし表にない、見えないものはないに等しいです。</p>
<p>別にC#だって自分達の手でライブラリを選び、作り、組み上げていく。それがこれからの時代のスタンダードです。遅れていたのかもしれません。しかし、遅すぎるなんてことはない。素材は良いし、.NETは死んだのでなく、むしろ風が吹いてきている。リアルなモデルケースとして、引っ張っていけたらと思っています。</p>
<h2>FAQ</h2>
<ul>
<li>今時Windowsサーバー？</li>
</ul>
<p>AWSやAzureなどで簡単にWindowsインスタンスの立ち上げが可能なので、今時というか普通に選択肢に入ってくれるといいですねえ、これからは。ウェブ＝LAMPとか誰が決めたの？という話で。コスト面ではそんなに高くなるわけでもないし、それで開発効率が上がったり、サーバー台数が削減されるなら、むしろプラスです。開発効率に関しては人員次第ですが、うちのメンバーの習熟度で言ったら間違いなく上がります、圧倒的に。</p>
<ul>
<li>サーバーサイドでトラフィック以外がくってるのおかしい</li>
</ul>
<p>そうそう、一般的にウェブではネックなのは通信部分だけ、と思っていたことも有りました。でもまぁ、クックパッドの<a href="http://techlife.cookpad.com/2013/06/07/rubykaigi-high-performance-rails/">Rails アプリケーションのパフォーマンスについて RubyKaigi 2013 で発表しました</a>のスライドのResponse time breakdownのところ。SQLが20%がRubyが80%とあるんですね。うちのグラフと一緒？CakePHPはとにかくアレなわけですが、重量級フレームワークは割とそうなるもんなのかしらねえ、と少しだけホッとしたような絶望したような。</p>
<p>先入観じゃなくちゃんとモニタリングしてくのが大事、と当たり前の話ですけれど。スライドでも推しましたが<a href="http://newrelic.com/">New Relic</a>は本当に最高なので、よほどの事情がない限りは入れるべきかなぁ、と。PHP, Ruby, Java, .NET, Python, Node.js、多くの言語に対応しています。確実にパワーは喰いますが、それでも全然お釣りくる。</p>
<ul>
<li>アプリケーションサーバー:DBマスター:DBスレーブの比率がおかしい</li>
</ul>
<p>ええと、これ、実質的にはSlaveは0です。色々な経緯があって、アプリ本体からは参照も全てMasterにし
か振ってません。Slaveの用途は管理画面からの参照用とか、その程度です（スタンバイという点でも、RDSのMulti-AZを利用しているので意味は無い）。となると比率はますますオカシクなるわけですが、うーん、まあ、今時のDBってなんだかんだで頑丈ですからねえ、そう増えないかなあ。しかしそれにしてもアプリケーションサーバーの台数が多すぎなのは、まぁもう本当にすみませんすみませんって感じなわけなのですが。みんなCakePHP触ってみるといいですよ、XHProfにかけると絶望しますから。</p>
<p>勿論チューニングの余地はあります。ありますし、最後にはCakePHPを捨てるというところになることも見えるし、PHPにこだわる理由がどこにもありません。それならC#移行に、といったところですね。とはいえ実際のとこ増え続けることによる歪みが色々発生してるので、ヒィヒィ言いながら適宜対処してます。あと、最低限というか割とそれなりにはCakePHP本体に手を入れたりもしてはいるんですけど、それでも中々どうにも。</p>
<ul>
<li>PHPのLINQあるよ</li>
</ul>
<p>ないよ。幾つかのPHP-LINQライブラリを、コードも読んで評価しましたが、ゴミという結論に達しました。私は<a href="http://linqjs.codeplex.com/">JavaScriptにLINQ移植</a>したりとかしているので、LINQにはこだわりがありひじょーにうるさいのです。あとCakePHPに含まれてるコレクション系のメソッドもゴミですね。かわりに自作したLINQっぽいコレクション処理用の何かを使っています。PHP 5.4を使っているので、ラムダとかもがしがし使えはするので、メソッドチェーンでフィルターやグルーピング、複数キーのソートとか一通りできるように作りました。これ作ってなかったら死んでたわ……。ただ、簡易的な実装なので遅延実行ではありません。最近発表された<a href="http://akanehara.info/phpcon/ginq/#/">Ginq</a>は非常に良いですね！もっと前にあったら、採用していたかもしれません。</p>
<ul>
<li>「何でもハッシュに詰めるしかない」</li>
</ul>
<p>ここ説明が足りなくてアレでしたね、申し訳ないです。文脈としてはIntelliSenseが効くか効かないか、の話しかするつもりなかったのと、ハッシュだろうとオブジェクトだろうとDBからの戻り値の場合はどうせ効かないのでどうでもいい、といった感だったので不正確でした、すみません。</p>
<p>あ、DBから以外の部分で、Modelとして作りこむところでは普通にclass立てたり、TypeHinting使ったりPhpDoc書いたりして、補完がなるべく効きやすいように作ってはいますよ。IDE信奉者なので、<a href="http://www.jetbrains.com/phpstorm/">PhpStorm</a>を会社で購入して使っていますので。とはいえ、タイプヒンティングやPHPDocでも、PHP自体がゆるふわなので効きめはイマイチなんですよ。じゃあ、PHP自体がのゆるふわさを捨てて完全にガチガチに書くか？といったら、それはそれでイマイチになるので、まぁ、半分諦めるのがいいかな、とは。</p>
<p>一応誤解なきように弁解すると、無知のC#モノがイヤイヤPHP使ってるだけでPHPについて何も分かっちゃいない、というほどに分かってないわけではないです。一応はPHPの最新言語仕様についてはちゃんと追っかけて差分取っているぐらいには使っています。さすがに仕事の商売道具ですから、嫌いだから何も勉強しない！わけでもないです。traitなども効果的だと思ったところには使ってますし、まぁtrait使うと更にPhpStormの補完が死ぬわけですが。</p>
<ul>
<li>なんで水平分割いやがるの</li>
</ul>
<p>一応スライド中にも書きましたが、メンドーごとが増えるので。特に嫌なのは、<a href="http://www.heidisql.com/">HeidiSQL</a>とか、GUIツール郡の使い勝手が低下して、かわりに自社製のツールセット（コマンドか、しょぼいWebUI）になるか、とかですよねえ、それが一番避けたくて。他社の話を聞いていて驚くのは、phpMyAdminとかコマンド叩いてるとかいうんですよ、DB見たりするのに。私的には、ありえない。みんなもっとちゃんとGUIツールも使いましょう。必要とあらばウェブツールだけじゃなくてGUIツールも自作しましょう(C#なら簡単です！)。</p>
<p>まあ、どうしてもダメになったら水平にします。でもFusion-IOはもとより、AWSでも10万IOPSのインスタンスが出たりとか、ハードウェア性能はどんどん進化しているので、何とかなってくれるんじゃないかなあ、と楽観視はしています。良い時代になったな、と思います。</p>
<h2>なぜ移行するの？C#のどこがいいの？</h2>
<p>ということを、<a href="http://t.co/mxY8JFk7j2">6/11 第90回codeseek＆第30回日本C#ユーザー会 勉強会 「やっぱり.NETだよね」</a>でお話しますので、明日ですが、当日まで申し込みは受け付けてる的なノリがいつもの感じだとあるので、時間あるかたは是非お越しください。そんなにDisってよりは割とSoftな感じです、私の分はいちおー。</p>
<p>珍しく既にスライドは完成していまして、「Static vs Dynamic」「Type for IntelliSense」「Type for Refactoring」「Debugger is Power」「LINQ vs array_xxx」「Razor:Template Engine Revolution」といったようなタイトルが並んでますので、気になった方はどーぞ。</p>
<p>ああ、そう、あとA vs Bにおいて、全てにおけてAのほうがいい、なんてことは絶対にないんですね。どこかしらかはBのほうがよかったり、BならXxxなのに、とかいうようなことも出てくるでしょう。何がどれだけ自分に、自分達に良いのかの選択をしてくのが肝要なので、その選択を考えるための道具になればいいかと思ってます。</p>
</div>
<h1 data-pagefind-sort="date:2013-05-27" data-pagefind-meta="published:2013-05-27"><a href="https://neue.cc/2013/05/27_405.html">HttpClient詳解、或いはAsyncOAuthのアップデートについて</a></h1>
<ul class="date"><li>2013-05-27</li></ul>
<div class="entry_body"><p>すっかり忘れていたわけではないですが、ちょっとかなり前、3/30の<a href="http://metrostyledev.net/index.php/event/20130330/">Room metro #15</a>にて、HttpClient詳解という、HttpClientについてのセッションを行いました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/17899218" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/httpclient" title="HttpClient詳解、或いは非同期の落とし穴について" target="_blank">HttpClient詳解、或いは非同期の落とし穴について</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>HttpClientは、使えば使うほど、もうWebRequestやWebClientに戻りたくないわー、という非常に秀逸な、完全にこれからのスタンダードになる代物なので、きっちり習得しましょう。</p>
<p>或いは非同期の落とし穴について、ということで、async/awaitでも顕在の、いや、async/awaitだからこそ現れるデッドロックの問題と回避方法についても紹介しています。はまる時ははまっちゃうんですよねー、これ、何気に地味に実は。それなりに痛い目みました、私も。</p>
<h2>PCL版のRC</h2>
<p>HttpClientは現在.NET 4.5とWindows Store Appsのほうに標準搭載されていますが、それ以外でも使うために、Portable Class Libraryとしての提供がされています。そして、5/22に<a href="http://blogs.msdn.com/b/dotnet/archive/2013/05/22/portable-httpclient-is-now-available-as-rc.aspx">Portable HttpClient is now available as RC</a>としてRC版がリリースされました！</p>
<p>こないだまでのBeta版だと、AsyncOAuthを使ってTiwtterのストリーミングAPIを読む時に、awaitすると全く戻ってこなくなるという現象がありました。これはAsyncOAuthが悪いのかHttpClientが悪いのか調べたんですが、結果としてHttpClientのバグでした。HttpClientは内部で通信にWebRequestを使っているのですが、それのAllowReadStreamBufferingとAllowWriteStreamBufferingをfalseにセットしなければならないのに、何もセットしない（ことによって結果的にtrueになっている）状態でした。すると、ストリーミングAPIを読むのにバッファを取ろうとして、当然ストリーミングなのでオワリがないので永遠に帰ってこないという……。</p>
<p>ちゃんとバグ報告したら（偉い！←自分で言う）、今回のRC版で直してくれたようです、多分。とりあえずWP8のEmulatorで試した限りでは、ちゃんとストリーミングAPI動きました。よかったよかった。というわけで、AsyncOAuthもver.0.6.4として、新しいHttpClientに依存するようにアップデートしておきました。なお、AsyncOAuthについては<a href="http://neue.cc/2013/02/27_398.html">AsyncOAuth - C#用の全プラットフォーム対応の非同期OAuthライブラリ</a>を読んでくださいな。</p>
<p>そういえば同時に、というか4/17にですが、.NET4などでもasync/awaitを使えるようにする<a href="http://blogs.msdn.com/b/bclteam/archive/2013/04/17/microsoft-bcl-async-is-now-stable.aspx">Microsoft.Bcl.Async</a>はStableになってました。これで気兼ねなくasync使える！</p>
<h2>6月の予定</h2>
<p>6月は何故かいっぱいイベントに出ることになっています。6/8の<a href="http://www.buildinsider.net/event/offline/01">Build Insider OFFLINE</a>、そこで「.NET最先端技術によるハイパフォーマンスウェブアプリケーション」についてお話します。もう席は満席となってしまいましたが、Ustreamでの中継も行われるようですので、よろしければそちらで見ていただければと思います。</p>
<p>また、6/11~14あたりに、<a href="http://csharp-users.jp/">C#ユーザー会</a>で何か話すそうです。何か。何でしょうね。一節によるとPHP被害者友の会（？）だとか・</p>
<p>そして6/22に<a href="http://atnd.org/event/E0015958">つくばC#勉強会</a>でThe History of LINQと題して、何か話すそうです。はい。つくばいいですね！素晴らしいですぅー。つくば勉強会はまだまだ残席あるようなので、みんな参加しよう！登壇者も募集しているようですので、登壇もしよう！</p>
</div>
<h1 data-pagefind-sort="date:2013-04-24" data-pagefind-meta="published:2013-04-24"><a href="https://neue.cc/2013/04/24_404.html">RxとRedisを用いたリモートPub/Sub通信</a></h1>
<ul class="date"><li>2013-04-24</li></ul>
<div class="entry_body"><p>今日から始まった<a href="http://www.buildinsider.net/">Build Insider</a>で、RedisとBookSleeveの記事を書きました - <a href="http://www.buildinsider.net/small/rediscshap/01">C#のRedisライブラリ「BookSleeve」の利用法</a>。Redis、面白いし、Windowsで試すのも想像以上に簡単なので、是非是非試してみて欲しいです。そして何よりもBookSleeve！使うと、強制的に全てがasyncになるので、C# 5.0でのコーディングの仕方のトレーニングになる（笑）。にちじょー的にasync/awaitを使い倒すと、そこから色々アイディアが沸き上がっきます。ただたんにsyncがasyncになった、などというだけじゃなく、アプリケーションの造りが変わります。そういう意味では、Taskは結構過小評価されてるのかもしれないな、なんて最近は思っています。</p>
<p>さて、RedisにはPub/Sub機能がついているわけですが、Pub/Sub→オブザーバーパターン→Rx！これはティンと来た！と、いうわけで、これ、Rxに乗せられました、とても自然に。というわけで、□□を○○と見做すシリーズ、なCloudStructuresにRx対応を載せました。</p>
<ul>
<li><a href="https://github.com/neuecc/CloudStructures">GitHub - CloudStructures</a></li>
<li><a href="https://nuget.org/packages/CloudStructures/">PM&gt; Install-Package CloudStructures -Pre</a></li>
</ul>
<p>追加したクラスはRedisSubject&lt;T&gt;。これはSubjectやAsyncSubjectなどと同じく、ISubject&lt;T&gt;になっています。IObservableであり、IObserverでもある代物。とりあえず、コード例を見てください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var settings = new RedisSettings(&quot;127.0.0.1&quot;);

var subject = new RedisSubject&lt;string&gt;(settings, &quot;PubSubTest&quot;);

// SubscribeはIObservable&lt;T&gt;なのでRxなLINQで書ける
var a = subject
    .Select(x =&gt; DateTime.Now.Ticks + &quot; &quot; + x)
    .Subscribe(x =&gt; Console.WriteLine(x));

var b = subject
    .Where(x =&gt; !x.StartsWith(&quot;A&quot;))
    .Subscribe(x =&gt; Console.WriteLine(x), () =&gt; Console.WriteLine(&quot;completed!&quot;));

// IObserverなのでOnNext/OnError/OnCompletedでメッセージ配信
subject.OnNext(&quot;ABCDEFGHIJKLM&quot;);
subject.OnNext(&quot;あいうえお&quot;);
subject.OnNext(&quot;なにぬねの&quot;);

Thread.Sleep(200); // 結果表示を待つ...

a.Dispose(); // UnsubscribeはDisposeで
subject.OnCompleted(); // OnCompletedを受信したSubscriberもUnsubscribeされる
</code></pre>
<p>はい、別になんてこともない極々フツーのRxのSubjectです。が、しかし、これはネットワークを通って、Redisを通して、全てのSubscriberへとメッセージを配信しています。おお～。いやまあ、コードの見た目からじゃあそういうの分からないので何も感動するところもないのですが、とにかく、本当に極々自然に普通に、しかし、ネットワークを超えます。この、見た目何も変わらずに、というところがいいところなわけです。</p>
<p>Subscribeする側はIObservableなので別にフツーに合成していけますし、Publishする側もIObserverなので、Subscribeにしれっと潜り込ませたりしても構わない。もう、全然、普通にインメモリなRxでやる時と同じことが、できます。</p>
<p>オワリ。地味だ。</p>
<p>う、うーん。ほ、ほらほら！！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ネットワーク経由
var settings = new RedisSettings(&quot;xx.xxx.xxx.xxx&quot;);

var subject = new RedisSubject&lt;DateTime&gt;(settings, &quot;PubSubTest&quot;);

// publisherはこちらのコード
while (true)
{
    Console.ReadLine();
    var now = DateTime.Now;
    Console.WriteLine(now.Ticks);
    subject.OnNext(now);
}

// subscriberはこちらのコードを動かす
subject.Subscribe(x =&gt;
{
    var now = DateTime.Now;
    Console.Write(x.Ticks + &quot; =&gt; &quot; + now.Ticks);
    Console.WriteLine(&quot; | &quot; + (now - x));
});
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/redis_network_pubsub.jpg">
</p>
<p>というわけで、実際にネットワーク経由(AWS上に立てたRedisサーバーを通してる)で動かしてみた結果がこんな感じです。ネットワークを超えたことで用法は幾らでもある！夢膨らみまくり！</p>
<p>で、↑のコードは遅延時間のチェックを兼ねてるのですが、概ね、0.03秒ぐらい。たまにひっかかって0.5秒超えてるのがあって、ぐぬぬですが。実際のとこRedis/Linuxの設定で結構変わってくるところがあるので、その辺は煮詰めてくださいといったところでしょうか。</p>
<p>ともあれチャットとかなら全然問題なし、ゲームでもアクションとかタイミングにシビアじゃないものなら余裕ですね、ボードゲームぐらいなら全く問題ない。ちょっとしたMMOぐらいならいけるかも。これからはネットワーク対戦はRedisで、Rxで！！！</p>
<h2>余談</h2>
<p>CloudStructuresですが、.configからの設定読み込み機能も地味につけました。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;configSections&gt;
    &lt;section name=&quot;cloudStructures&quot; type=&quot;CloudStructures.Redis.CloudStructuresConfigurationSection, CloudStructures&quot; /&gt;
&lt;/configSections&gt;

&lt;cloudStructures&gt;
    &lt;redis&gt;
        &lt;group name=&quot;cache&quot;&gt;
            &lt;add host=&quot;127.0.0.1&quot; /&gt;
            &lt;add host=&quot;127.0.0.2&quot; port=&quot;1000&quot; /&gt;
        &lt;/group&gt;
        &lt;group name=&quot;session&quot;&gt;
            &lt;add host=&quot;127.0.0.1&quot; db=&quot;2&quot; valueConverter=&quot;CloudStructures.Redis.ProtoBufRedisValueConverter, CloudStructures&quot; /&gt;
        &lt;/group&gt;
    &lt;/redis&gt;
&lt;/cloudStructures&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// これで設定を読み込める
var groups = CloudStructuresConfigurationSection.GetSection().ToRedisGroups();
</code></pre>
<p>色々使いやすくなってきて良い感じじゃあないでしょーか。</p>
<h2>コールバック撲滅</h2>
<p>そうそう、最後に実装の話を。元々BookSleeveのPub/Sub購読はコールバック形式です。「public Task Subscribe(string key, Action&lt;string, byte[]&gt; handler)」handlerはstringがキー, byte[]が送られてくるオブジェクトを指します。コールバック is ダサい。コールバック is 扱いにくい。ので、コールバックを見かけたらObservableかTaskに変換することを考えましょう！それがC# 5.0世代の常識です！</p>
<p>というわけで、以下のようにして変換しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public IDisposable Subscribe(IObserver&lt;T&gt; observer)
{
    var channel = Connection.GetOpenSubscriberChannel();

    var disposable = System.Reactive.Disposables.Disposable.Create(() =&gt;
    {
        channel.Unsubscribe(Key).Wait();
    });

    // ここが元からあるコールバック
    channel.Subscribe(Key, (_, xs) =&gt;
    {
        using (var ms = new MemoryStream(xs))
        {
            var value = RemotableNotification&lt;T&gt;.ReadFrom(ms, valueConverter);
            value.Accept(observer); // この中でobserverのOnNext/OnError/OnCompletedが叩かれる
            if (value.Kind == NotificationKind.OnError || value.Kind == NotificationKind.OnCompleted)
            {
                disposable.Dispose(); // ErrorかCompletedでもUnsubscribeしますん
            }
        }
    }).Wait();

    return disposable; // もしDisposableが呼ばれたらUnsubscribeしますん
}
</code></pre>
<p>こんなふぅーにRxで包むことで、相当使いやすさがアップします。感動した。</p>
</div>
<h1 data-pagefind-sort="date:2013-04-05" data-pagefind-meta="published:2013-04-05"><a href="https://neue.cc/2013/04/05_403.html">CloudStructures - ローカルとクラウドのデータ構造を透過的に表現するC# + Redisライブラリ</a></h1>
<ul class="date"><li>2013-04-05</li></ul>
<div class="entry_body"><p>というものを作りました。インストールはNuGetから。</p>
<ul>
<li><a href="https://github.com/neuecc/CloudStructures">GitHub - CloudStructures</a></li>
<li><a href="https://nuget.org/packages/CloudStructures/">PM&gt; Install-Package CloudStructures -Pre</a></li>
</ul>
<p>何を言ってるのかヨクワカラナイので、まずはコード例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public string Name { get; private set; }
    public List&lt;Person&gt; Friends { get; private set; }

    public Person(string name)
    {
        Name = name;
        Friends = new List&lt;Person&gt;();
    }
}

// こんなのがいるとして
var sato = new Person(&quot;さとう&quot;);

// 人を足す
sato.Friends.Add(new Person(&quot;やまだ&quot;));
sato.Friends.Add(new Person(&quot;いとう&quot;));

// 件数数える
var friendCount = sato.Friends.Count;
</code></pre>
<p>これは普通にローカルで表現する場合です。実に普通です。では、次。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// RedisServerの設定の表現
public static class RedisServer
{
    public static readonly RedisSettings Default = new RedisSettings(&quot;127.0.0.1&quot;);
}

// こんなクラスがあるとして
public class Person
{
    public string Name { get; private set; }
    public RedisList&lt;Person&gt; Friends { get; private set; }

    public Person(string name)
    {
        Name = name;
        Friends = new RedisList&lt;Person&gt;(RedisServer.Default, &quot;Person-&quot; + Name);
    }
}

// こんなのがいるとして
var sato = new Person(&quot;さとう&quot;);

// 人を足す
await sato.Friends.AddLast(new Person(&quot;やまだ&quot;));
await sato.Friends.AddLast(new Person(&quot;いとう&quot;));

// 件数数える
var friendCount = await sato.Friends.GetLength();
</code></pre>
<p>この場合、Redisを通してサーバー上にデータは保存されています。ですが、操作感覚はローカルにあるものとほぼほぼ同じです。違いは全ての操作が非同期なので、awaitするぐらい。</p>
<h2>IAsyncList</h2>
<p>これは、<a href="http://actorfx.codeplex.com/">Actor Framework for Windows Azure</a>のDistributed Collectionsに影響を受けています。ActorFxのそれは、SOURCE CODEを落としてdocsフォルダの Distributed Collections using the ActorFx.docx に色々書いてあって面白いので必読です。</p>
<p>そして、ActorFxではSystem.Cloud.Collectionsとして(System名前空間！)、現状、以下のようなインターフェイスが定義されています（まだ変更の可能性大いにあり）。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace System.Cloud.Collections
{
    public interface IAsyncCollection&lt;T&gt; : IObservable&lt;T&gt;
    {
        Task&lt;int&gt; CountAsync { get; }
        Task&lt;bool&gt; IsReadOnlyAsync { get; }

        Task AddAsync(T item);
        Task ClearAsync();
        Task&lt;bool&gt; ContainsAsync(T item);
        Task CopyToAsync(T[] array, int arrayIndex);
        Task&lt;bool&gt; RemoveAsync(T item);
    }

    public interface IAsyncList&lt;T&gt; : IAsyncCollection&lt;T&gt;
    {
        Task&lt;T&gt; GetItemAsync(int index);
        Task SetItemAsync(int index, T value);
        Task&lt;int&gt; IndexOfAsync(T item);
        Task InsertAsync(int index, T item);
        Task RemoveAtAsync(int index);

        // Less chatty versions
        Task AddAsync(IEnumerable&lt;T&gt; items);
        Task RemoveRangeAsync(int index, int count);
    }

    public interface IAsyncDictionary&lt;TKey, TValue&gt; : IAsyncCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;
    {
        Task&lt;TValue&gt; GetValueAsync(TKey key);
        Task SetValueAsync(TKey key, TValue value);
        Task&lt;Tuple&lt;bool, TValue&gt;&gt; TryGetValueAsync(TKey key);

        // No AddAsync - use SetValueAsync instead.  We have no atomic operation to add iff a value is not in the dictionary.
        Task&lt;bool&gt; ContainsKeyAsync(TKey key);
        Task&lt;bool&gt; RemoveAsync(TKey key);

        // Bulk operations
        Task&lt;ICollection&lt;TValue&gt;&gt; GetValuesAsync(IEnumerable&lt;TKey&gt; keys);
        Task SetValuesAsync(IEnumerable&lt;TKey&gt; keys, IEnumerable&lt;TValue&gt; values);
        Task RemoveAsync(IEnumerable&lt;TKey&gt; keys);

        ICollection&lt;TKey&gt; Keys { get; }
        ICollection&lt;TValue&gt; Values { get; }
    }
}
</code></pre>
<p>わくわくしてきません？私はこの定義を見た瞬間に衝撃を受けました。RxのIObservable&lt;T&gt;を見た時と同程度の衝撃かもわからない。Ax(ActorFx)の実装としてはCloudList, CloudDictionary, CloudStringDictionaryがありますが(基盤としてAzure Table)、見てすぐにRedisと結びついた。Redisの持つデータ構造、List, Hash, Set, SortedSetってこれじゃないか！って。こういう風に表現されたらどれだけ素敵な見た目になるか……！</p>
<h2>Strings, Set, SortedSet, List, Hash, その他</h2>
<p>というわけで、最初の例ではRedisListだけ出しましたが、StringsもSetもSortedSetもHashもあります。また、HashClassやMemoizedRedisStringといった特殊なものも幾つか用意してあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// フィールドに持たなくても、ふつーにRedisClient的に使ってもいいよ
var client = new RedisString&lt;string&gt;(RedisServer.Default, &quot;toaru-key&quot;);
await client.Set(&quot;あいうえお!&quot;, expirySeconds: TimeSpan.FromMinutes(60).TotalSeconds);

// RedisClassはRedisのHash構造をクラスにマッピングするもの
var hito = new RedisClass&lt;Hito&gt;(RedisServer.Default, &quot;hito-1&quot;);
await hito.SetField(&quot;Name&quot;, &quot;やまもと&quot;);
await hito.Increment(&quot;Money&quot;, 100);

var localHito = await hito.GetValue(); // Cloud -&gt; Localに落とす、的ないめーぢ
</code></pre>
<p>実際色々あるので見て回ってください！</p>
<h2>ConnectionManagement</h2>
<p>基盤的な機能として、BookSleeveの接続管理を兼ねています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Redisの設定を表す
var settings = new RedisSettings(host: &quot;127.0.0.1&quot;, port: 6379, db: 0);

// BookSleeveはスレッドセーフで単一のコネクションを扱う
// コネクションを一つに保ったり切断されていた場合の再接続などをしてくれる
var conn = settings.GetConnection();


// 複数接続はRedisGroupで管理できる
var group = new RedisGroup(groupName: &quot;Cache&quot;, settings: new[]
{
    new RedisSettings(host: &quot;100.0.0.1&quot;, port: 6379, db: 0),
    new RedisSettings(host: &quot;105.0.0.1&quot;, port: 6379, db: 0),
});

// keyを元に分散先のサーバーを決める（デフォルトはMD5をサーバー台数で割って決めるだけの単純な分散）
var conn = group.GetSettings(&quot;hogehoge-100&quot;).GetConnection();

// シリアライザはデフォルトではJSONとProtoBufを用意（未指定の場合はJSON）
new RedisSettings(&quot;127.0.0.1&quot;, converter: new JsonRedisValueConverter());
new RedisSettings(&quot;127.0.0.1&quot;, converter: new ProtoBufRedisValueConverter());
</code></pre>
<p>って、ここまで<a href="https://code.google.com/p/booksleeve/">BookSleeve</a>の説明がなかった！BookSleeveはRedisのライブラリで、非同期の操作のみを提供しています。CloudStructuresのRedis操作はBookSleeveに全部委ねてます。というかぶっちゃけ、かなり単純なラップがほとんどだったりします（！）。見せ方を変えただけ、です、よーするところ。</p>
<p>んで、BookSleeveは斬新で非常に良いライブラリなのですけれど、操作が本当にプリミティブなものしかないので（全てのGetとSetがstringとbyte[]しかない、とかね）、ある程度、自分で作りこんでやらないと全く使えません。なので、この部分だけでも、結構使えるかなって思います。</p>
<h2>Next</h2>
<p>個人的にはすっごく面白いと思ってます。見せ方の違いでしかないわけですが、しかし、その見せ方の違いというのが非常に大事なのです。直感的、ですが、ある種奇抜なデザインなので、戸惑うとは思います。異色度合いで言ったら、以前に私の作ったReactivePropertyと同程度に異色かな、と。だからこそ、凄く大きな可能性を感じませんか？</p>
<p>ちなみに、これは（いつものように）コンセプト止まりじゃなくて、実際に使う予定アリなので、しっかり育ててく気満々です。是非、試してみてもらえると嬉しいですね。</p>
</div>
<h1 data-pagefind-sort="date:2013-04-02" data-pagefind-meta="published:2013-04-02"><a href="https://neue.cc/2013/04/02_402.html">Microsoft MVP for Visual C#を再再受賞しました</a></h1>
<ul class="date"><li>2013-04-02</li></ul>
<div class="entry_body"><p>今年も再受賞することができました。去年は某g社のフロントに立って、というのもあって、オフライン活動が割と非常に活発でした。ブログは量は減りましたし、中身も職業柄ウェブ系の要素が濃くなった感。とはいえ、内容自体は結構面白げなC#の内容になってたのではかしらん。基本的には、他で得られない情報や、ディープに踏み込んだ先の話、新しい考え。そういったのを提供し続けたいです。</p>
<p>今年はもっともっと面白くしたい。去年に、私は</p>
<blockquote>
<p>C#を世間（といっても、技術系の人に、ですね）に強くアピールするにはどうすればいいのか、といったら、一番大事なのはそれで書かれたメジャーなアプリケーションなのです。PerlではてなやMixi、livedoorなどを思い浮かべる、RubyでCookpadを、ScalaでFoursquareやTwitterを、そういった憧れにも似た気持ちを浮かべさせるようなアプリケーションがなければいけなくて。</p>
</blockquote>
<blockquote>
<p>Stack OverflowはC#, ASP.NET MVCだし、TIOBEのプログラミング言語ランキングでは三位など、海外でのC#の地位は十分に高い。のですが、国内ではそれと比べれば全くもってない。日本で誰もが知る会社の誰もが知るアプリケーション、それがC#で書かれている。そういう状態にならなければ、日本で強く普及は無理だな、と。</p>
</blockquote>
<p>と言いました。今年はそれを実現するため、<a href="http://grani.jp/">謎社（もう謎ではない）</a>のCTOとして、人の憧れるような、日本を代表するC#の企業にします。C#による圧倒的な成果、C#だからこその強さ、というのを現実に示していく。幸い、私は今、それができる場所にいると思っています。</p>
<p>そんなわけで、今年もよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2013-03-27" data-pagefind-meta="published:2013-03-27"><a href="https://neue.cc/2013/03/27_401.html">C#のラムダ式でyieldっぽい何かをawaitで代用する方法</a></h1>
<ul class="date"><li>2013-03-27</li></ul>
<div class="entry_body"><p>C#がインラインでyield書けないならawait使えばいいじゃない。と、偉い人は言いました。というわけで、こそこそっと開発がされているIxに、面白い機能が入りました（開発リポジトリ上だけなのでNuGetからダウンロードしても、まだ入ってません）。こんなのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var hoge = &quot;あいうえお&quot;;

var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    await Yield.Return(100);

    hoge = &quot;ふがふが&quot;; // インラインで書けるのでお外への副作用が可能

    await Yield.Return(1000);
});


foreach (var item in seq)
{
    Console.WriteLine(item); // 10, 100, 1000
}
Console.WriteLine(hoge); // ふがふが
</code></pre>
<p>そう、yield return(っぽい何か)がラムダ式で、メソッド外部に出すことなく書けてしまうのです！これは素敵ですね？い、いや、なんか何やってるのか分からなすぎて黒魔術怖いって雰囲気も漂ってますね！しかし面白いものは面白いので、実装見ましょう。</p>
<p><a href="http://rx.codeplex.com/SourceControl/changeset/8f1e73bca96e">add types iyielder, iawaitable, and iawait; add support for creating ienumerable from action<iyielder>.</a>ということで、まあ、ローカルで動かしたいんでコピペってきましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class EnumerableEx
{
    public static IEnumerable&lt;T&gt; Create&lt;T&gt;(Action&lt;IYielder&lt;T&gt;&gt; create)
    {
        if (create == null) throw new ArgumentNullException(&quot;create&quot;);

        foreach (var x in new Yielder&lt;T&gt;(create))
        {
            yield return x;
        }
    }
}

public interface IYielder&lt;in T&gt;
{
    IAwaitable Return(T value);
    IAwaitable Break();
}

public interface IAwaitable
{
    IAwaiter GetAwaiter();
}

public interface IAwaiter : ICriticalNotifyCompletion
{
    bool IsCompleted { get; }
    void GetResult();
}

public class Yielder&lt;T&gt; : IYielder&lt;T&gt;, IAwaitable, IAwaiter, ICriticalNotifyCompletion
{
    private readonly Action&lt;Yielder&lt;T&gt;&gt; _create;
    private bool _running;
    private bool _hasValue;
    private T _value;
    private bool _stopped;
    private Action _continuation;

    public Yielder(Action&lt;Yielder&lt;T&gt;&gt; create)
    {
        _create = create;
    }

    public IAwaitable Return(T value)
    {
        _hasValue = true;
        _value = value;
        return this;
    }

    public IAwaitable Break()
    {
        _stopped = true;
        return this;
    }

    public Yielder&lt;T&gt; GetEnumerator()
    {
        return this;
    }

    public bool MoveNext()
    {
        if (!_running)
        {
            _running = true;
            _create(this);
        }
        else
        {
            _hasValue = false;
            _continuation();
        }

        return !_stopped &amp;&amp; _hasValue;
    }

    public T Current
    {
        get
        {
            return _value;
        }
    }

    public IAwaiter GetAwaiter()
    {
        return this;
    }

    public bool IsCompleted
    {
        get { return false; }
    }

    public void GetResult() { }


    public void OnCompleted(Action continuation)
    {
        _continuation = continuation;
    }

    public void UnsafeOnCompleted(Action continuation)
    {
        _continuation = continuation;
    }
}
</code></pre>
<p>ほぅ、わけわからん？若干トリッキーなので、順を追っていきますか。asyncについて考える前に、まず、基本的なforeachのルール。実はIEnumerableを実装している必要はなくて、GetEnumeratorという名前のメソッドがあればいい。同様にMoveNextとCurrentというメソッドがあればIEnumerator扱いされる。なので、foreach (var x in new Yielder<T>(create)) されているYielderはIEnumerableじゃないし、GetEnumeratorでreturn thisされていますが、YielderはIEnumeratorでもない。でも、foreachでグルグル回せている、というわけです。挙動は通常のforeachと同じで、MoveNext→Current、といった形です。</p>
<p>あと、インターフェイスが、IAwaitableとかいっぱい再定義されてて、ワケワカランのですけれど、そこまで意味あるわけじゃないです。これはラムダ式にYielderを渡すわけですが、そこで内部の諸々が呼べちゃうのはイクナイので隠ぺいする、程度の意味合いでしかないので、これを実装するのにインターフェイスの再定義が必要！というわけは全然ないです。</p>
<p>で、コアになるのはMoveNext。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public bool MoveNext()
{
    if (!_running)
    {
        _running = true;
        _create(this);
    }
    else
    {
        _hasValue = false;
        _continuation();
    }

    return !_stopped &amp;&amp; _hasValue;
}
</code></pre>
<p>そもそもyield returnで生成されたメソッドが最初に実行されるのは、GetEnumeratorのタイミングではなく、GetEnumeratorされて最初のMoveNextが走った時、なので、ここが本体になっているのはセマンティクス的に問題なし。</p>
<p>!_runnningは初回実行時の意味で、ここで_create(this)、によってラムダ式で書いた本体が走ります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    // ↑のとこがまず実行され始める
    await Yield.Return(100);
    await Yield.Return(1000);
});

public IAwaitable Return(T value)
{
    _hasValue = true;
    _value = value;
    return this;
}
</code></pre>
<p>まずはメソッド実行なのでReturn。これは値をセットして回っているだけ。そしてIAwaitableを返し、await。ここで流れは別のところに行きます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public bool IsCompleted
{
    get { return false; }
}

public void GetResult() { }


public void OnCompleted(Action continuation)
{
    _continuation = continuation;
}

public void UnsafeOnCompleted(Action continuation)
{
    _continuation = continuation;
}
</code></pre>
<p>まず完了しているかどうかの確認(IsCompleted)が走りますが、この場合は常にfalseで(そうしないと終了ということになってラムダ式のほうに戻ってこなくなっちゃう)。これによってUnsafeOnCompleted(ICriticalNotifyCompletionが実装されている場合はこっちが走る)でcontinuation(メソッド本体)が走る。で、「次回用」に変数保存して、MoveNext(create(this)したとこの位置)に戻ってくる。あとはMoveNextがtrueを返すのでCurrentで値取得して、それがyield returnされる。</p>
<p>二度目のMoveNextでは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public bool MoveNext()
{
    if (!_running)
    {
        _running = true;
        _create(this);
    }
    else
    {
        _hasValue = false;
        _continuation(); // ここが呼び出されて
    }

    return !_stopped &amp;&amp; _hasValue;
}

var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    // ここから再度走り出す
    await Yield.Return(100);
    await Yield.Return(1000);
});
</code></pre>
<p>といった感じになって、以下繰り返し。良く出来てますね！ていうか、asyncなのに非同期全く関係ないのが素敵。そう、asyncは別に非同期関係なく使えちゃうわけです。ここ大事なので繰り返しましょう。asyncは別に非同期関係なく使うことができます。</p>
<h2>まとめ</h2>
<p>async、フツーに使うのもそろそろ飽きてき頃だと思うので、弄って遊ぶのは大正義。実際に投下しだすかどうかは判断次第。あと、↑のはまだ大事な要素ができていないので絶対使いませんけれど。大事な要素はIDisposableであること。foreachで大事だと思ってるのはDisposeしてくれるとこ！だとも思っているので、それが実現できてないのはナイナー、と。</p>
<p>そういえばAsyncについてですが、3/30の土曜に<a href="http://metrostyledev.net/index.php/event/20130330/">Room metro #15</a>でHttpClient(非同期の塊！)について話すので、まだ残席ありますので良ければお越しくだしあー。</p>
</div>
<h1 data-pagefind-sort="date:2013-03-09" data-pagefind-meta="published:2013-03-09"><a href="https://neue.cc/2013/03/09_400.html">並列実行とSqlConnection</a></h1>
<ul class="date"><li>2013-03-09</li></ul>
<div class="entry_body"><p>どうも、ParallelやThreadな処理が苦痛度100なペチパーです。嘘です。空前のThreadLocalブームが来てたり来てなかったりする昨今です。あ、謎社の宣伝しますと<a href="http://corp.gree.net/jp/ja/news/press/2013/0308-01.html">グリーとグラニ、「GREE」におけるソーシャルゲームの提供などについて戦略的業務提携に合意</a>というわけで、ぐりとぐら、としかいいようがない昨今でもあります。その日に開催されていたGREEプラットフォームカンファレンスでは、謎社はC#企業になる！と大宣言したので、ちゃんと実現させていきたいところです、いや、むしろそのためにフル回転しています。</p>
<p>そんな宣伝はおいておいて本題なのですけれど、SQL。データベース。大量にクエリ発行したい時など、パラレル実行したいの！インサートだったら当然BulkInsertが一番早いんですが、Updateとかね。シンドイんだよね。あとUpsert(Merge/ON DUPLICATE KEY UPDATE)とかも使っちゃったりしてね。そんなわけで、お手軽お気楽な手法としてはParallelがありますねー、.NETはこの辺本当に楽なんだよねー、ぴーHPはシラネ。</p>
<p>で、実際パラレールにこんな感じに書くと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var connection = new SqlConnection(&quot;接続文字列&quot;))
{
    connection.Open();
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>落ちます。理由は単純明快でSqlConnectionはスレッドセーフじゃないから。というわけで、やるなら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Parallel.For(1, 1000, x =&gt;
{
    using (var connection = new SqlConnection(&quot;接続文字列&quot;))
    {
        connection.Open();
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    }
});
</code></pre>
<p>となります、これなら絶対安全。でも、スレッドって基本的にコアの数とちょびっとしか立てられないわけだし、連続的に実行しているのだから、たとえコネクションプール行きだとかなんだりであっても、一々コネクションを開いて閉じてをするよりも、開きっぱで行きたいよね。</p>
<p>ようするにSqlConnectionがスレッドセーフじゃないからいけない。これはどこかで聞いたような話です。先日<a href="http://neue.cc/2013/03/06_399.html">C#とランダム</a>で出したThreadLocalの出番ではないでしょうか！</p>
<h2>ThreadLocal</h2>
<p>というわけでスレッドセーフなSqlConnectionを作りましょう、ThreadLocalを使って。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var connection = new ThreadLocal&lt;SqlConnection&gt;(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }))
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>new SqlConnectionがThreadLocalに変わっただけのお手軽さ。これで、安全なんですって！本当に？本当に。で、実際こうして速度はどうなのかというと、私の環境で実行したところ、シングルスレッドで16秒、毎回new SqlConnectionするParallelで5秒、ThreadLocalなParallelで2秒でした。これは圧勝。幸せになれそう。</p>
<h2>Disposeを忘れない、或いは忘れた</h2>
<p>でも↑のコードはダメです。ダメな理由は、コネクションをDisposeしてないからです。ThreadLocalのDisposeは、あくまでThreadLocalのDisposeなのであって、中身のDisposeはしてくれてないのです。ここ忘れると悲劇が待ってます。でもFactoryで作ってる上にThreadで一意なValue、どうやってまとめてDisposeすればいいの！というと、trackAllValuesというオプションを有効にすると簡単に実現できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var connection = new ThreadLocal&lt;SqlConnection&gt;(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }
    , trackAllValues: true)) // ThreadLocalの.Valuesプロパティの参照を有効化する
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });

    // 生成された全てのConnectionを一括Dispose
    foreach (var item in connection.Values.OfType&lt;IDisposable&gt;()) item.Dispose();
}
</code></pre>
<p>この<a href="http://msdn.microsoft.com/ja-jp/library/hh139139.aspx">trackAllValuesが可能なThreadLocal</a>は.NET 4.5からです。それ以前の人は、残念でした……。謎社は遠慮なく.NET 4.5を使いますので全然問題ありません(</p>
<h2>もう一つまとめて</h2>
<p>とはいえ、なんか面倒くさいので、ちょっとラップしませう、以下のようなクラスを用意します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class DisposableThreadLocal
{
    public static DisposableThreadLocal&lt;T&gt; Create&lt;T&gt;(Func&lt;T&gt; valueFactory)
        where T : IDisposable
    {
        return new DisposableThreadLocal&lt;T&gt;(valueFactory);
    }
}

public class DisposableThreadLocal&lt;T&gt; : ThreadLocal&lt;T&gt;
    where T : IDisposable
{
    public DisposableThreadLocal(Func&lt;T&gt; valueFactory)
        : base(valueFactory, trackAllValues: true)
    {

    }

    protected override void Dispose(bool disposing)
    {
        var exceptions = new List&lt;Exception&gt;();
        foreach (var item in this.Values.OfType&lt;IDisposable&gt;())
        {
            try
            {
                item.Dispose();
            }
            catch (Exception e)
            {
                exceptions.Add(e);
            }
        }

        base.Dispose(disposing);

        if (exceptions.Any()) throw new AggregateException(exceptions);
    }
}
</code></pre>
<p>これを使うと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var connection = DisposableThreadLocal.Create(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }))
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>といったように、超シンプルに書けます。うん。いいね。</p>
<h2>それAsync？</h2>
<p>Asyncでドバッと発行してTask.WhenAll的なやり方も、接続が非スレッドセーフなのは変わらなくて、結構やりづらいんですよ……。それで、なんか色々細かくawaitしまくりで逆に遅くなったら意味ないし。それならドストレートに行ったほうがいいのでは感が若干ある。どうせThreadなんてそこそこ余ってるんだから（←そうか？）局所的にParallelってもいいぢゃないと思いたい、とかなんとかかんとか。</p>
<h2>非.NET 4.5の場合</h2>
<p>Parallel.For, ForEachに関しては、localInit, localFinallyというタスク内で一意になる変数を利用したオーバーロードを利用して、似たような雰囲気で書けます。正確には同じ挙動ではないですが、まぁまぁ悪くない結果が得られます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Parallel.For(1, 1000,
    () =&gt;
    {
        // local init
        var conn = new SqlConnection(&quot;接続文字列&quot;);
        conn.Open();
        return conn;
    },
    (x, state, connection) =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
        return connection;
    },
    (connection) =&gt;
    {
        // local finally
        connection.Dispose();
    });
</code></pre>
<p>オーバーロードが結構地獄でシンドイですね！ここも簡単にラップしたものを作りましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ParallelEx
{
    public static ParallelLoopResult DisposableFor&lt;TDisposable&gt;(long fromInclusive, long toExclusive, Func&lt;TDisposable&gt; resourceFactory, Action&lt;long, ParallelLoopState, TDisposable&gt; body)
        where TDisposable : IDisposable
    {
        return Parallel.For(fromInclusive, toExclusive, resourceFactory, (item, state, resource) =&gt; { body(item, state, resource); return resource; }, disp =&gt; disp.Dispose());
    }

    public static ParallelLoopResult DisposableForEach&lt;T, TDisposable&gt;(IEnumerable&lt;T&gt; source, Func&lt;TDisposable&gt; resourceFactory, Action&lt;T, ParallelLoopState, TDisposable&gt; body)
        where TDisposable : IDisposable
    {
        return Parallel.ForEach(source, resourceFactory, (item, state, resource) =&gt; { body(item, state, resource); return resource; }, disp =&gt; disp.Dispose());
    }
}
</code></pre>
<p>こうしたものを作れば、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">ParallelEx.DisposableFor(1, 1000,
    () =&gt;
    {
        var conn = new var conn = new SqlConnection(&quot;接続文字列&quot;);
        conn.Open();
        return conn;
    },
    (x, state, connection) =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
</code></pre>
<p>まぁまぁ許せる、かな？</p>
</div>
<h1 data-pagefind-sort="date:2013-03-06" data-pagefind-meta="published:2013-03-06"><a href="https://neue.cc/2013/03/06_399.html">C#とランダム</a></h1>
<ul class="date"><li>2013-03-06</li></ul>
<div class="entry_body"><p>古くて新しいわけはない昔ながらのSystem.Randomのお話。Randomのコンストラクタは二種類あって、seed引数アリの場合は必ず同じ順序で数値を返すようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 何度実行しても同じ結果
var rand = new Random(0);
Console.WriteLine(rand.Next()); // 1559595546
Console.WriteLine(rand.Next()); // 1755192844
Console.WriteLine(rand.Next()); // 1649316166
</code></pre>
<p>例えばゲームのリプレイなどは、ランダムだけど同一の結果が得られることを期待したいわけなので、大事大事ですね。(とはいえ、Windows-CLIとLinux-monoでは結果が違ったりするので、マルチプラットフォームでの共有などという場合は、別策を取ったほうがよさそうです)。何も渡さない場合はseedとしてEnvironment.TickCountが渡されます。精度はミリ秒。ということは、ですね、例えばループの中でRandomをnewするとですよ、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">for (int i = 0; i &lt; 100; i++)
{
    var rand = new Random();
    Console.WriteLine(rand.Next());
}
</code></pre>
<p>マシンスペックにもよりますが、私の環境では30個ぐらい同じ数値が出た後に、別の、また30個ぐらい同じ数値が続き……となりました。何故か、というと、seedがEnvironment.TickCountだからで、ループ内といったようなミリ秒を超える超高速の状態で生成されている時は、seed値が同じとなってしまうから。なので、正しくは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var rand = new Random();
for (int i = 0; i &lt; 100; i++)
{
    Console.WriteLine(rand.Next());
}
</code></pre>
<p>といったように、ループの外に出す必要性があります。</p>
<h2>ランダムなランダム</h2>
<p>では、ランダムなランダムが欲しい場合は。例えばマルチスレッド。そうでなくても、例えばループの外に出す（直接的でなくてもメソッドの中身がそうなっていて、意図せず使われてしまう可能性がある）のを忘れてしまうのを強制的に避ける場合。もしくは、別にマルチスレッドは気を付けるよー、といっても、ASP.NETとか複数リクエストが同時に走るわけで、同タイミングでのRandom生成になってしまう可能性は十分にある。そういう時は、RandomNumberGeneratorを使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var rng = new RNGCryptoServiceProvider())
{
    // 厳密にランダムなInt32を作る
    var buffer = new byte[sizeof(int)];
    rng.GetBytes(buffer);
    var seed = BitConverter.ToInt32(buffer, 0);
    // そのseedを基にRandomを作る
    var rand = new Random(seed);
}
</code></pre>
<p>これでマルチスレッドでも安全安心だ！勿論、RNGCryptoServiceProviderはちょっとコスト高。でも、全然我慢できる範囲ではある。お終い。</p>
<h2>ThreadLocal</h2>
<p>でも、これって別にスレッドセーフなランダムが欲しいってだけなわけだよね、それなのにちょっとした、とはいえ、コスト高を背負うのって馬鹿げてない？そこで出てくるのが<a href="http://msdn.microsoft.com/ja-jp/library/dd642243.aspx">ThreadLocal&lt;T&gt;</a>、.NET 4.0以降ですが、スレッド単位で一意な変数を宣言できます。それを使った、<a href="http://csharpindepth.com/Articles/Chapter12/Random.aspx">Jon Skeet氏（ゆーめーじん）の実装</a>は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class RandomProvider
{    
    private static int seed = Environment.TickCount;
    
    private static ThreadLocal&lt;Random&gt; randomWrapper = new ThreadLocal&lt;Random&gt;(() =&gt;
        new Random(Interlocked.Increment(ref seed))
    );

    public static Random GetThreadRandom()
    {
        return randomWrapper.Value;
    }
}
</code></pre>
<p>なるほどねー！これなら軽量だし、とってもセーフで安心できるしイイね！もし複数スレッドで同時タイミングで初期化が走った時のために、Interlocked.Incrementで、必ず違う値がseedになるようになってるので、これなら色々大丈夫。</p>
<h2>マルチスレッド→マルチサーバー</h2>
<p>けれど、大丈夫なのは、一台のコンピューターで完結する時だけの時の話。クラウドでしょ！サーバー山盛りでしょ！な時代では、サーバーをまたいで同時タイミングなEnvironment.TickCountで初期化されてしまう可能性が微レ存。というわけで、Environment.TickCountに頼るのは完全に安全ではない。じゃあ、そう、合わせ技で行けばいいじゃない、seedは完全ランダムで行きましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class RandomProvider
{
    private static ThreadLocal&lt;Random&gt; randomWrapper = new ThreadLocal&lt;Random&gt;(() =&gt;
    {
        using (var rng = new RNGCryptoServiceProvider())
        {
            var buffer = new byte[sizeof(int)];
            rng.GetBytes(buffer);
            var seed = BitConverter.ToInt32(buffer, 0);
            return new Random(seed);
        }
    });

    public static Random GetThreadRandom()
    {
        return randomWrapper.Value;
    }
}
</code></pre>
<p>これで、軽量かつ安全安泰なRandomが手に入りました。めでたしめでたし。</p>
</div>
<a href="https://neue.cc/11">Prev |</a>
<a href="https://neue.cc/13">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
