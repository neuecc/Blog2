<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2013/06/10_406.html">.NET最先端技術によるハイパフォーマンスウェブアプリケーション FAQ</a></h1>
<ul class="date"><li>2013-06-10</li></ul>
<div class="entry_body"><p>Build Insider Offlineにて、「.NET最先端技術によるハイパフォーマンスウェブアプリケーション」と題して、グラニのC#によるウェブアプリケーション作成の仕組みについて話してきました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/22662425" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/net-22662425" title=".NET最先端技術によるハイパフォーマンスウェブアプリケーション" target="_blank">.NET最先端技術によるハイパフォーマンスウェブアプリケーション</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>一日でViewsが1万、はてブが250と、ドトネト系にしては珍しく多くの人に見てもらえたようでなにより。</p>
<p>今までのC#関連って、MS純正ライブラリを使ったどうのこうの、というのはありましたが、外部ライブラリを組み合わせて、実践的にどうしているかっていうような話ってほとんどなかったんですよね。やってるところがない、ことはないのですが、しかし表にない、見えないものはないに等しいです。</p>
<p>別にC#だって自分達の手でライブラリを選び、作り、組み上げていく。それがこれからの時代のスタンダードです。遅れていたのかもしれません。しかし、遅すぎるなんてことはない。素材は良いし、.NETは死んだのでなく、むしろ風が吹いてきている。リアルなモデルケースとして、引っ張っていけたらと思っています。</p>
<h2>FAQ</h2>
<ul>
<li>今時Windowsサーバー？</li>
</ul>
<p>AWSやAzureなどで簡単にWindowsインスタンスの立ち上げが可能なので、今時というか普通に選択肢に入ってくれるといいですねえ、これからは。ウェブ＝LAMPとか誰が決めたの？という話で。コスト面ではそんなに高くなるわけでもないし、それで開発効率が上がったり、サーバー台数が削減されるなら、むしろプラスです。開発効率に関しては人員次第ですが、うちのメンバーの習熟度で言ったら間違いなく上がります、圧倒的に。</p>
<ul>
<li>サーバーサイドでトラフィック以外がくってるのおかしい</li>
</ul>
<p>そうそう、一般的にウェブではネックなのは通信部分だけ、と思っていたことも有りました。でもまぁ、クックパッドの<a href="http://techlife.cookpad.com/2013/06/07/rubykaigi-high-performance-rails/">Rails アプリケーションのパフォーマンスについて RubyKaigi 2013 で発表しました</a>のスライドのResponse time breakdownのところ。SQLが20%がRubyが80%とあるんですね。うちのグラフと一緒？CakePHPはとにかくアレなわけですが、重量級フレームワークは割とそうなるもんなのかしらねえ、と少しだけホッとしたような絶望したような。</p>
<p>先入観じゃなくちゃんとモニタリングしてくのが大事、と当たり前の話ですけれど。スライドでも推しましたが<a href="http://newrelic.com/">New Relic</a>は本当に最高なので、よほどの事情がない限りは入れるべきかなぁ、と。PHP, Ruby, Java, .NET, Python, Node.js、多くの言語に対応しています。確実にパワーは喰いますが、それでも全然お釣りくる。</p>
<ul>
<li>アプリケーションサーバー:DBマスター:DBスレーブの比率がおかしい</li>
</ul>
<p>ええと、これ、実質的にはSlaveは0です。色々な経緯があって、アプリ本体からは参照も全てMasterにし
か振ってません。Slaveの用途は管理画面からの参照用とか、その程度です（スタンバイという点でも、RDSのMulti-AZを利用しているので意味は無い）。となると比率はますますオカシクなるわけですが、うーん、まあ、今時のDBってなんだかんだで頑丈ですからねえ、そう増えないかなあ。しかしそれにしてもアプリケーションサーバーの台数が多すぎなのは、まぁもう本当にすみませんすみませんって感じなわけなのですが。みんなCakePHP触ってみるといいですよ、XHProfにかけると絶望しますから。</p>
<p>勿論チューニングの余地はあります。ありますし、最後にはCakePHPを捨てるというところになることも見えるし、PHPにこだわる理由がどこにもありません。それならC#移行に、といったところですね。とはいえ実際のとこ増え続けることによる歪みが色々発生してるので、ヒィヒィ言いながら適宜対処してます。あと、最低限というか割とそれなりにはCakePHP本体に手を入れたりもしてはいるんですけど、それでも中々どうにも。</p>
<ul>
<li>PHPのLINQあるよ</li>
</ul>
<p>ないよ。幾つかのPHP-LINQライブラリを、コードも読んで評価しましたが、ゴミという結論に達しました。私は<a href="http://linqjs.codeplex.com/">JavaScriptにLINQ移植</a>したりとかしているので、LINQにはこだわりがありひじょーにうるさいのです。あとCakePHPに含まれてるコレクション系のメソッドもゴミですね。かわりに自作したLINQっぽいコレクション処理用の何かを使っています。PHP 5.4を使っているので、ラムダとかもがしがし使えはするので、メソッドチェーンでフィルターやグルーピング、複数キーのソートとか一通りできるように作りました。これ作ってなかったら死んでたわ……。ただ、簡易的な実装なので遅延実行ではありません。最近発表された<a href="http://akanehara.info/phpcon/ginq/#/">Ginq</a>は非常に良いですね！もっと前にあったら、採用していたかもしれません。</p>
<ul>
<li>「何でもハッシュに詰めるしかない」</li>
</ul>
<p>ここ説明が足りなくてアレでしたね、申し訳ないです。文脈としてはIntelliSenseが効くか効かないか、の話しかするつもりなかったのと、ハッシュだろうとオブジェクトだろうとDBからの戻り値の場合はどうせ効かないのでどうでもいい、といった感だったので不正確でした、すみません。</p>
<p>あ、DBから以外の部分で、Modelとして作りこむところでは普通にclass立てたり、TypeHinting使ったりPhpDoc書いたりして、補完がなるべく効きやすいように作ってはいますよ。IDE信奉者なので、<a href="http://www.jetbrains.com/phpstorm/">PhpStorm</a>を会社で購入して使っていますので。とはいえ、タイプヒンティングやPHPDocでも、PHP自体がゆるふわなので効きめはイマイチなんですよ。じゃあ、PHP自体がのゆるふわさを捨てて完全にガチガチに書くか？といったら、それはそれでイマイチになるので、まぁ、半分諦めるのがいいかな、とは。</p>
<p>一応誤解なきように弁解すると、無知のC#モノがイヤイヤPHP使ってるだけでPHPについて何も分かっちゃいない、というほどに分かってないわけではないです。一応はPHPの最新言語仕様についてはちゃんと追っかけて差分取っているぐらいには使っています。さすがに仕事の商売道具ですから、嫌いだから何も勉強しない！わけでもないです。traitなども効果的だと思ったところには使ってますし、まぁtrait使うと更にPhpStormの補完が死ぬわけですが。</p>
<ul>
<li>なんで水平分割いやがるの</li>
</ul>
<p>一応スライド中にも書きましたが、メンドーごとが増えるので。特に嫌なのは、<a href="http://www.heidisql.com/">HeidiSQL</a>とか、GUIツール郡の使い勝手が低下して、かわりに自社製のツールセット（コマンドか、しょぼいWebUI）になるか、とかですよねえ、それが一番避けたくて。他社の話を聞いていて驚くのは、phpMyAdminとかコマンド叩いてるとかいうんですよ、DB見たりするのに。私的には、ありえない。みんなもっとちゃんとGUIツールも使いましょう。必要とあらばウェブツールだけじゃなくてGUIツールも自作しましょう(C#なら簡単です！)。</p>
<p>まあ、どうしてもダメになったら水平にします。でもFusion-IOはもとより、AWSでも10万IOPSのインスタンスが出たりとか、ハードウェア性能はどんどん進化しているので、何とかなってくれるんじゃないかなあ、と楽観視はしています。良い時代になったな、と思います。</p>
<h2>なぜ移行するの？C#のどこがいいの？</h2>
<p>ということを、<a href="http://t.co/mxY8JFk7j2">6/11 第90回codeseek＆第30回日本C#ユーザー会 勉強会 「やっぱり.NETだよね」</a>でお話しますので、明日ですが、当日まで申し込みは受け付けてる的なノリがいつもの感じだとあるので、時間あるかたは是非お越しください。そんなにDisってよりは割とSoftな感じです、私の分はいちおー。</p>
<p>珍しく既にスライドは完成していまして、「Static vs Dynamic」「Type for IntelliSense」「Type for Refactoring」「Debugger is Power」「LINQ vs array_xxx」「Razor:Template Engine Revolution」といったようなタイトルが並んでますので、気になった方はどーぞ。</p>
<p>ああ、そう、あとA vs Bにおいて、全てにおけてAのほうがいい、なんてことは絶対にないんですね。どこかしらかはBのほうがよかったり、BならXxxなのに、とかいうようなことも出てくるでしょう。何がどれだけ自分に、自分達に良いのかの選択をしてくのが肝要なので、その選択を考えるための道具になればいいかと思ってます。</p>
</div>
<h1><a href="https://neue.cc/2013/05/27_405.html">HttpClient詳解、或いはAsyncOAuthのアップデートについて</a></h1>
<ul class="date"><li>2013-05-27</li></ul>
<div class="entry_body"><p>すっかり忘れていたわけではないですが、ちょっとかなり前、3/30の<a href="http://metrostyledev.net/index.php/event/20130330/">Room metro #15</a>にて、HttpClient詳解という、HttpClientについてのセッションを行いました。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/17899218" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/httpclient" title="HttpClient詳解、或いは非同期の落とし穴について" target="_blank">HttpClient詳解、或いは非同期の落とし穴について</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>HttpClientは、使えば使うほど、もうWebRequestやWebClientに戻りたくないわー、という非常に秀逸な、完全にこれからのスタンダードになる代物なので、きっちり習得しましょう。</p>
<p>或いは非同期の落とし穴について、ということで、async/awaitでも顕在の、いや、async/awaitだからこそ現れるデッドロックの問題と回避方法についても紹介しています。はまる時ははまっちゃうんですよねー、これ、何気に地味に実は。それなりに痛い目みました、私も。</p>
<h2>PCL版のRC</h2>
<p>HttpClientは現在.NET 4.5とWindows Store Appsのほうに標準搭載されていますが、それ以外でも使うために、Portable Class Libraryとしての提供がされています。そして、5/22に<a href="http://blogs.msdn.com/b/dotnet/archive/2013/05/22/portable-httpclient-is-now-available-as-rc.aspx">Portable HttpClient is now available as RC</a>としてRC版がリリースされました！</p>
<p>こないだまでのBeta版だと、AsyncOAuthを使ってTiwtterのストリーミングAPIを読む時に、awaitすると全く戻ってこなくなるという現象がありました。これはAsyncOAuthが悪いのかHttpClientが悪いのか調べたんですが、結果としてHttpClientのバグでした。HttpClientは内部で通信にWebRequestを使っているのですが、それのAllowReadStreamBufferingとAllowWriteStreamBufferingをfalseにセットしなければならないのに、何もセットしない（ことによって結果的にtrueになっている）状態でした。すると、ストリーミングAPIを読むのにバッファを取ろうとして、当然ストリーミングなのでオワリがないので永遠に帰ってこないという……。</p>
<p>ちゃんとバグ報告したら（偉い！←自分で言う）、今回のRC版で直してくれたようです、多分。とりあえずWP8のEmulatorで試した限りでは、ちゃんとストリーミングAPI動きました。よかったよかった。というわけで、AsyncOAuthもver.0.6.4として、新しいHttpClientに依存するようにアップデートしておきました。なお、AsyncOAuthについては<a href="http://neue.cc/2013/02/27_398.html">AsyncOAuth - C#用の全プラットフォーム対応の非同期OAuthライブラリ</a>を読んでくださいな。</p>
<p>そういえば同時に、というか4/17にですが、.NET4などでもasync/awaitを使えるようにする<a href="http://blogs.msdn.com/b/bclteam/archive/2013/04/17/microsoft-bcl-async-is-now-stable.aspx">Microsoft.Bcl.Async</a>はStableになってました。これで気兼ねなくasync使える！</p>
<h2>6月の予定</h2>
<p>6月は何故かいっぱいイベントに出ることになっています。6/8の<a href="http://www.buildinsider.net/event/offline/01">Build Insider OFFLINE</a>、そこで「.NET最先端技術によるハイパフォーマンスウェブアプリケーション」についてお話します。もう席は満席となってしまいましたが、Ustreamでの中継も行われるようですので、よろしければそちらで見ていただければと思います。</p>
<p>また、6/11~14あたりに、<a href="http://csharp-users.jp/">C#ユーザー会</a>で何か話すそうです。何か。何でしょうね。一節によるとPHP被害者友の会（？）だとか・</p>
<p>そして6/22に<a href="http://atnd.org/event/E0015958">つくばC#勉強会</a>でThe History of LINQと題して、何か話すそうです。はい。つくばいいですね！素晴らしいですぅー。つくば勉強会はまだまだ残席あるようなので、みんな参加しよう！登壇者も募集しているようですので、登壇もしよう！</p>
</div>
<h1><a href="https://neue.cc/2013/04/24_404.html">RxとRedisを用いたリモートPub/Sub通信</a></h1>
<ul class="date"><li>2013-04-24</li></ul>
<div class="entry_body"><p>今日から始まった<a href="http://www.buildinsider.net/">Build Insider</a>で、RedisとBookSleeveの記事を書きました - <a href="http://www.buildinsider.net/small/rediscshap/01">C#のRedisライブラリ「BookSleeve」の利用法</a>。Redis、面白いし、Windowsで試すのも想像以上に簡単なので、是非是非試してみて欲しいです。そして何よりもBookSleeve！使うと、強制的に全てがasyncになるので、C# 5.0でのコーディングの仕方のトレーニングになる（笑）。にちじょー的にasync/awaitを使い倒すと、そこから色々アイディアが沸き上がっきます。ただたんにsyncがasyncになった、などというだけじゃなく、アプリケーションの造りが変わります。そういう意味では、Taskは結構過小評価されてるのかもしれないな、なんて最近は思っています。</p>
<p>さて、RedisにはPub/Sub機能がついているわけですが、Pub/Sub→オブザーバーパターン→Rx！これはティンと来た！と、いうわけで、これ、Rxに乗せられました、とても自然に。というわけで、□□を○○と見做すシリーズ、なCloudStructuresにRx対応を載せました。</p>
<ul>
<li><a href="https://github.com/neuecc/CloudStructures">GitHub - CloudStructures</a></li>
<li><a href="https://nuget.org/packages/CloudStructures/">PM&gt; Install-Package CloudStructures -Pre</a></li>
</ul>
<p>追加したクラスはRedisSubject&lt;T&gt;。これはSubjectやAsyncSubjectなどと同じく、ISubject&lt;T&gt;になっています。IObservableであり、IObserverでもある代物。とりあえず、コード例を見てください。</p>
<pre><code class="language-csharp">var settings = new RedisSettings(&quot;127.0.0.1&quot;);

var subject = new RedisSubject&lt;string&gt;(settings, &quot;PubSubTest&quot;);

// SubscribeはIObservable&lt;T&gt;なのでRxなLINQで書ける
var a = subject
    .Select(x =&gt; DateTime.Now.Ticks + &quot; &quot; + x)
    .Subscribe(x =&gt; Console.WriteLine(x));

var b = subject
    .Where(x =&gt; !x.StartsWith(&quot;A&quot;))
    .Subscribe(x =&gt; Console.WriteLine(x), () =&gt; Console.WriteLine(&quot;completed!&quot;));

// IObserverなのでOnNext/OnError/OnCompletedでメッセージ配信
subject.OnNext(&quot;ABCDEFGHIJKLM&quot;);
subject.OnNext(&quot;あいうえお&quot;);
subject.OnNext(&quot;なにぬねの&quot;);

Thread.Sleep(200); // 結果表示を待つ...

a.Dispose(); // UnsubscribeはDisposeで
subject.OnCompleted(); // OnCompletedを受信したSubscriberもUnsubscribeされる
</code></pre>
<p>はい、別になんてこともない極々フツーのRxのSubjectです。が、しかし、これはネットワークを通って、Redisを通して、全てのSubscriberへとメッセージを配信しています。おお～。いやまあ、コードの見た目からじゃあそういうの分からないので何も感動するところもないのですが、とにかく、本当に極々自然に普通に、しかし、ネットワークを超えます。この、見た目何も変わらずに、というところがいいところなわけです。</p>
<p>Subscribeする側はIObservableなので別にフツーに合成していけますし、Publishする側もIObserverなので、Subscribeにしれっと潜り込ませたりしても構わない。もう、全然、普通にインメモリなRxでやる時と同じことが、できます。</p>
<p>オワリ。地味だ。</p>
<p>う、うーん。ほ、ほらほら！！</p>
<pre><code class="language-csharp">// ネットワーク経由
var settings = new RedisSettings(&quot;xx.xxx.xxx.xxx&quot;);

var subject = new RedisSubject&lt;DateTime&gt;(settings, &quot;PubSubTest&quot;);

// publisherはこちらのコード
while (true)
{
    Console.ReadLine();
    var now = DateTime.Now;
    Console.WriteLine(now.Ticks);
    subject.OnNext(now);
}

// subscriberはこちらのコードを動かす
subject.Subscribe(x =&gt;
{
    var now = DateTime.Now;
    Console.Write(x.Ticks + &quot; =&gt; &quot; + now.Ticks);
    Console.WriteLine(&quot; | &quot; + (now - x));
});
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/redis_network_pubsub.jpg">
</p>
<p>というわけで、実際にネットワーク経由(AWS上に立てたRedisサーバーを通してる)で動かしてみた結果がこんな感じです。ネットワークを超えたことで用法は幾らでもある！夢膨らみまくり！</p>
<p>で、↑のコードは遅延時間のチェックを兼ねてるのですが、概ね、0.03秒ぐらい。たまにひっかかって0.5秒超えてるのがあって、ぐぬぬですが。実際のとこRedis/Linuxの設定で結構変わってくるところがあるので、その辺は煮詰めてくださいといったところでしょうか。</p>
<p>ともあれチャットとかなら全然問題なし、ゲームでもアクションとかタイミングにシビアじゃないものなら余裕ですね、ボードゲームぐらいなら全く問題ない。ちょっとしたMMOぐらいならいけるかも。これからはネットワーク対戦はRedisで、Rxで！！！</p>
<h2>余談</h2>
<p>CloudStructuresですが、.configからの設定読み込み機能も地味につけました。</p>
<pre><code class="language-xml">&lt;configSections&gt;
    &lt;section name=&quot;cloudStructures&quot; type=&quot;CloudStructures.Redis.CloudStructuresConfigurationSection, CloudStructures&quot; /&gt;
&lt;/configSections&gt;

&lt;cloudStructures&gt;
    &lt;redis&gt;
        &lt;group name=&quot;cache&quot;&gt;
            &lt;add host=&quot;127.0.0.1&quot; /&gt;
            &lt;add host=&quot;127.0.0.2&quot; port=&quot;1000&quot; /&gt;
        &lt;/group&gt;
        &lt;group name=&quot;session&quot;&gt;
            &lt;add host=&quot;127.0.0.1&quot; db=&quot;2&quot; valueConverter=&quot;CloudStructures.Redis.ProtoBufRedisValueConverter, CloudStructures&quot; /&gt;
        &lt;/group&gt;
    &lt;/redis&gt;
&lt;/cloudStructures&gt;
</code></pre>
<pre><code class="language-csharp">// これで設定を読み込める
var groups = CloudStructuresConfigurationSection.GetSection().ToRedisGroups();
</code></pre>
<p>色々使いやすくなってきて良い感じじゃあないでしょーか。</p>
<h2>コールバック撲滅</h2>
<p>そうそう、最後に実装の話を。元々BookSleeveのPub/Sub購読はコールバック形式です。「public Task Subscribe(string key, Action&lt;string, byte[]&gt; handler)」handlerはstringがキー, byte[]が送られてくるオブジェクトを指します。コールバック is ダサい。コールバック is 扱いにくい。ので、コールバックを見かけたらObservableかTaskに変換することを考えましょう！それがC# 5.0世代の常識です！</p>
<p>というわけで、以下のようにして変換しました。</p>
<pre><code class="language-csharp">public IDisposable Subscribe(IObserver&lt;T&gt; observer)
{
    var channel = Connection.GetOpenSubscriberChannel();

    var disposable = System.Reactive.Disposables.Disposable.Create(() =&gt;
    {
        channel.Unsubscribe(Key).Wait();
    });

    // ここが元からあるコールバック
    channel.Subscribe(Key, (_, xs) =&gt;
    {
        using (var ms = new MemoryStream(xs))
        {
            var value = RemotableNotification&lt;T&gt;.ReadFrom(ms, valueConverter);
            value.Accept(observer); // この中でobserverのOnNext/OnError/OnCompletedが叩かれる
            if (value.Kind == NotificationKind.OnError || value.Kind == NotificationKind.OnCompleted)
            {
                disposable.Dispose(); // ErrorかCompletedでもUnsubscribeしますん
            }
        }
    }).Wait();

    return disposable; // もしDisposableが呼ばれたらUnsubscribeしますん
}
</code></pre>
<p>こんなふぅーにRxで包むことで、相当使いやすさがアップします。感動した。</p>
</div>
<h1><a href="https://neue.cc/2013/04/05_403.html">CloudStructures - ローカルとクラウドのデータ構造を透過的に表現するC# + Redisライブラリ</a></h1>
<ul class="date"><li>2013-04-05</li></ul>
<div class="entry_body"><p>というものを作りました。インストールはNuGetから。</p>
<ul>
<li><a href="https://github.com/neuecc/CloudStructures">GitHub - CloudStructures</a></li>
<li><a href="https://nuget.org/packages/CloudStructures/">PM&gt; Install-Package CloudStructures -Pre</a></li>
</ul>
<p>何を言ってるのかヨクワカラナイので、まずはコード例を。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public string Name { get; private set; }
    public List&lt;Person&gt; Friends { get; private set; }

    public Person(string name)
    {
        Name = name;
        Friends = new List&lt;Person&gt;();
    }
}

// こんなのがいるとして
var sato = new Person(&quot;さとう&quot;);

// 人を足す
sato.Friends.Add(new Person(&quot;やまだ&quot;));
sato.Friends.Add(new Person(&quot;いとう&quot;));

// 件数数える
var friendCount = sato.Friends.Count;
</code></pre>
<p>これは普通にローカルで表現する場合です。実に普通です。では、次。</p>
<pre><code class="language-csharp">// RedisServerの設定の表現
public static class RedisServer
{
    public static readonly RedisSettings Default = new RedisSettings(&quot;127.0.0.1&quot;);
}

// こんなクラスがあるとして
public class Person
{
    public string Name { get; private set; }
    public RedisList&lt;Person&gt; Friends { get; private set; }

    public Person(string name)
    {
        Name = name;
        Friends = new RedisList&lt;Person&gt;(RedisServer.Default, &quot;Person-&quot; + Name);
    }
}

// こんなのがいるとして
var sato = new Person(&quot;さとう&quot;);

// 人を足す
await sato.Friends.AddLast(new Person(&quot;やまだ&quot;));
await sato.Friends.AddLast(new Person(&quot;いとう&quot;));

// 件数数える
var friendCount = await sato.Friends.GetLength();
</code></pre>
<p>この場合、Redisを通してサーバー上にデータは保存されています。ですが、操作感覚はローカルにあるものとほぼほぼ同じです。違いは全ての操作が非同期なので、awaitするぐらい。</p>
<h2>IAsyncList</h2>
<p>これは、<a href="http://actorfx.codeplex.com/">Actor Framework for Windows Azure</a>のDistributed Collectionsに影響を受けています。ActorFxのそれは、SOURCE CODEを落としてdocsフォルダの Distributed Collections using the ActorFx.docx に色々書いてあって面白いので必読です。</p>
<p>そして、ActorFxではSystem.Cloud.Collectionsとして(System名前空間！)、現状、以下のようなインターフェイスが定義されています（まだ変更の可能性大いにあり）。</p>
<pre><code class="language-csharp">namespace System.Cloud.Collections
{
    public interface IAsyncCollection&lt;T&gt; : IObservable&lt;T&gt;
    {
        Task&lt;int&gt; CountAsync { get; }
        Task&lt;bool&gt; IsReadOnlyAsync { get; }

        Task AddAsync(T item);
        Task ClearAsync();
        Task&lt;bool&gt; ContainsAsync(T item);
        Task CopyToAsync(T[] array, int arrayIndex);
        Task&lt;bool&gt; RemoveAsync(T item);
    }

    public interface IAsyncList&lt;T&gt; : IAsyncCollection&lt;T&gt;
    {
        Task&lt;T&gt; GetItemAsync(int index);
        Task SetItemAsync(int index, T value);
        Task&lt;int&gt; IndexOfAsync(T item);
        Task InsertAsync(int index, T item);
        Task RemoveAtAsync(int index);

        // Less chatty versions
        Task AddAsync(IEnumerable&lt;T&gt; items);
        Task RemoveRangeAsync(int index, int count);
    }

    public interface IAsyncDictionary&lt;TKey, TValue&gt; : IAsyncCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;
    {
        Task&lt;TValue&gt; GetValueAsync(TKey key);
        Task SetValueAsync(TKey key, TValue value);
        Task&lt;Tuple&lt;bool, TValue&gt;&gt; TryGetValueAsync(TKey key);

        // No AddAsync - use SetValueAsync instead.  We have no atomic operation to add iff a value is not in the dictionary.
        Task&lt;bool&gt; ContainsKeyAsync(TKey key);
        Task&lt;bool&gt; RemoveAsync(TKey key);

        // Bulk operations
        Task&lt;ICollection&lt;TValue&gt;&gt; GetValuesAsync(IEnumerable&lt;TKey&gt; keys);
        Task SetValuesAsync(IEnumerable&lt;TKey&gt; keys, IEnumerable&lt;TValue&gt; values);
        Task RemoveAsync(IEnumerable&lt;TKey&gt; keys);

        ICollection&lt;TKey&gt; Keys { get; }
        ICollection&lt;TValue&gt; Values { get; }
    }
}
</code></pre>
<p>わくわくしてきません？私はこの定義を見た瞬間に衝撃を受けました。RxのIObservable&lt;T&gt;を見た時と同程度の衝撃かもわからない。Ax(ActorFx)の実装としてはCloudList, CloudDictionary, CloudStringDictionaryがありますが(基盤としてAzure Table)、見てすぐにRedisと結びついた。Redisの持つデータ構造、List, Hash, Set, SortedSetってこれじゃないか！って。こういう風に表現されたらどれだけ素敵な見た目になるか……！</p>
<h2>Strings, Set, SortedSet, List, Hash, その他</h2>
<p>というわけで、最初の例ではRedisListだけ出しましたが、StringsもSetもSortedSetもHashもあります。また、HashClassやMemoizedRedisStringといった特殊なものも幾つか用意してあります。</p>
<pre><code class="language-csharp">// フィールドに持たなくても、ふつーにRedisClient的に使ってもいいよ
var client = new RedisString&lt;string&gt;(RedisServer.Default, &quot;toaru-key&quot;);
await client.Set(&quot;あいうえお!&quot;, expirySeconds: TimeSpan.FromMinutes(60).TotalSeconds);

// RedisClassはRedisのHash構造をクラスにマッピングするもの
var hito = new RedisClass&lt;Hito&gt;(RedisServer.Default, &quot;hito-1&quot;);
await hito.SetField(&quot;Name&quot;, &quot;やまもと&quot;);
await hito.Increment(&quot;Money&quot;, 100);

var localHito = await hito.GetValue(); // Cloud -&gt; Localに落とす、的ないめーぢ
</code></pre>
<p>実際色々あるので見て回ってください！</p>
<h2>ConnectionManagement</h2>
<p>基盤的な機能として、BookSleeveの接続管理を兼ねています。</p>
<pre><code class="language-csharp">// Redisの設定を表す
var settings = new RedisSettings(host: &quot;127.0.0.1&quot;, port: 6379, db: 0);

// BookSleeveはスレッドセーフで単一のコネクションを扱う
// コネクションを一つに保ったり切断されていた場合の再接続などをしてくれる
var conn = settings.GetConnection();


// 複数接続はRedisGroupで管理できる
var group = new RedisGroup(groupName: &quot;Cache&quot;, settings: new[]
{
    new RedisSettings(host: &quot;100.0.0.1&quot;, port: 6379, db: 0),
    new RedisSettings(host: &quot;105.0.0.1&quot;, port: 6379, db: 0),
});

// keyを元に分散先のサーバーを決める（デフォルトはMD5をサーバー台数で割って決めるだけの単純な分散）
var conn = group.GetSettings(&quot;hogehoge-100&quot;).GetConnection();

// シリアライザはデフォルトではJSONとProtoBufを用意（未指定の場合はJSON）
new RedisSettings(&quot;127.0.0.1&quot;, converter: new JsonRedisValueConverter());
new RedisSettings(&quot;127.0.0.1&quot;, converter: new ProtoBufRedisValueConverter());
</code></pre>
<p>って、ここまで<a href="https://code.google.com/p/booksleeve/">BookSleeve</a>の説明がなかった！BookSleeveはRedisのライブラリで、非同期の操作のみを提供しています。CloudStructuresのRedis操作はBookSleeveに全部委ねてます。というかぶっちゃけ、かなり単純なラップがほとんどだったりします（！）。見せ方を変えただけ、です、よーするところ。</p>
<p>んで、BookSleeveは斬新で非常に良いライブラリなのですけれど、操作が本当にプリミティブなものしかないので（全てのGetとSetがstringとbyte[]しかない、とかね）、ある程度、自分で作りこんでやらないと全く使えません。なので、この部分だけでも、結構使えるかなって思います。</p>
<h2>Next</h2>
<p>個人的にはすっごく面白いと思ってます。見せ方の違いでしかないわけですが、しかし、その見せ方の違いというのが非常に大事なのです。直感的、ですが、ある種奇抜なデザインなので、戸惑うとは思います。異色度合いで言ったら、以前に私の作ったReactivePropertyと同程度に異色かな、と。だからこそ、凄く大きな可能性を感じませんか？</p>
<p>ちなみに、これは（いつものように）コンセプト止まりじゃなくて、実際に使う予定アリなので、しっかり育ててく気満々です。是非、試してみてもらえると嬉しいですね。</p>
</div>
<h1><a href="https://neue.cc/2013/04/02_402.html">Microsoft MVP for Visual C#を再再受賞しました</a></h1>
<ul class="date"><li>2013-04-02</li></ul>
<div class="entry_body"><p>今年も再受賞することができました。去年は某g社のフロントに立って、というのもあって、オフライン活動が割と非常に活発でした。ブログは量は減りましたし、中身も職業柄ウェブ系の要素が濃くなった感。とはいえ、内容自体は結構面白げなC#の内容になってたのではかしらん。基本的には、他で得られない情報や、ディープに踏み込んだ先の話、新しい考え。そういったのを提供し続けたいです。</p>
<p>今年はもっともっと面白くしたい。去年に、私は</p>
<blockquote>
<p>C#を世間（といっても、技術系の人に、ですね）に強くアピールするにはどうすればいいのか、といったら、一番大事なのはそれで書かれたメジャーなアプリケーションなのです。PerlではてなやMixi、livedoorなどを思い浮かべる、RubyでCookpadを、ScalaでFoursquareやTwitterを、そういった憧れにも似た気持ちを浮かべさせるようなアプリケーションがなければいけなくて。</p>
</blockquote>
<blockquote>
<p>Stack OverflowはC#, ASP.NET MVCだし、TIOBEのプログラミング言語ランキングでは三位など、海外でのC#の地位は十分に高い。のですが、国内ではそれと比べれば全くもってない。日本で誰もが知る会社の誰もが知るアプリケーション、それがC#で書かれている。そういう状態にならなければ、日本で強く普及は無理だな、と。</p>
</blockquote>
<p>と言いました。今年はそれを実現するため、<a href="http://grani.jp/">謎社（もう謎ではない）</a>のCTOとして、人の憧れるような、日本を代表するC#の企業にします。C#による圧倒的な成果、C#だからこその強さ、というのを現実に示していく。幸い、私は今、それができる場所にいると思っています。</p>
<p>そんなわけで、今年もよろしくお願いします。</p>
</div>
<h1><a href="https://neue.cc/2013/03/27_401.html">C#のラムダ式でyieldっぽい何かをawaitで代用する方法</a></h1>
<ul class="date"><li>2013-03-27</li></ul>
<div class="entry_body"><p>C#がインラインでyield書けないならawait使えばいいじゃない。と、偉い人は言いました。というわけで、こそこそっと開発がされているIxに、面白い機能が入りました（開発リポジトリ上だけなのでNuGetからダウンロードしても、まだ入ってません）。こんなのです。</p>
<pre><code class="language-csharp">var hoge = &quot;あいうえお&quot;;

var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    await Yield.Return(100);

    hoge = &quot;ふがふが&quot;; // インラインで書けるのでお外への副作用が可能

    await Yield.Return(1000);
});


foreach (var item in seq)
{
    Console.WriteLine(item); // 10, 100, 1000
}
Console.WriteLine(hoge); // ふがふが
</code></pre>
<p>そう、yield return(っぽい何か)がラムダ式で、メソッド外部に出すことなく書けてしまうのです！これは素敵ですね？い、いや、なんか何やってるのか分からなすぎて黒魔術怖いって雰囲気も漂ってますね！しかし面白いものは面白いので、実装見ましょう。</p>
<p><a href="http://rx.codeplex.com/SourceControl/changeset/8f1e73bca96e">add types iyielder, iawaitable, and iawait; add support for creating ienumerable from action<iyielder>.</a>ということで、まあ、ローカルで動かしたいんでコピペってきましょう。</p>
<pre><code class="language-csharp">public static class EnumerableEx
{
    public static IEnumerable&lt;T&gt; Create&lt;T&gt;(Action&lt;IYielder&lt;T&gt;&gt; create)
    {
        if (create == null) throw new ArgumentNullException(&quot;create&quot;);

        foreach (var x in new Yielder&lt;T&gt;(create))
        {
            yield return x;
        }
    }
}

public interface IYielder&lt;in T&gt;
{
    IAwaitable Return(T value);
    IAwaitable Break();
}

public interface IAwaitable
{
    IAwaiter GetAwaiter();
}

public interface IAwaiter : ICriticalNotifyCompletion
{
    bool IsCompleted { get; }
    void GetResult();
}

public class Yielder&lt;T&gt; : IYielder&lt;T&gt;, IAwaitable, IAwaiter, ICriticalNotifyCompletion
{
    private readonly Action&lt;Yielder&lt;T&gt;&gt; _create;
    private bool _running;
    private bool _hasValue;
    private T _value;
    private bool _stopped;
    private Action _continuation;

    public Yielder(Action&lt;Yielder&lt;T&gt;&gt; create)
    {
        _create = create;
    }

    public IAwaitable Return(T value)
    {
        _hasValue = true;
        _value = value;
        return this;
    }

    public IAwaitable Break()
    {
        _stopped = true;
        return this;
    }

    public Yielder&lt;T&gt; GetEnumerator()
    {
        return this;
    }

    public bool MoveNext()
    {
        if (!_running)
        {
            _running = true;
            _create(this);
        }
        else
        {
            _hasValue = false;
            _continuation();
        }

        return !_stopped &amp;&amp; _hasValue;
    }

    public T Current
    {
        get
        {
            return _value;
        }
    }

    public IAwaiter GetAwaiter()
    {
        return this;
    }

    public bool IsCompleted
    {
        get { return false; }
    }

    public void GetResult() { }


    public void OnCompleted(Action continuation)
    {
        _continuation = continuation;
    }

    public void UnsafeOnCompleted(Action continuation)
    {
        _continuation = continuation;
    }
}
</code></pre>
<p>ほぅ、わけわからん？若干トリッキーなので、順を追っていきますか。asyncについて考える前に、まず、基本的なforeachのルール。実はIEnumerableを実装している必要はなくて、GetEnumeratorという名前のメソッドがあればいい。同様にMoveNextとCurrentというメソッドがあればIEnumerator扱いされる。なので、foreach (var x in new Yielder<T>(create)) されているYielderはIEnumerableじゃないし、GetEnumeratorでreturn thisされていますが、YielderはIEnumeratorでもない。でも、foreachでグルグル回せている、というわけです。挙動は通常のforeachと同じで、MoveNext→Current、といった形です。</p>
<p>あと、インターフェイスが、IAwaitableとかいっぱい再定義されてて、ワケワカランのですけれど、そこまで意味あるわけじゃないです。これはラムダ式にYielderを渡すわけですが、そこで内部の諸々が呼べちゃうのはイクナイので隠ぺいする、程度の意味合いでしかないので、これを実装するのにインターフェイスの再定義が必要！というわけは全然ないです。</p>
<p>で、コアになるのはMoveNext。</p>
<pre><code class="language-csharp">public bool MoveNext()
{
    if (!_running)
    {
        _running = true;
        _create(this);
    }
    else
    {
        _hasValue = false;
        _continuation();
    }

    return !_stopped &amp;&amp; _hasValue;
}
</code></pre>
<p>そもそもyield returnで生成されたメソッドが最初に実行されるのは、GetEnumeratorのタイミングではなく、GetEnumeratorされて最初のMoveNextが走った時、なので、ここが本体になっているのはセマンティクス的に問題なし。</p>
<p>!_runnningは初回実行時の意味で、ここで_create(this)、によってラムダ式で書いた本体が走ります。</p>
<pre><code class="language-csharp">var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    // ↑のとこがまず実行され始める
    await Yield.Return(100);
    await Yield.Return(1000);
});

public IAwaitable Return(T value)
{
    _hasValue = true;
    _value = value;
    return this;
}
</code></pre>
<p>まずはメソッド実行なのでReturn。これは値をセットして回っているだけ。そしてIAwaitableを返し、await。ここで流れは別のところに行きます。</p>
<pre><code class="language-csharp">public bool IsCompleted
{
    get { return false; }
}

public void GetResult() { }


public void OnCompleted(Action continuation)
{
    _continuation = continuation;
}

public void UnsafeOnCompleted(Action continuation)
{
    _continuation = continuation;
}
</code></pre>
<p>まず完了しているかどうかの確認(IsCompleted)が走りますが、この場合は常にfalseで(そうしないと終了ということになってラムダ式のほうに戻ってこなくなっちゃう)。これによってUnsafeOnCompleted(ICriticalNotifyCompletionが実装されている場合はこっちが走る)でcontinuation(メソッド本体)が走る。で、「次回用」に変数保存して、MoveNext(create(this)したとこの位置)に戻ってくる。あとはMoveNextがtrueを返すのでCurrentで値取得して、それがyield returnされる。</p>
<p>二度目のMoveNextでは</p>
<pre><code class="language-csharp">public bool MoveNext()
{
    if (!_running)
    {
        _running = true;
        _create(this);
    }
    else
    {
        _hasValue = false;
        _continuation(); // ここが呼び出されて
    }

    return !_stopped &amp;&amp; _hasValue;
}

var seq = EnumerableEx.Create&lt;int&gt;(async Yield =&gt;
{
    await Yield.Return(10);
    // ここから再度走り出す
    await Yield.Return(100);
    await Yield.Return(1000);
});
</code></pre>
<p>といった感じになって、以下繰り返し。良く出来てますね！ていうか、asyncなのに非同期全く関係ないのが素敵。そう、asyncは別に非同期関係なく使えちゃうわけです。ここ大事なので繰り返しましょう。asyncは別に非同期関係なく使うことができます。</p>
<h2>まとめ</h2>
<p>async、フツーに使うのもそろそろ飽きてき頃だと思うので、弄って遊ぶのは大正義。実際に投下しだすかどうかは判断次第。あと、↑のはまだ大事な要素ができていないので絶対使いませんけれど。大事な要素はIDisposableであること。foreachで大事だと思ってるのはDisposeしてくれるとこ！だとも思っているので、それが実現できてないのはナイナー、と。</p>
<p>そういえばAsyncについてですが、3/30の土曜に<a href="http://metrostyledev.net/index.php/event/20130330/">Room metro #15</a>でHttpClient(非同期の塊！)について話すので、まだ残席ありますので良ければお越しくだしあー。</p>
</div>
<h1><a href="https://neue.cc/2013/03/09_400.html">並列実行とSqlConnection</a></h1>
<ul class="date"><li>2013-03-09</li></ul>
<div class="entry_body"><p>どうも、ParallelやThreadな処理が苦痛度100なペチパーです。嘘です。空前のThreadLocalブームが来てたり来てなかったりする昨今です。あ、謎社の宣伝しますと<a href="http://corp.gree.net/jp/ja/news/press/2013/0308-01.html">グリーとグラニ、「GREE」におけるソーシャルゲームの提供などについて戦略的業務提携に合意</a>というわけで、ぐりとぐら、としかいいようがない昨今でもあります。その日に開催されていたGREEプラットフォームカンファレンスでは、謎社はC#企業になる！と大宣言したので、ちゃんと実現させていきたいところです、いや、むしろそのためにフル回転しています。</p>
<p>そんな宣伝はおいておいて本題なのですけれど、SQL。データベース。大量にクエリ発行したい時など、パラレル実行したいの！インサートだったら当然BulkInsertが一番早いんですが、Updateとかね。シンドイんだよね。あとUpsert(Merge/ON DUPLICATE KEY UPDATE)とかも使っちゃったりしてね。そんなわけで、お手軽お気楽な手法としてはParallelがありますねー、.NETはこの辺本当に楽なんだよねー、ぴーHPはシラネ。</p>
<p>で、実際パラレールにこんな感じに書くと……</p>
<pre><code class="language-csharp">using (var connection = new SqlConnection(&quot;接続文字列&quot;))
{
    connection.Open();
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>落ちます。理由は単純明快でSqlConnectionはスレッドセーフじゃないから。というわけで、やるなら</p>
<pre><code class="language-csharp">Parallel.For(1, 1000, x =&gt;
{
    using (var connection = new SqlConnection(&quot;接続文字列&quot;))
    {
        connection.Open();
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    }
});
</code></pre>
<p>となります、これなら絶対安全。でも、スレッドって基本的にコアの数とちょびっとしか立てられないわけだし、連続的に実行しているのだから、たとえコネクションプール行きだとかなんだりであっても、一々コネクションを開いて閉じてをするよりも、開きっぱで行きたいよね。</p>
<p>ようするにSqlConnectionがスレッドセーフじゃないからいけない。これはどこかで聞いたような話です。先日<a href="http://neue.cc/2013/03/06_399.html">C#とランダム</a>で出したThreadLocalの出番ではないでしょうか！</p>
<h2>ThreadLocal</h2>
<p>というわけでスレッドセーフなSqlConnectionを作りましょう、ThreadLocalを使って。</p>
<pre><code class="language-csharp">using (var connection = new ThreadLocal&lt;SqlConnection&gt;(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }))
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>new SqlConnectionがThreadLocalに変わっただけのお手軽さ。これで、安全なんですって！本当に？本当に。で、実際こうして速度はどうなのかというと、私の環境で実行したところ、シングルスレッドで16秒、毎回new SqlConnectionするParallelで5秒、ThreadLocalなParallelで2秒でした。これは圧勝。幸せになれそう。</p>
<h2>Disposeを忘れない、或いは忘れた</h2>
<p>でも↑のコードはダメです。ダメな理由は、コネクションをDisposeしてないからです。ThreadLocalのDisposeは、あくまでThreadLocalのDisposeなのであって、中身のDisposeはしてくれてないのです。ここ忘れると悲劇が待ってます。でもFactoryで作ってる上にThreadで一意なValue、どうやってまとめてDisposeすればいいの！というと、trackAllValuesというオプションを有効にすると簡単に実現できます。</p>
<pre><code class="language-csharp">using (var connection = new ThreadLocal&lt;SqlConnection&gt;(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }
    , trackAllValues: true)) // ThreadLocalの.Valuesプロパティの参照を有効化する
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });

    // 生成された全てのConnectionを一括Dispose
    foreach (var item in connection.Values.OfType&lt;IDisposable&gt;()) item.Dispose();
}
</code></pre>
<p>この<a href="http://msdn.microsoft.com/ja-jp/library/hh139139.aspx">trackAllValuesが可能なThreadLocal</a>は.NET 4.5からです。それ以前の人は、残念でした……。謎社は遠慮なく.NET 4.5を使いますので全然問題ありません(</p>
<h2>もう一つまとめて</h2>
<p>とはいえ、なんか面倒くさいので、ちょっとラップしませう、以下のようなクラスを用意します。</p>
<pre><code class="language-csharp">public static class DisposableThreadLocal
{
    public static DisposableThreadLocal&lt;T&gt; Create&lt;T&gt;(Func&lt;T&gt; valueFactory)
        where T : IDisposable
    {
        return new DisposableThreadLocal&lt;T&gt;(valueFactory);
    }
}

public class DisposableThreadLocal&lt;T&gt; : ThreadLocal&lt;T&gt;
    where T : IDisposable
{
    public DisposableThreadLocal(Func&lt;T&gt; valueFactory)
        : base(valueFactory, trackAllValues: true)
    {

    }

    protected override void Dispose(bool disposing)
    {
        var exceptions = new List&lt;Exception&gt;();
        foreach (var item in this.Values.OfType&lt;IDisposable&gt;())
        {
            try
            {
                item.Dispose();
            }
            catch (Exception e)
            {
                exceptions.Add(e);
            }
        }

        base.Dispose(disposing);

        if (exceptions.Any()) throw new AggregateException(exceptions);
    }
}
</code></pre>
<p>これを使うと</p>
<pre><code class="language-csharp">using (var connection = DisposableThreadLocal.Create(() =&gt; { var conn = new SqlConnection(&quot;接続文字列&quot;); conn.Open(); return conn; }))
{
    Parallel.For(1, 1000, x =&gt;
    {
        var _ = connection.Value.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
}
</code></pre>
<p>といったように、超シンプルに書けます。うん。いいね。</p>
<h2>それAsync？</h2>
<p>Asyncでドバッと発行してTask.WhenAll的なやり方も、接続が非スレッドセーフなのは変わらなくて、結構やりづらいんですよ……。それで、なんか色々細かくawaitしまくりで逆に遅くなったら意味ないし。それならドストレートに行ったほうがいいのでは感が若干ある。どうせThreadなんてそこそこ余ってるんだから（←そうか？）局所的にParallelってもいいぢゃないと思いたい、とかなんとかかんとか。</p>
<h2>非.NET 4.5の場合</h2>
<p>Parallel.For, ForEachに関しては、localInit, localFinallyというタスク内で一意になる変数を利用したオーバーロードを利用して、似たような雰囲気で書けます。正確には同じ挙動ではないですが、まぁまぁ悪くない結果が得られます。</p>
<pre><code class="language-csharp">Parallel.For(1, 1000,
    () =&gt;
    {
        // local init
        var conn = new SqlConnection(&quot;接続文字列&quot;);
        conn.Open();
        return conn;
    },
    (x, state, connection) =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
        return connection;
    },
    (connection) =&gt;
    {
        // local finally
        connection.Dispose();
    });
</code></pre>
<p>オーバーロードが結構地獄でシンドイですね！ここも簡単にラップしたものを作りましょう。</p>
<pre><code class="language-csharp">public static class ParallelEx
{
    public static ParallelLoopResult DisposableFor&lt;TDisposable&gt;(long fromInclusive, long toExclusive, Func&lt;TDisposable&gt; resourceFactory, Action&lt;long, ParallelLoopState, TDisposable&gt; body)
        where TDisposable : IDisposable
    {
        return Parallel.For(fromInclusive, toExclusive, resourceFactory, (item, state, resource) =&gt; { body(item, state, resource); return resource; }, disp =&gt; disp.Dispose());
    }

    public static ParallelLoopResult DisposableForEach&lt;T, TDisposable&gt;(IEnumerable&lt;T&gt; source, Func&lt;TDisposable&gt; resourceFactory, Action&lt;T, ParallelLoopState, TDisposable&gt; body)
        where TDisposable : IDisposable
    {
        return Parallel.ForEach(source, resourceFactory, (item, state, resource) =&gt; { body(item, state, resource); return resource; }, disp =&gt; disp.Dispose());
    }
}
</code></pre>
<p>こうしたものを作れば、</p>
<pre><code class="language-csharp">ParallelEx.DisposableFor(1, 1000,
    () =&gt;
    {
        var conn = new var conn = new SqlConnection(&quot;接続文字列&quot;);
        conn.Open();
        return conn;
    },
    (x, state, connection) =&gt;
    {
        var _ = connection.Query&lt;DateTime&gt;(&quot;select current_timestamp&quot;).First(); // Dapper
    });
</code></pre>
<p>まぁまぁ許せる、かな？</p>
</div>
<h1><a href="https://neue.cc/2013/03/06_399.html">C#とランダム</a></h1>
<ul class="date"><li>2013-03-06</li></ul>
<div class="entry_body"><p>古くて新しいわけはない昔ながらのSystem.Randomのお話。Randomのコンストラクタは二種類あって、seed引数アリの場合は必ず同じ順序で数値を返すようになります。</p>
<pre><code class="language-csharp">// 何度実行しても同じ結果
var rand = new Random(0);
Console.WriteLine(rand.Next()); // 1559595546
Console.WriteLine(rand.Next()); // 1755192844
Console.WriteLine(rand.Next()); // 1649316166
</code></pre>
<p>例えばゲームのリプレイなどは、ランダムだけど同一の結果が得られることを期待したいわけなので、大事大事ですね。(とはいえ、Windows-CLIとLinux-monoでは結果が違ったりするので、マルチプラットフォームでの共有などという場合は、別策を取ったほうがよさそうです)。何も渡さない場合はseedとしてEnvironment.TickCountが渡されます。精度はミリ秒。ということは、ですね、例えばループの中でRandomをnewするとですよ、</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 100; i++)
{
    var rand = new Random();
    Console.WriteLine(rand.Next());
}
</code></pre>
<p>マシンスペックにもよりますが、私の環境では30個ぐらい同じ数値が出た後に、別の、また30個ぐらい同じ数値が続き……となりました。何故か、というと、seedがEnvironment.TickCountだからで、ループ内といったようなミリ秒を超える超高速の状態で生成されている時は、seed値が同じとなってしまうから。なので、正しくは</p>
<pre><code class="language-csharp">var rand = new Random();
for (int i = 0; i &lt; 100; i++)
{
    Console.WriteLine(rand.Next());
}
</code></pre>
<p>といったように、ループの外に出す必要性があります。</p>
<h2>ランダムなランダム</h2>
<p>では、ランダムなランダムが欲しい場合は。例えばマルチスレッド。そうでなくても、例えばループの外に出す（直接的でなくてもメソッドの中身がそうなっていて、意図せず使われてしまう可能性がある）のを忘れてしまうのを強制的に避ける場合。もしくは、別にマルチスレッドは気を付けるよー、といっても、ASP.NETとか複数リクエストが同時に走るわけで、同タイミングでのRandom生成になってしまう可能性は十分にある。そういう時は、RandomNumberGeneratorを使います。</p>
<pre><code class="language-csharp">using (var rng = new RNGCryptoServiceProvider())
{
    // 厳密にランダムなInt32を作る
    var buffer = new byte[sizeof(int)];
    rng.GetBytes(buffer);
    var seed = BitConverter.ToInt32(buffer, 0);
    // そのseedを基にRandomを作る
    var rand = new Random(seed);
}
</code></pre>
<p>これでマルチスレッドでも安全安心だ！勿論、RNGCryptoServiceProviderはちょっとコスト高。でも、全然我慢できる範囲ではある。お終い。</p>
<h2>ThreadLocal</h2>
<p>でも、これって別にスレッドセーフなランダムが欲しいってだけなわけだよね、それなのにちょっとした、とはいえ、コスト高を背負うのって馬鹿げてない？そこで出てくるのが<a href="http://msdn.microsoft.com/ja-jp/library/dd642243.aspx">ThreadLocal&lt;T&gt;</a>、.NET 4.0以降ですが、スレッド単位で一意な変数を宣言できます。それを使った、<a href="http://csharpindepth.com/Articles/Chapter12/Random.aspx">Jon Skeet氏（ゆーめーじん）の実装</a>は</p>
<pre><code class="language-csharp">public static class RandomProvider
{    
    private static int seed = Environment.TickCount;
    
    private static ThreadLocal&lt;Random&gt; randomWrapper = new ThreadLocal&lt;Random&gt;(() =&gt;
        new Random(Interlocked.Increment(ref seed))
    );

    public static Random GetThreadRandom()
    {
        return randomWrapper.Value;
    }
}
</code></pre>
<p>なるほどねー！これなら軽量だし、とってもセーフで安心できるしイイね！もし複数スレッドで同時タイミングで初期化が走った時のために、Interlocked.Incrementで、必ず違う値がseedになるようになってるので、これなら色々大丈夫。</p>
<h2>マルチスレッド→マルチサーバー</h2>
<p>けれど、大丈夫なのは、一台のコンピューターで完結する時だけの時の話。クラウドでしょ！サーバー山盛りでしょ！な時代では、サーバーをまたいで同時タイミングなEnvironment.TickCountで初期化されてしまう可能性が微レ存。というわけで、Environment.TickCountに頼るのは完全に安全ではない。じゃあ、そう、合わせ技で行けばいいじゃない、seedは完全ランダムで行きましょう。</p>
<pre><code class="language-csharp">public static class RandomProvider
{
    private static ThreadLocal&lt;Random&gt; randomWrapper = new ThreadLocal&lt;Random&gt;(() =&gt;
    {
        using (var rng = new RNGCryptoServiceProvider())
        {
            var buffer = new byte[sizeof(int)];
            rng.GetBytes(buffer);
            var seed = BitConverter.ToInt32(buffer, 0);
            return new Random(seed);
        }
    });

    public static Random GetThreadRandom()
    {
        return randomWrapper.Value;
    }
}
</code></pre>
<p>これで、軽量かつ安全安泰なRandomが手に入りました。めでたしめでたし。</p>
</div>
<h1><a href="https://neue.cc/2013/02/27_398.html">AsyncOAuth - C#用の全プラットフォーム対応の非同期OAuthライブラリ</a></h1>
<ul class="date"><li>2013-02-27</li></ul>
<div class="entry_body"><p>待ち望まれていた<a href="http://blogs.msdn.com/b/bclteam/archive/2013/02/18/portable-httpclient-for-net-framework-and-windows-phone.aspx">HttpClientがPortable Class Library化</a>しました、まだBetaだけどね！というわけで、早速PCL版のHttpClientをベースにしたOAuthライブラリを仕上げてみました。ポータブルクラスライブラリなので、.NET 4.5は勿論、Windows Phone 7.5, 8, Windows Store Apps, Silverlight, それと.NET 4.0にも対応です。</p>
<ul>
<li><a href="https://github.com/neuecc/AsyncOAuth">AsyncOAuth - GitHub</a></li>
</ul>
<p>前身のReactiveOAuthがTwitterでしかロクにテストしてなくてHatenaでズタボロだったことを反省し、今回はSampleにTwitterとHatenaを入れておきました＆どっちでもちゃんと正常に動きます。なお、完全に上位互換なので、ReactiveOAuthはObsoleteです。それと、ライブラリのインストールはNuGet経由でのみの提供です。</p>
<p>PM&gt; Install-Package <a href="https://nuget.org/packages/AsyncOAuth/">AsyncOAuth -Pre</a></p>
<p>もしくはPreReleaseを表示に含めてGUIから検索してください。</p>
<h2>AsyncOAuth is not a new library</h2>
<p>AsyncOAuthの実態はOAuthMessageHandlerというDelegatingHandlerです。</p>
<pre><code class="language-csharp">var client = new HttpClient(new OAuthMessageHandler(&quot;consumerKey&quot;, &quot;consumerSecret&quot;, new AccessToken(&quot;accessToken&quot;, &quot;accessTokenSecret&quot;)));

// 上のだとnewの入れ子が面倒なので短縮形、戻り値は上のと同じ
var client = OAuthUtility.CreateOAuthClient(&quot;consumerKey&quot;, &quot;consumerSecret&quot;, new AccessToken(&quot;accessToken&quot;, &quot;accessTokenSecret&quot;));
</code></pre>
<p>こうなっていると何がいいか、というと、全ての操作がHttpClient標準通りなのです。</p>
<pre><code class="language-csharp">// Get
var json = await client.GetStringAsync(&quot;http://api.twitter.com/1.1/statuses/home_timeline.json?count=&quot; + count + &quot;&amp;page=&quot; + page);

// Post
var content = new FormUrlEncodedContent(new[] { new KeyValuePair&lt;string, string&gt;(&quot;status&quot;, status) });
var response = await client.PostAsync(&quot;http://api.twitter.com/1.1/statuses/update.json&quot;, content);
var json = await response.Content.ReadAsStringAsync();

// Multi Post
var content = new MultipartFormDataContent();
content.Add(new StringContent(status), &quot;\&quot;status\&quot;&quot;);
content.Add(new ByteArrayContent(media), &quot;media[]&quot;, &quot;\&quot;&quot; + fileName + &quot;\&quot;&quot;);

var response = await client.PostAsync(&quot;https://upload.twitter.com/1/statuses/update_with_media.json&quot;, content);
var json = await response.Content.ReadAsStringAsync();
</code></pre>
<p>もうおれおれクライアントのAPIを覚える必要はありません。これからの標準クライアントであるHttpClientの操作だけを覚えればいいのです。</p>
<p>コンセプトはHttpClientチームから掲示されているサンプルコード<a href="http://blogs.msdn.com/b/henrikn/archive/2012/02/16/extending-httpclient-with-oauth-to-access-twitter.aspx">Extending HttpClient with OAuth to Access Twitter</a>どおりですが、このサンプルコードは本当にただのコンセプトレベルなサンプルで、そのまんまじゃ使えないので、ちゃんと実用的なOAuthライブラリとして叩き直したのがAsyncOAuthになります。DelegatingHandlerというのは、リクエストを投げる直前をフックするものなので、そこでOAuth用の認証を作っているわけです。</p>
<h2>イニシャライズ</h2>
<p>使う場合は、必ず最初にHMAC-SHA1の計算関数をセットしなければなりません。何故か、というと、ポータブルクラスライブラリには現状、暗号系のライブラリが含まれていなくて、その部分は含むことができないからです。外部から差し込んでもらうことでしか対処できない、という。ご不便おかけしますが、的な何か。そのうち含まれてくれるといいなあ、って感じですねえ。それまでは、以下のコードをApp.xaml.csとかApplication_Startとか、初回の本当に最初の最初に呼ばれるところに、コピペってください。</p>
<pre><code class="language-csharp">// WinRT以外(Silverlight, Windows Phone, Consoleなどなど)
OAuthUtility.ComputeHash = (key, buffer) =&gt; { using (var hmac = new HMACSHA1(key)) { return hmac.ComputeHash(buffer); } };

// Windows Store App(めんどうくせえええええ)
AsyncOAuth.OAuthUtility.ComputeHash = (key, buffer) =&gt;
{
    var crypt = Windows.Security.Cryptography.Core.MacAlgorithmProvider.OpenAlgorithm(&quot;HMAC_SHA1&quot;);
    var keyBuffer = Windows.Security.Cryptography.CryptographicBuffer.CreateFromByteArray(key);
    var cryptKey = crypt.CreateKey(keyBuffer);

    var dataBuffer = Windows.Security.Cryptography.CryptographicBuffer.CreateFromByteArray(buffer);
    var signBuffer = Windows.Security.Cryptography.Core.CryptographicEngine.Sign(cryptKey, dataBuffer);

    byte[] value;
    Windows.Security.Cryptography.CryptographicBuffer.CopyToByteArray(signBuffer, out value);
    return value;
};
</code></pre>
<p>また、使いかたの詳しいサンプルは、GitHub上のソースコードからAsyncOAuth.ConsoleAppの中にTwitter.csとHatena.csがあるので、それを見てもらえればと思います。AccessToken取得までの、認証系の説明はここには書きませんが（OAuthAuthorizerという特別に用意してあるものを使う）、その具体的な書き方が乗っています。特にHatenaの認証はTwitterに比べるとかなりメンドーくさいので、メンドーくさい系のOAuthが対象の場合は参考になるかと思います。</p>
<h2>ストリーミング、Single vs Multiple、或いはRxの再来</h2>
<p>勿論、TwitterのストリーミングAPIにも対応できます。以下のようなコードを書けばOK。</p>
<pre><code class="language-csharp">public async Task GetStream(Action&lt;string&gt; fetchAction)
{
    var client = OAuthUtility.CreateOAuthClient(consumerKey, consumerSecret, accessToken);
    client.Timeout = System.Threading.Timeout.InfiniteTimeSpan; // ストリーミングなのでTimeoutで切られないよう設定しておくこと

    using (var stream = await client.GetStreamAsync(&quot;https://userstream.twitter.com/1.1/user.json&quot;))
    using (var sr = new StreamReader(stream))
    {
        while (!sr.EndOfStream)
        {
            var s = await sr.ReadLineAsync();
            fetchAction(s);
        }
    }
}
</code></pre>
<p>ほぅ、Actionですか、コールバックですか……。ダサい。使い勝手悪い。最悪。しかし、じゃあ何返せばいいんだよ！ということになる。Taskは一つしか返せない、でもストリーミングは複数。うーん、うーん、と、そこでIObservable&lt;T&gt;の出番です。Reactive Extensionsを参照して、以下のように書き換えましょう。</p>
<pre><code class="language-csharp">public IObservable&lt;string&gt; GetStream()
{
    return Observable.Create&lt;string&gt;(async (observer, ct) =&gt;
    {
        try
        {
            var client = OAuthUtility.CreateOAuthClient(consumerKey, consumerSecret, accessToken);
            client.Timeout = System.Threading.Timeout.InfiniteTimeSpan; // ストリーミングなのでTimeoutで切られないよう設定しておくこと

            using (var stream = await client.GetStreamAsync(&quot;https://userstream.twitter.com/1.1/user.json&quot;))
            using (var sr = new StreamReader(stream))
            {
                while (!sr.EndOfStream &amp;&amp; !ct.IsCancellationRequested)
                {
                    var s = await sr.ReadLineAsync();
                    observer.OnNext(s);
                }
            }
        }
        catch (Exception ex)
        {
            observer.OnError(ex);
            return;
        }
        if (!ct.IsCancellationRequested)
        {
            observer.OnCompleted();
        }
    });
}
</code></pre>
<pre><code class="language-csharp">var client = new TwitterClient(consumerKey, consumerSecret, new AccessToken(accessTokenKey, accessTokenSecret));

// subscribe async stream
var cancel = client.GetStream()
    .Skip(1)
    .Subscribe(x =&gt; Console.WriteLine(x));

Console.ReadLine();
cancel.Dispose(); // キャンセルはDisposeで行う
</code></pre>
<p>といったように、自然にRxと繋げられます。コールバックのObservable化はObservable.Createで、そんなに難しくはない(ただしOnNext以外にちゃんとOnError, OnCompletedも記述してあげること)です。キャンセル対応に関しては、ちゃんとCancelleationToken付きのオーバーロードで行いましょう。そうしないと、Subscribeの解除はされていても、内部ではループが延々と動いている、といったような状態になってしまいますので。</p>
<p>ともあれ、asyncやCancellationTokenとRxがスムースに結合されていることは良くわかるかと思います。完璧！</p>
<p>こういった、単発の非同期はTaskで、複数の非同期はIObservable&lt;T&gt;で行う、というガイドはTPLチームからも示されています。先日の<a href="http://blogs.msdn.com/b/pfxteam/archive/2013/02/20/mvp-summit-presentation-on-async.aspx">pfxteamからのスライド</a>から引用すると（ちなみにこのスライドはTask系の落とし穴などが超丁寧に書かれているので必読！）</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/asnc_sync_mult.jpg">
</p>
<p>といった感じです。んねー。</p>
<h2>まとめ</h2>
<p>ReactiveOAuthはオワコン。HttpClient始まってる。Reactive Extensions自体は終わってない、むしろ始まってる。というわけで、色々と使いこなしていきましょう。</p>
<p>追記：リリースから一晩開けて、POST周りを中心にバグが発見されていてお恥ずかしい限りです。あらかた修正したとは思うのですが(NuGetのバージョンは随時上げています)、怪しい挙動見つけたら報告下さると嬉しいです。勿論、GitHubなのでPull Requestでも！</p>
</div>
<h1><a href="https://neue.cc/2013/02/19_397.html">C#でぬるぽを回避するどうでもいい方法</a></h1>
<ul class="date"><li>2013-02-19</li></ul>
<div class="entry_body"><p>どうもペチパーです。嘘です逃げないで。まあ、どうでもいいPHPの例をまずは出しませう。あ、逃げないで、PHPの話はすぐやめるんで。</p>
<pre><code class="language-php">// ネストしてる配列
$hoge[&quot;huga&quot;][&quot;hage&quot;][&quot;tako&quot;] = &quot;なのなの&quot;;

// なのなの
$v = isset($hoge[&quot;huga&quot;][&quot;hage&quot;][&quot;tako&quot;])
    ? $hoge[&quot;huga&quot;][&quot;hage&quot;][&quot;tako&quot;]
    : &quot;ない&quot;;

// 途中で欠けてる配列
$hoge[&quot;huga&quot;] = &quot;なのなの&quot;;

// ない
$v = isset($hoge[&quot;huga&quot;][&quot;hage&quot;][&quot;tako&quot;])
    ? $hoge[&quot;huga&quot;][&quot;hage&quot;][&quot;tako&quot;]
    : &quot;ない&quot;;
</code></pre>
<p>全体的にキモいんですが、まあ無視してもらって、何が言いたいか、と言うとisset。これはネストしてる部分も一気に評価してくれるのです。フツーの関数だと常識的に考えて評価は先に内側で行うので配列の境界外で死ぬんですが、issetは関数みたいな見た目だけど実は言語構文なのだ！キモチワルイ。ともあれ、そんなわけでネストしてるものの有無を一気にチェックできるのです。</p>
<p>で、PHPのこと書いてるとサイト違うので、C#の話をしませう。</p>
<h2>C#でネストネスト</h2>
<p>PHPは何でも連想配列なのですが、C#だったらクラスのプロパティでしょうか。以下のようなシチュエーション。</p>
<pre><code class="language-csharp">// こういうドカドカした構造があるとして
class Hoge
{
    public Huga Prop1 { get; set; }
}

class Huga
{
    public Hage Prop2 { get; set; }
}

class Hage
{
    public string Prop3 { get; set; }
}

// こっちプログラム本体
var hoge = new Hoge();

// とちゅーでヌルぽが発生すると死んじゃうんの回避が醜悪！
var prop3 = (hoge != null &amp;&amp; hoge.Prop1 != null &amp;&amp; hoge.Prop1.Prop2 != null &amp;&amp; hoge.Prop1.Prop2.Prop3 != null)
    ? hoge.Prop1.Prop2.Prop3
    : null;
</code></pre>
<p>!=nullの連鎖が面倒くさいですぅー。なんとかしてくださいぃー。ぴーHPに負けてるんじゃないですかぁー？とか言われてないですが言われてるってことにするので、しょうがないからエレガントな解決策を探してあげました、誰にも頼まれてませんが！</p>
<h2>Love ExpressionTree</h2>
<p>こーいう風に書ければいいんでしょ！下のhoge.GetValueOrDefaultってとこです。</p>
<pre><code class="language-csharp">// こんなHogeがあるとして
var hoge = new Hoge();

// すっきり！
var value = hoge.GetValueOrDefault(x =&gt; x.Prop1.Prop2.Prop3);
Console.WriteLine(value == null); // true

// 中身が詰まってたら
hoge = new Hoge { Prop1 = new Huga { Prop2 = new Hage { Prop3 = &quot;ほげ！&quot; } } };
var value2 = hoge.GetValueOrDefault(x =&gt; x.Prop1.Prop2.Prop3);
Console.WriteLine(value2); // ほげ！
</code></pre>
<p>すっごくスッキリしますね！イイね！</p>
<p>で、どーやってるかというと、ExpressionTreeでグルグルですよ。</p>
<pre><code class="language-csharp">public static class MonyaMonyaExtensions
{
    public static TR GetValueOrDefault&lt;T, TR&gt;(this T value, Expression&lt;Func&lt;T, TR&gt;&gt; memberSelector)
        where T : class
    {
        var expression = memberSelector.Body;

        var memberNames = new List&lt;string&gt;();
        while (!(expression is ParameterExpression))
        {
            if ((expression is UnaryExpression) &amp;&amp; (expression.NodeType == ExpressionType.Convert))
            {
                expression = ((UnaryExpression)expression).Operand;
                continue;
            }

            var memberExpression = (MemberExpression)expression;
            memberNames.Add(memberExpression.Member.Name);
            expression = memberExpression.Expression;
        }

        object value2 = value;
        for (int i = memberNames.Count - 1; i &gt;= 0; i--)
        {
            if (value2 == null) return default(TR);
            var memberName = memberNames[i];
            dynamic info = value2.GetType().GetMember(memberName)[0];
            value2 = info.GetValue(value2);
        }

        return (TR)value2;
    }
}
</code></pre>
<p>はい。というわけで、一つ言えるのは、これ、あんま速くないんで実用には使わないでくださいね、あくまでネタです、ネタ。</p>
<h2>もにゃど</h2>
<p>それもにゃど、という人はLINQでMaybeモナドでも検索しませう。既出なので私は書きません。</p>
</div>
<h1><a href="https://neue.cc/2013/02/08_396.html">連打対策などりの同時アクセス禁止機構</a></h1>
<ul class="date"><li>2013-02-08</li></ul>
<div class="entry_body"><p>ゆるふわ連打対策のお時間です。連打されて無限にあーーーーーーー！という悲鳴を上げたり上げなかったりするとかしないとしても、何らかの対策したいよね！ということで、ASP.NETのお話。Application.Lock使ってSessionに、というのは複数台数あったら死ぬのでナシね(Application.Lockは当然、一台単位でのロックなので複数台数でロックは共有されてない)。そんなわけで、カジュアルな一手を打ちます。先に利用例から。</p>
<pre><code class="language-csharp">static void StandardUsage(string token)
{
    // 複数サーバーで共有されるロックもどきの取得
    using (var rock = DistributedLock.Acquire(&quot;StandardUsage-Lock-Token-&quot; + token))
    {
        rock.ThrowIfLockAlreadyExists(); // 二重に取得された場合は即座に例外！

        // 以下、本体を書けばいい
    }
}
</code></pre>
<p>こんなふーに書けると、楽ですね。tokenは、まあ好きな単位で。ユーザー一人の単位だったら、認証済みなら何らかのIDを。非認証状態なら、POSTのHiddenにGUIDでも仕込んでおけばいい、と。ただの連打対策ってわけじゃなく、複数ユーザー間で同時処理されるのを抑えたければ、何らかのキーを、例えばソーシャルゲームだとチーム単位で、チームIDでかけたりとかします。</p>
<p>ロックもどきには↑の例ではMemcachedを使いました。単純に、Memcachedに指定キーでAddしにいく→Keyが既に存在していると上書きしないで追加に失敗→二重実行時は必ず失敗したという結果を受け取れる(bool:falseで)→Disposeで追加出来たときのみキーを必ず削除する（＆保険でexpireもつけておく)</p>
<p>usingの部分は割と定型なので、毎回コントローラーを丸ごと囲むとかなら、属性作って、属性ペタッと貼るだけでOKみたいな形にするといいと思われます！</p>
<p>ド単純ですが、普通に機能して、結構幸せになれるかな？Memcachedならカジュアルに叩いても、相当耐えきれますから。あ、勿論、固定の台にリクエストが飛ぶの前提なのでノードがぐいぐい動的に追加削除されまくるよーな状況ではダメですよ、はい。あんまないでしょうが（Memcachedはクライアントサイドの分散で、複数台あってもキーが同一の場合は基本的に同じ台に飛ぶ）。</p>
<pre><code class="language-csharp">public class DistributedLockAlreadyExistsException : Exception
{
    public DistributedLockAlreadyExistsException(string key)
        : base(&quot;LockKey:&quot; + key)
    { }
}

public class DistributedLock : IDisposable
{
    static MemcachedClient client = new MemcachedClient();
    static readonly TimeSpan DefaultExpire = TimeSpan.FromSeconds(5);

    public bool IsAcquiredLock { get; private set; }
    string key;
    bool disposed;

    private DistributedLock(string key, TimeSpan expire)
    {
        this.key = key;
        this.IsAcquiredLock = client.Store(StoreMode.Add, key, DateTime.Now.Ticks, expire);
    }

    public static DistributedLock Acquire(string key)
    {
        return Acquire(key, DefaultExpire);
    }

    public static DistributedLock Acquire(string key, TimeSpan expire)
    {
        return new DistributedLock(key, expire);
    }

    public async Task&lt;bool&gt; WaitAndRetry(int retryCount, TimeSpan waitTime)
    {
        var count = 0;
        while (count++ &lt; retryCount &amp;&amp; !IsAcquiredLock)
        {
            await Task.Delay(waitTime);
            IsAcquiredLock = client.Store(StoreMode.Add, key, DateTime.Now.Ticks, DefaultExpire);
        }
        return IsAcquiredLock;
    }

    public void ThrowIfLockAlreadyExists()
    {
        if (!IsAcquiredLock)
        {
            throw new DistributedLockAlreadyExistsException(key);
        }
    }

    public void Dispose()
    {
        if (!disposed &amp;&amp; IsAcquiredLock)
        {
            disposed = true;
            var removeSuccess = client.Remove(key);
        }
        GC.SuppressFinalize(this);
    }

    ~DistributedLock()
    {
        Dispose();
    }
}
</code></pre>
<p>Memcachedのライブラリは<a href="https://github.com/enyim/EnyimMemcached">EnyimMemcached</a>です。</p>
<h2>Asyncとリトライ</h2>
<p>取得に失敗したら、間隔おいてリトライぐらいはしたいですよね、いや、連打対策なら不要ですが、そうでないように使う場合は。でも、ベタにThread.Sleepでまったりしたくないよねえ、という、そこでasyncですよ！async！</p>
<pre><code class="language-csharp">async static Task TaskUsage(string token)
{
    using (var rock = DistributedLock.Acquire(&quot;TaskUsage-Lock-Token-&quot; + token))
    {
        if (!rock.IsAcquiredLock)
        {
            // 200ミリ秒感覚で3回取得に挑戦する
            await rock.WaitAndRetry(3, TimeSpan.FromMilliseconds(200));
            rock.ThrowIfLockAlreadyExists(); // それでもダメなら例外投げるん
        }

        // 以下、本体を書けばいい！
    }
}
</code></pre>
<p>WaitAndRetryメソッドではawait Task.Delay(waitTime)によって待機させています。少し前だとまんどくせ、と思って書く気のしない処理も、C# 5.0のお陰でカジュアルに書けるようになっていいですね。</p>
<h2>Memcachedを立てないサーバー一台の場合</h2>
<p>サーバー一台の場合は、わざわざMemcached立てるのも馬鹿らしいので、インメモリなキャッシュを代替として使えばいいと思われます。HttpRuntime.Cacheでも、System.Runtime.Caching.MemoryCacheでも、なんでもを、client.Storeのとこに差し替えてもらえれば。ただ、MemoryCacheは何かちょっと今回試すためにもぞもぞ弄ってたんですが、Addまわりの挙動がすんごく怪しくて信用ならない気がするので私は使うのパス。大丈夫なのかなあ。</p>
<h2>まとめ</h2>
<p>うーん、まんま、かつ、ゆるふわ単純な話なので特にまとめる話はないかしらん。</p>
<p>ので、We're Hiringということで<a href="http://grani.jp/">謎社のほめぱげが少しだけリニューアル</a>、ただしリクルートページが諸事情でまだ工事中！メールフォーム入れるつもりなので、↑のような感じにC# 5.0をすぐに振り回すような最先端な環境のC#でウェブな開発がやりたい方は、是非応募してください。相当本気で人が欲しいところですねー。現状ですけれど、<a href="http://gamebiz.jp/?p=93013">リリース2週間で早くもランキング3位を獲得</a>などと、あまり細かくは言えないのですけれど、まあ非常に好調ですので、安心して＆是非とも一緒に加速させましょう。</p>
</div>
<h1><a href="https://neue.cc/2013/02/02_395.html">Razorで空テンプレートとセパレータテンプレート</a></h1>
<ul class="date"><li>2013-02-02</li></ul>
<div class="entry_body"><p>Razorに限らずT4でもなんでもいいんですが、テンプレートで素のforeachだと、セパレータだったり空の時の代替テンプレートだったりを、どういう風に表現すればいいのかなあ、と悩ましいのです、どうなっているのでしょう実際世の中的に。</p>
<p>WebFormsのRepeaterだとSeparatorTemplateタグと、拡張すればEmptyTemplateなども作れますね。Smarty(PHPのテンプレート、最近ペチパーなので)には{foreachelse}で配列が空の時のテンプレートが吐かれます。カスタムの構文を定義すれば、勿論なんだってありです。</p>
<p>RepeaterにせよSmartyにせよ、よーするところ独自のテンプレート構文だから好き放題できますが、俺々構文って、それ自体の覚える手間もあり、あんまスッキリしないんですよねえ。RazorのIs not a new language、だからEasy to Learn。は大事。また、そういった独自拡張がないからこそ、Compact, Expressive, and Fluidが実現できる(開き@だけで閉じタグレスはやっぱ偉大)し、フルにIntelliSenseなどエディタサポートも効くわけだし。</p>
<p>やりたいことって、コード上のノイズが限りなく少なく、かつ、HTMLという&quot;テキスト&quot;を最大限コントロールの効く形で吐くこと。なわけで、その辺を損なっちゃあ、見失っちゃあ、いけないね。</p>
<p>で、しかしようするところ、やりたいのはforeachを拡張したい。foreachする時に空の時の出力とセパレータの時の出力を足したい。あと、どうせならインデックスも欲しい。あと、最初の値か、とか最後の値か、とかも欲しい（最初はともかく「最後」はindexがないものを列挙すると大変）</p>
<p>そのうえで、Razorの良さである素のC#構文（と、ほぼほぼ同じものとして扱える）というのを生かしたうえで、書きやすくするには(例えばHtmlヘルパーに拡張メソッド定義して、引数でテンプレートやラムダ渡したり、というのは閉じカッコが増えたり空ラムダが出たりして書きづらいしグチャグチャしてしまいクリーンさが消える)、と思って、考えたのが、foreachで回すアイテム自体に情報載せればいいな、と。</p>
<pre><code class="language-csharp">&lt;table&gt;
    @foreach (var item in source.ToLoopItem(withEmpty: true, withSeparator: true))
    {
        // empty template
        if (item.IsEmpty)
        {
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;中身が空だよ！&lt;/td&gt;
        &lt;/tr&gt;
        }

        // separator
        if (item.IsSeparator)
        { 
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot;&gt;------------&lt;/td&gt;
        &lt;/tr&gt;
        }

        // body
        if (item.IsElement)
        {
        &lt;tr style=&quot;@(item.IsLast ? &quot;background-color:red&quot; : null)&quot;&gt;
            &lt;td&gt;@item.Index&lt;/td&gt;
            &lt;td&gt;@item.Item&lt;/td&gt;
        &lt;/tr&gt;
        }
    }
&lt;/table&gt;
</code></pre>
<p>何も足さない何も引かない。とはいえどっかに何か足さなきゃならない。C#として崩さないで足すんなら、単独の要素の一つ上に包んで情報を付与してやりゃあいいんだね、と。foreachで回す時にToLoopItem拡張メソッドを呼べば、情報を足してくれます。</p>
<p>IsEmptyは全体が空の時、IsSeparatorは要素の間の時、IsElementが本体の要素の列挙の時、を指します。Elementの時は、更にIsFirst, IsLast, Indexが取れる。item.Itemはちょっと間抜けか。ともあれ、実際にRazorで書いてみた感触としても悪くなく収まってる。</p>
<p>Emptyだけならばループの外で@if(!source.Any()) /* 空の時のテンプレート */ としてやればいいし、そのほうが綺麗感はある。けれど、それだとsourceがIEnumerableの時キモチワルイ（二度列挙開始が走る）とかもあるし、コレクションに関わるものはforeachのスコープ内に全部収まったほうがスッキリ感も、なくもない。</p>
<p>IndexとIsLastだけが欲しいなら、空テンプレートとセパレータはオプションだから、withEmpty, withSeparatorを共にfalseにすれば、全部Elementなので、if(item.IsElement)は不要になる。</p>
<p>それにしてもRazor V2で属性にnull渡すと属性自体を吐かないでくれる機能は素敵ですなあ。クリーンは正義！</p>
<p>実装はこんな感じ。</p>
<pre><code class="language-csharp">public struct LoopItem&lt;T&gt;
{
    public readonly bool IsEmpty;
    public readonly bool IsSeparator;
    public readonly bool IsElement;
    public readonly bool IsFirst;
    public readonly bool IsLast;
    public readonly int Index;
    public readonly T Item;

    public LoopItem(bool isEmpty = false, bool isSeparator = false, bool isElement = false, bool isFirst = false, bool isLast = false, int index = 0, T item = default(T))
    {
        this.IsEmpty = isEmpty;
        this.IsSeparator = isSeparator;
        this.IsElement = isElement;
        this.IsFirst = isFirst;
        this.IsLast = isLast;
        this.Index = index;
        this.Item = item;
    }

    public override string ToString()
    {
        return (IsEmpty) ? &quot;Empty&quot;
             : (IsSeparator) ? &quot;Separator&quot;
             : Index + &quot;:&quot; + Item.ToString();
    }
}

public static class LoopItemEnumerableExtensions
{
    public static IEnumerable&lt;LoopItem&lt;T&gt;&gt; ToLoopItem&lt;T&gt;(this IEnumerable&lt;T&gt; source, bool withEmpty = false, bool withSeparator = false)
    {
        if (source == null) source = Enumerable.Empty&lt;T&gt;();

        var index = 0;
        using (var e = source.GetEnumerator())
        {
            var hasNext = e.MoveNext();
            if (hasNext)
            {
                while (true)
                {
                    var item = e.Current;
                    hasNext = e.MoveNext();
                    if (hasNext)
                    {
                        yield return new LoopItem&lt;T&gt;(index: index, isElement: true, isFirst: (index == 0), item: item);
                    }
                    else
                    {
                        yield return new LoopItem&lt;T&gt;(index: index, isElement: true, isFirst: (index == 0), isLast: true, item: item);
                        break;
                    }

                    if (withSeparator) yield return new LoopItem&lt;T&gt;(index: index, isSeparator: true);
                    index++;
                }
            }
            else
            {
                if (withEmpty)
                {
                    yield return new LoopItem&lt;T&gt;(isEmpty: true);
                }
            }
        }
    }
}
</code></pre>
<p>大事なのは、IEnumerable&lt;T&gt;へのループは必ず一回にすること、ね。よくあるAny()で調べてから、ループ本体を廻すと、二度列挙実行が走る（Anyは最初を調べるだけですが、もしIEnumerable&lt;T&gt;が遅延実行の場合、そのコストは読めない）というのは、精神衛生上非常に良くない。</p>
<p>あとIsLastを取るために、一手先を取得してからyield returnをしなければならないので、少しゴチャついてしまいましたが、まあ、こういうのがViewの表面上に現れる苦難を思えば！</p>
<p>最近、イミュータブルな入れ物を作りたい時はコンストラクタにずらずら引数並べるでファイナルアンサー。と思うようになりました、一周回って。名前付き引数で書かせれば、数が多くても可読性落ちたりとかないですし、これでいいでしょう。名前付きで書かせることを強制したいけれど、それは無理なので適度に諦めるとして。</p>
<p>最後にユニットテストを置いておきます。例によってMSTest + <a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>で。</p>
<pre><code class="language-csharp">[TestClass]
public class LoopItemTest
{
    [TestMethod]
    public void Empty()
    {
        Enumerable.Empty&lt;int&gt;().ToLoopItem(withEmpty: false).Any().IsFalse();
        Enumerable.Empty&lt;int&gt;().ToLoopItem(withEmpty: true).Is(new LoopItem&lt;int&gt;(isEmpty: true));
        ((IEnumerable&lt;int&gt;)null).ToLoopItem(withEmpty: false).Any().IsFalse();
        ((IEnumerable&lt;int&gt;)null).ToLoopItem(withEmpty: true).Is(new LoopItem&lt;int&gt;(isEmpty: true));
    }

    [TestMethod]
    public void Separator()
    {
        Enumerable.Range(1, 3).ToLoopItem(withSeparator: false).Is(
            new LoopItem&lt;int&gt;(index: 0, item: 1, isFirst: true, isElement: true),
            new LoopItem&lt;int&gt;(index: 1, item: 2, isElement: true),
            new LoopItem&lt;int&gt;(index: 2, item: 3, isLast: true, isElement: true)
        );

        Enumerable.Range(1, 1).ToLoopItem(withSeparator: true).Is(
            new LoopItem&lt;int&gt;(index: 0, item: 1, isFirst: true, isLast: true, isElement: true)
        );

        Enumerable.Range(1, 3).ToLoopItem(withSeparator: true).Is(
            new LoopItem&lt;int&gt;(index: 0, item: 1, isFirst: true, isElement: true),
            new LoopItem&lt;int&gt;(index: 0, isSeparator: true),
            new LoopItem&lt;int&gt;(index: 1, item: 2, isElement: true),
            new LoopItem&lt;int&gt;(index: 1, isSeparator: true),
            new LoopItem&lt;int&gt;(index: 2, item: 3, isLast: true, isElement: true)
        );

        Enumerable.Range(1, 4).ToLoopItem(withSeparator: true).Is(
            new LoopItem&lt;int&gt;(index: 0, item: 1, isFirst: true, isElement: true),
            new LoopItem&lt;int&gt;(index: 0, isSeparator: true),
            new LoopItem&lt;int&gt;(index: 1, item: 2, isElement: true),
            new LoopItem&lt;int&gt;(index: 1, isSeparator: true),
            new LoopItem&lt;int&gt;(index: 2, item: 3, isLast: false, isElement: true),
            new LoopItem&lt;int&gt;(index: 2, isSeparator: true),
            new LoopItem&lt;int&gt;(index: 3, item: 4, isLast: true, isElement: true)
        );
    }
}
</code></pre>
<p>structだと同値比較のために何もしなくていいのが楽ですね、けれどChaining AssertionならIsStructuralEqualがあるので、もしclassでも、やっぱり楽です！</p>
<h2>まとめ</h2>
<p>RazorだけじゃなくT4でコレクション回す時なんかにも使えます。なにかと毎度毎度、悩みの種なんですよねー。他に、こういうやり方もいいんでないー？とかあったら教えてください。</p>
</div>
<h1><a href="https://neue.cc/2013/01/29_394.html">Modern C# Programming 現代的なC#の書き方、ライブラリの選び方</a></h1>
<ul class="date"><li>2013-01-29</li></ul>
<div class="entry_body"><p>と、題しまして<a href="https://itmedia.smartseminar.jp/public/seminar/view/465">第1回 業開中心会議 .NET技術の断捨離</a>で話してきました。岩永さんが概念的なものを、私がC#とライブラリにフォーカスして具体的なものを、パネルディスカッションでフレームワーク周りの話を。的な分担だったでしょうか。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/16217129" width="597" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/modern-c-programming-img" title="Modern C# Programming 現代的なC#の書き方、ライブラリの選び方" target="_blank">Modern C# Programming 現代的なC#の書き方、ライブラリの選び方</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a></strong> </div>
<p>Modern、といっても、すんごく最先端で尖った感じ！ではなくて、本来は今そこに当たり前のようにあるやり方を、ちゃんと選択していこう。といったような内容です。対象をどの辺に置こうかなあ、といったところで、やっぱ@ITでいうギョーカイだと、ラムダ禁止とか.NET 2.0を強いられているんだ、とかそういう人も少なくないのだろうと思ったので、その辺りを最低ラインに敷いて中身を組みました。</p>
<p>つまりLINQ使えってことですよ！というか、もう登場から5年も経とうとしているのに、未だにLINQ使うべきだよ！と言って回らなければならない事実が悲しくもあり。ちなみに他の言語にもLINQ的なものはあるのに、それでもなお何故LINQが良いか、という答えは、IntelliSenseにあります。IntelliSenseの気持ちよさをどう最大限に生かすか。それを考えるのが大事で、IntelliSenseにフォーカスしてプログラムを書くのが、真のModern C# Programmingなのです、というのがメッセージです。嘘。</p>
<h2>パネルディスカッション補足</h2>
<p>DataSetは、もう古臭いし捨てればいいぢゃーん。なわけですが、UIコンポーネントがDataSet依存なんです！という場合は、そりゃしょうがない。アプリケーションを作るにあたって何を優先するか、であり、そのコンポーネントを使うのが最優先な条件なら、回避不能です。案としては、DataSetを必要としないUIコンポーネントを買うべき、といったところです。スライド中にも入れましたけれど、資産は本当に資産なのか？負債じゃあないのか？と。負の遺産に縛られるのは何よりも苦しいことです。</p>
<p>EntityFrameworkの是非については、うーん、そもそも私はORMは幻想だと思っているところがあるので、根源的にYES、って言いづらいのですよね。別に、もう悪くもないと思ってます。ここで言いたかったのは、選択肢があるよ、ということです。EntityFrameworkというかORMを「使わなければならない」ことは全くない。そういうメッセージを伝えたいのです。</p>
<p>データアクセステクノロジとしてLINQ to SQLを採用していない環境で、LINQ to ObjectsとLINQ to SQLが誤爆するということを懸念している、という話が出ました。少しでも知識のある人ならば「絶対にない」ということは分かります。失礼な言い方をすれば、知識のない人が先入観だけでアリかナシかをトップダウンで決めている、そういう現状があることが停滞を生んでるのではないかな。</p>
<p>WebFormsの未来は、あるのかないのか、本当に使い分けなんてあるのか。ね、まあ、ないよね。WebFormsのコンセプトとか、私は結構好きです、今も。でも、Webの進化についていけなかった結果、生のHTMLと生のJavaScriptとコンポーネントが混じり合ってカオスになってる。中途半端な抽象化ならば、ないほうがよっぽどマシで、WebFormsの達成したかった理想は失敗したといってもいい。</p>
<p>MSがちゃんとWebFormsにも開発リソース割いてるよ、安心してよ、といっても、最低限の現状維持ぐらいでは？私はMSが全力で注力してWebFormsを立て直そうとすれば、立て直せたのじゃないかな、と思ってます。でも、それでMVC側に割くリソースをWebFormsに振るとか愚かしいし、だから実際振られてない。つまるところWebFormsの未来はどうなのか、そりゃ暗いよね。</p>
<p>管理画面はWebFormsで、みたいな話も眉唾なんですよね。使用技術が分かれる（しかも一方は暗い未来のもの）のは良いことかといったら、NOでしょう。別に、既にWebFormsに習熟しているし、既存資産（そう！資産ね、いつだってそうだ！）があるならいいでしょう。でも、これからの人は最初からASP.NET MVCで、WebFormsなんて全然知らなくて。といったことになるでしょ。その時どーなの？その資産を残していきたいの？それだったらMVCでGridView的なものをやるための手法を確立するほうが、よほど資産じゃないの？</p>
<p>などなどですが、WinForms→WPFのように、明らかに後継、のような形でない以上は、Microsoftからはお茶濁しなアナウンスしかこないでしょう。そういうのは、しょうがない。なので、あなたが思っている、それが答えとなります。</p>
<h2>謎社始まりました</h2>
<p>スライドの自己紹介にも書きましたが、謎社改め<a href="http://grani.jp/">株式会社グラニ</a>はじまりました。去年の9月に設立で、私もほぼほぼ設立期メンバーとして働いていました（ほぼほぼ、なのはシンガポール行ってたりなんだったりだったのでジョインが若干遅れた）。ちょうどセッションの前日に第一弾タイトル、<a href="http://gamebiz.jp/?p=91132">神獄のヴァルハラゲート</a>がGREEでリリースされました！わー、きゃー。ソーシャルゲーム、ではありますが、ゲーマー視点であっても良い内容に仕上がっていると誇れるだけのものは出来たと思っています（私だけじゃなく、チームとして、ね）。ので、試してみてもらえると嬉しいです。</p>
<p>さて、そうしてうまく立ち上がったことで、謎社も人を募集するフェーズに入ります。C#エンジニア、はもとよりサーバー管理とかインフラとかフロントエンドとかデータマイニングとか、まあ色々な職種の人間が全然足りません（ぶっちけ全員アプリケーションエンジニアなので）。というわけで、興味あるという人は、私のほうまでメール ils@neue.cc でもTwitterでも声かけてもらえるといいかな、と思います。採用ページは出すかもしれないし、その前に埋まるかもしれないし、なので。</p>
<p>個人的には、日本を代表するC#の企業にしたいと思っています。そして、それが出来るメンバーが揃っています（代表する、ためには技術だけではなく企業として育つ＝良いコンテンツがなければダメなわけで、それが出来るずば抜けた実力のプランナーやイラストレーターが在籍している）。詳しい話はその時に、という感じではありますが、大きく成長出来ると思っていますので、是非是非お待ちしております。</p>
</div>
<h1><a href="https://neue.cc/2013/01/10_393.html">C#でFlash Liteなswfをバイナリ編集して置換する</a></h1>
<ul class="date"><li>2013-01-10</li></ul>
<div class="entry_body"><p>Flash Liteに限定しませんが、そういうのをどうしてもしたい！というシチュエーションは少なからずごく一部であるようです。どーいうことかというと、ガラケーが積んでるFlash Lite、は、パラメータを受け取って、それをもとにどうこうする、というのが非常に弱い。ほぼほぼ出来ない。でも、違うメッセージを表示したい、画像を変えたい、などという需要があります。特に、ソーシャルゲームはまさにそうで。そこで各社がどういう手段を取っているかというと、.swfを開いてバイナリ編集して、直接、テキストだったり画像だったりを置換しています。</p>
<p>RubyやPHPには有名なライブラリがあって実例豊富だけれど、ドトネトにはない。というのが弱点の一つでした。ん？あれ？gloopsではどうしていたの？というとそこのところは内緒（辞めた人間なのであまり言えません）</p>
<p>で、SWF仕様読みながら自前で解析してやるしかないかなあ、画像置換ぐらいしかやらないからフルセットの再現はしなくていいので、手間でもないだろう、でも手間だなあ、嫌だなあ、と思ったら、ライブラリ、あったじゃないですか！それが<a href="https://github.com/debreuil/Swf2XNA">Swf2XNA</a>。to XNAということでFlashをXNAで使えるようにする(<a href="http://gree.github.com/lwf/">GreeのLWF</a>、よりもスクリプトも再現するから高級版ですなー)、他にXAMLに書きだしたりとか色々できるよう。中々高機能で良さそう！</p>
<p>といっても、そもそも目的がテキスト/画像置換しかしないので高機能である必要はないのですが、高機能を実現するために、SWFの解析回りはバッチリ。</p>
<p>残念ながらドキュメントはXNA周り中心で（当たり前か）さっぱり、コンパイル済みバイナリも用意されてないでソースからのみ。と、使うには微妙にハードですが、一から仕様読み解いてぽちぽち作るよりも百億倍楽なので、喜んで使わせて頂きます。とはいえ、swfの仕様については、ある程度読んで頭に入れておいたほうがいいです、というかそうでないと、どう操作すればいいのか全くピンと来ないので。</p>
<p>SWFの詳しい話は<a href="http://labs.gree.jp/blog/2011/01/2353/">SWFバイナリ編集のススメ</a>が親切丁寧で非常に詳しい、分かりやすい。ので、それと照らし合わせながら進めていきましょう。</p>
<h2>SWFをSwfFormatで読み込む</h2>
<p>Swf2XNAのソリューションを開くといっぱいあって何が何やら。しかもコンパイル通らないし（XNA周りが未インストールだから）。で、困るのですが、今回はXNA周りは不要でコアのSWF解析さえできればいいので、そのためのプロジェクトはSwfFormat。これはXNAなどなどを入れなくても単体でビルド通るので、ビルドしてDLLを作りましょう。</p>
<p>さて、ビルドが通ったら、まずは<a href="http://labs.gree.jp/blog/2010/08/631/">SWFバイナリ編集のススメ第一回</a>に従って、orz.swfをサンプルとしていただいて、解析してみましょう。</p>
<pre><code class="language-csharp">// SwfReaderはちょっと高級なBinaryReader的なもの
// swfはbit単位での処理しなきゃならない部分があるのでBinaryReaderだけだと不便
var reader = new SwfReader(File.ReadAllBytes(&quot;orz.swf&quot;));

// SwfCompilationUnitがSwfの構造を表す
// コンストラクタの時点で生成出来てる(XElement.Loadみたいなもの)
var swf = new SwfCompilationUnit(reader);
</code></pre>
<p>メインとなるクラスはSwfCompilationUnitです。これが全て。中身がどうなってるか、というと、Visual Studioで見るのが速いですね。いやほんと、皆IDE使うべきだと思いますよ、ほんと（最近ぺちぱーなので愚痴る、いや、私自身はPHPはPHPStormで書いてるのですが）</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/swfcompilationunit.jpg">
</p>
<p>ばっちり解析済みのようです。Headerを見ても、問題なく作れてる。</p>
<h2>Tagを置き換えてみる</h2>
<p>SWFの中身の実態はTagです。↑で見ると、orz.swfにはTagが87個ありますね。どういうのが並んでいるのか、というと、これもVisual Studioで見るのが手っ取り早い。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/swftags.jpg">
</p>
<p>ふむふむ。なんとなくわかるような感じ。フレームがあってオブジェクトがあって、みたいな。では、<a href="http://labs.gree.jp/blog/2010/08/726/">SWFバイナリ編集のススメ第二回</a>に進んで、背景色を変更しましょう。背景色は↑で開いている、BackgroundColorTagを弄ります。具体的な作業手順、コードは以下のような感じ。</p>
<pre><code class="language-csharp">// 要素はTagの中に詰まってるので、それを探してパラメータを置きかえ
var tagIndex = swf.Tags.FindIndex(x =&gt; x.TagType == TagType.BackgroundColor);
var tag = (BackgroundColorTag)swf.Tags[tagIndex];
tag.Color.R = 255; // 背景色を真っ赤に
tag.Color.G = 0;
tag.Color.B = 0;

// Tagはstructなため、代入しないと反映されない
swf.Tags[tagIndex] = tag;

using (var ms = new MemoryStream())
{
    // SwfWriterはMemoryStreamしか受け付けない(Lengthを最後に書き換えたりするから、その必要があるみたい)
    var sw = new SwfWriter(ms);
    swf.ToSwf(sw); // メモリストリームに書きだされた

    // ファイルに置換後のSWFを出力
    File.WriteAllBytes(&quot;replaced.swf&quot;, ms.ToArray());
}
</code></pre>
<p>Tagを置き換えて(classじゃなくてstructなので、実際にListに再代入しないと変更が反映されないことに注意)、あとはSwfCompilationUnitのToSwfを使ってMemoryStreamに吐き出してやれば、それだけでTagの置換は完了です。無事、背景色が真っ赤なswfが生成されました！すっごく簡単だわー。</p>
<h2>画像置換</h2>
<p><a href="http://labs.gree.jp/blog/2010/09/782/">SWFバイナリ編集のススメ第三回 (JPEG)</a>に従って、画像置換もやってみましょう。</p>
<pre><code class="language-csharp">var reader = new SwfReader(File.ReadAllBytes(&quot;orz.swf&quot;));
var swf = new SwfCompilationUnit(reader);

// DefineBitsTagはCharacterIdを持つので、実際はそれを参照して置換するTagを探すと良い
var tagIndex = swf.Tags.FindIndex(x =&gt; x.TagType == TagType.DefineBitsJPEG2);
var tag = (DefineBitsTag)swf.Tags[tagIndex];
tag.JpegData = File.ReadAllBytes(&quot;ethnyan.jpg&quot;); // jpegデータを直接置き換え
swf.Tags[tagIndex] = tag;

using (var ms = new MemoryStream())
{
    // Tagの画像を置き換えたことでHeaderのFileLengthも変わらなければなりませんが
    // ↑でTagに代入しただけでは、そこは変わっていないままです
    // が、ToSwfの際に、Headerも再計算された値に置き換えてくれるので、手動で変える必要はなし
    var sw = new SwfWriter(ms);
    swf.ToSwf(sw);

    // ファイルに置換後のSWFを出力
    File.WriteAllBytes(&quot;replaced.swf&quot;, ms.ToArray());
}
</code></pre>
<p>やってることは当然ながら同じで、置き換えたいTagを探す、置き換える、ToSwfで吐き出す。それだけです。簡単～。</p>
<p>置き換えによってFileLengthが変わる、などといったことはSwfCompilationUnitが面倒を見てくれるので、考えなくても大丈夫です。素晴らしい。</p>
<h2>まとめ</h2>
<p>RubyやPHPにはライブラリあるけれど、ドトネトにはないというのが弱点の一つでした（多分）。これで解決しましたね！さあ、C#で是非とも参入しましょう。</p>
<p>置換にあたって元swfファイルって変わらないから、SwfCompilationUnitをキャッシュすれば、ファイルオープンや解析のコストがなくなり、バイナリ編集のコストが純粋なバイト書き出しだけに抑えられますね。<a href="http://www.klab.com/jp/services/products/flamixer/index.html">KlabのFlamixer</a>は、初回パース時に構造を変えてMessagePackでシリアライズしておくので、というけれど、それだって読み込みやデシリアライズのコストありますものね。ASP.NETならゼロシリアライゼーションコストでキャッシュ出来るから、それ以上に期待持てそうだし、実際、軽くテストして見た限りだと、相当速くて、かなりイケテルと思いますですね。</p>
<p>というわけで謎社ではC#でほげもげしたい人をそのうち募集しますので暫しお待ちを。</p>
</div>
<h1><a href="https://neue.cc/2013/01/05_392.html">C#でローカル変数からDictionaryを生成する</a></h1>
<ul class="date"><li>2013-01-05</li></ul>
<div class="entry_body"><p>どうもPHPerです。あ、すぐC#のコード出しますので帰らないで！というわけで、PHPには<a href="http://php.net/manual/ja/function.compact.php">compact</a>というローカル変数からハッシュテーブルを作るという関数があります。割と多用します。その逆のextractという関数もありますが、そちらはカオスなのでスルー。</p>
<pre><code class="language-php">$name = &quot;hogehoge&quot;;
$age = 35;

// {&quot;name&quot;:&quot;hogehoge&quot;, &quot;age&quot;:35}
$dict = compact(&quot;name&quot;, &quot;age&quot;);
</code></pre>
<p>へー。いいかもね。これをC#でやるには？もったいぶってもshoganaiので先に答えを出しますが、匿名型を使えばよいです。</p>
<pre><code class="language-csharp">var name = &quot;hogehoge&quot;;
var age = 35;

// Dictionary&lt;string, object&gt; : {&quot;name&quot;:&quot;hogehoge&quot;, &quot;age&quot;:35}
var dict = Compact(new { name, age });
</code></pre>
<p>はい。別にPHPと見比べても面倒くさいことは全然ないです。C#はLLですから（嘘）</p>
<p><a href="http://msdn.microsoft.com/ja-jp/library/bb397696.aspx">匿名型</a>は「メンバー名を指定しなかった場合、コンパイラによって、初期化に使用するプロパティと同じ名前が付けられます。」ので、それを利用すればローカル変数の名前をキャプチャできる、という至極単純な仕組み。</p>
<h2>Reflection vs FastMember</h2>
<p>Compactメソッドの中身ですが、リフレクションでプロパティなめてDictionaryに吐き出しているだけです。LINQを使えば瞬殺。</p>
<pre><code class="language-csharp">static Dictionary&lt;string, object&gt; Compact(object obj)
{
    return obj.GetType().GetProperties()
        .Where(x =&gt; x.CanRead)
        .ToDictionary(pi =&gt; pi.Name, pi =&gt; pi.GetValue(obj));
}
</code></pre>
<p>CanReadは、一応、匿名型以外を流し込む時のことも考慮しましょうか、的に。</p>
<p>さて、リフレクションを使うと実行速度がー気になってーカジュアルにー使いたくないー、のが人情というものです。個人的にはそこまで遅くもないので、そう気にしなければカジュアルに使ってもいいと思ってたりしますが、まあ気になるならShoganaiし、気にするのはいいことです。</p>
<p>そこで取り出すは<a href="http://code.google.com/p/fast-member/">FastMember</a>。超高速シリアライザで有名なprotobuf-netの作者が作った、シンプルなプロパティアクセス高速化ライブラリです。</p>
<p>これを使って書くと</p>
<pre><code class="language-csharp">static Dictionary&lt;string, object&gt; Compact(object obj)
{
    var type = FastMember.TypeAccessor.Create(obj.GetType());
    return type.GetMembers().ToDictionary(x =&gt; x.Name, x =&gt; type[obj, x.Name]);
}
</code></pre>
<p>というように、書き方的にはそんなに違いはないですが、生成速度は数倍上昇します。TypeAccessor.Createして、GetMembersでプロパティ情報の列挙(TypeとNameがあるだけ)、PropertyInfoのGetValue的なのはインデクサを使います。FastMemberにはTypeAccessorの他にObjectAccessorがありますが、使い方は似たような感じなので略（インデクサの第一引数に対象オブジェクトを渡す必要がなくなる）。</p>
<p>FastMemberの仕組みですが、初回実行時にはリフレクションでプロパティ舐めています。別に魔法が存在するわけではないので、プロパティ名を取りたければ、リフレクション以外の選択肢はありません。そして取得したデータを基にしてILの動的生成を行いキャッシュし、以降のアクセス時はキャッシュから取得したアクセサ経由となるため、素のリフレクションよりも高速となっています。</p>
<p>よって、初回実行時に限れば、実行時間はむしろかなり遅くなります（IL生成は軽い処理ではない）。単純な平均で考えれば、1万アクセスぐらいないとペイしません（要素数による、多ければ多いほどFastMemberのほうが有利です）。という程度には、リフレクションもそんなに遅くはないです。ただまあ、初回に目をつむって以降の実行速度重視のほうがユーザー体験での満足度は高いケースがほとんどとは思われますので、個人的にはFastMember使って済ませるほうがいいな、とは思います。気分的にもスッキリしますしね。</p>
<p>ちなみに.NETでリフレクションにはTypeDescriptorという手段も標準で用意されていますが、アレはクソがつくほど遅いので、アレだけはやめておきましょう。少なくとも素のリフレクションを避けてあっちを使う理由がない。</p>
<h2>名前大事</h2>
<p>Compactという名前はPHP臭が激しいしC#的にはイミフなので、ちゃんとした名前をつけたほうがいいでしょう、ToDictionaryとか、ね。</p>
<h2>匿名型 as Dictionary</h2>
<p>Compact、という例を出すから何だか新しい感じがしなくもない誤魔化しでして、実のところ、ようするに、ただの匿名型→Dictionaryです。ASP.NET MVCではそこら中に見かけるアレです。ソレです。コレです。</p>
<p>その辺のアレコレは<a href="http://nyaruru.hatenablog.com/entry/20080706/p1">ややニッチな Anonymous Types の使い方をまとめてみる (C# 3.0) - NyaRuRuが地球にいたころ</a>にまとまっているので見ていただくとして、以上終了。</p>
<p>実際問題、Dictionary&lt;string, object&gt;を要求するシチュエーションというのは少なくありません。パラメータ渡すところなんて、そうですよね。一々Dictionaryを使うのは、カッタルイってものです。なので、別にASP.NET MVCに限らず、↑のようなメソッドを作って、objectも受け入れられるようにしてあげるってのは、現代のC#的にはアリだと私は考えています。</p>
<pre><code class="language-csharp">// Dictionaryの初期化は割と面倒くさい
var hoge = ToaruMethod(new Dictionary&lt;string, object&gt;
{
    {&quot;screen_name&quot;, &quot;hogehoge&quot;},
    {&quot;count&quot;, 10},
    {&quot;since_id&quot;, 12345}
});

// 書きやすい！素敵！抱いて！
var hoge = ToaruMethod(new
{
    screen_name = &quot;hogehoge&quot;,
    count = 10,
    since_id = 12345
});
</code></pre>
<p>んね。</p>
<p>そうなるとメソッドの引数にobjectというものが出てしまって、安全性がショボーンになってしまいますので、やたらめったら使うのもまたアレですけれど。</p>
<p>匿名型がIAnonymousTypeとか、何らかのマーカーついてたらなあ、なんて思わなくもなかったりもしなかったりしましたが、こういう用途で使う時って、普通のクラスからも変換したかったりするので、匿名型に限定したほうが不便なんですね。幾ばくかの安全性は増しますが。ともあれともあれ、普通のクラスと匿名型に違いなんてない、と考えると、区別できないことは自然だから別にいいかなあ、なんて、ね、思ってます。where T : classと引数に制限つけるぐらいが丁度良いんではないでしょうか。</p>
<h2>まとめ</h2>
<p>PHPの良いところってどこなのか非常に悩ましい。その辺のほげもげに関してはいつか特に言いたいことはなくもないけどとくにない（去年の年末に勉強会というか技術交流会というかで、PHPの会社に行ってPHP vs C#なプレゼンはしてきましたが）。</p>
<p>というわけで、C#はLightweightだという話でした。ん？</p>
</div>
<a href="https://neue.cc/11">Prev |</a>
<a href="https://neue.cc/13">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
