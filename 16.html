<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2011-12-10" data-pagefind-meta="published:2011-12-10"><a href="https://neue.cc/2011/12/10_357.html">.NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a></h1>
<ul class="date"><li>2011-12-10</li></ul>
<div class="entry_body"><p>今年もAdvent Calendarの季節がやってきましたね。去年は私はC#とJavaScriptで書きましたが、今年はC#とSilverlightでやります。というわけで、この記事は<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>用のエントリです。前日は<a href="https://twitter.com/#!/Posaune">@posaune</a>さんの<a href="http://d.hatena.ne.jp/posaunehm/20111209/1323443047">SilverlightのListBoxでつくるいんちきHorizontalTextBlock </a>でした。</p>
<p>今回の記事中のサンプルはSilverlight 4で書いています。が、Silverlight用という体裁を持つためにDebug.WriteLineで書いているというだけで、Silverlightらしさは皆無です！えー。.NET 4でもWindows Phone 7でも関係なく通じる話ですねん。</p>
<h2>シリアライザを使う場面</h2>
<p>概ね3つではないでしょうか。外部で公開されているデータ(APIをネット経由で叩くとか)をクラスに変換する。これは 自分の管理外→プログラム での片方向です。内部で持っているデータ(クラスのインスタンス)を保存用・復元用に相互変換する。これは プログラム←→自分の管理内 での双方向です。最後に、内部で持っているデータを公開用に変換する。これは プログラム→外部 での片方向。</p>
<p>目的に応じてベストな選択は変わってきます。こっから延々と長ったらしいので、まず先に結論のほうを。</p>
<ul>
<li>外部APIを叩く→XML/XmlSerializer, JSON/DataContractJsonSerializer</li>
<li>オブジェクトの保存・復元用→DataContractSerializer</li>
<li>外部公開→さあ？</li>
</ul>
<p>外部公開のは、Silverlightの話じゃないので今回はスルーだ！<a href="http://msdn.microsoft.com/ja-jp/library/system.xml.linq.xstreamingelement.aspx">XStreamingElement</a>で組み上げてもいいし、何でもいいよ！WCFのテンプレにでも従えばいいんぢゃないでしょーか。</p>
<h2>XmlSerializer</h2>
<p>古くからあるので、シリアライザといったらこれ！という印象な方も多いのではないでしょうか。その名の通り、素直にXMLの相互変換をしてくれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなクラスがあるとして
// (以降、断り書きなくPersonが出てきたらこいつを使ってると思ってください)
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new XmlSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.Deserialize(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">// 出力結果のXML
﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
  &lt;Age&gt;99&lt;/Age&gt;
&lt;/Person&gt;
</code></pre>
<p>素直な使い勝手、素直な出力。いいですね。さて、しかし特に外部APIを叩いて手に入るXMLは名前PascalCaseじゃねーよ、とか属性の場合どうすんだよ、という場合も多いでしょう。細かい制御にはXmlAttributeを使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[XmlRoot(&quot;people&quot;)]
public class People
{
    [XmlElement(&quot;count&quot;)]
    public int Count { get; set; }
    [XmlArray(&quot;persons&quot;)]
    [XmlArrayItem(&quot;person&quot;)]
    public Person[] Persons { get; set; }
}

[XmlRoot(&quot;person&quot;)]
public class Person
{
    [XmlElement(&quot;name&quot;)]
    public string Name { get; set; }
    [XmlAttribute(&quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new People
{
    Count = 2,
    Persons = new[]
{
    new Person { Name = &quot;山本山&quot;, Age = 99 },
    new Person { Name = &quot;トマト&quot;, Age = 19 }
}
};
var xml = @&quot;
    &lt;people&gt;
        &lt;count&gt;2&lt;/count&gt;
        &lt;persons&gt;
            &lt;person age=&quot;&quot;14&quot;&quot;&gt;
                &lt;name&gt;ほむ&lt;/name&gt;
            &lt;/person&gt;
            &lt;person age=&quot;&quot;999&quot;&quot;&gt;
                &lt;name&gt;いか&lt;/name&gt;
            &lt;/person&gt;
        &lt;/persons&gt;
    &lt;/people&gt;&quot;;

var serializer = new XmlSerializer(typeof(People));

// シリアライズ
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data);
    Debug.WriteLine(Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length));
}

// デシリアライズ
using (var sr = new StringReader(xml))
{
    var value = (People)serializer.Deserialize(sr);
    foreach (var item in value.Persons)
    {
        Debug.WriteLine(item.Name + &quot;:&quot; + item.Age);
    }
}

// 出力結果のXMLは↑に書いたXMLと同じようなものなので割愛
</code></pre>
<p>ちょっと属性制御が面倒ですが、それなりに分かりやすく書けます。他によく使うのは無視して欲しいプロパティを指定するXmlIgnoreかしら。さて、そんな便利なXmlSerializerですが、XML化するクラスに制限があります。有名所ではDictionaryがシリアライズできねえええええ！とか。小細工して回避することは一応可能ですが、そんな無理するぐらいなら使うのやめたほうがいいでしょう、シリアライザは別にXmlSerializerだけじゃないのだから。</p>
<p>というわけで、XmlSerializerの利用シーンのお薦めは、ネットワークから外部APIを叩いて手に入るXMLをクラスにマッピングするところです。柔軟な属性制御により、マッピングできないケースは(多分)ないでしょう。いや、分かりませんが。まあ、ほとんどのケースでは大丈夫でしょう！しかし、LINQ to XMLの登場により、手書きで変換するのも十分お手軽なってしまったので、こうして分かりにくい属性制御するぐらいならXElement使うよ、というケースのほうが多いかもしれません。結局、XML構造をそのまま映すことしかできないので、より細かく変換できたほうが良い場合もずっとあって。</p>
<p>実際、私はもう長いことXmlSerializer使ってない感じ。LINQ to XMLは偉大。</p>
<h2>DataContractSerializer</h2>
<p>割と新顔ですが、もう十分古株と言ってよいでしょう(どっちだよ)。XmlSerializerと同じくオブジェクトをXMLに変換するのですが、その機能はずっと強力です。Dictionaryだってなんだってシリアライズできますよ、というわけで、現在では.NETの標準シリアライザはこいつです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;&lt;Age&gt;99&lt;/Age&gt;&lt;Name&gt;山本山&lt;/Name&gt;&lt;/Person&gt;
</code></pre>
<p>とまあ、使い勝手はXmlSerializerと似たようなものです。おお、出力されるXMLは整形されていません。整形して出力したい場合は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 出力を整形したい場合はXmlWriter/XmlWriterSettingsを挟む
using (var ms = new MemoryStream())
using (var xw = XmlWriter.Create(ms, new XmlWriterSettings { Indent = true }))
{
    serializer.WriteObject(xw, data);

    xw.Flush();
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;
  &lt;Age&gt;99&lt;/Age&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
&lt;/Person&gt;
</code></pre>
<p>さて、結果をXmlSerializerと見比べてみるとどうでしょう。名前空間が違います。SilverlightApplication34ってありますね。これは、私がこのXMLを出力するのに使ったSilverlightプロジェクトの名前空間です。ワシのConsoleApplicationは221まであるぞ（整理しろ）。さて、ではこのXMLをデシリアライズするのに、別のアプリケーション・別のクラスで使ってみるとどうでしょう？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace TestSilverlightApp
{
    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();

            var xml = @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
            &lt;Person xmlns:i=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot; xmlns=&quot;&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&quot;&gt;
                &lt;Age&gt;99&lt;/Age&gt;
                &lt;Name&gt;山本山&lt;/Name&gt;
            &lt;/Person&gt;&quot;;

            var serializer = new DataContractSerializer(typeof(Person));
            using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
            {
                // System.Runtime.Serialization.SerializationExceptionが起こってデシリアライズできない
                // 名前空間 'http://schemas.datacontract.org/2004/07/TestSilverlightApp' の要素 'Person' が必要です。
                // 名前が 'Person' で名前空間が 'http://schemas.datacontract.org/2004/07/SilverlightApplication34' の 'Element' が検出されました。
                var value = (Person)serializer.ReadObject(ms);
            }
        }
    }
}
</code></pre>
<p>デシリアライズ出来ません。対象オブジェクトが名前空間によって厳密に区別されるからです。じゃあどうするのよ！というと、属性で名前空間を空、という指示を与えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// DataContract属性をクラスにつけた場合は
// そのクラス内のDataMember属性をつけていないプロパティは無視される
[DataContract(Namespace = &quot;&quot;, Name = &quot;person&quot;)]
public class Person
{
    [DataMember(Name = &quot;name&quot;)]
    public string Name { get; set; }
    [DataMember(Name = &quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなプレーンなXMLも読み込める
var xml = @&quot;
    &lt;person&gt;
        &lt;age&gt;99&lt;/age&gt;
        &lt;name&gt;山本山&lt;/name&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age);
}
</code></pre>
<p>属性面倒くせー、ですけれど、まあしょうがない。そうすれば外部からのXMLも読み込めるし、と思っていた時もありました。以下のようなケースではどうなるでしょうか？Personクラスは↑のものを使うとして。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなさっきと少しだけ違うXMLがあるとして
var xml = @&quot;
    &lt;person&gt;
        &lt;name&gt;山本山&lt;/name&gt;
        &lt;age&gt;99&lt;/age&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 結果は？？？
}
</code></pre>
<p>これは出力結果は「山本山:0」になります。Ageが0、つまり復元されませんでした。なぜかというと、XMLを見てください。nameが先で、ageが、後。DataContractSerializerは規程された順序に強く従います。DataMember属性のOrderプロパティで順序を与えるか、与えない場合はアルファベット順(つまりAgeが先でNameが後)となります。この辺は<a href="http://msdn.microsoft.com/ja-jp/library/ms729813.aspx">データ メンバーの順序</a>に書かれています。</p>
<p>と、いうような事情から、DataContractSerializerを外部XMLからの受け取りに使うのはお薦めしません。XmlSerializerなら順序無視なので大丈夫です。いや、普通は順序が変わったりなどしないだろう！と思わなくもなくもないけれど、意外とデタラメなのじゃないか、基本的にはお外からのデータが何もかも信用できるわけなどないのだ、とうがってしまい(TwitterのAPIとか胡散臭さいのを日常的に触っていると！)、厳しいかなって、思ってしまうのです。</p>
<p>しかし、オブジェクトの保存・復元用にはDataContractSerializerは無類の強さを発揮します。例えば設定用のクラスを丸ごとシリアライズ・デシリアライズとかね。iniにして、じゃなくてフツーはXMLにすると思いますが、それです、それ。Dictionaryだってシリアライズできるし、引数なしコントラクタがないクラスだってシリアライズできちゃうんですよ？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// とある引数なしコンストラクタがないクラス
[DataContract]
public class ToaruClass
{
    [DataMember]
    public string Name { get; set; }

    public ToaruClass(string name)
    {
        Name = name;
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var toaru = new ToaruClass(&quot;たこやき&quot;);

var serializer = new DataContractSerializer(typeof(ToaruClass));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, toaru); // シリアライズできるし

    ms.Position = 0;
    var value = (ToaruClass)serializer.ReadObject(ms); // デシリアライズできる

    Debug.WriteLine(value.Name); // たこやき
}
</code></pre>
<p>ただし、対象クラスにDataContract属性をつけてあげる必要はあります。つけてないとシリアライズもデシリアライズもできません。</p>
<p>ちなみに何でコンストラクタがないのにインスタンス化出来るんだよ！というと、<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.formatterservices.getuninitializedobject.aspx">System.Runtime.Serialization.FormatterServices.GetUninitializedObject</a>を使ってインスタンス化しているからです（Silverlightの場合はアクセス不可能）。こいつはコンストラクタをスルーしてオブジェクトを生成する反則スレスレな存在です、というか反則です。チートであるがゆえに、対象クラスにはDataContract属性をつける必要があります。コンストラクタ無視してもいいよ、ということを保証してあげないとおっかない、というわけです。(GetUninitializedObjectメソッド自体は別に属性は不要で何でもインスタンス化できます、typeof(void)ですらインスタンス化できます、無茶苦茶である)</p>
<p>なお、このGetUninitializedObjectが使われるのはDataContract属性がついているクラスのみです。DataContract属性がついていなければ、普通のコンストラクタが呼ばれるし、逆にDataContract属性がついていると、例え引数をうけないコンストラクタがあったとしても、GetUninitializedObject経由となりコンストラクタは無視されます。DataContract属性を付ける時はコンストラクタ内でシリアライズで復元できない副作用のある処理をすべきではない。ということに注意してください。</p>
<p>また、.NET 4版ではprivateプロパティの値も復元できるのですが、Silverlightの場合は無理のようです。ということでフル.NETなら不変オブジェクトでもサクサク大勝利、と思ってたのですが、Silverlightでの不変オブジェクトのシリアライズ・デシリアライズは不可能のようです。保存したいなら、保存専用の代理のオブジェクトを立ててやるしかない感じでしょうかね。</p>
<p>そんなわけで微妙な点も若干残りはしますが、オブジェクトを保存するのにはDataContractSerializerがお薦めです。</p>
<h2>DataContractとSerializable</h2>
<p>シリアライズ可能なクラス、の意味でDataContract属性をつけているわけですが、じゃあSerializable属性は？というと、えーと、SerializableはSilverlightでは入っていなかったりするとおり、過去の遺物ですね。なかったということで気にしないようにしましょう。</p>
<h2>DataContractJsonSerializer</h2>
<p>今時の言語はJSONが簡単に扱えなきゃダメです。XMLだけ扱えればいい、なんて時代は過ぎ去りました。しかしC#は悲しいことに標準では……。いや、いや、Silverlightには<a href="http://msdn.microsoft.com/ja-jp/library/system.json.aspx">System.Json</a>がありますね。しかし.NET 4にはありません(.NET 4.5とWinRTには入ります)。いや、しかし.NET 4には<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>があります(それ出していいならJSON.NETがあるよ、で終わりなんですけどね)。が、Windows Phone 7には何もありません。ああ……。</p>
<p>とはいえ、シリアライザならば用意されています。DataContractJsonSerializerです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml); // {&quot;Age&quot;:99,&quot;Name&quot;:&quot;山本山&quot;}

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<p>使い勝手はDataContractSerializerと完全に一緒です。ただし、違う点が幾つか。名前空間が（そもそもJSONで表現不可能なので）なくなったのと、順序も関係なく復元可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var json1 = @&quot;{&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;,&quot;&quot;Age&quot;&quot;:99}&quot;;
var json2 = @&quot;{&quot;&quot;Age&quot;&quot;:99,&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;}&quot;;

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms1 = new MemoryStream(Encoding.UTF8.GetBytes(json1)))
using (var ms2 = new MemoryStream(Encoding.UTF8.GetBytes(json2)))
{
    var value1 = (Person)serializer.ReadObject(ms1);
    var value2 = (Person)serializer.ReadObject(ms2);

    Debug.WriteLine(value1.Name + &quot;:&quot; + value2.Age);
    Debug.WriteLine(value2.Name + &quot;:&quot; + value2.Age);
}
</code></pre>
<p>というわけで、随分とDataContractSerializerよりも使い勝手が良い模様。いい話だなー。さて、難点は出力されるJSONの整形が不可能です。DataContractSerializerではXmlWriterSettingsで行えましたが、DataContractJsonSerializerではそれに相当するものがありません。というわけでヒューマンリーダブルな形で出力、とはならず、一行にドバーっとまとめて吐かれるのでかなり苦しい。</p>
<p>もう一つ、これは本当に大したことない差なのでどうでもいいのですが、DataContractSerializerのほうが速いです。理由は単純でDataContractSerializerに一枚被せる形でDataContractJsonSerializerが実装されているから。その辺の絡みで.NET 4には<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.json.jsonreaderwriterfactory.aspx">JsonReaderWriterFactory</a>などがあって、これを直に触ってJSON→XML変換をするとLINQ to XMLを通したJSONの直接操作が標準ライブラリのみで可能なのですが、Silverlight/Windows Phone 7では残念なことに触ることができません。</p>
<p>外部APIを叩いて変換する際に、シリアライズはお手軽で便利であると同時に、完全に同一の形のオブジェクトを用意しなければならなくて、かったるい側面もあります。LINQ to XML慣れしていると特に。そういった形でJSONを扱いたい場合、WP7では<a href="http://json.codeplex.com/">Json.NET</a>を使う、しかありません。使えばいいんぢゃないかな、どうせNuGetでサクッと入れられるのだし。</p>
<p>とはいえまあ、そう言うほど使いづらいわけでもないので、標準のみでJSONを扱いたいという場合は、DataContractJsonSerializerが第一にして唯一の選択肢になります。</p>
<h2>JavaScriptSerializer</h2>
<p>.NET Framework 4.0 Client Profileでは使えないのですが、FullならばSystem.Web.Extensionを参照することでJavaScriptSerializerが使えます。もはや完全にSilverlightと関係ないのでアレですが、少し見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var serializer = new JavaScriptSerializer();

var target = new { Name = &quot;ほむほむ&quot;, Age = 14 };
var json = serializer.Serialize(target); // stringを返す
</code></pre>
<p>Serializeで文字列としてのJSONを返す、というのがポイントです。それと、シリアライザ作成時にtypeを指定しません。また、匿名型もJSON化することが可能です（これはDataContractSerializerでは絶対無理）。ただし、コンストラクタのないクラスのデシリアライズは不可能です。</p>
<p>中々使い勝手がいいですね！で、これは、リフレクションベースの非常に素朴な実装です。だから匿名型でもOKなんですねー。ちょっとした用途には非常に楽なのですが、Client Profileでは使えないこともありますし(ASP.NETで使うために用意されてる)、あまり積極的に使うべきものではないと思います。ちなみに、一時期ではObsoleteになっていてDataContractJsonSerializer使え、と出ていたのですが、またObsoleteが外され普通に使えるようになりました。やはり標準シリアライザとしてはDataContractJsonSerializerだけだと重すぎる、ということでしょうか。</p>
<h2>バイナリとか</h2>
<p>別にシリアライズってXMLやJSONだけじゃあないのですね。サードパーティ製に目を向ければ、色々なものがあります。特に私がお薦めなのは<a href="http://code.google.com/p/protobuf-net/">protobuf-net</a>。これはGoogleが公開しているProtocol Buffersという仕様を.NETで実装したものなのですが、とにかく速い。めちゃくちゃ速い。稀代のILマスターが書いているだけある恐ろしい出来栄えです。SilverlightやWP7版もあるので、Protocol Buffersの本来の用途というだけなく、幅広く使えるのではかとも思います。</p>
<p>もう一つは国内だと最近目にすることの多い<a href="http://msgpack.org/">MessagePack</a>。以前に<a href="http://neue.cc/2010/05/29_261.html">.NET(C#)におけるシリアライザのパフォーマンス比較</a>を書いたときは振るわないスコアでしたが、最近別のC#実装が公開されまして、それは作者によるベンチ<a href="https://oikw.org/memo/2011/04/23/0">MessagePack for .NET (C#) を書いた</a>によると、protobuf-netよりも速いそうです。</p>
<h2>Next</h2>
<p>というわけでSilverlight枠でいいのか怪しかったですが、シリアライザの話でした。次は<a href="https://twitter.com/#!/ugaya40">@ugaya40</a>さんのWeakEventの話です。引き続きチェックを。あ、あと、Silverlight Advent Calendarはまだ埋まってない（！）ので、是非是非参加して、埋めてやってください。申し込みは<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>から。皆さんのエントリ、待ってます。どうやらちょうど今日Silverlight 5がリリースされたようなので、SL5の新機能ネタとかいいんじゃないでしょうか。</p>
</div>
<h1 data-pagefind-sort="date:2011-12-09" data-pagefind-meta="published:2011-12-09"><a href="https://neue.cc/2011/12/09_356.html">自家製拡張メソッド制作のすすめ だいx回 BufferWithPadding</a></h1>
<ul class="date"><li>2011-12-09</li></ul>
<div class="entry_body"><p><a href="http://nuget.org/packages/Ix_Experimental-Main">Ix(Interactive Extensions)</a>は使っていますか？Rxから逆移植されてきている(IxのNuGet上のアイコンはRxのアイコンの逆向きなのですね)、LINQ to Objectsを更に拡張するメソッド群です。みんな大好きForEachなど、色々入っています。その中でも、私はBufferというものをよく使っています。Ixが参照できない場合は何度も何度も自作するぐらいに使いどころいっぱいあって、便利です。こんなの。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 指定個数分をまとめたIList&lt;T&gt;を返します
// 第二引数を使うとずらす個数を指定することもできます
// これの結果は
// 0123
// 4567
// 89
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>標準でこういうのできないのー？というと、できないんですよねえ、残念なことに。</p>
<p>さて、ところで、この場合、指定個数に足りなかった場合はその分縮められたものが帰ってきます。上の例だと返ってくるListの長さは4, 4, 2でした。でも、埋めて欲しい場合ってあります。足りない分は0で埋めて長さは4, 4, 4であって欲しい、と。そこはLINQなので、創意工夫で頑張りましょう。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// EnumerableEx.Repeatは指定の値の無限リピート
// それと結合して、Takeで詰めることで足りない場合だけ右を埋めることが出来る
// 0123
// 4567
// 8900
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.Concat(EnumerableEx.Repeat(0)).Take(4).ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>EnumerableEx.RepeatはIxにある無限リピート。Ixを参照しない場合は Enumerable.Repeat(value, int.MaxValue) で代用することも一応可能です。</p>
<p>さて、しかしこれも面倒なので、自家製拡張メソッドを作りましょう。拡張メソッドはばんばん作るべきなのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 指定した値で埋めるように。これの結果は
// 0123
// 4567
// 89-1-1
foreach (var xs in Enumerable.Range(0, 10).BufferWithPadding(4, -1))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}

public static class EnumerableExtensions
{
    public static IEnumerable&lt;T[]&gt; BufferWithPadding&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue = default(T))
    {
        if (source == null) throw new ArgumentNullException(&quot;source&quot;);
        if (count &lt;= 0) throw new ArgumentOutOfRangeException(&quot;count&quot;);

        return BufferWithPaddingCore(source, count, paddingValue);
    }

    static IEnumerable&lt;T[]&gt; BufferWithPaddingCore&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue)
    {
        var buffer = new T[count];
        var index = 0;
        foreach (var item in source)
        {
            buffer[index++] = item;
            if (index == count)
            {
                yield return buffer;
                index = 0;
                buffer = new T[count];
            }
        }

        if (index != 0)
        {
            for (; index &lt; count; index++)
            {
                buffer[index] = paddingValue;
            }
            yield return buffer;
        }
    }
}
</code></pre>
<p>すっきりしますね！Emptyの時は何も列挙しないようにしていますが、Emptyの時は埋めたのを一つ欲しい、と思う場合は最後のifの囲みを外せばOK。あと、最後のif...for...yieldの部分を var dest = new T[index]; Array.Copy(buffer, dest, index); yield return dest; に変えればパディングしないBufferになります。Ix参照したくないけどBuffer欲しいなあ、と思ったときにコピペってどうぞ。</p>
<p>本体のコードと引数チェックを分けているのは、yield returnは本体が丸ごと遅延評価されるため、引数チェックのタイミング的によろしくないからです。少し面倒ですが、分割するのが良い書き方。詳しくは<a href="http://neue.cc/2011/08/15_338.html">neue cc - 詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)</a>で書いていますので見てください。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-30" data-pagefind-meta="published:2011-11-30"><a href="https://neue.cc/2011/11/30_355.html">Reactive Extensionsとスレッドのlock</a></h1>
<ul class="date"><li>2011-11-30</li></ul>
<div class="entry_body"><p>ぱられるぱられる。もしパラレルにイベントが飛んできたら、どうする？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TestParallel
{
    public event Action&lt;int&gt; Log = _ =&gt; { }; // nullチェック面倒ぃので

    public void Raise()
    {
        // デュアルコア以上のマシンで試してね！
        Parallel.For(0, 10000000, x =&gt;
        {
            Log(x);
        });
    }
}

class Program
{
    static void Main(string[] args)
    {
        var list = new List&lt;int&gt;();
        var tes = new TestParallel();

        // イベント登録して
        tes.Log += x =&gt; list.Add(x);

        // 実行
        tes.Raise();
    }
}
</code></pre>
<p>これは、十中八九、例外が出ます。list.Addはスレッドセーフじゃないので、まあそうだよね、と。では、Rxを使ってみるとどうなるでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var list = new List&lt;int&gt;();
var tes = new TestParallel();

// イベント登録して
Observable.FromEvent&lt;int&gt;(h =&gt; tes.Log += h, h =&gt; tes.Log -= h)
    .Subscribe(list.Add);

// 実行
tes.Raise();
</code></pre>
<p>やはり変わりません。例外出ます。FromEventを中継しているだけですから……。さて、しかし一々Addの手前でlockするのは面倒だ、と、そこでSynchronizeメソッドが使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.FromEvent&lt;int&gt;(h =&gt; tes.Log += h, h =&gt; tes.Log -= h)
    .Synchronize()
    .Subscribe(list.Add);

// ようするにこんな感じになってる

var gate = new Object();
//....
lock(gate)
{
    OnNext();
}
</code></pre>
<p>これで、list.Addを問題なく動作させられます。Listとか適度にデリケートなので適当に注意してあげましょう。</p>
<h2>Subjectの場合</h2>
<p>さて、上のはイベントでしたが、ではSubjectの場合はどうなるでしょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TestParallel
{
    Subject&lt;int&gt; logMessenger = new Subject&lt;int&gt;();
    public IObservable&lt;int&gt; Log { get { return logMessenger.AsObservable(); } }

    public void Raise()
    {
        // デュアルコア以上のマシンで試してね！
        Parallel.For(0, 10000000, x =&gt;
        {
            logMessenger.OnNext(x);
        });
    }
}

class Program
{
    static void Main(string[] args)
    {
        var list = new List&lt;int&gt;();
        var tes = new TestParallel();

        // イベント登録して
        tes.Log.Subscribe(list.Add);

        // 実行
        tes.Raise();
    }
}
</code></pre>
<p>たまーに例外起こらず処理できることもあるんですが、まあ大体は例外起こるんじゃないかと思います。初期のRxのSubjectは割とガチガチにlockされてたのですが、現在はパフォーマンスが優先されているため挙動が変更され、ゆるゆるです。回避策は同様にSynchronizeを足すことです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">tes.Log.Synchronize().Subscribe(list.Add);
</code></pre>
<p>これで問題なし。</p>
<h2>余談</h2>
<p>手元に残っていた大昔のRxを使って実行してみたら、死ぬほど遅かったり。確実に現在のものはパフォーマンス上がっていますねえ。あと、なんかもう最近面倒でeventだからってEventArgs使わなきゃならないなんて誰が言ったー、とActionばかり使うという手抜きをしてます。だってsenderいらないもん、大抵のばやい。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-20" data-pagefind-meta="published:2011-11-20"><a href="https://neue.cc/2011/11/20_354.html">ReactiveProperty ver 0.3.0.0 - MとVMのバインディングという捉え方</a></h1>
<ul class="date"><li>2011-11-20</li></ul>
<div class="entry_body"><p>今回の更新よりアイコンが付きました。専用のアイコンがあると、とっても本格的な感じがしますねー。色はRxにあわせて紫-赤紫。デザインは私の好みな幾何学的な感じです。@ocazucoさんに作って頂きました、ありがとうございます！色々ワガママ言ってお手数かけました。</p>
<p class="noindent">
	<img src="http://neue.cc/ReactivePropertyIcon_100x100.png">
<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Rx - ver 0.3.0.0</a>
</p>
<p>Rxとは何か、というとIObservable&lt;T&gt;と「見なせる」ものを合成するためのライブラリです。だから、見なせるものさえ見つかれば、活躍の幅は広がっていく。ReactivePropertyは色々なものを、そのように「見なして」いくことで、RxでOrchestrateできる幅をドラスティックに広げます。土台にさえ乗せてしまえば、あとはRxにお任せ。その場合に大切なのは、土台に乗せられるよう、閉じないことです。しかし、もし閉じているのなら、開くための鍵を提供します。</p>
<h2>デフォルトモード変更</h2>
<p>ReactivePropertyのデフォルトモードが DistinctUntilChanged|RaiseLatestValueOnSubscribe になりました。今まではRaise...が入ってなかったのですが、思うところあって変わりました。例えばCombineLatestは、全てが一度は発火していないと動き出しません。ReactiveCommandの条件に使うなどの場合にRaiseしてくれないと不都合極まりなく、かつ、Subscribeと同時にRaiseすることによる不都合なシーンは逆に少ない。ことを考えると、必然的にデフォルトをどちらに振るべきかは、分かりきった話でした。</p>
<p>そのことは0.1の時、サンプル作りながら思ってたんですが悩んだ末に、省いちゃったんですねえ。RaiseLatestValueOnSubscribeが入ると不便なシーンもある(initialValueを設定しないとまず最初にnullが飛んでいくとか)ので、どちらを取るかは悩ましいところではあるんですが、シチュエーションに応じて最適なほうを選んでください、としか言いようがないところです。</p>
<h2>ToReactivePropertyAsSynchronized</h2>
<p>長い。メソッド名が。</p>
<p>これは何かというとINotifyPropertyChanged-&gt;ReactiveProperty変換です。今までもObservePropertyメソッド経由で変換できましたが、それは一度IObservable&lt;T&gt;に変換するため、Model→ReactivePropertyという一方向のPushでしかありませんでした。Two-wayでのバインドで値の同期を取りたい場合は、今回から搭載されたToReactivePropertyAsSynchronizedを使ってください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな通知付きモデルがあるとして
public class ObservableObject : INotifyPropertyChanged
{
    private string name;
    public string Name
    {
        get { return name; }
        set
        {
            name = value;
            PropertyChanged(this, new PropertyChangedEventArgs(&quot;Name&quot;));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}

// それを使ったViewModelを作るなら
public class TwoWayViewModel
{
    public ReactiveProperty&lt;string&gt; OneWay { get; private set; }
    public ReactiveProperty&lt;string&gt; TwoWay { get; private set; }

    public TwoWayViewModel()
    {
        var inpc = new ObservableObject { Name = &quot;ヤマダ&quot; };

        // ObservePropertyを使うとIObservable&lt;T&gt;に変換できます
        // ラムダ式でプロパティを指定するので、完全にタイプセーフです
        // それをToReactivePropertyすればOneWayで同期したReactivePropertyになります
        OneWay = inpc.ObserveProperty(x =&gt; x.Name).ToReactiveProperty();

        // ToReactivePropertyAsSynchronizedで双方向に同期することができます
        TwoWay = inpc.ToReactivePropertyAsSynchronized(x =&gt; x.Name);
    }
}
</code></pre>
<p>INotifyProeprtyChangedなModelをReactivePropertyなViewModelに持っていきたい時などに、使いやすいのではと思います。また、同期する型が異なっていても対応することができます。コンバーターのようにconvertとconvertBackを指定してください。</p>
<h2>ReactiveProperty.FromObject</h2>
<p>こちらもToReactivePropertyの亜種ですが、ReactiveProperty→Modelというソース方向への片方向の同期を取ります。ModelはINotifyPropertyChangedである必要はありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなただのクラスがあったとして
public class PlainObject
{
    public string Name { get; set; }
}

// それと同期させたいとき
public class OneWayToSourceViewModel
{
    public ReactiveProperty&lt;string&gt; OneWayToSource { get; private set; }

    public OneWayToSourceViewModel()
    {
        var poco = new PlainObject { Name = &quot;ヤマダ&quot; };

        // ReactiveProperty.FromObjectで変換することができます
        // この場合、ReactiveProperty -&gt; Objectの方向のみ値が流れます
        OneWayToSource = ReactiveProperty.FromObject(poco, x =&gt; x.Name);
    }
}
</code></pre>
<p>片方向の同期が定型的な局面、例えば設定クラスなんかは通知は必要ないと思うのですが、それをUIから一方向で値を投影したい場合に、これを使うことで楽になると思います。</p>
<p>また、Sampleにこれら3つの解説を追加しましたので、実際にどう反映されるのか、動きを確認したい場合はそちらを見てください。</p>
<h2>CombineLatestValuesAreAllTrue</h2>
<p>長い。メソッド名が。これは<a href="http://d.hatena.ne.jp/okazuki/20111027/1319722680">Reactive Extensionsお題 - かずきのBlog@Hatena</a>に書かれているもので、使うシーンよくありそうな頻出パターンになりそうだと思ったので、お借りすることにしました。ありがとうございます。使い方を見てもらったほうが速いので、まず例を。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyComibineLatestAllTrue.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedA.Value, Mode=TwoWay}&quot;&gt;Check A&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedB.Value, Mode=TwoWay}&quot;&gt;Check B&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsCheckedC.Value, Mode=TwoWay}&quot;&gt;Check C&lt;/CheckBox&gt;
    &lt;/StackPanel&gt;
    &lt;Button Command=&quot;{Binding ExecCommand}&quot;&gt;全部チェックで押せる&lt;/Button&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Reactive.Extensions; (これを忘れないように)

public class MainPageViewModel
{
    public ReactiveProperty&lt;bool&gt; IsCheckedA { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsCheckedB { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsCheckedC { get; private set; }
    public ReactiveCommand ExecCommand { get; private set; }

    public MainPageViewModel()
    {
        IsCheckedA = new ReactiveProperty&lt;bool&gt;();
        IsCheckedB = new ReactiveProperty&lt;bool&gt;();
        IsCheckedC = new ReactiveProperty&lt;bool&gt;();

        ExecCommand = new[] { IsCheckedA, IsCheckedB, IsCheckedC }
            .CombineLatestValuesAreAllTrue()
            .ToReactiveCommand();

        ExecCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;しんぷる！&quot;));
    }
}
</code></pre>
<p>3つのチェックボックスが全てONなら実行可能なコマンドを作る、です。こんな風に、全てがtrueの時、といった集約をしたい場合に便利に使うことができます。プレゼンテーションロジック、に該当する部分だと思いますが、ここでもRxは十分以上に活躍できます。また、外部からCanExecuteChangedをぶっ叩くようなカオティックなこともしません、ReactiveCommandならね。</p>
<h2>ReactiveTimer</h2>
<p>Timerです。.NETはTimerが山のようにあります。Threading.Timer, Timers.Timer, Forms.Timer, DispatcherTimer, Observable.Timer。ここにまたReactiveTimerという新たなるTimerが誕生し、人類を混乱の淵に陥れようとしていた……。まさにカオス。</p>
<p>ちょっと整理しましょう。まず、Threading.Timerは一番ネイティブなTimerと捉えられます。そのままだと少しつかいづらいので、軽くラップしてイベントベースにしたのがTimers.Timer。Forms.TimerとDispatcherTimerは、それぞれのアプリケーション基盤で時間を計って伝達してくれるというもの、UI系でのInvokeが不要になるので便利。と、それなりに役割の違いはあります。微妙な差ですが。</p>
<p>最後のObservable.TimerはIObservableで通達してくれるのでRxと非常に相性が良いタイマー。また、タイマーを行う場所もISchedulerで任意に指定できるので、ThreadPoolでもDispatcherでもCurrentThread(この場合はSleepで止まるので固まりますけどね)でも、もしくは仮想スケジューラ(任意に時間を動かせるのでテストが簡単になる)でも良いという柔軟さが素敵で、Rx以降のプログラミングではタイマーなんてObseravble.Timer一択だろ常識的に考えて。という勢い。(精度は若干落ちるので、よほど精度を求める時はThreading．Timerを使いましょう)。だと思っていた時もありました。</p>
<p>一時停止出来ないんですよ、Observable.Timer。発動したらしっぱなし。Stopはできる(Disposeする)けど、そうしたら再開は出来ない。それじゃあ困る場合があります！はい。結構あります。そういう場合はTimers.TimerをFromEventでラップする。それはそれで良いのですが、Observable.TimerのISchedulerを指定可能という柔軟さを捨てるのは勿体無いなあ、と思ったのでした。</p>
<p>そこで、今回ReactiveTimerを作りました。機能は、Observable.TimerのStop/Start出来る版です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestClass]
public class ReactiveTimerTest : ReactiveTest
{
    [TestMethod]
    public void TimerTest()
    {
        // テスト用の自由に時間を動かせるスケジューラ
        var testScheduler = new TestScheduler();
        var recorder = testScheduler.CreateObserver&lt;long&gt;();

        // 作成時点では動き出さない
        var timer = new ReactiveTimer(TimeSpan.FromSeconds(1), testScheduler);
        timer.Subscribe(recorder); // Subscribeしても動き出さない

        timer.Start(TimeSpan.FromSeconds(3)); // ここで開始。初期値を与えるとその時間後にスタート

        // 時間を絶対時間10秒のポイントまで進める(AdvanceTo)
        testScheduler.AdvanceTo(TimeSpan.FromSeconds(5).Ticks);

        // MessagesにSubscribeに届いた時間と値が記録されているので、Assertする
        recorder.Messages.Is(
            OnNext(TimeSpan.FromSeconds(3).Ticks, 0L),
            OnNext(TimeSpan.FromSeconds(4).Ticks, 1L),
            OnNext(TimeSpan.FromSeconds(5).Ticks, 2L));
        
        timer.Stop(); // timerを止める
        recorder.Messages.Clear(); // 記録をクリア

        // 時間を現在時間から5秒だけ進める(AdvanceBy)
        testScheduler.AdvanceBy(TimeSpan.FromSeconds(5).Ticks);

        // timerは止まっているので値は届いてないことが確認できる
        recorder.Messages.Count.Is(0);
    }
}
</code></pre>
<p>そう、単体テストしたい場合は、TestSchedulerに差し替えれば、AdvancedBy/Toによって、時間を自由に進めることが可能になります。Assertに使っているIs拡張メソッドは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>です。Testing周りの詳しい解説は<a href="http://d.hatena.ne.jp/ZOETROPE/20111031#1320077799">Rx-Testingの使い方 - ZOETROPEの日記</a>に書かれています。</p>
<h2>CountNotifier/BooleanNotifier</h2>
<p>SignalNotifierという名前はよく分からないので、今回よりCountNotifierに変更しました。また、名前空間をNotifiersに変更しました。更に、二値での通知を行うBooleanNotifierを新規追加しました。どちらも、IObservable経由での通知を行うフラグです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Reactive.Notifiers;

// 通知可能(IObservable)なboolean flag
var boolFlag = new BooleanNotifier(initialValue: false);
boolFlag.Subscribe(b =&gt; Console.WriteLine(b));

boolFlag.TurnOn(); // trueにする, trueの状態だったら何もしない
boolFlag.Value = false; // .Valueで変更、既にfalseの状態でも通知する
boolFlag.SwitchValue(); // 値を反転させる

// 通知可能(IObservable)なcount flag
var countFlag = new CountNotifier();
countFlag.Subscribe(x =&gt; Console.WriteLine(x));

countFlag.Increment(); // incしたり
countFlag.Decrement(); // decしたりの状態が通知される

// Empty(0になった状態)という判定でフィルタして状態監視したりできる
countFlag.Where(x =&gt; x == CountChangedStatus.Empty);
</code></pre>
<p>例えば非同期処理を行う際などの、状態の管理に使うことができます。</p>
<h2>Pairwise</h2>
<p><a href="http://neue.cc/2011/11/09_352.html">neue cc - Reactive Extensionsで前後の値を利用する</a>で書いた、前後の値をまとめる拡張メソッドです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// { Old = 1, New = 2 }
// { Old = 2, New = 3 }
// { Old = 3, New = 4 }
// { Old = 4, New = 5 }
Observable.Range(1, 5)
    .Pairwise()
    .Subscribe(Console.WriteLine);
</code></pre>
<p>古い値と新しい値を使って何かしたい場合などにどうぞ。</p>
<h2>CatchIgnore</h2>
<p>例外処理用に、OnErrorRetryというものを用意していましたが、今回それ以外にCatchIgnoreを追加しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 1, 2
Observable.Range(1, 5)
    .Do(x =&gt; { if (x == 3) throw new Exception(); })
    .CatchIgnore()
    .Subscribe(Console.WriteLine);
</code></pre>
<p>ようするに、CatchしてEmptyを返す手間を省くためのものです。onErrorにe =&gt; {}と書くのと似てますが、シーケンスの途中で捕まえれるので、メソッドチェーンの繋ぎ方によっては全然異なる役割を持つ可能性があります。</p>
<h2>その他の削除やバグ修正や見送ったものなど</h2>
<p>RxのExperimental版が更新されてたので、それに合わせました。Rxの更新内容はZipとCombineLatestに大量のオーバーロード+配列を受け入れるようになったので、何でも結合できるようになりました。それにともないReactivePropertyでは独自拡張としてCombineLatestのオーバーロードを用意していたのですが、Experimental版のみ削除しました。パフォーマンスもExperimentalのもののほうがずっと良いので、早くStableにも降りてきて欲しいです。</p>
<p>WebRequestのUploadValuesで、値が&amp;で連結されていないという致命的なバグがあったので修正しました。本当にすみません……。また、Silverlightでデザイン画面がプレビューできなくなる不具合を修正しました。デザインモード怖い。</p>
<p>バリデーション周りは、ちょっと大きめに(といっても内部だけの話で外部的には変わらない予定)変更入れようと思ってたのですが、それは次回で。あと、同期系メソッドもバリデーションの成否によって同期するかしないかを決定しようかなあ、とか思うんですが、ちょっと大変なので後になりそう。</p>
<h2>まとめ</h2>
<p>今回はデータリンクを主眼に置きました。デフォルトモードの変更もその一環です。直接的に意味を見るのなら、厚めのMをスマートにVMとシンクロナイズさせる、ということになります。冒頭の台詞、閉じた世界を開けるための道具です。ObserveProperty(OneWay)、ToReactivePropertyAsSynchronized(TwoWay)、ReactiveProperty.FromObject(OneWayToSource)。</p>
<p>OneWayとかTwoWayとかOneWayToSourceというとおり、VMとMの間のバインディングエンジンだと見ることができます。VとVMの間をWPFなりのフレームワークが担い吸収するように、ReactivePropertyはVMとMの間を吸収します。手書きでバインディングだと、ボイラープレートでは手間だし見通しも悪くなる。このほうが、ずっと、楽だし自然に書けます。</p>
<p>ReactivePropertyはV-VM間の接続も担うため、結果として全てがV-VM-M-VM-Vとして一つに繋がる。何をどう組もうと自然に一つに繋がっていく。わくわくしませんか？むしろカオスの予感がする？けれど、カオスの先に本当の光がある、……かもしれない。</p>
<p>ちなみに同期系のものはみんなプロパティ指定だけでGetとかSetとか自動でやっていますが、動的コード生成(＆キャッシュ)によりハイパー高速化されているので、パフォーマンス上の問題はありません。そこは安心してください。というと何か凄そうなことやってる気がしますが、勿論そんなことはなくて、偉大なるExpressionTreeに全面的にお任せしているだけだったり。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-13" data-pagefind-meta="published:2011-11-13"><a href="https://neue.cc/2011/11/13_353.html">XboxInfoTwit - ver.2.4.0.0</a></h1>
<ul class="date"><li>2011-11-13</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comがリニューアルしたので、それに対応しました。今回より.NET Framework 4.0専用になりましたので(今までは3.5)、もし動かなくなった！とかの場合は、.NET Framework 4.0をインストールしてください。</p>
<p>最近はすっかり放置気味ですみませんでした、わざわざブログのコメント欄に報告頂いたものもスルーしていて、大変申し訳ありません。ええと、一応、今回プログラムを少し見直しまして、最近絶不調にエラーばっかだったと思うのですが、若干改善されたのではかと思います。</p>
<p>あと、リニューアルにともない、内部がかなり変わったんですが「全然テストしてない」ので、動作がヘンテコな可能性は大いにあります。変なとこあったら報告していただけると助かります。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-09" data-pagefind-meta="published:2011-11-09"><a href="https://neue.cc/2011/11/09_352.html">Reactive Extensionsで前後の値を利用する</a></h1>
<ul class="date"><li>2011-11-09</li></ul>
<div class="entry_body"><p><a href="https://twitter.com/#!/toya256tweet">@Toya256tweet</a>さんの作成された<a href="http://dependencyvariable.codeplex.com/">Dependency Variable Lib</a>を見て、<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty</a>でも大体再現できるかなあ、でもOldValueとNewValueのところが少し面倒なのよね、というところで一例。ReactivePropertyの値の変更時に、古い値と新しい値を同時に得られるようにします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var p = new ReactiveProperty&lt;int&gt;(1, mode: ReactivePropertyMode.RaiseLatestValueOnSubscribe);

p.Zip(p.Skip(1), (Old, New) =&gt; new { Old, New })
    .Subscribe(a =&gt; Console.WriteLine(a.Old + &quot; -&gt; &quot; + a.New));

p.Value = 10; // 1 -&gt; 10
p.Value = 100; // 10 -&gt; 100
</code></pre>
<p>挙動は<a href="http://d.hatena.ne.jp/okazuki/20111109/1320817437">@okazukiさんの解説されている</a>通りです。残念ながら、頭やわらかい、というわけではなくて頻出パターンのイディオムなだけなので、ただたんに覚えているから、というだけです、がくり。まあ、LINQにせよRxにせよ、メソッドの組み合わせで成り立っているということは、パターン化しやすいということなのですね。イディオムを知っていればいるほど、更にそのイディオムを組み合わせて、と、手法は無限に広がっていきます。</p>
<p>私は非同期をvoidにしてモデル作り込むっての好きくないです。IObservableなりTaskなりを返してくれれば、先があるのですが、そうでないとやりようがないですから。例えば<a href="http://d.hatena.ne.jp/okachimachiorz/20111010/1318250533">データモデル考え中 - 急がば回れ、選ぶなら近道</a>で示される「2」のパターンが、Silverlightなどでの従来のやり方だったと思われます。実行のトリガーだけを外から渡して、モデルの中で結果は閉じる。変更はINotifyPropertyChanged経由で通知。正直言って、私はこのやり方はナシだと思っています。スパゲティになりがちだから。Rxは「3」のパターンに近いと思います。順序の制御は、まさにミドルウェア足るReactive Extensionsが保証する。柔軟性は見ての通りで、無限の広がりがあります。</p>
<p>今まではコールバックしかなかったので必然的に2に収まらざるを得なかったですが、今はRxもあるし、C#5.0からはawaitもあるし、なので、モデルの作り方も「変わっていく」と思います。Viewの機能の強さによってViewModelのありようが変わるように、言語やフレームワークの機能の強さによってModelのありようが変わるのは当然でしょう。</p>
<h2>ScanとPairwise</h2>
<p>さて、自分自身と結合というのは、結局のところ二つ購読しているということなので、これはIObservableがHotでないと成り立ちません(ReactivePropertyはHotです)。というわけで、ColdなIObservableでも対応したい時はScanを使うといいでしょう。HotとかColdとか何言ってるのか分からないという場合は<a href="http://d.hatena.ne.jp/okazuki/20111107/1320677760">Reactive Extensions再入門 その５「HotとCold」 - かずきのBlog@Hatena</a>を読むといいでしょう。最近、自分で解説してるのを放棄しだしてる気がするよくない傾向、ではなくて、次回の<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a>ではまさにObservable.TimerとフツーのTimerを使ってColdとHotの解説しようと思ってたのですよ！ネタ被った、けれど気にせず書きます:)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var p = new ReactiveProperty&lt;int&gt;(1, mode: ReactivePropertyMode.RaiseLatestValueOnSubscribe);

var oldNewPair = p.Scan(Tuple.Create(0, 0), (t, x) =&gt; Tuple.Create(t.Item2, x)).Skip(1);

oldNewPair.Subscribe(Console.WriteLine);

p.Value = 10; // (1, 10)
p.Value = 100; // (10, 100)
</code></pre>
<p>Scanは自分自身の前の値を参照できるので、色々と応用が効きます。値の入れ物のための初期値は不要なのでSkip(1)で除去してやるのがポイント。</p>
<p>もう一つ、メソッドの組み合わせでのパターン化、というのは、つまりパーツ化しやすいということでもあります。拡張メソッドに分離してやりましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ObservablePairwiseExtensions
{
    // OldNewPair&lt;T&gt;はReactivePropertyに入っています
    // using Codeplex.Reactive.Extensions;

    public static IObservable&lt;OldNewPair&lt;T&gt;&gt; Pairwise&lt;T&gt;(this IObservable&lt;T&gt; source)
    {
        return source.Scan(
                new OldNewPair&lt;T&gt;(default(T), default(T)),
                (pair, newValue) =&gt; new OldNewPair&lt;T&gt;(pair.NewItem, newValue))
            .Skip(1);
    }

    public static IObservable&lt;TR&gt; Pairwise&lt;T, TR&gt;(this IObservable&lt;T&gt; source, Func&lt;T, T, TR&gt; selector)
    {
        return source.Pairwise().Select(x =&gt; selector(x.OldItem, x.NewItem));
    }
}

// ↑というような拡張メソッドを作ってやったとして
var p = new ReactiveProperty&lt;int&gt;(1, mode: ReactivePropertyMode.RaiseLatestValueOnSubscribe);

p.Pairwise().Subscribe(x =&gt; Console.WriteLine(x.OldItem + &quot; -&gt; &quot; + x.NewItem));

p.Value = 10; // 1 -&gt; 10
p.Value = 100; // 10 -&gt; 100
</code></pre>
<p>OldNewPairを使ったのは、TupleがSL/WP7にないから、というのと、OldItemとNewItemというプロパティ名に意味があって、分かりやすいから、です。基本的にC#でTupleを使うことはあんまないですね。LINQのパイプライン内でならば匿名型、それを超えるなら面倒くさくてもクラスを立ててあげたほうがいいと、私は思っています。勿論、今後Tupleのための構文やパターンマッチが入るとしたら別ですけど。というか、つまるところ専用構文がない状態ではTupleを使うメリットはそんなにないのです。匿名型かわいいよ匿名型。言語比較の際に、<a href="http://d.hatena.ne.jp/ymotongpoo/20111105/1320506449">C#はTupleがこんな腐ってるぜー</a>、とかやられるのはちょっと勘弁願いたいところ(まぁでも普通に敵いませんのは認めます、けれど言語・IDE・フレームワークは三位一体だとも思っています。引き離して単独で評価することには、あまり価値を感じません。IDEでうまく機能することを優先した言語、それを前提にしたフレームワーク。どの要素も引き離せませんから。はいはい、C#がお好きなんですね、という感じですが、でも例えばHTML/ブラウザというGUIフレームワークの上だったらJavaScriptがベストだ、といった捉え方でもありますね)</p>
<p>それはともかくとして、Pairwiseは多用しそうなので、次のReactiveProperty(ver.0.3)で入れたいと思います(あとOldNewPairのToStringのオーバーライド)。ちなみに<a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>にはPairwise、入ってます。そう、Rxでの頻出パターンということは、それはIx(Enumerable)にも存在するパターンなのです。この辺がRxの面白いところです！私にとって、こういった書き方の初出は<a href="http://d.hatena.ne.jp/NyaRuRu/20090311/p1">前後の値も利用したシーケンス処理 - NyaRuRuの日記</a>でした。</p>
<h2>ObserveChanged</h2>
<p>突然出てきたOldNewPairですが、これが既にReactiveProperty内で定義されているのは、ObservableCollectionの拡張メソッド群で使用しているからです。今まで紹介していなかったと思うので、ここで紹介しましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// using Codeplex.Reactive.Extensionsとすると
// ObservableCollection&lt;T&gt;に(ReactiveColelctionとか継承したものでも可)
// ObserveXxxChangedという拡張メソッドが利用できる
var collection = new ObservableCollection&lt;int&gt;();

// 追加されたのを監視できる、IObservable&lt;T&gt;
collection.ObserveAddChanged()
    .Subscribe(x =&gt; Console.WriteLine(&quot;Add:&quot; + x));
// 削除されたのを監視できる、IObservable&lt;T&gt;
collection.ObserveRemoveChanged()
    .Subscribe(x =&gt; Console.WriteLine(&quot;Remove:&quot; + x));
// 置換を監視できる、IObservable&lt;OldNewPair&lt;T&gt;&gt;
collection.ObserveReplaceChanged()
    .Subscribe(p =&gt; Console.WriteLine(p.OldItem + &quot;→&quot; + p.NewItem));
// リセットを監視できる、IObservable&lt;Unit&gt;
collection.ObserveResetChanged()
    .Subscribe(_ =&gt; Console.WriteLine(&quot;Clear&quot;));

collection.Add(100); // Add:100
collection.Add(1000); // Add:1000
collection[1] = 300; // 1000→300
collection.Remove(100); // Remove:100
collection.Clear(); // Clear
</code></pre>
<p>この手の監視では、通常CollectionChangedイベント経由でNotifyCollectionChangedEventArgsを使って値を取り出すわけですが、型がobject[]なので一々キャストしたりなど、非常に使いにくいと思っていました。ObserveXxxChangedを使えば、完全にタイプセーフで、値も取り出しやすい形に整形してくれています。是非是非どうぞ。</p>
<h2>まとめ</h2>
<p>@Toya256tweetさんにも示唆頂いたのですが、ReactivePropertyはMVVMに限定されない、汎用的なものだと考えています。値の導出ルールを宣言的に書く、というのは色々なところで使える、気がします。でもやはり、Functional Reactive Programmingが全然流行ってないことを考えても、ルールによって自動的に変動する値って、基本的にGUI向けなのだろうなあ、って。そして、GUIで強いのはやっぱJavaとか.NETといったFRP不毛地帯なので、流行るなんて考えられないことでした。しかし、今は違う。C#にはRxが来た。C#で実現できるのならば、強力なGUIプラットフォームが目の前にあるわけなので、かなり可能性はあるんじゃないかな！と思いたいところです。</p>
<p><a href="http://www.kmonos.net/wlog/83.html#_2259080315">d.y.d. - ReaJ / Reactive JavaScript</a>の例は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// RaiseLatestValueOnSubscribeはv0.3ではデフォルトに変更する予定
var mode = ReactivePropertyMode.RaiseLatestValueOnSubscribe;

var x = new ReactiveProperty&lt;int&gt;(10, mode);
var y = x.Select(n =&gt; n + 100).ToReactiveProperty(mode: mode);
x.Value = 20;
x.Value = 30;
Console.WriteLine(y.Value); // 130
</code></pre>
<p>まあ、不格好です。ReactiveProperty用の専用構文でも用意してくれないとね、rp x = 10; rp y = x + 100; とかで上記の形に整形されたら素敵なのですが。というのはともかくとして、一応、実現できています。GUI環境への反映はWPFのバインディング機構に投げて解決ですし。JavaScriptにおいても、ReactivePropertyを移植して、ベースとして<a href="http://knockoutjs.com/">Knockout.js</a>辺りを採用すればいい感じに実用的になりそうです。その辺は追々やっていきたいところ。</p>
<p>勿論、Rx自体の可能性はGUI(や非同期)だけに閉じているわけではないので、全く別なところでの可能性、使い道というのも追い求めていきたいです。</p>
<p>ともあれともかく、<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty</a>、試してみてくださいな。</p>
</div>
<h1 data-pagefind-sort="date:2011-11-07" data-pagefind-meta="published:2011-11-07"><a href="https://neue.cc/2011/11/07_351.html">Rx連載開始とRx本感想とZenbook買ったという話</a></h1>
<ul class="date"><li>2011-11-07</li></ul>
<div class="entry_body"><p>まーたブログを放置気味な昨今は大変よろしくなく、だらだらTwitterを眺めているだけで一日が終わる症にかかっています。さて、そんなわけですが、@ITにてRx入門の連載を開始しました。</p>
<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_01/introrx_01_01.html">Reactive Extensionsの概要と利用方法 － ＠IT</a></li>
</ul>
<p>導入なので細かいことは言わず、なんか凄そう！と思ってもらえればいいなー、という構成にしました。用語もそんな並べず、でも、ところどころ引っかかるワードがある、言い方を悪くするとハッタリ気味に、印象に残ってくれればいいなあ、と。初回とはいえ、導入だけであっさり終わってしまったのはちょっと反省。どんな形になるのかイマイチ掴めなくて、もう少し書けばよかったな、と思ってます。あと、図をもう少し入れるべきだったな、と……。そんなこんなな反省を生かし、次回はボリューム増でお送りします。</p>
<p>@okazukiさんが<a href="http://d.hatena.ne.jp/okazuki/20111031/1320072227">Reactive Extensiions再入門</a>を始めたり、@zoetroさんが<a href="http://d.hatena.ne.jp/ZOETROPE/20111031#1320077799">Rx-Testingについて詳しい記事</a>を書かれていたり(これは素晴らしい！)、Rxも盛り上がってきた感じがしますね！それは気のせいです。というだけで終わらせないよう、ガンガン行きましょうー。</p>
<h2>Rx本</h2>
<p>(やっと)発売されました。まず印象ですが、薄いです。私は電子書籍で買っちゃってるのでリアルな厚さは分からないんですが、180ページです。それでこの値段かよ、という不満を最初は持ってしまうかもしれません。あと、LINQ and Rxです。どういうことかというと中身の半分はフツーのLINQの話です。それを差っ引くとRxは90ページしかありません。更にRxJSやReactiveUIの話もあります。そこを差っ引くと50ページぐらいしかないじゃないかゴルァ。というわけで、Rx本として考えると、分量には不満が残ると思われます。全てのメソッドをカバーする、という内容でもないのでリファレンスとしても使えません。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>とはいえ、要素要素は満遍なくカバーできているのと、現在唯一のRx本ではあるので、本で学びたいなあ、と思うならこれしか選択肢はありません。WindowやJoin、Testingなんかは（私の怠慢により）このブログでは少しも紹介していないので、それらを知りたい方や、 Web上から断片的な情報を拾って組み上げるのは手間なので、購入するのは十分アリだとは思います。まあ、私の@IT連載が完了したら、第一の選択肢はそれを見ること、になります(ｷﾘｯ。となれるように、頑張ります。</p>
<h2>ASUS Zenbook UX31</h2>
<p>どうでもいいんですが、UX31を買いました。Intelの推奨するUltrabookの第一弾の中では大本命の一品です。さて、Ultrabookとは何か、というと、ようするところWindows版Macbook Airです。薄く軽く速い。宗教上の理由で林檎はお断りだ！な人にとっては救いの手なわけです。内心羨ましいとか思ってたりしたんだからね！しかしですよ、Win系の勉強会ではそうでもないですが、それ以外の勉強会でのMac率の高さといったら！会場の9割がMacだよ、とかドヤ顔でツイートされた日には！多様性は善、はどこに行ったんだよという話です。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ux31body.jpg">
</p>
<p>側面は、実用的な意味ではフルフラットのほうが良いのでしょうし、特に日本メーカーはそこに拘っている印象があるのですが、審美的にはこうした処理をしたほうがいいですね、視覚上のトリックとはいえ、圧倒的に薄く見えるので。ちなみに側面から見ると本当にMacbook Airソックリでパク……と口から出てしまうのも已むを得ないかな、とは思いますが、それ以外の部分はそんなに似てるわけでもないですよ。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ux31crystalmark.jpg">
</p>
<p>ZenbookはSSDがSATA 3.0（6Gbps）ということもあって、滅茶苦茶速いですね。今後はこの速度がスタンダードになっていくのかと思うと、いい時代です、ほんと。</p>
<p>その他の印象ですが、キーボードはまぁまぁ、タッチパッドはサイテー。タッチパッドはキー入力中の誤動作率の高さ(位置とか大きさが悪いのだろうなあ)も酷くてストレスフル。基本はマウス使いますけれど、いつもマウス持ち歩くのもねえ。ああ、あと、UX31はUltrabookの中で唯一解像度が1600x900と高い(他は1366x768)のがポイントです。フルHDじゃないのかよ！とVAIO Zのオーダーメイドな人が言ってくるかもしれませんが、まぁVAIO Zは店頭モデルはともかくフルHDでオーダーすると高いですからね。こっちは10万円なのでコストパフォーマンスが違うわけです、はい。あと、13インチで1600x900は程良いですよ。フルHDだとちょっと文字が細かすぎになる感も。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B005YWPI7O" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B005YWPJLE" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>総じて満足度は高くお薦めなので、是非買ってください(上のリンク先から！)</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ux31connector.jpg">
</p>
<p>悲しいことに私はいきなりACアダプタのコネクタを破壊してしまって充電不能に陥りました、ｵｩﾉｩ。地震で物が降ってきてですね。脆いものです。</p>
<p>追記：ASUSのサポートセンターに連絡し、交換してもらいました。非常に対応もよかったので、全然問題ないです。ネガティブな方向でURLがばら蒔かれてしまって想定外だったのですが、全然大丈夫ですよ、とは書いておきます。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-24" data-pagefind-meta="published:2011-10-24"><a href="https://neue.cc/2011/10/24_350.html">Chaining Assertion ver1.6.1.0</a></h1>
<ul class="date"><li>2011-10-24</li></ul>
<div class="entry_body"><ul>
<li><a href="http://chainingassertion.codeplex.com/">Chaining Assertion - Codeplex</a></li>
</ul>
<p>Chaining Assertionとは、メソッドチェーンな形で簡単にユニットテストを書けるようにする拡張メソッドです。何でそういうのが必要なのか、とかの理由などは<a href="http://neue.cc/2010/08/02_270.html">neue cc - テストを簡単にするほんの少しの拡張メソッド</a>で。</p>
<p>最近こっそり小さな更新が続いているのですが、今回の更新は、IsNullにmessageが指定できるようになりました。実のところ、他のIsは指定できたのですが、IsNullだけ指定不可能でした。理由はただたんに忘れてたから、です。とてもしょうもない……。と、@okazukiさんに<a href="http://d.hatena.ne.jp/okazuki/20111022/1319257560">ChainingAssertion使ってみた</a>で指摘頂きました。いやあ、ありがとうございます。</p>
<p>そんなこんなで見直していて、そういえば params object[] parameters なオーバーロードが欠けてるなあ、入れたほうがいいかしらん、と少し実装初めてからやめました。やりたければstring.Format使ってください、はい。ちなみに理由はオーバーロードが必要(messageのほうに{}が入っていてparametersは空、というケースを避けるため、paramsとはいえ別のオーバーロードを用意する必要がある)だからです。</p>
<p>オーバーロードは減らしたいんです。少ないほうが分かりやすいというのは自明な話だと思います。使いやすいAPIのためには、クラスの数を減らそう、メソッドの数を減らそう、オーバーロードの数を減らそう、引数の数を減らそう。少ないことは美です。それでですね、メソッド数を減らすためもあって、Isはかなりオーバーロード嵩んでいるのですよね。だから、瑣末な機能を追加するためだけにホイホイとオーバーロードは足せません。</p>
<h2>その他</h2>
<p>@shinsukeodaさんに<a href="http://d.hatena.ne.jp/odashinsuke/20111005/1317813807">ChainingAssertion for MSTest のパラメタライズドテストを NUnit 感覚で利用すると… </a>で紹介頂き本当にありがとうございます。本題の、パラメタライズドテストについてですが、これが非常に悩ましい。実装的にビミョーになってしまう、というのもそうなのですが、NUnitは本当のパラメタライズドテストで、テストケースがバラバラになるのですが、ChainingAssertionのものは擬似的なものに過ぎないので、テスト結果的には一つのテストケースなのですね。そして、一つのケースなのにInitializeやCleanupを呼んでいく、という挙動がアリなのかナシなのかが、自分のなかで答えがでないのです。なので、今はちょっと見送りです。もう少し考えて答えが出たら、その時に、かしらん。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-17" data-pagefind-meta="published:2011-10-17"><a href="https://neue.cc/2011/10/17_349.html">ReactiveProperty ver.0.2.0.0</a></h1>
<ul class="date"><li>2011-10-17</li></ul>
<div class="entry_body"><ul>
<li><a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Reactive Extensions</a></li>
</ul>
<p>ver.0.2！ご意見ご感想は随時募集中で、コメントなりTwitterで私に@を投げてくれるなり、ただたんにTwitterでReactivePropertyと含めてつぶやいてくれるなり(検索経由で拾えるので)、ブログで記事を書いてくださるついでにクエスチョンしてみたりなどなど、ちょっとした疑問でも要望でも、何でもどうぞ。特に、細かな使用感の向上というのはリクエストがあってこそですので！斜め上からやってきた結果として世界最先端(但し逆向き)を体感出来るのは今だけです！斜め上なのでReactivePropertyのうまい使い方は今のところ誰にも分かりません、私もわかりません(えー)。というわけで、みんなで模索できたらいいな、と思います。</p>
<p>国内はもとよりReactiveUIの作者からも言及頂いて結構褒めてもらったりなどなど、RxのForumで宣伝したかいがあったね！というわけで、私自身かなり真剣に取り組んでますので、付き合って頂ければ幸いです。 /* 現在ReactiveOAuthをほっぽりだしてるという信頼感のなさがアレなので、そちらも早めに何とかします…… */</p>
<p>今回は、0.1では中途半端な存在だったReactiveCollectionを徹底的に考察して再デザインしました。他に細かい追加が幾つか。まずは小さな追加から。</p>
<h2>追加したり変わったりしたもの</h2>
<p>ObserverPropertyが、最初のSubscribe時に値をPushするようになりました(引数でfalseを指定するとオフにも出来る、そうすると、普通にFromEventしたのと同じ)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ToaranaiViewModel
{
    ToaruModel model;
    public ReactiveProperty&lt;string&gt; Name { get; private set; }

    public ToaranaiViewModel()
    {
        // こんなINotifyPropertyChangedなModelがあるとして
        model = new ToaruModel { Name = &quot;Anders&quot; };

        // 初期値として現在値(この場合&quot;Anders&quot;)を持つ
        Name = model.ObserveProperty(x =&gt; x.Name).ToReactiveProperty();
    }
}

public class ToaruModel : INotifyPropertyChanged
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; PropertyChanged(this, new PropertyChangedEventArgs(&quot;Name&quot;)); }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}
</code></pre>
<p>これにより、既存のModelからToObservablePropertyしてViewModelにする際などに、デフォルトで値が同期されるので多くのシチュエーションで、より便利になったと思います。という提案を@okazukiさんにリクエスト貰ったので実装しました:) @okazukiさんは<a href="http://d.hatena.ne.jp/okazuki/20111017/1318827792">ReactivePropertyを使ってみた感想 イケテル！気持ちいい！ハードルは高い？ - かずきのBlog@Hatena</a>という記事も書いてくれました、わーい。</p>
<p>ObserverProeprtyはINotifyPropertyChangedへの拡張メソッドです。また、今回よりINotifyPropertyChangingにObservePropertyChanging拡張メソッドを追加しました。ObserverProeprtyと同様な感覚で使えます。</p>
<p>それとReactiveCommand(無印)のExecuteが引数なしでnullをぶん投げるようになりました。なお、これがあるのは無印のほうのみで&lt;T&gt;のほうにはありません。だって、ジェネリックするということはパラメータが欲しい前提ですものね。ジェネリックのほうはExecute(T parmeter)を受け入れるうようにオーバーロードを隠蔽。こういう細かいところの使いやすさの向上ってのは随時取り組みたいところです。</p>
<p>また、ReactiveCommand(無印・ジェネリック共に)をDisposeすると、SubscribeしてたものにOnCompletedを投げるように変更しました。なお、ReactiveCommandをDisposeすると、CanExecuteもfalseになります。永久的にfalseにする、という意味合いで使えるかと思いますが、使うシチュエーションは分かりません。</p>
<h2>ReactiveCollectionの再デザイン</h2>
<p>ReactiveCollectionに大きめの変更を入れました。今まで通知をIScheduler上で行なっていましたが、これを廃止しました。かわりにToReactiveCollectionなどIObservableからの変換時は、Addと通知、両方をIScheduler上にしました。また、IScheduler上で各種操作(Add, Clear, Remove)を行うメソッド AddOnScheduler などを追加しました。この変更のデザイン上のポリシーは以下になります。</p>
<p>ObservableCollectionとスレッドセーフ・ディスパッチャーセーフというのは非常に難しい。まず、ObservableColectionは変更と通知がワンセットだと考えられる。コレクションが変更され通知を出し、通知され側(主にUI)がコレクションを読みに来る。これは全部ひとまとまりでなければならない。通知され側がコレクションを読みに行く際に、ズレがあってはならない。よって、通知をUIスレッドで行うなら、変更もUIスレッドで行われる必要がある。</p>
<p>しかし、全ての操作を内部で片っ端からDispatcherにBeginInvokeするアプローチを取ると、それはそれで都合が悪い。例えば別スレッドでAddしたりRemoveしたりClearしても、そのコード上では変更はすぐには反映されない。ClearしてもCountは変わらない。AddしてもCountは変わらない。そんな気味の悪いコレクションクラスは使えません。WPFではDispatcher.Invokeがあるので、変更と通知を強制的にUIスレッド上で行う、ということが可能でしたが、SilverlightにはBeginInvokeしかないので、操作をUIスレッドで行うことを保証するコレクションクラスの作成は不可能。(<a href="http://caliburnmicro.codeplex.com/">Caliburn Micro</a>のBindableCollectionは全部UIスレッド上で行うようにしているみたいですね、まあBindableにのみ焦点を当てるなら現実的なので、それはそれでいいと思います)</p>
<p>だから、コレクションを触る時は利用側がDispatcher.BeginInvokeして、明示的にDispatcherの中へ入ろう。というのが、整合性が取れて一番良いのだと思います。今まで、ReactiveCollectionは通知だけIScheduler上で行うようになっていました。でも、これはあまり良いデザインではない、操作と通知は同一スレッド上で行うべきなのだから、これでは乖離する可能性がある。単純なAddだけのようなケースでは問題になることは少ないし、利便性としては、その方が簡単にバインドで出来て良いよね、ではあるのだけど、決して良いデザインではない。いずれ発覚する破綻への気づきを遅らせているという点で、むしろ限りなく悪い。</p>
<p>よって、内部で片っ端からDispatcherにBeginInvokeする代わりに、AddOnSchedulerなど、(ReactiveCollection生成時に指定した/デフォルトはUIDispatcher)スケジューラ上で操作を行うと利用側が明示するアプローチを取ってみました。Rxには使い勝手の良いISchedulerが存在する。だからこそアリなやり方かな、と思います。この辺はまだまだ考えどころだと思いますので、ご意見ありましたらお願いします。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;ListBox ItemsSource=&quot;{Binding TimeItems}&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ToaruViewModel
{
    public ReactiveCollection&lt;string&gt; TimeItems { get; private set; }

    public ToaruViewModel()
    {
        // 1秒毎に現在時刻表示が追加されるコレクション
        TimeItems = Observable.Interval(TimeSpan.FromSeconds(1))
            .Select(_ =&gt; DateTime.Now.ToString())
            .ToReactiveCollection();
            
        // 5秒間隔で上記コレクションをクリアする
        Observable.Interval(TimeSpan.FromSeconds(5))
            .Subscribe(_ =&gt; TimeItems.ClearOnScheduler());
    }
}
</code></pre>
<p>今回考えるにあたっては<a href="http://shinichiaoyagi.blogspot.com/2011/06/net-observablecollection.html">青柳 臣一 ブログ（技術系）: [.NET] スレッドセーフな ObservableCollection&lt;T&gt; が欲しい</a>をとっても参考にさせて頂きました。</p>
<p>ReactiveProperty, ReactiveCommandは確固たる意思のもとに作ったんですが、ReactiveCollectionは非常に中途半端でした。が、今回ようやく理念が立てれたのではかと思います。なお、ObservableCollection/ReactiveCollectionにはObserveAddChangedなど、変更通知をIObservableで受け取ることのできる拡張メソッドを足してあるので、そちらも便利に使うことが可能です(素のNotifyCollectionChangedEventArgsはIList(ジェネリックじゃない！)であったりして非常に触りにくいので、その辺をきっちり整理してあります)。</p>
<p>とか言ってますが、コードにしたらたかが十数行なのですよね。それを決めるのに、ここ一週間ずっと考えてました。つまり私の生産性は一日一行です(ｷﾘｯ</p>
<h2>まだ追加してないもの</h2>
<p>Validation周りをValidationSummaryやDescriptionViewerに対応させる。とか、OnErrorRetryが値を返せるようにする。などは次に載せるつもりです。これらを加えてから、と思ったんですがReactiveCollectionの変更が大きいので、先に出したくて見送りました。</p>
<h2>ReactiveProperty-Experimental</h2>
<p>今回からExperimental版のRxにも対応しました。NuGetでは<a href="http://nuget.org/List/Packages/ReactiveProperty-Experimental">ReactiveProperty-Experimental</a>です。しかし、
.NET 4.5やWinRTへの対応は、まだしていません。せっかくRx(Experimental)がWinRT対応したので、それに合わせたいと思ったのですが断念。理由としてはVS11がCode Contractsに対応していないから、です。Code Contractsのバイナリリライトかけないと動かないので、どうにもなりません……。それがなければ今すぐにでも対応させたいのですけれどねえ。こういう時に機敏に動けないのはとても悲しいので、次回からはCode Contractsの採用は見送りたいと思ってしまいます……。</p>
<p>ところで、それを意識してではありますが、.NET 4.0版のDLL名をReactiveProperty.NET40.dllに変えました。複数プラットフォームに対応する場合、全てのDLLを同じ名前にする(JSON.NETなどはそうですね)か、全てのDLLにプラットフォームの識別子をつける(MVVMLightなどはそうです)か。前者のほうがスマートではあるのですが、分かりやすさを考え、後者を選びました。Stable版とExperimental版の区別もありますし、DLL名から判定出来たほうがいいかな、と。</p>
<h2>今後</h2>
<p>okazukiさんの記事にもあるように「MVVMライブラリにも精通しつつReactive Extensionsのことも知っててReactivePropertyの概要を把握してないといけない上に必要に応じてMVVMライブラリとReactivePropertyを繋ぐような機能を作りこまないといけない」きゃー、難しそう！でも事実だ！</p>
<p>私としてはReactivePropertyを通してReactive Extensionsを学習してもらえればいいかなあ、と思っています。Rxはイベントが合成出来る！というけれど、合成しようにもイベントのソースがないと始まらない。ReactivePropertyを使うと、手軽に合成のためのソースが手に入るので、イベント周りのRxでのこね方の学習に最適なのではかと思います。……多分。</p>
<p>既存MVVMライブラリとの使い分けなどに関しては、この類の「選択肢が増えます系」の永遠の課題ですねえ。結局、どう使い分けるかの判断をユーザーに丸投げしているわけですもの。ガイドなどを掲示できればベストなのですが、そもそも私がMVVMに全然詳しくないのであった。そもそも私自身がどう使えばいいのか分かってないぐらいなので(えー)、触ってみて、ついでに足りなかったり、これがこうなってたらいい、とかいう思いがあったら、私がそういうのに全然気づいてない確率100%なので、是非言ってやってください。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-14" data-pagefind-meta="published:2011-10-14"><a href="https://neue.cc/2011/10/14_348.html">Reactive Extensions v1.1.11011.11リリースに見る.NET 4.5からの非同期処理</a></h1>
<ul class="date"><li>2011-10-14</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の<a href="http://www.microsoft.com/download/en/details.aspx?id=27724">v1.1.11011 (Experimental Release)</a>がリリースされました。リリース対象はExperimental(実験)版のみです。Stable(安定)版のほうは変更ありません。別件で少しコメントで質問したところ、近いうちにStable版の更新もあるかも、とのことでしたので、Stableはそちらを待ちましょう。<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/23062737-e154-41af-99f6-45d819992254">リリース内容の詳細な解説はフォーラムにあります</a>。</p>
<p>今回の大きな追加は<a href="http://msdn.microsoft.com/en-us/netframework/hh403373">.NET Framework 4.5 Developer Preview</a>と<a href="http://msdn.microsoft.com/en-us/windows/apps">WinRT</a>への対応です。というわけで、WinRT関連では、WinRT用のスケジューラであったりイベントであったりへの対応とまぁまぁ想像つく普通のもの。あと非同期処理を他言語と結びつけるIAsyncOperationへの書き出し、などなどもサポートされるようですね。</p>
<p>そして.NET 4.5周りでは、C#5.0のAsyncサポート・クラスライブラリがTask中心に書き換わることが念頭に置かれ、大規模に変更が入っています。今後のRxの方針がよく見えますので、Experimentalではありますが注意深く観察してみる必要がありそうです。というわけで、しっかり紹介します。なお、以下の話は.NET 4.5のRxの話なので、.NET 4.0以前の場合では直接は関係なく、Obsoleteにもなっていません。が、将来フレームワークのバージョン上げたらObsolete祭りでモニョるのは覚悟が必要かしらん。もう一つ注意としては、あくまでExperimentalなので、将来的にもこのままかどうかは保証されません。現時点での話です。</p>
<h2>FromAsyncPatternがObsolete</h2>
<p>はい、Obsoleteです。理由としては、.NET 4.5では多くのメソッドがBegin-Endパターンの代わりにTaskを返すXxxAsyncメソッドを持っています。そしてTaskとIObservableは相互に変換可能だから、Rxで扱いたいならXxxAsync().ToObservableすればいいでしょ、ということでした。Begin-EndパターンなのにXxxAsyncを持っていないメソッドにはどうするんだ！という場合は、TaskFactory.FromAsyncがあるので、それ使えばいい、とのこと。まあ、それはレアケースなので滅多にないかな。</p>
<p>毎回ToObservableなんて面倒くさい、という人のためにSelectManyに限っては、Taskを受け取るオーバーロードが用意されているので、ToObservableは不要です。内部では予想つく通り、ただ単にToObservableしているだけですね。その他の合成系メソッド(MergeやSwitch)などは残念ながらというか当然というか、ToObservableしてください。</p>
<h2>IObservableはAwaitable</h2>
<p>IObservable&lt;T&gt;も非同期を扱うものなので、awaitできます。正確に言えばGetAwaiterが定義された、といったところでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://google.com/&quot;);
var response = await Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)();
</code></pre>
<p>基本的にRxの非同期はFromAsyncPatternを初めとして長さが1のものを扱っていますが、複数の値が流れる場合はどうなるかというと、挙動は「最後の値」です。正確に言えばAsyncSubjectが利用されているので、OnCompletedの直前のOnNextの値。ではEmpty(OnCompletedのみ)やNever(何もなし)ではどうなるのか、というと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 10(最後の値)
var a = await Observable.Range(1, 10);
            
// InvalidOperationException(シーケンスに値がない)
var b = await Observable.Empty&lt;int&gt;();
            
// ある意味フリーズ、ここで永遠に止まる
var c = await Observable.Never&lt;int&gt;();
</code></pre>
<p>となります。これだけ見るとNeverって使い道がイミフですが、何かとMergeする必要があるときに、マージ対象がないときはNeverを渡すなどなど、ライブラリに近い部分では結構使う場所あります。私の書いているReactivePropertyというライブラリでもそうして利用しています。</p>
<h2>FirstなどがObsolete、かわりにFirstAsyncなどとWaitが追加</h2>
<p>え？という感じですがObsoleteです。対象はFirst,Last,Single、それとForEachも。FirstOrDefaultなど、XxxDefault系も同様です。つまり同期的にブロックするタイプのものが全てObsolete行きになりました。代わりにFirstAsyncなどXxxAsyncが用意されています。それとawaitを組み合わせてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var source = Observable.Return(&quot;async?&quot;);

var value0 = await source; // LastAsyncと挙動は同じ
var value1 = await source.FirstAsync();
var value2 = await source.LastAsync();
</code></pre>
<p>長さ1と分かっている状況なら、何もなくそのままawaitでも良いのではかしらん。LastAsyncがそれに相当しますね。さて、しかしawaitのお陰で同期的「のように」書けるには違いないけれど、FirstやLastなどはブロックして「同期」な挙動を取っていたわけなので、単純にObsolete行きにされたら困ってしまいます。そこで、同期的に待機して最後の値を取り出すWaitメソッドが用意されました(これは.NET 4.0やSilverlightなどでも使える、新たに追加されたメソッドです)。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var source = Observable.Return(&quot;async?&quot;);

var value0 = source.Wait();
var value1 = source.FirstAsync().Wait();
var value2 = source.LastAsync().Wait();
</code></pre>
<p>ちなみにWaitの中身はLastです。Lastという名前から離して、同期的に待機して値を取り出す、と明示させたのですね。それはいいと思います。Waitはいい。Waitはいいんですが、FirstをObsoleteにしてFirstAsyncを追加するのは、正直気にいりません。私は反対です。</p>
<p>ターゲットフレームワーク間でコードが共有出来なくなる、IQbservableプロバイダに影響が出る、そもそも標準クエリ演算子から離れるのはどうよ。などなど。だいたい、AllやAny、Maxなどは長さ1のIObservable&lt;T&gt;を返すようになっていました。Firstなどだけです、同期的に待機して値を取り出す、という別の意味が与えられていたのは。だから、ここはFirstはObsoleteにせず、FirstAsyncの挙動、つまりIObservable&lt;T&gt;を返すように変更すればいいのです。同期待ちについては、Waitが搭載されたので心配無用です。これで、全ての挙動に統一が取れる。</p>
<p>唯一問題点を挙げれば、本当に本当に「破壊的変更」になるんですよね。それも、Stableとか銘打ったものへの影響も出る。メソッド名同じで戻り値が変わる。そういう変更を許せるものか。私は、許してしまってもいいと思うのですけれど。Firstを廃止してFirstAsyncを追加、などという歪な形を将来に残すよりかは、ずっといい。</p>
<p>なので、Forumにもそうコメント入れましたところ返答貰えました。「Stableリリースが存在する以上、XxxAsyncのままでいるしかない。これが不幸なことは同意しますけれど、暫くはこのままでいるしかない。」とのことでした。というわけで、Stableと銘打つのが早まったな…… としか言いようがなく。あの段階でここまで読めなかったのはしょうがないところ、と思いつつ、やはり手痛いミスかなあ。うーん、将来に渡っての完璧なAPIを作り上げるというのは実に難しい。</p>
<p>まあ、Firstを多用する(といっても単体テストや動作確認時ぐらいですけど)のは、値を一つ取り出したい、ということなので、await sourceかsource.Wait() で済む。FirstAsyncやLastAsyncを直接使うことは恐らく少なくて、ならば実際上の問題というのはそこまでないかもしれません。</p>
<h2>長さ1の非同期処理の戻り値はTaskを選ぶべきか、Rxを選ぶべきか</h2>
<p>メソッドを作るときの非同期処理の戻り値。これは、Taskを選ぶべきです。それは.NET標準と合わせるべきという理由からもそうですし、この.NET 4.5向けのRxの指針からしてそうなっています。長さ1のIObservableで非同期を表現する、というのは特殊だったと言わざるを得ないので、メソッドを作るとき、非同期処理の戻り値はTaskにしたほうが間違いなく良いでしょう。</p>
<p>ただ、アプリケーショに全体でRxによる合成を中心に置く場合は、ToObservableが面倒くさい、というだけじゃなく逆にオーバーヘッドになる可能性もあるので、IObservable中心にしたほうが良いでしょう。この辺は一概には言えずケースバイケースでしょうか。どちらにせよToObservable&lt;-&gt;ToTaskで相互変換が可能なわけなので、あまりガチガチに捉える必要もないですけれど。</p>
<p>あと、あくまで.NET 4.5の話でasync/awaitが入るからTaskのほうが良いと言ってるのであって、.NET 4.0以前ならまた違う話です。というかその場合だとRx一択です。</p>
<h2>ねぇ、Rxってもう要らない子？</h2>
<p>時代の徒花でしたね、短い命だった……。</p>
<p>って、ちょっと待ったー。それはYESでもあり、NOでもあります。YESなのは、単純な形での非同期処理ならば、遥かに楽になりますし、それに何よりもRxを通すよりもパフォーマンスは良いと思われるので、むしろasync/awaitを使うべきです。具体的には、SelectManyしてSubscribeするだけ、あとCatchで少し例外処理、みたいなコードなら、もう全面的にRxさようならでいいでしょう。</p>
<p>でも往々にしてそういう処理だけじゃないよね？以前にも紹介しましたがSwitch（新しい処理が入ったら以前の非同期処理はキャンセルして新しい処理のみを後続に流す）などを手書きせず演算子一つにパッケージ化できることや、全体的にTaskのメソッド群よりも合成や待ち合わせが容易に記述できる、などなど。そして、「複数の戻り値のある非同期処理、例えばStreamのBeginReadは細切れにbyte[]が得られますが、それを複数回分の非同期処理をまとめてシーケンスとして、IObservable&lt;byte[]&gt;としてまとめることは現状ではRxしかできません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 複数回のBeginReadをRx+Asyncで一つにまとめる例
static IObservable&lt;byte[]&gt; ReadMultipleAsync(Stream stream, int bufferSize)
{
    return Observable.Create&lt;byte[]&gt;(async observer =&gt;
    {
        try
        {
            while (true)
            {
                var buffer = new byte[bufferSize];
                var readCount = await stream.ReadAsync(buffer, 0, bufferSize);

                if (readCount == 0) break;
                if (readCount != bufferSize)
                {
                    var newBuffer = new byte[readCount];
                    Array.Copy(buffer, newBuffer, readCount);
                    buffer = newBuffer;
                }

                observer.OnNext(buffer); // yield returnのノリで書く
            }
            observer.OnCompleted(); // 完了合図と
        }
        catch (Exception ex)
        {
            observer.OnError(ex); // 例外は自前で明示的に
        }
    });
}
</code></pre>
<p>ExperimentalリリースではObservable.Createがasync/await対応しているので、擬似的なyield returnとして、非同期での列挙をそこそこ簡単に記述することができます。OnErrorとOnCompletedは自前で管理する必要がありますけれど。</p>
<p>なので、メソッド単体で分けた場合の戻り値は「長さ1」ならTask、複数ならIObservable。それらメソッドを使って非同期処理を組み上げる時は、単純ならawaitのみ、複雑ならRx。というのが使い分けの指針です。とはいえ、使い分けっていうのは幻想に近くて、実際はどっちか一つになりがちだとは思っています。そして、それならTask中心になるでしょうねえ、とも。非同期における大抵のシチュエーションでRxがサヨウナラ気味になるのはしかたのない話です。ぶっちゃけSelectManyしてSubscribeがほとんどだし、それ以外のことだって、同期的のように書けるのなら、いくらでもやりようはありますから。</p>
<p>まあ、未来を待たなくても今使える解としてなら十分ですし、それ自体がawait可能なので、今書いたコードは将来に渡っても無駄にはなりません。FromAsyncPatternがObsoleteというのは、まあ単純に.NET4.5本来のXxxAsyncに置き換えればいいというだけなので無駄になる、とは言わないでしょう。</p>
<p>けれど、それだけじゃあ、すごく後ろ向きで、寂しいよね。Rx自体の持つ力というのは、別に非同期に限らない。ただの幾つもある側面のうちの一つにすぎない。そこで出した私の答えが<a href="http://neue.cc/2011/10/07_346.html">ReactiveProperty : WPF/SL/WP7のためのRxとMVVMを繋ぐ拡張ライブラリ</a>です。ReactivePropertyはC#5.0によってプレゼンスが低下するReactive Extensionsに新たな価値をもたらしたいという危機感から作ったものだったりします(後付け、じゃなくてこれは本当の話です、次の一手を指すならRx自体に注目の集まっている今しかない、とも)</p>
<p>ReactivePropertyを通して見ると、非同期だけではない、Rxの持つポテンシャルがよく分かるのではないでしょうか？Rxの真の強みはイベント単独や非同期単独ではなくて、それらが、ただの配列も含めて、統一的に扱える、だから全て一本のストリームになって合成処理が自由自在。というOrchestrateな部分にある。ReactivePropertyはそれを全面的に押し出してます（半強制的に全てが一本に繋がるようになってる）</p>
<p>Rxは、この先も力強く存在し続けるので、学習する価値は間違いなくありますよ！</p>
<h2>まとめ</h2>
<p>相変わらずフリーダムな変更が続いているRxですが、あくまでExperimental版の話です。Stableでは、こんなバカバカと変わっていくことはないので、安心して使えばいいです。あと、Experimentalなのでまだまだ変動の余地はある、と思いますので、意見あればForumで直接言っておくとよさそう。私も、何やらかんやらと意見言っておきました(昔は書くのにビビッてたのに、今は平然と書いててアレです、慣れですね、ようするに)。</p>
<p>ところでRxは.NET 4.5に標準搭載されるのか否か、ですが、なんかまだまだ全然色々と変更や模索する気満々なようなので、この様子だと、仮にそういう話があったとしても間に合わなさそうという点で、標準搭載はなさそうですねー。ほぼ完成してるのに標準入りしない、とかだと悲しいんですが、そういう形で標準搭載見送り、ならばむしろ喜ばしい話なので、いいかなー、と思います。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>それにしてもRx本は出すタイミング難しいですねえ。今回の変更は非同期周りの話がガラッと変わってきちゃうわけなので。また延期かしらねえ。さすがにそれはないか。ところで私もLINQ + Rx本をオライリーから出したいです(←ただたんに表紙をデンキウナギ(Rxのロゴはピンクのデンキウナギ)にしてウナギ本と呼ばれたいという一点だけの話なので間に受けないでください)</p>
</div>
<h1 data-pagefind-sort="date:2011-10-11" data-pagefind-meta="published:2011-10-11"><a href="https://neue.cc/2011/10/11_347.html">ReactivePropertyのデモをしました</a></h1>
<ul class="date"><li>2011-10-11</li></ul>
<div class="entry_body"><p><a href="http://silverlightsquare.com/index.php/tokyo04.html">Silverlightを囲む会in東京#4</a>にて、<a href="http://neue.cc/2011/10/07_346.html">先日公開したReactiveProperty</a>についてお話しました。</p>
<div style="width:595px" id="__ss_9602585"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/reactiveproperty-slintokyo4" title="ReactiveProperty - slintokyo4" target="_blank">ReactiveProperty - slintokyo4</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/9602585" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>本題のセッションの後の、お楽しみセッションということで、LT的に5分程度とか思っていたつもりなのですが、大幅に時間オーバーして17分も喋っていました。これは酷い。色々と寛容に見て頂き感謝です。さおさんありがとうー。IIJさんも本当にありがとうございます。時間オーバーを許してくれたというのと(笑)、それと、ネットワークが良好だったお陰でTwitterインクリメンタルサーチのデモが出来たので。毎度ながら凄まじい画質のSmooth Streamingといい、神会場すぎます。</p>
<p>いつまで残るか分かりませんが、会場で行ったセッションの録画です。<a href="http://live.streamingmedia.jp/slintky04/">Silverlight を囲む会 in 東京 #4 @ IIJ 神保町三井ビル</a>。私のセッションは04:01:30 - 04:19:00です。ライブコーディングしているのは04:05:30-04:16:30ですね。</p>
<p>色々アレゲなのはいいとして、以前にスマベンで話をしたときにも反省事項だったのですがすっかり失念してた声の小ささはダメですねー。次は気をつけます。むしろ早口気味なのかと気にしてたんですが、録画を見るとそうでもないというか、このぐらいで調度良いぐらいですね。スライドはちゃっちゃと進めて欲しいし、本題のDemoは素早く進行して欲しいですから。ライブコーディングは好評だったようで何よりです。ちなみに、スムーズにプログラム書いていて凄い！と評価いただきましたが、やる内容が決まっているから書けたというだけで、例えばギターやピアノの演奏などと同じなわけで、普段は頭抱えながらゆったり書いてます。</p>
<p>ちなみに最後のTwitter検索のコードは若干アレだったので、修正したのをここに載せておきます。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, UpdateSourceTrigger=PropertyChanged}&quot; /&gt;
    &lt;ListBox ItemsSource=&quot;{Binding SearchResults.Value}&quot; /&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MainWindowViewModel
{
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveProperty&lt;string[]&gt; SearchResults { get; private set; }

    public MainWindowViewModel()
    {
        CurrentText = new ReactiveProperty&lt;string&gt;();

        SearchResults = CurrentText
            .Select(word =&gt; new WebClient()
                .DownloadStringObservableAsync(&quot;http://search.twitter.com/search.atom?q=&quot; + Uri.EscapeUriString(word)))
            .Switch()
            .Select(s =&gt;
            {
                var xml = XElement.Parse(s);
                var ns = xml.Name.Namespace;
                return xml.Descendants(ns + &quot;title&quot;).Select(x =&gt; x.Value).ToArray();
            })
            .OnErrorRetry((WebException e) =&gt; Debug.WriteLine(e))
            .ToReactiveProperty();
    }
}
</code></pre>
<p>SelectManyよりもSelect-&gt;Switchのほうがいいのと、OnErrorRetryの書く場所は、WebClientの真下だと永遠にリクエストをリピートしちゃうのでダメでしたね。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-07" data-pagefind-meta="published:2011-10-07"><a href="https://neue.cc/2011/10/07_346.html">ReactiveProperty : WPF/SL/WP7のためのRxとMVVMを繋ぐ拡張ライブラリ</a></h1>
<ul class="date"><li>2011-10-07</li></ul>
<div class="entry_body"><p class="noindent">
	<img style="width:640px" src="http://neue.cc/wp-content/uploads/image/RxMVVMLoop.jpg">
</p>
<p>MVVM拡張、という言い方が適切かは不明ですが、ともあれ、RxでXAMLによるUIシステムとの親和性を高めるライブラリを作成し、リリースしました。</p>
<ul>
<li><a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Reactive Extensions</a></li>
</ul>
<p>中身は大きく分けて二つで、一つはReactivePropertyというXAMLと双方向にバインド可能なIObservable&lt;T&gt;、ReactiveCommandというIObservable&lt;bool&gt;からCanExecuteの条件を宣言的に生成するコマンドなど、MVVM的なUI絡みのクラス群。もう一つはWebClientやWebRequestなど、非同期処理のための拡張メソッド群になります。</p>
<p>名前はUI中心に見えますが、UI絡みはいらないよ、という人は非同期周りだけを使ってくれても問題ありません。それと、機能紹介の前に一つ。決して既存のMVVMフレームワークを置き換えたり、同等の機能を提供するものではありません。ViewModelBaseやMessengerなどに相当するものはないので、その辺は適宜、既存のMVVMフレームワークを使えばいいと思います。というか、併用することを推奨します。だから「拡張ライブラリ」と名乗っています。</p>
<h2>UIへのバインディング</h2>
<p>ReactivePropertyとは何か。というと、双方向にバインド可能なIObservable&lt;T&gt;です。まず、ViewModel(Model)-&gt;Viewという片方向のバインドを見てみましょう。時計のようなものを作ります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;TextBlock Text=&quot;{Binding DisplayText.Value}&quot;  HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class SimpleClockViewModel
{
    // 双方向にバインド可能なIObservable&lt;T&gt;
    public ReactiveProperty&lt;string&gt; DisplayText { get; private set; }

    public SimpleClockViewModel()
    {
        // 1秒毎に値を発行、Selectで現在時刻に変換してToReactivePropertyでバインド可能にする
        DisplayText = Observable.Interval(TimeSpan.FromSeconds(1))
            .Select(_ =&gt; DateTime.Now.ToString())
            .ToReactiveProperty();
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>XAML側ではDisplayText.Valueというように、.Valueまで指定してバインドします。実に簡単にIObservableがバインドできると分かるのではないでしょうか？</p>
<p>IObservableとは、時間軸に沿って値が変わるものです。Intervalはx秒置きに等間隔で変わるので、まさに「時間」といったものですが、それ以外のものも全て時間軸に乗っていると考えることが可能です。例えばイベント、クリックやマウスムーブ、ジェスチャーやセンサーイベントで考えると、タッチした、x秒後にまたタッチした、x秒後にまたタッチした…… 発行される時間が不定期なだけで、時間軸に沿って次の値が出力されるという図式は同じです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rxeventime.jpg">
</p>
<p>非同期処理もそうで、x秒後に一回だけ値が来る。Rangeや配列のToObservableは0.0001秒刻みに値が来る。Rxで、IObservableで表現することが出来る値というのは、時間軸に乗って変わる/発行する値ということになります。そして、見渡してみると、IObservableになる、時間によって変わるという表現がマッチするものは意外と多い。特にリッチクライアントでは。UI自身の値の変化(バインディング/イベントによる通知)もそうだし、ModelのINotifyPropertyChangedもそう。INotifyPropertyChangedとは、或るプロパティの値が変化したという通知を行うオブジェクト。そのプロパティだけに着目してみれば、時間軸上で連続的に変化する値とみなせる、つまりIObservableで表現できます。</p>
<h2>UIからのバインディング</h2>
<p>では、UIからのバインディングもしてみましょう。これは、空のReactivePropertyを作成してバインディングします。これにより、UIからの入力をIObservableとして他へと中継することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;!-- このTriggerは入力と同時に発火させるために(SL4では)必要なもの --&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, Mode=TwoWay}&quot;&gt;
        &lt;i:Interaction.Behaviors&gt;
            &lt;prism:UpdateTextBindingOnPropertyChanged /&gt;
        &lt;/i:Interaction.Behaviors&gt;
    &lt;/TextBox&gt;
    &lt;TextBlock Text=&quot;{Binding DisplayText.Value}&quot; /&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class FromUIViewModel
{
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveProperty&lt;string&gt; DisplayText { get; private set; }

    public FromUIViewModel()
    {
        // UIからのテキスト入力の受け口
        CurrentText = new ReactiveProperty&lt;string&gt;();

        // そして、それを元にして加工してUIへ返してみたり
        DisplayText = CurrentText
            .Select(x =&gt; x.ToUpper()) // 全て大文字にして
            .Delay(TimeSpan.FromSeconds(3)) // 3秒後に値を流す
            .ToReactiveProperty();
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=1" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>Interaction.Behaviorは本題とは関係なくて、値の更新通知のタイミングを、値の変更と同時にするためのものです（デフォルトだとフォーカスが移ったときかな）。WPFでは、こういった小細工がなくてもいいのですが、SL4,WP7では必要なので已むを得ず。詳しくは <a href="http://code.msdn.microsoft.com/Silverlight-4TextBoxTextBin-3edebee5">Silverlight 4のTextBoxのTextプロパティの変更のタイミングでBindingのSourceを更新したい - MSDN Samples Gallery</a> に。というわけで、このUpdateTextBindingOnPropertyChangedはPrismからコピペってきたものです。</p>
<p>さて、入力の受け付けをベースにするものは、newで空の物を作ります。出力中心のものはToReactivePropertyなわけですね。あとは、文字が非連続的に、(同じスレッド上の)非同期でやってくるので、LINQで加工します。Selectで大文字にして、そして、Rxなので時間系のものも使えるので、Delayを使ってみたりしながら、UIに戻しました。なお、Delayの時点で値の実行スレッドはUIスレッドからスレッドプールに移りますが、ReactivePropertyを使う限りは、ReactiveProperty内部でスレッド間の値の通知を解決するため、Dispatcher.BeginInvokeも、ObserveOnDispatcherも不必要です。実行スレッドを意識するなんて原始的ですよね、ReactivePropertyなら、全く意識する必要がなくなります。非同期は自然のまま非同期で扱える。だって、そもそも全てが非同期なのだもの。</p>
<h2>ReactiveCommand</h2>
<p>ReactivePropertyのもう一つの大事な機構が、ReactiveCommandです。これは、IObservable&lt;bool&gt;という、実行可否の変化のストリームからICommandを生成します。一般的なMVVMフレームワークで使われるRelayCommand, DelegateCommandとは発想が異なるのですが、私はこのReactiveCommandのアプローチこそがベストだと考えます。まずは例を。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked1.Value, Mode=TwoWay}&quot;&gt;CheckBox1&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked2.Value, Mode=TwoWay}&quot;&gt;CheckBox2&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked3.Value, Mode=TwoWay}&quot;&gt;CheckBox3&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked4.Value, Mode=TwoWay}&quot;&gt;CheckBox4&lt;/CheckBox&gt;
    &lt;/StackPanel&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, Mode=TwoWay}&quot; /&gt;
    &lt;Button Command=&quot;{Binding ExecCommand}&quot;&gt;Execute?&lt;/Button&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Extensions; // 拡張メソッドを使う場合はこれを忘れず。

public class CommmandDemoViewModel
{
    public ReactiveProperty&lt;bool&gt; IsChecked1 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked2 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked3 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked4 { get; private set; }
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveCommand ExecCommand { get; private set; }

    public CommmandDemoViewModel()
    {
            var mode = ReactivePropertyMode.RaiseLatestValueOnSubscribe | ReactivePropertyMode.DistinctUntilChanged;

            IsChecked1 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked2 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked3 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked4 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            CurrentText = new ReactiveProperty&lt;string&gt;(
                initialValue: &quot;テキストが空の時はボタン押せないよ&quot;,
                mode: mode);

            ExecCommand = IsChecked1.CombineLatest(IsChecked2, IsChecked3, IsChecked4, CurrentText,
                    (a, b, c, d, txt) =&gt; a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; txt != &quot;&quot;)
                .ToReactiveCommand();

            ExecCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;Execute!&quot;));
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="150px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=2" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>全てのチェックがONで、かつ、テキストボックスに文字が含まれていないとボタンを押せません（テキストボックスの値の判定はフォーカスが外れてからになります）。CombineLatestというのは、二つの値のうち、どちらか一つが更新されると、片方は新しい値、片方はキャッシュから値を返して、イベントを合成するものです。もし片方にキャッシュがない場合はイベントは起こしません。「二つの値」というように、標準では二つの合成しか出来ないのですが、ReactivePropertyではこれを拡張して7つの値まで同時に合成できるようにしました（それ以上合成したい場合は、匿名型にまとめて、再度CombineLatestを繋げればよいでしょう）。この拡張はCodeplex.Reactive.Extensionsをusingすることで使えるようになります。Extensions名前空間には、他にも有益な拡張メソッドが大量に定義されていますので、是非覗いてみてください。</p>
<p>さて、つまりCombineLatestの結果というのは、ボタンが押せるか否かの、条件のストリームです。どういうことかというと、連続的なCanExecuteです。なので、そのままICommandに変換してしまいましょう、というのがToReactiveCommandになります。CanExecuteに変更があることを、条件のほうからPushして伝えるので、従来使われてきたコマンドを集中管理するCommandManager.RequerySuggestedや、(イベントなので)本来外から叩けないCanExecuteChangedを外から叩けるようにする、などの手立ては不要です。</p>
<p>常にtrueのコマンドならば、new ReactiveCommand()で生成できます。</p>
<p>ところで、mode: ReactivePropertyMode.RaiseLatestValueOnSubscribe というのは、Subscribeされる時に(ToReactivePropertyやToReactiveCommandは内部でSubscribeしています)、同時に最新の値を返します(最新の値がない場合は初期値を返します。初期値は指定することもできますし、もし指定していない場合はdefault(T)になります)。どういうことかというと、判定のタイミングの問題があります。CombineLatestは全てに一度は値の通知が来ている(キャッシュが存在する)状態じゃないと、イベントを起こしてくれません。なので、CanExecuteを初回時から判定させるために、これの指定が必要です。なお、ReactivePropertyModeのデフォルトはDistinctUntilChangedのみで、RaiseLatestValueOnSubscribeは明示的に指定しなければなりません。一件便利そうに見えるRaiseLatestValueOnSubscribeですが、問題も抱えていまして、後でも詳しく説明しますがバリデーションの時。バリデーションの場合は初回実行はして欲しくない（画面を表示したら、いきなり真っ赤っかだと嫌でしょう？）ケースがほとんどのはずです。RaiseLatestValueOnSubscribeを指定すると、初回実行してしまうので、そういう場合にとても都合が悪いのです。これは、良し悪しなので、適宜判断して、最適な方をお選びください。</p>
<h2>宣言的であるということ</h2>
<p>ReactiveCommandは、条件を宣言的に記述しました。そして、外部から叩くことは禁じられているので、その宣言以外のことが絡む可能性はありません。また、状態を外部変数から取得する(RelayCommandなどはそうなりますね)わけではないので、CanExecuteの変化のスコープはToReactiveCommandをする一連のシーケンスを読むだけですみます。変数を返す場合は、変数を使う範囲、つまりオブジェクト全体から変更可能性が混ざるという、大きなスコープの観察を余儀なくされます。読む場合だけでなく、書く場合でも、集中的に変化の条件を記述することができるので、ずっと楽でしょう。</p>
<p>ReactivePropertyもまた、同じです。値の変化の条件を宣言的に記述しました（こちらはReactiveCommandと違い、(Two-wayでバインド可能にするという都合上外部から叩くことが可能なのでスコープは閉じていませんが）。大事なのは、スコープを小さくすること。大きなスコープは往々に管理しきれないものです。リッチクライアントはステートを持つ。その通りだ。プロパティが、オブジェクトが、絡みあう。それは実に複雑なのは間違いない。でも複雑だから難しくて当然、複雑だからテストできない、複雑さを複雑なまま放っておいたら、それはただの新世代のスパゲティにすぎない。</p>
<p>ステートを捨てようじゃあなくて、宣言的にやろう。それがReactivePropertyの解決策、提案です。</p>
<h2>INotifyPropertyChangedと一緒に。</h2>
<p>全てReactivePropertyで相互作用を記述する、というのは理想的ですが過激派です。それに、既存のModelや自動生成のModelなど、様々なところにINotifyPropertyChangedはあります。理想だけじゃ生きていけません。それに、私もプレーンなModelはPOCO(+INotifyPropertyChanged)のほうが嬉しい。でも、IObservableになっていないと、関係の合成が不可能で困るので、INotifyPropertyChanged -&gt; ReactivePropery変換を可能にしました。ここでは説明しませんが、その逆のReactiveProperty -&gt; INotifyPropertyChanged変換も可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Extensions; // ObservePropertyもこれをusingで。

public class ObserveViewModel
{
    public ReactiveProperty&lt;string&gt; ModelText { get; private set; }

    public ObserveViewModel()
    {
        ModelText = new ToaruModel()
            .ObserveProperty(x =&gt; x.Text) // タイプセーフにIObservable&lt;T&gt;に変換
            .ToReactiveProperty();
    }
}

// WCFからだったりEntity Frameworkだったり既存のModelだったり他のViewModelだったり
// ともかく、INotifyPropertyChangedは至る所に存在します
public class ToaruModel : INotifyPropertyChanged
{
    private string text;
    public string Text
    {
        get { return text; }
        set { text = value; PropertyChanged(this, new PropertyChangedEventArgs(&quot;Text&quot;)); }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}
</code></pre>
<p>INotifyPropertyChangedの仕組みって、とあるプロパティが変更された、と名前でPushして、変更通知を受けた方はその名前を元にPullで取り出す。描画フレームワークが面倒を見ているなら、それでいいのですが、通常使うには、とてもまどろっこしい。だから、そうしたオブジェクトという大きな土台から名前ベースのPush &amp; Pull通知を、プロパティ単位の小さなPush通知に変換してやりました。指定はExpressionで行うのでタイプセーフですしね。</p>
<p>ReactivePropertyのほうがINotifyPropertyChangedよりも細かいハンドリングが効くのは当たり前の話で、単位が小さいから。逆に、だから、INotifyPropertyChangedという大きい単位で関係を作り込んでいくのは、非常に複雑でスパゲティの元だと言わざるを得ない。勿論、Reactive Extensionsという、プロパティ単位でのPushを自在に扱う仕組みが背後にあってこそのやり方ではあるのですが。</p>
<h2>MとVMの境界</h2>
<p>が、曖昧にみえるのはその通りかもしれません。けれど、処理がVMに偏りすぎるように見えるのなら、それは素直にMに移せばいい。細かいMを束ねるMを導入すればいい。名前は、サービスでもファサードでもプロキシーでもアプリケーションでもコントローラーでも、なんでもいい(わけではないけれど)。移せばいいなんて簡単にいいますが、それは簡単にできるからです。VM-M-VMが一気通貫してループを描いているなら、ローカル変数への依存もなくメソッドチェーンを切った貼ったするだけなので、どこに置くのも移すのは楽です。</p>
<p>そもそも、最初から明確に分けようとしたってどうせうまくいかないもの。インターフェイスだって、具象型から抽象を見出したほうが簡単だし、ずっとうまくいくでしょう？ネーミングだってリファクタリングで徐々に洗練させる。そもそもVMがヘヴィになりがちなのは、目で見える境界がないから、なせいでしょう。VはXAMLで線引きされるけれど、それ以外はコードで地続き。理想論だけで線を引こうとしたって空疎だし、そもそも、無理な話。境界を見出すには具体的に積み重なった後じゃないと無理でしょう(勿論、境界の敷き方を常日頃考える、研究することは有意義だと思います。そもそも考えていないと、いざ境界を見出そうとしても見えませんから)</p>
<h2>そもそもMVVMなのか</h2>
<p>UIに対するReactive Programmingなのは間違いないと思ってます。Reactive ProgrammingはUI向きだ。よく聞くその話は、実際その通りだと思うのですが、しかし同時にUI(というか、WPF/SL/WP7などXAML)とRxってどうもイマイチフィットしないなぁ、と悩んでいました。その理由は、最終的に描画を司るフレームワーク(XAML)とミスマッチなせいにあるのだと、気づきました。フレームワークの要求(INotifyPropertyChangedなオブジェクトであったりICommandであったり)と異なるものを、そのまま使おうとしたところで、良い結果は得られない。ゴリ押ししてもXAMLの旨みが生かせないし、Reactive Programmingを大前提に置いた描画フレームワークを構築すれば、もっと違う形になるでしょうが、そんなものは非現実的な話です。膨大な投資のされた、現在のXAML中心のシステムより良いもの……。やはり、絵空事にしか見えません。それに、XAMLは何だかんだ言って、良いものです。</p>
<p>それを認識したならば、必要なのは、境界を繋ぐシステムだと導ける。そのことを念頭においてReactivePropertyとReactiveCommandをデザインしました。MVVMライクなのは描画フレームワークに合わせた結果です、だから、MVVMでもあり、そうでもないようでもある。ただ、それによってパラダイムがミックスされてどちらの長所も活かせるし、世界最高峰のシステムであるXAMLアプリケーションに乗っかれるので今すぐ実用的という面もあるわけなので、これでいいと思うんです。いや、これがいいんです。マルチパラダイムは悪いことではない。あとは、ミックス故に生まれる新しい悩みをどう解消していくか、です。</p>
<p>マルチパラダイムといえば、ReactivePropertyは描画フレームワークからの言語への要求が変化（吸収）しているので、F#でも美味しくXAMLアプリケーションを書くことが可能になるでしょう。多分。</p>
<h2>非同期拡張メソッド群</h2>
<p>Rxは非同期の苦痛を癒す。とはいっても、実のところ素の状態だと罠が多くて、意外と使いづらかったりします。WebClientは、実行順序の問題があり、そのままではRxで扱いにくい。WebRequestはWebRequestでプリミティブすぎて機能が乏しいし、そのままではリソース処理に問題を抱えたりします。どちらも、ただFromEvent, FromAsyncするだけでは足りなくて、もう一手間かけたRx化が必要です。そのため、WebClient, WebRequestに対して拡張メソッドを用意し、簡単に実行出来るようにしました。</p>
<p>ReactivePropertyと合わせてのインクリメンタルサーチの例を。これは、ReactivePropertyのダウンロードファイルに含む非同期サンプルですので、是非ダウンロードして、サンプルを実際に実行してみてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Asynchronous; // 非同期系の拡張メソッド群を格納
using Codeplex.Reactive.Extensions; // OnErrorRetryはこちら

public class AsynchronousViewModel
{
    public ReactiveProperty&lt;string&gt; SearchTerm { get; private set; }
    public ReactiveProperty&lt;string&gt; SearchingStatus { get; private set; }
    public ReactiveProperty&lt;string&gt; ProgressStatus { get; private set; }
    public ReactiveProperty&lt;string[]&gt; SearchResults { get; private set; }

    public AsynchronousViewModel()
    {
        // IncrementしたりDecrementしたりすることでイベント(Empty ,Inc, Dec, Max)が発生する
        // それはネットワークの状態を管理するのに都合が良い(IObservable&lt;SignalChangedStatus&gt;)
        var connect = new SignalNotifier();
        // 指定したスケジューラ(デフォルトはUIDispatcherScheduler)上で任意にイベントを起こせる
        // 主にProgressと併用して進捗報告に利用する
        var progress = new ScheduledNotifier&lt;DownloadProgressChangedEventArgs&gt;();

        SearchTerm = new ReactiveProperty&lt;string&gt;();

        // 検索は当然非同期で行い、それをダイレクトにバインドしてしまう
        SearchResults = SearchTerm
            .Select(term =&gt;
            {
                connect.Increment(); // 非同期なのでリクエストは一つじゃなく並列になるので、これで管理
                return WikipediaModel.SearchTermAsync(term, progress)
                    .Finally(() =&gt; connect.Decrement()); // リクエストが終了したら、確実にカウントを下げる
            })
            .Switch() 
            .OnErrorRetry((WebException ex) =&gt; ProgressStatus.Value = &quot;error occured&quot;)
            .Select(w =&gt; w.Select(x =&gt; x.ToString()).ToArray())
            .ToReactiveProperty();

        // SignalChangedStatus : Increment(network open), Decrement(network close), Empty(all complete)
        SearchingStatus = connect
            .Select(x =&gt; (x != SignalChangedStatus.Empty) ? &quot;loading...&quot; : &quot;complete&quot;)
            .ToReactiveProperty();

        ProgressStatus = progress
            .Select(x =&gt; string.Format(&quot;{0}/{1} {2}%&quot;, x.BytesReceived, x.TotalBytesToReceive, x.ProgressPercentage))
            .ToReactiveProperty();
    }
}

// 非同期リクエストとデータ。単純ですが、Modelということで。
public class WikipediaModel
{
    const string ApiFormat = &quot;http://en.wikipedia.org/w/api.php?action=opensearch&amp;search={0}&amp;format=xml&quot;;

    public string Text { get; set; }
    public string Description { get; set; }

    public WikipediaModel(XElement item)
    {
        var ns = item.Name.Namespace;
        Text = (string)item.Element(ns + &quot;Text&quot;);
        Description = (string)item.Element(ns + &quot;Description&quot;);
    }

    // WebClientの他に、WebRequestやWebResponseへの非同期拡張メソッドも多数用意されています
    // また、ほとんど全ての非同期拡張メソッドにはプログレス通知を受け付けるオーバーロードがあります
    public static IObservable&lt;WikipediaModel[]&gt; SearchTermAsync(string term, IProgress&lt;DownloadProgressChangedEventArgs&gt; progress)
    {
        var clinet = new WebClient();
        return clinet.DownloadStringObservableAsync(new Uri(string.Format(ApiFormat, term)), progress)
            .Select(Parse);
    }

    static WikipediaModel[] Parse(string rawXmlText)
    {
        var xml = XElement.Parse(rawXmlText);
        var ns = xml.Name.Namespace;
        return xml.Descendants(ns + &quot;Item&quot;)
            .Select(x =&gt; new WikipediaModel(x))
            .ToArray();
    }

    public override string ToString()
    {
        return Text + &quot;:&quot; + Description;
    }
}
</code></pre>
<p>色々な機能を一度に説明しようとしているので、些か複雑かもしれません。まず、非同期リクエストは並列になります。例えばボタンを、通信中はDisabledにするのに、単純にbooleanで管理してもうまくいきません。どれか一つのアクセスが始まったらDisabledにしてどれか一つのアクセスが終わったらEnabledにする。それではダメです。どれか一つのアクセスが終わったところで、他のリクエストが通信中かもしれないケースに対応できませんから。</p>
<p>そこで、ReactivePropertyではSignalNotifierというものを用意しました。これは、IncrementかDecrementの操作によって、「ゼロになった」「インクリメントされた」「デクリメントされた」「Max（初期値で指定した場合）になった」というイベントを発行します。イベントといっても、自身がIObservable&lt;SignalStatus&gt;になっているので、直接Rxで扱えます。これのネットワークリクエストへの適用はシンプルで、通信開始されたらインクリメント。通信終了したらデクリメントする。そして、ゼロになったか否かを見れば、それが通信中か否かの判定になります。</p>
<p>非同期拡張メソッドはキャンセルに対しても強く考慮されています。WebClient(のSubscribeの戻り値)にDisposeするとCancelAsyncを、WebRequest(のSubscribeの戻り値)にDisposeするとAbortを呼ぶようになっています。このような挙動は、単純にFromEvent, FromAsyncしただけでは実現できないので、大きくて間を省けることでしょう。ネットワークリクエストを自身でキャンセルすることは少ないかもしれませんが、上の例であげたSwitchは内部でDisposeを呼びまくる仕組みになっていますので、しっかり対応している、というのは実行上、大きなアドバンテージとなります。</p>
<p>Switchは複数の非同期リクエストが確認された場合に、前のリクエストをキャンセル＋キャンセルが遅れた場合でも遮断して結果を後続に返さないことで、最新のリクエストの結果のみを返します。そのため、非同期リクエストが抱える結果が前後してしまう可能性、例えばインクリメンタルサーチではLINQと検索したのに、LINQの結果よりも後にLIの結果が返ってきたために、表示されるのがLIの結果になってしまう。などという自体が防げます。</p>
<p>また、OnErroRetryに注目してください。これはReactivePropertyが独自に定義している拡張メソッドで、例外発生時の処理をすると同時に、Retry（ここでいうとSearchTermの再購読なので、つまりチェーンの状態が維持される、ということになる）します。ToReactivePropertyを使い、ダイレクトに結び付けている場合は、例外が発生するとチェーンが終了して困るのですが、例外処理にこのOnErrorRetryを使うことで、そのような悩みは不要になります。なお、このOnErrorRetryは勿論ReactiveProperty専用というわけでもなく汎用的に使えます。例えば、もしネットワークからのダウンロードに失敗したら、一定間隔を置いて再度ダウンロードをする、但しリトライの挑戦は指定回数まで。というよくありそうな処理が、引数で回数とTimeSpanが指定できるので、簡単に記述できます。</p>
<p>進捗レポートも非同期処理では欠かせませんが、これは非同期拡張メソッドとScheduledNotifierを組み合わせることで、簡単に実現出来ます。これら非同期周りのサポートはReactivePropertyの重要な柱だと考えているので、UI周りの機能は必要ない、という人も、是非試してみて欲しいです。</p>
<h2>同期 vs 非同期</h2>
<p>SLやWP7はともかく、WPFでこのように強烈に非同期サポートする意味はあるのでしょうか。というと、あります(ただたんにコード共有しているから、というだけではなく)。まず、WinRTがそうなように、時間のかかる処理は時間のかかる処理なわけなので、強制的に非同期になっていたほうが、ViewModelなり束ねるModelなりで、そこら中に、明示的にスレッド管理(ただたんにTaskに投げるのも含む)をしないで済みます。本質的に非同期(CPU依存ではない形で時間がかかる)なものは非同期として扱ったほうが易しいのです。</p>
<p>もう一つは、Switchのような、キャンセルを多用した処理が書きやすいこと。それに、自然な形でプログレス処理もサポートできます。更には、ReactivePropertyを全面に使うのなら、全てがReactiveに通知しあう世界、つまり全てが非同期で回っているので、非同期のほうが圧倒的に相性が良いです。同期プログラミングさようなら。大丈夫です、何も問題ありません。</p>
<h2>C#5.0 Async vs Rx</h2>
<p>従来通りに書く。シンプルに同期のように。のならば、async/awaitのほうがずっと良い。そういう使い方をする場合は、Rxを非同期に使う必要性というのは、今後はなくなるでしょう。ではRxでの非同期に価値はなくなってしまうのか？というと、それに関しては明確にNOと答えます。</p>
<p>Rxの場合はLINQということで、宣言的なスタイル、演算子という形に汎用的な処理を閉じ込められる高いモジュール性。というのがあります。上で見たきたように、Switchのようなこと、OnErrorRetryのようなこと、これらを演算子という形で定義して、メソッド一発で適用出来るのはRxならではの利点です。もし自分でそれらの処理を書くとしたら…… あまり考えたくはないし、もしメソッドの形でまとめあげるとしても、Rxのように綺麗に適用させるのは不可能でしょう。どこか歪んだシグネチャを抱えることになります。</p>
<p>ReactivePropertyと親和性が高いのでViewModelへの伝達に使いやすいというのもポイントですね(TaskとIObservableは相互に変換可能なので、ToTaskしたりToObservableしたりするだけなので、別段問題でもないですけど)</p>
<p>使い分けというのは実際のところ幻想みたいなことなので、人によりどちらか主体のスタイルには落ち着くでしょう。私は、とりあえずRx主体で行きたいかなあと思ってますが、ライブラリ的な部分ではasync/awaitを使って書くでしょう(演算子の組み合わせでやろうとすると書くのも難しいし、パフォーマンスも出ないので)。現在のシーケンスに対する、yield returnで汎用的な演算子を作って、通常使うシーンではLINQ to Objectsで、定義した演算子を含めて使っていく。というのと同じスタイルが良さそうだと想像します。async/awaitの書きやすさ・パフォーマンスと、Rxのモジュール性の両立はその辺かなあ、って。</p>
<p>あと、連続的な非同期処理を一纏めにするというのが(今のところ)async/awaitだと出来ない(Task&lt;T&gt;の戻り値は一つだけだから)ので、その辺をやりたい場合にもRx(IObservable&lt;T&gt;は元より複数の戻り値を内包する)頼みになります。ここは将来的にどういう形になるのか、まだ不明瞭なところなので断言はしませんが。</p>
<h2>Validation</h2>
<p>ReactivePropertyでは、三種類のバリデーションに対応しています。DataAnnotationsによる属性ベース、IDataErrorInfoによるPull型のエラー確認、INotifyDataErrorInfoによるPush型/非同期のエラー確認。ただし、WPFではINotifyDataErrorInfoは使えなく(.NET4.5からは入るようですが)、WP7ではDataAnnotationsが使えません。これはクラスライブラリの問題なので私の方では如何ともしがたくで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// XAMLは省略。詳しくはSample/Validationを見てください

public class ValidationViewModel
{
    [Required]
    [Range(0, 100)]
    public ReactiveProperty&lt;string&gt; ValidationAttr { get; private set; }
    public ReactiveProperty&lt;string&gt; ValidationData { get; private set; }
    [StringLength(5)]
    public ReactiveProperty&lt;string&gt; ValidationBoth { get; private set; }
    public ReactiveProperty&lt;string&gt; ValidationNotify { get; private set; }
    public ReactiveProperty&lt;string&gt; ErrorInfo { get; private set; }
    public ReactiveCommand NextCommand { get; private set; }

    public ValidationViewModel()
    {
        // 属性ベースのバリデーションは、自身のプロパティをExpressionで指定することで適用できます
        // 通常属性ベースの場合、例外経由ですが、ReactivePropertyではIDataErrroInfo経由になります
        // そのため、XAML側ではValidatesOnDataErrors=Trueにしてください
        ValidationAttr = new ReactiveProperty&lt;string&gt;()
            .SetValidateAttribute(() =&gt; ValidationAttr);

        // IDataErrorInfoではエラー時のメッセージを渡します、nullの場合は成功の判定になります
        ValidationData = new ReactiveProperty&lt;string&gt;()
            .SetValidateError(s =&gt; s.All(Char.IsUpper) ? null : &quot;not all uppercase&quot;);

        // 三種類の指定は、重ねることが可能です（但し同じ種類のものを複数指定するのは不可能）
        ValidationBoth = new ReactiveProperty&lt;string&gt;()
            .SetValidateAttribute(() =&gt; ValidationBoth)
            .SetValidateError(s =&gt; s.All(Char.IsLower) ? null : &quot;not all lowercase&quot;);

        // INotifyDataErrorInfoの場合は、IObservable&lt;IEnumerable&gt;を返してください
        // 第一引数はself、つまりIObservable&lt;T&gt;になっていて、最終的にSelectでIEnumerableに変換します
        // IObservableということで、非同期での検証が可能になっているのがポイントです
        // これもIDataErrorInfoと同じく、nullの場合は成功という判定になります
        ValidationNotify = new ReactiveProperty&lt;string&gt;(&quot;foo!&quot;, ReactivePropertyMode.RaiseLatestValueOnSubscribe)
            .SetValidateNotifyError(self =&gt; self
                .Delay(TimeSpan.FromSeconds(3)) // DB問い合わせなど非同期なバリデーション（が可能）
                .Select(s =&gt; string.IsNullOrEmpty(s) ? null : new[] { &quot;not empty string&quot; }));

        // バリデーションの結果は、三種類全てまとめられてObserveErrorChangedから購読できます
        var errors = Observable.Merge(
            ValidationAttr.ObserveErrorChanged,
            ValidationData.ObserveErrorChanged,
            ValidationBoth.ObserveErrorChanged,
            ValidationNotify.ObserveErrorChanged);

        // もし、それらを分類したいときは、OfTypeを使うといいでしょう
        ErrorInfo = Observable.Merge(
                errors.Where(o =&gt; o == null).Select(_ =&gt; &quot;&quot;), // 成功はnull
                errors.OfType&lt;Exception&gt;().Select(e =&gt; e.Message), // 属性からはException
                errors.OfType&lt;string&gt;(), // IDataErrorInfoからはstring
                errors.OfType&lt;string[]&gt;().Select(xs =&gt; xs[0]))  // INotifyDataErrorInfoからは、IEnumerableの何か
            .ToReactiveProperty();

        // 検証が全部通ったら実行可能にするコマンド、などもこうやって書けますね！
        NextCommand = errors.Select(x =&gt; x == null).ToReactiveCommand(initialValue: false);
        NextCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;Can go to next!&quot;));
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=3" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>一点だけ通常と異なるのは、属性ベースのものを例外ではなくてIDataErrorInfoとして扱います（この辺はRxのパイプラインを通す都合上、例外を出すという形での実現が不可能だったので）</p>
<h2>Event to Observable</h2>
<p>イベントをXAML側で指定して、ReactivePropetyにバインドすることが可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;i:Interaction.Triggers&gt;
        &lt;i:EventTrigger EventName=&quot;MouseMove&quot;&gt;
            &lt;r:EventToReactive ReactiveProperty=&quot;{Binding MouseMove}&quot; /&gt;
        &lt;/i:EventTrigger&gt;
    &lt;/i:Interaction.Triggers&gt;
    &lt;TextBlock Text=&quot;{Binding CurrentPoint.Value}&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class EventToReactiveViewModel
{
    public ReactiveProperty&lt;MouseEventArgs&gt; MouseMove { get; private set; }
    public ReactiveProperty&lt;string&gt; CurrentPoint { get; private set; }

    public EventToReactiveViewModel()
    {
        // UIからのイベントストリームを受信
        MouseMove = new ReactiveProperty&lt;MouseEventArgs&gt;();
        
        // とりあえず座標を表示する、というもの
        CurrentPoint = MouseMove
            .Select(m =&gt; m.GetPosition(null))
            .Select(p =&gt; string.Format(&quot;X:{0} Y:{1}&quot;, p.X, p.Y))
            .ToReactiveProperty(&quot;MouseDown and drag move&quot;);
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=4" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>お手軽なので、結構便利だと思います。あの長大なFromEventPatternを書くよりかは(笑)</p>
<h2>シリアライズ</h2>
<p>特にWP7では頻繁な休止と復帰で、シリアライズ/デシリアライズによる状態の回復が重要です。そこで、値の回復を可能にするシリアライズ用のヘルパーを用意しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなビューモデルがあるとして
public class SerializationViewModel
{
    // なにもつけてないと普通にシリアライズ対象
    public ReactiveProperty&lt;bool&gt; IsChecked { get; private set; }
    [IgnoreDataMember] // Ignoreつけたら無視
    public ReactiveProperty&lt;int&gt; SelectedIndex { get; private set; }
    [DataMember(Order = 3)] // Orderつけたら、デシリアライズの順序を規程
    public ReactiveProperty&lt;int&gt; SliderPosition { get; private set; }
}

// 例えばWindows Phone 7のトゥームストーンなシチュエーションを考えてみると
private SerializationViewModel viewmodel = new SerializationViewModel();
private string viewmodelData = null;

protected override void OnNavigatingFrom(System.Windows.Navigation.NavigationEventArgs e)
{
    viewmodelData = SerializeHelper.PackReactivePropertyValue(viewmodel);
}

protected override void OnNavigatedTo(System.Windows.Navigation.NavigationEventArgs e)
{
    SerializeHelper.UnpackReactivePropertyValue(viewmodel, viewmodelData);
}
</code></pre>
<p>デシリアライズの順序はDataMember属性のOrderに従います。詳しくは<a href="http://msdn.microsoft.com/ja-jp/library/ms729813.aspx">データ メンバーの順序</a>を参照のこと。Pushしあう関係の都合上、デシリアライズの順序によって正確な復元ができないこともあるでしょうから、その場合は、Orderをつけると、ある程度制御できます。また、IgnoreDataMember属性をつけておくと、シリアライズ対象から除外することが可能です。</p>
<h2>スニペットとサンプル</h2>
<p>NuGetから入れてもらってもいいのですが、ダウンロードしてもらえるとコードスニペットとサンプルがついてきますので、最初はダウンロードのほうがいいかもです。コードスニペットはrpropでReactiveProperty&lt;T&gt; PropertyName{ get; private set; }という頻繁に書くことになる宣言が展開されます。他にはrcomm(ReactiveCommand)など。</p>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/ReactivePropertySample.jpg">
</p>
<p>サンプルはWPF/SL4/WP7全てで用意しました。サンプルを割としっかり用意した最大の理由は、ただ渡されても、もしかしなくてもどう書けばいいのかさっぱり分からないのでは、と思ったのがあります。決して複雑ではなく、むしろシンプルだし記述量は大幅に減るわけです、が、従来のやり方からするとあまりにも突飛なのは否めないので、いきなりスイスイ書くというのは無理ですよねぇ、と。</p>
<p>その他紹介していない、サンプルに載ってない機能は、まだいっぱい。こんなに記事がなくなっちゃってもまだ全然足りない。でも、いきなりてんこ盛りだと引いてしまうので、基本的にはReactivePropertyとReactiveCommandが主体で、慣れたら徐々に周囲を見てもらえばな、ぐらいに思っています。</p>
<h2>まとめ</h2>
<p>仕上がりはかなり良いと、興奮しています。この長い記事！興奮を伝えたいという気持ちでいっぱいだからです。今後も、利用シーンの模索と合わせて、どんどん進化させていくつもりです。初回リリースですし、というのもありますが、コアコンセプトの実現と、使い勝手としてのAPIの錬成に力を注いだので、それ以外の部分の研究が疎かになっているというのは否めませんので、そこのところの強化も行なっていきます。また、JavaScriptへの移植もノリ気なので、まず<a href="http://knockoutjs.com/">Knockout.js</a>を試して、その上に構築させたいなあ、とか考えています。</p>
<p>ところで、10/8土曜日、明日の<a href="http://silverlightsquare.com/index.php/tokyo04.html">Silverlightを囲む会in東京#4</a>の一番最後に、少し、デモ中心でお話をするつもりなので（最後のオマケなのでほんの少しだけですけどね)良ければ見に来てください。ギリギリではありますが、まだ申し込みも出来ると思います。また、もしよければ会場/懇親会でつかまえて聞いてくれたりすると泣いて喜びます。会場に来れなくてもIIJさんのSmooth Streamingで超高画質な配信が行われると思われますので、そちらでも是非是非。</p>
</div>
<h1 data-pagefind-sort="date:2011-09-23" data-pagefind-meta="published:2011-09-23"><a href="https://neue.cc/2011/09/23_345.html">SL/WP7のSilverlight Unit Test Frameworkについて少し深く</a></h1>
<ul class="date"><li>2011-09-23</li></ul>
<div class="entry_body"><p>の、前に少し。<a href="http://dynamicjson.codeplex.com/" title="DynamicJson">DynamicJson</a>と<a href="http://linqcomparer.codeplex.com/" title="AnonymousComparer - lambda compare selector for Linq">AnonymousComparer</a>をNuGetに登録しました。どちらも.csファイル一個のお手軽クラスですが、NuGetからインストール可能になったことで、より気楽に使えるのではかと思います。機能説明は省略。</p>
<p>そして、昨日の今日ですが<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>を<a href="http://archive.msdn.microsoft.com/silverlightut" title="Silverlight Unit Test Framework - Home">Silverlight Unit Test Framework</a>に対応させました。リリースのバージョンは1.6.0.1ということで。NuGetでは<a href="http://nuget.org/List/Packages/ChainingAssertion-SL">ChainingAssertion-SL</a>と<a href="http://nuget.org/List/Packages/ChainingAssertion-WP7">ChainingAssertion-WP7</a>になります。</p>
<h2>Silverlight Unit Test Framework</h2>
<p>Silverlightで使う場合は(WP7じゃなくてね、という意味です)、一応<a href="http://silverlight.codeplex.com/" title="Silverlight Toolkit">Silverlight Toolkit</a>に同梱という話ではあるのですが、テンプレートなどの用意が面倒くさいので、NuGet経由で入れるのが最も楽のようです。<a href="http://nuget.org/List/Packages/Silverlight.UnitTest" title="NuGet gallery">Install-Package Silverlight.UnitTest</a>で。</p>
<p>まず、Silverlightアプリケーションを新規作成。Webサイトでのホストはなしでいいです。それとブラウザで実行させる必要もないので、プロジェクトのプロパティからOut of Browserに変更してしまいましょう。次に、NuGetからInstall-Package Silverlight.UnitTest。これでライブラリの参照と、ApplicationExtensions.cs(イニシャライズ用拡張メソッド)、UnitTest.cs（テスト用テンプレ）が追加されているはずです。次にApp.xaml.csのStartupを以下のように書き換えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">private void Application_Startup(object sender, StartupEventArgs e)
{
    // this.StartTestRunnerDelayed();
    this.StartTestRunnerImmediate();
}
</code></pre>
<p>StartTestRunnerDelayedはテストランナー起動時に実行オプション（指定属性のもののみ実行するなど）を選択可能にするもの、Immediateはすぐに全テストを実行する、というものです。どちらかを選択すればOK。それで、とりあえず実行(Ctrl+F5)してみれば、テストランナーが立ち上がって、デフォテンプレに含まれるUnitTest.csのものが実行されているんじゃないかしらん。あとは、それを適宜書き換えていけばよし。なお、テンプレのテストクラスはSilverlightTestを継承していますが、これは必ずしも継承する必要はありません。後述しますが、Asynchronousのテストを行いたいときは必須ですが、そうでないならば、普通にMSTestでの場合と同じように、[TestClass]と[TestMethod]属性がついているものがテスト対象になっています。</p>
<p>なお、MainPage.xaml/.xaml.csは不要なので削除してしまってOK。StartTestRunnerによって、参照DLLのほうに含まれるxamlが呼ばれているためです。</p>
<h2>WP7の場合。</h2>
<p>一応NuGetにも用意されてるっぽい(silverlight.unittest.wp7)んですが、動きませんでした。ので、今のところ手動で色々用意する必要があります。詳しくは<a href="http://d.hatena.ne.jp/okazuki/20110911/1315736690" title="Windows Phone 7用の単体テストツール？ その２「使ってみた」 - かずきのBlog@Hatena">Windows Phone 7用の単体テストツール？ その２「使ってみた」 - かずきのBlog@Hatena</a>に全部書いてあるのでそちらを参照のことということで。参照するためのDLLを拾ってくる→App.xaml.cs、ではなくてMainPage.xaml.csを書き換える、という、Silverlight版とやることは一緒なのですけどね。こういう状況なのはMangoのSDKがベータだったからとかなんとかのせいだとは思うので、近いうちに解決するのではかと、楽観視したいところです。</p>
<h2>Chaining Assertionを使ってみる</h2>
<p><a href="http://neue.cc/2011/09/20_344.html" title="neue cc - Chaining Assertion ver 1.6.0.0">Chaining Assertion ver 1.6.0.0</a>の解説で紹介した失敗結果が丁寧に表示されるよー、をチェックしてみませう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public int Age { get; set; }
    public string FamilyName { get; set; }
    public string GivenName { get; set; }
}
 
[TestClass]
public class ToaruTest
{
    [TestMethod]
    public void PersonTest()
    {
        // こんなPersonがあるとすると
        var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
        // こんな風にメソッドチェーンで書ける(10歳以下でYamadaTarouであることをチェックしてます)    
        // 実際の値は50歳でYamamotoTasukeなので、このアサーションは失敗するでしょう
        person.Is(p =&gt; p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
    }
}
</code></pre>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/persontestwp7.jpg">
</p>
<p>はい、ちゃんと表示されます。Chaining Assertionを使うと、メソッドチェーンスタイルで、実際の値.Is(期待値の条件)というように、 簡潔な記述でテストを書くことが出来るのがうりです。また、失敗時には、この場合personの値を詳細に出力してくれるので、何故失敗したのかが大変分かりやすい。もし、普通に書くと以下のようになりますが、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// もし普通に書く場合
var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
Assert.IsTrue(person.Age &lt;= 10);
Assert.AreEqual(&quot;Yamada&quot;, person.FamilyName);
Assert.AreEqual(&quot;Tarou&quot;, person.GivenName);
</code></pre>
<p>まず、Assert.IsTrueでは失敗時にperson.Ageの値を出してくれないので、確認が面倒です。また、この場合、Personが正しいかをチェックしたいわけなので、FamilyNameやGivenNameも同時に判定して欲しいところですが、Ageを判定した時点で失敗のため、そこでテストは終了してしまうため、FamilyNameやGivienNameの実際の値を知ることは出来ません。</p>
<p>などなどの利点があるので、<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>はお薦めです！この記事はSilverlight Unit Test Frameworkの紹介の体をとっていますが、実態はChaining Assertionの宣伝記事ですからね(ｷﾘｯ</p>
<h2>非同期テストをしてみる</h2>
<p>Silverlightといったら非同期は避けて通れない。というわけで、Silverlight Unit Test Frameworkには非同期をテストできる機構が備わっています。[Asynchronous]というように、Asynchronous属性をつければそれだけでOK。と、思っていた時もありました。実際に試してみると全然違って、独特なシステムのうえにのっかっていて、かなり面倒くさかった……。</p>
<p>準備。まず、非同期テストをしたいクラスはSilverlightTestクラスを継承します。そしてAsynchronous属性をつけます。すると、そのテストメソッドはTestCompleteが呼ばれるか例外を検知するまでは、終了しなくなります。というわけで、こんな感じ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestClass]
public class ToaruTest : SilverlightTest
{
    [TestMethod]
    [Asynchronous]
    public void AsyncTest()
    {
        var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
        req.BeginGetResponse(ar =&gt;
        {
            try
            {
                req.EndGetResponse(ar)
                    .ResponseUri.ToString()
                    .Is(&quot;http://www.google.co.jp/&quot;);
            }
            catch (Exception ex)
            {
                EnqueueCallback(() =&gt; { throw ex; }); // 例外はテスト用スレッドに投げる必要がある
                return;
            }

            // ↓は定型句なので、EnqueueTestComplete(); という単純化されたのが用意されている
            EnqueueCallback(() =&gt; TestComplete()); // 何事もなければ終了でマーク
        }, null);
    }
}
</code></pre>
<p>このUnitTestの非同期は、独自のスレッドモデル（のようなもの）で動いていて、Dispatcherのようなキューにたいしてアクションを放り投げてあげる必要があります。別スレッドからUIスレッドは触れないように、「成功(TestComplete)」か「失敗(例外発生)」を伝えるには、EnqueueCallbackを経由しなければなりません。この辺はDispatcher.BeginInvokeするようなもの、と考えるといいかもしれません。</p>
<p>上のは少し原理に忠実にやりすぎた。まるごとEnqueueCallbackしてしまえばスレッドを意識する必要性は少しだけ減ります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod, Asynchronous]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/404&quot;); //404なので例外出してくれる
    req.BeginGetResponse(ar =&gt;
    {
        EnqueueCallback(() =&gt; req.EndGetResponse(ar)
            .ResponseUri.ToString()
            .Is(&quot;http://www.google.co.jp/&quot;));

        EnqueueTestComplete();
    }, null);
}
</code></pre>
<p>といっても、これは非常に単純なケースなだけであって、複雑なケースを書くとどんどん泣きたくなっていくでしょう……。一応、Enqueueには他にEnqueueConditionalという、条件式がtrueになるまで待機し続けるというものが用意されているので、若干制御はできなくもないんですが、あんまりできるとは言い難い仕組みがあります。詳しくは述べませんというか、別に使いやすいシステムじゃないのでどうでもいいです。</p>
<h2>Rxを使ってみる</h2>
<p>結果・もしくは例外を別のスレッドシステムに投げる。どこかで聞いたことあるような。ここでティンと来るのは<a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>のObserveOnDispatcherです。Dispatcher.BeginInvokeのかわりにEnqueueCallback。丸っきりそっくり。なので、ObserveOnTestQueueのようなメソッドが作れれば、非常に使い勝手がいいんじゃないか。と思い浮かぶわけです。</p>
<p>と、浮かんだ人は実に素敵な発想力を持っていますね。浮かんだのは私じゃなくて海外の人です。はい。<a href="http://blog.richardszalay.com/2011/08/08/writing-asynchronous-unit-tests-with-rx-and-the-silverlight-unit-testing-framework/" title="Writing asynchronous unit tests with Rx and the Silverlight Unit Testing Framework | Richard Szalay">Writing asynchronous unit tests with Rx and the Silverlight Unit Testing Framework | Richard Szalay</a>に、実装が書かれています。</p>
<p>そのRxによるScheduler実装を使うと(WP7版なのでSystem.ObservableとMicrosoft.Phone.Reactiveも参照してください)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod, Asynchronous]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
    Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse,req.EndGetResponse)()
        .ObserveOnTest(this)
        .Subscribe(r =&gt; 
            r.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;),
            () =&gt; TestComplete());
}
</code></pre>
<p>EnqueueCallbackの管理がなくなり、非常に簡単に記述できました。Rxのスケジューラのシステムの柔軟さの賜物ですね。これはRxの素晴らしい応用例だと本当に感動しました。Richard Szalayさんに乾杯。それと、私がこの記事を知ったのは<a href="http://www.infoq.com/jp/news/2011/09/Rx-Silverlight-Tests" title="InfoQ: Rx と Silverlight で非同期テストを記述する">InfoQ: Rx と Silverlight で非同期テストを記述する</a>からなので、紹介したInfoQと、そして翻訳した勇 大地さんにも大変感謝します。</p>
<h2>Silverlightの場合</h2>
<p>Richard SzalayさんのコードはWP7のMicrosoft.Phone.Reactiveのためのものなので、Silverlight用Rxの場合はそのままでは動きません。はい。残念ながら、WP7版RxとDataCenter版Rxとでは、互換性がかなり崩壊しているので、そのまま動くことなんてないんです。悲しいですねえ……。これに関しては<a href="http://techblog.hilife-jp.info/2011/09/rx-silverlight-web.html" title="銀の光と藍い空: 「Rx と Silverlight で非同期テストを記述する」をWeb版にも使えるようにしたい!">銀の光と藍い空: 「Rx と Silverlight で非同期テストを記述する」をWeb版にも使えるようにしたい!</a>に書かれていますが、Silverlight用に移植してあげればよいようです。</p>
<p>既に、上記記事で田中さんが移植されているのですが、二番煎じに書いてみました（と、※欄で書いたものを流用です、毎回、流用させてもらっていてすみません……）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class TestHarnessSchedulerObservableExtensions
{
    public static IObservable&lt;T&gt; ObserveOnTestHarness&lt;T&gt;(this IObservable&lt;T&gt; source, WorkItemTest workItemTest)
    {
        return source.ObserveOn(new TestHarnessScheduler(workItemTest));
    }

    public static IDisposable RunAsyncTest&lt;T&gt;(this IObservable&lt;T&gt; source, WorkItemTest workItemTest, Action&lt;T&gt; assertion)
    {
        return source.ObserveOnTestHarness(workItemTest).Subscribe(assertion, () =&gt; workItemTest.TestComplete());
    }
}

public class TestHarnessScheduler : IScheduler, IDisposable
{
    readonly WorkItemTest workItemTest;
    readonly CompositeDisposable subscriptions;

    public TestHarnessScheduler(WorkItemTest workItemTest)
    {
        var completionSubscription =
            Observable.FromEventPattern&lt;TestMethodCompletedEventArgs&gt;(
                h =&gt; workItemTest.UnitTestHarness.TestMethodCompleted += h,
                h =&gt; workItemTest.UnitTestHarness.TestMethodCompleted -= h)
            .Take(1)
            .Subscribe(_ =&gt; Dispose());

        this.subscriptions = new CompositeDisposable(completionSubscription);
        this.workItemTest = workItemTest;
    }

    public void Dispose()
    {
        subscriptions.Dispose();
    }

    public DateTimeOffset Now
    {
        get { return DateTimeOffset.Now; }
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        return Schedule(state, dueTime - Now, action);
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        if (subscriptions.IsDisposed) return Disposable.Empty;

        workItemTest.EnqueueDelay(dueTime);
        return Schedule(state, action);
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        if (subscriptions.IsDisposed) return Disposable.Empty;

        var cancelToken = new BooleanDisposable();

        workItemTest.EnqueueCallback(() =&gt;
        {
            if (!cancelToken.IsDisposed) action(this, state);
        });

        subscriptions.Add(cancelToken);
        return Disposable.Create(() =&gt; subscriptions.Remove(cancelToken));
    }
}
</code></pre>
<p>Richard Szalayさんのコードが非常に素晴らしく、あらゆるケースへのキャンセルに対して完全に考慮されているという感じなので、そのまま持ってきました。実際のところ、テスト用なので「例外発生/TestCompleteが呼ばれる」で実行自体が終了してしまうわけなので、こうもギチギチに考えなくてもいいのではかなー、とか緩いことを思ってしまいますが、まあ、よく出来ているならよく出来ているままに使わさせてもらいます。</p>
<p>メソッド名は、ObserveOnTestHarnessに変更しました。ObserveOnTestだけだと何かイマイチかなー、と思いまして。それと、時間のスケジューリングは、NotSupportedではなくて、EnqueueDelayというのものがあるので、それを使うことにしてみました。それと、ObserveOn -&gt; Subscribe -&gt; onCompletedにTestCompleteが定形文句なので、それらをひとまとめにしたRunAsyncTestを追加。こんな風に書けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://www.google.co.jp/444&quot;);
Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
    .RunAsyncTest(this, res =&gt; 
        res.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;));
</code></pre>
<p>定形文句が減る、つまりうっかりミスで書き忘れて死亡というのがなくなる、というのはいいことです。</p>
<h2>通常のMSTestの場合</h2>
<p>ところで、もしSilverlight/WP7固有の機能は使っていなくて、WPFでも利用出来るようなコードならば、コードをリンク共有の形でWPF側に持っていってしまって、そこでテスト実行してしまうと非常に楽です。まず第一に、MSTestやNUnitなどの通常のテストフレームワークが使えるため、Visual Studio統合やCIが簡単に行えます。第二に、非同期のテストが(Rxを使った場合)更に簡単になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
    var result = Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
        .First(); // First()で同期的に待機して値が取れる。複数の場合はToEnumerable().ToArray()で。

    result.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;);
}
</code></pre>
<p>FirstやToEnumerable.ToArrayにより、同期的に待機することが出来るので、簡単にテストすることができます。通常のコードは同期的待機はすべきではないのですが、こうしたユニットテストの場合は便利に使えます。</p>
<p>じゃあSilverlightのユニットテストでも待機できるのはないか？というと、それはできません。理由は<a href="http://neue.cc/2010/10/14_280.html">Windows Phone 7で同期APIを実現するたった つの冴えないやり方</a>で書いたのですが、WebRequestなどのネットワーク問い合わせは、一度Dispatcherに積まれて、現在のメソッドを抜けた後に実行開始されるので、テスト実行スレッドで同期的に待って値を取り出すことは不可能なのです。</p>
<p>こういった細部の違いもあるので、コード共有してMSTestでチェックするのは楽でいいのですが、やはりSilverlight/WP7の実際の環境で動かされるユニットテストのほうも必要不可欠かなー、と。どこまでやるか、にもよりますが。</p>
<h2>まとめ</h2>
<p><a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>は便利なので是非試してみてね！</p>
<p>なお、Rxを使うとTestScheduler(時間を好きなように進められる)やITestableObserver(通知の時間と値を記録できる)といった、イベント/非同期のテストを強力に支援する仕組みが備わっているので、それらと併用することで、より簡単に、もしくは今までは不可能だったことを記述できるようになります。それはまた後日そのうち。</p>
<p>SL/WP7のテストは、本当はIDE統合されてるといいんですけどねー。まあ、エミュレータ動かさなければならないので、しょうがないかな、というところもありますけれど。その辺も次期VisualStudioでは改善されるのかされないのか、怪しいところです。現在DeveloperPreviewで出ているVS11は、特に何も手をつけられてる感じがしないので、そのままな可能性はなきにしもあらず。どうなるかしらん。async/awaitが入ることだし、色々変わってくるとは思うんですけれど。</p>
</div>
<h1 data-pagefind-sort="date:2011-09-20" data-pagefind-meta="published:2011-09-20"><a href="https://neue.cc/2011/09/20_344.html">Chaining Assertion ver 1.6.0.0</a></h1>
<ul class="date"><li>2011-09-20</li></ul>
<div class="entry_body"><p><a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>というメソッドチェーンスタイルでユニットテストを書くことの出来るテスト用補助ライブラリをver.1.6に更新しました。内容はAssertEx.ThrowsContractExceptionの追加と、ラムダ式を使った判定の失敗時メッセージが親切になりました。</p>
<h2>ThrowsContractException</h2>
<p>まず、契約失敗でスローされる例外を厳密に検出することができるということについて。以前に<a href="http://www.slideshare.net/neuecc/code-contracts-8069150" title="基礎からのCode Contracts">基礎からのCode Contracts</a>というスライドに書きましたが、Contract.Requires(など)で発生する、契約の条件に合っていない時にスローされる例外は、ContractExceptionというリライト時にアセンブリに埋め込まれる型のため、型を判別してのcatchは不可能です。</p>
<p>そのため、従来は大雑把にExceptionがスローされるか否か、でしか判定できませんでした。そこでThrowsContractExceptionを使うと、厳密に、契約失敗の例外のみを判定することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなContractなクラスがあるとして
public class QB
{
    public void Homu(string s)
    {
        Contract.Requires(s != null);
    }
}

// こういう風に契約違反の例外を捉えることができる
[TestMethod]
public void QBTest()
{
    AssertEx.ThrowsContractException(() =&gt;
        new QB().Homu(null));
}
</code></pre>
<p>Code Contractsを使ったコードを書いている場合は、便利に使えるのではないでしょうかー。</p>
<h2>ラムダ式によるアサーション</h2>
<p>で、Chaining Assertionって、こんな感じに書けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public int Age { get; set; }
    public string FamilyName { get; set; }
    public string GivenName { get; set; }
}

// こうして判定することが出来ます
[TestMethod]
public void PersonTest()
{
    // GetPersonメソッドでPersonインスタンスを取得するとして、
    // こんな風にメソッドチェーンで書ける(10歳以下でYamadaTarouであることをチェックしてます)
    new HogeService().GetPerson().Is(p =&gt;
        p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
}
</code></pre>
<p>今回追加したのは、失敗した時のメッセージをより分かりやすくしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod]
public void PersonTest()
{
    // こんなPersonがあるとすると
    var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
    // このアサーションは失敗します
    person.Is(p =&gt; p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/chainigassertion_error_lambda.jpg">
</p>
<p>分かりやすいですよね！値は全部のダンプじゃなくて、ラムダ式の中で使われているプロパティ/フィールドのみを出すことにしているので、メッセージ欄が極度に爆発することもないです。今はまだ一階層の値しか出力してないのですが、いずれはもう少し複雑に解析して表示できるようにしたいところ。理想は<a href="http://d.hatena.ne.jp/kyon_mm/20110315/1300193710" title="Groovyのassertがすごく見やすい件について - うさぎ組">GroovyのPowerAssert</a>のようなグラフィカルな表示ですね。Expressionにより、データはあるので、解析をがんばれば作ること自体は可能だ、というのがC#のポテンシャルです。活かすか殺すかは、努力次第。まだ、活かしきれてはいません。</p>
<h2>まとめ</h2>
<p>MSでSilverlight周りのチームにいるJafar Husain氏（Silverlight Toolkitに入ってるという話で最初にRxを世界に紹介した人ですね！）は、<a href="http://themechanicalbride.blogspot.com/2009/06/better-unit-tests-with-testassert-for.html" title="unfold: Better Unit Tests with Test.Assert() for NUnit/VSTT/SUTF">unfold: Better Unit Tests with Test.Assert() for NUnit/VSTT/SUTF</a>という記事で.NETはずっとパワフルなのに、いつまでJUnitスタイルの古いAPIを引きずってるんだ？と問題提起し、Expressionを解析して適切なAssertに差し替えるという、Queryable的な実装を示しました。Chaining Assertionでは、もっと野蛮に、拡張メソッドとラムダ式により、C#らしいスタイルで軽快に記述することを可能にしました。</p>
<p>最近少し刺され気味なので若干弁解しておきますが、別にスタイルは自由ですよ。でも他人に使わせるものは、より良いものであるべきだし、そうして他人が使ったりリファレンスとして参照されるものが、あんまりな出来だったら、そりゃ一言あって然りでしょう。本当に多くの人が参照するものだったら、なおのことです。いやまあ、度を超えた発言は刺されてもしょうがないですが。</p>
<p>NuGetからも入れられるのと、MSTestの他にNUnit, MbUnit, xUnit.NETにも対応しているので、試してもらえると嬉しいです。</p>
</div>
<h1 data-pagefind-sort="date:2011-09-17" data-pagefind-meta="published:2011-09-17"><a href="https://neue.cc/2011/09/17_343.html">Rxにおける並行非同期実行とリソース処理の問題</a></h1>
<ul class="date"><li>2011-09-17</li></ul>
<div class="entry_body"><p>非同期(Asynchronous)だの並列(Parallel)だの並行(Concurerrent)だの、よくわからない単語が並びます。ParallelがやりたければPLINQ使うべし、と思うわけですがそれはさておき、Rxを使うと、意図しても意図しなくても、並行な状態にはなります。そして、その意図していないという状態は危うい線を踏んでいるので、きちんと認識しておく必要があります。また、危ういと同時に、Rxはその並行をうまくコントロールするメソッドが揃っているので、覚えておくと世界が一気に広がります。</p>
<p>例えば、こういう非同期メソッドがあるとして。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">IObservable&lt;T&gt; AsyncModoki&lt;T&gt;(T value, int second)
{
    // second秒後にvalueを返す非同期処理をシミュレート
    return Observable.Return(value)
        .Delay(TimeSpan.FromSeconds(second));
}

static void Main(string[] args)
{
    // 1,2,3,4という入力をすぐに送り込む
    new[] { 1, 2, 3, 4 }
        .ToObservable()
        .SelectMany(x =&gt; AsyncModoki(x, 3))
        .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

    Console.ReadLine();
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="50px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>1~4は、全て同時にリクエストが開始されます。だから、3秒後に同時に結果が表示されます。</p>
<p>同時に実行が開始されているということは、非同期の結果が完了する時間にズレがある場合、結果が前後することがあります。実際、上のものも何度か実行すると毎回結果が変わると思います(Delayは（デフォルトだと）値をThreadPoolに投げて遅延させます。ThreadPoolに入った時点で、順序の保証が消滅する)。というわけで、基本的にSelectManyを使った場合1:1で渡していくわけではなければ、順序は壊れると考えてください。さて、それだと困る場合もあるのではと思いますので、結果の順序を制御する方法が幾つかあります。</p>
<h2>Switch</h2>
<p>Switchは実に有意義なメソッドで、分かると、SelectMany以上に多用することが多くなるのではと思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">clickEventObservable // クリック毎に
    .Select(x =&gt; AsyncModoki(x, 1)) // 何らかの非同期処理をするとする
    .Switch() // IObservable&lt;IObservable&lt;T&gt;&gt;の状態なので、Switch
    .Subscribe(Console.WriteLine);
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="50px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=1" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>クリックすると1秒遅延（非同期処理でもしていると考えてください）して、値が表示されます。しかし、1秒以内に次の値がクリックされた場合はキャンセルされ、表示しません。</p>
<p>つまり、最新の値だけを返すことを保証します。それ以前のものはキャンセル(Disposeが呼ばれる)されます。どういう時に使うかというと、例えばインクリメンタルサーチ。L, LI, LIN, LINQと入力が変わる度に非同期リクエストを発生させますが、欲しい結果は最後の一件のみで、次のキー入力があった場合は以前のものはキャンセルして欲しい。キャンセルはともかく、非同期実行だと結果が前後してしまうことだってあります。LINQと入力したのにLIの結果一覧が表示されてしまったら困る。そんな場合に、まさに、うってつけです。そして存外、こういったシチュエーションは多いのではないかと思われます。例えば私の以前作った<a href="http://utakotoha.codeplex.com/">Utakotoha</a>というWP7用歌詞表示アプリケーションも、曲のスキップに応じて最新のものだけを表示するために、Switchを利用しました。（コードが激しく酷いのと機能貧弱っぷりなので、そろそろ書き直したい）</p>
<h2>Merge/Concat</h2>
<p>Switch以外にも色々あります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">new[] { 1, 2, 3, 4 }
    .ToObservable()
    .SelectMany(x =&gt; AsyncModoki(x, 1)) // 全て並行実行(最初の例です)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1)) // IO&lt;IO&lt;T&gt;&gt;
    .Merge() // こちらも全て並行実行、SelectMany(xs =&gt; xs)と同じ
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1))
    .Merge(2) // 2件ずつ並行実行する(並行実行数の指定が可能)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));


new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1))
    .Concat() // 1件ずつ実行する(Merge(1)と同じ)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="200px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=2" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>ネストはSelectManyで一気に崩してしまうケースが一般的でしょうけれど、IObservable&lt;IObservable&lt;T&gt;&gt;といったネストした状態にすると、選択肢がSwitchもそうですが、更に、MergeとConcatを選択することができます。ちなみに、このintで並行実行数が指定可能なMergeはWP7同梱版のRxには存在しません。残念。(もう一つ余談ですが、SelectManyはRx内部ではSelect(selector).Merge()という実装になっていたりします)</p>
<h2>実行タイミングの問題</h2>
<p>上のSilverlight、Merge2とMerge2Exの二つを用意しましたが、Merge2Exのほうは4つ同時に表示されるのが確認出来るはずです。コードはほぼ同一なのですが、AsyncModokiを似たようで別なものに差し替えました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Merge(2):Ex
new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki2(x, 1)) // これが差分
    .Merge(2)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

// スレッドプール上で非同期実行(結果は指定秒数後に返る)のシミュレート
// second秒後にネットワーク問い合わせが返る、的なものをイメージしてみてください
static IObservable&lt;T&gt; AsyncModoki2&lt;T&gt;(T value, int second)
{
    var subject = new AsyncSubject&lt;T&gt;();

    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        Thread.Sleep(TimeSpan.FromSeconds(second)); // 指定秒数待機
        subject.OnNext(value);
        subject.OnCompleted(); // 完了（2つでワンセット）
    });

    return subject; // これ自体はすぐに返す(FromAsyncPatternの中身はこんな感じ)
}
</code></pre>
<p>このAsyncModoki2は、このメソッドを通ると即座にThreadPoolに送り込んで「実行」しています。Subscribeされるかどうかとは関係なく、Subscribeの「前に」。対してAsyncModokiはSubscribeされないと実行が開始されません。同じようで違う、この二つの状態をRxでは「Hot」と「Cold」と呼んで区別しています。HotはSubscribeとは関係なく動いているもの、イベントなんかはそうですね。ColdはSubscribeされて初めて動き出すもの、Observable.ReturnであったりRangeであったりと、Rxからの生成子の場合は、こちらのパターンが多いです。</p>
<p>実はFromAsyncPatternはHotなので、Subscribeとは関係なく即座に(といっても戻り値はFuncなのでInvokeしたら、ですが)非同期実行が開始されたりします。これは、あまり都合が良くなく（例えば上の例で見たように、MergeはSubscribeのタイミングによって実行数をコントロールしている）、Coldに変換したほうが扱いやすいです。そのためのメソッドがDefer。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IObservable&lt;WebResponse&gt; AsyncModoki3&lt;T&gt;(WebRequest req)
{
    return Observable.Defer(()=&gt;
        Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse,req.EndGetResponse)());
}
</code></pre>
<p>こちらのほうが、大抵の利用シーンにはマッチするかと思われます。</p>
<h2>キャンセル時のリソース処理の問題</h2>
<p>Switchは実に有意義なのですが、それの行っていることは、次の値を検知すると前の値をキャンセルする、ということです。普段はあまりキャンセルはしないと思うのですが、Switch内部では大量のキャンセルが発生しています。さて、どのような問題が発生するか、というと、例えば……。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Net;
using System.Reactive.Linq;

class Program
{
    static void Main(string[] args)
    {
        // ネットワークの最大接続数。通常、デフォルトは2になっているはず。
        ServicePointManager.DefaultConnectionLimit = 2;

        // テキストボックスのTextChangedイベントをイメージした、インクリメンタルサーチで来る文字列群
        new[] { &quot;w&quot;, &quot;wi&quot;, &quot;wik&quot;, &quot;wiki&quot;, &quot;wikip&quot;, &quot;wikipe&quot;, &quot;wikiped&quot;, &quot;wikipedi&quot;, &quot;wikipedia&quot; }
            .ToObservable()
            .Select((word, id) =&gt;
            {
                // wikipediaのAPIにリクエスト飛ばす
                var url = &quot;http://en.wikipedia.org/w/api.php?action=opensearch&amp;search=&quot; + word + &quot;&amp;format=xml&quot;;
                var req = (HttpWebRequest)WebRequest.Create(url);
                req.UserAgent = &quot;test&quot;;

                return Observable.FromAsyncPattern&lt;WebResponse&gt;((ac, state) =&gt;
                    {
                        Console.WriteLine(&quot;ASYNC START:&quot; + id);
                        return req.BeginGetResponse(ac, state);
                    }, ar =&gt;
                    {
                        Console.WriteLine(&quot;ASYNC END:&quot; + id);
                        return req.EndGetResponse(ar);
                    })()
                    .Select(res =&gt;
                    {
                        using (res) // ここのセクションが呼ばれることはない
                        {
                            Console.WriteLine(&quot;CALLED NEXT:&quot; + id);
                            return &quot;response string:&quot; + id;
                        }
                    });
            })
            .Switch()
            .ForEach(Console.WriteLine); // 終了を待機する形でのSubscribe
    }
}

// ConsoleApplication用のコードですが、是非実行してみてください。結果は以下のようになります。

ASYNC START:0
ASYNC START:1
ASYNC START:2
ASYNC START:3
ASYNC START:4
ASYNC START:5
ASYNC START:6
ASYNC START:7
ASYNC START:8
ASYNC END:0
ASYNC END:1
// そしてフリーズ...
</code></pre>
<p>これは、フリーズします。何故かというと、まず8件の非同期処理が一斉に開始されます(ASYNC STARTの表示)。一斉に開始はされますが、ネットワークの最大接続数は2なので、それ以外のものは内部的には待機されています。そして、Switchによる切り替えは最新のものだけを通すようにするため、7件はキャンセルされます。その後、最初の二件分のネットワークリクエストが終了し(ASYNC ENDの表示)、キャンセルされているためメソッドチェーンの続きであるSelectは呼ばれません。そして、フリーズ。</p>
<p>何故フリーズしてしまうかというと、EndGetResponseで取得した最初の二件のWebResponseが解放されていないためです。キャンセルが呼ばれなければ、Selectを通り、そこでusingにより利用+解放されるのですが、そのセクションを通らなければ何の意味がありません。使われることなく虚空に放り出されたWebResponseが、永遠にネットワーク接続を握ったままになってしまっています。</p>
<p>当然、大問題。</p>
<p>Switchを諦めてSelectMany(全件キャンセルせずに並行実行、どうせネットワーク自体の最大接続数で制限かかっているし)というのも手ではあります。大体の場合は結果は問題ないでしょう。けれど、Switchの利点は何でしたっけ、と。結果が前後しないことです。LINQを検索しようとしていたのに、検索結果が前後したせいでLINQ→LINの順番に結果が得られた結果、表示されるのがLINの結果では困ってしまいます。Switchなら、後に実行したものが必ず最後に来ると保証されるので、そのようなことにはなりません。反面、SelectManyは並行実行のため、前後する可能性が出てきます。Switchはこの例で挙げたような、インクリメンタルサーチのようなものと相性がとても良いんですね。</p>
<h2>ではどうするか？</h2>
<p>WebResponseのDispose(Close)を呼べれば解決するので、FromAsyncPatternのEnd部分に少し細工を加えてやる、ということが考えられます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなFromAsyncPatternを用意して
public static IObservable&lt;TResult&gt; SafeFromAsyncPattern&lt;TResult&gt;(Func&lt;AsyncCallback, object, IAsyncResult&gt; begin, Func&lt;IAsyncResult, TResult&gt; end)
    where TResult : IDisposable
{
    // WP7版ではCreateWithDisposableで(この辺の細かな差異が割とウザい)
    return Observable.Create&lt;TResult&gt;(observer =&gt;
    {
        var disposable = new BooleanDisposable();

        Observable.FromAsyncPattern&lt;TResult&gt;(begin, ar =&gt;
        {
            var result = end(ar);
            if (disposable.IsDisposed) result.Dispose(); // キャンセルされてたらDispose
            return result;
        })().Subscribe(observer);

        return disposable; // Disposeが呼ばれるとIsDisposedがtrueになる
    });
}

// こんな風に使うとか
public static IObservable&lt;WebResponse&gt; GetResponseAsObservable(this WebRequest req)
{
    return ObservableEx.SafeFromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse);
}
</code></pre>
<p>これにより、キャンセルされたかどうかをEnd部分で判定することが出来ます。よってEnd時にキャンセルされていたらリソースをDisposeしてしまう(ここでreturnしたオブジェクトは、チェーンは切れているので別に使われることなく虚空を彷徨うだけ)。これにより、FromAsyncPatternがリソースを返し、かつ、いつキャンセルされても問題なくなります。</p>
<p>他にも色々なアプローチが考えられます。CompositeDisposable/MutableDisposable/SingleAssignDisposableなどを使い、Disposeが呼ばれたら同時に管理下のリソースをDisposeしてしまう、といった手法。これは、リソースのDisposeされる瞬間が逆にコントロールしにくくなって、例えばWebResponseですと、その後のStreamを呼んでる最中にWebResponseがDisposeされてしまうなどの自体も起こりうるので、少し厄介に思えました。。リソースを後続に渡すまでは責任を持つ。それ以降はノータッチなので好きにやらせる、利用も解放も後続側が責任を。その方が自然だし、素直な動きになるので、いいかな。</p>
<p>他には、キャンセルを伝搬しないようなメソッドを作り、Disposeが呼ばれてもリソースを受け取れるようにし、後続でリソースをDisposeする、などの手段も考えられます。そうすればSafeFromAsyncPatternなどといった、独自のFromAsyncPatternを作る必要はなく、全てに適用できて汎用性は高いのですが、チェーンでの保証が途切れてしまうのが若干微妙かな、と……。この辺は悩ましいところです。</p>
<p>そもそもWebRequestなら、DisposeでAbortしてしまったほうが、キャンセルらしくていいかもしれない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IObservable&lt;WebResponse&gt; GetResponseAsObservable(this WebRequest request)
{
    return Observable.Create&lt;WebResponse&gt;(observer =&gt;
    {
        Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse,
            ar =&gt;
            {
                try
                {
                    return request.EndGetResponse(ar); // Abort後の場合は例外発生
                }
                catch (WebException ex)
                {
                    if (ex.Status == WebExceptionStatus.RequestCanceled) return null;
                    throw; // キャンセル時以外は再スロー
                }
            })()
            .Subscribe(observer);
        return () =&gt; request.Abort(); // Dispose時にこのActionが呼ばれる
    });
}
</code></pre>
<p>Disposeが呼ばれるとwebRequest.Abortが呼ばれます。その後にEndGetResponseを呼ぶとRequestCanceledなWebExceptionが発生するので、キャンセルされていたならnullを(どちらにせよ、Dispose済みなので、ここでreturnしたものは次のメソッドチェーンで使われることはない)、そうでない例外ならば再スローを、という方針です。悪くなさそうですが、どうでしょうか。私的にはこれを採用するのがベストかなー、と考え中です。</p>
<h2>まとめ</h2>
<p>SwitchやMergeなどで、従来扱いにくかった並行処理時の非同期のコントロールが簡単になりました。単純に一本の非同期をSelectManyで摩り替えるだけもアリですけれど、せっかくの多機能なのだから、並行にリクエストなどを飛ばして、より速いアプリケーション作りを目指してもいいかもしれません。同期リクエストをTask.Factory.StartNewで包んで振り回すよりかは、ずっと楽です。また、現在行われているMSのイベントBUILDで発表されたWinRTなどは、完全に非同期主体です。C#5.0でasync/awaitが入り、非同期がより扱いやすくなることで、それに併せてModelの有り様も、同期から非同期へと変わっていき、それにあわせてVMなどの書き方も変わってくるのではかと思われます。</p>
<p>ただ、リソースの問題にだけは気をつけて！上で挙げた問題は、本質的にはFromAsyncPatternに限らず、リソース処理が引き離されている場合の全てで該当します。リソースを扱うのは難しい。とはいえ、全面的に問題になるのは、このFromAsyncPatternぐらいな気はします。Observable.Usingなども用意されているので、不用意にリソースをチェーン間で渡したりしなければ原則的には起こらない。けれど、そのFromAsyncPatternこそがリソースを扱うシチュエーションで最も使われるものなんですよね、とほほほ。</p>
<p>キャンセル(Dispose)を不用意に呼ばなければ問題は起こらないといえば起こらないんですが(そのため、不適切に書いてしまっていても、多くのケースで問題が表面化することはないでしょう)、Switchのようなアプローチが取れなくなるのがどうにも。現状だと、とりあえず気をつけましょう、としか言いようがないので、気をつけましょう。もし何かうまい具合に動かないなあ、と思ったら、この辺を疑ってみると良いかもしれません。</p>
<p>その辺難しいなあ、という場合は、近いうちに私の出すRx拡張ライブラリを使いましょう。特に考えなくても済むよう、色々配慮してあります。いつ出るの？というと、はい、最近ゴリゴリと書いてますんで(ブログがちょっと放置気味だった程度には)、必ず近いうちに出します。</p>
</div>
<a href="https://neue.cc/15">Prev |</a>
<a href="https://neue.cc/17">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
