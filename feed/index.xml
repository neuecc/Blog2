<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>neue cc</title>
    <link>http://neue.cc/</link>
    <description>C# Technical Blog</description>
    <language>ja</language>
    <lastBuildDate>Mon, 05 May 2025 23:35:38 +0900</lastBuildDate>
    <item>
      <guid isPermaLink="true">https://neue.cc/2025/05/05_ZLinq.html</guid>
      <link>https://neue.cc/2025/05/05_ZLinq.html</link>
      <title>ゼロアロケーションLINQライブラリ「ZLinq」のリリースとアーキテクチャ解説</title>
      <description>&lt;h1 data-pagefind-sort="date:2025-05-05" data-pagefind-meta="published:2025-05-05"&gt;&lt;a href="https://neue.cc/2025/05/05_ZLinq.html"&gt;ゼロアロケーションLINQライブラリ「ZLinq」のリリースとアーキテクチャ解説&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2025-05-05&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ZLinq"&gt;ZLinq&lt;/a&gt; v1を先月リリースしました！structとgenericsベースで構築することによりゼロアロケーションを達成しています。またLINQ to Span, LINQ to SIMD, LINQ to Tree(FileSystem, JSON, GameObject, etc.)といった拡張要素と、任意の型のDrop-in replacement Source Generator。そして.NET Standard 2.0, Unity, Godotなどの多くのプラットフォームサポートまで含めた大型のライブラリとなっています！現在GitHub Starsも2000を超えました。&lt;/p&gt;
&lt;p&gt;https://github.com/Cysharp/ZLinq&lt;/p&gt;
&lt;p&gt;structベースのLINQそのものは珍しいものではなく、昔から多くの実装が挑戦してきました。しかし、真に実用的と言えるものはこれまでありませんでした。極度なアセンブリサイズの肥大化、オペレーターの網羅の不足、最適化不足で性能が劣るなど、実験的な代物を抜け切れていないものばかりでした。ZLinqでは実用的に使えるものを目指し、.NET 10(Shuffle, RightJoin, LeftJoinなど新しいものも含む)に含まれる全てのメソッドとオーバーロードの100%のカバーと、99%の挙動の互換性の確保、そしてアロケーションだけではなく、SIMD化も含めて、多くのケースにおける性能面で勝てるように実装しました。&lt;/p&gt;
&lt;p&gt;それが出来るのは、そもそも私のLINQ実装の経験はものすごく長くて、2009年4月に&lt;a href="https://github.com/neuecc/linq.js/"&gt;linq.js&lt;/a&gt;というJavaScript用のLINQ to Objectsライブラリを公開しています(linq.jsは現在もForkした人が今もメンテナンスされているようです、素晴らしい！)。他にもUnityで広く使われているReactive Extensionsライブラリ&lt;a href="https://github.com/neuecc/UniRx"&gt;UniRx&lt;/a&gt;を実装し、直近ではそれの進化版である&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;を公開したばかりです。バリエーションとしても&lt;a href="https://assetstore.unity.com/packages/tools/integration/linq-to-gameobject-24256"&gt;LINQ to GameObject&lt;/a&gt;、&lt;a href="https://github.com/neuecc/LINQ-to-BigQuery"&gt;LINQ to BigQuery&lt;/a&gt;、&lt;a href="https://github.com/Cysharp/SimdLinq/"&gt;SimdLinq&lt;/a&gt;といったものを作っていました。これらに、ゼロアロケーション関連ライブラリ(&lt;a href="https://github.com/Cysharp/ZString"&gt;ZString&lt;/a&gt;, &lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;)やハイパフォーマンスシリアライザー(&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/"&gt;MessagePack-CSharp&lt;/a&gt;, &lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;)の知見を掛け合わせることで、標準ライブラリの上位互換という野心的目標を達成できました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/raw/main/img/benchmarkhead.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;これはシンプルなベンチマークで、Where, Where.Take, Where.Take.Selectとメソッドチェーンを重ねれば重ねるほど、通常はアロケーションが増えていきますがZLinqはずっとゼロです。&lt;/p&gt;
&lt;p&gt;性能は元のソース、個数、値の型、そしてメソッドの繋げ方によって変わってきます。多くのケースで性能面で有利なことを確認するために、ZLinqでは様々なケースのベンチマークを用意し、GitHub Actions上で走らせています。&lt;a href="https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yml"&gt;ZLinq/actions/Benchmark&lt;/a&gt;。構造上どうしても負けてしまうケースも存在はするのですが、現実的なケースではほとんど勝っています。&lt;/p&gt;
&lt;p&gt;ベンチマーク上極端に差が出るものでいえば、シンプルにSelectを複数回繰り返したものは、SystemLinqもZLinqも特殊な最適化が入っていないケースになりますが、大きな性能差が出ています。&lt;/p&gt;
&lt;p&gt;| Method       | Mean       | Allocated |
|------------- |-----------:|----------:|
| LinqSelect1  | 1,114.4 μs |      49 B |
| LinqSelect2  | 1,831.7 μs |     193 B |
| LinqSelect3  | 5,639.8 μs |     342 B |
| LinqSelect4  | 8,896.9 μs |     492 B |
|              |            |           |
| ZLinqSelect1 |   624.4 μs |       1 B |
| ZLinqSelect2 |   780.4 μs |       1 B |
| ZLinqSelect3 | 1,247.6 μs |       1 B |
| ZLinqSelect4 | 1,248.8 μs |       1 B |&lt;/p&gt;
&lt;p&gt;シンプルなケースでは、DistinctやOrderByなど中間バッファを必要とするものは、積極的なプーリングによりアロケーションを大きく抑えているため、差が大きくなります(ZLinqは原則&lt;code&gt;ref strcut&lt;/code&gt;であり短寿命が期待できるため、プーリング利用はややアグレッシブにしています)。例えばこのベンチマークはDistinctです。&lt;/p&gt;
&lt;p&gt;| Method      | Mean     | Gen0   | Gen1   | Allocated |
|------------ |---------:|-------:|-------:|----------:|
| SystemLinq  | 67.52 μs | 3.4180 | 0.3662 |   58656 B |
|             |          |        |        |           |
| ZLinq       | 33.02 μs |      - |      - |      56 B |&lt;/p&gt;
&lt;p&gt;LINQはメソッド呼び出しのパターンにより特殊な最適化がかかるなど、アロケーションを抑えるだけでは性能面で常に勝てるわけではありません。そうしてオペレーターの繋がりによる最適化に関しても、これは.NET 9で最適化されたパターンとして&lt;a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/"&gt;Performance Improvements in .NET 9&lt;/a&gt;で紹介されている例ですが、ZLinqではそれらの最適化を全て実装し、より高いパフォーマンスを引き出しています。&lt;/p&gt;
&lt;p&gt;| Method                                   | Mean         | Gen0   | Allocated |
|----------------------------------------- |-------------:|-------:|----------:|
| DistinctFirst_SystemLinq                 |    22.638 ns | 0.0038 |      64 B |
| AppendSelectLast_SystemLinq              |    33.865 ns | 0.0067 |     112 B |
| RangeReverseCount_SystemLinq             |    22.420 ns | 0.0029 |      48 B |
| DefaultIfEmptySelectElementAt_SystemLinq |    19.283 ns | 0.0029 |      48 B |
| ListSkipTakeElementAt_SystemLinq         |    38.704 ns | 0.0057 |      96 B |
| RangeUnionFirst_SystemLinq               |    38.567 ns | 0.0067 |     112 B |
| SelectWhereSelectSum_SystemLinq          | 3,605.709 ns | 0.0076 |     168 B |
|                                          |              |        |           |
| DistinctFirst_ZLinq                      |    23.085 ns |      - |         - |
| AppendSelectLast_ZLinq                   |    21.665 ns |      - |         - |
| RangeReverseCount_ZLinq                  |     7.429 ns |      - |         - |
| DefaultIfEmptySelectElementAt_ZLinq      |    19.056 ns |      - |         - |
| ListSkipTakeElementAt_ZLinq              |    29.341 ns |      - |         - |
| RangeUnionFirst_ZLinq                    |    31.048 ns |      - |         - |
| SelectWhereSelectSum_ZLinq               | 1,260.455 ns |      - |         - |&lt;/p&gt;
&lt;p&gt;ZLinqの良いところとして、これらLINQの進化による最適化の恩恵を、最新の.NETだけではなく、全ての世代の.NET(.NET Frameworkも含む)が得られることでもあります。&lt;/p&gt;
&lt;p&gt;利用法はシンプルに、&lt;code&gt;AsValueEnumerable()&lt;/code&gt;呼び出しを追加するだけです。オペレーターに関しては100%網羅しているので、既存コードからの置き換えも全て問題なくコンパイルが通り、動作します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq;

var seq = source
    .AsValueEnumerable() // only add this line
    .Where(x =&amp;gt; x % 2 == 0)
    .Select(x =&amp;gt; x * 3);

foreach (var item in seq) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ZLinqでは挙動の互換性を保証するために、dotnet/runtimeのSystem.Linq.Testsを移植して &lt;a href="https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests"&gt;ZLinq/System.Linq.Tests&lt;/a&gt; 常に走らせています。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/blob/main/img/testrun.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;9000件のテストケースのカバーにより、動作を保証しています（Skipしているケースはref structであるため、同一テストコードを動かせない場合によるものなど）&lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;AsValueEnumerable()&lt;/code&gt; すら省略したDrop-In Replacementを任意で有効化するSource Generatorも提供しています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;[assembly: ZLinq.ZLinqDropInAttribute(&amp;quot;&amp;quot;, ZLinq.DropInGenerateTypes.Everything)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/blob/main/img/dropin.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;この仕組みにより、Drop-In Replacementの範囲を自由にコントロールすることができます。&lt;code&gt;ZLinq/System.Linq.Tests&lt;/code&gt;自体がDrop-In Replacementにより、既存テストコードを変えずにZLinqで動作するようになっています。&lt;/p&gt;
&lt;h2&gt;ValueEnumerableのアーキテクチャと最適化&lt;/h2&gt;
&lt;p&gt;使い方などはReadMeを参照してもらえればいいので、ここでは最適化の話を深堀します。ただたんなるシーケンスを遅延実行するだけ、ではないところが、アーキテクチャ上の特色であり、他の言語のコレクション処理ライブラリと比べても、多くの工夫が詰まっています。&lt;/p&gt;
&lt;p&gt;連鎖のベースとなる&lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;の定義はこうなっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public readonly ref struct ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;(TEnumerator enumerator)
    where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;, allows ref struct // allows ref structは.NET 9以上の場合のみ
{
    public readonly TEnumerator Enumerator = enumerator;
}

public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable
{
    bool TryGetNext(out T current); // as MoveNext + Current

    // Optimization helper
    bool TryGetNonEnumeratedCount(out int count);
    bool TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span);
    bool TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを基にして、例えばWhereなどのオペレーターはこうした連鎖が続きます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static ValueEnumerable&amp;lt;Where&amp;lt;TEnumerator, TSource&amp;gt;, TSource&amp;gt; Where&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Func&amp;lt;TSource, Boolean&amp;gt; predicate)
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;ではなくてこのようなアプローチを取ったのは、&lt;code&gt;(this TEnumerable source) where TEnumerable : struct, IValueEnumerable&amp;lt;TSource&amp;gt;&lt;/code&gt;のような定義にすると、&lt;code&gt;TSource&lt;/code&gt;への型推論が効かなくなります。これはC#が型引数の制約からは型推論をしないという言語仕様上の制限(&lt;a href="https://github.com/dotnet/csharplang/discussions/6930"&gt;dotnet/csharplang#6930&lt;/a&gt;)があるためで、もしそのような定義のまま実装をすると、インスタンスメソッドとして大量の組み合わせを定義することになります。それをやったのが&lt;a href="https://github.com/kevin-montrose/LinqAF"&gt;LinqA&lt;/a&gt;であり、その結果&lt;a href="https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/"&gt;100,000+ methods and massive assembly sizes&lt;/a&gt;ということで、あまり良い結果をもたらしていません。&lt;/p&gt;
&lt;p&gt;LINQにおいては実装は全て&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;側にあり、また、全てのEnumeratorはstructのため、&lt;code&gt;GetEnumerator()&lt;/code&gt;ではなくて、共通で&lt;code&gt;Enumerator&lt;/code&gt;のコピー渡しするだけで、それぞれのEnumeratorが独立したステートで処理できることに気付いたので、&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;を&lt;code&gt;ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt;でラップするだけ、という構成に最終的になりました。これにより型が制約側ではなくて型宣言側に現れるので、型推論での問題もありません。&lt;/p&gt;
&lt;h3&gt;TryGetNext&lt;/h3&gt;
&lt;p&gt;次にイテレートの本体であるMoveNextについて詳しく見ていきましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Traditional interface
public interface IEnumerator&amp;lt;out T&amp;gt; : IDisposable
{
    bool MoveNext();
    T Current { get; }
}

// iterate example
while (e.MoveNext())
{
    var item = e.Current; // invoke get_Current()
}

// ZLinq interface
public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable
{
    bool TryGetNext(out T current);
}

// iterate example
while (e.TryGetNext(out var item))
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C#の &lt;code&gt;foreach&lt;/code&gt; は &lt;code&gt;MoveNext() + Current&lt;/code&gt; に展開されるわけですが、問題が二点あります。一つはメソッド呼び出し回数で、イテレート毎にMoveNextとget_Currentの2回必要です。もう一つはCurrentのために、変数を保持する必要があること。そこで、それらを&lt;code&gt;bool TryGetNext(out T current)&lt;/code&gt;にまとめました。これによりメソッド呼び出し回数が一度で済みパフォーマンス上有利です。&lt;/p&gt;
&lt;p&gt;なお、この &lt;code&gt;bool TryGetNext(out T current)&lt;/code&gt; 方式は、例えば&lt;a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"&gt;Rustのイテレーター&lt;/a&gt;で採用されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-Rust"&gt;pub trait Iterator {
    type Item;
    // Required method
    fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変数の保持に関してはピンとこないと思うので、例としてSelectの実装を見てください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public sealed class LinqSelect&amp;lt;TSource, TResult&amp;gt;(IEnumerator&amp;lt;TSource&amp;gt; source, Func&amp;lt;TSource, TResult&amp;gt; selector) : IEnumerator&amp;lt;TResult&amp;gt;
{
    // フィールドが3つ
    IEnumerator&amp;lt;TSource&amp;gt; source = source;
    Func&amp;lt;TSource, TResult&amp;gt; selector = selector;
    TResult current = default!;

    public TResult Current =&amp;gt; current;

    public bool MoveNext()
    {
        if (source.MoveNext())
        {
            current = selector(source.Current);
            return true;
        }

        return false;
    }
}

public ref struct ZLinqSelect&amp;lt;TEnumerator, TSource, TResult&amp;gt;(TEnumerator source, Func&amp;lt;TSource, TResult&amp;gt; selector) : IValueEnumerator&amp;lt;TResult&amp;gt;
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
{
    // フィールドが2つ
    TEnumerator source = source;
    Func&amp;lt;TSource, TResult&amp;gt; selector = selector;

    public bool TryGetNext(out TResult current)
    {
        if (source.TryGetNext(out var value))
        {
            current = selector(value);
            return true;
        }

        current = default!;
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;は&lt;code&gt;MoveNext()&lt;/code&gt;で進めて&lt;code&gt;Current&lt;/code&gt;で返す、という都合上、&lt;code&gt;Current&lt;/code&gt;のフィールドが必要です。ところがZLinqでは進めると同時に値を返すため、フィールドに保持する必要がありません。これは、全体が&lt;code&gt;struct&lt;/code&gt;ベースで構築されているZLinqではかなり大きな違いがあります。ZLinqではメソッドチェーンの度に、以前のstructを丸ごと抱える(&lt;code&gt;TEnumerator&lt;/code&gt;がstruct)構造になるため、メソッドチェーンを重ねる度に構造体のサイズが肥大化していきます。常識的な範囲内でメソッドチェーンを重ねる限りは、パフォーマンス上も問題にはなっていなかったのですが、それでも小さければ小さいほどコピーコストが小さくなり性能面で有利にはなります。1バイトでも構造体を小さくする、ためにも&lt;code&gt;TryGetNext&lt;/code&gt;の採用は必然でした。&lt;/p&gt;
&lt;p&gt;TryGetNextの欠点は、共変・反変をサポートできないことです。ただし私は、そもそもイテレーターや配列から共変・反変のサポートは撤廃すべきだと思っています。&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;との相性が悪いため、メリット・デメリットを天秤にかけると、時代遅れの概念だと言えます。具体例を出すと、配列のSpan化は失敗する可能性があり、それはコンパイル時には検出できず実行時エラーとなります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// ジェネリクスの変性によりDerived[]をBase[]で受け取る。
Base[] array = new Derived[] { new Derived(), new Derived() };

// その場合、Span&amp;lt;T&amp;gt;へのキャストやAsSpan()は実行時エラーになる！
// System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.
Span&amp;lt;Base&amp;gt; foo = array;

class Base;
class Derived : Base;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;以前に追加された機能のため、もうどうにもならないとは思いますが、現代の.NETはあらゆるところでSpanが活用されるようになっているので、それが実行時エラーになる可能性をはらんでいる時点で、使い物にならないと考えてもいいはずです。&lt;/p&gt;
&lt;h3&gt;TryGetNonEnumeratedCount / TryGetSpan / TryCopyTo&lt;/h3&gt;
&lt;p&gt;全てを愚直に列挙するだけだと、パフォーマンスは最大化されません。例えばToArrayするときに、もしサイズの変動がないなら(&lt;code&gt;array.Select().ToArray()&lt;/code&gt;)、&lt;code&gt;new T[count]&lt;/code&gt;のように固定長配列を作ることができます。SystemLinqでも、そうした最適化を実現するために、内部的には&lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt;型が使われているのですが、引数は&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;のため、必ず &lt;code&gt;if (source is Iterator&amp;lt;TSource&amp;gt; iterator)&lt;/code&gt; のようなコードが必要になっています。&lt;/p&gt;
&lt;p&gt;ZLinqでは最初からLINQのための定義を前提にできるため、すべて織り込み済みで用意しています。ただし、むやみやたらに増やすのはアセンブリサイズの肥大化を招くため、必要最小限の定義で、最大限の効果を生み出すように調整したのが、この3つのメソッドとなっています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryGetNonEnumeratedCount(out int count)&lt;/code&gt;は、元のソースが有限の個数であり、途中にフィルタリング系メソッド(WhereやDistinctなど。TakeやSkipは算出可能なため含まない)が挟まらない場合は成功します。ToArrayなどのほか、OrderByやShuffleなど中間バッファが必要な時に効果が出るケースもあります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span)&lt;/code&gt;は、元ソースが連続的なメモリとして取得できる場合には、オペレーターによってはSIMDが適用されて劇的なパフォーマンス向上に繋がったり、Spanによるループ処理によって集計パフォーマンスが高まるなど、性能面で大きな違いをもたらす可能性があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset)&lt;/code&gt;は内部イテレーターによってパフォーマンスを向上させる仕組みです。外部イテレーターと内部イテレーターについて説明すると、例えば&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;は&lt;code&gt;foreach&lt;/code&gt;と&lt;code&gt;ForEach&lt;/code&gt;の両方が選べます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// external iterator
foreach (var item in list) { Do(item); }

// internal iterator
list.ForEach(Do);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;見た目は似ていますが、性能面で違いがあります。foreachは素直な構文で書けている。ForEachはデリゲート渡し。処理の実体まで分解すると&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// external iterator
List&amp;lt;T&amp;gt;.Enumerator e = list.GetEnumerator();
while (e.MoveNext())
{
    var item = e.Current;
    Do(item);
}

// internal iterator
for (int i = 0; i &amp;lt; _size; i++)
{
    action(_items[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これはデリゲート呼び出し(+デリゲート生成アロケーション)のオーバーヘッド vs イテレーターのMoveNext + Current呼び出しの対決になっていて、イテレート速度自体は内部イテレーターのほうが速い。この場合デリゲート呼び出しのほうが軽量な場合があり、ベンチマーク的に内部イテレーターのほうが有利な可能性があります。&lt;/p&gt;
&lt;p&gt;もちろん、ケースバイケースであることと、ラムダ式にキャプチャが発生したり、普通の制御構文が使えない(continueなど)ことから、私としては&lt;code&gt;ForEach&lt;/code&gt;は使うべきではないし、拡張メソッドで&lt;code&gt;ForEach&lt;/code&gt;のようなものを独自定義すべきではない、とも思っていますが、原理的にはこのような違いが存在します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset)&lt;/code&gt;は、デリゲートではなく&lt;code&gt;Span&lt;/code&gt;を受け取ることで限定的に内部イテレーター化しました。&lt;/p&gt;
&lt;p&gt;これもSelectを例に出すと、ToArrayの場合にCountが取れているとSpanを渡して内部イテレーターで処理します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public ref struct Select
{
    public bool TryCopyTo(Span&amp;lt;TResult&amp;gt; destination, Index offset)
    {
        if (source.TryGetSpan(out var span))
        {
            if (EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))
            {
                // loop inlining
                for (var i = 0; i &amp;lt; slice.Length; i++)
                {
                    destination[i] = selector(slice[i]);
                }
                return true;
            }
        }
        return false;
    }
}

// ToArray
if (enumerator.TryGetNonEnumeratedCount(out var count))
{
    var array = GC.AllocateUninitializedArray&amp;lt;TSource&amp;gt;(count);

    // try internal iterator
    if (enumerator.TryCopyTo(array.AsSpan(), 0))
    {
        return array;
    }

    // otherwise, use external iterator
    var i = 0;
    while (enumerator.TryGetNext(out var item))
    {
        array[i] = item;
        i++;
    }

    return array;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、SelectはSpanは作れませんが、元ソースがSpanを作れるなら、内部イテレーターとして処理することでループ処理を高速化することが可能です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo&lt;/code&gt;の定義は普通の&lt;code&gt;CopyTo&lt;/code&gt;と違って、&lt;code&gt;Index offset&lt;/code&gt;を持っています。また、destinationはソースサイズよりも小さいことを許しています（通常の.NETのCopyToはdestinationが小さいと失敗する)。これによって、destinationのサイズが1の場合、IndexによってElementAtが表現できます。そして0ならFirstだし^1の場合はLastになります。&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;自体に&lt;code&gt;First&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;を持たせると、クラス定義として無駄が多くなってしまいますが（アセンブリサイズにも影響が出る）、小さいdestinationとIndexを持たせることにより、一つのメソッドでより多くの最適化ケースをカバーできるようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static TSource ElementAt&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Index index)
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
{
    using var enumerator = source.Enumerator;
    var value = default(TSource)!;
    var span = new Span&amp;lt;T&amp;gt;(ref value); // create single span
    if (enumerator.TryCopyTo(span, index))
    {
        return value;
    }
    // else...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ところで、このTryGetNextや内部イテレーターに関しては、2007年の時点で &lt;a href="https://nyaruru.hatenablog.com/entry/20070818/p1"&gt;https://nyaruru.hatenablog.com/entry/20070818/p1&lt;/a&gt; で紹介されていました。この記事はずっと頭に残っていて、ようやくこうして20年経って理屈通りの実現ができました。という点でも少し感慨深いです。2008年前後はLINQ登場前後ということで、このあたりの話がアツかった時代なんですよねー。&lt;/p&gt;
&lt;h2&gt;LINQ to Span&lt;/h2&gt;
&lt;p&gt;ZLinqは .NET 9 以上であれば、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;に対しても、全てのLINQオペレーターを繋げることができます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq;

// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)
Span&amp;lt;int&amp;gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 };
var seq1 = span.AsValueEnumerable().Select(x =&amp;gt; x * x);

// If enables Drop-in replacement, you can call LINQ operator directly.
var seq2 = span.Select(x =&amp;gt; x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Span対応のLINQを謳ったライブラリも、世の中には多少ありますが、それらは&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;にだけ拡張メソッドを定義する、といったようなものであり、汎用的な仕組みではありませんでした。網羅されるオペレーターも制約があり、一部のものに限られていました。それは言語的にも&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;をジェネリクス引数として受け取ることができなかったためで、汎用的に処理できるようになったのは .NET 9で&lt;code&gt;allows ref struct&lt;/code&gt;が登場してくれたおかげです。&lt;/p&gt;
&lt;p&gt;ZLinqでは&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;と&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;に何の区別もありません、全て平等に取り扱われます。&lt;/p&gt;
&lt;p&gt;ただし、&lt;code&gt;allows ref struct&lt;/code&gt;の言語/ランタイムサポートが必要なため、&lt;code&gt;ZLinq自体は&lt;/code&gt;.NET Standard 2.0以上の全ての.NETをサポートしていますが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;対応に関してのみ.NET 9以上限定の機能となっています。また、これにより.NET 9以上の場合は、全てのオペレーターが&lt;code&gt;ref struct&lt;/code&gt;になっている、という違いがあります。&lt;/p&gt;
&lt;h2&gt;LINQ to SIMD&lt;/h2&gt;
&lt;p&gt;System.Linqでは、一部の集計メソッドがSIMDによって高速化されています。例えば一部のプリミティブ型の配列に直接SumやMaxを呼び出すと高速化されています。これらの呼び出しはforで処理するよりも遥かに高速化されます。とはいえ、&lt;code&gt;IEnumerbale&amp;lt;T&amp;gt;&lt;/code&gt;がベースであるため、適用可能な型が限定的であるなどの欠点を感じています。ZLinqでは&lt;code&gt;IValueEnumeartor.TryGetSpan&lt;/code&gt;によって&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;が取得できる場合が対象となるコレクションとなるため、より汎用的になっています（もちろん&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;に適用することもできます)。&lt;/p&gt;
&lt;p&gt;対応するメソッドは以下のようなものになっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeat&lt;/strong&gt; for &lt;code&gt;unmanaged struct&lt;/code&gt; and &lt;code&gt;size is power of 2&lt;/code&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sum&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SumUnchecked&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Average&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Min&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contains&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SequenceEqual&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sum&lt;/code&gt;はオーバーフローをチェックします。これは処理においてオーバーヘッドとなっているため、独自に&lt;code&gt;SumUnchecked&lt;/code&gt;というメソッドも追加しています。性能差は以下のようになり、Uncheckedのほうがより高速です。&lt;/p&gt;
&lt;p&gt;| Method            | N     | Mean          | Allocated |
|------------------ |------ |--------------:|----------:|
| ForLoop           | 16384 | 25,198.556 ns |         - |
| SystemLinqSum     | 16384 |  1,402.259 ns |         - |
| ZLinqSum          | 16384 |  1,351.449 ns |         - |
| ZLinqSumUnchecked | 16384 |    721.832 ns |         - |&lt;/p&gt;
&lt;p&gt;これらメソッドは条件がマッチした場合に暗黙的に適用されるということであり、SIMDを狙って適用させるには内部パイプラインへの理解が必要とされています。そこで&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;には&lt;code&gt;.AsVectorizable()&lt;/code&gt;というメソッドを用意しました。SIMD適用可能な&lt;code&gt;Sum&lt;/code&gt;, &lt;code&gt;SumUnchecked&lt;/code&gt;, &lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, and &lt;code&gt;SequenceEqual&lt;/code&gt;を明示的に呼び出すことができます（ただし&lt;code&gt;Vector.IsHardwareAccelerated &amp;amp;&amp;amp; Vector&amp;lt;T&amp;gt;.IsSupported&lt;/code&gt;ではない場合は通常の処理にフォールバックされるため、必ずしもSIMDが適用されることを保証するわけではありません）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;int&amp;gt;&lt;/code&gt;には&lt;code&gt;VectorizedFillRange&lt;/code&gt;というメソッドが追加されます。これは&lt;code&gt;ValueEunmerable.Range().CopyTo()&lt;/code&gt;と同じ処理で、連番で埋める処理がSIMDで高速化されます。連番が必要になる局面で、forで埋めるよりも遥かに高速なので、覚えておくといいかもしれません。&lt;/p&gt;
&lt;p&gt;| Method | Mean       | Allocated |
|------- |-----------:|----------:|
| For    | 6,228.9 ns |         - |
| Range  |   540.0 ns |         - |&lt;/p&gt;
&lt;h3&gt;Vectorizable Methods&lt;/h3&gt;
&lt;p&gt;SIMDによるループ処理を手書きするのは、慣れが必要で少し手間がいります。そこでFuncを引数に与えることでカジュアルに使えるヘルパーをいくつか用意しました。デリゲートを経由するオーバーヘッドが発生するためインラインで書くよりもパフォーマンスは劣りますが、カジュアルにSIMD処理できるという点では便利かもしれません。これらは引数に&lt;code&gt;Func&amp;lt;Vector&amp;lt;T&amp;gt;, Vector&amp;lt;T&amp;gt;&amp;gt; vectorFunc&lt;/code&gt;と&lt;code&gt;Func&amp;lt;T, T&amp;gt; func&lt;/code&gt;を受け取り、ループの埋められるところまで&lt;code&gt;Vector&amp;lt;T&amp;gt;&lt;/code&gt;で処理し、残りを&lt;code&gt;Func&amp;lt;T&amp;gt;&lt;/code&gt;で処理します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T[]&lt;/code&gt;, &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;には&lt;code&gt;VectorizedUpdate&lt;/code&gt;というメソッドが用意されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq.Simd; // needs using

int[] source = Enumerable.Range(0, 10000).ToArray();

[Benchmark]
public void For()
{
    for (int i = 0; i &amp;lt; source.Length; i++)
    {
        source[i] = source[i] * 10;
    }
}

[Benchmark]
public void VectorizedUpdate()
{
    // arg1: Vector&amp;lt;int&amp;gt; =&amp;gt; Vector&amp;lt;int&amp;gt;
    // arg2: int =&amp;gt; int
    source.VectorizedUpdate(static x =&amp;gt; x * 10, static x =&amp;gt; x * 10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;| Method           | N     | Mean       | Error    | StdDev  | Allocated |
|----------------- |------ |-----------:|---------:|--------:|----------:|
| For              | 10000 | 4,560.5 ns | 67.24 ns | 3.69 ns |         - |
| VectorizedUpdate | 10000 |   558.9 ns |  6.42 ns | 0.35 ns |         - |&lt;/p&gt;
&lt;p&gt;forよりも高速、ですが、パフォーマンスはマシン環境やサイズによって変わるので、盲目的に使うのではなくて、都度検証することをお薦めします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsVectorizable()&lt;/code&gt;には&lt;code&gt;Aggregate&lt;/code&gt;, &lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Select&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;が用意されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;source.AsVectorizable().Aggregate((x, y) =&amp;gt; Vector.Min(x, y), (x, y) =&amp;gt; Math.Min(x, y))
source.AsVectorizable().All(x =&amp;gt; Vector.GreaterThanAll(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);
source.AsVectorizable().Any(x =&amp;gt; Vector.LessThanAll(x, new(5000)), x =&amp;gt; x &amp;lt; 5000);
source.AsVectorizable().Count(x =&amp;gt; Vector.GreaterThan(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パフォーマンスは、データ次第ではありますが一例としてはCountで、このぐらいの差が出ることもあります。&lt;/p&gt;
&lt;p&gt;| Method            | Mean        | Error    | StdDev  | Allocated |
|------------------ |------------:|---------:|--------:|----------:|
| LinqCount         | 10,909.3 ns | 54.79 ns | 3.00 ns |         - |
| VectorizableCount |  1,048.4 ns | 39.39 ns | 2.16 ns |         - |&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Select&lt;/code&gt;, &lt;code&gt;Zip&lt;/code&gt;に関しては、後続に&lt;code&gt;ToArray&lt;/code&gt;か&lt;code&gt;CopyTo&lt;/code&gt;を選びます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Select
source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).ToArray();
source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).CopyTo(destination);

// Zip2
array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).CopyTo(destination);
array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).ToArray();

// Zip3
array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).CopyTo(destination);
array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).ToArray();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Zipなんかは結構面白い＆ちゃんと高速なので、使いどころあるかもしれません(2つのVec3のマージとか)。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;| Method                      | Mean      |
|---------------------------- |----------:|
| ZLinqZipCopyTo              | 329.43 μs |
| ZLinqZip3CopyTo             | 584.69 μs |
| ZLinqVectorizableZipCopyTo  |  24.17 μs |
| ZLinqVectorizableZip3CopyTo |  29.26 μs |
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;LINQ to Tree&lt;/h2&gt;
&lt;p&gt;皆さんLINQ to XMLを使ったことはありますか? LINQの登場した2008年は、まだまだXML全盛期で、LINQ to XMLのあまりにも使いやすいAPIには衝撃を受けました。しかし、すっかり時代はJSONでありLINQ to XMLを使うことはすっかりなくなりました。&lt;/p&gt;
&lt;p&gt;しかし、LINQ to XMLの良さというのは、ツリー構造に対するLINQ的操作のリファレンスデザインだと捉えることができます。ツリー構造がLINQになる、そのガイドライン。LINQ to Objectsと非常に相性の良い探索の抽象化。その代表例がRoslynのSyntaxTreeに対する操作で、AnalyzerやSource Generatorを書くのにDescendantsなどのメソッドを日常的に利用しています。&lt;/p&gt;
&lt;p&gt;そこでZLinqはそのコンセプトを拡張し、ツリー構造に対して汎用的に &lt;code&gt;Ancestors&lt;/code&gt;, &lt;code&gt;Children&lt;/code&gt;, &lt;code&gt;Descendants&lt;/code&gt;, &lt;code&gt;BeforeSelf&lt;/code&gt;, and &lt;code&gt;AfterSelf&lt;/code&gt; が適用できるインターフェイスを定義しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/blob/main/img/axis.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;これはUnityのGameObjectへの走査の図ですが、標準でFileSystem(DirectoryTreeはツリー構造)やJSON(System.Text.JsonのJsonNodeに対してLINQ to XML的な操作を可能にする)を用意しています。もちろん、任意にインターフェイスを実装することで追加することもできます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface ITraverser&amp;lt;TTraverser, T&amp;gt; : IDisposable
    where TTraverser : struct, ITraverser&amp;lt;TTraverser, T&amp;gt; // self
{
    T Origin { get; }
    TTraverser ConvertToTraverser(T next); // for Descendants
    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants
    bool TryGetChildCount(out int count);   // optional: optimize use for Children
    bool TryGetParent(out T parent); // for Ancestors
    bool TryGetNextChild(out T child); // for Children | Descendants
    bool TryGetNextSibling(out T next); // for AfterSelf
    bool TryGetPreviousSibling(out T previous); // BeforeSelf
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例えばJSONに対しては&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var json = JsonNode.Parse(&amp;quot;&amp;quot;&amp;quot;
// snip...
&amp;quot;&amp;quot;&amp;quot;);

// JsonNode
var origin = json![&amp;quot;nesting&amp;quot;]![&amp;quot;level1&amp;quot;]![&amp;quot;level2&amp;quot;]!;

// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.
foreach (var item in origin.Descendants().Select(x =&amp;gt; x.Node).OfType&amp;lt;JsonArray&amp;gt;())
{
    // [true, false, true], [&amp;quot;fast&amp;quot;, &amp;quot;accurate&amp;quot;, &amp;quot;balanced&amp;quot;], [1, 1, 2, 3, 5, 8, 13]
    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように書くことができます。&lt;/p&gt;
&lt;p&gt;Unityには&lt;code&gt;GameObject&lt;/code&gt;や&lt;code&gt;Transform&lt;/code&gt;、Godotには&lt;code&gt;Node&lt;/code&gt;へのLINQ to Treeを標準で用意しました。アロケーションや走査のパフォーマンスにかなり気を使って書かれているので、手動でループを回すよりも、もしかしたら高速かもしれません。&lt;/p&gt;
&lt;h2&gt;OSSと私&lt;/h2&gt;
&lt;p&gt;ここ数ヶ月で.NET関連のOSSには幾つか事件がありました。名のしれたOSSの商業ライセンス化、など……。私は、&lt;a href="https://github.com/Cysharp"&gt;github/Cysharp&lt;/a&gt;で出しているOSSの数は40を超え、個人やMessagePack organizationなどのものも含めると、総スター数では50000を超えるなど.NET周りのサードパーティーとしては最大規模でのOSS提供者なのではないかと思います。&lt;/p&gt;
&lt;p&gt;商業化、に関しては予定はありません、が、メンテナンスに関しては規模が大きくなってきたため、追いつかなくなっている面が多々あります。OSSが批判を覚悟で商業化を試みるの要因として、メンテナーに対する精神的な負荷というのが大きい（時間に対しての報酬が全く見合っていない）のですが、私も、まぁ、大変です！&lt;/p&gt;
&lt;p&gt;金銭面は置いておいて、お願い事としては、メンテナンスが滞ることがあることは多少受け入れて欲しい！今回のZLinqのような大きなライブラリを仕込んでいる最中は、集中する時間が必要なため、他のライブラリのIssueやPRへの応答が数ヶ月音信不通になります。意識的に全く見ないようにしています、タイトルすら見てません（ダッシュボードや通知のメールなども一切目にしないようにしています）。そうした不義理を働くことで創造的なライブラリを生み出すことができるのだ、これは必要な犠牲なのです……！&lt;/p&gt;
&lt;p&gt;また、そうじゃなくても、面倒見てるライブラリの数が多すぎるのでローテートでも数ヶ月の遅延が発生することは、あります。もうこれは絶対的なマンパワーが不足しているため、しょうがないじゃないですかー、というわけで、そのしょうがないを受け入れて、ちょっと返事が遅れるだけでthis library is dead的なこと言わないで欲しいなあ、というのが正直なところです！言われると辛い！なるべく努力はしたいんですが、特に新しいライブラリの創造は時間をめちゃくちゃ取られて大量の遅延が発生して、その遅延が更に遅延を呼んで泥沼になって精神を削っていくのですよー。&lt;/p&gt;
&lt;p&gt;あとはMicrosoft関連でイラッとさせられてモチベーションを削られるとか、この辺はC#関連のOSSあるあるが発生したりしたりしながらも、なるべく末永く続けていきたいとは思っています。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ZLinqの構造は最初のプレビュー版公開後のフィードバックで結構変わっていて、&lt;a href="https://github.com/Akeit0"&gt;@Akeit0&lt;/a&gt;さんにはコアとなる&lt;code&gt;ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt;という定義や&lt;code&gt;TryCopyTo&lt;/code&gt;への&lt;code&gt;Index&lt;/code&gt;の追加など、パフォーマンスに重要なコア部分の提案を多く頂きました！また、&lt;a href="https://github.com/filzrev"&gt;@filzrev&lt;/a&gt;さんからは多大なテスト・ベンチマークのインフラストラクチャーを提供してもらいました。互換性確保やパフォーマンス向上は、この貢献がなければ成しえませんでした。お二人には深く感謝します。&lt;/p&gt;
&lt;p&gt;改めて、ゼロアロケーションLINQライブラリというコンセプト自体はそこまで珍しいものでもなく、今までもライブラリが死屍累々と転がっていたわけですが、ZLinqは徹底度合いが違う。経験と知識があるうえで、精神論で気合で、全メソッド実装、テストケースも全部流して完全互換、最適化類もSIMD含めて全部実装する、をやり切ったのが立派なところなのではないかな、と。いや、ほんとこれめっちゃ大変だったのです……。&lt;/p&gt;
&lt;p&gt;タイミングとしても.NET 9/C# 13が、フルセットでやりたいことが全部やれる言語機能となったことは、やる気を後押ししてくれました。と、同時に、Unityや.NET Standard 2.0対応も大事にできたのもいいことです。&lt;/p&gt;
&lt;p&gt;ただのゼロアロケーションLINQというだけではなく、LINQ to Treeはお気に入りの機能なので是非使ってみて欲しいですね……！そもそもに元々は、10年前に作っていたLINQ to GameObjectをモダン化しよう、というのが出発点でした。昔のコードだったのでかなりベタ書きだったのですが、もうちょっと抽象化したほうがいいかな、と弄っているうちに、だったらゼロアロケーションLINQとしての抽象化まで進化させてしまったほうがいいのでは、という思いつきに至ったのでした。&lt;/p&gt;
&lt;p&gt;ところで、LINQのパフォーマンスのネックの一つとしてはデリゲートがあり、一部のライブラリはstructでFuncのようなものを模写するValueDelegateというアプローチがあるのですが、それはあえて採用していません。というのも、それらの定義はかなり手間なので、現実的にはやってられないはずです。そこまでやるなら普通にインラインで書いたほうがマシなので、LINQでValueDelegate構造を使う意味はありません。そんなベンチマークハックのためだけに内部構造の複雑化とアセンブリサイズの肥大化を招くのは無駄なので、System.Linqと互換のFuncのみを受け入れるスタイルにしています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;が.NET標準のSystem.Reactiveを置き換えるものという野心的ライブラリでしたが、System.Linqの置き換えはそれよりも遥かに大きな、あるいは大袈裟すぎる代物なので、採用に抵抗感はあるんじゃないかなー、と思います。ですが、置き換えるだけのメリットは掲示できていると思うので、是非とも試してみてくれると嬉しいです！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 05 May 2025 00:00:00 +0900</pubDate>
      <a10:updated>2025-05-05T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/30_year.html</guid>
      <link>https://neue.cc/2024/12/30_year.html</link>
      <title>2024年を振り返る</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-30" data-pagefind-meta="published:2024-12-30"&gt;&lt;a href="https://neue.cc/2024/12/30_year.html"&gt;2024年を振り返る&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-30&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;今年も&lt;a href="https://cysharp.co.jp/"&gt;Cysharp&lt;/a&gt;はちゃんと生存していて良きかな、というわけでサイトが相変わらずペライチなのでそろそろリニューアルしたいと思って幾星霜。&lt;/p&gt;
&lt;p&gt;そんなわけで今年もC#をやりこみ（？）していました……！&lt;/p&gt;
&lt;p&gt;新規:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Claudia"&gt;Claudia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StreamReader"&gt;Utf8StreamReader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大型アップデート&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework v5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C# v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MasterMemory"&gt;MasterMemory v3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;うーん、十分でしょ！割といつも年の中で浮き沈みはあって、調子でないなあ、ここ数ヶ月ダメだぁ、みたいな気持ちになることが割とあるのですが、振り返ってみれば十分すぎるでしょ！むしろやりすぎでしょ！というわけで、C#最前線キープとしては全く問題ないでしょう。&lt;/p&gt;
&lt;p&gt;ハイライトとしてはやはり年初の&lt;a href="https://neue.cc/2024/02/27_R3.html"&gt;R3 - C#用のReactive Extensionsの新しい現代的再実装&lt;/a&gt;ですかね……！これは、めちゃくちゃ大変でした。物量とかそのものの実装難易度とかもそうなのですが、スタンダードとなっているインターフェイスや仕様を変えるという判断を通しているんですよね。これが、ちゃんと成り立たせられるのか、それで普及させられるのか、という悩みもあり、また、インターフェイスも作りながら割とクルクル最後まで変えながらやってたので、完成して良かったし、1年弱経って、ちゃんと受け入れられているのを見てようやくホッと一息です。Unityにおいても、今年はNuGet化を強烈に推進していったわけですが、なんだかんだで受け入れてもらえってるような気がしますがどうでしょう……？&lt;/p&gt;
&lt;p&gt;Claudiaや、なんかブログに書く機会を逸して書いてない気がするのですがUtf8StreamReaderなんかも中々いい感じではあったと思います。&lt;/p&gt;
&lt;p&gt;そして大型アップデート系はSource Generator祭り。まず&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;は傑作かと！これは自信作ですねー、めちゃくちゃいいものが出来たと思ってます。直近の&lt;a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html"&gt;ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など&lt;/a&gt;で完全に仕上がりました。&lt;/p&gt;
&lt;p&gt;MessagePack for C#は長年懸案だったSource Generator化をついに果たしました。そして色々あって共同メンテナーが離脱したことにより、再度主導権が私の方に戻っています。この辺のことは思うところは割とあるのですが、まぁ結果的には良かったかな、と思ってます。再びやれることの幅も広がったので、&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;ともどもで来年は強化していきたいと思っています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://neue.cc/2024/12/20_mastermemory_v3.html"&gt;MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース&lt;/a&gt;も、ずっとSource Generator化したいと思って2年ぐらい放置していた案件なので、ようやく解消できて嬉しい話ですね。しかもやってたら想像通りにめちゃくちゃDX(Developer Experience)よくなってるので、やっと理想が実現できた、というかむしろ時代がやっと追いついた（なんせこの辺の仕組みはSource Generator以前に構築していたパターンなので）という気持ちです。&lt;/p&gt;
&lt;p&gt;Cysharpの提供しているライブラリから単独コードジェネレーターは消滅して全てSource Generator化し、そして&lt;a href="https://neue.cc/2024/01/15_shareprojectinunity.html"&gt;.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法&lt;/a&gt;でも書いたようにUnityとのコードシェアもかなりやりやすい手法が確立できたので、まさにこれはC#大統一理論元年……！「出来ない」よりは「出来たほうがいい」ので、別に今までのやり方が悪かったとは思いませんが、ようやく理想形に到達できた、という感じではあります。来年初頭にはMagicOnionのMessagePack for C# v3対応を出す予定で、これで全てのパーツが揃います！&lt;/p&gt;
&lt;h2&gt;なんとか of the Year&lt;/h2&gt;
&lt;p&gt;今年一番大きかった変化として、メモ環境に&lt;a href="https://obsidian.md/"&gt;Obsidian&lt;/a&gt;を全面導入したのですが、これは超絶良いですね。Daily Notesの有用性というのをようやく理解しました。有料課金して同期することで更に便利、プラグインもマシマシで便利、まぁ入れすぎてもしょうがないので適度に絞ってますよ、と思ったんですが、意外と結構はいってるかも……。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/f44a7f98-36b6-4699-8ab4-1158d5796f19" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/c4bc0d3e-7707-451b-ba6e-1cff03e31733" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;TODOもObsidianに寄せるようにしていますが、特にTODOプラグインなどは使わずにDaily Notesで表現できるように若干工夫しています（TemplaterでJavaScript書いてDaily Notesの生成時にチェック済みのTODOタスクは自動で消すようにしてる＆未チェックのTODOタスクは引き継ぐようにしている）。TODOアプリは無限に彷徨って毎年違うものに変えてたりするのですが、これが一番手に馴染んでるので決定版ということでいいかなー。&lt;/p&gt;
&lt;p&gt;もう一つ革命的に良かったと思うのは&lt;a href="https://consumer.huawei.com/jp/audio/freeclip/"&gt;HUAWEI FreeClip&lt;/a&gt;。これはとんでもなく良くてビックリした。HUAWEI製品のクオリティの高さにもビビッた。オープンイヤー型のイヤホンなわけですが、付け心地も良いし細かいところも良く出来てるし音質もしっかりしてる。言う事無し。オープンイヤーは、外音取り込みとは耳への圧迫感が自然さが全然違うんですよねえ、これだと1日中付けっぱなしとまではしないけど、割と頻繁に耳につけといて、音を聞くことが増えました。講演動画とか英語のリスニングとか日常生活に流せるといい感じ度が上がります。あとダラダラYouTube見る頻度が相当上がってしまった……。あまり使い分けとかは出来ないタイプの人間なので今まで使っていたAirPods Proはお蔵入りしてFreeClip一本使いになってます。ノイズキャンセリング性能がーというのと真逆なわけですが、外音と混じった音楽も、それはそれで心地よいのでいい感じなので、騒音環境下でもそこまで気にならず使えてる気がします。&lt;/p&gt;
&lt;p&gt;あとは、家のキーボードを&lt;a href="https://www.realforce.co.jp/products/series_rc1.html"&gt;Realforce RC1&lt;/a&gt;に変更しました。HHKBにF1-12キーが追加されたようなレイアウトなわけですが、まず、キーボードにF1-F12は必須なんですよね！Visual Studio的に！あとは、日本語キーボードレイアウトじゃないとダメ人間なので、ずっとコンパクト配列にしたいなあと思いつつも選択肢がなくてなあ、と、テンキーレスぐらいで我慢していたので、満を持しての本命というわけでした。&lt;/p&gt;
&lt;p&gt;それとFnキーとの組み合わせによるハードウェアキーレイアウト変更が柔軟かつ安定性が高いことに気づいた！昔から無変換＋ESDFを十字キーとして使う癖があって、AutoHotKeyなどソフトウェアでフックするやつを使って実現していたのですが、挙動的に不安定（抜けが出たりするのが辛い）なのが気になってました。が、Realforceの設定で無変換と変換をFnキーにしてしまって、Fnキーとの組み合わせでESDFを十字キーにしてしまえば完璧だった……！というわけで現在のレイアウトがこちら。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/4824b421-878d-42ee-8bd2-1c7dcc201a3d" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;そんなにキーボードから手を離さないで全部操作出来ないと！みたいな感じではなく、右手はマウス行きしちゃうので、左手側に詰め込みがちです。とにかくESDFでの十字キー化が安定したのがめっちゃ嬉しい。これ、WSDFじゃないんですか？というところなのですが、主に使うシチュエーションはテキストエディタでの十字移動なので、ESDFはホームポジションから手を動かさずに十字キーになるのがWSDFに比べての圧倒的利点です。それとQAZが空くので、そこにもキーを詰め込めるのも嬉しい。&lt;/p&gt;
&lt;p&gt;というわけでQ, AはHome/End(ちなみに私はHomeめちゃくちゃよく使います)。Z, CにShift + Home/End。XにShift + @(つまり```)。VにWin + V。それと1, 2, 3にはAlt + 1, 2, 3を入れています、というのも私は&lt;a href="https://arc.net/"&gt;Arc&lt;/a&gt;というブラウザを使っているのですが、これのスペースの切り替えがAltになっていて、AltよりもFn（元の無変換）を使うことが多いので、そのまま切り替えられるようにしたほうが便利かな、と。&lt;/p&gt;
&lt;p&gt;そしてFn + 半角/全角にCtrl + Shift + Alt + Eを割り当てて、これはWindowsのアプリケーションへのグローバルショートカットキーで&lt;a href="https://www.voidtools.com/"&gt;Everything&lt;/a&gt;を宛ててます。あまりキーをフックするようなのをソフトウェア側で仕込みたくはないのですが、Windows標準機能ならまぁ良いでしょう、ということで。&lt;/p&gt;
&lt;p&gt;マクロが欲しいとかショートカットキー登録数が少ないとか思うところもありますが、全体的にはかなり相当良いです！&lt;/p&gt;
&lt;p&gt;キーボードといえば、iPad Pro用に&lt;a href="https://www.logicool.co.jp/ja-jp/products/tablet-keyboards/keys-to-go2-apple.920-013030.html"&gt;logicool Keys-To-Go 2 for iPad&lt;/a&gt;を買ったのですが、これもかなり良くて体験変わりました。今までモバイルキーボード難民で全然しっくり来るものがなかったのですが、これが一番アリだなあ、という感じですね……！&lt;/p&gt;
&lt;p&gt;iPadには&lt;a href="https://www.amazon.co.jp/dp/B0972XHTRF"&gt;prendre タブレットスタンド iPad&lt;/a&gt;を貼り付けてキックスタンドにしてます。たった17g追加するだけで自立する！これは超便利。軽量化したとはいえ、重たいiPadなのでケースとか入れてこれ以上重たくしたくはない。が、自立してくれないと不便、で、色々探して買ったのがこれでした。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/9532238d-203b-4556-bf8e-4c0ccb9a38af" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;横はもちろん、縦でもちゃんと安定してくれる。粘着テープで貼り付けるタイプは剥がれる危険性があるわけですが、iPad Proが軽量化してくれたおかげもあってそこそこ安定しています。ただし両面テープは付属のは剥がして、色々試した結果&lt;a href="https://www.amazon.co.jp/dp/B00BPJLP3G"&gt;スリーエム(3M) 3M 両面テープ 超強力 スーパー多用途 薄手 幅12mm&lt;/a&gt;に落ち着きました。あまり強力すぎると、それはそれで剥がしにくくて売るときとかに泣いちゃう（本当に剥がれない……！）ので、粘着力が基本なのですが、その上でいざというときに剥がれてくれるかどうかのバランスも大事……。&lt;/p&gt;
&lt;p&gt;というわけかで&lt;a href="https://av.watch.impress.co.jp/docs/news/1589552.html"&gt;iPad Pro 13インチ&lt;/a&gt;も買ったのですが、これは満足感高いです。違いは、やっぱ有機ELディスプレイですかねー、今までのiPadの画質って割と不満足というか、どう見てもiPhoneよりも画質悪いじゃん！という感じで萎え萎えだった（のであまり使わなくなっていった……）のですが、今回の画質ならOKです！というわけで利用頻度上がりました。ちなみにNano-textureガラスではありません。いや、最初Nano-textureガラスのやつを買っちゃったんですが、これ普通に画質めちゃくちゃ悪いんですよ。インターネットマンが画質は大して変わらないとか言うから信じたのにめっちゃ悪くて……。耐えられなかったのですみませんがの返品からの買い直しコンボさせていただきました……。&lt;/p&gt;
&lt;p&gt;そして、&lt;a href="https://povo.jp/"&gt;povo&lt;/a&gt;。ずっとauだったのですが、povoに乗り換えました。で、これがめちゃくちゃいい、というかiPadでの利用にとてもいい。SIM付きモデル買ったのですが、auでのデータ共有がうまくできず（難易度高すぎ＆なんかバグってると思う……）塩漬けだったのです。が、povoで単独での契約だと、当たり前ですがスムーズに通信できて快適。iPadもテザリングがそこそこiPhoneとスムーズにつながるからなくてもいいじゃん、とか思ってなくもなかったのですが、単独で通信できる快適さはぜんぜん違う！そして、私の用途的に別にそんなに毎日通信するわけでもないので、あんまりギガはいらないんですが、povoだとプロモーションと合わせると実質0円運用できるのが、とてもいい感じです。例えばローソン500円購入券がpovoで500円で買えて0.3GBの通信料がついてくる、とかだと、どうせ500円買うんだしpovoで買ってiPadに0.3GBチャージしとくかあ、みたいな。&lt;/p&gt;
&lt;p&gt;最後に、Game of the Yearは今更グランツーリスモ7ということで（？）。というのもLogicoolの&lt;a href="https://gaming.logicool.co.jp/ja-jp/products/driving/pro-racing-wheel.html"&gt;PROレーシングホイール&lt;/a&gt; + PRO RACING PEDALSを買ったのですが、これが抜群にいい……！今まで(G923)とは桁違い、というか実際桁違いで、G923が2.4nmというフィードバック力しか出せていないのですが、PROレーシングホイール11nm出る！11nmって別に全くピンと来ないのですが、触ってみると2.4nmはスカスカで、逆に11nmをフルに出すと重くて曲げられないレベル（実際、筋肉痛になった……）。そんなわけで一気に楽しくなったので、今年は一番グランツーリスモ7をやってた気がします。はい。&lt;/p&gt;
&lt;h2&gt;来年&lt;/h2&gt;
&lt;p&gt;C#でSaaS作りたい欲求はずっとあるので、OSSメンテナンス業が重くのしかかりつつも、来年はそっち側でも進展を見せたいと思ってます……！Cysharpももう少し大きくしたいとは思っているので、引き続きよろしくおねがいします。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 30 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-30T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/20_mastermemory_v3.html</guid>
      <link>https://neue.cc/2024/12/20_mastermemory_v3.html</link>
      <title>MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-20" data-pagefind-meta="published:2024-12-20"&gt;&lt;a href="https://neue.cc/2024/12/20_mastermemory_v3.html"&gt;MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-20&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/MasterMemory"&gt;MasterMemory&lt;/a&gt; v3出しました！ついにSource Generator化されました！&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/e804fa52-f6a5-4972-a510-0b3b17a31230" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;MasterMemoryはC#のインメモリデータベースで、高速で、メモリ消費量が少なく、タイプセーフ。というライブラリです。SQLiteを素朴に使うよりも &lt;em&gt;4700&lt;/em&gt;倍高速だぞ、と。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61031896-61890800-a3fb-11e9-86b7-84c821d347a4.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;もともとMasterMemoryはC#コードからC#コードを生成するという、Source Generatorのなかった時代にSource Generatorのようなことをやる先進的な設計思想を持ったシステムでした。今回移植してみて、あまりにもスムーズに移植できるし、旧来のコードも全く手を付けずにそのまま動いたので我ながら感心しました。やっと時代が追い付いたか……。&lt;/p&gt;
&lt;p&gt;というわけで、以下のようなC#定義からデータベース構築のためのコードと、クエリ部分がSource Generatorによって自動生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MemoryTable(&amp;quot;person&amp;quot;), MessagePackObject(true)]
public record Person
{
    [PrimaryKey]
    public required int PersonId { get; init; }
    
    [SecondaryKey(0), NonUnique]
    [SecondaryKey(1, keyOrder: 1), NonUnique]
    public required int Age { get; init; }

    [SecondaryKey(2), NonUnique]
    [SecondaryKey(1, keyOrder: 0), NonUnique]
    public required Gender Gender { get; init; }

    public required string Name { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61035808-cb58e000-a402-11e9-9209-d51665d1cd56.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;C#コードとして生成されるので、クエリが全て入力補完も効くし戻り値も型付けされていてタイプセーフなのはもちろん、パフォーマンスの良さにも寄与しています。&lt;/p&gt;
&lt;p&gt;読み取り専用データベースとして使うので、クラス定義はイミュータブルのほうがいいわけですが、最近のC#は &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;required&lt;/code&gt; といった機能が提供されているので、Readonly Databaseとしての使い勝手が更に上がりました。Unityでは&lt;code&gt;required&lt;/code&gt;は使えませんが&lt;code&gt;record&lt;/code&gt;と&lt;code&gt;init&lt;/code&gt;は使えるので、Unityでも問題ありません。&lt;/p&gt;
&lt;p&gt;なお、Unity版は今回からNuGetForUnityでの提供となります。また、MessagePack for C#もSource Generator対応のv3を要求します。&lt;/p&gt;
&lt;h2&gt;Next&lt;/h2&gt;
&lt;p&gt;MasterMemory、実は結構使われています。ゲームでも採用されているものを割と見かけるようになりました。なので、外部ツール由来のコード生成の面倒さにはだいぶ心を痛めていたので、ようやく解消できて本当に嬉しい！&lt;/p&gt;
&lt;p&gt;v2からv3へのマイグレーションもそんなに大変ではない、はずです。あえて生成コードの品質や、コアの関数、メソッドシグネチャなどには一切手を加えていないので、今までコマンドラインツールを叩いていた部分を削除するだけで、そのまま動き出すぐらいの代物になっています。名前空間の設定だけ、アセンブリ属性で行ってください。&lt;/p&gt;
&lt;p&gt;そのうえでrecord対応（今までしてなかった！）や#nullable enable対応（今までしてなかった！）を追加しているので、生成部分以外の使い勝手も上がっているはずです。&lt;/p&gt;
&lt;p&gt;今後は&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;対応や、そもそものAPIの更なるモダン化（現状はnetstandard2.0なので古い）、全体的に改修したいところ(ImmutableBuilderなど生成コードの差し替え部分)、などなどやれること自体はめっちゃありますので、折を見て手を入れていけるといいかなあ、と思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-20T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</guid>
      <link>https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</link>
      <title>ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-16" data-pagefind-meta="published:2024-12-16"&gt;&lt;a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html"&gt;ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-16&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt; v5の比較的アップデートをしました！v5自体の詳細は以前に書いた&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;を参照ください。v5はかなり面白いコンセプトになっていて、そして支持されたと思っているのですが、幾つか使い勝手を犠牲にした点があったので、今回それらをケアしました。というわけで使い勝手がかなり上がった、と思います……！&lt;/p&gt;
&lt;h2&gt;名前の自動変換を無効にする&lt;/h2&gt;
&lt;p&gt;コマンドネームとオプションネームは、デフォルトでは自動的にkebab-caseに変換されます。これはコマンドラインツールの標準的な命名規則に従うものですが、内部アプリケーションで使うバッチファイルの作成に使ったりする場合などには、変換されるほうが煩わしく感じるかもしれません。そこで、アセンブリ単位でオフにする機能を今回追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;

[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]

var app = ConsoleApp.Create();
app.Add&amp;lt;MyProjectCommand&amp;gt;();
app.Run(args);

public class MyProjectCommand
{
    public void Execute(string fooBarBaz)
    {
        Console.WriteLine(fooBarBaz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]&lt;/code&gt;によって自動変換が無効になります。この例では &lt;code&gt;ExecuteCommand --fooBarBaz&lt;/code&gt; がコマンドとなります。&lt;/p&gt;
&lt;p&gt;実装面でいうと、Source Generatorにコンフィグを与えるのはAdditionalFilesにjsonや独自書式のファイル(例えばBannedApiAnalyzersのBannedSymbols.txt)を置くパターンが多いですが、ファイルを使うのは結構手間が多くて面倒なんですよね。boolの1つや2つを設定するぐらいなら、アセンブリ属性を使うのが一番楽だと思います。&lt;/p&gt;
&lt;p&gt;実装手法としては&lt;code&gt;CompilationProvider&lt;/code&gt;から&lt;code&gt;Assembly.GetAttributes&lt;/code&gt;で引っ張ってこれます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var generatorOptions = context.CompilationProvider.Select((compilation, token) =&amp;gt;
{
    foreach (var attr in compilation.Assembly.GetAttributes())
    {
        if (attr.AttributeClass?.Name == &amp;quot;ConsoleAppFrameworkGeneratorOptionsAttribute&amp;quot;)
        {
            var args = attr.NamedArguments;
            var disableNamingConversion = args.FirstOrDefault(x =&amp;gt; x.Key == &amp;quot;DisableNamingConversion&amp;quot;).Value.Value as bool? ?? false;
            return new ConsoleAppFrameworkGeneratorOptions(disableNamingConversion);
        }
    }

    return new ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion: false);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを他のSyntaxProviderからのSourceとCombineしてやれば、生成時に属性の値を参照できるようになります。&lt;/p&gt;
&lt;h2&gt;ConfigureServices/ConfigureLogging/ConfigureConfiguration&lt;/h2&gt;
&lt;p&gt;ゼロディペンデンシーを掲げている都合上、特定のライブラリに依存したコードを生成することができないという制約がConsoleAppFramework v5にはありました。そのため、DIとの統合時に自分でServiceProviderをビルドしなければならないなの、利用には一手間必要でした。そこで、NuGetでのDLLの参照状況を解析し、&lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;が参照されていると、&lt;code&gt;ConfigureServices&lt;/code&gt;メソッドが&lt;code&gt;ConsoleAppBuilder&lt;/code&gt;から使えるという実装を追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create()
    .ConfigureServices(service =&amp;gt;
    {
        service.AddTransient&amp;lt;MyService&amp;gt;();
    });

app.Add(&amp;quot;&amp;quot;, ([FromServices] MyService service, int x, int y) =&amp;gt; Console.WriteLine(x + y));

app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりフレームワークそのものはゼロディペンデンシーでありながら、ライブラリ依存のコードも生成することができるという、新しい体験を提供します。これは&lt;code&gt;MetadataReferencesProvider&lt;/code&gt;から引っ張ってきて生成処理に回すことで実現しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var hasDependencyInjection = context.MetadataReferencesProvider
    .Collect()
    .Select((xs, _) =&amp;gt;
    {
        var hasDependencyInjection = false;

        foreach (var x in xs)
        {
            var name = x.Display;
            if (name == null) continue;

            if (!hasDependencyInjection &amp;amp;&amp;amp; name.EndsWith(&amp;quot;Microsoft.Extensions.DependencyInjection.dll&amp;quot;))
            {
                hasDependencyInjection = true;
                continue;
            }

            // etc...
        }

        return new DllReference(hasDependencyInjection, hasLogging, hasConfiguration, hasJsonConfiguration, hasHost);
    });

context.RegisterSourceOutput(hasDependencyInjection, EmitConsoleAppConfigure);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参照の解析は複数のものに対して行っていて、他にも&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt;が参照されていれば&lt;code&gt;ConfigureLogging&lt;/code&gt;が使えるようになります。なので&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;と組み合わせれば&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: ZLogger
var app = ConsoleApp.Create()
    .ConfigureLogging(x =&amp;gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&amp;quot;log.txt&amp;quot;);
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject logger to constructor
public class MyCommand(ILogger&amp;lt;MyCommand&amp;gt; logger)
{
    public void Echo(string msg)
    {
        logger.ZLogInformation($&amp;quot;Message is {msg}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように、比較的すっきりと設定が統合できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appsettings.json&lt;/code&gt;から設定ファイルを引っ張ってくるというのも最近では定番パターンですが、これも&lt;code&gt;Microsoft.Extensions.Configuration.Json&lt;/code&gt;を参照していると&lt;code&gt;ConfigureDefaultConfiguration&lt;/code&gt;が使えるようになり、これは&lt;code&gt;SetBasePath(System.IO.Directory.GetCurrentDirectory())&lt;/code&gt;と&lt;code&gt;AddJsonFile(&amp;quot;appsettings.json&amp;quot;, optional: true)&lt;/code&gt;を自動的に行います（追加でActionでconfigureすることも可能、また、ConfigureEmptyConfigurationもあります）。&lt;/p&gt;
&lt;p&gt;なのでコンフィグを読み込んでクラスにバインドしてコマンドにDIで渡す、などといった処理もシンプルに書けるようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Configuration.Json
var app = ConsoleApp.Create()
    .ConfigureDefaultConfiguration()
    .ConfigureServices((configuration, services) =&amp;gt;
    {
        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions
        services.Configure&amp;lt;PositionOptions&amp;gt;(configuration.GetSection(&amp;quot;Position&amp;quot;));
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject options
public class MyCommand(IOptions&amp;lt;PositionOptions&amp;gt; options)
{
    public void Echo(string msg)
    {
        ConsoleApp.Log($&amp;quot;Binded Option: {options.Value.Title} {options.Value.Name}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt;でビルドしたい場合は、&lt;code&gt;ToConsoleAppBuilder&lt;/code&gt;が、これも&lt;code&gt;Microsoft.Externsions.Hosting&lt;/code&gt;を参照すると追加されるようになっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Hosting
var app = Host.CreateApplicationBuilder()
    .ToConsoleAppBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、今回から設定されている&lt;code&gt;IServiceProvider&lt;/code&gt;は&lt;code&gt;Run&lt;/code&gt;または&lt;code&gt;RunAsync&lt;/code&gt;終了後に自動的にDisposeするようになりました。&lt;/p&gt;
&lt;h2&gt;RegisterCommands from Attribute&lt;/h2&gt;
&lt;p&gt;コマンドの追加は&lt;code&gt;Add&lt;/code&gt;または&lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;が必要でしたが、クラスに属性を付与することで自動的に追加される機能をいれました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands]
public class Foo
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}

[RegisterCommands(&amp;quot;bar&amp;quot;)]
public class Bar
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらは自動で追加されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create();

// Commands:
//   baz
//   bar baz
app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらとは別に追加で&lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;することも可能です。&lt;/p&gt;
&lt;p&gt;なお、実装の当初予定では任意の属性を使えるようにする予定だったのですが、&lt;code&gt;IncrementalGenerator&lt;/code&gt;のAPIの都合上難しくて、固定の&lt;code&gt;RegisterCommands&lt;/code&gt;属性のみを対象としています。また、継承することもできません……。なので独自の処理用属性がある場合は、組み合わせてもらう必要があります。例えば以下のように。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands, Batch(&amp;quot;0 10 * * *&amp;quot;)]
public class MyCommands
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この辺は&lt;a href="https://qiita.com/omt_teruki/items/dae315c7e86722fe05e6"&gt;ConsoleAppFrameworkとAWS CDKで爆速バッチ開発&lt;/a&gt;を読んで、うーん、v5を使ってもらいたい！なんとかしたい！と思って色々考えたのですが、この辺が現状の限界でした……。名前変換オフりたいのもわかるー、とか今回の更新内容はこの記事での利用例を参考にさせていただきました、ありがとうございます！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;v5のリリース以降もフィルターを外部アセンブリに定義できるようになったり、Incremental Generatorの実装を見直して高速化するなど、Improvmentは続いています！非常に良いフレームワークに仕上がってきました！&lt;/p&gt;
&lt;p&gt;ところで&lt;a href="https://github.com/dotnet/command-line-api/"&gt;System.CommandLine&lt;/a&gt;、現状うまくいってないから&lt;a href="https://github.com/dotnet/command-line-api/issues/2338"&gt;Resettting System.CommandLine&lt;/a&gt;だ！と言ったのが今年の3月。例によって想像通り進捗は無です。知ってた。そうなると思ってた。何も期待しないほうがいいし、普通にConsoleAppFramework使っていくで良いでしょう。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-16T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/06_MessagePack_v3.html</guid>
      <link>https://neue.cc/2024/12/06_MessagePack_v3.html</link>
      <title>SourceGenerator対応のMessagePack for C# v3リリースと今後について</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-06" data-pagefind-meta="published:2024-12-06"&gt;&lt;a href="https://neue.cc/2024/12/06_MessagePack_v3.html"&gt;SourceGenerator対応のMessagePack for C# v3リリースと今後について&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-06&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;先月&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#プロジェクト&lt;/a&gt;は &lt;a href="https://dotnetfoundation.org/"&gt;.NET Foundation&lt;/a&gt;に参加しました！より安定した視点で利用していただけるという一助になればいいと思っています。&lt;/p&gt;
&lt;p&gt;そして、長く開発を続けていたメジャーバージョンアップ、v3がリリースされました。コア部分はv2とはほぼ変わらずですが、Source Generatorを全面的に導入しています。引き続きIL動的生成も存在するため、IL動的生成とSource Generatorのハイブリッドなシリアライザーとなります。v3にはSource GeneratorとAnalyzerがビルトインで同梱されていて、今までのコードはv3でコンパイルするだけで自動的にSource Generator化されます。v2 -&amp;gt; v3アップデートでSource Generator対応するために追加でユーザーがコードを記述する必要はありません！&lt;/p&gt;
&lt;p&gt;挙動を詳しく見ていきましょう。例えば、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MyTestClass
{
    [Key(0)]
    public int MyProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というコードを書くと、自動的に以下のコードがSource Generatorによって内部的に生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial class GeneratedMessagePackResolver
{
    internal sealed class MyTestClassFormatter : IMessagePackFormatter&amp;lt;MyTestClass&amp;gt;
    {
        public void Serialize(ref MessagePackWriter writer, MyTestClass value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.MyProperty);
        }

        public MyTestClass Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var ____result = new MyTestClass();

            for (int i = 0; i &amp;lt; length; i++)
            {
                switch (i)
                {
                    case 0:
                        ____result.MyProperty = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            reader.Depth--;
            return ____result;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、このGeneratedMessagePackResolverはデフォルトのオプション(StandardResolverなど)に最初から登録されているため、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static readonly IFormatterResolver[] DefaultResolvers = [
    BuiltinResolver.Instance,
    AttributeFormatterResolver.Instance,
    SourceGeneratedFormatterResolver.Instance, // here
    ImmutableCollection.ImmutableCollectionResolver.Instance,
    CompositeResolver.Create(ExpandoObjectFormatter.Instance),
    DynamicGenericResolver.Instance, // only enable for RuntimeFeature.IsDynamicCodeSupported
    DynamicUnionResolver.Instance];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザーコードのアセンブリに含まれているシリアライズ対象クラスは、Source Generatorによって生成されたコードが優先的に使われることになります。GeneratedMessagePackResolverは既定の名前空間や名前を変えたり、生成フォーマッターをmapベースに変更するなど、幾つかのカスタマイズポイントも用意されています。より詳しくは新しいドキュメントを見てください。また、v2 -&amp;gt; v3の変更箇所の詳細を知りたい人は&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/develop/doc/migrating_v2-v3.md"&gt;Migration Guide v2 -&amp;gt; v3&lt;/a&gt;をチェックしてください。&lt;/p&gt;
&lt;p&gt;Unityにおいては導入方法が大きく変わりました。コアライブラリは .NET 版と共通になりNuGetからのインストールが必要となります。そのうえでUPMでUnity用の追加コードをダウンロードする必要があります。詳しくは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/#unity-support"&gt;MessagePack-CSharp#unity-support&lt;/a&gt;のセクションを確認してください。&lt;/p&gt;
&lt;p&gt;.unitypackageの提供は廃止されています。また、IL2CPP対応のために要求していたmpcはなくなりました。完全にSource Generatorに移行されます。そのため、Unityのサポートバージョンは &lt;code&gt;2022.3.12f1&lt;/code&gt; からとなります。Source Generatorに関してはNuGetForUnityでのコアライブラリインストール時に自動的に有効化されるため、追加の作業は必要ありません。&lt;/p&gt;
&lt;h2&gt;History and Next&lt;/h2&gt;
&lt;p&gt;MessagePack for C#のオリジナル(v1)は私(Yoshifumi Kawai/@neuecc)によって、2017年にリリースしました。当時開発していたゲームのパフォーマンス問題を解決するために、2016年時点で存在していた(バイナリ)シリアライザーでは需要を満たせなかったため、パフォーマンスを最重要視したバイナリシリアライザーとして作成しました。合わせて、同じくネットワークシステムとして作成したgRPCベースのRPCフレームワーク&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;もリリースしています。&lt;/p&gt;
&lt;p&gt;v1リリース当時は&lt;code&gt;byte[]&lt;/code&gt;のみを対象としていましたが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;など、.NETには次々と新しいI/O系のAPIが追加されていったため、v2ではそれらに焦点を当てた新しいデザインが導入されました。この実装はMicrosoftのEngineerである&lt;a href="https://github.com/AArnott"&gt;Andrew Arnott / @AArnott&lt;/a&gt;氏によって主導され、リリースしています。&lt;/p&gt;
&lt;p&gt;以降、共同のメンテナンス体制として、そして私の個人リポジトリ(neuecc/MessagePack-CSharp)からオーガナイゼーション(MessagePack-CSharp/MessagePack-CSharp)して今に至ります。Visual Studio内部での利用や&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol"&gt;SignalRのバイナリープロトコル&lt;/a&gt;、Blazor Serverのプロトコルなど大きなMicrosoftのプロダクトでも使用され、GitHubでのスター数は.NETのバイナリーシリアライザーとしては最も大きなスターを集めています。&lt;a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-migration-guide/"&gt;.NET 9で廃止されたBinaryFormatter&lt;/a&gt;の移行先の一つとしても推奨されています。&lt;/p&gt;
&lt;p&gt;v3ではSource Generatorに対応することで、より高いパフォーマンスと柔軟性、AOT対応への第一段階に踏み出すことができました。&lt;/p&gt;
&lt;p&gt;MessagePack for C#プロジェクトは大きな成功を収めたと考えていますが、しかし現在、AArnott氏は個人の新しいMessagePackプロジェクトの開発を開始しています。私もその間、&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;という異なるフォーマットのシリアライザーをリリースしています。そのため、MessagePack for C#の今後と、その特性について、ある程度説明する必要があると思います。&lt;/p&gt;
&lt;p&gt;引き続きメンテナンス体制は2人だと考えていますが、アクティブな活動に関しては、再び私が担うことになるかもしれません。私はMessagePackとMemoryPackとでは異なる性質を持ったフォーマットであるため、どちらも重要であるという認識で動いています。オリジナルの実装であるMessagePack for C#も気に入ってますし、現在においても決して引けを取ることのないものだと思っています。&lt;/p&gt;
&lt;p&gt;AArnott氏の別のMessagePackシリアライザーとは根本的な哲学が若干異なります。その点で、私はそれはより良く改善されたシリアライザーではなく、別の個性のシリアライザーだと認識しています。そこで、違いについて説明させてください。&lt;/p&gt;
&lt;h2&gt;Binary spec, default settings and performance&lt;/h2&gt;
&lt;p&gt;シリアライザーのパフォーマンスに重要なのは、「仕様と実装」の両方です。例えばテキストフォーマットのJSONよりもバイナリフォーマットのほうが一般的には速いでしょう。しかし、よくできたJSONシリアライザーは、中途半端な実装のバイナリシリアライザーよりも高速です（私はそれを&lt;a href="https://github.com/neuecc/Utf8Json"&gt;Utf8Json&lt;/a&gt;というシリアライザーを作成することで実証したことがあります）。なので、仕様も大事だし、実装も大事です。どちらも兼ねることができれば、それがベストなパフォーマンスのシリアライザーとなります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://msgpack.org/"&gt;MessagePackのバイナリ仕様&lt;/a&gt;は &amp;quot;It's like JSON. but fast and small.&amp;quot; を標語にしている通り、JSONのバイナリ化としてあらわされています。ところが、MessagePack for C#のデフォルトは必ずしもJSON likeを狙っているわけではありません。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MsgPackSchema
{
    [Key(0)]
    public bool Compact { get; set; }
    [Key(1)]
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このクラスをシリアライズした場合は、JSONで表現すると&lt;code&gt;[true, 0]&lt;/code&gt;のようになります。これはオブジェクトをarrayベースでシリアライズしているからで、mapベースでシリアライズすると&lt;code&gt;{&amp;quot;Compact&amp;quot;:true,&amp;quot;Schema&amp;quot;:0}&lt;/code&gt;のような表現になります。&lt;/p&gt;
&lt;p&gt;arrayベースの利点は見た通りに、バイナリ容量として、よりコンパクトになります。容量がコンパクトなことは処理量が少なくなるためシリアライズの速度にも良い影響を与えます。また、デシリアライズにおいては、文字列を比較してデシリアライズするプロパティを探索する必要がなくなるため、より高速なデシリアライズ速度が期待できます。&lt;/p&gt;
&lt;p&gt;なお、arrayベースのシリアライズはMessagePackの仕様策定者である Sadayuki Furuhashi 氏によるリファレンス実装であるmsgpack-javaなどでも採用されているため、決して異端のやり方というわけではありません。&lt;/p&gt;
&lt;p&gt;MessagePack-CSharpではJSONライクなmapベースでシリアライズしたい場合は&lt;code&gt;[MessagePackObject(true)]&lt;/code&gt;と記述することができます。また、Source Generatorの場合はResolver単位でオーバーライドして強制的にmapベースにすることも可能です。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject(keyAsPropertyName: true)]
public class MsgPackSchema
{
    public bool Compact { get; set; }
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapの利点は、柔軟なスキーマエボリューションの実現と、他言語との疎通する際にコミュニケーションが取りやすいこと、バイナリそのものの自己記述性が高いことです。デメリットは容量とパフォーマンスへの悪影響、特にオブジェクトの配列においては一要素毎にプロパティ名が含まれることになってしまい、かなりの無駄となります。&lt;/p&gt;
&lt;p&gt;デフォルトをarrayにしているのは、コンパクトさとパフォーマンスの追求のためです。私はMessagePackをJSON likeの前に、高いパフォーマンスを実現可能なバイナリ仕様として考えました。もちろん、mapも重要なので、その上で比較的簡単にmapモードを実現するために属性に&lt;code&gt;(true)&lt;/code&gt;を追加するだけで可能にしました。&lt;/p&gt;
&lt;p&gt;arrayモードの場合はKey属性を全てのプロパティに付与する必要があります。これは、例えばProtocol Buffersなどでも数値タグを必要とするように、プロパティ名そのものをキーとするわけではなければ、必須だと考えています。もちろん、連番で自動採番させることも可能ですが、バイナリフォーマットのキーを暗黙的に処理するのはリスクが大きすぎる(順番を弄ったりするだけでバイナリ互換性が壊れることになる)と判断しています。つまり、明示的がデフォルト、ということです。大きなプロジェクト開発ではシニアメンバーからジュニアメンバーまでコードを触ることになるでしょう、全てを理解している人だけがコードを触るわけではありません。なので、暗黙的な挙動は避けるべきで、明示的にすべきだという強い意志で、この設計を選んでいます。&lt;/p&gt;
&lt;p&gt;ただしKeyを全てのプロパティに付与する作業はとても苦痛です(私はMessagePack-CSharp開発以前には、DataContractやprotobuf-netで辛い思いをしました)。そこで、Analyzer + Code Fixによって、自動的に付与する機能を用意しました。これにより明示的であることの苦痛は和らげられ、良いとこどりができているのだと考えています。&lt;/p&gt;
&lt;p&gt;別のMessagePackシリアライザーのデフォルトはmapのようです。これは&lt;a href="https://github.com/eiriktsarpalis/PolyType"&gt;PolyType&lt;/a&gt;というSource Generatorベースのライブラリ作成のための抽象化ライブラリがベースとしているためでもあり、また、そちらのほうを好んでいるという明示的な判断でもあるようです。&lt;/p&gt;
&lt;p&gt;「デフォルト」はライブラリで一つしか選べません。どちらのモードで処理することができたとしても、「デフォルト」はただ一つです。改めて言うと、私はバイナリフォーマットとしての「コンパクトとパフォーマンス」を好み、優先しています。&lt;/p&gt;
&lt;p&gt;皆さんはPolyTypeについて初めて知ったかもしれません。私はPolyTypeはあまり好意的には考えていません。ちょっとしたものを作るには非常に便利だとは思いますが、ベストなパフォーマンスを狙ったり、ベストなアイディアを表現するには、抽象層であることの制限が大きすぎると考えています。なので、MessagePack for C#で採用することはありませんし、他の何かを作る際にも採用することはないでしょう。&lt;/p&gt;
&lt;h2&gt;Unity(multiplatform) Support&lt;/h2&gt;
&lt;p&gt;MessagePack for C#ではv1の時代からゲームエンジンUnityの1st classのサポートを実行してきました。これは私が&lt;a href="https://en.wikipedia.org/wiki/Cygames"&gt;Cygames&lt;/a&gt;という日本のゲーム会社の関連会社(&lt;a href="https://cysharp.com/"&gt;Cysharp&lt;/a&gt;)のCEOを務めていて、ビデオゲームインダストリーと関係性が深いという都合もあります。自分たちで実際にUnityで動くものを作り、使ってきました。もちろん、サーバーサイドやデスクトップアプリケーションでも使っています。&lt;/p&gt;
&lt;p&gt;UnityにはIL2CPPという独自のAOTシステムがあり、特にiOSなどモバイルプラットフォームでのリリースには必須なのですが、それもSource Generatorが存在しなかった時代から、mpcというRoslynを使ったコードジェネレートツールを作り、提供してきました。数百のモバイルゲームでMessagePackが使われているのは、これら私の熱心なサポートのお陰といっても過言ではないでしょう。v3ではついにSource Generatorベースになったことにより、ワークフローが大きく簡易化されることとなります！&lt;/p&gt;
&lt;p&gt;一般的に、.NETコミュニティにおいてはUnityサポートはかなり軽視されていました。また、外から見ているとMicrosoftやMicrosoftの従業員もそのようで、自社のプラットフォーム以外への関心は薄そうです。こうした態度は、あまり好ましいとは思っていませんし、せっかくの .NET の可能性を狭めていることにもなっています。Xamarinがうまく成長軌道に乗らなかったのも、そのようなMicrosoft自体の冷たい視線のせいだとも思っています。&lt;/p&gt;
&lt;p&gt;私は、私の作るライブラリはなるべくUnityにもしっかり対応できるように気を付けて作っています（最新は新しいReactive Extensionsライブラリーである&lt;a href="https://github.com/Cysharp/R3"&gt;Cysharp/R3&lt;/a&gt;）。別のMessagePackシリアライザーに関しては、あまりしっかりした対応はされなさそうですが……。&lt;/p&gt;
&lt;h2&gt;Beyond v3&lt;/h2&gt;
&lt;p&gt;v3のNative AOT Supportは完全ではありません。Source Generatorにするだけでは完全なNative AOT対応とはならないのは難しいところです。これはUnityのAOTであるIL2CPPでは完璧に動作しているだけに、正直不可解なことでもあり、また、Microsoftのよくない癖が出ているな、とも思っています。つまり、完璧な対応をするために、複雑なものを提供している。それが現在のNative AOTです。複雑怪奇な属性やフローは、理解できるところもありますが、もう少し簡略化すべきだったと思います。まぁ、もう修正されることもないのでしょうが……。&lt;/p&gt;
&lt;p&gt;パフォーマンス面でもv1からv2で退化してしまった点もあるので、最新の知見を元に、実装面での改善を施す必要があります。特にReadOnlySequenceの利用幅が大きいことは、かなりの制約を生み出していて、不満があります。&lt;/p&gt;
&lt;p&gt;.NET 9でPipeReader/PipeWriterが標準化されたことによる、より良い非同期APIや、パフォーマンスを両立したストリーミング対応というのも、大きなトピックとなるかもしれません。&lt;/p&gt;
&lt;p&gt;MessagePack for C#は広く使われているが故に、破壊的変更はしづらいし、互換性の維持は最重要トピックスです。しかし、世の中が変わっていく以上、進化しないことを選んだら、それは滅びる道でしかありません。やれることはまだまだあると思っていますので、.NETにおける最先端の、最高のバイナリシリアライザーであり続けたいと思っています（&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;もね……！)&lt;/p&gt;
&lt;p&gt;まずは、v3のSource Generatorをぜひ試してみてください。皆の力でより良いものを作っていけるというのも、OSSの良さだと思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 06 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-06T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/03_SharpFuzz.html</guid>
      <link>https://neue.cc/2024/12/03_SharpFuzz.html</link>
      <title>Fuzzing in .NET: Introducing SharpFuzz</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-03" data-pagefind-meta="published:2024-12-03"&gt;&lt;a href="https://neue.cc/2024/12/03_SharpFuzz.html"&gt;Fuzzing in .NET: Introducing SharpFuzz&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-03&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;この記事は&lt;a href="https://qiita.com/advent-calendar/2024/csharplang"&gt;C# Advent Calendar 2024&lt;/a&gt;に参加しています。また、先月開催された&lt;a href="https://dotnetnew.connpass.com/event/335955/"&gt;dotnet new&lt;/a&gt;というイベントでの発表のフォローアップ、のつもりだったのですがコロナ感染につき登壇断念……。というわけで、セッション資料はないので普通にブログ記事とします！&lt;/p&gt;
&lt;h2&gt;dotnet/runtime と Fuzzing&lt;/h2&gt;
&lt;p&gt;今年に入ってからdotnet/runtimeにFuzzingテストが追加されています。&lt;a href="https://github.com/dotnet/runtime/tree/main/src/libraries/Fuzzing"&gt;dotnet/runtime/Fuzzing&lt;/a&gt;。というわけで、実はfuzzingは非常に最近のトピックスなのです……！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0"&gt;ファジング&lt;/a&gt;とはなんなのか、ザックリとはランダムな入力値を大量に投げつけることによって不具合や脆弱性を発見するためのテストツールです。エッジケースのテスト、やはりどうしても抜けちゃいがちだし、ましてや脆弱性になりうる絶妙な不正データを人為的に作るのも難しいので、ここはツール頼みで行きましょう。&lt;/p&gt;
&lt;p&gt;Goでは1.18(2022年)から標準でgo fuzzコマンドとして追加されたらしいので、
&lt;a href="https://future-architect.github.io/articles/20220214a/"&gt;Go1.18から追加されたFuzzingとは&lt;/a&gt;のような解説記事を読むのもイメージを掴みやすいです。&lt;/p&gt;
&lt;p&gt;さて、dotnet/runtimeのFuzzingでは現状&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AssemblyNameInfoFuzzer&lt;/li&gt;
&lt;li&gt;Base64Fuzzer&lt;/li&gt;
&lt;li&gt;Base64UrlFuzzer&lt;/li&gt;
&lt;li&gt;HttpHeadersFuzzer&lt;/li&gt;
&lt;li&gt;JsonDocumentFuzzer&lt;/li&gt;
&lt;li&gt;NrbfDecoderFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesByteCharFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesStringFuzzer&lt;/li&gt;
&lt;li&gt;TextEncodingFuzzer&lt;/li&gt;
&lt;li&gt;TypeNameFuzzer&lt;/li&gt;
&lt;li&gt;UTF8Fuzzer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というのものが用意されてます。わかるようなわからないような。だいたいデータのパース系によく使われるものなので、その通りのところに用意されています。一番わかりやすいJsonDocumentFuzzerを見てみましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal sealed class JsonDocumentFuzzer : IFuzzer
{
    public string[] TargetAssemblies { get; } = [&amp;quot;System.Text.Json&amp;quot;];
    public string[] TargetCoreLibPrefixes =&amp;gt; [];
    public string Dictionary =&amp;gt; &amp;quot;json.dict&amp;quot;;

    // fuzzerからのランダムなバイト列が入力
    public void FuzzTarget(ReadOnlySpan&amp;lt;byte&amp;gt; bytes)
    {
        if (bytes.IsEmpty)
        {
            return;
        }

        // The first byte is used to select various options.
        // The rest of the input is used as the UTF-8 JSON payload.
        byte optionsByte = bytes[0];
        bytes = bytes.Slice(1);

        var options = new JsonDocumentOptions
        {
            AllowTrailingCommas = (optionsByte &amp;amp; 1) != 0,
            CommentHandling = (optionsByte &amp;amp; 2) != 0 ? JsonCommentHandling.Skip : JsonCommentHandling.Disallow,
        };

        using var poisonAfter = PooledBoundedMemory&amp;lt;byte&amp;gt;.Rent(bytes, PoisonPagePlacement.After);

        try
        {
            // それをParseに投げて、もし不正な例外が来たらなんかバグっていたということで
            JsonDocument.Parse(poisonAfter.Memory, options);
        }
        catch (JsonException) { }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ようは想定外のデータ入力で&lt;code&gt;JsonDocument.Parse&lt;/code&gt;が失敗しないことを祈る、といったものですね。正常に認識しているinvalidな値なら&lt;code&gt;JsonException&lt;/code&gt;をthrowするはずですが、&lt;code&gt;ArgumentException&lt;/code&gt;とか&lt;code&gt;StackOverflowException&lt;/code&gt;とかが出てきちゃった場合は認識できていない不正パターンなので、ちゃんとしたハンドリングが必要になってきます。&lt;/p&gt;
&lt;p&gt;では、これを参考にやっていきましょう、とはなりません。えー。まず、dotnet/runtimeのFuzzingではSharpFuzz, libFuzzer, そしてOneFuzzが使用されていると書いてあるのですが、OneFuzzはMicrosoft内部ツールなので外部では使用できません。正確には&lt;a href="https://www.publickey1.jp/blog/20/project_onefuzzwindowsmicorosoft_edge.html"&gt;2020年にオープンソース公開&lt;/a&gt;したものの、&lt;a href="https://github.com/microsoft/onefuzz"&gt;2023年にはクローズドに戻している&lt;/a&gt;状態です。まぁ事情は色々ある。しょーがない。&lt;/p&gt;
&lt;p&gt;というわけで、これはMicrosoft内部で動かすためのOneFuzzや、dotnet/runtimeで動かすために調整してある&lt;code&gt;IFuzzer&lt;/code&gt;といったフレームワーク部分が含まれているので、小規模な自分たちのコードをfuzzingするにあたっては、不要ですし、ぶっちゃけあまり参考にはなりません！解散！&lt;/p&gt;
&lt;h2&gt;Introducing SharpFuzz&lt;/h2&gt;
&lt;p&gt;そんなわけでdotnet/runtimeのFuzzingでも使われている&lt;a href="https://github.com/Metalnem/sharpfuzz"&gt;Metalnem/sharpfuzz: AFL-based fuzz testing for .NET&lt;/a&gt;を直接使っていきます。sharpfuzzは&lt;a href="https://lcamtuf.coredump.cx/afl/"&gt;afl-fuzz&lt;/a&gt;と連動して動くように作られている .NETライブラリです。3rd Partyライブラリですが作者はMicrosoftの人です（dotnet/runtimeで採用されている理由でもあるでしょう）。ReadMeのTrophiesでは色々なもののバグを見つけてやったぜ、と書いてあります。AngleSharpとかGoogle.ProtobufとかGraphQL-ParserとかMarkdigとかMessagePack for C#とImageSharpとか。まぁ、やはり用途としてはパーサーのバグを見つけるのには適切、という感じです。&lt;/p&gt;
&lt;p&gt;AFL(American Fuzzy Lop)ってなに？ということなのですが、そもそもファジングの「ランダムな入力値を大量に投げつける」行為は、完全なランダムデータを投げつけていくわけではありません。完全ランダムだとあまりにも時間がかかりすぎるため、脆弱性発見において実用的とは言えない。そこでAFLはシード値からのミューテーションと、カバレッジをトレースしながら効率よくデータを生成していきます。Wikipediaから引用すると&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;テスト対象のプログラム（テスト項目）のソースコードをインストルメント化することにより、afl-fuzzは、ソフトウェアのどのブロックが特定のテスト刺激で実行されたかを後で確認できる。そのため、AFLはグレーボックステストに使用することができる。遺伝的手法による検査データの生成に関連して、ファザーはテストデータをより適切に生成できるため、このメソッドを使用しない他のファザーよりも、処理中に以前は使用されていなかったコードブロックが実行される。その結果、コードカバレッジは比較的短い時間で比較的高い結果が得られる。この方法は、生成されたデータ内の構造を独立して（つまり、事前の情報なしで）生成することができる。このプロパティは、テストカバレッジの高いテストコーパス（テストケースのコレクション）を生成するためにも使用される。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;というわけでdotnet testのようにテストコードを渡したら全自動でやってくれる、というほど甘くはなくて、多少の下準備が必要になってきます。SharpFuzzは一連の処理をある程度やってくれるようにはなっていますが、そもそもに実行までに二段階の処理が必要になっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharpfazzコマンド(dotnet tool)でdllにトレースポイントを注入する&lt;/li&gt;
&lt;li&gt;その注入されたdll(とexe)をネイティブのfuzzing実行プロセス(afl-fuzzなど)に渡す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dllにトレースポイントを注入はお馴染みの&lt;a href="https://github.com/jbevain/cecil"&gt;Cecil&lt;/a&gt;でビルド済みのDLLのILを弄ってトレースポイントを仕込みます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/c3b43b60-8526-44cd-8482-6f1185206b65" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これは注入済みのdllですが、Trace.SharedMemとかTrace.PrevLocationとか、分岐点に対して明らかに注入している様が見えます。そうしたトレースポイントとの通信や実行データ生成などは外部プロセスが行うので、SharpFuzzというライブラリは、それ自体は実行ツールではなくて、それらとの橋渡しをするためのシステムということです。&lt;/p&gt;
&lt;p&gt;ではやっていきましょう！色々なシステムが絡んでくる分、ちょっとややこしく面倒くさいのと、ReadMeの例をそのままやると罠が多いので、少しアレンジしていきます。&lt;/p&gt;
&lt;p&gt;まずはRequirementsですが、実行機であるAFLがWindowsでは動きません(Linux, macOSでは動く)。なのでWSL上で動かしましょうという話になってくるのですが、それはあんまりにもやりづらいので、&lt;a href="https://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt;というLLVMが開発しているAFL互換のFuzzingツールを使っていくことにします。これはWindowsでビルドできます。&lt;/p&gt;
&lt;p&gt;自分でビルドする必要はなく、SharpFuzzの作者が連携して使うことを意識して用意してくれている&lt;a href="https://github.com/Metalnem/libfuzzer-dotnet/releases"&gt;libfuzzer-dotnetのReleasesページ&lt;/a&gt;から、バイナリを直接落としてきましょう。&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;次に、IL書き換えを行うツール&lt;code&gt;SharpFuzz.CommandLine&lt;/code&gt;を .NET toolで入れていきましょう。これはglobalでいいかな、と思います。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet tool install --global SharpFuzz.CommandLine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、今回は&lt;a href="https://github.com/kevin-montrose/Jil"&gt;Jil&lt;/a&gt;という、今はもうあまり使われることもないJsonシリアライザーをターゲットとしてやっていこうということなので、JilとSharpFuzzをインストールします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet add package Jil --version 2.15.4
dotnet add package SharpFuzz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで注意が必要なのは、Jilの最新バージョンはSharpFuzzにより発見されたバグが修正されているので、最新版を入れるとチュートリアルにはなりません！というわけでここは必ずバージョン下げて入れましょう。&lt;/p&gt;
&lt;p&gt;新規のConsoleApplicationで、コードは以下のようにします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;
using SharpFuzz;

// 実行機としてlibFuzzerを使う(引数はReadOnlySpan&amp;lt;byte&amp;gt;)
Fuzzer.LibFuzzer.Run(span =&amp;gt;
{
    try
    {
        using var stream = new MemoryStream(span.ToArray());
        using var reader = new StreamReader(stream);
        JSON.DeserializeDynamic(reader); // このメソッドが正しく動作してくれるかをテスト
    }
    catch (Jil.DeserializationException)
    {
        // Jil.DeserializationExceptionは既知の例外（正しくハンドリングできてる）なので握り潰し
        // それ以外の例外が発生したらルート側にthrowされて問題が検知される
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今度はベースになるテストデータを用意します。名前とかはなんでもいいんですが、&lt;code&gt;Testcases&lt;/code&gt;フォルダに&lt;code&gt;Test.json&lt;/code&gt;を追加しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/606cede7-9a20-4efe-8e58-642330ced8d5" alt="image" /&gt;&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;click&amp;quot;:&amp;quot;Close()&amp;quot;}]}}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このデータを元にしてfuzzerは値を変形させていくことになります。&lt;/p&gt;
&lt;p&gt;では実行しましょう！実行するためには、ビルドしてILポストプロセスしてlibFuzzer経由で動かす……。という一連の定型の流れが必要になるため、作者の用意してくれているPowerShellスクリプト&lt;a href="https://raw.githubusercontent.com/Metalnem/sharpfuzz/master/scripts/fuzz-libfuzzer.ps1"&gt;fuzz-libfuzzer.ps1&lt;/a&gt;をダウンロードしてきて使いましょう。&lt;/p&gt;
&lt;p&gt;とりあえず&lt;code&gt;fuzz-libfuzzer.ps1&lt;/code&gt;と&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;をcsprojと同じディレクトリに配置して、以下のコマンドを実行します。&lt;code&gt;ConsoleApp24.csproj&lt;/code&gt;の部分だけ適当に変えてください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;動かすと、見つかった場合はいい感じに止まってくれます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/1ce45aa1-2d50-46f2-8f86-947db39406d6" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;なお、見つからなかった場合は無限に探し続けるので、なんとなくもう見つかりそうにないなあ、と思ったら途中で自分でとめる(Ctrl+C)必要があります。&lt;/p&gt;
&lt;p&gt;Testcasesには途中の残骸と、クラッシュした場合は&lt;code&gt;crash-id&lt;/code&gt;でクラッシュ時のデータが拾えます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/d90f5bb1-4509-41b6-a139-16789a5a501c" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;今回見つかったクラッシュデータは&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;popid&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でした。実際このデータを使って再現できます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;

//  クラッシュファイルのプロパティでデータはCopy to Output Directoryしてしまう
//  &amp;lt;None Update=&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;&amp;gt;
//    &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
//  &amp;lt;/None&amp;gt;
var crash = File.ReadAllBytes(&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;);
var span = crash.AsSpan();

// Fuzzing時と同じコード
using var stream = new MemoryStream(span.ToArray());
using var reader = new StreamReader(stream);
JSON.DeserializeDynamic(reader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上！完璧！便利！一度手順を理解してしまえば、そこまで難しいことではないので、是非ハンズオンでやってみることをお薦めします。なお、ps1のスクリプトは実行対象自身へのインジェクトは除外されるようになっているので、小規模な自分のコードでfuzzingを試してみたいと思った場合は、対象コードはexeとは異なるプロジェクトに分離しておく必要があります。&lt;/p&gt;
&lt;p&gt;ところで、AFLにはdictionaryという仕組みがあり、既知のキーワード集がある場合は生成速度を大幅に上昇させることが可能です。例えば&lt;a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/json.dict"&gt;json.dict&lt;/a&gt;を使う場合は&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot; -dict ./json.dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように指定します。JSONとかYAMLとかXMLとかZipとか、一般的な形式は&lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries"&gt;AFLplusplus/dictionaries&lt;/a&gt;などに沢山転がっています。独自に作ることも可能で、例えばdotnet/runtimeのFuzzingではBinaryFormatterのテストが置いてありますが、これは&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/binaryformatter-migration-guide/read-nrbf-payloads"&gt;NRBF(.NET Remoting Binary Format)&lt;/a&gt;の辞書、&lt;a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Fuzzing/DotnetFuzzing/Dictionaries/nrbfdecoder.dict"&gt;nrbfdecoder.dict&lt;/a&gt;を用意しているようでした。&lt;/p&gt;
&lt;p&gt;もちろん、なしでも動かすことはできますが、用意できそうなら用意しておくとよいでしょう。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;でも実際バグ見つかってたりするので、この手のライブラリを作る人だったら覚えておいて損はないです。シリアライザーに限らずパーサーに関わるものだったらネットワークプロトコルでも、なんでも適用可能です。ただし現状、入力が&lt;code&gt;byte[]&lt;/code&gt;に制限されているので、応用性自体はあるようで、なかったりはします。これがintとか受け入れてくれると、様々なメソッドに対してカジュアルに使えて、より便利な気もしますが……(実際go fuzzは&lt;code&gt;byte[]&lt;/code&gt;だけじゃなくて基本的なプリミティブの生成に対応している)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;列から適当に切り出してintとして使う、といったような処理だと、ミューテーションやカバレッジの関係上、適切な値を取得しにくいので、あまりうまくやれません。libFuzzerでは&lt;a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md"&gt;Structure-Aware Fuzzing with libFuzzer&lt;/a&gt;といったような手法が考案されていて、protocol buffersの構造を与えるとか、gRPCの構造を与えるとかでうまく活用している事例はあるようです。この辺はSharpFuzzの対応次第となります(いつかやりたい、とは書いてありましたが、現実的にいつ来るかというと、あまり期待しないほうが良いでしょう)&lt;/p&gt;
&lt;p&gt;Rustにも&lt;a href="https://github.com/rust-fuzz/cargo-fuzz"&gt;cargo fuzz&lt;/a&gt;といったcrateがあり、それなりに使われているようです。&lt;/p&gt;
&lt;p&gt;Fuzzingは適用範囲が限定的であることと下準備の手間などがあり、一般的なアプリケーション開発者においては、あまりメジャーなテスト手法ではないというのが現状だと思いますが、使えるところはないようで意外とあるとも思うので、ぜひぜひ試してみてください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-03T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/11/19_cysharp_oss.html</guid>
      <link>https://neue.cc/2024/11/19_cysharp_oss.html</link>
      <title>CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-11-19" data-pagefind-meta="published:2024-11-19"&gt;&lt;a href="https://neue.cc/2024/11/19_cysharp_oss.html"&gt;CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-11-19&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;「CysharpのOSS群から見るModern C#の現在地」というタイトルでセッションしてきました。&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="73bfd578c3324a6e8ce74457445fe9c0" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;作りっぱなし、というわけではないですが（比較的メンテナンスしてるとは思います！）、リリースから年月が経ったライブラリをどう思っているかは見えないところありますよね、というわけで、その辺を軽く伝えられたのは良かったのではないかと思います。&lt;/p&gt;
&lt;p&gt;この中だと非推奨に近くなっているのが&lt;a href="https://github.com/Cysharp/ZString"&gt;ZString&lt;/a&gt;と&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;でしょうか。&lt;/p&gt;
&lt;h2&gt;Ulid vs .NET 9 UUID v7&lt;/h2&gt;
&lt;p&gt;スライドにも書きましたが、ULIDをそこそこ使ってきての感想としては、「Guidではないこと」が辛いな、と。独自文字列形式とか要らないし。そんなわけで私はむしろUUID v7のほうを薦めたいレベルだったりはします。.NET 9から&lt;code&gt;Guid.CreateVersion7()&lt;/code&gt;という形で、標準で生成できるようになりました。&lt;/p&gt;
&lt;p&gt;パフォーマンス的なところは些細なことなので問題ないのですが、 .NET 9未満との互換性が取れないのは厳しいところかもしれません。というわけで、自作のV7実装を用意してあげるといいでしょう。以下に置いておきますのでどうぞ（コードのベースはdotnet/runtimeのCCreateVersion7です）&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-Csharp"&gt;public static class GuidEx
{
    private const byte Variant10xxMask = 0xC0;
    private const byte Variant10xxValue = 0x80;
    private const ushort VersionMask = 0xF000;
    private const ushort Version7Value = 0x7000;

    public static Guid CreateVersion7() =&amp;gt; CreateVersion7(DateTimeOffset.UtcNow);

    public static Guid CreateVersion7(DateTimeOffset timestamp)
    {
        // 普通にGUIDを作る
        Guid result = Guid.NewGuid();

        // 先頭48bitをいい感じに埋める
        var unix_ts_ms = timestamp.ToUnixTimeMilliseconds();

        // GUID layout is int _a; short _b; short _c, byte _d;
        Unsafe.As&amp;lt;Guid, int&amp;gt;(ref Unsafe.AsRef(ref result)) = (int)(unix_ts_ms &amp;gt;&amp;gt; 16); // _a
        Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 2) = (short)(unix_ts_ms); // _b

        ref var c = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 3);
        c = (short)((c &amp;amp; ~VersionMask) | Version7Value);

        ref var d = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(ref result)), 8);
        d = (byte)((d &amp;amp; ~Variant10xxMask) | Variant10xxValue);

        return result;
    }

    // GuidにはTimestamp部分を取り出すメソッドがないので、これも用意してあげると便利
    public static DateTimeOffset GetTimestamp(in Guid guid)
    {
        // エンディアンについては特に考慮してません
        ref var p = ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(in guid));
        var lower = Unsafe.ReadUnaligned&amp;lt;uint&amp;gt;(ref p);
        var upper = Unsafe.ReadUnaligned&amp;lt;ushort&amp;gt;(ref Unsafe.Add(ref p, 4));
        var time = (long)upper + (((long)lower) &amp;lt;&amp;lt; 16);
        return DateTimeOffset.FromUnixTimeMilliseconds(time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UUID v7のよくあるユースケースはDBの主キーにGUID(UUID v4)の代わりに使う、ということです。UUID v4だとランダムに配置されるので断片化して、auto incrementの主キーに比べると色々と遅くなる。それがv7だとランダムの性質を持ちつつも配置場所はタイムスタンプベースなのでauto incrementと同様になるため性能劣化がない。&lt;/p&gt;
&lt;p&gt;という理屈を踏まえたうえで、.NETのUUID v7事情を踏まえると単純に置き換えるだけで良い、とはなりません。&lt;/p&gt;
&lt;p&gt;GUIDは内部的なバイナリデータとしてはリトルエンディアンで保持していて、出力時に切り分けるというデザインになっています(無指定の場合はlittleEndianでの出力)。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public readonly struct Guid
{
    public byte[] ToByteArray()
    public byte[] ToByteArray(bool bigEndian)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination, bool bigEndian, out int bytesWritten)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String(char36)として格納するなら気にしなくてもいいのですが、GUID型やバイナリ型としてデータベースに格納する時は、UUID v7に関してはビッグエンディアンで書き出さないと、ソート可能にならない非常に都合が悪い。これのハンドリングは言語のデータベースドライバーライブラリの責務となっています。&lt;/p&gt;
&lt;p&gt;代表的なライブラリを見ていくと、MySQLの&lt;a href="https://mysqlconnector.net/connection-options/"&gt;mysqlconnector-netはコネクションストリング&lt;/a&gt;で &lt;code&gt;GuidFormat=Binary16&lt;/code&gt; を指定することでbig-endianでBINARY(16)に書き込む設定となります。&lt;/p&gt;
&lt;p&gt;PostgreSQLの場合、&lt;a href="https://github.com/npgsql/npgsql/blob/94de20fed2e7e64a1eb6f26c9fc044131a362958/src/Npgsql/Internal/Converters/Primitive/GuidUuidConverter.cs#L29"&gt;npgsqlのGuidUuidConverter&lt;/a&gt;が常にbigEndianとして処理するようになっているようです。&lt;/p&gt;
&lt;p&gt;ではMicrosoft SQL Serverはどうかというと、ばっちしlittle-endianです。ダメです。というわけで、性能を期待してCreateVersion7を使うと、逆に断片化して遅くなるような憂き目にあいます。&lt;/p&gt;
&lt;p&gt;こちらは&lt;a href="https://github.com/dotnet/SqlClient/discussions/2999"&gt;dotnet/SqlClientのdiscussions#2999&lt;/a&gt;で議論されているようなので、成り行きに注目ということで。今までとの互換性などを考えると一括でbigにしてしまえばいいじゃん、というわけにもいかないしで、中々素直にはいかないかもしれませんね……。&lt;/p&gt;
&lt;p&gt;なお、このことは別に.NET 9がリリースされる前にもわかっていたことなのに（私でもダメだという状況は把握していた）、リリースされるまでアクションが全く起きないというところに、今のSQL Serverへのやる気を感じたりなかったり。&lt;/p&gt;
&lt;h2&gt;MagicOnion&lt;/h2&gt;
&lt;p&gt;イベントではCysharpの @mayuki さんからMagicOnionの入門セッションもありました！&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="d5b4ad47f5cd4e9f984022e64d623d51" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;MagicOnionも2016年の初リリース、2018年のリブート(v2)、googleのgRPC C Coreからgrpc-dotnetベースへの変更、クライアントのHttpClientベースへの変更など、内部的には色々変わってきたし機能面でも磨かれてきています。まだまだ次のアップデートが控えている、最前線で戦える強力なフレームワークとなっています！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 19 Nov 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-11-19T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/08/29_AlternateLookup.html</guid>
      <link>https://neue.cc/2024/08/29_AlternateLookup.html</link>
      <title>.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-08-29" data-pagefind-meta="published:2024-08-29"&gt;&lt;a href="https://neue.cc/2024/08/29_AlternateLookup.html"&gt;.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-08-29&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;.NET 9 から辞書系のクラス、&lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;ConcurrentDictionary&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, &lt;code&gt;FrozenDictionary&lt;/code&gt;, &lt;code&gt;FrozenSet&lt;/code&gt;に &lt;code&gt;GetAlternateLookup&amp;lt;TKey, TValue, TAlternate&amp;gt;()&lt;/code&gt; というメソッドが追加されました。今までDictionaryの操作はTKey経由でしかできませんでした。それは当たり前、なのですが、困るのが文字列キーで、これはstringでも操作したいし、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;でも操作したくなります。今までは&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;しか手元にない場合はToStringでstring化が必須でした、ただたんにDictionaryの値を参照したいだけなのに！&lt;/p&gt;
&lt;p&gt;その問題も、.NET 9から追加された&lt;code&gt;GetAlternateLookup&lt;/code&gt;を使うと、辞書に別の検索キーを持たせることが出来るようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var dict = new Dictionary&amp;lt;string, int&amp;gt;
{
    { &amp;quot;foo&amp;quot;, 10 },
    { &amp;quot;bar&amp;quot;, 20 },
    { &amp;quot;baz&amp;quot;, 30 }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;char&amp;gt;&amp;gt;();

var keys = &amp;quot;foo, bar, baz&amp;quot;;

// .NET 9 SpanSplitEnumerator
foreach (Range range in keys.AsSpan().Split(','))
{
    ReadOnlySpan&amp;lt;char&amp;gt; key = keys.AsSpan(range).Trim();

    // ReadOnlySpan&amp;lt;char&amp;gt;でstring keyの辞書のGet/Add/Removeできる
    int value = lookup[key];
    Console.WriteLine(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ところでSplitは、通常のstringのSplitは配列とそれぞれ区切られたstringをアロケーションしてしまいますが、.NET 8から、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;に対して固定個数のSplitができる&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.split"&gt;MemoryExtensions.Split&lt;/a&gt;が追加されました。.NET 9では、更にSpanSplitEnumeratorを返すSplitが新たに追加されています。これにより一切の追加のアロケーションなく、元の文字列から&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;を切り出すことができます。&lt;/p&gt;
&lt;p&gt;そうして取り出した&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;のキーで参照するために、&lt;code&gt;GetAlternateLookup&lt;/code&gt;が必要になってくるわけです。&lt;/p&gt;
&lt;p&gt;使い道としては、例えばシリアライザーは頻繁にキーと値のルックアップが必要になります。私の開発している&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#&lt;/a&gt;では、高速でアロケーションフリーなデシリアライズのために、複数の戦略を採用しています。その一つはUTF8の文字列を8バイトずつの&lt;a href="https://en.wikipedia.org/wiki/Automata_theory"&gt;オートマトン&lt;/a&gt;として扱う&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs"&gt;AutomataDictionary&lt;/a&gt;、この部分は更にIL EmitやSource Generatorではインライン化して埋め込まれて辞書検索もなくしています。もう一つは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/5793c81/src/MessagePack/Internal/AsymmetricKeyHashTable.cs"&gt;AsymmetricKeyHashTable&lt;/a&gt;という機構で、これは同一の対象を表す2つのキーで検索可能にしようというもので、内部的には &lt;code&gt;byte[]&lt;/code&gt; と &lt;code&gt;ArraySegment&amp;lt;byte&amp;gt;&lt;/code&gt; で検索できるような辞書を作っていました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// MessagePack for C#のもの
internal interface IAsymmetricEqualityComparer&amp;lt;TKey1, TKey2&amp;gt;
{
    int GetHashCode(TKey1 key1);
    int GetHashCode(TKey2 key2);
    bool Equals(TKey1 x, TKey1 y);
    bool Equals(TKey1 x, TKey2 y); // TKey1とTKey2での比較
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり、今までは、こうした別の検索キーを持った辞書が必要なシチュエーションでは、辞書そのものの自作が必要だったし、パフォーマンスのためには基礎的なデータ構造すら自作を厭わない必要がありましたが、.NET 9からはついに標準でそれが実現するようになりました。&lt;/p&gt;
&lt;p&gt;AlternateLookupでも必要なのは&lt;code&gt;IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;&lt;/code&gt;で、以下のような定義になっています。(&lt;code&gt;IAsymmetricEqualityComparer&lt;/code&gt;と似たような定義なので、また時代を10年先取りしてしまったか)&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;
    where TAlternate : allows ref struct
    where T : allows ref struct
{
    bool Equals(TAlternate alternate, T other);
    int GetHashCode(TAlternate alternate);
    T Create(TAlternate alternate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C# 13から追加された言語機能 &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/ref-struct"&gt;allows ref struct&lt;/a&gt; によってref struct、つまり&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;などをジェネリクスの型引数にすることができるようになりました。&lt;/p&gt;
&lt;p&gt;基本的にはこれは&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;とセットで実装する必要があります。実際、&lt;code&gt;Dictionary.GetAlternateLookup&lt;/code&gt;ではDictionaryの&lt;code&gt;IEqualityComparer&lt;/code&gt;が&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していないと実行時例外が出ます（コンパイル時チェックではありません！）また、EqualityComparerなのに&lt;code&gt;Create&lt;/code&gt;があるのが少し奇妙ですが、これはAdd操作のために必要だからです。&lt;/p&gt;
&lt;p&gt;現状、標準では&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;は&lt;code&gt;string&lt;/code&gt;用しかありません。stringで標準的に使われるEqualityComparerは&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していて、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;で操作できますが、それ以外は用意されていません。&lt;/p&gt;
&lt;p&gt;しかし、現代において現実的に必要なのはUTF8です、&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;です。シリアライザーのルックアップで使う、と言いましたが、現代のシリアライザーの入力はUTF8です。&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;の出番なんてありません。というわけで、以下のような&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を用意しましょう！&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public sealed class Utf8StringEqualityComparer : IEqualityComparer&amp;lt;byte[]&amp;gt;, IAlternateEqualityComparer&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;, byte[]&amp;gt;
{
    public static IEqualityComparer&amp;lt;byte[]&amp;gt; Default { get; } = new Utf8StringEqualityComparer();

    // IEqualityComparer

    public bool Equals(byte[]? x, byte[]? y)
    {
        if (x == null &amp;amp;&amp;amp; y == null) return true;
        if (x == null || y == null) return false;

        return x.AsSpan().SequenceEqual(y);
    }

    public int GetHashCode([DisallowNull] byte[] obj)
    {
        return GetHashCode(obj.AsSpan());
    }

    // IAlternateEqualityComparer

    public byte[] Create(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        return alternate.ToArray();
    }

    public bool Equals(ReadOnlySpan&amp;lt;byte&amp;gt; alternate, byte[] other)
    {
        return other.AsSpan().SequenceEqual(alternate);
    }

    public int GetHashCode(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        // System.IO.Hashing package, cast to int is safe for hashing
        return unchecked((int)XxHash3.HashToUInt64(alternate));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;は標準では参照比較になってしまいますが、データの一致で比較したいので、&lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;.SequenceEqual&lt;/code&gt; を使います。これは、特にTが幾つかのプリミティブの場合はSIMDを活用して高速な比較が実現されています。ハッシュコードの算出は、高速なアルゴリズム&lt;a href="https://github.com/Cyan4973/xxHash"&gt;xxHash&lt;/a&gt;シリーズの最新版であるXXH3の.NET実装である&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3"&gt;XxHash3&lt;/a&gt;を用いるのがベストでしょう。これはNuGetから&lt;code&gt;System.IO.Hashing&lt;/code&gt;をインポートする必要があります。64ビットで算出するため戻り値はulongですが、32ビット値が必要な場合はxxHashの作者より、ただたんに切り落とすだけで問題ないと言明されているため、intにキャストするだけで済まします。&lt;/p&gt;
&lt;p&gt;使う場合の例は、こんな感じです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Utf8StringEqualityComparerを設定した辞書を作る

var dict = new Dictionary&amp;lt;byte[], bool&amp;gt;(Utf8StringEqualityComparer.Default)
{
    { &amp;quot;foo&amp;quot;u8.ToArray(), true },
    { &amp;quot;bar&amp;quot;u8.ToArray(), false },
    { &amp;quot;baz&amp;quot;u8.ToArray(), false }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;&amp;gt;();

// こんな入力があるとする

ReadOnlySpan&amp;lt;byte&amp;gt; json = &amp;quot;&amp;quot;&amp;quot;    
{
    &amp;quot;foo&amp;quot;: 0,
    &amp;quot;bar&amp;quot;: 0,
    &amp;quot;baz&amp;quot;: 0
}
&amp;quot;&amp;quot;&amp;quot;u8;

// System.Text.Json
var reader = new Utf8JsonReader(json);

while (reader.Read())
{
    if (reader.TokenType == JsonTokenType.PropertyName)
    {
        // 切り出したKeyで検索できる
        ReadOnlySpan&amp;lt;byte&amp;gt; key = reader.ValueSpan;
        var flag = lookup[key];
        
        Console.WriteLine(flag);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一つ注意なのは、&lt;code&gt;string&lt;/code&gt;と&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;でAlternateKeyを作ろうとするのはやめたほうが良いでしょう。それだと、常にエンコードが必要になり、悪いとこどりのようになってしまいます(&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.rune"&gt;Rune&lt;/a&gt;を使ってアロケーションレスで処理するにしても、どちらにせよバイナリ比較だけで済ませられる&lt;code&gt;byte[]&lt;/code&gt;キーとは比較になりません）。どうしても両方の検索が必要なら、辞書を二つ用意するほうがマシです。&lt;/p&gt;
&lt;p&gt;ともあれ、これは私にとっては念願の機能です！色々なバリエーションで、Span対応のためにジェネリクスにもできずに決め打ちで辞書を何度も作ってきました、汎用的に使えるようになったのは大歓迎です。&lt;code&gt;allows ref struct&lt;/code&gt;はジェネリクス定義での煩わしさもありますが（自動判定での付与でも良かったような？）、言語としては重要な進歩です。.NET 9, C# 13、使っていきましょう。現状はまだプレビューですが、11月に正式版がリリースされるはずです。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 29 Aug 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-08-29T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/07/11_mvp-renew14.html</guid>
      <link>https://neue.cc/2024/07/11_mvp-renew14.html</link>
      <title>Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-07-11" data-pagefind-meta="published:2024-07-11"&gt;&lt;a href="https://neue.cc/2024/07/11_mvp-renew14.html"&gt;Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-07-11&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Microsoft MVPは一年ごとに再審査されるのですが、今年も更新しました。2011年から初めて14回目ということで、長い！のですが、引き続きC#の最前線に立ち続けられていると思います。以下、審査用書類に出した、審査期間での実績一覧です。&lt;/p&gt;
&lt;h2&gt;OSS New&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;MagicPhysX&lt;/a&gt;&lt;br /&gt;
.NET PhysX 5 binding to all platforms(win, osx, linux) for 3D engine, deep learning, dedicated server of gaming.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/PrivateProxy"&gt;PrivateProxy&lt;/a&gt;&lt;br /&gt;
Source Generator and .NET 8 UnsafeAccessor based high-performance strongly-typed private accessor for unit testing and runtime.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Utf8StringInterpolation&lt;/a&gt;&lt;br /&gt;
Successor of ZString; UTF8 based zero allocation high-peformance String Interpolation and StringBuilder.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;&lt;br /&gt;
The new future of dotnet/reactive and UniRx.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Claudia"&gt;Claudia&lt;/a&gt;&lt;br /&gt;
Unofficial Anthropic Claude API client for .NET.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StreamReader"&gt;Utf8StreamReader&lt;/a&gt;&lt;br /&gt;
Utf8 based StreamReader for high performance text processing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OSS Update&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/StructureOfArraysGenerator"&gt;StructureOfArraysGenerator&lt;/a&gt;&lt;br /&gt;
Structure of arrays source generator to make CPU Cache and SIMD friendly data structure for high-performance code in .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;&lt;br /&gt;
Fast .NET C# Implementation of ULID for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;&lt;br /&gt;
Zero Allocation Text/Structured Logger for .NET with StringInterpolation and Source Generator, built on top of a Microsoft.Extensions.Logging.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZString/"&gt;ZString&lt;/a&gt;&lt;br /&gt;
Zero Allocation StringBuilder for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack-CSharp&lt;/a&gt;&lt;br /&gt;
Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin).&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ObservableCollections"&gt;ObservableCollections&lt;/a&gt;&lt;br /&gt;
High performance observable collections and synchronized views, for WPF, Blazor, Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UnitGenerator/"&gt;UnitGenerator&lt;/a&gt;&lt;br /&gt;
C# Source Generator to create value-object, inspired by units of measure.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;&lt;br /&gt;
Zero encoding extreme performance binary serializer for C# and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;&lt;br /&gt;
Generate C# FFI from Rust for automatically brings native code and C native library to .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/DFrame"&gt;DFrame&lt;/a&gt;&lt;br /&gt;
Distributed load testing framework for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MessagePipe"&gt;MessagePipe&lt;/a&gt;&lt;br /&gt;
High performance in-memory/distributed messaging pipeline for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UniTask"&gt;UniTask&lt;/a&gt;&lt;br /&gt;
Provides an efficient allocation free async/await integration for Unity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Speaker&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition"&gt;CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/pulse1923/metabasupuratutohuomu-inspix-world-haphpmoc-plus-plus-momatometec-number-nitong-magiconiongazhi-erubatukuendozui-shi-hua-shou-fa"&gt;メタバースプラットフォーム 「INSPIX WORLD」はPHPもC++もまとめてC#に統一！ ～MagicOnionが支えるバックエンド最適化手法～ - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/ta-yan-yu-gameinnochang-he-norustnohuo-yong-fa-csbindgenniyoruc-number-x-rust-ffishi-jian-shi-li"&gt;他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例 - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Book&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.jp/dp/4862465900"&gt;Unityプログラミング・バイブル R6号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;世界中見てもこんだけ叩き出してる人間いないので、これだけやってれば、満場一致で更新でいいでしょう。はい。自分で言うのもあれですが。あれ。&lt;/p&gt;
&lt;p&gt;期間中で言うと&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;が大型タイトル（？）です。また、Updateのほうも大型リニューアルとして&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger v2&lt;/a&gt;は相当力の入ったものになっています。今年の範囲だと、こないだ出した&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework v5&lt;/a&gt;や、近いうちにリリースされる（はず）の&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C# v3&lt;/a&gt;といった計画も控えています。なお、&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;は現在メンテナーじゃないので実績に含めてはいないのですが、引き続きアクティブに開発されています！&lt;/p&gt;
&lt;p&gt;ところで、このサイトも地味に更新されていて（自作のC#製静的サイトジェネレーターで作られています、ハンドメイド！）、ついに全文検索が搭載されました！上のほうのインプットボックスがそれになっているので、ぜひ試してみてください。ちょっと引っ掛かり方が変な可能性も高いですが、そこは検索ライブラリの仕様なので、いつか改善されるでしょう。多分きっと。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-07-11T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html</guid>
      <link>https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html</link>
      <title>ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-06-13" data-pagefind-meta="published:2024-06-13"&gt;&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-06-13&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt;の完全に新しいバージョンをリリースしました。完全に設計しなおして実装も完全に作り直された、何もかもが新しいフレームワークになっています。設計指針として「Zero Dependency, Zero Overhead, Zero Reflection, Zero Allocation, AOT Safe」を掲げ、もちろん、他を圧倒的に引き離すパフォーマンスを実現しています。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ConsoleAppFramework/assets/46207/db4bf599-9fe0-4ce4-801f-0003f44d5628" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これはコールドスタートアップ・ウォームアップなしでのベンチマークとなっていて、CLIアプリケーションでの実際での利用に最も即したものだと考えています。System.CommandLineと比較すれば280倍！メモリアロケーション量もほかのフレームワークの100~1000倍少なくなっています(表示されている400Bはほぼシステム自体のallocなのでフレームワーク自体は0です)。&lt;/p&gt;
&lt;p&gt;このパフォーマンスは、全てをSource Generatorで生成することで実現しました。例えば以下のようなコード。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;

// args: ./cmd --foo 10 --bar 20
ConsoleApp.Run(args, (int foo, int bar) =&amp;gt; Console.WriteLine($&amp;quot;Sum: {foo + bar}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConsoleAppFrameworkはSource GeneratorがRunで与えられているラムダ式の引数を解析して、Runメソッドそのものを生成します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal static partial class ConsoleApp
{
    // Generate the Run method itself with arguments and body to match the lambda expression
    public static void Run(string[] args, Action&amp;lt;int, int&amp;gt; command)
    {
        // code body
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常C#のSource Generatorは属性をクラスかメソッドに与えて、それを元に生成されますが、ConsoleAppFrameworkはメソッドの呼び出しを監視して生成のキーにしています。これはRustのマクロから発想を得ていて、Rustには&lt;a href="https://doc.rust-lang.org/book/ch19-06-macros.html"&gt;Attribute-like macros and Function-like macros&lt;/a&gt;といったような分類がありますが、今回のやりかたはFunction-likeなスタイルと言えるでしょう。&lt;/p&gt;
&lt;p&gt;実際の生成されるコード全体は以下のようなものになります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal static partial class ConsoleApp
{
    public static void Run(string[] args, Action&amp;lt;int, int&amp;gt; command)
    {
        if (TryShowHelpOrVersion(args, 2, -1)) return;

        var arg0 = default(int);
        var arg0Parsed = false;
        var arg1 = default(int);
        var arg1Parsed = false;

        try
        {
            for (int i = 0; i &amp;lt; args.Length; i++)
            {
                var name = args[i];

                switch (name)
                {
                    case &amp;quot;--foo&amp;quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg0)) { ThrowArgumentParseFailed(&amp;quot;foo&amp;quot;, args[i]); }
                        arg0Parsed = true;
                        break;
                    }
                    case &amp;quot;--bar&amp;quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg1)) { ThrowArgumentParseFailed(&amp;quot;bar&amp;quot;, args[i]); }
                        arg1Parsed = true;
                        break;
                    }
                    default:
                        // omit...(case-insensitive compare codes)
                        ThrowArgumentNameNotFound(name);
                        break;
                }
            }
            if (!arg0Parsed) ThrowRequiredArgumentNotParsed(&amp;quot;foo&amp;quot;);
            if (!arg1Parsed) ThrowRequiredArgumentNotParsed(&amp;quot;bar&amp;quot;);

            command(arg0!, arg1!);
        }
        catch (Exception ex)
        {
            Environment.ExitCode = 1;
            if (ex is ValidationException or ArgumentParseFailedException)
            {
                LogError(ex.Message);
            }
            else
            {
                LogError(ex.ToString());
            }
        }
    }

    static partial void ShowHelp(int helpId)
    {
        Log(&amp;quot;&amp;quot;&amp;quot;
Usage: [options...] [-h|--help] [--version]

Options:
  --foo &amp;lt;int&amp;gt;     (Required)
  --bar &amp;lt;int&amp;gt;     (Required)
&amp;quot;&amp;quot;&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特にひねりもなさそうなド直球ドシンプルなコードに見えるのではないでしょうか。それが大事です！単純なコードであればあるほど速い！フレームワークなのに単純、だから速い。というのが目指している姿です。余計なコードはいっさいなく、メソッド本体に全ての処理が集約されているので、フレームワークとしてゼロ・オーバーヘッド、最適化した手書きコードと同等の速度を実現しました。&lt;/p&gt;
&lt;p&gt;CLIアプリケーションは通常、コールドスタートからの単発の実行になるため、動的コード生成(IL.EmitやExpression.Compile)やキャッシュ(ArrayPoolやDictionary生成による以降のマッチング高速化)が効きにくい分野です。それらを作ったほうがオーバーヘッドが大きいですから。かといってリフレクションなどをそのまま使うのは、それはそれで低速です。ConsoleAppFrameworkは全ての必要な処理をインライン生成することによって、単発実行での速度が圧倒的に高速化されています。&lt;/p&gt;
&lt;p&gt;リフレクションもないのでNative AOTとの親和性も圧倒的に高く、コールドスタートアップ速度におけるC#の欠点は一切なくなります。&lt;/p&gt;
&lt;p&gt;もう一つ特徴として、&lt;code&gt;ConsoleApp&lt;/code&gt;クラスを含めて、全てがSource Generatorによって生成されるために、ConsoleAppFramework自体も含めて依存が全くありません。&lt;/p&gt;
&lt;p&gt;コンソールアプリケーションを作るシチュエーションは多用です。多数の依存を持った大きなバッチアプリケーションの場合もあれば、超単機能の小さなコマンドの場合もあります。小さなコマンドを作りたい時には、少しも追加の依存を入れたくはないでしょう。それこそ &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; を参照すると、それだけで数十個の依存DLLが追加されてしまいます！ConsoleAppFrameworkなら、自身も含めて依存ゼロです。&lt;/p&gt;
&lt;p&gt;依存ゼロの良いところは明らかにバイナリサイズが小さくなることです。特にNative AOTではバイナリサイズは気になるところですが、ConsoleAppFrameworkなら追加のコストはほぼゼロです。&lt;/p&gt;
&lt;p&gt;そしてもちろん、単機能ではフレームワークとしては物足りない、ということで以下のような機能が実現されています。十分に充実した機能群は、他のフレームワークと比べても全く見劣りしないはずです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIGINT/SIGTERM(Ctrl+C) handling with gracefully shutdown via &lt;code&gt;CancellationToken&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter(middleware) pipeline to intercept before/after execution&lt;/li&gt;
&lt;li&gt;Exit code management&lt;/li&gt;
&lt;li&gt;Support for async commands&lt;/li&gt;
&lt;li&gt;Registration of multiple commands&lt;/li&gt;
&lt;li&gt;Registration of nested commands&lt;/li&gt;
&lt;li&gt;Setting option aliases and descriptions from code document comment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.ComponentModel.DataAnnotations&lt;/code&gt; attribute-based Validation&lt;/li&gt;
&lt;li&gt;Dependency Injection for command registration by type and public methods&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.Extensions&lt;/code&gt;(Logging, Configuration, etc...) integration&lt;/li&gt;
&lt;li&gt;High performance value parsing via &lt;code&gt;ISpanParsable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Parsing of params arrays&lt;/li&gt;
&lt;li&gt;Parsing of JSON arguments&lt;/li&gt;
&lt;li&gt;Help(&lt;code&gt;-h|--help&lt;/code&gt;) option builder&lt;/li&gt;
&lt;li&gt;Default show version(&lt;code&gt;--version&lt;/code&gt;) option&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成されるコードはモジュール化されていて、コードが使用する機能によって変化し、常にその機能の実現において最小のコードが生成されるようになっています。それにより多機能と高速さを両立しています。また、どの機能も最速で実行できるよう念入りに調整してあるため、全機能が有効化されてもなお、他とは比較にならないほどに高速です。&lt;/p&gt;
&lt;p&gt;余談ですが、デリゲートはデリゲート生成というアロケーションがあります。つまり真のゼロアロケーション・ゼロオーバーヘッドじゃないじゃん、と言うことができます。しかし、ちゃんとConsoleAppFrameworkは真のゼロアロケーションを実現する仕組みもちゃんと用意されています。以下のように静的関数をfunction pointerとして渡してください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;unsafe
{
    ConsoleApp.Run(args, &amp;amp;Sum);
}

static void Sum(int x, int y) =&amp;gt; Console.Write(x + y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すると、以下のような &lt;code&gt;delegate* managed&amp;lt;&amp;gt;&lt;/code&gt; （あまり見慣れないと思いますが、managed function pointerという言語機能がC#には追加されているのです）の引数を持ったメソッドの実体を生成します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static unsafe void Run(string[] args, delegate* managed&amp;lt;int, int, void&amp;gt; command)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これならもう完全に文句なくゼロアロケーション・ゼロオーバーヘッドです！&lt;/p&gt;
&lt;p&gt;実用的には別にデリゲートでも全く関係ないレベルですが、完全に完璧を目指す執拗な姿勢により、対応を入れました。これでどの角度からも絶対に文句は付けられないでしょう。&lt;/p&gt;
&lt;h2&gt;高速な値変換&lt;/h2&gt;
&lt;p&gt;文字列からC#の値に変換する最速の手段はなんでしょうか？intだったら &lt;code&gt;int.TryParse&lt;/code&gt; ですよね。では、他は？intは決め打ちだからいいとして、string -&amp;gt; T(あるいはobject)を汎用的にするには？というと少し難しい話になってきて、昔は&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.componentmodel.typeconverter?view=net-8.0"&gt;TypeConverter&lt;/a&gt;というものが使われてきました。もちろん、パフォーマンスは悪いです。&lt;/p&gt;
&lt;p&gt;あるいは最近はJsonSerializerが標準搭載されているから、それに丸投げしてみるというのもアリでしょう。もちろん、パフォーマンスは決して良くはありません。特にコールドスタートアップで考えるとJsonSerializerのキャッシュ処理が必要になってきて、単発実行においてはかなりのオーバーヘッドが足されてしまいます。&lt;/p&gt;
&lt;p&gt;ConsoleAppFrameworkでは&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.iparsable-1?view=net-8.0"&gt;IParsable&lt;/a&gt;, &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1?view=net-8.0"&gt;ISpanParsable&lt;/a&gt;を採用しています。これは .NET 7から追加され、C# 11で追加されたstatic abstract interfaceが使用されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface IParsable&amp;lt;TSelf&amp;gt; where TSelf : IParsable&amp;lt;TSelf&amp;gt;?
{
	static abstract TSelf Parse(string s, IFormatProvider? provider);
	static abstract bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out TSelf result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C# 11になってようやく汎用的な 「文字列 -&amp;gt; 値」変換処理が実現するようになったのです！ ConsoleAppFrameworkでは .NET 8/C# 12 を最小実行可能環境としているため、問答無用で採用しました。HalfやInt128などの .NET 8で登場した新しい型や、自分で定義する方も&lt;code&gt;IParsable&amp;lt;T&amp;gt;&lt;/code&gt;を実装すればそれを使って高速に処理されます！&lt;/p&gt;
&lt;p&gt;とはいえ、intなどの基本型はそもそもSource Generatorがintであることを知っているので、直接int.TryParseのように直接実行されるようになっていたりはします。&lt;/p&gt;
&lt;p&gt;なお、値のバインディングに関してはparams arrayやデフォルト値にも対応しています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;ConsoleApp.Run(args, (
    [Argument]DateTime dateTime,  // Argument
    [Argument]Guid guidvalue,     // 
    int intVar,                   // required
    bool boolFlag,                // flag
    MyEnum enumValue,             // enum
    int[] array,                  // array
    MyClass obj,                  // object
    string optional = &amp;quot;abcde&amp;quot;,    // optional
    double? nullableValue = null, // nullable
    params string[] paramsArray 
    ) =&amp;gt; { });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちょうどC# 12から&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression"&gt;ラムダ式にデフォルト値やparamsが使用できるようになりました&lt;/a&gt;、ということが反映されています。&lt;/p&gt;
&lt;h2&gt;ドキュメントコメントによる定義&lt;/h2&gt;
&lt;p&gt;DescriptionやAliasの追加は、今までは、あるいは他のフレームワークでは属性を使って記述していました。しかし、それは少しメソッドの各パラメーターに属性、更にかなり長めの文字列を付与するのは、メソッドとしてかなり読みづらくなります。&lt;/p&gt;
&lt;p&gt;そこでConsoleAppFrameworkではドキュメントコメントを活用することにしました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;class Commands
{
    /// &amp;lt;summary&amp;gt;
    /// Display Hello.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;message&amp;quot;&amp;gt;-m, Message to show.&amp;lt;/param&amp;gt;
    public static void Hello(string message) =&amp;gt; Console.Write($&amp;quot;Hello, {message}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-txt"&gt;Usage: [options...] [-h|--help] [--version]

Display Hello.

Options:
  -m|--message &amp;lt;string&amp;gt;    Message to show. (Required)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というコマンドになります。ドキュメントコメントであれば、多くの引数があっても自然な見た目を保つことが可能です。この手法が取れるのはSource Generatorで生成するため.xmlは不要でコードから直接読み取れることの強みでもありますね。（ただしSource Generatorでドキュメントコメントをあらゆる環境で読み取れるようにするには若干のハックが必要でした）&lt;/p&gt;
&lt;h2&gt;複数コマンドの追加&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleApp.Run&lt;/code&gt;は単独コマンドのためのショートカットでしたが、複数のコマンドやネストされているサブコマンドの追加も可能です。例えば以下のような設定を行った場合の生成を例を見ていきます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create();

app.Add(&amp;quot;foo&amp;quot;, () =&amp;gt; { });
app.Add(&amp;quot;foo bar&amp;quot;, (int x, int y) =&amp;gt; { });
app.Add(&amp;quot;foo bar barbaz&amp;quot;, (DateTime dateTime) =&amp;gt; { });
app.Add(&amp;quot;foo baz&amp;quot;, async (string foo = &amp;quot;test&amp;quot;, CancellationToken cancellationToken = default) =&amp;gt; { });

app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードのAddは、まず以下のように展開されます。Source Generatorが全てのAddされるラムダ式の型を知っているので、それぞれ固有の型を持ったフィールドに割り当てます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial struct ConsoleAppBuilder
{
    Action command0 = default!;
    Action&amp;lt;int, int&amp;gt; command1 = default!;
    Action&amp;lt;global::System.DateTime&amp;gt; command2 = default!;
    Func&amp;lt;string, global::System.Threading.CancellationToken, Task&amp;gt; command3 = default!;

    partial void AddCore(string commandName, Delegate command)
    {
        switch (commandName)
        {
            case &amp;quot;foo&amp;quot;:
                this.command0 = Unsafe.As&amp;lt;Action&amp;gt;(command);
                break;
            case &amp;quot;foo bar&amp;quot;:
                this.command1 = Unsafe.As&amp;lt;Action&amp;lt;int, int&amp;gt;&amp;gt;(command);
                break;
            case &amp;quot;foo bar barbaz&amp;quot;:
                this.command2 = Unsafe.As&amp;lt;Action&amp;lt;global::System.DateTime&amp;gt;&amp;gt;(command);
                break;
            case &amp;quot;foo baz&amp;quot;:
                this.command3 = Unsafe.As&amp;lt;Func&amp;lt;string, global::System.Threading.CancellationToken, Task&amp;gt;&amp;gt;(command);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりDelegateを保持しておくための配列や、DelegateのままInvokeするリフレクション/ボクシングが防げています。&lt;/p&gt;
&lt;p&gt;Runでは、&lt;code&gt;string[] args&lt;/code&gt;からコマンドを選択するために定数文字列のswitchが埋め込まれます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial void RunCore(string[] args)
{
    if (args.Length == 0)
    {
        ShowHelp(-1);
        return;
    }
    switch (args[0])
    {
        case &amp;quot;foo&amp;quot;:
            if (args.Length == 1)
            {
                RunCommand0(args, args.AsSpan(1), command0);
                return;
            }
            switch (args[1])
            {
                case &amp;quot;bar&amp;quot;:
                    if (args.Length == 2)
                    {
                        RunCommand1(args, args.AsSpan(2), command1);
                        return;
                    }
                    switch (args[2])
                    {
                        case &amp;quot;barbaz&amp;quot;:
                            RunCommand2(args, args.AsSpan(3), command2);
                            break;
                        default:
                            RunCommand1(args, args.AsSpan(2), command1);
                            break;
                    }
                    break;
                case &amp;quot;baz&amp;quot;:
                    RunCommand3(args, args.AsSpan(2), command3);
                    break;
                default:
                    RunCommand0(args, args.AsSpan(1), command0);
                    break;
            }
            break;
        default:
            ShowHelp(-1);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C#で文字列から特定のコードにジャンプする最速の手段は、switchで文字列定数を使うことです。展開されるアルゴリズムは何度か修正されていて、C# 12では&lt;a href="https://github.com/dotnet/roslyn/issues/56374"&gt;Performance: faster switch over string objects · Issue #56374 · dotnet/roslyn&lt;/a&gt;として、まず長さをチェックした後に、差が存在する1文字だけを絞るといった形でマッチさせます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dictionary&amp;lt;string, T&amp;gt;&lt;/code&gt;からのマッチなどよりも高速で初期化時間もアロケーションもないのが、C#コンパイラの助けを借りれる強みであり、そうした処理ができるのはC#コードそのものを出力するSource Generator方式だけです。なので絶対に最速なわけです。&lt;/p&gt;
&lt;h2&gt;DIとCancellationTokenとライフタイム&lt;/h2&gt;
&lt;p&gt;引数にはコマンドのパラメーターとして有効になるもの以外に、DI経由で渡したいもの(例えば&lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;など)や、特別扱いする型として&lt;code&gt;ConsoleAppContext&lt;/code&gt;と&lt;code&gt;CancellationToken&lt;/code&gt;を定義することができます。&lt;/p&gt;
&lt;p&gt;DIによる受取は、コンソールアプリケーションがASP.NETのプロジェクトなどと設定ファイルを共有したいようなシチュエーションで有効でしょう。そうした場合のために、 Microsoft.Extensions.Hosting と連動させることが可能です。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;CancellationToken&lt;/code&gt;を渡した場合は、SIGINT/SIGTERM/SIGKILL(Ctrl+C)をフックするコンソールアプリケーションとしてのライフタイム管理が働くようになります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;await ConsoleApp.RunAsync(args, async (int foo, CancellationToken cancellationToken) =&amp;gt;
{
    await Task.Delay(TimeSpan.FromSeconds(5), cancellationToken);
    Console.WriteLine($&amp;quot;Foo: {foo}&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードは以下のように展開されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using var posixSignalHandler = PosixSignalHandler.Register(ConsoleApp.Timeout);
var arg0 = posixSignalHandler.Token;

await Task.Run(() =&amp;gt; command(arg0!)).WaitAsync(posixSignalHandler.TimeoutToken);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET 6から追加された&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration?view=net-8.0"&gt;PosixSignalRegistration&lt;/a&gt;を使って、SIGINT/SIGTERM/SIGKILLがフックし、CancellationTokenをキャンセルの状態にします。と同時に、即時終了を抑制します(通常Ctrl + Cを押すと即座にAbortされますが、Abortされなくなります)。&lt;/p&gt;
&lt;p&gt;それによりアプリケーションがCancellationTokenを正常にハンドリングする余地を残しています。&lt;/p&gt;
&lt;p&gt;ただしCancellationTokenをハンドリングしないと終了命令を無視するだけになってしまい、それはそれで困るので、強制的に終了するタイムアウト時間が設けられています。デフォルトでは5秒に設定されていますが、これは &lt;code&gt;ConsoleApp.Timeout&lt;/code&gt; プロパティで自由に変更できます。もし強制終了をオフにしたい場合は &lt;code&gt;ConsoleApp.Timeout = Timeout.InfiniteTimeSpan&lt;/code&gt; を指定すると良いでしょう。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.waitasync?view=net-8.0"&gt;Task.WaitAsync&lt;/a&gt;は .NET 6 からです。TimeSpanを渡す以外に、CancellationTokenを渡すことも可能なので、単純な数秒後ではなく、WaitAsyncの発火するタイミングをPosixSignalRegistrationが発火した後にTimeout後、といった条件を作ることができました。&lt;/p&gt;
&lt;h2&gt;フィルターパイプライン&lt;/h2&gt;
&lt;p&gt;実行の前後をフックする仕組みとしてConsoleAppFrameworkではFilterを採用しています。ミドルウェアパターンとも呼ばれて、特にasync/awaitが使える言語ではよく見かけるパターンだと思います。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal class NopFilter(ConsoleAppFilter next) : ConsoleAppFilter(next) // ctor needs `ConsoleAppFilter next` and call base(next)
{
    // implement InvokeAsync as filter body
    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        try
        {
            /* on before */
            await Next.InvokeAsync(context, cancellationToken); // invoke next filter or command body
            /* on after */
        }
        catch
        {
            /* on error */
            throw;
        }
        finally
        {
            /* on finally */
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この設計パターンは本当に優れていて、実行をフックしたいような仕組みを用意したい場合は、このパターンを採用することを絶対にお薦めします。GoFの時代にasync/awaitがあったら、重要なデザインパターンとして載っていたことでしょう。&lt;/p&gt;
&lt;p&gt;ReadMeにはフィルターでできることとして、実行時間のロギング・ExitCodeのカスタマイズ・多重実行禁止・認証処理などを紹介しています。&lt;code&gt;Task InvokeAsync&lt;/code&gt;一つで様々な処理を実現できる素晴らしさ。誰がこのパターンを最初に発見したんでしょうね？&lt;/p&gt;
&lt;p&gt;フィルターの設計にも色々な手法があるのですが、ConsoleAppFrameworkでは最もパフォーマンスの出る方法を選びました。コンストラクターでNextを受け取ることと、コードジェネレート時に静的に全ての利用するフィルターが決定するので（動的な追加は許可していません）、全てを埋め込んで組み立てています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();

// The above code will generate the following code:

sealed class Command0Invoker(string[] args, Action command) : ConsoleAppFilter(null!)
{
    public ConsoleAppFilter BuildFilter()
    {
        var filter0 = new NopFilter(this);
        var filter1 = new NopFilter(filter0);
        var filter2 = new NopFilter(filter1);
        var filter3 = new NopFilter(filter2);
        var filter4 = new NopFilter(filter3);
        return filter4;
    }

    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        return RunCommand0Async(context.Arguments, args, command, context, cancellationToken);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これにより、中間の配列のアロケーションや、ラムダ式のキャプチャのアロケーションは発生せず、フィルターの個数 + 1(メソッド本体のラップ)の追加のアロケーションのみが追加のコストとなります。また、戻り値のTaskは、同期的に完了する場合はTask.Completed相当のものが使われることになるため、これをValueTaskにする必要はありません。&lt;/p&gt;
&lt;p&gt;コンストラクターでNextを受け取ってbaseに渡すだけのコードも、primary constructorのお陰で簡単に書けるようになりました。&lt;/p&gt;
&lt;h2&gt;コマンドライン引数の構文について&lt;/h2&gt;
&lt;p&gt;コマンドライン引数はスペース区切りで&lt;code&gt;string[] args&lt;/code&gt;に渡されるということ以外は、完全に自由です。なんとなく &lt;code&gt;--&lt;/code&gt;や&lt;code&gt;-&lt;/code&gt;がパラメーター識別子だと思われていますが、実際はなんでもいいし、なんだったらWindowsは&lt;code&gt;/&lt;/code&gt;が使われることも多かった。&lt;/p&gt;
&lt;p&gt;とはいえ、ある程度標準的なルールは存在します。代表的なものは&lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html"&gt;POSIX規格&lt;/a&gt;と、その拡張である&lt;a href="https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html"&gt;GNU Coding Standards&lt;/a&gt;でしょうか。ConsoleAppFrameworkでも、POSIX規格にある程度は従いつつ、GNU Coding Stadardsで定義されている &lt;code&gt;--version&lt;/code&gt; と &lt;code&gt;--help&lt;/code&gt; を組み込みのオプションとしています。名前も &lt;code&gt;--lower-kebab-case&lt;/code&gt; がデフォルトです。&lt;/p&gt;
&lt;p&gt;「ある程度」というのは、つまり、完全に従っているというわけではありません。規格にせよ伝統的な慣習にせよ、古いルールは現代的な観点から許容すべきでないルールも少なくありません。例えば&lt;code&gt;-x&lt;/code&gt;と&lt;code&gt;-X&lt;/code&gt;が区別されて異なる挙動をするというのは絶対にナシでしょう。あるいは広く使われているものでもバンドリング、&lt;code&gt;-fdx&lt;/code&gt;は&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;と解釈されるといったものも、あまり良いとは思えません。バンドリングに関しては、パフォーマンス上でも、パース処理を複雑化させるため問題があります。&lt;/p&gt;
&lt;p&gt;ConsoleAppFrameworkで優先しているのはパフォーマンスであるため、パフォーマンス上問題を引き起こす可能性のあるルールに関しては採用していません。大文字小文字の区別はしないようにしていますが、これは小文字のマッチングを先に行った後、フォールバックとしてcase-insensitiveのマッチングを行うため、実用上のパフォーマンスの低下は起こらないと考えています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/commandline/syntax"&gt;System.CommandLine のコマンド ライン構文の概要 - .NET | Microsoft Learn&lt;/a&gt;を見ると、System.CommandLineがかなり柔軟な構文解釈を可能にしていることがわかるでしょう。それはとても良いことです！良いことではあるのですが、パフォーマンス劣化を引き起こしているなら問題です。そして実際、System.CommandLineの性能はベンチマーク結果から明らかなとおり、非常に悪い。これはちょっといただけません。&lt;/p&gt;
&lt;p&gt;迷走を続けている&lt;a href="https://github.com/dotnet/command-line-api"&gt;System.CommandLine&lt;/a&gt;は、どうやら再度分解されて実装を変更するようです。&lt;a href="https://github.com/dotnet/command-line-api/issues/2338"&gt;Resetting System.CommandLine&lt;/a&gt;ということで、POSIX規格のパーサーとしての小さなコアを.NET 9 あるいは .NET 10で標準採用されることを目指している、ようです。&lt;/p&gt;
&lt;p&gt;もしそれらが標準採用されたとしても、パフォーマンスの観点からは、ConsoleAppFrameworkを超えることは絶対にないでしょう。&lt;/p&gt;
&lt;h2&gt;v4からの互換性について&lt;/h2&gt;
&lt;p&gt;破壊的変更！破壊的変更を厭わないことはいいことです、イノベーションを妨げない、常に先端的であり続けるために必要なことです。C#の先端を走り続けるのはCysharpのアイデンティティでもあります。と、同時に、もちろん大迷惑なことです。今回の v4 -&amp;gt; v5 に関しては .NET Frameworkから.NET Coreに変わったような、 ASP.NET から ASP.NET Coreに変わったような、そんな変革なのでしょうがない、どうしても必要な変化だったのだ……。&lt;/p&gt;
&lt;p&gt;ただし、実際のところは別にそこまで大きく変わっているわけではなかったりもします。名前変換処理(lower-kebab-case)のロジックは同じものを使っているため、名前がズレてしまうといったこともないので、コンパイルエラー出たメソッド名をマッピングするだけ、ではあります。そのぐらいのことはよくある、よね？&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create(args); app.Run(); -&amp;gt; var app = ConsoleApp.Create(); app.Run(args);
app.AddCommand/AddSubCommand -&amp;gt; app.Add(string commandName)
app.AddRootCommand -&amp;gt; app.Add(&amp;quot;&amp;quot;)
app.AddCommands&amp;lt;T&amp;gt; -&amp;gt; app.Add&amp;lt;T&amp;gt;
app.AddSubCommands&amp;lt;T&amp;gt; -&amp;gt; app.Add&amp;lt;T&amp;gt;(string commandPath)
app.AddAllCommandType -&amp;gt; NotSupported(use Add&amp;lt;T&amp;gt; manually)
[Option(int index)] -&amp;gt; [Argument]
[Option(string shortName, string description)] -&amp;gt; Xml Document Comment
ConsoleAppFilter.Order -&amp;gt; NotSupported(global -&amp;gt; class -&amp;gt; method declrative order)
ConsoleAppOptions.GlobalFilters -&amp;gt; app.UseFilter&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全体的には、より単純化された、ようするに「良くなった」と思ってもらえる仕様変更だとは思います。&lt;/p&gt;
&lt;p&gt;また、標準で &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; に乗っからなくなったというのは大きな違いですが、これは一行追加するだけで解決します。Hostingの上に乗っかるというのは、つまりはHostingで生成するServiceProviderを使う、それだけのことなのだ、と。実際はLifetime管理もありますが、それはConsoleAppFrameworkが自前でやっているので、DIのためのServiceProviderだけ渡してやれば実用上の違いはありません。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using var host = Host.CreateDefaultBuilder().Build(); // use using for host lifetime
ConsoleApp.ServiceProvider = host.ServiceProvider;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;v4では&lt;code&gt;ConsoleAppBase&lt;/code&gt;を継承させていましたが、v5ではPOCOでよくなりました。代わりに&lt;code&gt;ConsoleAppContext&lt;/code&gt;や&lt;code&gt;CancellationToken&lt;/code&gt;に関してはコンストラクタインジェクションで受け取ってください。これも、C# 12のprimary constructorのお陰でそんなに手間じゃなくなりました。これもベースクラスを必要とする仕組みをやめた理由の一つになります。&lt;/p&gt;
&lt;h2&gt;真のIncremental Generator&lt;/h2&gt;
&lt;p&gt;Incremental Generatorって、ただたんに何も考えずに作るとIncrementalにならないのです。というのは知識として知ってはいたのですが、今まで見て見ぬふりをしていました！ありがたいことに指摘が入ったので、重い腰を上げてちゃんと抜本的な対応を取ることにしました。&lt;/p&gt;
&lt;p&gt;まず最初にやらなければならないのは、Incrementalであるかどうかを視認できるようにすることです。普通に動かしていても内部状態は全く見えないので、ユニットテストで状態をチェックできるようにすることが大事です。例えばこんなユニットテストが書かれています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;    [Fact]
    public void RunLambda()
    {
        var step1 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&amp;gt; 0);
&amp;quot;&amp;quot;&amp;quot;;

        var step2 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&amp;gt; 100); // body change

Console.WriteLine(&amp;quot;foo&amp;quot;); // unrelated line
&amp;quot;&amp;quot;&amp;quot;;

        var step3 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int (int x, int y) =&amp;gt; 100); // change signature

Console.WriteLine(&amp;quot;foo&amp;quot;);
&amp;quot;&amp;quot;&amp;quot;;

        var reasons = CSharpGeneratorRunner.GetIncrementalGeneratorTrackedStepsReasons(&amp;quot;ConsoleApp.Run.&amp;quot;, step1, step2, step3);

        reasons[0][0].Reasons.Should().Be(&amp;quot;New&amp;quot;);
        reasons[1][0].Reasons.Should().Be(&amp;quot;Unchanged&amp;quot;);
        reasons[2][0].Reasons.Should().Be(&amp;quot;Modified&amp;quot;);

        VerifySourceOutputReasonIsCached(reasons[1]);
        VerifySourceOutputReasonIsNotCached(reasons[2]);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Incremental Generatorは &lt;code&gt;trackIncrementalGeneratorSteps: true&lt;/code&gt; というオプションを渡してDriverを動かすと、各ステップの状態の結果が見えるようになります。&lt;code&gt;IncrementalStepRunReason&lt;/code&gt;には&lt;code&gt;New&lt;/code&gt;, &lt;code&gt;Unchanged&lt;/code&gt;, &lt;code&gt;Modified&lt;/code&gt;, &lt;code&gt;Cached&lt;/code&gt;, &lt;code&gt;Removed&lt;/code&gt; という状態があり、最終出力の手前が&lt;code&gt;Unchanged&lt;/code&gt;か&lt;code&gt;Cached&lt;/code&gt;なら、出力処理がスキップされます。&lt;/p&gt;
&lt;p&gt;上のユニットテストではstep2では出力コードに変更のない箇所に変更が加わっただけなので、Unchangedです。なので最終段ではCachedになっていました。step3は再生成が必要な変更が加わっているのでModifiedとなり、ソースコード生成処理まで走ります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IncrementalStepRunReason&lt;/code&gt;は&lt;code&gt;TrackedSteps&lt;/code&gt;から取り出すことが出来るのですが、そのままだとちょっと読みづらすぎるので、確認しやすいように整形しています、というのが&lt;code&gt;GetIncrementalGeneratorTrackedStepsReasons&lt;/code&gt;というユーティリティメソッドです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static (string Key, string Reasons)[][] GetIncrementalGeneratorTrackedStepsReasons(string keyPrefixFilter, params string[] sources)
{
    var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp12); // 12
    var driver = CSharpGeneratorDriver.Create(
        [new ConsoleAppGenerator().AsSourceGenerator()],
        driverOptions: new GeneratorDriverOptions(IncrementalGeneratorOutputKind.None, trackIncrementalGeneratorSteps: true))
        .WithUpdatedParseOptions(parseOptions);

    var generatorResults = sources
        .Select(source =&amp;gt;
        {
            var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));
            driver = driver.RunGenerators(compilation);
            return driver.GetRunResult().Results[0];
        })
        .ToArray();

    var reasons = generatorResults
        .Select(x =&amp;gt; x.TrackedSteps
            .Where(x =&amp;gt; x.Key.StartsWith(keyPrefixFilter) || x.Key == &amp;quot;SourceOutput&amp;quot;)
            .Select(x =&amp;gt;
            {
                if (x.Key == &amp;quot;SourceOutput&amp;quot;)
                {
                    var values = x.Value.Where(x =&amp;gt; x.Inputs[0].Source.Name?.StartsWith(keyPrefixFilter) ?? false);
                    return (
                        x.Key,
                        Reasons: string.Join(&amp;quot;, &amp;quot;, values.SelectMany(x =&amp;gt; x.Outputs).Select(x =&amp;gt; x.Reason).ToArray())
                    );
                }
                else
                {
                    return (
                        Key: x.Key.Substring(keyPrefixFilter.Length),
                        Reasons: string.Join(&amp;quot;, &amp;quot;, x.Value.SelectMany(x =&amp;gt; x.Outputs).Select(x =&amp;gt; x.Reason).ToArray())
                    );
                }
            })
            .OrderBy(x =&amp;gt; x.Key)
            .ToArray())
        .ToArray();

    return reasons;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ごちゃごちゃしてよくわからないという感じですが、つまりそのままだと本当によくわからない代物ということで。Keyに関しては各ステップで &lt;code&gt;.WithTrackingName(&amp;quot;ConsoleApp.Run.0_CreateSyntaxProvider&amp;quot;)&lt;/code&gt; のような命名規則で付与しています。TrackedStepsが&lt;code&gt;ImmutableDictionary&lt;/code&gt;のため列挙の順番が順不同でイマイチ確認しづらいので、番号振ってソートするようにしました。また、複数のRegisterSourceOutputが走っていると(ConsoleAppFrameworkではRun系とBuilder系の2種が動いてる)混線してわかりづらくなるため、keyPrefixとしてフィルタリングするようにしています。&lt;/p&gt;
&lt;p&gt;注意すべき点とか、いい感じに作る方法とか、色々説明しておかなければならないことが多いのですが、めちゃくちゃ長くなるので、それはまたの機会ということで……！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;もともとConsoleAppFrameworkはCysharpの製品ラインでは珍しく、パフォーマンスを重視していたわけではない、という成り立ちがあります。どちらかというと機能面、当時それなりに珍しかったHostingと融合してCLIフレームワークを作るといったコンセプトの立証を主軸に作り上げ、そして一定の成果を挙げました。何回かの改修でHelpがリッチになったりMinimal APIっぽく書けるようになったりもしましたが、どうしても古くささが目立ってきました。&lt;/p&gt;
&lt;p&gt;特に&lt;a href="https://github.com/mayuki/Cocona"&gt;Cocona&lt;/a&gt;は、ConsoleAppFrameworkの影響を受けつつも、より柔軟で、より強力な機能を備えていてとても素晴らしいライブラリです。このままではConsoleAppFrameworkはただの劣化版ではないか、という意識もありました。自信をもってベストであると薦められないのは心苦しい。というかCoconaを作っているのはCysharpの同僚ですしですの。&lt;/p&gt;
&lt;p&gt;なので、今回APIの幾つかは逆にCoconaからの影響を受けつつ(&lt;code&gt;[Argument]&lt;/code&gt;など)、全く異なるキャラクターを持ったフレームワークとなるように腐心しました。パースについての項目で説明したように、ConsoleAppFramework v5は柔軟性をある程度犠牲にしているため、豊富な機能が必要ならば、System.CommandLineやCoconaを使用することをお薦めします。&lt;/p&gt;
&lt;p&gt;また、パフォーマンスの観点から言うと、本体の実行時間が長ければ長いほどフレームワークのオーバーヘッドなんてどうでもよくはなります。10分、1分、いや、10秒ぐらいかかる処理であるなら、フレームワーク部分が1msだろうと50msだろうと誤差みたいなものでしょう。それはそもそもJITコンパイルにも言えることではありますが。とはいえ、Native AOTだのコールドスタートアップ速度だのがやいやい言われる昨今では、別にそんなもの無視できる程度の話だろう、と一刀両断できるわけでもなく、早いに越したことはないのは間違いないとも言えます。&lt;/p&gt;
&lt;p&gt;パフォーマンスや依存性なしといったメリットはもちろんですが、アプローチや設計面でも特異で面白いものになっていると思いますので、是非お試しください！もちろん、実用性もめちゃくちゃ高く、文句なしに必須ライブラリと考えてもらってもいいのではないでしょうか！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-06-13T00:00:00+09:00</a10:updated>
    </item>
  </channel>
</rss>