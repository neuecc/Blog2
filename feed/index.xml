<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>neue cc</title>
    <link>http://neue.cc/</link>
    <description>C# Technical Blog</description>
    <language>ja</language>
    <lastBuildDate>Mon, 14 Jul 2025 10:09:35 +0900</lastBuildDate>
    <item>
      <guid isPermaLink="true">https://neue.cc/2025/07/14_mvp-renew15.html</guid>
      <link>https://neue.cc/2025/07/14_mvp-renew15.html</link>
      <title>Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々々受賞しました</title>
      <description>&lt;h1 data-pagefind-sort="date:2025-07-14" data-pagefind-meta="published:2025-07-14"&gt;&lt;a href="https://neue.cc/2025/07/14_mvp-renew15.html"&gt;Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々々受賞しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2025-07-14&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Microsoft MVPは一年ごとに再審査されるのですが、今年も更新しました。2011年から初めて15回目です。昨今の予算の事情を考えると、席も少なくなっているのではないかという気配があるので、いつまでも居座るのはどうなのかという気もしますが、まぁ実績出してるから、しょうがないね……？&lt;/p&gt;
&lt;p&gt;毎年新しいOSSでヒット作を出すのも大変ですよ、と思いつつ去年は&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;、今年は&lt;a href="https://github.com/Cysharp/ZLinq"&gt;ZLinq&lt;/a&gt;を出しました。これは文句なしでいいんじゃないかと。ZLinqは本当に作るの大変だったんで報われたい（？）&lt;/p&gt;
&lt;p&gt;今回の審査期間中の対外的な発表は以下の3つがありました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/dot-netnofei-tong-qi-zhan-lue-tounitytonoxiang-hu-yun-yong"&gt;.NETの非同期戦略とUnityとの相互運用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/r3nokodokarajian-rushi-jian-linqshi-zhuang-zui-shi-hua-konkarentopuroguramingushi-li"&gt;R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/cysharpnoossqun-karajian-rumodern-c-number-noxian-zai-di"&gt;CysharpのOSS群から見るModern C#の現在地&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2025年に入ってからは何もやっていないので、何か機会があれば、と伺ってはいるのですが中々どうして。今年はAI関連に力を入れたいと思っているので、まずはOSSで何か出してから、というのがいつもの自分のパターンなので、それは近々出します……！あとはZLinqに関してはアーキテクチャを話す場が作れるといいんですが、まぁそのうちどこかで。今のところ予定は完全に未定です。&lt;/p&gt;
&lt;p&gt;自社のタイトルではないので私のほうから大きく言えることはないのですが、先日は&lt;a href="https://shadowverse-wb.com/ja/"&gt;大きなタイトル&lt;/a&gt;がリリースされたというのもあるので、そういったところからもC#(クライアント/サーバー)の力を世の中にアピールできるといいな、とは思っています。&lt;/p&gt;
&lt;p&gt;というわけで引き続き、C#の推進やっていきます！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 14 Jul 2025 00:00:00 +0900</pubDate>
      <a10:updated>2025-07-14T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2025/05/05_ZLinq.html</guid>
      <link>https://neue.cc/2025/05/05_ZLinq.html</link>
      <title>ゼロアロケーションLINQライブラリ「ZLinq」のリリースとアーキテクチャ解説</title>
      <description>&lt;h1 data-pagefind-sort="date:2025-05-05" data-pagefind-meta="published:2025-05-05"&gt;&lt;a href="https://neue.cc/2025/05/05_ZLinq.html"&gt;ゼロアロケーションLINQライブラリ「ZLinq」のリリースとアーキテクチャ解説&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2025-05-05&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ZLinq"&gt;ZLinq&lt;/a&gt; v1を先月リリースしました！structとgenericsベースで構築することによりゼロアロケーションを達成しています。またLINQ to Span, LINQ to SIMD, LINQ to Tree(FileSystem, JSON, GameObject, etc.)といった拡張要素と、任意の型のDrop-in replacement Source Generator。そして.NET Standard 2.0, Unity, Godotなどの多くのプラットフォームサポートまで含めた大型のライブラリとなっています！現在GitHub Starsも2000を超えました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZLinq"&gt;https://github.com/Cysharp/ZLinq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;structベースのLINQそのものは珍しいものではなく、昔から多くの実装が挑戦してきました。しかし、真に実用的と言えるものはこれまでありませんでした。極度なアセンブリサイズの肥大化、オペレーターの網羅の不足、最適化不足で性能が劣るなど、実験的な代物を抜け切れていないものばかりでした。ZLinqでは実用的に使えるものを目指し、.NET 10(Shuffle, RightJoin, LeftJoinなど新しいものも含む)に含まれる全てのメソッドとオーバーロードの100%のカバーと、99%の挙動の互換性の確保、そしてアロケーションだけではなく、SIMD化も含めて、多くのケースにおける性能面で勝てるように実装しました。&lt;/p&gt;
&lt;p&gt;それが出来るのは、そもそも私のLINQ実装の経験はものすごく長くて、2009年4月に&lt;a href="https://github.com/neuecc/linq.js/"&gt;linq.js&lt;/a&gt;というJavaScript用のLINQ to Objectsライブラリを公開しています(linq.jsは現在もForkした人が今もメンテナンスされているようです、素晴らしい！)。他にもUnityで広く使われているReactive Extensionsライブラリ&lt;a href="https://github.com/neuecc/UniRx"&gt;UniRx&lt;/a&gt;を実装し、直近ではそれの進化版である&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;を公開したばかりです。バリエーションとしても&lt;a href="https://assetstore.unity.com/packages/tools/integration/linq-to-gameobject-24256"&gt;LINQ to GameObject&lt;/a&gt;、&lt;a href="https://github.com/neuecc/LINQ-to-BigQuery"&gt;LINQ to BigQuery&lt;/a&gt;、&lt;a href="https://github.com/Cysharp/SimdLinq/"&gt;SimdLinq&lt;/a&gt;といったものを作っていました。これらに、ゼロアロケーション関連ライブラリ(&lt;a href="https://github.com/Cysharp/ZString"&gt;ZString&lt;/a&gt;, &lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;)やハイパフォーマンスシリアライザー(&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/"&gt;MessagePack-CSharp&lt;/a&gt;, &lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;)の知見を掛け合わせることで、標準ライブラリの上位互換という野心的目標を達成できました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/raw/main/img/benchmarkhead.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;これはシンプルなベンチマークで、Where, Where.Take, Where.Take.Selectとメソッドチェーンを重ねれば重ねるほど、通常はアロケーションが増えていきますがZLinqはずっとゼロです。&lt;/p&gt;
&lt;p&gt;性能は元のソース、個数、値の型、そしてメソッドの繋げ方によって変わってきます。多くのケースで性能面で有利なことを確認するために、ZLinqでは様々なケースのベンチマークを用意し、GitHub Actions上で走らせています。&lt;a href="https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yaml"&gt;ZLinq/actions/Benchmark&lt;/a&gt;。構造上どうしても負けてしまうケースも存在はするのですが、現実的なケースではほとんど勝っています。&lt;/p&gt;
&lt;p&gt;ベンチマーク上極端に差が出るものでいえば、シンプルにSelectを複数回繰り返したものは、SystemLinqもZLinqも特殊な最適化が入っていないケースになりますが、大きな性能差が出ています。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_1.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;シンプルなケースでは、DistinctやOrderByなど中間バッファを必要とするものは、積極的なプーリングによりアロケーションを大きく抑えているため、差が大きくなります(ZLinqは原則&lt;code&gt;ref strcut&lt;/code&gt;であり短寿命が期待できるため、プーリング利用はややアグレッシブにしています)。例えばこのベンチマークはDistinctです。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_2.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;LINQはメソッド呼び出しのパターンにより特殊な最適化がかかるなど、アロケーションを抑えるだけでは性能面で常に勝てるわけではありません。そうしてオペレーターの繋がりによる最適化に関しても、これは.NET 9で最適化されたパターンとして&lt;a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/"&gt;Performance Improvements in .NET 9&lt;/a&gt;で紹介されている例ですが、ZLinqではそれらの最適化を全て実装し、より高いパフォーマンスを引き出しています。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_3.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;ZLinqの良いところとして、これらLINQの進化による最適化の恩恵を、最新の.NETだけではなく、全ての世代の.NET(.NET Frameworkも含む)が得られることでもあります。&lt;/p&gt;
&lt;p&gt;利用法はシンプルに、&lt;code&gt;AsValueEnumerable()&lt;/code&gt;呼び出しを追加するだけです。オペレーターに関しては100%網羅しているので、既存コードからの置き換えも全て問題なくコンパイルが通り、動作します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq;

var seq = source
    .AsValueEnumerable() // only add this line
    .Where(x =&amp;gt; x % 2 == 0)
    .Select(x =&amp;gt; x * 3);

foreach (var item in seq) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ZLinqでは挙動の互換性を保証するために、dotnet/runtimeのSystem.Linq.Testsを移植して &lt;a href="https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests"&gt;ZLinq/System.Linq.Tests&lt;/a&gt; 常に走らせています。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/raw/main/img/testrun.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;9000件のテストケースのカバーにより、動作を保証しています（Skipしているケースはref structであるため、同一テストコードを動かせない場合によるものなど）&lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;AsValueEnumerable()&lt;/code&gt; すら省略したDrop-In Replacementを任意で有効化するSource Generatorも提供しています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[assembly: ZLinq.ZLinqDropInAttribute(&amp;quot;&amp;quot;, ZLinq.DropInGenerateTypes.Everything)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/raw/main/img/dropin.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;この仕組みにより、Drop-In Replacementの範囲を自由にコントロールすることができます。&lt;code&gt;ZLinq/System.Linq.Tests&lt;/code&gt;自体がDrop-In Replacementにより、既存テストコードを変えずにZLinqで動作するようになっています。&lt;/p&gt;
&lt;h2&gt;ValueEnumerableのアーキテクチャと最適化&lt;/h2&gt;
&lt;p&gt;使い方などはReadMeを参照してもらえればいいので、ここでは最適化の話を深堀します。ただたんなるシーケンスを遅延実行するだけ、ではないところが、アーキテクチャ上の特色であり、他の言語のコレクション処理ライブラリと比べても、多くの工夫が詰まっています。&lt;/p&gt;
&lt;p&gt;連鎖のベースとなる&lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;の定義はこうなっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public readonly ref struct ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;(TEnumerator enumerator)
    where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;, allows ref struct // allows ref structは.NET 9以上の場合のみ
{
    public readonly TEnumerator Enumerator = enumerator;
}

public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable
{
    bool TryGetNext(out T current); // as MoveNext + Current

    // Optimization helper
    bool TryGetNonEnumeratedCount(out int count);
    bool TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span);
    bool TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを基にして、例えばWhereなどのオペレーターはこうした連鎖が続きます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static ValueEnumerable&amp;lt;Where&amp;lt;TEnumerator, TSource&amp;gt;, TSource&amp;gt; Where&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Func&amp;lt;TSource, Boolean&amp;gt; predicate)
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;ではなくてこのようなアプローチを取ったのは、&lt;code&gt;(this TEnumerable source) where TEnumerable : struct, IValueEnumerable&amp;lt;TSource&amp;gt;&lt;/code&gt;のような定義にすると、&lt;code&gt;TSource&lt;/code&gt;への型推論が効かなくなります。これはC#が型引数の制約からは型推論をしないという言語仕様上の制限(&lt;a href="https://github.com/dotnet/csharplang/discussions/6930"&gt;dotnet/csharplang#6930&lt;/a&gt;)があるためで、もしそのような定義のまま実装をすると、インスタンスメソッドとして大量の組み合わせを定義することになります。それをやったのが&lt;a href="https://github.com/kevin-montrose/LinqAF"&gt;LinqAF&lt;/a&gt;であり、その結果&lt;a href="https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/"&gt;100,000+ methods and massive assembly sizes&lt;/a&gt;ということで、あまり良い結果をもたらしていません。&lt;/p&gt;
&lt;p&gt;LINQにおいては実装は全て&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;側にあり、また、全てのEnumeratorはstructのため、&lt;code&gt;GetEnumerator()&lt;/code&gt;ではなくて、共通で&lt;code&gt;Enumerator&lt;/code&gt;のコピー渡しするだけで、それぞれのEnumeratorが独立したステートで処理できることに気付いたので、&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;を&lt;code&gt;ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt;でラップするだけ、という構成に最終的になりました。これにより型が制約側ではなくて型宣言側に現れるので、型推論での問題もありません。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TryGetNext&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;次にイテレートの本体であるMoveNextについて詳しく見ていきましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Traditional interface
public interface IEnumerator&amp;lt;out T&amp;gt; : IDisposable
{
    bool MoveNext();
    T Current { get; }
}

// iterate example
while (e.MoveNext())
{
    var item = e.Current; // invoke get_Current()
}

// ZLinq interface
public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable
{
    bool TryGetNext(out T current);
}

// iterate example
while (e.TryGetNext(out var item))
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C#の &lt;code&gt;foreach&lt;/code&gt; は &lt;code&gt;MoveNext() + Current&lt;/code&gt; に展開されるわけですが、問題が二点あります。一つはメソッド呼び出し回数で、イテレート毎にMoveNextとget_Currentの2回必要です。もう一つはCurrentのために、変数を保持する必要があること。そこで、それらを&lt;code&gt;bool TryGetNext(out T current)&lt;/code&gt;にまとめました。これによりメソッド呼び出し回数が一度で済みパフォーマンス上有利です。&lt;/p&gt;
&lt;p&gt;なお、この &lt;code&gt;bool TryGetNext(out T current)&lt;/code&gt; 方式は、例えば&lt;a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"&gt;Rustのイテレーター&lt;/a&gt;で採用されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-Rust"&gt;pub trait Iterator {
    type Item;
    // Required method
    fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変数の保持に関してはピンとこないと思うので、例としてSelectの実装を見てください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public sealed class LinqSelect&amp;lt;TSource, TResult&amp;gt;(IEnumerator&amp;lt;TSource&amp;gt; source, Func&amp;lt;TSource, TResult&amp;gt; selector) : IEnumerator&amp;lt;TResult&amp;gt;
{
    // フィールドが3つ
    IEnumerator&amp;lt;TSource&amp;gt; source = source;
    Func&amp;lt;TSource, TResult&amp;gt; selector = selector;
    TResult current = default!;

    public TResult Current =&amp;gt; current;

    public bool MoveNext()
    {
        if (source.MoveNext())
        {
            current = selector(source.Current);
            return true;
        }

        return false;
    }
}

public ref struct ZLinqSelect&amp;lt;TEnumerator, TSource, TResult&amp;gt;(TEnumerator source, Func&amp;lt;TSource, TResult&amp;gt; selector) : IValueEnumerator&amp;lt;TResult&amp;gt;
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
{
    // フィールドが2つ
    TEnumerator source = source;
    Func&amp;lt;TSource, TResult&amp;gt; selector = selector;

    public bool TryGetNext(out TResult current)
    {
        if (source.TryGetNext(out var value))
        {
            current = selector(value);
            return true;
        }

        current = default!;
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;は&lt;code&gt;MoveNext()&lt;/code&gt;で進めて&lt;code&gt;Current&lt;/code&gt;で返す、という都合上、&lt;code&gt;Current&lt;/code&gt;のフィールドが必要です。ところがZLinqでは進めると同時に値を返すため、フィールドに保持する必要がありません。これは、全体が&lt;code&gt;struct&lt;/code&gt;ベースで構築されているZLinqではかなり大きな違いがあります。ZLinqではメソッドチェーンの度に、以前のstructを丸ごと抱える(&lt;code&gt;TEnumerator&lt;/code&gt;がstruct)構造になるため、メソッドチェーンを重ねる度に構造体のサイズが肥大化していきます。常識的な範囲内でメソッドチェーンを重ねる限りは、パフォーマンス上も問題にはなっていなかったのですが、それでも小さければ小さいほどコピーコストが小さくなり性能面で有利にはなります。1バイトでも構造体を小さくする、ためにも&lt;code&gt;TryGetNext&lt;/code&gt;の採用は必然でした。&lt;/p&gt;
&lt;p&gt;TryGetNextの欠点は、共変・反変をサポートできないことです。ただし私は、そもそもイテレーターや配列から共変・反変のサポートは撤廃すべきだと思っています。&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;との相性が悪いため、メリット・デメリットを天秤にかけると、時代遅れの概念だと言えます。具体例を出すと、配列のSpan化は失敗する可能性があり、それはコンパイル時には検出できず実行時エラーとなります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// ジェネリクスの変性によりDerived[]をBase[]で受け取る。
Base[] array = new Derived[] { new Derived(), new Derived() };

// その場合、Span&amp;lt;T&amp;gt;へのキャストやAsSpan()は実行時エラーになる！
// System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.
Span&amp;lt;Base&amp;gt; foo = array;

class Base;
class Derived : Base;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;以前に追加された機能のため、もうどうにもならないとは思いますが、現代の.NETはあらゆるところでSpanが活用されるようになっているので、それが実行時エラーになる可能性をはらんでいる時点で、使い物にならないと考えてもいいはずです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TryGetNonEnumeratedCount / TryGetSpan / TryCopyTo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全てを愚直に列挙するだけだと、パフォーマンスは最大化されません。例えばToArrayするときに、もしサイズの変動がないなら(&lt;code&gt;array.Select().ToArray()&lt;/code&gt;)、&lt;code&gt;new T[count]&lt;/code&gt;のように固定長配列を作ることができます。SystemLinqでも、そうした最適化を実現するために、内部的には&lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt;型が使われているのですが、引数は&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;のため、必ず &lt;code&gt;if (source is Iterator&amp;lt;TSource&amp;gt; iterator)&lt;/code&gt; のようなコードが必要になっています。&lt;/p&gt;
&lt;p&gt;ZLinqでは最初からLINQのための定義を前提にできるため、すべて織り込み済みで用意しています。ただし、むやみやたらに増やすのはアセンブリサイズの肥大化を招くため、必要最小限の定義で、最大限の効果を生み出すように調整したのが、この3つのメソッドとなっています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryGetNonEnumeratedCount(out int count)&lt;/code&gt;は、元のソースが有限の個数であり、途中にフィルタリング系メソッド(WhereやDistinctなど。TakeやSkipは算出可能なため含まない)が挟まらない場合は成功します。ToArrayなどのほか、OrderByやShuffleなど中間バッファが必要な時に効果が出るケースもあります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span)&lt;/code&gt;は、元ソースが連続的なメモリとして取得できる場合には、オペレーターによってはSIMDが適用されて劇的なパフォーマンス向上に繋がったり、Spanによるループ処理によって集計パフォーマンスが高まるなど、性能面で大きな違いをもたらす可能性があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset)&lt;/code&gt;は内部イテレーターによってパフォーマンスを向上させる仕組みです。外部イテレーターと内部イテレーターについて説明すると、例えば&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;は&lt;code&gt;foreach&lt;/code&gt;と&lt;code&gt;ForEach&lt;/code&gt;の両方が選べます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// external iterator
foreach (var item in list) { Do(item); }

// internal iterator
list.ForEach(Do);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;見た目は似ていますが、性能面で違いがあります。foreachは素直な構文で書けている。ForEachはデリゲート渡し。処理の実体まで分解すると&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// external iterator
List&amp;lt;T&amp;gt;.Enumerator e = list.GetEnumerator();
while (e.MoveNext())
{
    var item = e.Current;
    Do(item);
}

// internal iterator
for (int i = 0; i &amp;lt; _size; i++)
{
    action(_items[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これはデリゲート呼び出し(+デリゲート生成アロケーション)のオーバーヘッド vs イテレーターのMoveNext + Current呼び出しの対決になっていて、イテレート速度自体は内部イテレーターのほうが速い。この場合デリゲート呼び出しのほうが軽量な場合があり、ベンチマーク的に内部イテレーターのほうが有利な可能性があります。&lt;/p&gt;
&lt;p&gt;もちろん、ケースバイケースであることと、ラムダ式にキャプチャが発生したり、普通の制御構文が使えない(continueなど)ことから、私としては&lt;code&gt;ForEach&lt;/code&gt;は使うべきではないし、拡張メソッドで&lt;code&gt;ForEach&lt;/code&gt;のようなものを独自定義すべきではない、とも思っていますが、原理的にはこのような違いが存在します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset)&lt;/code&gt;は、デリゲートではなく&lt;code&gt;Span&lt;/code&gt;を受け取ることで限定的に内部イテレーター化しました。&lt;/p&gt;
&lt;p&gt;これもSelectを例に出すと、ToArrayの場合にCountが取れているとSpanを渡して内部イテレーターで処理します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public ref struct Select
{
    public bool TryCopyTo(Span&amp;lt;TResult&amp;gt; destination, Index offset)
    {
        if (source.TryGetSpan(out var span))
        {
            if (EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))
            {
                // loop inlining
                for (var i = 0; i &amp;lt; slice.Length; i++)
                {
                    destination[i] = selector(slice[i]);
                }
                return true;
            }
        }
        return false;
    }
}

// ToArray
if (enumerator.TryGetNonEnumeratedCount(out var count))
{
    var array = GC.AllocateUninitializedArray&amp;lt;TSource&amp;gt;(count);

    // try internal iterator
    if (enumerator.TryCopyTo(array.AsSpan(), 0))
    {
        return array;
    }

    // otherwise, use external iterator
    var i = 0;
    while (enumerator.TryGetNext(out var item))
    {
        array[i] = item;
        i++;
    }

    return array;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、SelectはSpanは作れませんが、元ソースがSpanを作れるなら、内部イテレーターとして処理することでループ処理を高速化することが可能です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TryCopyTo&lt;/code&gt;の定義は普通の&lt;code&gt;CopyTo&lt;/code&gt;と違って、&lt;code&gt;Index offset&lt;/code&gt;を持っています。また、destinationはソースサイズよりも小さいことを許しています（通常の.NETのCopyToはdestinationが小さいと失敗する)。これによって、destinationのサイズが1の場合、IndexによってElementAtが表現できます。そして0ならFirstだし^1の場合はLastになります。&lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;自体に&lt;code&gt;First&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;を持たせると、クラス定義として無駄が多くなってしまいますが（アセンブリサイズにも影響が出る）、小さいdestinationとIndexを持たせることにより、一つのメソッドでより多くの最適化ケースをカバーできるようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static TSource ElementAt&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Index index)
    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct
{
    using var enumerator = source.Enumerator;
    var value = default(TSource)!;
    var span = new Span&amp;lt;T&amp;gt;(ref value); // create single span
    if (enumerator.TryCopyTo(span, index))
    {
        return value;
    }
    // else...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ところで、このTryGetNextや内部イテレーターに関しては、2007年の時点で &lt;a href="https://nyaruru.hatenablog.com/entry/20070818/p1"&gt;https://nyaruru.hatenablog.com/entry/20070818/p1&lt;/a&gt; で紹介されていました。この記事はずっと頭に残っていて、ようやくこうして20年経って理屈通りの実現ができました。という点でも少し感慨深いです。2008年前後はLINQ登場前後ということで、このあたりの話がアツかった時代なんですよねー。&lt;/p&gt;
&lt;h2&gt;LINQ to Span&lt;/h2&gt;
&lt;p&gt;ZLinqは .NET 9 以上であれば、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;に対しても、全てのLINQオペレーターを繋げることができます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq;

// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)
Span&amp;lt;int&amp;gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 };
var seq1 = span.AsValueEnumerable().Select(x =&amp;gt; x * x);

// If enables Drop-in replacement, you can call LINQ operator directly.
var seq2 = span.Select(x =&amp;gt; x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Span対応のLINQを謳ったライブラリも、世の中には多少ありますが、それらは&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;にだけ拡張メソッドを定義する、といったようなものであり、汎用的な仕組みではありませんでした。網羅されるオペレーターも制約があり、一部のものに限られていました。それは言語的にも&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;をジェネリクス引数として受け取ることができなかったためで、汎用的に処理できるようになったのは .NET 9で&lt;code&gt;allows ref struct&lt;/code&gt;が登場してくれたおかげです。&lt;/p&gt;
&lt;p&gt;ZLinqでは&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;と&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;に何の区別もありません、全て平等に取り扱われます。&lt;/p&gt;
&lt;p&gt;ただし、&lt;code&gt;allows ref struct&lt;/code&gt;の言語/ランタイムサポートが必要なため、&lt;code&gt;ZLinq自体は&lt;/code&gt;.NET Standard 2.0以上の全ての.NETをサポートしていますが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;対応に関してのみ.NET 9以上限定の機能となっています。また、これにより.NET 9以上の場合は、全てのオペレーターが&lt;code&gt;ref struct&lt;/code&gt;になっている、という違いがあります。&lt;/p&gt;
&lt;h2&gt;LINQ to SIMD&lt;/h2&gt;
&lt;p&gt;System.Linqでは、一部の集計メソッドがSIMDによって高速化されています。例えば一部のプリミティブ型の配列に直接SumやMaxを呼び出すと高速化されています。これらの呼び出しはforで処理するよりも遥かに高速化されます。とはいえ、&lt;code&gt;IEnumerbale&amp;lt;T&amp;gt;&lt;/code&gt;がベースであるため、適用可能な型が限定的であるなどの欠点を感じています。ZLinqでは&lt;code&gt;IValueEnumeartor.TryGetSpan&lt;/code&gt;によって&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;が取得できる場合が対象となるコレクションとなるため、より汎用的になっています（もちろん&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;に適用することもできます)。&lt;/p&gt;
&lt;p&gt;対応するメソッドは以下のようなものになっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeat&lt;/strong&gt; for &lt;code&gt;unmanaged struct&lt;/code&gt; and &lt;code&gt;size is power of 2&lt;/code&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sum&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SumUnchecked&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Average&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Min&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contains&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SequenceEqual&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sum&lt;/code&gt;はオーバーフローをチェックします。これは処理においてオーバーヘッドとなっているため、独自に&lt;code&gt;SumUnchecked&lt;/code&gt;というメソッドも追加しています。性能差は以下のようになり、Uncheckedのほうがより高速です。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_4.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;これらメソッドは条件がマッチした場合に暗黙的に適用されるということであり、SIMDを狙って適用させるには内部パイプラインへの理解が必要とされています。そこで&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;には&lt;code&gt;.AsVectorizable()&lt;/code&gt;というメソッドを用意しました。SIMD適用可能な&lt;code&gt;Sum&lt;/code&gt;, &lt;code&gt;SumUnchecked&lt;/code&gt;, &lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, and &lt;code&gt;SequenceEqual&lt;/code&gt;を明示的に呼び出すことができます（ただし&lt;code&gt;Vector.IsHardwareAccelerated &amp;amp;&amp;amp; Vector&amp;lt;T&amp;gt;.IsSupported&lt;/code&gt;ではない場合は通常の処理にフォールバックされるため、必ずしもSIMDが適用されることを保証するわけではありません）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;int&amp;gt;&lt;/code&gt;には&lt;code&gt;VectorizedFillRange&lt;/code&gt;というメソッドが追加されます。これは&lt;code&gt;ValueEunmerable.Range().CopyTo()&lt;/code&gt;と同じ処理で、連番で埋める処理がSIMDで高速化されます。連番が必要になる局面で、forで埋めるよりも遥かに高速なので、覚えておくといいかもしれません。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_5.png" alt="" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vectorizable Methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIMDによるループ処理を手書きするのは、慣れが必要で少し手間がいります。そこでFuncを引数に与えることでカジュアルに使えるヘルパーをいくつか用意しました。デリゲートを経由するオーバーヘッドが発生するためインラインで書くよりもパフォーマンスは劣りますが、カジュアルにSIMD処理できるという点では便利かもしれません。これらは引数に&lt;code&gt;Func&amp;lt;Vector&amp;lt;T&amp;gt;, Vector&amp;lt;T&amp;gt;&amp;gt; vectorFunc&lt;/code&gt;と&lt;code&gt;Func&amp;lt;T, T&amp;gt; func&lt;/code&gt;を受け取り、ループの埋められるところまで&lt;code&gt;Vector&amp;lt;T&amp;gt;&lt;/code&gt;で処理し、残りを&lt;code&gt;Func&amp;lt;T&amp;gt;&lt;/code&gt;で処理します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T[]&lt;/code&gt;, &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;には&lt;code&gt;VectorizedUpdate&lt;/code&gt;というメソッドが用意されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ZLinq.Simd; // needs using

int[] source = Enumerable.Range(0, 10000).ToArray();

[Benchmark]
public void For()
{
    for (int i = 0; i &amp;lt; source.Length; i++)
    {
        source[i] = source[i] * 10;
    }
}

[Benchmark]
public void VectorizedUpdate()
{
    // arg1: Vector&amp;lt;int&amp;gt; =&amp;gt; Vector&amp;lt;int&amp;gt;
    // arg2: int =&amp;gt; int
    source.VectorizedUpdate(static x =&amp;gt; x * 10, static x =&amp;gt; x * 10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_6.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;forよりも高速、ですが、パフォーマンスはマシン環境やサイズによって変わるので、盲目的に使うのではなくて、都度検証することをお薦めします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsVectorizable()&lt;/code&gt;には&lt;code&gt;Aggregate&lt;/code&gt;, &lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Select&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;が用意されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;source.AsVectorizable().Aggregate((x, y) =&amp;gt; Vector.Min(x, y), (x, y) =&amp;gt; Math.Min(x, y))
source.AsVectorizable().All(x =&amp;gt; Vector.GreaterThanAll(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);
source.AsVectorizable().Any(x =&amp;gt; Vector.LessThanAll(x, new(5000)), x =&amp;gt; x &amp;lt; 5000);
source.AsVectorizable().Count(x =&amp;gt; Vector.GreaterThan(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パフォーマンスは、データ次第ではありますが一例としてはCountで、このぐらいの差が出ることもあります。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_7.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Select&lt;/code&gt;, &lt;code&gt;Zip&lt;/code&gt;に関しては、後続に&lt;code&gt;ToArray&lt;/code&gt;か&lt;code&gt;CopyTo&lt;/code&gt;を選びます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Select
source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).ToArray();
source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).CopyTo(destination);

// Zip2
array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).CopyTo(destination);
array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).ToArray();

// Zip3
array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).CopyTo(destination);
array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).ToArray();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Zipなんかは結構面白い＆ちゃんと高速なので、使いどころあるかもしれません(2つのVec3のマージとか)。&lt;/p&gt;
&lt;p&gt;&lt;img src="/article_img/20250505_8.png" alt="" /&gt;&lt;/p&gt;
&lt;h2&gt;LINQ to Tree&lt;/h2&gt;
&lt;p&gt;皆さんLINQ to XMLを使ったことはありますか? LINQの登場した2008年は、まだまだXML全盛期で、LINQ to XMLのあまりにも使いやすいAPIには衝撃を受けました。しかし、すっかり時代はJSONでありLINQ to XMLを使うことはすっかりなくなりました。&lt;/p&gt;
&lt;p&gt;しかし、LINQ to XMLの良さというのは、ツリー構造に対するLINQ的操作のリファレンスデザインだと捉えることができます。ツリー構造がLINQになる、そのガイドライン。LINQ to Objectsと非常に相性の良い探索の抽象化。その代表例がRoslynのSyntaxTreeに対する操作で、AnalyzerやSource Generatorを書くのにDescendantsなどのメソッドを日常的に利用しています。&lt;/p&gt;
&lt;p&gt;そこでZLinqはそのコンセプトを拡張し、ツリー構造に対して汎用的に &lt;code&gt;Ancestors&lt;/code&gt;, &lt;code&gt;Children&lt;/code&gt;, &lt;code&gt;Descendants&lt;/code&gt;, &lt;code&gt;BeforeSelf&lt;/code&gt;, and &lt;code&gt;AfterSelf&lt;/code&gt; が適用できるインターフェイスを定義しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLinq/raw/main/img/axis.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;これはUnityのGameObjectへの走査の図ですが、標準でFileSystem(DirectoryTreeはツリー構造)やJSON(System.Text.JsonのJsonNodeに対してLINQ to XML的な操作を可能にする)を用意しています。もちろん、任意にインターフェイスを実装することで追加することもできます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface ITraverser&amp;lt;TTraverser, T&amp;gt; : IDisposable
    where TTraverser : struct, ITraverser&amp;lt;TTraverser, T&amp;gt; // self
{
    T Origin { get; }
    TTraverser ConvertToTraverser(T next); // for Descendants
    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants
    bool TryGetChildCount(out int count);   // optional: optimize use for Children
    bool TryGetParent(out T parent); // for Ancestors
    bool TryGetNextChild(out T child); // for Children | Descendants
    bool TryGetNextSibling(out T next); // for AfterSelf
    bool TryGetPreviousSibling(out T previous); // BeforeSelf
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例えばJSONに対しては&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var json = JsonNode.Parse(&amp;quot;&amp;quot;&amp;quot;
// snip...
&amp;quot;&amp;quot;&amp;quot;);

// JsonNode
var origin = json![&amp;quot;nesting&amp;quot;]![&amp;quot;level1&amp;quot;]![&amp;quot;level2&amp;quot;]!;

// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.
foreach (var item in origin.Descendants().Select(x =&amp;gt; x.Node).OfType&amp;lt;JsonArray&amp;gt;())
{
    // [true, false, true], [&amp;quot;fast&amp;quot;, &amp;quot;accurate&amp;quot;, &amp;quot;balanced&amp;quot;], [1, 1, 2, 3, 5, 8, 13]
    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように書くことができます。&lt;/p&gt;
&lt;p&gt;Unityには&lt;code&gt;GameObject&lt;/code&gt;や&lt;code&gt;Transform&lt;/code&gt;、Godotには&lt;code&gt;Node&lt;/code&gt;へのLINQ to Treeを標準で用意しました。アロケーションや走査のパフォーマンスにかなり気を使って書かれているので、手動でループを回すよりも、もしかしたら高速かもしれません。&lt;/p&gt;
&lt;h2&gt;OSSと私&lt;/h2&gt;
&lt;p&gt;ここ数ヶ月で.NET関連のOSSには幾つか事件がありました。名のしれたOSSの商業ライセンス化、など……。私は、&lt;a href="https://github.com/Cysharp"&gt;github/Cysharp&lt;/a&gt;で出しているOSSの数は40を超え、個人やMessagePack organizationなどのものも含めると、総スター数では50000を超えるなど.NET周りのサードパーティーとしては最大規模でのOSS提供者なのではないかと思います。&lt;/p&gt;
&lt;p&gt;商業化、に関しては予定はありません、が、メンテナンスに関しては規模が大きくなってきたため、追いつかなくなっている面が多々あります。OSSが批判を覚悟で商業化を試みるの要因として、メンテナーに対する精神的な負荷というのが大きい（時間に対しての報酬が全く見合っていない）のですが、私も、まぁ、大変です！&lt;/p&gt;
&lt;p&gt;金銭面は置いておいて、お願い事としては、メンテナンスが滞ることがあることは多少受け入れて欲しい！今回のZLinqのような大きなライブラリを仕込んでいる最中は、集中する時間が必要なため、他のライブラリのIssueやPRへの応答が数ヶ月音信不通になります。意識的に全く見ないようにしています、タイトルすら見てません（ダッシュボードや通知のメールなども一切目にしないようにしています）。そうした不義理を働くことで創造的なライブラリを生み出すことができるのだ、これは必要な犠牲なのです……！&lt;/p&gt;
&lt;p&gt;また、そうじゃなくても、面倒見てるライブラリの数が多すぎるのでローテートでも数ヶ月の遅延が発生することは、あります。もうこれは絶対的なマンパワーが不足しているため、しょうがないじゃないですかー、というわけで、そのしょうがないを受け入れて、ちょっと返事が遅れるだけでthis library is dead的なこと言わないで欲しいなあ、というのが正直なところです！言われると辛い！なるべく努力はしたいんですが、特に新しいライブラリの創造は時間をめちゃくちゃ取られて大量の遅延が発生して、その遅延が更に遅延を呼んで泥沼になって精神を削っていくのですよー。&lt;/p&gt;
&lt;p&gt;あとはMicrosoft関連でイラッとさせられてモチベーションを削られるとか、この辺はC#関連のOSSあるあるが発生したりしたりしながらも、なるべく末永く続けていきたいとは思っています。&lt;/p&gt;
&lt;p&gt;かなり危機感は持っているので、AIによってどこまで負荷の軽減ができるのか、というところをテーマに、ある程度実験場として色々やっていきたいなあ、と思っています。うまくいけば、よりコアに集中できる環境になってくれるわけですしね。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ZLinqの構造は最初のプレビュー版公開後のフィードバックで結構変わっていて、&lt;a href="https://github.com/Akeit0"&gt;@Akeit0&lt;/a&gt;さんにはコアとなる&lt;code&gt;ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt;という定義や&lt;code&gt;TryCopyTo&lt;/code&gt;への&lt;code&gt;Index&lt;/code&gt;の追加など、パフォーマンスに重要なコア部分の提案を多く頂きました！また、&lt;a href="https://github.com/filzrev"&gt;@filzrev&lt;/a&gt;さんからは多大なテスト・ベンチマークのインフラストラクチャーを提供してもらいました。互換性確保やパフォーマンス向上は、この貢献がなければ成しえませんでした。お二人には深く感謝します。&lt;/p&gt;
&lt;p&gt;改めて、ゼロアロケーションLINQライブラリというコンセプト自体はそこまで珍しいものでもなく、今までもライブラリが死屍累々と転がっていたわけですが、ZLinqは徹底度合いが違う。経験と知識があるうえで、精神論で気合で、全メソッド実装、テストケースも全部流して完全互換、最適化類もSIMD含めて全部実装する、をやり切ったのが立派なところなのではないかな、と。いや、ほんとこれめっちゃ大変だったのです……。&lt;/p&gt;
&lt;p&gt;タイミングとしても.NET 9/C# 13が、フルセットでやりたいことが全部やれる言語機能となったことは、やる気を後押ししてくれました。と、同時に、Unityや.NET Standard 2.0対応も大事にできたのもいいことです。&lt;/p&gt;
&lt;p&gt;ただのゼロアロケーションLINQというだけではなく、LINQ to Treeはお気に入りの機能なので是非使ってみて欲しいですね……！そもそもに元々は、10年前に作っていたLINQ to GameObjectをモダン化しよう、というのが出発点でした。昔のコードだったのでかなりベタ書きだったのですが、もうちょっと抽象化したほうがいいかな、と弄っているうちに、だったらゼロアロケーションLINQとしての抽象化まで進化させてしまったほうがいいのでは、という思いつきに至ったのでした。&lt;/p&gt;
&lt;p&gt;ところで、LINQのパフォーマンスのネックの一つとしてはデリゲートがあり、一部のライブラリはstructでFuncのようなものを模写するValueDelegateというアプローチがあるのですが、それはあえて採用していません。というのも、それらの定義はかなり手間なので、現実的にはやってられないはずです。そこまでやるなら普通にインラインで書いたほうがマシなので、LINQでValueDelegate構造を使う意味はありません。そんなベンチマークハックのためだけに内部構造の複雑化とアセンブリサイズの肥大化を招くのは無駄なので、System.Linqと互換のFuncのみを受け入れるスタイルにしています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;が.NET標準のSystem.Reactiveを置き換えるものという野心的ライブラリでしたが、System.Linqの置き換えはそれよりも遥かに大きな、あるいは大袈裟すぎる代物なので、採用に抵抗感はあるんじゃないかなー、と思います。ですが、置き換えるだけのメリットは掲示できていると思うので、是非とも試してみてくれると嬉しいです！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 05 May 2025 00:00:00 +0900</pubDate>
      <a10:updated>2025-05-05T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/30_year.html</guid>
      <link>https://neue.cc/2024/12/30_year.html</link>
      <title>2024年を振り返る</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-30" data-pagefind-meta="published:2024-12-30"&gt;&lt;a href="https://neue.cc/2024/12/30_year.html"&gt;2024年を振り返る&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-30&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;今年も&lt;a href="https://cysharp.co.jp/"&gt;Cysharp&lt;/a&gt;はちゃんと生存していて良きかな、というわけでサイトが相変わらずペライチなのでそろそろリニューアルしたいと思って幾星霜。&lt;/p&gt;
&lt;p&gt;そんなわけで今年もC#をやりこみ（？）していました……！&lt;/p&gt;
&lt;p&gt;新規:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Claudia"&gt;Claudia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StreamReader"&gt;Utf8StreamReader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大型アップデート&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework v5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C# v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MasterMemory"&gt;MasterMemory v3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;うーん、十分でしょ！割といつも年の中で浮き沈みはあって、調子でないなあ、ここ数ヶ月ダメだぁ、みたいな気持ちになることが割とあるのですが、振り返ってみれば十分すぎるでしょ！むしろやりすぎでしょ！というわけで、C#最前線キープとしては全く問題ないでしょう。&lt;/p&gt;
&lt;p&gt;ハイライトとしてはやはり年初の&lt;a href="https://neue.cc/2024/02/27_R3.html"&gt;R3 - C#用のReactive Extensionsの新しい現代的再実装&lt;/a&gt;ですかね……！これは、めちゃくちゃ大変でした。物量とかそのものの実装難易度とかもそうなのですが、スタンダードとなっているインターフェイスや仕様を変えるという判断を通しているんですよね。これが、ちゃんと成り立たせられるのか、それで普及させられるのか、という悩みもあり、また、インターフェイスも作りながら割とクルクル最後まで変えながらやってたので、完成して良かったし、1年弱経って、ちゃんと受け入れられているのを見てようやくホッと一息です。Unityにおいても、今年はNuGet化を強烈に推進していったわけですが、なんだかんだで受け入れてもらえってるような気がしますがどうでしょう……？&lt;/p&gt;
&lt;p&gt;Claudiaや、なんかブログに書く機会を逸して書いてない気がするのですがUtf8StreamReaderなんかも中々いい感じではあったと思います。&lt;/p&gt;
&lt;p&gt;そして大型アップデート系はSource Generator祭り。まず&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;は傑作かと！これは自信作ですねー、めちゃくちゃいいものが出来たと思ってます。直近の&lt;a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html"&gt;ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など&lt;/a&gt;で完全に仕上がりました。&lt;/p&gt;
&lt;p&gt;MessagePack for C#は長年懸案だったSource Generator化をついに果たしました。そして色々あって共同メンテナーが離脱したことにより、再度主導権が私の方に戻っています。この辺のことは思うところは割とあるのですが、まぁ結果的には良かったかな、と思ってます。再びやれることの幅も広がったので、&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;ともどもで来年は強化していきたいと思っています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://neue.cc/2024/12/20_mastermemory_v3.html"&gt;MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース&lt;/a&gt;も、ずっとSource Generator化したいと思って2年ぐらい放置していた案件なので、ようやく解消できて嬉しい話ですね。しかもやってたら想像通りにめちゃくちゃDX(Developer Experience)よくなってるので、やっと理想が実現できた、というかむしろ時代がやっと追いついた（なんせこの辺の仕組みはSource Generator以前に構築していたパターンなので）という気持ちです。&lt;/p&gt;
&lt;p&gt;Cysharpの提供しているライブラリから単独コードジェネレーターは消滅して全てSource Generator化し、そして&lt;a href="https://neue.cc/2024/01/15_shareprojectinunity.html"&gt;.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法&lt;/a&gt;でも書いたようにUnityとのコードシェアもかなりやりやすい手法が確立できたので、まさにこれはC#大統一理論元年……！「出来ない」よりは「出来たほうがいい」ので、別に今までのやり方が悪かったとは思いませんが、ようやく理想形に到達できた、という感じではあります。来年初頭にはMagicOnionのMessagePack for C# v3対応を出す予定で、これで全てのパーツが揃います！&lt;/p&gt;
&lt;h2&gt;なんとか of the Year&lt;/h2&gt;
&lt;p&gt;今年一番大きかった変化として、メモ環境に&lt;a href="https://obsidian.md/"&gt;Obsidian&lt;/a&gt;を全面導入したのですが、これは超絶良いですね。Daily Notesの有用性というのをようやく理解しました。有料課金して同期することで更に便利、プラグインもマシマシで便利、まぁ入れすぎてもしょうがないので適度に絞ってますよ、と思ったんですが、意外と結構はいってるかも……。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/f44a7f98-36b6-4699-8ab4-1158d5796f19" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/c4bc0d3e-7707-451b-ba6e-1cff03e31733" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;TODOもObsidianに寄せるようにしていますが、特にTODOプラグインなどは使わずにDaily Notesで表現できるように若干工夫しています（TemplaterでJavaScript書いてDaily Notesの生成時にチェック済みのTODOタスクは自動で消すようにしてる＆未チェックのTODOタスクは引き継ぐようにしている）。TODOアプリは無限に彷徨って毎年違うものに変えてたりするのですが、これが一番手に馴染んでるので決定版ということでいいかなー。&lt;/p&gt;
&lt;p&gt;もう一つ革命的に良かったと思うのは&lt;a href="https://consumer.huawei.com/jp/audio/freeclip/"&gt;HUAWEI FreeClip&lt;/a&gt;。これはとんでもなく良くてビックリした。HUAWEI製品のクオリティの高さにもビビッた。オープンイヤー型のイヤホンなわけですが、付け心地も良いし細かいところも良く出来てるし音質もしっかりしてる。言う事無し。オープンイヤーは、外音取り込みとは耳への圧迫感が自然さが全然違うんですよねえ、これだと1日中付けっぱなしとまではしないけど、割と頻繁に耳につけといて、音を聞くことが増えました。講演動画とか英語のリスニングとか日常生活に流せるといい感じ度が上がります。あとダラダラYouTube見る頻度が相当上がってしまった……。あまり使い分けとかは出来ないタイプの人間なので今まで使っていたAirPods Proはお蔵入りしてFreeClip一本使いになってます。ノイズキャンセリング性能がーというのと真逆なわけですが、外音と混じった音楽も、それはそれで心地よいのでいい感じなので、騒音環境下でもそこまで気にならず使えてる気がします。&lt;/p&gt;
&lt;p&gt;あとは、家のキーボードを&lt;a href="https://www.realforce.co.jp/products/series_rc1.html"&gt;Realforce RC1&lt;/a&gt;に変更しました。HHKBにF1-12キーが追加されたようなレイアウトなわけですが、まず、キーボードにF1-F12は必須なんですよね！Visual Studio的に！あとは、日本語キーボードレイアウトじゃないとダメ人間なので、ずっとコンパクト配列にしたいなあと思いつつも選択肢がなくてなあ、と、テンキーレスぐらいで我慢していたので、満を持しての本命というわけでした。&lt;/p&gt;
&lt;p&gt;それとFnキーとの組み合わせによるハードウェアキーレイアウト変更が柔軟かつ安定性が高いことに気づいた！昔から無変換＋ESDFを十字キーとして使う癖があって、AutoHotKeyなどソフトウェアでフックするやつを使って実現していたのですが、挙動的に不安定（抜けが出たりするのが辛い）なのが気になってました。が、Realforceの設定で無変換と変換をFnキーにしてしまって、Fnキーとの組み合わせでESDFを十字キーにしてしまえば完璧だった……！というわけで現在のレイアウトがこちら。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/4824b421-878d-42ee-8bd2-1c7dcc201a3d" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;そんなにキーボードから手を離さないで全部操作出来ないと！みたいな感じではなく、右手はマウス行きしちゃうので、左手側に詰め込みがちです。とにかくESDFでの十字キー化が安定したのがめっちゃ嬉しい。これ、WSDFじゃないんですか？というところなのですが、主に使うシチュエーションはテキストエディタでの十字移動なので、ESDFはホームポジションから手を動かさずに十字キーになるのがWSDFに比べての圧倒的利点です。それとQAZが空くので、そこにもキーを詰め込めるのも嬉しい。&lt;/p&gt;
&lt;p&gt;というわけでQ, AはHome/End(ちなみに私はHomeめちゃくちゃよく使います)。Z, CにShift + Home/End。XにShift + @(つまり```)。VにWin + V。それと1, 2, 3にはAlt + 1, 2, 3を入れています、というのも私は&lt;a href="https://arc.net/"&gt;Arc&lt;/a&gt;というブラウザを使っているのですが、これのスペースの切り替えがAltになっていて、AltよりもFn（元の無変換）を使うことが多いので、そのまま切り替えられるようにしたほうが便利かな、と。&lt;/p&gt;
&lt;p&gt;そしてFn + 半角/全角にCtrl + Shift + Alt + Eを割り当てて、これはWindowsのアプリケーションへのグローバルショートカットキーで&lt;a href="https://www.voidtools.com/"&gt;Everything&lt;/a&gt;を宛ててます。あまりキーをフックするようなのをソフトウェア側で仕込みたくはないのですが、Windows標準機能ならまぁ良いでしょう、ということで。&lt;/p&gt;
&lt;p&gt;マクロが欲しいとかショートカットキー登録数が少ないとか思うところもありますが、全体的にはかなり相当良いです！&lt;/p&gt;
&lt;p&gt;キーボードといえば、iPad Pro用に&lt;a href="https://www.logicool.co.jp/ja-jp/products/tablet-keyboards/keys-to-go2-apple.920-013030.html"&gt;logicool Keys-To-Go 2 for iPad&lt;/a&gt;を買ったのですが、これもかなり良くて体験変わりました。今までモバイルキーボード難民で全然しっくり来るものがなかったのですが、これが一番アリだなあ、という感じですね……！&lt;/p&gt;
&lt;p&gt;iPadには&lt;a href="https://www.amazon.co.jp/dp/B0972XHTRF"&gt;prendre タブレットスタンド iPad&lt;/a&gt;を貼り付けてキックスタンドにしてます。たった17g追加するだけで自立する！これは超便利。軽量化したとはいえ、重たいiPadなのでケースとか入れてこれ以上重たくしたくはない。が、自立してくれないと不便、で、色々探して買ったのがこれでした。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/9532238d-203b-4556-bf8e-4c0ccb9a38af" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;横はもちろん、縦でもちゃんと安定してくれる。粘着テープで貼り付けるタイプは剥がれる危険性があるわけですが、iPad Proが軽量化してくれたおかげもあってそこそこ安定しています。ただし両面テープは付属のは剥がして、色々試した結果&lt;a href="https://www.amazon.co.jp/dp/B00BPJLP3G"&gt;スリーエム(3M) 3M 両面テープ 超強力 スーパー多用途 薄手 幅12mm&lt;/a&gt;に落ち着きました。あまり強力すぎると、それはそれで剥がしにくくて売るときとかに泣いちゃう（本当に剥がれない……！）ので、粘着力が基本なのですが、その上でいざというときに剥がれてくれるかどうかのバランスも大事……。&lt;/p&gt;
&lt;p&gt;というわけかで&lt;a href="https://av.watch.impress.co.jp/docs/news/1589552.html"&gt;iPad Pro 13インチ&lt;/a&gt;も買ったのですが、これは満足感高いです。違いは、やっぱ有機ELディスプレイですかねー、今までのiPadの画質って割と不満足というか、どう見てもiPhoneよりも画質悪いじゃん！という感じで萎え萎えだった（のであまり使わなくなっていった……）のですが、今回の画質ならOKです！というわけで利用頻度上がりました。ちなみにNano-textureガラスではありません。いや、最初Nano-textureガラスのやつを買っちゃったんですが、これ普通に画質めちゃくちゃ悪いんですよ。インターネットマンが画質は大して変わらないとか言うから信じたのにめっちゃ悪くて……。耐えられなかったのですみませんがの返品からの買い直しコンボさせていただきました……。&lt;/p&gt;
&lt;p&gt;そして、&lt;a href="https://povo.jp/"&gt;povo&lt;/a&gt;。ずっとauだったのですが、povoに乗り換えました。で、これがめちゃくちゃいい、というかiPadでの利用にとてもいい。SIM付きモデル買ったのですが、auでのデータ共有がうまくできず（難易度高すぎ＆なんかバグってると思う……）塩漬けだったのです。が、povoで単独での契約だと、当たり前ですがスムーズに通信できて快適。iPadもテザリングがそこそこiPhoneとスムーズにつながるからなくてもいいじゃん、とか思ってなくもなかったのですが、単独で通信できる快適さはぜんぜん違う！そして、私の用途的に別にそんなに毎日通信するわけでもないので、あんまりギガはいらないんですが、povoだとプロモーションと合わせると実質0円運用できるのが、とてもいい感じです。例えばローソン500円購入券がpovoで500円で買えて0.3GBの通信料がついてくる、とかだと、どうせ500円買うんだしpovoで買ってiPadに0.3GBチャージしとくかあ、みたいな。&lt;/p&gt;
&lt;p&gt;最後に、Game of the Yearは今更グランツーリスモ7ということで（？）。というのもLogicoolの&lt;a href="https://gaming.logicool.co.jp/ja-jp/products/driving/pro-racing-wheel.html"&gt;PROレーシングホイール&lt;/a&gt; + PRO RACING PEDALSを買ったのですが、これが抜群にいい……！今まで(G923)とは桁違い、というか実際桁違いで、G923が2.4nmというフィードバック力しか出せていないのですが、PROレーシングホイール11nm出る！11nmって別に全くピンと来ないのですが、触ってみると2.4nmはスカスカで、逆に11nmをフルに出すと重くて曲げられないレベル（実際、筋肉痛になった……）。そんなわけで一気に楽しくなったので、今年は一番グランツーリスモ7をやってた気がします。はい。&lt;/p&gt;
&lt;h2&gt;来年&lt;/h2&gt;
&lt;p&gt;C#でSaaS作りたい欲求はずっとあるので、OSSメンテナンス業が重くのしかかりつつも、来年はそっち側でも進展を見せたいと思ってます……！Cysharpももう少し大きくしたいとは思っているので、引き続きよろしくおねがいします。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 30 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-30T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/20_mastermemory_v3.html</guid>
      <link>https://neue.cc/2024/12/20_mastermemory_v3.html</link>
      <title>MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-20" data-pagefind-meta="published:2024-12-20"&gt;&lt;a href="https://neue.cc/2024/12/20_mastermemory_v3.html"&gt;MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-20&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/MasterMemory"&gt;MasterMemory&lt;/a&gt; v3出しました！ついにSource Generator化されました！&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/e804fa52-f6a5-4972-a510-0b3b17a31230" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;MasterMemoryはC#のインメモリデータベースで、高速で、メモリ消費量が少なく、タイプセーフ。というライブラリです。SQLiteを素朴に使うよりも &lt;em&gt;4700&lt;/em&gt;倍高速だぞ、と。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61031896-61890800-a3fb-11e9-86b7-84c821d347a4.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;もともとMasterMemoryはC#コードからC#コードを生成するという、Source Generatorのなかった時代にSource Generatorのようなことをやる先進的な設計思想を持ったシステムでした。今回移植してみて、あまりにもスムーズに移植できるし、旧来のコードも全く手を付けずにそのまま動いたので我ながら感心しました。やっと時代が追い付いたか……。&lt;/p&gt;
&lt;p&gt;というわけで、以下のようなC#定義からデータベース構築のためのコードと、クエリ部分がSource Generatorによって自動生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MemoryTable(&amp;quot;person&amp;quot;), MessagePackObject(true)]
public record Person
{
    [PrimaryKey]
    public required int PersonId { get; init; }
    
    [SecondaryKey(0), NonUnique]
    [SecondaryKey(1, keyOrder: 1), NonUnique]
    public required int Age { get; init; }

    [SecondaryKey(2), NonUnique]
    [SecondaryKey(1, keyOrder: 0), NonUnique]
    public required Gender Gender { get; init; }

    public required string Name { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61035808-cb58e000-a402-11e9-9209-d51665d1cd56.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;C#コードとして生成されるので、クエリが全て入力補完も効くし戻り値も型付けされていてタイプセーフなのはもちろん、パフォーマンスの良さにも寄与しています。&lt;/p&gt;
&lt;p&gt;読み取り専用データベースとして使うので、クラス定義はイミュータブルのほうがいいわけですが、最近のC#は &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;required&lt;/code&gt; といった機能が提供されているので、Readonly Databaseとしての使い勝手が更に上がりました。Unityでは&lt;code&gt;required&lt;/code&gt;は使えませんが&lt;code&gt;record&lt;/code&gt;と&lt;code&gt;init&lt;/code&gt;は使えるので、Unityでも問題ありません。&lt;/p&gt;
&lt;p&gt;なお、Unity版は今回からNuGetForUnityでの提供となります。また、MessagePack for C#もSource Generator対応のv3を要求します。&lt;/p&gt;
&lt;h2&gt;Next&lt;/h2&gt;
&lt;p&gt;MasterMemory、実は結構使われています。ゲームでも採用されているものを割と見かけるようになりました。なので、外部ツール由来のコード生成の面倒さにはだいぶ心を痛めていたので、ようやく解消できて本当に嬉しい！&lt;/p&gt;
&lt;p&gt;v2からv3へのマイグレーションもそんなに大変ではない、はずです。あえて生成コードの品質や、コアの関数、メソッドシグネチャなどには一切手を加えていないので、今までコマンドラインツールを叩いていた部分を削除するだけで、そのまま動き出すぐらいの代物になっています。名前空間の設定だけ、アセンブリ属性で行ってください。&lt;/p&gt;
&lt;p&gt;そのうえでrecord対応（今までしてなかった！）や#nullable enable対応（今までしてなかった！）を追加しているので、生成部分以外の使い勝手も上がっているはずです。&lt;/p&gt;
&lt;p&gt;今後は&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;対応や、そもそものAPIの更なるモダン化（現状はnetstandard2.0なので古い）、全体的に改修したいところ(ImmutableBuilderなど生成コードの差し替え部分)、などなどやれること自体はめっちゃありますので、折を見て手を入れていけるといいかなあ、と思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-20T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</guid>
      <link>https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</link>
      <title>ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-16" data-pagefind-meta="published:2024-12-16"&gt;&lt;a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html"&gt;ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-16&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt; v5の比較的アップデートをしました！v5自体の詳細は以前に書いた&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;を参照ください。v5はかなり面白いコンセプトになっていて、そして支持されたと思っているのですが、幾つか使い勝手を犠牲にした点があったので、今回それらをケアしました。というわけで使い勝手がかなり上がった、と思います……！&lt;/p&gt;
&lt;h2&gt;名前の自動変換を無効にする&lt;/h2&gt;
&lt;p&gt;コマンドネームとオプションネームは、デフォルトでは自動的にkebab-caseに変換されます。これはコマンドラインツールの標準的な命名規則に従うものですが、内部アプリケーションで使うバッチファイルの作成に使ったりする場合などには、変換されるほうが煩わしく感じるかもしれません。そこで、アセンブリ単位でオフにする機能を今回追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;

[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]

var app = ConsoleApp.Create();
app.Add&amp;lt;MyProjectCommand&amp;gt;();
app.Run(args);

public class MyProjectCommand
{
    public void Execute(string fooBarBaz)
    {
        Console.WriteLine(fooBarBaz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]&lt;/code&gt;によって自動変換が無効になります。この例では &lt;code&gt;ExecuteCommand --fooBarBaz&lt;/code&gt; がコマンドとなります。&lt;/p&gt;
&lt;p&gt;実装面でいうと、Source Generatorにコンフィグを与えるのはAdditionalFilesにjsonや独自書式のファイル(例えばBannedApiAnalyzersのBannedSymbols.txt)を置くパターンが多いですが、ファイルを使うのは結構手間が多くて面倒なんですよね。boolの1つや2つを設定するぐらいなら、アセンブリ属性を使うのが一番楽だと思います。&lt;/p&gt;
&lt;p&gt;実装手法としては&lt;code&gt;CompilationProvider&lt;/code&gt;から&lt;code&gt;Assembly.GetAttributes&lt;/code&gt;で引っ張ってこれます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var generatorOptions = context.CompilationProvider.Select((compilation, token) =&amp;gt;
{
    foreach (var attr in compilation.Assembly.GetAttributes())
    {
        if (attr.AttributeClass?.Name == &amp;quot;ConsoleAppFrameworkGeneratorOptionsAttribute&amp;quot;)
        {
            var args = attr.NamedArguments;
            var disableNamingConversion = args.FirstOrDefault(x =&amp;gt; x.Key == &amp;quot;DisableNamingConversion&amp;quot;).Value.Value as bool? ?? false;
            return new ConsoleAppFrameworkGeneratorOptions(disableNamingConversion);
        }
    }

    return new ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion: false);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを他のSyntaxProviderからのSourceとCombineしてやれば、生成時に属性の値を参照できるようになります。&lt;/p&gt;
&lt;h2&gt;ConfigureServices/ConfigureLogging/ConfigureConfiguration&lt;/h2&gt;
&lt;p&gt;ゼロディペンデンシーを掲げている都合上、特定のライブラリに依存したコードを生成することができないという制約がConsoleAppFramework v5にはありました。そのため、DIとの統合時に自分でServiceProviderをビルドしなければならないなの、利用には一手間必要でした。そこで、NuGetでのDLLの参照状況を解析し、&lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;が参照されていると、&lt;code&gt;ConfigureServices&lt;/code&gt;メソッドが&lt;code&gt;ConsoleAppBuilder&lt;/code&gt;から使えるという実装を追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create()
    .ConfigureServices(service =&amp;gt;
    {
        service.AddTransient&amp;lt;MyService&amp;gt;();
    });

app.Add(&amp;quot;&amp;quot;, ([FromServices] MyService service, int x, int y) =&amp;gt; Console.WriteLine(x + y));

app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりフレームワークそのものはゼロディペンデンシーでありながら、ライブラリ依存のコードも生成することができるという、新しい体験を提供します。これは&lt;code&gt;MetadataReferencesProvider&lt;/code&gt;から引っ張ってきて生成処理に回すことで実現しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var hasDependencyInjection = context.MetadataReferencesProvider
    .Collect()
    .Select((xs, _) =&amp;gt;
    {
        var hasDependencyInjection = false;

        foreach (var x in xs)
        {
            var name = x.Display;
            if (name == null) continue;

            if (!hasDependencyInjection &amp;amp;&amp;amp; name.EndsWith(&amp;quot;Microsoft.Extensions.DependencyInjection.dll&amp;quot;))
            {
                hasDependencyInjection = true;
                continue;
            }

            // etc...
        }

        return new DllReference(hasDependencyInjection, hasLogging, hasConfiguration, hasJsonConfiguration, hasHost);
    });

context.RegisterSourceOutput(hasDependencyInjection, EmitConsoleAppConfigure);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参照の解析は複数のものに対して行っていて、他にも&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt;が参照されていれば&lt;code&gt;ConfigureLogging&lt;/code&gt;が使えるようになります。なので&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;と組み合わせれば&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: ZLogger
var app = ConsoleApp.Create()
    .ConfigureLogging(x =&amp;gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&amp;quot;log.txt&amp;quot;);
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject logger to constructor
public class MyCommand(ILogger&amp;lt;MyCommand&amp;gt; logger)
{
    public void Echo(string msg)
    {
        logger.ZLogInformation($&amp;quot;Message is {msg}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように、比較的すっきりと設定が統合できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appsettings.json&lt;/code&gt;から設定ファイルを引っ張ってくるというのも最近では定番パターンですが、これも&lt;code&gt;Microsoft.Extensions.Configuration.Json&lt;/code&gt;を参照していると&lt;code&gt;ConfigureDefaultConfiguration&lt;/code&gt;が使えるようになり、これは&lt;code&gt;SetBasePath(System.IO.Directory.GetCurrentDirectory())&lt;/code&gt;と&lt;code&gt;AddJsonFile(&amp;quot;appsettings.json&amp;quot;, optional: true)&lt;/code&gt;を自動的に行います（追加でActionでconfigureすることも可能、また、ConfigureEmptyConfigurationもあります）。&lt;/p&gt;
&lt;p&gt;なのでコンフィグを読み込んでクラスにバインドしてコマンドにDIで渡す、などといった処理もシンプルに書けるようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Configuration.Json
var app = ConsoleApp.Create()
    .ConfigureDefaultConfiguration()
    .ConfigureServices((configuration, services) =&amp;gt;
    {
        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions
        services.Configure&amp;lt;PositionOptions&amp;gt;(configuration.GetSection(&amp;quot;Position&amp;quot;));
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject options
public class MyCommand(IOptions&amp;lt;PositionOptions&amp;gt; options)
{
    public void Echo(string msg)
    {
        ConsoleApp.Log($&amp;quot;Binded Option: {options.Value.Title} {options.Value.Name}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt;でビルドしたい場合は、&lt;code&gt;ToConsoleAppBuilder&lt;/code&gt;が、これも&lt;code&gt;Microsoft.Externsions.Hosting&lt;/code&gt;を参照すると追加されるようになっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Hosting
var app = Host.CreateApplicationBuilder()
    .ToConsoleAppBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、今回から設定されている&lt;code&gt;IServiceProvider&lt;/code&gt;は&lt;code&gt;Run&lt;/code&gt;または&lt;code&gt;RunAsync&lt;/code&gt;終了後に自動的にDisposeするようになりました。&lt;/p&gt;
&lt;h2&gt;RegisterCommands from Attribute&lt;/h2&gt;
&lt;p&gt;コマンドの追加は&lt;code&gt;Add&lt;/code&gt;または&lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;が必要でしたが、クラスに属性を付与することで自動的に追加される機能をいれました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands]
public class Foo
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}

[RegisterCommands(&amp;quot;bar&amp;quot;)]
public class Bar
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらは自動で追加されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create();

// Commands:
//   baz
//   bar baz
app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらとは別に追加で&lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;することも可能です。&lt;/p&gt;
&lt;p&gt;なお、実装の当初予定では任意の属性を使えるようにする予定だったのですが、&lt;code&gt;IncrementalGenerator&lt;/code&gt;のAPIの都合上難しくて、固定の&lt;code&gt;RegisterCommands&lt;/code&gt;属性のみを対象としています。また、継承することもできません……。なので独自の処理用属性がある場合は、組み合わせてもらう必要があります。例えば以下のように。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands, Batch(&amp;quot;0 10 * * *&amp;quot;)]
public class MyCommands
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この辺は&lt;a href="https://qiita.com/omt_teruki/items/dae315c7e86722fe05e6"&gt;ConsoleAppFrameworkとAWS CDKで爆速バッチ開発&lt;/a&gt;を読んで、うーん、v5を使ってもらいたい！なんとかしたい！と思って色々考えたのですが、この辺が現状の限界でした……。名前変換オフりたいのもわかるー、とか今回の更新内容はこの記事での利用例を参考にさせていただきました、ありがとうございます！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;v5のリリース以降もフィルターを外部アセンブリに定義できるようになったり、Incremental Generatorの実装を見直して高速化するなど、Improvmentは続いています！非常に良いフレームワークに仕上がってきました！&lt;/p&gt;
&lt;p&gt;ところで&lt;a href="https://github.com/dotnet/command-line-api/"&gt;System.CommandLine&lt;/a&gt;、現状うまくいってないから&lt;a href="https://github.com/dotnet/command-line-api/issues/2338"&gt;Resettting System.CommandLine&lt;/a&gt;だ！と言ったのが今年の3月。例によって想像通り進捗は無です。知ってた。そうなると思ってた。何も期待しないほうがいいし、普通にConsoleAppFramework使っていくで良いでしょう。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-16T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/06_MessagePack_v3.html</guid>
      <link>https://neue.cc/2024/12/06_MessagePack_v3.html</link>
      <title>SourceGenerator対応のMessagePack for C# v3リリースと今後について</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-06" data-pagefind-meta="published:2024-12-06"&gt;&lt;a href="https://neue.cc/2024/12/06_MessagePack_v3.html"&gt;SourceGenerator対応のMessagePack for C# v3リリースと今後について&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-06&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;先月&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#プロジェクト&lt;/a&gt;は &lt;a href="https://dotnetfoundation.org/"&gt;.NET Foundation&lt;/a&gt;に参加しました！より安定した視点で利用していただけるという一助になればいいと思っています。&lt;/p&gt;
&lt;p&gt;そして、長く開発を続けていたメジャーバージョンアップ、v3がリリースされました。コア部分はv2とはほぼ変わらずですが、Source Generatorを全面的に導入しています。引き続きIL動的生成も存在するため、IL動的生成とSource Generatorのハイブリッドなシリアライザーとなります。v3にはSource GeneratorとAnalyzerがビルトインで同梱されていて、今までのコードはv3でコンパイルするだけで自動的にSource Generator化されます。v2 -&amp;gt; v3アップデートでSource Generator対応するために追加でユーザーがコードを記述する必要はありません！&lt;/p&gt;
&lt;p&gt;挙動を詳しく見ていきましょう。例えば、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MyTestClass
{
    [Key(0)]
    public int MyProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というコードを書くと、自動的に以下のコードがSource Generatorによって内部的に生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial class GeneratedMessagePackResolver
{
    internal sealed class MyTestClassFormatter : IMessagePackFormatter&amp;lt;MyTestClass&amp;gt;
    {
        public void Serialize(ref MessagePackWriter writer, MyTestClass value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.MyProperty);
        }

        public MyTestClass Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var ____result = new MyTestClass();

            for (int i = 0; i &amp;lt; length; i++)
            {
                switch (i)
                {
                    case 0:
                        ____result.MyProperty = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            reader.Depth--;
            return ____result;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、このGeneratedMessagePackResolverはデフォルトのオプション(StandardResolverなど)に最初から登録されているため、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static readonly IFormatterResolver[] DefaultResolvers = [
    BuiltinResolver.Instance,
    AttributeFormatterResolver.Instance,
    SourceGeneratedFormatterResolver.Instance, // here
    ImmutableCollection.ImmutableCollectionResolver.Instance,
    CompositeResolver.Create(ExpandoObjectFormatter.Instance),
    DynamicGenericResolver.Instance, // only enable for RuntimeFeature.IsDynamicCodeSupported
    DynamicUnionResolver.Instance];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザーコードのアセンブリに含まれているシリアライズ対象クラスは、Source Generatorによって生成されたコードが優先的に使われることになります。GeneratedMessagePackResolverは既定の名前空間や名前を変えたり、生成フォーマッターをmapベースに変更するなど、幾つかのカスタマイズポイントも用意されています。より詳しくは新しいドキュメントを見てください。また、v2 -&amp;gt; v3の変更箇所の詳細を知りたい人は&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/develop/doc/migrating_v2-v3.md"&gt;Migration Guide v2 -&amp;gt; v3&lt;/a&gt;をチェックしてください。&lt;/p&gt;
&lt;p&gt;Unityにおいては導入方法が大きく変わりました。コアライブラリは .NET 版と共通になりNuGetからのインストールが必要となります。そのうえでUPMでUnity用の追加コードをダウンロードする必要があります。詳しくは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/#unity-support"&gt;MessagePack-CSharp#unity-support&lt;/a&gt;のセクションを確認してください。&lt;/p&gt;
&lt;p&gt;.unitypackageの提供は廃止されています。また、IL2CPP対応のために要求していたmpcはなくなりました。完全にSource Generatorに移行されます。そのため、Unityのサポートバージョンは &lt;code&gt;2022.3.12f1&lt;/code&gt; からとなります。Source Generatorに関してはNuGetForUnityでのコアライブラリインストール時に自動的に有効化されるため、追加の作業は必要ありません。&lt;/p&gt;
&lt;h2&gt;History and Next&lt;/h2&gt;
&lt;p&gt;MessagePack for C#のオリジナル(v1)は私(Yoshifumi Kawai/@neuecc)によって、2017年にリリースしました。当時開発していたゲームのパフォーマンス問題を解決するために、2016年時点で存在していた(バイナリ)シリアライザーでは需要を満たせなかったため、パフォーマンスを最重要視したバイナリシリアライザーとして作成しました。合わせて、同じくネットワークシステムとして作成したgRPCベースのRPCフレームワーク&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;もリリースしています。&lt;/p&gt;
&lt;p&gt;v1リリース当時は&lt;code&gt;byte[]&lt;/code&gt;のみを対象としていましたが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;など、.NETには次々と新しいI/O系のAPIが追加されていったため、v2ではそれらに焦点を当てた新しいデザインが導入されました。この実装はMicrosoftのEngineerである&lt;a href="https://github.com/AArnott"&gt;Andrew Arnott / @AArnott&lt;/a&gt;氏によって主導され、リリースしています。&lt;/p&gt;
&lt;p&gt;以降、共同のメンテナンス体制として、そして私の個人リポジトリ(neuecc/MessagePack-CSharp)からオーガナイゼーション(MessagePack-CSharp/MessagePack-CSharp)して今に至ります。Visual Studio内部での利用や&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol"&gt;SignalRのバイナリープロトコル&lt;/a&gt;、Blazor Serverのプロトコルなど大きなMicrosoftのプロダクトでも使用され、GitHubでのスター数は.NETのバイナリーシリアライザーとしては最も大きなスターを集めています。&lt;a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-migration-guide/"&gt;.NET 9で廃止されたBinaryFormatter&lt;/a&gt;の移行先の一つとしても推奨されています。&lt;/p&gt;
&lt;p&gt;v3ではSource Generatorに対応することで、より高いパフォーマンスと柔軟性、AOT対応への第一段階に踏み出すことができました。&lt;/p&gt;
&lt;p&gt;MessagePack for C#プロジェクトは大きな成功を収めたと考えていますが、しかし現在、AArnott氏は個人の新しいMessagePackプロジェクトの開発を開始しています。私もその間、&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;という異なるフォーマットのシリアライザーをリリースしています。そのため、MessagePack for C#の今後と、その特性について、ある程度説明する必要があると思います。&lt;/p&gt;
&lt;p&gt;引き続きメンテナンス体制は2人だと考えていますが、アクティブな活動に関しては、再び私が担うことになるかもしれません。私はMessagePackとMemoryPackとでは異なる性質を持ったフォーマットであるため、どちらも重要であるという認識で動いています。オリジナルの実装であるMessagePack for C#も気に入ってますし、現在においても決して引けを取ることのないものだと思っています。&lt;/p&gt;
&lt;p&gt;AArnott氏の別のMessagePackシリアライザーとは根本的な哲学が若干異なります。その点で、私はそれはより良く改善されたシリアライザーではなく、別の個性のシリアライザーだと認識しています。そこで、違いについて説明させてください。&lt;/p&gt;
&lt;h2&gt;Binary spec, default settings and performance&lt;/h2&gt;
&lt;p&gt;シリアライザーのパフォーマンスに重要なのは、「仕様と実装」の両方です。例えばテキストフォーマットのJSONよりもバイナリフォーマットのほうが一般的には速いでしょう。しかし、よくできたJSONシリアライザーは、中途半端な実装のバイナリシリアライザーよりも高速です（私はそれを&lt;a href="https://github.com/neuecc/Utf8Json"&gt;Utf8Json&lt;/a&gt;というシリアライザーを作成することで実証したことがあります）。なので、仕様も大事だし、実装も大事です。どちらも兼ねることができれば、それがベストなパフォーマンスのシリアライザーとなります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://msgpack.org/"&gt;MessagePackのバイナリ仕様&lt;/a&gt;は &amp;quot;It's like JSON. but fast and small.&amp;quot; を標語にしている通り、JSONのバイナリ化としてあらわされています。ところが、MessagePack for C#のデフォルトは必ずしもJSON likeを狙っているわけではありません。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MsgPackSchema
{
    [Key(0)]
    public bool Compact { get; set; }
    [Key(1)]
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このクラスをシリアライズした場合は、JSONで表現すると&lt;code&gt;[true, 0]&lt;/code&gt;のようになります。これはオブジェクトをarrayベースでシリアライズしているからで、mapベースでシリアライズすると&lt;code&gt;{&amp;quot;Compact&amp;quot;:true,&amp;quot;Schema&amp;quot;:0}&lt;/code&gt;のような表現になります。&lt;/p&gt;
&lt;p&gt;arrayベースの利点は見た通りに、バイナリ容量として、よりコンパクトになります。容量がコンパクトなことは処理量が少なくなるためシリアライズの速度にも良い影響を与えます。また、デシリアライズにおいては、文字列を比較してデシリアライズするプロパティを探索する必要がなくなるため、より高速なデシリアライズ速度が期待できます。&lt;/p&gt;
&lt;p&gt;なお、arrayベースのシリアライズはMessagePackの仕様策定者である Sadayuki Furuhashi 氏によるリファレンス実装であるmsgpack-javaなどでも採用されているため、決して異端のやり方というわけではありません。&lt;/p&gt;
&lt;p&gt;MessagePack-CSharpではJSONライクなmapベースでシリアライズしたい場合は&lt;code&gt;[MessagePackObject(true)]&lt;/code&gt;と記述することができます。また、Source Generatorの場合はResolver単位でオーバーライドして強制的にmapベースにすることも可能です。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject(keyAsPropertyName: true)]
public class MsgPackSchema
{
    public bool Compact { get; set; }
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapの利点は、柔軟なスキーマエボリューションの実現と、他言語との疎通する際にコミュニケーションが取りやすいこと、バイナリそのものの自己記述性が高いことです。デメリットは容量とパフォーマンスへの悪影響、特にオブジェクトの配列においては一要素毎にプロパティ名が含まれることになってしまい、かなりの無駄となります。&lt;/p&gt;
&lt;p&gt;デフォルトをarrayにしているのは、コンパクトさとパフォーマンスの追求のためです。私はMessagePackをJSON likeの前に、高いパフォーマンスを実現可能なバイナリ仕様として考えました。もちろん、mapも重要なので、その上で比較的簡単にmapモードを実現するために属性に&lt;code&gt;(true)&lt;/code&gt;を追加するだけで可能にしました。&lt;/p&gt;
&lt;p&gt;arrayモードの場合はKey属性を全てのプロパティに付与する必要があります。これは、例えばProtocol Buffersなどでも数値タグを必要とするように、プロパティ名そのものをキーとするわけではなければ、必須だと考えています。もちろん、連番で自動採番させることも可能ですが、バイナリフォーマットのキーを暗黙的に処理するのはリスクが大きすぎる(順番を弄ったりするだけでバイナリ互換性が壊れることになる)と判断しています。つまり、明示的がデフォルト、ということです。大きなプロジェクト開発ではシニアメンバーからジュニアメンバーまでコードを触ることになるでしょう、全てを理解している人だけがコードを触るわけではありません。なので、暗黙的な挙動は避けるべきで、明示的にすべきだという強い意志で、この設計を選んでいます。&lt;/p&gt;
&lt;p&gt;ただしKeyを全てのプロパティに付与する作業はとても苦痛です(私はMessagePack-CSharp開発以前には、DataContractやprotobuf-netで辛い思いをしました)。そこで、Analyzer + Code Fixによって、自動的に付与する機能を用意しました。これにより明示的であることの苦痛は和らげられ、良いとこどりができているのだと考えています。&lt;/p&gt;
&lt;p&gt;別のMessagePackシリアライザーのデフォルトはmapのようです。これは&lt;a href="https://github.com/eiriktsarpalis/PolyType"&gt;PolyType&lt;/a&gt;というSource Generatorベースのライブラリ作成のための抽象化ライブラリがベースとしているためでもあり、また、そちらのほうを好んでいるという明示的な判断でもあるようです。&lt;/p&gt;
&lt;p&gt;「デフォルト」はライブラリで一つしか選べません。どちらのモードで処理することができたとしても、「デフォルト」はただ一つです。改めて言うと、私はバイナリフォーマットとしての「コンパクトとパフォーマンス」を好み、優先しています。&lt;/p&gt;
&lt;p&gt;皆さんはPolyTypeについて初めて知ったかもしれません。私はPolyTypeはあまり好意的には考えていません。ちょっとしたものを作るには非常に便利だとは思いますが、ベストなパフォーマンスを狙ったり、ベストなアイディアを表現するには、抽象層であることの制限が大きすぎると考えています。なので、MessagePack for C#で採用することはありませんし、他の何かを作る際にも採用することはないでしょう。&lt;/p&gt;
&lt;h2&gt;Unity(multiplatform) Support&lt;/h2&gt;
&lt;p&gt;MessagePack for C#ではv1の時代からゲームエンジンUnityの1st classのサポートを実行してきました。これは私が&lt;a href="https://en.wikipedia.org/wiki/Cygames"&gt;Cygames&lt;/a&gt;という日本のゲーム会社の関連会社(&lt;a href="https://cysharp.com/"&gt;Cysharp&lt;/a&gt;)のCEOを務めていて、ビデオゲームインダストリーと関係性が深いという都合もあります。自分たちで実際にUnityで動くものを作り、使ってきました。もちろん、サーバーサイドやデスクトップアプリケーションでも使っています。&lt;/p&gt;
&lt;p&gt;UnityにはIL2CPPという独自のAOTシステムがあり、特にiOSなどモバイルプラットフォームでのリリースには必須なのですが、それもSource Generatorが存在しなかった時代から、mpcというRoslynを使ったコードジェネレートツールを作り、提供してきました。数百のモバイルゲームでMessagePackが使われているのは、これら私の熱心なサポートのお陰といっても過言ではないでしょう。v3ではついにSource Generatorベースになったことにより、ワークフローが大きく簡易化されることとなります！&lt;/p&gt;
&lt;p&gt;一般的に、.NETコミュニティにおいてはUnityサポートはかなり軽視されていました。また、外から見ているとMicrosoftやMicrosoftの従業員もそのようで、自社のプラットフォーム以外への関心は薄そうです。こうした態度は、あまり好ましいとは思っていませんし、せっかくの .NET の可能性を狭めていることにもなっています。Xamarinがうまく成長軌道に乗らなかったのも、そのようなMicrosoft自体の冷たい視線のせいだとも思っています。&lt;/p&gt;
&lt;p&gt;私は、私の作るライブラリはなるべくUnityにもしっかり対応できるように気を付けて作っています（最新は新しいReactive Extensionsライブラリーである&lt;a href="https://github.com/Cysharp/R3"&gt;Cysharp/R3&lt;/a&gt;）。別のMessagePackシリアライザーに関しては、あまりしっかりした対応はされなさそうですが……。&lt;/p&gt;
&lt;h2&gt;Beyond v3&lt;/h2&gt;
&lt;p&gt;v3のNative AOT Supportは完全ではありません。Source Generatorにするだけでは完全なNative AOT対応とはならないのは難しいところです。これはUnityのAOTであるIL2CPPでは完璧に動作しているだけに、正直不可解なことでもあり、また、Microsoftのよくない癖が出ているな、とも思っています。つまり、完璧な対応をするために、複雑なものを提供している。それが現在のNative AOTです。複雑怪奇な属性やフローは、理解できるところもありますが、もう少し簡略化すべきだったと思います。まぁ、もう修正されることもないのでしょうが……。&lt;/p&gt;
&lt;p&gt;パフォーマンス面でもv1からv2で退化してしまった点もあるので、最新の知見を元に、実装面での改善を施す必要があります。特にReadOnlySequenceの利用幅が大きいことは、かなりの制約を生み出していて、不満があります。&lt;/p&gt;
&lt;p&gt;.NET 9でPipeReader/PipeWriterが標準化されたことによる、より良い非同期APIや、パフォーマンスを両立したストリーミング対応というのも、大きなトピックとなるかもしれません。&lt;/p&gt;
&lt;p&gt;MessagePack for C#は広く使われているが故に、破壊的変更はしづらいし、互換性の維持は最重要トピックスです。しかし、世の中が変わっていく以上、進化しないことを選んだら、それは滅びる道でしかありません。やれることはまだまだあると思っていますので、.NETにおける最先端の、最高のバイナリシリアライザーであり続けたいと思っています（&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;もね……！)&lt;/p&gt;
&lt;p&gt;まずは、v3のSource Generatorをぜひ試してみてください。皆の力でより良いものを作っていけるというのも、OSSの良さだと思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 06 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-06T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/03_SharpFuzz.html</guid>
      <link>https://neue.cc/2024/12/03_SharpFuzz.html</link>
      <title>Fuzzing in .NET: Introducing SharpFuzz</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-03" data-pagefind-meta="published:2024-12-03"&gt;&lt;a href="https://neue.cc/2024/12/03_SharpFuzz.html"&gt;Fuzzing in .NET: Introducing SharpFuzz&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-03&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;この記事は&lt;a href="https://qiita.com/advent-calendar/2024/csharplang"&gt;C# Advent Calendar 2024&lt;/a&gt;に参加しています。また、先月開催された&lt;a href="https://dotnetnew.connpass.com/event/335955/"&gt;dotnet new&lt;/a&gt;というイベントでの発表のフォローアップ、のつもりだったのですがコロナ感染につき登壇断念……。というわけで、セッション資料はないので普通にブログ記事とします！&lt;/p&gt;
&lt;h2&gt;dotnet/runtime と Fuzzing&lt;/h2&gt;
&lt;p&gt;今年に入ってからdotnet/runtimeにFuzzingテストが追加されています。&lt;a href="https://github.com/dotnet/runtime/tree/main/src/libraries/Fuzzing"&gt;dotnet/runtime/Fuzzing&lt;/a&gt;。というわけで、実はfuzzingは非常に最近のトピックスなのです……！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0"&gt;ファジング&lt;/a&gt;とはなんなのか、ザックリとはランダムな入力値を大量に投げつけることによって不具合や脆弱性を発見するためのテストツールです。エッジケースのテスト、やはりどうしても抜けちゃいがちだし、ましてや脆弱性になりうる絶妙な不正データを人為的に作るのも難しいので、ここはツール頼みで行きましょう。&lt;/p&gt;
&lt;p&gt;Goでは1.18(2022年)から標準でgo fuzzコマンドとして追加されたらしいので、
&lt;a href="https://future-architect.github.io/articles/20220214a/"&gt;Go1.18から追加されたFuzzingとは&lt;/a&gt;のような解説記事を読むのもイメージを掴みやすいです。&lt;/p&gt;
&lt;p&gt;さて、dotnet/runtimeのFuzzingでは現状&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AssemblyNameInfoFuzzer&lt;/li&gt;
&lt;li&gt;Base64Fuzzer&lt;/li&gt;
&lt;li&gt;Base64UrlFuzzer&lt;/li&gt;
&lt;li&gt;HttpHeadersFuzzer&lt;/li&gt;
&lt;li&gt;JsonDocumentFuzzer&lt;/li&gt;
&lt;li&gt;NrbfDecoderFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesByteCharFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesStringFuzzer&lt;/li&gt;
&lt;li&gt;TextEncodingFuzzer&lt;/li&gt;
&lt;li&gt;TypeNameFuzzer&lt;/li&gt;
&lt;li&gt;UTF8Fuzzer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というのものが用意されてます。わかるようなわからないような。だいたいデータのパース系によく使われるものなので、その通りのところに用意されています。一番わかりやすいJsonDocumentFuzzerを見てみましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal sealed class JsonDocumentFuzzer : IFuzzer
{
    public string[] TargetAssemblies { get; } = [&amp;quot;System.Text.Json&amp;quot;];
    public string[] TargetCoreLibPrefixes =&amp;gt; [];
    public string Dictionary =&amp;gt; &amp;quot;json.dict&amp;quot;;

    // fuzzerからのランダムなバイト列が入力
    public void FuzzTarget(ReadOnlySpan&amp;lt;byte&amp;gt; bytes)
    {
        if (bytes.IsEmpty)
        {
            return;
        }

        // The first byte is used to select various options.
        // The rest of the input is used as the UTF-8 JSON payload.
        byte optionsByte = bytes[0];
        bytes = bytes.Slice(1);

        var options = new JsonDocumentOptions
        {
            AllowTrailingCommas = (optionsByte &amp;amp; 1) != 0,
            CommentHandling = (optionsByte &amp;amp; 2) != 0 ? JsonCommentHandling.Skip : JsonCommentHandling.Disallow,
        };

        using var poisonAfter = PooledBoundedMemory&amp;lt;byte&amp;gt;.Rent(bytes, PoisonPagePlacement.After);

        try
        {
            // それをParseに投げて、もし不正な例外が来たらなんかバグっていたということで
            JsonDocument.Parse(poisonAfter.Memory, options);
        }
        catch (JsonException) { }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ようは想定外のデータ入力で&lt;code&gt;JsonDocument.Parse&lt;/code&gt;が失敗しないことを祈る、といったものですね。正常に認識しているinvalidな値なら&lt;code&gt;JsonException&lt;/code&gt;をthrowするはずですが、&lt;code&gt;ArgumentException&lt;/code&gt;とか&lt;code&gt;StackOverflowException&lt;/code&gt;とかが出てきちゃった場合は認識できていない不正パターンなので、ちゃんとしたハンドリングが必要になってきます。&lt;/p&gt;
&lt;p&gt;では、これを参考にやっていきましょう、とはなりません。えー。まず、dotnet/runtimeのFuzzingではSharpFuzz, libFuzzer, そしてOneFuzzが使用されていると書いてあるのですが、OneFuzzはMicrosoft内部ツールなので外部では使用できません。正確には&lt;a href="https://www.publickey1.jp/blog/20/project_onefuzzwindowsmicorosoft_edge.html"&gt;2020年にオープンソース公開&lt;/a&gt;したものの、&lt;a href="https://github.com/microsoft/onefuzz"&gt;2023年にはクローズドに戻している&lt;/a&gt;状態です。まぁ事情は色々ある。しょーがない。&lt;/p&gt;
&lt;p&gt;というわけで、これはMicrosoft内部で動かすためのOneFuzzや、dotnet/runtimeで動かすために調整してある&lt;code&gt;IFuzzer&lt;/code&gt;といったフレームワーク部分が含まれているので、小規模な自分たちのコードをfuzzingするにあたっては、不要ですし、ぶっちゃけあまり参考にはなりません！解散！&lt;/p&gt;
&lt;h2&gt;Introducing SharpFuzz&lt;/h2&gt;
&lt;p&gt;そんなわけでdotnet/runtimeのFuzzingでも使われている&lt;a href="https://github.com/Metalnem/sharpfuzz"&gt;Metalnem/sharpfuzz: AFL-based fuzz testing for .NET&lt;/a&gt;を直接使っていきます。sharpfuzzは&lt;a href="https://lcamtuf.coredump.cx/afl/"&gt;afl-fuzz&lt;/a&gt;と連動して動くように作られている .NETライブラリです。3rd Partyライブラリですが作者はMicrosoftの人です（dotnet/runtimeで採用されている理由でもあるでしょう）。ReadMeのTrophiesでは色々なもののバグを見つけてやったぜ、と書いてあります。AngleSharpとかGoogle.ProtobufとかGraphQL-ParserとかMarkdigとかMessagePack for C#とImageSharpとか。まぁ、やはり用途としてはパーサーのバグを見つけるのには適切、という感じです。&lt;/p&gt;
&lt;p&gt;AFL(American Fuzzy Lop)ってなに？ということなのですが、そもそもファジングの「ランダムな入力値を大量に投げつける」行為は、完全なランダムデータを投げつけていくわけではありません。完全ランダムだとあまりにも時間がかかりすぎるため、脆弱性発見において実用的とは言えない。そこでAFLはシード値からのミューテーションと、カバレッジをトレースしながら効率よくデータを生成していきます。Wikipediaから引用すると&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;テスト対象のプログラム（テスト項目）のソースコードをインストルメント化することにより、afl-fuzzは、ソフトウェアのどのブロックが特定のテスト刺激で実行されたかを後で確認できる。そのため、AFLはグレーボックステストに使用することができる。遺伝的手法による検査データの生成に関連して、ファザーはテストデータをより適切に生成できるため、このメソッドを使用しない他のファザーよりも、処理中に以前は使用されていなかったコードブロックが実行される。その結果、コードカバレッジは比較的短い時間で比較的高い結果が得られる。この方法は、生成されたデータ内の構造を独立して（つまり、事前の情報なしで）生成することができる。このプロパティは、テストカバレッジの高いテストコーパス（テストケースのコレクション）を生成するためにも使用される。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;というわけでdotnet testのようにテストコードを渡したら全自動でやってくれる、というほど甘くはなくて、多少の下準備が必要になってきます。SharpFuzzは一連の処理をある程度やってくれるようにはなっていますが、そもそもに実行までに二段階の処理が必要になっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharpfazzコマンド(dotnet tool)でdllにトレースポイントを注入する&lt;/li&gt;
&lt;li&gt;その注入されたdll(とexe)をネイティブのfuzzing実行プロセス(afl-fuzzなど)に渡す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dllにトレースポイントを注入はお馴染みの&lt;a href="https://github.com/jbevain/cecil"&gt;Cecil&lt;/a&gt;でビルド済みのDLLのILを弄ってトレースポイントを仕込みます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/c3b43b60-8526-44cd-8482-6f1185206b65" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これは注入済みのdllですが、Trace.SharedMemとかTrace.PrevLocationとか、分岐点に対して明らかに注入している様が見えます。そうしたトレースポイントとの通信や実行データ生成などは外部プロセスが行うので、SharpFuzzというライブラリは、それ自体は実行ツールではなくて、それらとの橋渡しをするためのシステムということです。&lt;/p&gt;
&lt;p&gt;ではやっていきましょう！色々なシステムが絡んでくる分、ちょっとややこしく面倒くさいのと、ReadMeの例をそのままやると罠が多いので、少しアレンジしていきます。&lt;/p&gt;
&lt;p&gt;まずはRequirementsですが、実行機であるAFLがWindowsでは動きません(Linux, macOSでは動く)。なのでWSL上で動かしましょうという話になってくるのですが、それはあんまりにもやりづらいので、&lt;a href="https://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt;というLLVMが開発しているAFL互換のFuzzingツールを使っていくことにします。これはWindowsでビルドできます。&lt;/p&gt;
&lt;p&gt;自分でビルドする必要はなく、SharpFuzzの作者が連携して使うことを意識して用意してくれている&lt;a href="https://github.com/Metalnem/libfuzzer-dotnet/releases"&gt;libfuzzer-dotnetのReleasesページ&lt;/a&gt;から、バイナリを直接落としてきましょう。&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;次に、IL書き換えを行うツール&lt;code&gt;SharpFuzz.CommandLine&lt;/code&gt;を .NET toolで入れていきましょう。これはglobalでいいかな、と思います。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet tool install --global SharpFuzz.CommandLine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、今回は&lt;a href="https://github.com/kevin-montrose/Jil"&gt;Jil&lt;/a&gt;という、今はもうあまり使われることもないJsonシリアライザーをターゲットとしてやっていこうということなので、JilとSharpFuzzをインストールします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet add package Jil --version 2.15.4
dotnet add package SharpFuzz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで注意が必要なのは、Jilの最新バージョンはSharpFuzzにより発見されたバグが修正されているので、最新版を入れるとチュートリアルにはなりません！というわけでここは必ずバージョン下げて入れましょう。&lt;/p&gt;
&lt;p&gt;新規のConsoleApplicationで、コードは以下のようにします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;
using SharpFuzz;

// 実行機としてlibFuzzerを使う(引数はReadOnlySpan&amp;lt;byte&amp;gt;)
Fuzzer.LibFuzzer.Run(span =&amp;gt;
{
    try
    {
        using var stream = new MemoryStream(span.ToArray());
        using var reader = new StreamReader(stream);
        JSON.DeserializeDynamic(reader); // このメソッドが正しく動作してくれるかをテスト
    }
    catch (Jil.DeserializationException)
    {
        // Jil.DeserializationExceptionは既知の例外（正しくハンドリングできてる）なので握り潰し
        // それ以外の例外が発生したらルート側にthrowされて問題が検知される
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今度はベースになるテストデータを用意します。名前とかはなんでもいいんですが、&lt;code&gt;Testcases&lt;/code&gt;フォルダに&lt;code&gt;Test.json&lt;/code&gt;を追加しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/606cede7-9a20-4efe-8e58-642330ced8d5" alt="image" /&gt;&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;click&amp;quot;:&amp;quot;Close()&amp;quot;}]}}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このデータを元にしてfuzzerは値を変形させていくことになります。&lt;/p&gt;
&lt;p&gt;では実行しましょう！実行するためには、ビルドしてILポストプロセスしてlibFuzzer経由で動かす……。という一連の定型の流れが必要になるため、作者の用意してくれているPowerShellスクリプト&lt;a href="https://raw.githubusercontent.com/Metalnem/sharpfuzz/master/scripts/fuzz-libfuzzer.ps1"&gt;fuzz-libfuzzer.ps1&lt;/a&gt;をダウンロードしてきて使いましょう。&lt;/p&gt;
&lt;p&gt;とりあえず&lt;code&gt;fuzz-libfuzzer.ps1&lt;/code&gt;と&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;をcsprojと同じディレクトリに配置して、以下のコマンドを実行します。&lt;code&gt;ConsoleApp24.csproj&lt;/code&gt;の部分だけ適当に変えてください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;動かすと、見つかった場合はいい感じに止まってくれます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/1ce45aa1-2d50-46f2-8f86-947db39406d6" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;なお、見つからなかった場合は無限に探し続けるので、なんとなくもう見つかりそうにないなあ、と思ったら途中で自分でとめる(Ctrl+C)必要があります。&lt;/p&gt;
&lt;p&gt;Testcasesには途中の残骸と、クラッシュした場合は&lt;code&gt;crash-id&lt;/code&gt;でクラッシュ時のデータが拾えます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/d90f5bb1-4509-41b6-a139-16789a5a501c" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;今回見つかったクラッシュデータは&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;popid&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でした。実際このデータを使って再現できます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;

//  クラッシュファイルのプロパティでデータはCopy to Output Directoryしてしまう
//  &amp;lt;None Update=&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;&amp;gt;
//    &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
//  &amp;lt;/None&amp;gt;
var crash = File.ReadAllBytes(&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;);
var span = crash.AsSpan();

// Fuzzing時と同じコード
using var stream = new MemoryStream(span.ToArray());
using var reader = new StreamReader(stream);
JSON.DeserializeDynamic(reader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上！完璧！便利！一度手順を理解してしまえば、そこまで難しいことではないので、是非ハンズオンでやってみることをお薦めします。なお、ps1のスクリプトは実行対象自身へのインジェクトは除外されるようになっているので、小規模な自分のコードでfuzzingを試してみたいと思った場合は、対象コードはexeとは異なるプロジェクトに分離しておく必要があります。&lt;/p&gt;
&lt;p&gt;ところで、AFLにはdictionaryという仕組みがあり、既知のキーワード集がある場合は生成速度を大幅に上昇させることが可能です。例えば&lt;a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/json.dict"&gt;json.dict&lt;/a&gt;を使う場合は&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot; -dict ./json.dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように指定します。JSONとかYAMLとかXMLとかZipとか、一般的な形式は&lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries"&gt;AFLplusplus/dictionaries&lt;/a&gt;などに沢山転がっています。独自に作ることも可能で、例えばdotnet/runtimeのFuzzingではBinaryFormatterのテストが置いてありますが、これは&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/binaryformatter-migration-guide/read-nrbf-payloads"&gt;NRBF(.NET Remoting Binary Format)&lt;/a&gt;の辞書、&lt;a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Fuzzing/DotnetFuzzing/Dictionaries/nrbfdecoder.dict"&gt;nrbfdecoder.dict&lt;/a&gt;を用意しているようでした。&lt;/p&gt;
&lt;p&gt;もちろん、なしでも動かすことはできますが、用意できそうなら用意しておくとよいでしょう。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;でも実際バグ見つかってたりするので、この手のライブラリを作る人だったら覚えておいて損はないです。シリアライザーに限らずパーサーに関わるものだったらネットワークプロトコルでも、なんでも適用可能です。ただし現状、入力が&lt;code&gt;byte[]&lt;/code&gt;に制限されているので、応用性自体はあるようで、なかったりはします。これがintとか受け入れてくれると、様々なメソッドに対してカジュアルに使えて、より便利な気もしますが……(実際go fuzzは&lt;code&gt;byte[]&lt;/code&gt;だけじゃなくて基本的なプリミティブの生成に対応している)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;列から適当に切り出してintとして使う、といったような処理だと、ミューテーションやカバレッジの関係上、適切な値を取得しにくいので、あまりうまくやれません。libFuzzerでは&lt;a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md"&gt;Structure-Aware Fuzzing with libFuzzer&lt;/a&gt;といったような手法が考案されていて、protocol buffersの構造を与えるとか、gRPCの構造を与えるとかでうまく活用している事例はあるようです。この辺はSharpFuzzの対応次第となります(いつかやりたい、とは書いてありましたが、現実的にいつ来るかというと、あまり期待しないほうが良いでしょう)&lt;/p&gt;
&lt;p&gt;Rustにも&lt;a href="https://github.com/rust-fuzz/cargo-fuzz"&gt;cargo fuzz&lt;/a&gt;といったcrateがあり、それなりに使われているようです。&lt;/p&gt;
&lt;p&gt;Fuzzingは適用範囲が限定的であることと下準備の手間などがあり、一般的なアプリケーション開発者においては、あまりメジャーなテスト手法ではないというのが現状だと思いますが、使えるところはないようで意外とあるとも思うので、ぜひぜひ試してみてください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-03T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/11/19_cysharp_oss.html</guid>
      <link>https://neue.cc/2024/11/19_cysharp_oss.html</link>
      <title>CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-11-19" data-pagefind-meta="published:2024-11-19"&gt;&lt;a href="https://neue.cc/2024/11/19_cysharp_oss.html"&gt;CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-11-19&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;「CysharpのOSS群から見るModern C#の現在地」というタイトルでセッションしてきました。&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="73bfd578c3324a6e8ce74457445fe9c0" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;作りっぱなし、というわけではないですが（比較的メンテナンスしてるとは思います！）、リリースから年月が経ったライブラリをどう思っているかは見えないところありますよね、というわけで、その辺を軽く伝えられたのは良かったのではないかと思います。&lt;/p&gt;
&lt;p&gt;この中だと非推奨に近くなっているのが&lt;a href="https://github.com/Cysharp/ZString"&gt;ZString&lt;/a&gt;と&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;でしょうか。&lt;/p&gt;
&lt;h2&gt;Ulid vs .NET 9 UUID v7&lt;/h2&gt;
&lt;p&gt;スライドにも書きましたが、ULIDをそこそこ使ってきての感想としては、「Guidではないこと」が辛いな、と。独自文字列形式とか要らないし。そんなわけで私はむしろUUID v7のほうを薦めたいレベルだったりはします。.NET 9から&lt;code&gt;Guid.CreateVersion7()&lt;/code&gt;という形で、標準で生成できるようになりました。&lt;/p&gt;
&lt;p&gt;パフォーマンス的なところは些細なことなので問題ないのですが、 .NET 9未満との互換性が取れないのは厳しいところかもしれません。というわけで、自作のV7実装を用意してあげるといいでしょう。以下に置いておきますのでどうぞ（コードのベースはdotnet/runtimeのCCreateVersion7です）&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-Csharp"&gt;public static class GuidEx
{
    private const byte Variant10xxMask = 0xC0;
    private const byte Variant10xxValue = 0x80;
    private const ushort VersionMask = 0xF000;
    private const ushort Version7Value = 0x7000;

    public static Guid CreateVersion7() =&amp;gt; CreateVersion7(DateTimeOffset.UtcNow);

    public static Guid CreateVersion7(DateTimeOffset timestamp)
    {
        // 普通にGUIDを作る
        Guid result = Guid.NewGuid();

        // 先頭48bitをいい感じに埋める
        var unix_ts_ms = timestamp.ToUnixTimeMilliseconds();

        // GUID layout is int _a; short _b; short _c, byte _d;
        Unsafe.As&amp;lt;Guid, int&amp;gt;(ref Unsafe.AsRef(ref result)) = (int)(unix_ts_ms &amp;gt;&amp;gt; 16); // _a
        Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 2) = (short)(unix_ts_ms); // _b

        ref var c = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 3);
        c = (short)((c &amp;amp; ~VersionMask) | Version7Value);

        ref var d = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(ref result)), 8);
        d = (byte)((d &amp;amp; ~Variant10xxMask) | Variant10xxValue);

        return result;
    }

    // GuidにはTimestamp部分を取り出すメソッドがないので、これも用意してあげると便利
    public static DateTimeOffset GetTimestamp(in Guid guid)
    {
        // エンディアンについては特に考慮してません
        ref var p = ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(in guid));
        var lower = Unsafe.ReadUnaligned&amp;lt;uint&amp;gt;(ref p);
        var upper = Unsafe.ReadUnaligned&amp;lt;ushort&amp;gt;(ref Unsafe.Add(ref p, 4));
        var time = (long)upper + (((long)lower) &amp;lt;&amp;lt; 16);
        return DateTimeOffset.FromUnixTimeMilliseconds(time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UUID v7のよくあるユースケースはDBの主キーにGUID(UUID v4)の代わりに使う、ということです。UUID v4だとランダムに配置されるので断片化して、auto incrementの主キーに比べると色々と遅くなる。それがv7だとランダムの性質を持ちつつも配置場所はタイムスタンプベースなのでauto incrementと同様になるため性能劣化がない。&lt;/p&gt;
&lt;p&gt;という理屈を踏まえたうえで、.NETのUUID v7事情を踏まえると単純に置き換えるだけで良い、とはなりません。&lt;/p&gt;
&lt;p&gt;GUIDは内部的なバイナリデータとしてはリトルエンディアンで保持していて、出力時に切り分けるというデザインになっています(無指定の場合はlittleEndianでの出力)。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public readonly struct Guid
{
    public byte[] ToByteArray()
    public byte[] ToByteArray(bool bigEndian)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination, bool bigEndian, out int bytesWritten)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String(char36)として格納するなら気にしなくてもいいのですが、GUID型やバイナリ型としてデータベースに格納する時は、UUID v7に関してはビッグエンディアンで書き出さないと、ソート可能にならない非常に都合が悪い。これのハンドリングは言語のデータベースドライバーライブラリの責務となっています。&lt;/p&gt;
&lt;p&gt;代表的なライブラリを見ていくと、MySQLの&lt;a href="https://mysqlconnector.net/connection-options/"&gt;mysqlconnector-netはコネクションストリング&lt;/a&gt;で &lt;code&gt;GuidFormat=Binary16&lt;/code&gt; を指定することでbig-endianでBINARY(16)に書き込む設定となります。&lt;/p&gt;
&lt;p&gt;PostgreSQLの場合、&lt;a href="https://github.com/npgsql/npgsql/blob/94de20fed2e7e64a1eb6f26c9fc044131a362958/src/Npgsql/Internal/Converters/Primitive/GuidUuidConverter.cs#L29"&gt;npgsqlのGuidUuidConverter&lt;/a&gt;が常にbigEndianとして処理するようになっているようです。&lt;/p&gt;
&lt;p&gt;ではMicrosoft SQL Serverはどうかというと、ばっちしlittle-endianです。ダメです。というわけで、性能を期待してCreateVersion7を使うと、逆に断片化して遅くなるような憂き目にあいます。&lt;/p&gt;
&lt;p&gt;こちらは&lt;a href="https://github.com/dotnet/SqlClient/discussions/2999"&gt;dotnet/SqlClientのdiscussions#2999&lt;/a&gt;で議論されているようなので、成り行きに注目ということで。今までとの互換性などを考えると一括でbigにしてしまえばいいじゃん、というわけにもいかないしで、中々素直にはいかないかもしれませんね……。&lt;/p&gt;
&lt;p&gt;なお、このことは別に.NET 9がリリースされる前にもわかっていたことなのに（私でもダメだという状況は把握していた）、リリースされるまでアクションが全く起きないというところに、今のSQL Serverへのやる気を感じたりなかったり。&lt;/p&gt;
&lt;h2&gt;MagicOnion&lt;/h2&gt;
&lt;p&gt;イベントではCysharpの @mayuki さんからMagicOnionの入門セッションもありました！&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="d5b4ad47f5cd4e9f984022e64d623d51" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;MagicOnionも2016年の初リリース、2018年のリブート(v2)、googleのgRPC C Coreからgrpc-dotnetベースへの変更、クライアントのHttpClientベースへの変更など、内部的には色々変わってきたし機能面でも磨かれてきています。まだまだ次のアップデートが控えている、最前線で戦える強力なフレームワークとなっています！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 19 Nov 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-11-19T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/08/29_AlternateLookup.html</guid>
      <link>https://neue.cc/2024/08/29_AlternateLookup.html</link>
      <title>.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-08-29" data-pagefind-meta="published:2024-08-29"&gt;&lt;a href="https://neue.cc/2024/08/29_AlternateLookup.html"&gt;.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-08-29&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;.NET 9 から辞書系のクラス、&lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;ConcurrentDictionary&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, &lt;code&gt;FrozenDictionary&lt;/code&gt;, &lt;code&gt;FrozenSet&lt;/code&gt;に &lt;code&gt;GetAlternateLookup&amp;lt;TKey, TValue, TAlternate&amp;gt;()&lt;/code&gt; というメソッドが追加されました。今までDictionaryの操作はTKey経由でしかできませんでした。それは当たり前、なのですが、困るのが文字列キーで、これはstringでも操作したいし、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;でも操作したくなります。今までは&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;しか手元にない場合はToStringでstring化が必須でした、ただたんにDictionaryの値を参照したいだけなのに！&lt;/p&gt;
&lt;p&gt;その問題も、.NET 9から追加された&lt;code&gt;GetAlternateLookup&lt;/code&gt;を使うと、辞書に別の検索キーを持たせることが出来るようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var dict = new Dictionary&amp;lt;string, int&amp;gt;
{
    { &amp;quot;foo&amp;quot;, 10 },
    { &amp;quot;bar&amp;quot;, 20 },
    { &amp;quot;baz&amp;quot;, 30 }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;char&amp;gt;&amp;gt;();

var keys = &amp;quot;foo, bar, baz&amp;quot;;

// .NET 9 SpanSplitEnumerator
foreach (Range range in keys.AsSpan().Split(','))
{
    ReadOnlySpan&amp;lt;char&amp;gt; key = keys.AsSpan(range).Trim();

    // ReadOnlySpan&amp;lt;char&amp;gt;でstring keyの辞書のGet/Add/Removeできる
    int value = lookup[key];
    Console.WriteLine(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ところでSplitは、通常のstringのSplitは配列とそれぞれ区切られたstringをアロケーションしてしまいますが、.NET 8から、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;に対して固定個数のSplitができる&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.split"&gt;MemoryExtensions.Split&lt;/a&gt;が追加されました。.NET 9では、更にSpanSplitEnumeratorを返すSplitが新たに追加されています。これにより一切の追加のアロケーションなく、元の文字列から&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;を切り出すことができます。&lt;/p&gt;
&lt;p&gt;そうして取り出した&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;のキーで参照するために、&lt;code&gt;GetAlternateLookup&lt;/code&gt;が必要になってくるわけです。&lt;/p&gt;
&lt;p&gt;使い道としては、例えばシリアライザーは頻繁にキーと値のルックアップが必要になります。私の開発している&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#&lt;/a&gt;では、高速でアロケーションフリーなデシリアライズのために、複数の戦略を採用しています。その一つはUTF8の文字列を8バイトずつの&lt;a href="https://en.wikipedia.org/wiki/Automata_theory"&gt;オートマトン&lt;/a&gt;として扱う&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs"&gt;AutomataDictionary&lt;/a&gt;、この部分は更にIL EmitやSource Generatorではインライン化して埋め込まれて辞書検索もなくしています。もう一つは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/5793c81/src/MessagePack/Internal/AsymmetricKeyHashTable.cs"&gt;AsymmetricKeyHashTable&lt;/a&gt;という機構で、これは同一の対象を表す2つのキーで検索可能にしようというもので、内部的には &lt;code&gt;byte[]&lt;/code&gt; と &lt;code&gt;ArraySegment&amp;lt;byte&amp;gt;&lt;/code&gt; で検索できるような辞書を作っていました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// MessagePack for C#のもの
internal interface IAsymmetricEqualityComparer&amp;lt;TKey1, TKey2&amp;gt;
{
    int GetHashCode(TKey1 key1);
    int GetHashCode(TKey2 key2);
    bool Equals(TKey1 x, TKey1 y);
    bool Equals(TKey1 x, TKey2 y); // TKey1とTKey2での比較
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり、今までは、こうした別の検索キーを持った辞書が必要なシチュエーションでは、辞書そのものの自作が必要だったし、パフォーマンスのためには基礎的なデータ構造すら自作を厭わない必要がありましたが、.NET 9からはついに標準でそれが実現するようになりました。&lt;/p&gt;
&lt;p&gt;AlternateLookupでも必要なのは&lt;code&gt;IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;&lt;/code&gt;で、以下のような定義になっています。(&lt;code&gt;IAsymmetricEqualityComparer&lt;/code&gt;と似たような定義なので、また時代を10年先取りしてしまったか)&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;
    where TAlternate : allows ref struct
    where T : allows ref struct
{
    bool Equals(TAlternate alternate, T other);
    int GetHashCode(TAlternate alternate);
    T Create(TAlternate alternate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C# 13から追加された言語機能 &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/ref-struct"&gt;allows ref struct&lt;/a&gt; によってref struct、つまり&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;などをジェネリクスの型引数にすることができるようになりました。&lt;/p&gt;
&lt;p&gt;基本的にはこれは&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;とセットで実装する必要があります。実際、&lt;code&gt;Dictionary.GetAlternateLookup&lt;/code&gt;ではDictionaryの&lt;code&gt;IEqualityComparer&lt;/code&gt;が&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していないと実行時例外が出ます（コンパイル時チェックではありません！）また、EqualityComparerなのに&lt;code&gt;Create&lt;/code&gt;があるのが少し奇妙ですが、これはAdd操作のために必要だからです。&lt;/p&gt;
&lt;p&gt;現状、標準では&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;は&lt;code&gt;string&lt;/code&gt;用しかありません。stringで標準的に使われるEqualityComparerは&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していて、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;で操作できますが、それ以外は用意されていません。&lt;/p&gt;
&lt;p&gt;しかし、現代において現実的に必要なのはUTF8です、&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;です。シリアライザーのルックアップで使う、と言いましたが、現代のシリアライザーの入力はUTF8です。&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;の出番なんてありません。というわけで、以下のような&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を用意しましょう！&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public sealed class Utf8StringEqualityComparer : IEqualityComparer&amp;lt;byte[]&amp;gt;, IAlternateEqualityComparer&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;, byte[]&amp;gt;
{
    public static IEqualityComparer&amp;lt;byte[]&amp;gt; Default { get; } = new Utf8StringEqualityComparer();

    // IEqualityComparer

    public bool Equals(byte[]? x, byte[]? y)
    {
        if (x == null &amp;amp;&amp;amp; y == null) return true;
        if (x == null || y == null) return false;

        return x.AsSpan().SequenceEqual(y);
    }

    public int GetHashCode([DisallowNull] byte[] obj)
    {
        return GetHashCode(obj.AsSpan());
    }

    // IAlternateEqualityComparer

    public byte[] Create(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        return alternate.ToArray();
    }

    public bool Equals(ReadOnlySpan&amp;lt;byte&amp;gt; alternate, byte[] other)
    {
        return other.AsSpan().SequenceEqual(alternate);
    }

    public int GetHashCode(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        // System.IO.Hashing package, cast to int is safe for hashing
        return unchecked((int)XxHash3.HashToUInt64(alternate));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;は標準では参照比較になってしまいますが、データの一致で比較したいので、&lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;.SequenceEqual&lt;/code&gt; を使います。これは、特にTが幾つかのプリミティブの場合はSIMDを活用して高速な比較が実現されています。ハッシュコードの算出は、高速なアルゴリズム&lt;a href="https://github.com/Cyan4973/xxHash"&gt;xxHash&lt;/a&gt;シリーズの最新版であるXXH3の.NET実装である&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3"&gt;XxHash3&lt;/a&gt;を用いるのがベストでしょう。これはNuGetから&lt;code&gt;System.IO.Hashing&lt;/code&gt;をインポートする必要があります。64ビットで算出するため戻り値はulongですが、32ビット値が必要な場合はxxHashの作者より、ただたんに切り落とすだけで問題ないと言明されているため、intにキャストするだけで済まします。&lt;/p&gt;
&lt;p&gt;使う場合の例は、こんな感じです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Utf8StringEqualityComparerを設定した辞書を作る

var dict = new Dictionary&amp;lt;byte[], bool&amp;gt;(Utf8StringEqualityComparer.Default)
{
    { &amp;quot;foo&amp;quot;u8.ToArray(), true },
    { &amp;quot;bar&amp;quot;u8.ToArray(), false },
    { &amp;quot;baz&amp;quot;u8.ToArray(), false }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;&amp;gt;();

// こんな入力があるとする

ReadOnlySpan&amp;lt;byte&amp;gt; json = &amp;quot;&amp;quot;&amp;quot;    
{
    &amp;quot;foo&amp;quot;: 0,
    &amp;quot;bar&amp;quot;: 0,
    &amp;quot;baz&amp;quot;: 0
}
&amp;quot;&amp;quot;&amp;quot;u8;

// System.Text.Json
var reader = new Utf8JsonReader(json);

while (reader.Read())
{
    if (reader.TokenType == JsonTokenType.PropertyName)
    {
        // 切り出したKeyで検索できる
        ReadOnlySpan&amp;lt;byte&amp;gt; key = reader.ValueSpan;
        var flag = lookup[key];
        
        Console.WriteLine(flag);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一つ注意なのは、&lt;code&gt;string&lt;/code&gt;と&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;でAlternateKeyを作ろうとするのはやめたほうが良いでしょう。それだと、常にエンコードが必要になり、悪いとこどりのようになってしまいます(&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.rune"&gt;Rune&lt;/a&gt;を使ってアロケーションレスで処理するにしても、どちらにせよバイナリ比較だけで済ませられる&lt;code&gt;byte[]&lt;/code&gt;キーとは比較になりません）。どうしても両方の検索が必要なら、辞書を二つ用意するほうがマシです。&lt;/p&gt;
&lt;p&gt;ともあれ、これは私にとっては念願の機能です！色々なバリエーションで、Span対応のためにジェネリクスにもできずに決め打ちで辞書を何度も作ってきました、汎用的に使えるようになったのは大歓迎です。&lt;code&gt;allows ref struct&lt;/code&gt;はジェネリクス定義での煩わしさもありますが（自動判定での付与でも良かったような？）、言語としては重要な進歩です。.NET 9, C# 13、使っていきましょう。現状はまだプレビューですが、11月に正式版がリリースされるはずです。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 29 Aug 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-08-29T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/07/11_mvp-renew14.html</guid>
      <link>https://neue.cc/2024/07/11_mvp-renew14.html</link>
      <title>Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-07-11" data-pagefind-meta="published:2024-07-11"&gt;&lt;a href="https://neue.cc/2024/07/11_mvp-renew14.html"&gt;Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-07-11&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Microsoft MVPは一年ごとに再審査されるのですが、今年も更新しました。2011年から初めて14回目ということで、長い！のですが、引き続きC#の最前線に立ち続けられていると思います。以下、審査用書類に出した、審査期間での実績一覧です。&lt;/p&gt;
&lt;h2&gt;OSS New&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;MagicPhysX&lt;/a&gt;&lt;br /&gt;
.NET PhysX 5 binding to all platforms(win, osx, linux) for 3D engine, deep learning, dedicated server of gaming.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/PrivateProxy"&gt;PrivateProxy&lt;/a&gt;&lt;br /&gt;
Source Generator and .NET 8 UnsafeAccessor based high-performance strongly-typed private accessor for unit testing and runtime.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Utf8StringInterpolation&lt;/a&gt;&lt;br /&gt;
Successor of ZString; UTF8 based zero allocation high-peformance String Interpolation and StringBuilder.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;&lt;br /&gt;
The new future of dotnet/reactive and UniRx.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Claudia"&gt;Claudia&lt;/a&gt;&lt;br /&gt;
Unofficial Anthropic Claude API client for .NET.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StreamReader"&gt;Utf8StreamReader&lt;/a&gt;&lt;br /&gt;
Utf8 based StreamReader for high performance text processing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OSS Update&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/StructureOfArraysGenerator"&gt;StructureOfArraysGenerator&lt;/a&gt;&lt;br /&gt;
Structure of arrays source generator to make CPU Cache and SIMD friendly data structure for high-performance code in .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;&lt;br /&gt;
Fast .NET C# Implementation of ULID for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;&lt;br /&gt;
Zero Allocation Text/Structured Logger for .NET with StringInterpolation and Source Generator, built on top of a Microsoft.Extensions.Logging.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZString/"&gt;ZString&lt;/a&gt;&lt;br /&gt;
Zero Allocation StringBuilder for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack-CSharp&lt;/a&gt;&lt;br /&gt;
Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin).&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ObservableCollections"&gt;ObservableCollections&lt;/a&gt;&lt;br /&gt;
High performance observable collections and synchronized views, for WPF, Blazor, Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UnitGenerator/"&gt;UnitGenerator&lt;/a&gt;&lt;br /&gt;
C# Source Generator to create value-object, inspired by units of measure.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;&lt;br /&gt;
Zero encoding extreme performance binary serializer for C# and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;&lt;br /&gt;
Generate C# FFI from Rust for automatically brings native code and C native library to .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/DFrame"&gt;DFrame&lt;/a&gt;&lt;br /&gt;
Distributed load testing framework for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MessagePipe"&gt;MessagePipe&lt;/a&gt;&lt;br /&gt;
High performance in-memory/distributed messaging pipeline for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UniTask"&gt;UniTask&lt;/a&gt;&lt;br /&gt;
Provides an efficient allocation free async/await integration for Unity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Speaker&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition"&gt;CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/pulse1923/metabasupuratutohuomu-inspix-world-haphpmoc-plus-plus-momatometec-number-nitong-magiconiongazhi-erubatukuendozui-shi-hua-shou-fa"&gt;メタバースプラットフォーム 「INSPIX WORLD」はPHPもC++もまとめてC#に統一！ ～MagicOnionが支えるバックエンド最適化手法～ - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/ta-yan-yu-gameinnochang-he-norustnohuo-yong-fa-csbindgenniyoruc-number-x-rust-ffishi-jian-shi-li"&gt;他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例 - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Book&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.jp/dp/4862465900"&gt;Unityプログラミング・バイブル R6号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;世界中見てもこんだけ叩き出してる人間いないので、これだけやってれば、満場一致で更新でいいでしょう。はい。自分で言うのもあれですが。あれ。&lt;/p&gt;
&lt;p&gt;期間中で言うと&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;が大型タイトル（？）です。また、Updateのほうも大型リニューアルとして&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger v2&lt;/a&gt;は相当力の入ったものになっています。今年の範囲だと、こないだ出した&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework v5&lt;/a&gt;や、近いうちにリリースされる（はず）の&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C# v3&lt;/a&gt;といった計画も控えています。なお、&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;は現在メンテナーじゃないので実績に含めてはいないのですが、引き続きアクティブに開発されています！&lt;/p&gt;
&lt;p&gt;ところで、このサイトも地味に更新されていて（自作のC#製静的サイトジェネレーターで作られています、ハンドメイド！）、ついに全文検索が搭載されました！上のほうのインプットボックスがそれになっているので、ぜひ試してみてください。ちょっと引っ掛かり方が変な可能性も高いですが、そこは検索ライブラリの仕様なので、いつか改善されるでしょう。多分きっと。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-07-11T00:00:00+09:00</a10:updated>
    </item>
  </channel>
</rss>