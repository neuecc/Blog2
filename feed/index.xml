<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>neue cc</title>
    <link>http://neue.cc/</link>
    <description>C# Technical Blog</description>
    <language>ja</language>
    <lastBuildDate>Wed, 11 May 2022 16:36:51 +0900</lastBuildDate>
    <item>
      <guid isPermaLink="true">https://neue.cc/2022/05/11_AlterNats.html</guid>
      <link>https://neue.cc/2022/05/11_AlterNats.html</link>
      <title>AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2022/05/11_AlterNats.html"&gt;AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2022-05-11&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;タイトルはここぞとばかりに全盛りにしてみました！今回NATSの.NETクライアント実装としてAlterNatsというライブラリを新しく作成し、公開しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/AlterNats"&gt;github - Cysharp/AlterNats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公式の既存クライアントの3倍以上、StackExchange.RedisのPubSubと比較して5倍以上高速であり、通常のPubSubメソッドは全てゼロアロケーションです。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/164392256-46d09111-ec70-4cf3-b33d-38dc5d258455.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;そもそも&lt;a href="https://nats.io/"&gt;NATS&lt;/a&gt;とはなんぞやか、というと、クラウドネイティブなPubSubのミドルウェアです。&lt;a href="https://www.cncf.io/"&gt;Cloud Native Computing Foundation&lt;/a&gt;のincubating projectなので、それなりの知名度と実績はあります。&lt;/p&gt;
&lt;p&gt;PubSubというと、特にC#だと&lt;a href="https://redis.io/"&gt;Redis&lt;/a&gt;のPubSub機能で行うのが、&lt;a href="https://github.com/StackExchange/StackExchange.Redis"&gt;StackExchange.Redis&lt;/a&gt;という実績あるライブラリもあるし、AWSやAzure、GCPがマネージドサービスも用意しているしで、お手軽でいいのですが、盲目的にそれを使うのが良いのか少し疑問に思っていました。&lt;/p&gt;
&lt;p&gt;RedisはKVS的な使い方がメインであり、PubSubはどちらかというとオマケ機能であるため&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PubSub専用のモニタリングの欠如&lt;/li&gt;
&lt;li&gt;PubSub用のクラスタリング対応&lt;/li&gt;
&lt;li&gt;マネージドサービスでの価格体系のバランスの悪さ（PubSub特化ならメモリはあまりいらない）&lt;/li&gt;
&lt;li&gt;そもそものパフォーマンス&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といった点が具体的な懸念です。そして、NATSはPubSub専用に特化されているため、そのためのシステムが豊富に組まれているし、性能も申し分なさそうに思えました。しいて欠点を言えばマネージドサービスが存在しないのがネックですが、純粋なPubSubとしての利用ならば永続化処理について考える必要がないので、ミドルウェアとしては運用しやすい部類にはいるのではないかと思っています。（NATS自体はNATS JetStreamという機能によってAt-least / exactly onceの保証のあるメッセージングの対応も可能ですが、そこに対応させるにはストレージが必要になる場合もあります）&lt;/p&gt;
&lt;p&gt;しかし調べていくうちに懸念となったのが公式クライアントである&lt;a href="https://github.com/nats-io/nats.net"&gt;nats.net&lt;/a&gt;で、あまり使いやすくないのですね。async/awaitにも対応していないし、古くさく、それどころかそもそも.NET的に奇妙に見えるAPIであり、そうなるとパフォーマンスに関しても疑問に思えてくる。&lt;/p&gt;
&lt;p&gt;何故そうなっているかの理由はReadMeにも明記されていて、メンテナンス性のためにGoクライアント(ちなみにNATS Server自体はGoで書かれている)と同じようなコードベースになっている、と。そのためC#的ではない部分が多々あるし、GoとC#ではパフォーマンスを出すための書き方が全く異なるので、あまり良い状況ではなさそう。&lt;/p&gt;
&lt;p&gt;それならば完全にC#に特化して独自に作ってしまうほうがいいだろうということで、作りました。公式クライアントと比べると全ての機能をサポートしているわけではない（JetStreamにも対応していないしLeaf Nodes運用で必須になるであろうTLSにも対応していません）のですが、PubSubのNATS Coreに特化して、まずは最高速を叩き出せるようにしました。PubSub利用する分には機能面での不足はないはずです。&lt;/p&gt;
&lt;p&gt;AlterNatsは公式じゃないAlternativeなNATSクライアントという意味です。まんまですね。割と語感が良いので命名的には結構気に入ってます。&lt;/p&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;APIは、&lt;code&gt;nats.net&lt;/code&gt;があまりにもC#っぽくなくややこしい、ということを踏まえて、シンプルに、簡単に、C#っぽく書けるように調整しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// create connection(default, connect to nats://localhost:4222)
await using var conn = new NatsConnection();

// for subscriber. await register to NATS server(not means await complete)
var subscription = await conn.SubscribeAsync&amp;lt;Person&amp;gt;(&amp;quot;foo&amp;quot;, x =&amp;gt;
{
    Console.WriteLine($&amp;quot;Received {x}&amp;quot;);
});

// for publisher.
await conn.PublishAsync(&amp;quot;foo&amp;quot;, new Person(30, &amp;quot;bar&amp;quot;));

// unsubscribe
subscription.Dipose();

// ---

public record Person(int Age, string Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Subscribeでhandlerを登録し、Publishでメッセージを飛ばす。データは全て自動でシリアライズされます（デフォルトではSystem.Text.Json、MessagePack for C#を用いたハイパフォーマンスなシリアライズも可能な拡張オプションも標準で用意してあります）&lt;/p&gt;
&lt;p&gt;別のURLへの接続や、認証のための設定などを行うNatsOptions/ConnectOptionsはイミュータブルです。そのため、with式で構築するやり方を取っています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Options can configure `with` operator
var options = NatsOptions.Default with
{
    Url = &amp;quot;nats://127.0.0.1:9999&amp;quot;,
    LoggerFactory = new MinimumConsoleLoggerFactory(LogLevel.Information),
    Serializer = new MessagePackNatsSerializer(),
    ConnectOptions = ConnectOptions.Default with
    {
        Echo = true,
        Username = &amp;quot;foo&amp;quot;,
        Password = &amp;quot;bar&amp;quot;,
    }
};

await using var conn = new NatsConnection(options);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NATSには標準で結果を受け取るプロトコルも用意されています。サーバー間の簡易的なRPCとして使うと便利なところもあるのではないかと思います。これも&lt;code&gt;SubscribeRequestAsync&lt;/code&gt;/&lt;code&gt;RequestAsync&lt;/code&gt;という形で簡単に直感的に書けるようにしました（Request側は戻り値の型を指定する必要があるため、型指定が少しだけ冗長になります）&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Server
await conn.SubscribeRequestAsync(&amp;quot;foobar&amp;quot;, (int x) =&amp;gt; $&amp;quot;Hello {x}&amp;quot;);

// Client(response: &amp;quot;Hello 100&amp;quot;)
var response = await conn.RequestAsync&amp;lt;int, string&amp;gt;(&amp;quot;foobar&amp;quot;, 100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例では &lt;code&gt;await using&lt;/code&gt;ですぐに破棄してしまっていますが、基本的にはConnectionはシングルトンによる保持を推奨しています。staticな変数に詰めてもいいし、DIでシングルトンとして登録してしまってもいいでしょう。接続は明示的にConnectAsyncすることもできますが、接続されていない場合は自動で接続を開くようにもなっています。&lt;/p&gt;
&lt;p&gt;コネクションはスレッドセーフで、物理的にも一つのコネクションには一つの接続として繋がり、全てのコマンドは自動的に多重化されます。これにより裏側で自動的にバッチ化された高効率な通信を実現していますが、負荷状況に応じて複数のコネクションを貼った場合が良いケースもあります。AlterNatsではNatsConnectionPoolという複数コネクションを内包したコネクションも用意しています。また、クライアント側で水平シャーディングを行うためのNatsShardingConnectionもあるため、必要に応じて使い分けることが可能です。&lt;/p&gt;
&lt;p&gt;内部のロギングはMicrosoft.Extensions.Loggingで管理されています。&lt;code&gt;AlterNats.Hosting&lt;/code&gt;パッケージを使うと、Generic Hostと統合された形で適切なILoggerFactoryの設定と、シングルトンのサービス登録を行ってくれます。&lt;/p&gt;
&lt;p&gt;DIでの取り出しは直接NatsConnectionを使わずに、INatsCommandを渡すことで余計な操作（コネクションの切断など）が出来ないようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using AlterNats;

var builder = WebApplication.CreateBuilder(args);

// Register NatsConnectionPool, NatsConnection, INatsCommand to ServiceCollection
builder.Services.AddNats();

var app = builder.Build();

app.MapGet(&amp;quot;/subscribe&amp;quot;, (INatsCommand command) =&amp;gt; command.SubscribeAsync(&amp;quot;foo&amp;quot;, (int x) =&amp;gt; Console.WriteLine($&amp;quot;received {x}&amp;quot;)));
app.MapGet(&amp;quot;/publish&amp;quot;, (INatsCommand command) =&amp;gt; command.PublishAsync(&amp;quot;foo&amp;quot;, 99));

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;メタバースアーキテクチャ&lt;/h2&gt;
&lt;p&gt;Cysharpでは&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;という .NET/Unity で使えるネットワークフレームワークを作っているわけですが、AlterNatsはこれと絡めることで、構成の幅を広げることができると考えています、というかむしろそのために作りました。&lt;/p&gt;
&lt;p&gt;クライアントにUnity、サーバーにMagicOnionがいるとして、サーバーが一台構成なら、平和です、繋げるだけですもの。開発の最初とかローカルでは楽なのでこの状態でもいいですね。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/164406771-58318153-c6a7-49c0-b3af-2b8389e2c9c1.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;しかし現実的にはサーバーは複数台になるので、そうなると色々なパターンが出てきます。よくあるのが、ロードバランサーを立ててそれぞれが別々のサーバーに繋がっているものを、更に後ろのPubSubサーバーを通して全サーバーに分配するパターン。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/164409016-b6e99f36-bdf7-47a9-80a6-558010963a36.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これはNode.jsのリアルタイムフレームワークである&lt;a href="https://socket.io/"&gt;Socket.IO&lt;/a&gt;のRedisアダプター、それの.NET版である&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/signalr/overview/getting-started/introduction-to-signalr"&gt;SignalR&lt;/a&gt;のRedisバックプレーン、もちろんMagicOnionにもあるのですが、このパターンはフレームワークでサポートされている場合も多いです。RedisのPubSubでできることはNATSでもできる、ということで、NATSでもできます。&lt;/p&gt;
&lt;p&gt;これは各サーバーをステートレスにできるのと、スケールしやすいので、Chatなどの実装にはやりやすい。欠点はステートを持ちにくいので、クライアントにステートがあり、データのやり取りをするタイプしか実装できません。サーバー側にステートを持ったゲームロジックは持たせずらいでしょう（ステートそのものは各サーバーで共有できないため）。また、PubSubを通すことによるオーバーヘッドも気になるところかもしれません。&lt;/p&gt;
&lt;p&gt;ロードバランサーを立てる場合、ロードバランサーのスティッキーセッションを活用して一台のサーバーに集約させるというパターンもあります（あるいは独自プロトコルでもリバースプロキシーを全面に立てて、カスタムなロジックで後ろの台を決定することもほぼ同様の話です）。ただし、色々なユーザーを同一サーバーに集約させたいようなケースでは、そのクッキーの発行誰がやるの、みたいなところは変わらずありますね。そこまで決めれるならIPアドレスを返して直繋ぎさせてしまってもいいんじゃないの？というのも真です。&lt;/p&gt;
&lt;p&gt;そうした外側に対象のIPアドレスを教えてくれるサービスがいて、先にそれに問い合わせてから、対象のサーバーへ繋ぎに行くパターンは、古典的ですが安定です。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/164417937-7d1adedb-36ee-453b-9ca6-9d41aded50af.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;この場合は同一サーバーに繋ぎにいくためにサーバー内にインメモリでフルにステートを持たせることが出来ますし、いわゆるゲームループを中で動かして処理するようなこともできます。また、画面のないヘッドレスUnityなどをホストして、クライアントそのものをサーバー上で動かすこともできますね。&lt;/p&gt;
&lt;p&gt;しかし、このパターンは素直なようでいて、実際VMだとやりやすいのですが、Kubernetesでやるのは難しかったりします。というのも、Kubernetesの場合は外部にIPが露出していないため、クラスター内の一台の特定サーバーに繋ぎにいくというのが難しい……！&lt;/p&gt;
&lt;p&gt;このような場合に最近よく活用されているのが&lt;a href="https://agones.dev/site/"&gt;Agones&lt;/a&gt;というGoogleが主導して作っているKubernetesの拡張で、まさにゲーム向きにKubernetesを使えるようにするためのシステムです。&lt;/p&gt;
&lt;p&gt;ただし、これはこれで難点があって、Agonesが想定しているゲームサーバーは1プロセス1ゲームセッション(まさにヘッドレスUnityのような)のホスティングであるため、1つのプロセスに多数のゲームセッションをホストさせるような使い方はそのままだと出来ません。コンテナなので、仮想的なプロセスを複数立ち上げればいいでしょ、というのが思想なのはわからなくもないのですが、現実的には軽量なゲームサーバー（それこそMagicOnionで組んだりする場合）なら、1プロセスに多数のゲームセッションを詰め込めれるし、これをコンテナで分けて立ち上げてしまうとコスト面では大きな差が出てしまいます。&lt;/p&gt;
&lt;p&gt;さて、Cysharpではステートフルな、特にゲームに向いたC#サーバーを構築するための補助ライブラリとして&lt;a href="https://github.com/Cysharp/LogicLooper"&gt;LogicLooper&lt;/a&gt;というゲームループを公開しています。このライブラリはこないだリリースした&lt;a href="https://neue.cc/2022/04/08_priconne-grandmasters.html"&gt;プリコネ！グランドマスターズ&lt;/a&gt;でも使用していますが、従来MagicOnionと同居して使っていたLogicLooperを、剥がしたアーキテクチャはどうだろうか、という提案があります。（実際のプリコネ！グランドマスターズのアーキテクチャはリバースプロキシーを使った方式を採用しているので、この案とは異なります）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/164417734-f2ec80e7-f12f-4a84-8252-ce28f9b53f05.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;パーツが増えて複雑になったように見えて、この構成には大きな利点があります。まず、同居しているものがなくなったので複雑になったようで実はシンプルになっています。それぞれがそれぞれの役割にフルに集中できるようになるため、パフォーマンスも良くなり、かつ、性能予測もしやすくなります。特にロジックをフルに回転させるLogicLooperがクライアントや接続数の影響を受けずに独立できているのは大きな利点です。&lt;/p&gt;
&lt;p&gt;ゲーム全体のステートはLogicLooper自体が管理するため、クライアントとの接続を直接受けているMagicOnion自体はステートレスな状態です。そのため、インフラ的にもロードバランサーの下にMagicOnionを並べるだけで済みますし、サーバー間の接続に伴う面倒事は全てNATSに押し付けられるため、インフラ管理自体はかなりシンプルな構成が取れます。&lt;/p&gt;
&lt;p&gt;また、MagicOnion自体はステートを持てるシステムであり、各ユーザーそれぞれのステートを持つのは容易です（サーバーを越えなければいい）。そこで、LogicLooperから届いたデータのうち、繋がってるユーザーに届ける必要がないデータは、MagicOnionの持つユーザーのステートを使ってカリング処理をして、そもそも転送しなかったり間引いたりして通信量を削減することで、ユーザーの体験が良くなります。&lt;/p&gt;
&lt;p&gt;各ユーザーから届くデータを使ったステート更新/データ送信に関しては、LogicLooperがゲームループ状になっているので、ループの間に溜まったデータをもとにしてバッチ処理を行えばいいでしょう。バッチ化というと、通信「回数」の削減のためのコマンドを単純にまとめあげて一斉送信するものと、内容を見て処理内容を縮小するパターンが考えられますが、LogicLooperを使ったアプローチでは後者を効率的に行なえます。前者のコマンドの一斉送信に関しては、AlterNatsが裏側で自動パイプライニング化としてまとめているので（後で詳しく説明します）、そこに関しても効率化されています。&lt;/p&gt;
&lt;p&gt;このアーキテクチャで気になるのがPubSub通信のオーバーヘッドですが、それに関しての解決策がAlterNatsで、究極的に高速なクライアントがあれば（さすがにインメモリには到底及ばないとはいえ）、そもそものクライアントとサーバーの間にもネットワークがいるわけで、経路のトータルで見れば実用的な範囲に収められる。という想定で作りました。&lt;/p&gt;
&lt;p&gt;ところで、そして究極的な利点は、全てC#で組めるということです。どういうことかというと、MagicOnionもLogicLooperも汎用的なC#フレームワークです。特別なプラグインを差し込んで処理するというわけではなくて、ふつーのC#コードをふつーに書くことで、それぞれの箇所に、アプリケーション固有のコードを仕込んでいくことができる。これが、本当の大きな利点です。専用のC++ミドルウェアを作って挟んで最適化できるぞ！などといったシステムは、素晴らしいことですが、専門性が高く再現性が低い。MagicOnionとLogicLooper、そしてAlterNatsを活用したこの構成なら、C#エンジニアなら誰でも（容易に）できる構成です。&lt;a href="https://cysharp.co.jp/"&gt;Cysharp&lt;/a&gt;のメッセージは「C#の可能性を切り開いていく」ですが、誰もが実現できる世界を作っていくというのが目標でもあります。&lt;/p&gt;
&lt;p&gt;なお、ワーカーとしてのLogicLooperを作るに&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/extensions/workers"&gt;Worker Service&lt;/a&gt;という.NET 6からのプロジェクトタイプが適切です。&lt;/p&gt;
&lt;h2&gt;ハイパフォーマンスSocketプログラミング&lt;/h2&gt;
&lt;h3&gt;Socket API&lt;/h3&gt;
&lt;p&gt;C#で最も低レベルにネットワーク処理を扱えるクラスは&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socket"&gt;Socket&lt;/a&gt;です。そして、非同期でハイパフォーマンスな処理を求めるなら&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socketasynceventargs"&gt;SocketAsyncEventArgs&lt;/a&gt;をうまく再利用しながらコールバックを仕込む必要があります。&lt;/p&gt;
&lt;p&gt;これは非常に厄介で些か難易度も高いのですが、現在はasync/awaitの時代、ちゃんとawaitできる***Asyncメソッド郡が用意されています。しかし、使ってはいけないAPI、使ってはいけないオーバーロードも並んでいるので、その選別が必要です。SocketのAPIは歴史的事情もあり混沌としてしまっているのです……。&lt;/p&gt;
&lt;p&gt;使うべきAPIを分かりやすく見分ける手段があります。それは戻り値が &lt;code&gt;ValueTask&lt;/code&gt; のものを選ぶことです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken)
public ValueTask&amp;lt;int&amp;gt; ReceiveAsync(Memory&amp;lt;byte&amp;gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
public ValueTask&amp;lt;int&amp;gt; SendAsync(ReadOnlyMemory&amp;lt;byte&amp;gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;オーバーロードにはTask返しのものもあるので、気をつけてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// これらのAPIは使ってはいけない
public Task ConnectAsync(string host, int port)
public Task&amp;lt;int&amp;gt; ReceiveAsync(ArraySegment&amp;lt;byte&amp;gt; buffer, SocketFlags socketFlags)
public Task&amp;lt;int&amp;gt; SendAsync(ArraySegment&amp;lt;byte&amp;gt; buffer, SocketFlags socketFlags)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ValueTask返しのAPIは内部的には &lt;code&gt;AwaitableSocketAsyncEventArgs&lt;/code&gt; というものがValueTaskの中身になるようになっていて、これがいい感じに使いまわされる(awaitされると内部に戻るようになっている）ことで、Taskのアロケーションもなく効率的な非同期処理を実現しています。&lt;code&gt;SocketAsyncEventArgs&lt;/code&gt;の使いにくさとは雲泥の差なので、これは非常にお薦めできます。&lt;/p&gt;
&lt;h3&gt;テキストプロトコルのバイナリコード判定&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.nats.io/reference/reference-protocols/nats-protocol"&gt;NATSのプロトコル&lt;/a&gt;はテキストプロトコルになっていて、文字列処理で簡単に切り出すことができます。実際これはStreamReaderを使うことで簡単にプロトコルの実装ができます。ReadLineするだけですから。しかし、ネットワークに流れるのは(UTF8)バイナリデータであり、文字列化は無駄なオーバーヘッドとなるため、パフォーマンスを求めるなら、バイナリデータのまま処理する必要があります。&lt;/p&gt;
&lt;p&gt;NATSでは先頭の文字列(&lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;MSG&lt;/code&gt;, &lt;code&gt;PING&lt;/code&gt;, &lt;code&gt;+OK&lt;/code&gt;, &lt;code&gt;-ERR&lt;/code&gt;など)によって流れてくるメッセージの種類が判定できます。文字列処理で空白でSplitして if (msg == &amp;quot;INFO&amp;quot;) などとすればめちゃくちゃ簡単ですが、先にも言った通り文字列変換は意地でも通しません。INFOは[73, 78, 70, 79]なので、Slice(0, 4).SequenceEqual で判定するのは悪くないでしょう。&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.sequenceequal"&gt;&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;のSequenceEqual&lt;/a&gt;はめちゃくちゃ最適化されていて、長いものであれば必要であればSIMDとかも使って高速に同値判定します。LINQのSequenceEqualとは別物です！&lt;/p&gt;
&lt;p&gt;しかし、もっと欲張って見てみましょう、プロトコルの識別子はサーバーから送られてくるものは全て4文字以内に収まっています。つまり、これはIntに変換しやすい状態です！というわけで、AlterNatsのメッセージ種判定コードはこうなっています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// msg = ReadOnlySpan&amp;lt;byte&amp;gt;
if(Unsafe.ReadUnaligned&amp;lt;int&amp;gt;(ref MemoryMarshal.GetReference&amp;lt;byte&amp;gt;(msg)) == 1330007625) // INFO
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これ以上速い判定はできないと思うので、理論上最速ということでいいでしょう。3文字の命令も、直後に必ずスペースや改行が来るので、それを含めた以下のような定数を使って判定に回しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal static class ServerOpCodes
{
    public const int Info = 1330007625;  // Encoding.ASCII.GetBytes(&amp;quot;INFO&amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
    public const int Msg = 541545293;    // Encoding.ASCII.GetBytes(&amp;quot;MSG &amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
    public const int Ping = 1196312912;  // Encoding.ASCII.GetBytes(&amp;quot;PING&amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
    public const int Pong = 1196314448;  // Encoding.ASCII.GetBytes(&amp;quot;PONG&amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
    public const int Ok = 223039275;     // Encoding.ASCII.GetBytes(&amp;quot;+OK\r&amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
    public const int Error = 1381123373; // Encoding.ASCII.GetBytes(&amp;quot;-ERR&amp;quot;) |&amp;gt; MemoryMarshal.Read&amp;lt;int&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;バイナリプロトコルなら特に何のひねりも必要なく実装できるので、バイナリプロトコルのほうが実装者に優しくて好きです……。&lt;/p&gt;
&lt;h3&gt;自動パイプライニング&lt;/h3&gt;
&lt;p&gt;NATSプロトコルの書き込み、読み込みは全てパイプライン（バッチ）化されています。これは&lt;a href="https://redis.io/docs/manual/pipelining/"&gt;RedisのPipelining&lt;/a&gt;の解説が分かりやすいですが、例えばメッセージを3つ送るのに、一つずつ送って、都度応答を待っていると、送受信における多数の往復がボトルネックになります。&lt;/p&gt;
&lt;p&gt;メッセージの送信において、AlterNatsは自動でパイプライン化しています。&lt;a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"&gt;System.Threading.Channels&lt;/a&gt;を用いてメッセージは一度キューに詰め込まれ、書き込み用のループが一斉に取り出してバッチ化します。ネットワーク送信が完了したら、再び送信処理待ち中に溜め込まれたメッセージを一括処理していく、という書き込みループのアプローチを取ることで、最高速の書き込み処理を実現しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/167585601-5634057e-812d-4b60-ab5b-61d9c8c37063.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;ラウンドトリップタイムの話だけではなく（そもそもNATSの場合はPublish側とSubscribe側が独立しているので応答待ちというのもないのですが）、システムコールの連続した呼び出し回数を削減できるという点でも効果が高いです。&lt;/p&gt;
&lt;p&gt;なお、.NET最高速ロガーである&lt;a href="https://github.com/Cysharp/ZLogger/"&gt;ZLogger&lt;/a&gt;でも同じアプローチを取っています。&lt;/p&gt;
&lt;h3&gt;一つのオブジェクトに機能を盛る&lt;/h3&gt;
&lt;p&gt;Channelに詰め込む都合上、データを書き込みメッセージオブジェクトに入れてヒープに保持しておく必要があります。また、書き込み完了まで待つ非同期メソッドのためのPromiseも必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await connection.PublishAsync(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こうしたAPIを効率よく実装するために、どうしても確保する必要のある一つのメッセージオブジェクト（内部的にはCommandと命名されている）に、あらゆる機能を同居して詰め込みましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class AsyncPublishCommand&amp;lt;T&amp;gt; : ICommand, IValueTaskSource, IThreadPoolWorkItem, IObjectPoolNode&amp;lt;AsyncPublishCommand&amp;lt;T&amp;gt;&amp;gt;

internal interface ICommand
{
    void Write(ProtocolWriter writer);
}

internal interface IObjectPoolNode&amp;lt;T&amp;gt;
{
    ref T? NextNode { get; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このオブジェクト(&lt;code&gt;AsyncPublishCommand&amp;lt;T&amp;gt;&lt;/code&gt;)自体は、T dataを保持して、Socketにバイナリデータとして書き込むための役割(&lt;code&gt;ICommand&lt;/code&gt;)をまずは持っています。&lt;/p&gt;
&lt;p&gt;それに加えて&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.sources.ivaluetasksource"&gt;IValueTaskSource&lt;/a&gt;であることにより、このオブジェクト自身がValueTaskになります。&lt;/p&gt;
&lt;p&gt;そしてawait時のコールバックとして、書き込みループを阻害しないためにThreadPoolに流す必要があります。そこで従来の&lt;code&gt;ThreadPool.QueueUserWorkItem(callback)&lt;/code&gt;を使うと、内部的には &lt;code&gt;ThreadPoolWorkItem&lt;/code&gt; を生成してキューに詰め込むため、余計なアロケーションがあります。 .NET Core 3.0から&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.ithreadpoolworkitem"&gt;IThreadPoolWorkItem&lt;/a&gt;を実装することで、内部の&lt;code&gt;ThreadPoolWorkItem&lt;/code&gt;の生成をなくすことができます。&lt;/p&gt;
&lt;p&gt;最後に、同居させることで必要なオブジェクトが1つになりましたが、その1つをプーリングしてゼロアロケーション化します。オブジェクトプールは&lt;code&gt;ConcurrentQueue&amp;lt;T&amp;gt;&lt;/code&gt;などを使うと簡単に実装できますが、自分自身をStackのNodeにすることで、配列を確保しないで済むようにしています。また、Nodeの出し入れに関しては、今回のキャッシュの実装では正確に取り出せる必要性はないため、lockは使わず、マルチスレッドで競合が発生した場合はキャッシュミス扱いにして新規生成するようにしています。これはオブジェクトプーリングにおける性能バランスとしては、良いチョイスだと考えています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal sealed class ObjectPool&amp;lt;T&amp;gt;
    where T : class, IObjectPoolNode&amp;lt;T&amp;gt;
{
    int gate;
    int size;
    T? root;
    readonly int limit;

    public ObjectPool(int limit)
    {
        this.limit = limit;
    }

    public int Size =&amp;gt; size;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPop([NotNullWhen(true)] out T? result)
    {
        // Instead of lock, use CompareExchange gate.
        // In a worst case, missed cached object(create new one) but it's not a big deal.
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            var v = root;
            if (!(v is null))
            {
                ref var nextNode = ref v.NextNode;
                root = nextNode;
                nextNode = null;
                size--;
                result = v;
                Volatile.Write(ref gate, 0);
                return true;
            }

            Volatile.Write(ref gate, 0);
        }
        result = default;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPush(T item)
    {
        if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
        {
            if (size &amp;lt; limit)
            {
                item.NextNode = root;
                root = item;
                size++;
                Volatile.Write(ref gate, 0);
                return true;
            }
            else
            {
                Volatile.Write(ref gate, 0);
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Zero-copy Architecture&lt;/h3&gt;
&lt;p&gt;Publish/Subscribeするデータは通常、C#の型をJSONやMessagePackなどにシリアライズしたものを流します。この場合、どうしてもbyte[]でやり取りすることが多くなります、例えばStackExchange.Redisの&lt;code&gt;RedisValue&lt;/code&gt;の中身は実質byte[]で、送信にせよ受信にせよ、byte[]を生成して保持することになります。&lt;/p&gt;
&lt;p&gt;これを避けるために、ArrayPoolから出し入れしてごまかしてゼロアロケーションにする、みたいなのはありがちではありますが、それでもコピーのコストが発生していることには代わりありません。ゼロアロケーションは当然目指すところですが、ゼロコピーに向けても頑張りましょう！&lt;/p&gt;
&lt;p&gt;AlterNatsのシリアライザーはWriteに&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;, Readに&lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;を要求します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface INatsSerializer
{
    int Serialize&amp;lt;T&amp;gt;(ICountableBufferWriter bufferWriter, T? value);
    T? Deserialize&amp;lt;T&amp;gt;(in ReadOnlySequence&amp;lt;byte&amp;gt; buffer);
}

public interface ICountableBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    int WrittenCount { get; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// 例えばMessagePack for C#を使う場合の実装
public class MessagePackNatsSerializer : INatsSerializer
{
    public int Serialize&amp;lt;T&amp;gt;(ICountableBufferWriter bufferWriter, T? value)
    {
        var before = bufferWriter.WrittenCount;
        MessagePackSerializer.Serialize(bufferWriter, value);
        return bufferWriter.WrittenCount - before;
    }

    public T? Deserialize&amp;lt;T&amp;gt;(in ReadOnlySequence&amp;lt;byte&amp;gt; buffer)
    {
        return MessagePackSerializer.Deserialize&amp;lt;T&amp;gt;(buffer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;System.Text.JsonやMessagePack for C#のSerializeメソッドには&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;を受け取るオーバーロードが用意されています。&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;経由でSocketに書き込むために用意しているバッファーにシリアライザが直接アクセスし、書き込みすることで、Socketとシリアライザ間でのbyte[]のコピーをなくします。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/167587816-c50b0af3-edaa-4a2a-b536-67aed0a5f908.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;Read側では、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.readonlysequence-1"&gt;&lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;&lt;/a&gt;を要求します。Socketからのデータの受信は断片的な場合も多く、それをバッファのコピーと拡大ではなく、連続した複数のバッファを一塊として扱うことでゼロコピーで処理するために用意されたクラスが&lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;「ハイパフォーマンスの I/O をより簡単に行えるように設計されたライブラリ」である&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/standard/io/pipelines"&gt;System.IO.Pipelines&lt;/a&gt;の&lt;code&gt;PipeReader&lt;/code&gt;で読み取ったものを扱うのが、よくあるパターンとなります。ただし、AlterNatsではPipelinesは使わずに独自の読み取り機構と&lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;を使用しました。&lt;/p&gt;
&lt;p&gt;System.Text.JsonやMessagePack for C#のSerializeメソッドには&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;を受け取るオーバーロードが用意されているため、それを直接渡すことができます。つまり、現代的なシリアライザは&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;と&lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;のサポートは必須です。これらをサポートしていないシリアライザはそれだけで失格です。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;プロトコルが単純で少ないのでちゃちゃっと作れると思いきや、まあ確かに雑にTcpClientとStreamReader/Writerでやれば秒殺だったのですが、プロトコルって量産部分でしかないので、そこがどんだけ量少なかろうと、基盤の作り込みは相応に必要で、普通に割と時間かかってしまった、のですが結構良い感じに作れたと思います。コード的にも例によって色々な工夫が盛り込まれていますので、是非ソースコードも読んでみてください。&lt;/p&gt;
&lt;p&gt;クライアント側の実装によってパフォーマンスが大きく違うというのはシリアライザでもよくあり経験したことですが、NATSのパフォーマンスを論じるにあたって、その言語のクライアントは大丈夫ですか？というところがあり、そして、C#は大丈夫ですよ、と言えるものになっていると思います。&lt;/p&gt;
&lt;p&gt;NATSの活用に関してはこれからやっていくので実例あるんですか？とか言われると知らんがな、というところですが（ところでMagicOnionはこないだの&lt;a href="https://neue.cc/2022/04/08_priconne-grandmasters.html"&gt;プリコネ！グランドマスターズ&lt;/a&gt;だけではなく最近特によくあるので、実例めっちゃあります）、これから色々使っていこうかなと思っているので、まぁ是非AlterNatsと共に試してみてください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Wed, 11 May 2022 00:00:00 +0900</pubDate>
      <a10:updated>2022-05-11T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2022/04/08_priconne-grandmasters.html</guid>
      <link>https://neue.cc/2022/04/08_priconne-grandmasters.html</link>
      <title>プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2022/04/08_priconne-grandmasters.html"&gt;プリコネ！グランドマスターズのサーバー開発をCysharpが開発協力しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2022-04-08&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Cygamesから4/1にリリースされた&lt;a href="https://priconne-grandmasters.jp/"&gt;プリコネ！グランドマスターズ&lt;/a&gt;のサーバーサイドとインフラ開発をCysharpが開発協力しました。リアルタイム通信を含むオートバトラー系のゲームです。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/162343388-734840a1-4b7d-467b-902c-1e06e527d208.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/162401207-d9e2bceb-6b94-435c-8e63-d96ce62cf97b.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;Cysharpはサーバー側のアーキテクチャ設計と基盤実装、クラウドインフラ構築、一部サーバーロジック実装を担いました。リアルタイム通信部分だけではなくてAPIサーバーからマッチメイキング、インフラまで、構成されるあらゆる要素がC#で作られています！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;クライアント (Unity)&lt;/li&gt;
&lt;li&gt;API サーバー(MagicOnion)&lt;/li&gt;
&lt;li&gt;バトルエンジンサーバー (リアルタイム通信; MagicOnion, LogicLooper)&lt;/li&gt;
&lt;li&gt;マッチメイキングサーバー (リアルタイム通信; MagicOnion)&lt;/li&gt;
&lt;li&gt;バッチ(ConsoleAppFramework)&lt;/li&gt;
&lt;li&gt;デバッグ機能サーバー (Web; Blazor)&lt;/li&gt;
&lt;li&gt;管理画面サーバー (Web; Blazor)&lt;/li&gt;
&lt;li&gt;インフラ (Infrastructure as Code; &lt;a href="https://www.pulumi.com/"&gt;Pulumi + C#&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サーバー側アプリケーションは.NET 6をKubernetes上で動かしています。Unityクライアント側でも&lt;a href="https://github.com/Cysharp/"&gt;CysharpのOSS&lt;/a&gt;は7つクレジットされていますが、表記のないサーバー側専用のものを合わせたら10個以上使用しています。ここまで徹頭徹尾C#でやっているプロジェクトは世界的にも珍しいんじゃないでしょうか。中心的に活躍しているのは&lt;a href="https://github.com/Cysharp/MagicOnion/"&gt;MagicOnion&lt;/a&gt;ですが、サーバーサイドゲームループのための&lt;a href="https://github.com/Cysharp/LogicLooper"&gt;LogicLooper&lt;/a&gt;、負荷テストのための&lt;a href="https://github.com/Cysharp/DFrame/"&gt;DFrame&lt;/a&gt;なども実戦投入されて、成果を出しました。サーバートラブルも特になく、しっかり安定稼働しました。という事後報告です。そして今日、もとより期間限定公開ということで一週間の配信期間が終了しました。&lt;/p&gt;
&lt;p&gt;アーキテクチャ含めの詳しい話は後日どこかでできるといいですね……！今回、私は実装者としては裏方というか監督というかという感じなので、発表する際は別の人にお任せします……！&lt;/p&gt;
&lt;p&gt;C#でのサーバー構成をまた一つ実証できて、参考になって欲しいのですが（そしてC#採用事例増えて欲しい！）、こういった構成を、Cysharpだから出来る、のではなくて、誰もが実現できる環境にしていきたいとも思っています。重要なパーツは積極的にOSS化していますし、実績も着実に積み重ねられています。が、しかしまだまだ難しい面も数多くあるということは認識しています。かといってmBaaSの方向でやっていくべき、とは思わないんですね。ロジックはゲームの差別化のための重要な要素であり、サーバーサイドでも書くべきで。だから注力しているのは書きやすくするための環境で、そのために足りないものを提供していっています。&lt;/p&gt;
&lt;p&gt;ところでサーバーとクライアントの繋ぎ、あるいはサーバーとサーバーの繋ぎが、MagicOnionだけだと複雑で難しくなってしまうところがあるな、と思っていまして、ちょうど先月-今月はメッセージングライブラリの開発に注力しています。&lt;a href="https://github.com/Cysharp/AlterNats"&gt;AlterNats&lt;/a&gt;という名前でPreview公開していますが、これを挟むと色々改善されるんじゃないかなあ、と思っているので、少々お待ち下さい。そんな感じに、常により最善のC#アーキテクチャの探究と、OSSを通じた共有をまだまだ続けていきます。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 08 Apr 2022 00:00:00 +0900</pubDate>
      <a10:updated>2022-04-08T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2022/02/28_DFrame.html</guid>
      <link>https://neue.cc/2022/02/28_DFrame.html</link>
      <title>DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2022/02/28_DFrame.html"&gt;DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2022-02-28&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;と、いうものをリリースしました。Web UIとなるDFrame.Controllerと、負荷テストシナリオをC#で書くDFrame.Workerの組み合わせで成り立っていて、DFrame.Workerをウェブ上のクラスターに配置することで(Controllerと接続するただの常駐アプリなので、配置先はオンプレでもVMでもコンテナでもKuberenetesでもなんでもいい)、1から数千のワーカーが連動して、大量のリクエストを発生させます。また、テストシナリオをプレーンなC#で記述できるということは、HTTP/1だけではなく、あらゆる種類の通信をカバーできます。WebSocket、HTTP/2、gRPC、MagicOnion、あるいはPhotonや自作のTCPトランスポート、更にはRedisやデータベースなどが対象になります。&lt;/p&gt;
&lt;p&gt;DFrame.Workerは通常の.NETの他に、Unityにも対応しています！つまり、大量のHeadless Unity、あるいはデバイスファームに配置することで、Unityでしか動かないような独自通信フレームワークであっても負荷テストをかけることが可能です。&lt;/p&gt;
&lt;p&gt;また、あまり注目されていませんが負荷テストツールにもパフォーマンスの違いは「かなり」あり、性能の良さは重要で、そこのところにもかなりチューニングしました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/DFrame/"&gt;github - Cysharp/DFrame&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155904375-084a199b-a473-4bc6-8362-009d214bd009.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;Web UI(DFrame.Controller)はBlazor Serverで作られていて、分散ワーカーとの通信はMagicOnionで行っています。自動化のためのWeb APIの口もあるため、Blazor Server, ASP.NET Minimum API, MagicOnionのキメラ同居なアーキテクチャでC#でフル活用なのが設計的にも面白いポイントです。&lt;/p&gt;
&lt;h2&gt;C#で負荷テストシナリオを書く意義&lt;/h2&gt;
&lt;p&gt;負荷テストフレームワークは世の中に山のようにあります。代表的なものでも&lt;a href="https://httpd.apache.org/docs/2.4/programs/ab.html"&gt;ab&lt;/a&gt;, &lt;a href="https://jmeter.apache.org/"&gt;jMeter&lt;/a&gt;, &lt;a href="https://k6.io/"&gt;k6&lt;/a&gt;, &lt;a href="https://www.artillery.io/"&gt;Artillery&lt;/a&gt;, &lt;a href="https://gatling.io/"&gt;Gatling&lt;/a&gt;, &lt;a href="https://github.com/wg/wrk"&gt;wrk&lt;/a&gt;, &lt;a href="https://github.com/codesenberg/bombardier"&gt;bombardier&lt;/a&gt;, &lt;a href="https://locust.io/"&gt;Locust&lt;/a&gt;、k6やArtillery、GatlingなどはSaaSとしても提供していますし、クラウドサービス側も、&lt;a href="https://azure.microsoft.com/ja-jp/services/load-testing/"&gt;Azure Load Testing(Managed jMeter)&lt;/a&gt;のようなマネージドサービスを出していますし、.NETでも&lt;a href="https://github.com/dotnet/crank"&gt;dotnet/crank&lt;/a&gt;というものが存在していたりします。&lt;/p&gt;
&lt;p&gt;DFrameはこの中でいうとアーキテクチャ含めLocustに近い(Controller-Worker構成やWebUIなど)のですが、その特徴の中で重要な点として挙げられているのが、シナリオをコードで書けること、です。よくわからんUIで設定させたり、複雑怪奇なXMLやYAMLやJSON書かせたりせず、プレーンなコードで書ける。これが大事。LocustはPythonですが、他にk6はJavaScriptで書けるようになっています。&lt;/p&gt;
&lt;p&gt;じゃあLocustでいいじゃん、k6でいいじゃん、という話になるのですが、C#で書きたいんですね、シナリオを。これは別にただ単に自分の好きな言語で書きたいからというわけではなくて、サーバーあるいはクライアント言語と負荷試験シナリオ作成言語は同一のものであるべきだからです。例えばUnityのゲームを開発している場合（サーバーサイドの言語は何でもいい）、UnityのゲームはC#で記述されていますが、その場合C#でテストシナリオが書けるのなら&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最初からクライアントSDK(エンドポイントと型付きのRequest/Response)に相当するものがある&lt;/li&gt;
&lt;li&gt;クライアントの実装と完全に等しいのでゲームのドメインロジックが最初からある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となります。それによりテストシナリオの記述の手間を大幅に削減できます。もちろん、Unity依存の部分を引き剥がすなどの追加の作業は必要ですが、完全に書き起こすなどといった無駄は発生しません。もしPythonでもJavaScriptでもLuaでも、とにかく異なる言語である場合は、比較にならないほどに作業量が膨大になってきます。&lt;/p&gt;
&lt;p&gt;そして実際のクライアントコードとある程度共通になることで、サーバー/クライアント側の変化への追随が用意になります。それにより一回のリリースのための負荷テストではなく、継続的な負荷テスト環境を作っていけます。&lt;/p&gt;
&lt;p&gt;また、プレーンなC#で記述できることで、冒頭にも書きましたがあらゆる通信の種類をカバーできるのは、通信プロトコルが多様化している昨今、大きな利点となります。&lt;/p&gt;
&lt;h2&gt;DFrameApp.Run&lt;/h2&gt;
&lt;p&gt;NuGetからDFrameをパッケージ参照したうえで、一行で起動します。テストシナリオ(Workload)の記述の行数もありますが、それでもこれだけで。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using DFrame;

DFrameApp.Run(7312, 7313); // WebUI:7312, WorkerListen:7313

public class SampleWorkload : Workload
{
    public override async Task ExecuteAsync(WorkloadContext context)
    {
        Console.WriteLine($&amp;quot;Hello {context.WorkloadId}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで &lt;code&gt;http://localhost:7312&lt;/code&gt; をブラウザで開けば、&lt;code&gt;SampleWorkload&lt;/code&gt;がいます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155892546-c00f1554-0e2c-4e11-acdd-f0d9be9c40c9.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;と、いうわけで、WorkloadのExecuteAsyncにコードを書くのが基本です。ExecuteAsync前の準備用としてSetupAsync、後始末としてTeardownAsyncもあります。単純なgRPCのテストを書くとこなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class GrpcTest : Workload
{
    GrpcChannel? channel;
    Greeter.GreeterClient? client;

    public override async Task SetupAsync(WorkloadContext context)
    {
        channel = GrpcChannel.ForAddress(&amp;quot;http://localhost:5027&amp;quot;);
        client = new Greeter.GreeterClient(channel);
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await client!.SayHelloAsync(new HelloRequest(), cancellationToken: context.CancellationToken);
    }

    public override async Task TeardownAsync(WorkloadContext context)
    {
        if (channel != null)
        {
            await channel.ShutdownAsync();
            channel.Dispose();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Concurrencyの数だけWorkloadが生成されて、Total Request / Workers / Concurrencyの数だけExecuteAsyncが実行されます。コードで書くと言っても別にそう複雑なこともなく、よくわからんDSLで書くわけでもないので、むしろ(C#が書けるなら)とても書きやすいでしょう。中身も見てのとおり単純なので、gRPCでもMagicOnionでも何でも実行できます。&lt;/p&gt;
&lt;p&gt;引数を受け取ることも可能なので、任意のURLを渡すようなものも作れます。コンストラクタでは、パラメーター、あるいはDIでインジェクトしたインスタンスを受け取れます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using DFrame;
using Microsoft.Extensions.DependencyInjection;

// use builder can configure services, logging, configuration, etc.
var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureServices(services =&amp;gt;
{
    services.AddSingleton&amp;lt;HttpClient&amp;gt;();
});
await builder.RunAsync();

public class HttpGetString : Workload
{
    readonly HttpClient httpClient;
    readonly string url;

    // HttpClient is from DI, URL is passed from Web UI
    public HttpGetString(HttpClient httpClient, string url)
    {
        this.httpClient = httpClient;
        this.url = url;
    }

    public override async Task ExecuteAsync(WorkloadContext context)
    {
        await httpClient.GetStringAsync(url, context.CancellationToken);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155893829-fc9f5e9d-fb05-4bcc-b8ee-6067be674b51.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;WebUI画面にString urlの入力箇所が現れて、好きなURLを叩き込むことができるようになりました。&lt;/p&gt;
&lt;p&gt;なお、単純なHTTPのGET/POST/PUT/DELETEをテストしたいという場合は、IncludesDefaultHttpWorkloadを有効にしてもらうと、内蔵のパラメーターを受け取るWorkloadが追加されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using DFrame;

var builder = DFrameApp.CreateBuilder(7312, 7313);
builder.ConfigureWorker(x =&amp;gt;
{
    x.IncludesDefaultHttpWorkload = true;
});
builder.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;分散テスト&lt;/h2&gt;
&lt;p&gt;Workerは起動時に指定したControllerのアドレスにHTTP/2(MagicOnion/gRPC)で繋ぎに行って、常駐します。という普通の（？）アプリケーションなので、ウェブサーバーを分散させるのと同様に複数のWorkerを立ち上げてもらえれば、自動的に繋がります。&lt;/p&gt;
&lt;p&gt;構成としては、以下の画像のようにControllerとWorkerのプロジェクトを分けるのが正当派（？）ですが&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/154921606-b9955331-1d15-4c4f-a769-faeb61b13872.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;同居させてしまって、起動時のコマンドライン引数でどちらかのモード（あるいは両方）が起動するようにすることも、ローカルでの開発がしやすくなるのでお薦めです。 &lt;code&gt;DFrameApp.CreateBuilder&lt;/code&gt; にはそのための補助的な機構が用意されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using DFrame;

var builder = DFrameApp.CreateBuilder(5555, 5556); // portWeb, portListenWorker

if (args.Length == 0)
{
    // local, run both(host WebUI on http://localhost:portWeb)
    await builder.RunAsync();
}
else if (args[0] == &amp;quot;controller&amp;quot;)
{
    // listen http://*:portWeb as WebUI and http://*:portListenWorker as Worker listen gRPC
    await builder.RunControllerAsync();
}
else if (args[0] == &amp;quot;worker&amp;quot;)
{
    // worker connect to (controller) address.
    // You can also configure from appsettings.json via builder.ConfigureWorker((ctx, options) =&amp;gt; { options.ControllerAddress = &amp;quot;&amp;quot; });
    await builder.RunWorkerAsync(&amp;quot;http://foobar:5556&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ローカルでWorkerの.exeを複数実行する、とかでも手元でとりあえずのWorker connectionsが増える様は確認できます。&lt;/p&gt;
&lt;p&gt;Workerを増やすと表がにぎやかになって楽しい。実行するWorkerの数はスライダーで調整できるので、各種パラメーターを台数1で調整したあとに、徐々に実行Workerを増やしていく、といった使い方も可能です。また、その辺を自動でやってくれるRepeatモード(TotalRequestとWorkerを完了後に指定数増やして繰り返す)も用意しました。jMeterでいうところのRamp-Upの代わりに使えればいいかな、という想定でもあります。&lt;/p&gt;
&lt;p&gt;アーキテクチャ的に最初から分散前提で作られているというのもあり、増やしても性能が劣化しない、リニアに性能が向上していくように作りました。Controllerは単一なのでスケールしないのですが、なるべく多くのWorkerをぶら下げられるように工夫しています。Controller &amp;lt;-&amp;gt; WorkerはMagicOnionで通信しているので、DFrame自身がMagicOnionの負荷テストになっているのです。&lt;/p&gt;
&lt;h2&gt;パフォーマンス&lt;/h2&gt;
&lt;p&gt;多数ある負荷テストフレームワークですが、パフォーマンスはそれぞれかなり異なります。詳しくはk6のブログ&lt;a href="https://k6.io/blog/comparing-best-open-source-load-testing-tools/"&gt;Open source load testing tool review 2020&lt;/a&gt;に非常に詳細に書かれていますが、例えばとにかくwrkがぶっちぎって他の数十倍~数百倍速かったりする、と。パフォーマンスは当然ながらとても重要で、ワーガーの非力さでターゲットに負荷をかけきれなかったりします。それに対応するためクラスターを組んでいくにしても、多くの台数やより高いスペックのマシンが必要になって、色々と辛い。&lt;/p&gt;
&lt;p&gt;というわけでパフォーマンスは高ければ高いほうがいいのですが、先のブログに書かれている通り、拡張性の口やレポート取り出しの口などは必要です。その点でWrkは機能を満たさないということで、ブログではなんか結果から取り除かれてますね（その対応がいいのかどうかはなんとも言えませんが、まぁk6自身のアピールのためでもあるのでしょうがないね）。ちなみにフレームワークのパフォーマンスの指標として使われている&lt;a href="https://www.techempower.com/benchmarks/"&gt;TechEmpower Web Framework Benchmarks&lt;/a&gt;の負荷クライアントはwrkのようです。&lt;/p&gt;
&lt;p&gt;さて、で、DFrameはどうかというと、かなり良好です。というのも、DFrameはライブラリとして提供されて、実行時は全てがC#の実行ファイルとしてコンパイル済みの状態になるのですね。スクリプトを動的に読んで実行するから遅くなってしまう、みたいなことがない。比較的高速な言語であるC#をそのまま利用するので、その時点である程度はいける。理論上。理屈上。&lt;/p&gt;
&lt;p&gt;と、いう甘い見込みのもと実際作っていくと、さすがにそこまでさっくりとはいかず、相応にチューニングが必要だったのですが、最終的にはかなりの数字が出るようになりました。比較としてabとk6で測ってみると&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155854372-6cd3976c-fb08-4ddb-b4a8-75235421cfc8.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155854390-a2360f29-956f-4ace-a848-ecc03c79cb21.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155854413-969e59c2-a914-4131-b3d7-f1f50591413b.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;本来はターゲットとワーカーは別マシンにしないといけないのですが(ワーカーの負荷でCPUが跳ね上がる影響をサーバー側がモロに影響受けてしまうので)、それでもそれなりに数字は変動しますし動きはするしマシンパワーも結構強め(Ryzen 9 5950x)なので、ちょっと手抜きでlocalhost上の無を返すHTTP/1サーバーをターゲットに、32並列(-c 32, -32VUs, Concurrency=32)で実行。&lt;/p&gt;
&lt;p&gt;abが、6287 req/sec、k6が125619 req/sec、DFrameが207634 req/secです。abは、厳しい、厳しい……。もっと出るはずと思っているんですが、私の環境(Windows)だと昔からこんな感じなので、性能的には信用できないかなぁ。Windowsだとダメだったりするのかもしないのかもしれませんね。DFrameの場合Concurrencyにまだ余裕があって、増やすとまだまだ伸びたのですが、k6は割と頭打ちでした。&lt;/p&gt;
&lt;p&gt;また、画像は出してませんがLocustは残念ながらかなり遅い上にCPUを食いまくるという感じで(Pythonだしね……）、いくらクラスタ化が容易とはいえ、ここまで1ワーカーあたりの性能が低いと、ないかなあ、という感想です。JMeterはそこまで悪くはないですが、パフォーマンスに影響を与える地雷コンフィグを必死にかいくぐってなおそこそこ程度なのはしんどみ。&lt;/p&gt;
&lt;p&gt;ちなみになんで圧倒的性能番長であるwrkと比較しないのかというと、Windowsで動かすのが大変だからです。すみません……。&lt;/p&gt;
&lt;h2&gt;自動化のためのREST API&lt;/h2&gt;
&lt;p&gt;最初はいいけど、毎回GUIでポチポチやるの面倒で、それはそれで嫌だよね。CIで定期的に回したりもできないし。というわけで、バッチ起動モード、はついていないのですが、代わりにREST APIが自動で有効になっています。例えば &lt;code&gt;/api/connections&lt;/code&gt; で現在接続中のワーカーコネクション数が取れます。実行パラメーターなどはPostでJSONを投げる形になっています。&lt;/p&gt;
&lt;p&gt;REST APIでJSONをやり取りするだけなので、どの言語から叩くことも可能ですが、C#の場合は &lt;code&gt;DFrame.RestSdk&lt;/code&gt; パッケージにて型付けされたクライアントが用意されているので、手間なくはじめられます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using DFrame.RestSdk;

var client = new DFrameClient(&amp;quot;http://localhost:7312/&amp;quot;);

// start request
await client.ExecuteRequestAsync(new()
{
    Workload = &amp;quot;SampleWorkload&amp;quot;,
    Concurrency = 10,
    TotalRequest = 100000
});

// loadtest is running, wait complete.
await client.WaitUntilCanExecute();

// get summary and results[]
var result = await client.GetLatestResultAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行状況は全て連動しているので、REST APIから実行した進捗もWeb UI側でリアルタイムに状況確認できます。&lt;/p&gt;
&lt;h2&gt;Unityでも動く&lt;/h2&gt;
&lt;p&gt;Unityで動かしやすいかといったら全然そんなことないので、動かせるようにするのはもはや執念という感じではあるのですが、Unity対応しました。冒頭で書いたようにヘッドレスUnityを並べてコントロールする、みたいな用途は考えられます。まぁ、あと普通の負荷テストでも、通信部分のC#を普通の .NET に切り出すのが面倒だという場合に、ヘッドレスUnityでとりあえずビルドすることで何もしなくてもOK（そうか？）という策もあります。&lt;/p&gt;
&lt;p&gt;Unityで動かす場合は、依存の解決(MagicOnion、gRPC、MessagePack for C#)が大変です！まぁ、それは置いておいて。それが出来ているなら、以下のようなMonoBehaviourに寿命をくっつけたインスタンスで起動させると良い感じです（MagicOnionというかネイティブgRPCは適切にコネクションをCloseしないとUnity Editorがフリーズするという酷い問題があるのですが、このコードは問題なくちゃんとクリーンアップしてくれるようになっています）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DFrameWorker : MonoBehaviour
{
    DFrameWorkerApp app;

    [RuntimeInitializeOnLoadMethod]
    static void Init()
    {
        new GameObject(&amp;quot;DFrame Worker&amp;quot;, typeof(SampleOne));
    }

    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }

    async void Start()
    {
        // setup your controller address
        app = new DFrameWorkerApp(&amp;quot;localhost:7313&amp;quot;);
        await app.RunAsync();
    }

    private void OnDestroy()
    {
        app.Dispose();
    }
}

[Preserve]
public class SampleWorkload : Workload
{
    public override Task ExecuteAsync(WorkloadContext context)
    {
        Debug.Log(&amp;quot;Exec&amp;quot;);
        return Task.CompletedTask;
    }

    public override Task TeardownAsync(WorkloadContext context)
    {
        Debug.Log(&amp;quot;Teardown&amp;quot;);
        return Task.CompletedTask;
    }
}

// Preserve for Unity IL2CPP

internal class PreserveAttribute : System.Attribute
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Editor上の確認だとこんな具合です。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/155901725-4ce8a36f-46e9-4437-aba7-639425f4b93f.png" alt="image" /&gt;&lt;/p&gt;
&lt;h2&gt;ライブラリかツールか&lt;/h2&gt;
&lt;p&gt;DFrame.Controller、他の設定を入れなければただのウェブアプリなので、ビルド済みのexeとしての提供も可能です。Locustなど他のツールも入れたら、とりあえず実行できる、のに比べると、必ず自分で組み込んでビルドしなきゃいけない。のは欠点に見える。&lt;/p&gt;
&lt;p&gt;なのでビルド済みコンテナをDocker Hubかなんかで提供するという案もあったのですが、Workerはどうしても自分で組み込んでビルドする必要があるので、そこだけ省けても利点あるのかな？と考えて、最終的に却下しました。かわりに &lt;code&gt;DFrameApp.Run&lt;/code&gt; の一行だけでController+Workerの同居が起動できるようにして、最初の一歩の面倒臭さをライブラリデザインの工夫で乗り切ることにしました。Controller自体も、&lt;code&gt;Microsoft.NET.Sdk.Web&lt;/code&gt;ではなく、コンソールアプリケーションのテンプレートの&lt;code&gt;Microsoft.NET.Sdk&lt;/code&gt;から起動できるようにしました。&lt;/p&gt;
&lt;p&gt;DFrame.Controllerがライブラリとして提供されていることのメリットは、コンフィグが通常のコードやASP.NETの仕組みに乗っかったほうが圧倒的にシンプルになります。DIで好きなロガーを設定して、URLの指定やSSLなどもappsettings.jsonで行うのは、大量の複雑怪奇なコマンドラインオプションよりもずっと良いでしょう。&lt;/p&gt;
&lt;p&gt;ログの永続化処理も、プラグイン的に用意するのではなく、普通にDIでインジェクトしてもらう(&lt;code&gt;IExecutionResultHistoryProvider&lt;/code&gt;というものが用意されていて、これを実装したものをDIに登録してもらえば、結果をデータベースに入れたり時系列DBに入れたりして統計的な参照ができるようになります)ほうが、使いやすいはずです。&lt;/p&gt;
&lt;h2&gt;Blazor Server + MagicOnion&lt;/h2&gt;
&lt;p&gt;DFrame.ControllerはBlazor ServerとMagicOnion(grpc-dotnet)が同居した構成になっています。これは中々面白い構成で、Web UIとMagicOnion(Server側)が同じメモリを共有しているので、末端のMagicOnion(Client側)の変更をダイレクトにC#だけを通してブラウザにまで届けているんですね。逆もしかりで、APIからのアクセス含めて、全てがリアルタイムに伝搬して画面も同期しているのですが、普通にやるとかなり複雑怪奇になるはずが、かなりシンプルに実装できています。&lt;/p&gt;
&lt;p&gt;と、いうわけで、Cysharpではこの組み合わせに可能性を感じていて、別のサービスも同種のアーキテクチャで絶賛制作中なので興味ありましたら以下略。&lt;/p&gt;
&lt;h2&gt;紆余曲折&lt;/h2&gt;
&lt;p&gt;最初のバージョンは2年ぐらい前に作っていました。コンセプトは「自己分裂する分散バッチフレームワーク」ということで、自分自身のコピーを動的に作って無限大に分散して実行していくというもので。分散のための基盤としてKubernetesを使って。クラウドネイティブ！かっこいい！そして、一応動くものはできていました。あとは仕上げていくだけ、といったところで、放置していました。完成させなきゃ、と思いつつ、内心薄々あんまいい感じではないな、と思っていたため手が進まず無限放置モードへ。そして時が流れ、社内でもがっつり使うことになり引っ張り出されてきたそれは、やはりあまりいい感じではなく。で、最終的に言われたんですね、そもそも分裂機能いらなくね？と。&lt;/p&gt;
&lt;p&gt;それでようやく気づくわけです、コンセプトから完全に間違っているからうまくいくわけがない！&lt;/p&gt;
&lt;p&gt;反省として良くなかった理由としては、まず、現代のクラウドコンピューターを過大に評価していた。「自己分裂する」のは、一瞬で無限大にスケールして即起動、そして終わったら即終了、ならば、まぁそれでいいんですが、現実のスケールする時間はそんなに立派じゃない。サーバーレスといいつつ、別に1リクエスト毎にコンテナが起動して処理するわけはなく、常駐してリクエストを待つ。そりゃそうだ、と。自己分裂のコンセプトだと、分裂コストが重たいのは否めない。&lt;/p&gt;
&lt;p&gt;もう一つは分裂するためのコードがDFrame内に記述されている。Kuberentesをコントロールするコードがたっぷり入ってしまって。そのせいでコードサイズが膨らんでしまったし、使う方も複雑なコンフィグをDFrame側に埋めなきゃいけなくなってしまった。これは二重にイケてない。作るのも複雑で、使うのも複雑ですからね、いいところがない……。&lt;/p&gt;
&lt;p&gt;と、いうわけで、最初のかっこいいコンセプトを否定して、自己分裂しない。単純に繋ぎに行くだけ。としたことで、頭を抱えてうまくいかないと感じていた行き詰まりは解消したのでした。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;もう少し早くに作って提供したかった、という後悔がめっちゃあるのですが、同時に .NET 6だから出来たという要素もめっちゃあるので(パラメーター渡しの仕組みなどは&lt;a href="https://neue.cc/2021/12/30.html"&gt;ConsoleAppFramework v4&lt;/a&gt;の設計の経験からスムーズに実装できた)、しょーがない。という気もする。Blazor Serverなどの進化も必要だったし。&lt;/p&gt;
&lt;p&gt;しかし↑で書いたとおり最初に立てたコンセプトが間違っていて、長いこと軌道修正できず放置してしまっていたというのは個人的には割と手痛い経験です……。まぁ、間違ったコンセプトのまま進行してしまうというのは別によくあるので、それはしょーがないものとして別にいいんですが、自力で気づいてパーッと作り上げられてたらなあ、みたいな、みたいな。。。&lt;/p&gt;
&lt;p&gt;ともあれ、完成したものとしてはかなり良い感じで（私の出すものとしては珍しくUIもちゃんとついているし！←UI作業は他の人に助力を請うてます）、ちょっとニッチ感もありますがC#アプリケーション開発の必需品として成り得る出来だと思っていますので、ぜひぜひお試しください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0900</pubDate>
      <a10:updated>2022-02-28T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2022/01/09_WebSerializer.html</guid>
      <link>https://neue.cc/2022/01/09_WebSerializer.html</link>
      <title>WebSerializer - オブジェクトからクエリストリングに変換するHttpClientリクエスト用シリアライザ</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2022/01/09_WebSerializer.html"&gt;WebSerializer - オブジェクトからクエリストリングに変換するHttpClientリクエスト用シリアライザ&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2022-01-09&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;code&gt;T value&lt;/code&gt;から URLエンコードされたクエリストリング、または&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;なHttpContentを生成する、つまりはウェブ(HTTP/1)リクエスト用のシリアライザを作りました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/WebSerializer/"&gt;github.com/Cysharp/WebSerializer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クエリストリングの生成、意外と面倒くさいな！と。(C#用の)専用のSDKが存在しないWeb APIの場合は、自分でURL組み立てたり&lt;code&gt;FormUrlEncodedContent&lt;/code&gt;を組み立てたりしますが、数が多いとまぁ面倒くさい。リクエストのパラメーター数が多いと、null抜いたりも面倒くさい。&lt;/p&gt;
&lt;p&gt;レスポンス側は&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.http.json.httpcontentjsonextensions.readfromjsonasync?view=net-6.0"&gt;ReadFromJsonAsync&lt;/a&gt;などでダイレクトに変換できるようになって特に問題はないのですが、リクエスト側は、かなりの手作業が要求されます。そのへんを全部やってくれる&lt;a href="https://github.com/reactiveui/refit"&gt;refit&lt;/a&gt;というライブラリもありますが(Androidの&lt;a href="https://github.com/square/retrofit"&gt;retrofit&lt;/a&gt;にインスパイアされたもの)、導入するにはちょっと大仰だな、と思うときも多々あります、というか私は今まで一度も使ってません。&lt;/p&gt;
&lt;p&gt;HttpClient用にURLを組み立てるのを簡略化してくれるぐらいでいいな、と思って考えていたら、そういえばそもそもそれってT valueから何かに変換する、つまりシリアライザじゃん、ということに気づきました。T -&amp;gt; msgpack byte[]に変換すればMessagePackシリアライザだし、T -&amp;gt; Json stringに変換すればJSONシリアライザだし、これはT -&amp;gt; UrlEncoded stringに変換するということなのだと。シリアライザ脳なので、そう理解すれば話が早い。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Cysharp.Web;

var req = new Request(sortBy: &amp;quot;id&amp;quot;, direction: SortDirection.Desc, currentPage: 3)

// sortBy=id&amp;amp;direction=Desc&amp;amp;currentPage=3
var q = WebSerializer.ToQueryString(req);

await httpClient.GetAsync(&amp;quot;/sort?&amp;quot;+ q);

// data...
public record Request(string? sortBy, SortDirection direction, int currentPage);

public enum SortDirection
{
    Default,
    Asc,
    Desc
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本的に使うメソッドは &lt;code&gt;WebSerializer.ToQueryString&lt;/code&gt; か &lt;code&gt;WebSerializer.ToHttpContent&lt;/code&gt; だけです。URLエンコードされてname=valueで&amp;amp;連結された文字列が取り出せます。メソッドとして叩いたりする場合は、そのまま匿名型で渡してあげればちょうど良い。urlも一緒に渡してあげれば全て同時に組み立ててくれます。値が&lt;code&gt;null&lt;/code&gt;のものは文字列化対象から自動で外されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;const string UrlBase = &amp;quot;https://foo.com/search&amp;quot;;

// null, SortDirection.Asc, 0
async Task SearchAsync(string? sortBy, SortDirection direction, int currentPage)
{
    // &amp;quot;https://foo.com/search?direction=Asc&amp;amp;currentPage=0&amp;quot;
    var url = WebSerializer.ToQueryString(UrlBase, new { sortBy, direction, currentPage });
    await httpClient.GetAsync(url);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;動的に組み立てる場合は、&lt;code&gt;Dictionary&amp;lt;string, object&amp;gt;&lt;/code&gt; も渡せます。(&lt;code&gt;FormUrlEncodedContent&lt;/code&gt;は&lt;code&gt;Dictionary&amp;lt;string, string&amp;gt;&lt;/code&gt;で、Value側のToString()が必須なのが地味に面倒くさいので、&lt;code&gt;object&lt;/code&gt;で良いというのは何気に楽だったりします)。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var req = new Dictionary&amp;lt;string, object&amp;gt;
{
    { &amp;quot;sortBy&amp;quot;, &amp;quot;id&amp;quot; },
    { &amp;quot;direction&amp;quot;, SortDirection.Desc },
    { &amp;quot;currentPage&amp;quot;, 10 }
};
var q = WebSerializer.ToQueryString(req);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;POST用には、&lt;code&gt;ToHttpContent&lt;/code&gt;を使います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task PostMessage(string name, string email, string message)
{
    var content = WebSerializer.ToHttpContent(new { name, email, message });
    await httpClient.PostAsync(&amp;quot;/postmsg&amp;quot;, content);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部的には&lt;code&gt;FormUrlEncodedContent&lt;/code&gt;は使わずに、専用のHttpContentを通しているため、&lt;code&gt;byte[]&lt;/code&gt;変換のオーバーヘッドがありません。&lt;/p&gt;
&lt;h2&gt;シリアライザ設計&lt;/h2&gt;
&lt;p&gt;ただたんにクエリストリング組み立てるだけっしょ！というと軽く見られてしまうかもしれないのですが、中身はかなりガチめに作ってあって、構成としては&lt;a href="https://github.com/neuecc/MessagePack-CSharp/"&gt;MessagePack for C#&lt;/a&gt;と同様です。パフォーマンスに関しても超ギチギチに詰めているわけではないですが、かなり気を配って作られているので、手で組み立てるよりもむしろ高速になるケースも多いはずです。拡張性もかなり高く作れているはずです。&lt;/p&gt;
&lt;p&gt;シリアライザのデザインに関してはMessagePack for C#の次期バージョン(v3)をどうしていこうかなあ、と考えているタイミングでもあるので、そのプロトタイプ的な意識もありますね。なので設計としてはむしろ最新型で、かなり洗練されています。.NET 5/6のみにしているので、レガシーも徹底的に切り捨てていますし。最初は .NET 6のみだったのですが、さすがにそれはやりすぎかと思い .NET 5は足しました。（が、2022-01-21のv1.3.0にて、.NET Standard 2.0/2.1対応もしました）&lt;/p&gt;
&lt;p&gt;例えばコンフィグ(&lt;code&gt;WebSerializerOptions&lt;/code&gt;)はイミュータブルなのですが、これ自体はrecordで作ってあってwith式でカスタムのコンフィグを作れます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// CultureInfo: 数値型やDateTimeの文字列化変換に渡すCultureInfo、デフォルトはnull
// CollectionSeparator: 配列などを変換する場合のセパレーター、デフォルトはnullでname=value&amp;amp;name=value...
// Provider: 対象の型をどのように変換するか(`IWebSerialzier&amp;lt;T&amp;gt;`)の変更
var newConfig = WebSerializerOptions.Default with
{
    CultureInfo = CultureInfo.InvariantCulture,
    CollectionSeparator = &amp;quot;,&amp;quot;,
    Provider = WebSerializerProvider.Create(
        new[] { new BoolZeroOneSerializer() },
        new[] { WebSerializerProvider.Default })
};

// Bool値を0, 1に変換する（こういうの求めてくるWeb APIあるんですよねー！）
public class BoolZeroOneSerializer : IWebSerializer&amp;lt;bool&amp;gt;
{
    public void Serialize(ref WebSerializerWriter writer, bool value, WebSerializerOptions options)
    {
        // true =&amp;gt; 0, false =&amp;gt; 1
        writer.AppendPrimitive(value ? 0 : 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IWebSerializer&amp;lt;T&amp;gt;&lt;/code&gt;のインターフェイスについて、&lt;code&gt;ref T value&lt;/code&gt;にしようか検討したのですが、最終的にやめました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IWebSerializer&amp;lt;T&amp;gt; : IWebSerializer
{
    void Serialize(ref WebSerializerWriter writer, T value, WebSerializerOptions options);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ref T value&lt;/code&gt;にすると、プロパティをそのまま渡せなくて、かなり面倒くさくなってね。理屈的にはlarge structに対するコピーコスト削減、ではあるけれど、まぁこのままだと99%効力ないかなあ、という感じがあり。入り口だけinにして一回分コピーを消すぐらいを落とし所にしました、とりあえず今回は。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static string ToQueryString&amp;lt;T&amp;gt;(in T value, WebSerializerOptions? options = default)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;それとSource Generator対応についても考えましたが、まぁ一旦今回は見送って、後でやるかもという感じでしょうか。アイディアは色々ありますが、まずは作ってみないとうまくハマるか見えないところがあるし、MessagePack for C#のような大きなものでドカンとやるよりは、最初は小さなものでテストしていくのが良いものを作る正攻法でもありますね。&lt;/p&gt;
&lt;h2&gt;Deserializeがない問題&lt;/h2&gt;
&lt;p&gt;ASP.NET CoreのAddControllerなら、Model Bindingでデシリアライズできるので、不要でしょう。.NET 6時点でのMinimal APIだとなんと自動モデルバインディングがなくて手動でQueryStringから組み立てるという手間が必要になってて、まぁそこでは必要かなあ？と思ったんですが、いや、それしたいならMinimal APIではなくてAddControllerしろや、と思ったので、機能入れるのやめました。実際、そのうちバインディング自体はいれるそうです（さすがに不便なので）。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;手で組み立てている人は結構多いと思うので、使えるシチュエーションはかなりあると思ってます。ただまあ、こんぐらいなら手でやるよ！と思う人は多いと思うので、その点ではニッチかなあ、というところですね。Web APIの仕様によってはリクエストパラメーターが微妙にデカくてイライラすることがあったり、まぁあとは数を作るときにはやっぱダルいので、ハマるシチュエーションも少なくはないかな、と。&lt;/p&gt;
&lt;p&gt;とりあえずは試してみてもらえればと思います。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0900</pubDate>
      <a10:updated>2022-01-09T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/12/31.html</guid>
      <link>https://neue.cc/2021/12/31.html</link>
      <title>2021年を振り返る</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/12/31.html"&gt;2021年を振り返る&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-12-31&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;例年、30日に投稿しているはずなのですが、今年は、どうしても今年中に作りきりたいという思いで&lt;a href="https://neue.cc/2021/12/30.html"&gt;ConsoleAppFramework v4&lt;/a&gt;のリリースをしてしまったので31日で。今年の後半から道具をガラーッと変えて、それがいい感じに作用していったので、なんか満足した気でいます。&lt;/p&gt;
&lt;h2&gt;Heyをとにかく薦めたい&lt;/h2&gt;
&lt;p&gt;今年良かったもの第一位は&lt;a href="https://hey.com/"&gt;Hey&lt;/a&gt;です。Ruby on Rails作者のDHHがやってる会社(Basecamp)のメールサービスなのですが、これが抜群によく出来てる！今までメール一ヶ月放置は当たり前、未読1万件、みたいな状態だったのですが、After Heyでは未読0。すごい。メーラー変えただけでこんな変わるとは。よく出来たツールは人を変えるね。&lt;/p&gt;
&lt;p&gt;どうしてもたまりがちな、スパムではないけど自分にとってはスパムに等しいもの（なんだかんだで送られてくる広告メールとかね）を、実質スパム扱いして、一生このメールは見ないという設定をワンポチでできるのが小気味よい。ワンポチどころか、最初のメール受信時に強制的に決めさせることで（決めないとメールが受信ボックスに入らないので、決めるしかない）、最初に使うときの罪悪感というか、とはいえ見るかもしれないしー、役に立つときもあるかもしれないしー、みたいななんとなくある抵抗感みたいなのを、その手で実行させ続けることにより薄れさせていく手腕は見事というほかない。&lt;/p&gt;
&lt;p&gt;メールを3分類、読むものとフィード的に見るもの（メルマガとかGitHubのWatchとか）と、領収書系で分けたというのもセンスを感じる。領収書は、例えばKindleで購入するたびに買いましたメールは、捨てるのもアレだけど別に自明すぎて見たくはない、ものが溜まっていくとメールボックスがウザいことになる、を専用の置き場を用意しました、で解決しているのはなるほどなー、と。フィード的なのは全部連結されているので、スクロールさせてバッと流し見で終わらせられるのも良い。&lt;/p&gt;
&lt;p&gt;細かいフィルターはできないけど、そもそも細かいフィルターなんて作るの面倒だしメンテ不能になるだけだから作るんじゃねえ、俺達の考えた最高のRailに乗ってりゃあいいんだよ、という押し付けがましさ全開の思想性溢れるのが、いいですね。そういうの、嫌いじゃないです。DHHの語るプログラミング的な思想も好きですしね、私は。Rubyは使いませんが、DHHの思想には納得できるものがめちゃくちゃ多くて割と好きなので。&lt;/p&gt;
&lt;p&gt;メールアドレスという、なんだかんだで変えられない、変えにくいものなのに、 &lt;code&gt;hey.com&lt;/code&gt; を使え！というのは中々ハードル高いのですが(基本的に汎用メーラーとしては使えず、専用メールアドレスが必要。GMailのクライアントにもPOP3クライアントにもならない)、今回私は10年以上使ってきたプロバイダのメールアドレスが不慮の事故により完全消滅したので、思い切って乗り換えることができました。結果、良かった。怪我の功名ということで。&lt;/p&gt;
&lt;h2&gt;iPad miniがとにかく良い&lt;/h2&gt;
&lt;p&gt;タブレットは、というかiPadはなんだかんだで今まで色々なサイズのものを買ってきました。普通のもAirもPro 13インチも。そしてほとんど全く使わなかったのですが……！なんか面倒くさくてねー、重いしー、と。で、iPhoneがPro Maxで大きいから、そこまでサイズ変わらないしねえと思ってminiだけは手を出さなかったのですが、世間でiPad mini 6があまりにも評判がいいので、じゃあまぁ試してみるかと買ったら、なるほど納得！これは超いい！最高……！&lt;/p&gt;
&lt;p&gt;やっぱ重さとサイズ感ですかね。これなら手軽に持ち運べる（今の時期コートとかだったらポケットにすら入る）し、片手で持てるというのが読みやすさにもめっちゃ寄与してる。デカいと手も疲れるし、ちゃっと手にとってソファで読もうとかいう気になれなかったわけですが、このサイズ感は絶妙、でした。大きさ的にも全然iPhone Pro Maxよりは明らかに大きくて、雑誌も十分読めるレベルで、漫画は快適。&lt;/p&gt;
&lt;p&gt;iPad miniのサイズのままで高級路線（有機EL積んでもらうとか）して欲しいですね。&lt;/p&gt;
&lt;p&gt;で、とても気に入ったので、いい感じのスタンドないかなあと思って選んだのが&lt;a href="https://www.moftjapan.com/products/moft-x-tablet-stand"&gt;MOFT X&lt;/a&gt;。ちょうどiPad mini 6用のサイズのものが出たのでこれがまた快適。どこでもいつでもさっくりスタンドになるのがこんなに良いとは。厚すぎない/重すぎないので、背中に常時貼り付けている状態でも苦にならないし。なんだったらカメラの出っ張り（うざい！）が相殺されて、平らなところにおいてもガタつかなくなったのが最高。&lt;/p&gt;
&lt;h2&gt;5K2Kは捗る&lt;/h2&gt;
&lt;p&gt;家の作業環境に割と不満があって、特にモニタ環境が良くなかった（32インチ4K + WQXGAの組合わせ、別に悪くはないんですけどね）ので、5K2K(5120x2160)モニタに変更。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/147818725-e1529666-172f-40fe-aa69-0491a27091d9.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;現状だとこの解像度は&lt;a href="https://www.dell.com/ja-jp/shop/dell-u4021qw-40%E3%82%A4%E3%83%B3%E3%83%81%E3%83%AF%E3%82%A4%E3%83%89%E6%9B%B2%E9%9D%A2usb-c-hub-%E3%83%A2%E3%83%8B%E3%82%BF-5k2k-21-9-ips%E9%9D%9E%E5%85%89%E6%B2%A2-tbhdmix2dprj45-%E9%AB%98%E3%81%95%E8%AA%BF%E6%95%B4/apd/210-aypy/%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC-%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B5%E3%83%AA%E3%83%BC"&gt;Dell U4021QW&lt;/a&gt;一択。40インチは大きいかなーと思ったんですが、横に長いから高さ的には今まで使ってた32インチとそう変わらず、ですかね。デカいっちゃあデカですが、こんなもんかな、という感じでもある。この机も横1200の机でそんあ大きい机じゃないんですが、ジャストサイズぐらいで収まりますし。&lt;/p&gt;
&lt;p&gt;人によっては100%サイズで使うのは小さい、と思ってしまいそうなところですが、私的には人体改造済み(&lt;a href="https://www.sannoclc.or.jp/hospital/icl/"&gt;ICL&lt;/a&gt;というレンズを眼球に埋める手術をしたので)なので問題なし、ということで100%サイズで使っています。&lt;/p&gt;
&lt;p&gt;このサイズ、いい感じに視野に全部収まるので、デュアルやトリプルよりも快適さあります。今まで、最大で5画面ぐらいまでモニタ増やしてきたのですが、結局メイン以外のものは首をふるのもダルくてそんなに使える感じではないし、音楽プレイヤーのプレイリストを並べるとかだったら、置いてるiPadで聞いて表示しとけばいいじゃん、ということで、全然問題なし。&lt;/p&gt;
&lt;p&gt;ツール補助がないとウィンドウがとっちらかってしまうので、Microsoft PowerToysの&lt;a href="https://docs.microsoft.com/ja-jp/windows/powertoys/fancyzones"&gt;FancyZones&lt;/a&gt;を使って割り振ってます。これのグリッド吸着がまた使いやすくて(Shift押しながら移動すると、事前定義したグリッドに張り付く)いいですね。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/147815474-6deb6990-da99-44e0-9d29-c2c39917395e.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;中央を広めに取りつつ(主にVisual Studioか、ブラウザがっつし見たりするときはブラウザを置く)、右にブラウザ、左は半分に割って下にGitKraken、上にExplorerみたいなパターンが多めでしょうか。Visual Studio + Unityとか、作業域的に大きく取りたいものを並べる場合は2分割のグリッドパターンも用意して、切り替えるようにしています。&lt;/p&gt;
&lt;p&gt;3分割みたいなのは、5K2Kぐらいの解像度がないと出来ないので、この解像度のモニタ増えてくれーって感じですね。選択肢がDELLしかないのは寂しい。液晶自体の画質もそんな良いわけでもないので、もう少し良いのが欲しい。しっかりしたHDR対応のが欲しい。120Hz出るのが欲しい。とか、思うところはそれなりにあります。とはいえ、それでも大満足です。もうこれ以外の解像度のモニタには戻りたくないなあ。&lt;/p&gt;
&lt;p&gt;と、いうわけで、モニタ変更のためにゴミ溜めだった机をキレイにした記念で、来年はずっとすっきりした机をキープするぞ、という強い気持ちがあります！単純に机がキレイになってたほうが作業やりやすいですしねー、やっぱゴミ溜めはダメですよ。&lt;/p&gt;
&lt;p&gt;キーボードをREALFORCE R3にしたのですが（前はR2でした）、今回からデフォ無線なんですね。キーボードなんて置きっぱなしだから別に有線でいいだろ、と思ってたんですが、これはこれでアリというか、めっちゃいいじゃん？と。サッとキーボードどかしたりがやりやすくなったのがいいですね、デスクで他の作業がやりやすくて。Bluetoothだから、そのままiPadやiPhoneに繋げてもいいし。いやあ、時代は無線。ケーブルがなくなってすっきりするし。&lt;/p&gt;
&lt;p&gt;と、いうわけで、無線環境が気に入ったので、デカい有線ヘッドフォン＋ヘッドフォンアンプを使っていたのですが(MDR-Z1R + TA-ZH1ES、合計40万もした)、撤去して、写真には写ってませんがAirPods Max買いました。これも満足。いやー、正直あんま有線ヘッドフォン使ってなかったんですよね、面倒くさくて。電源入れるだけ、ではありんですがやっぱ面倒くさくて。ケーブル太くて邪魔くさいし（無駄にケーブル換装して太いケーブルにしてしまったのも良くなかった）。PC専用になっちゃってiPhoneの音も聞けないし。&lt;/p&gt;
&lt;p&gt;AirPods MaxだとiPhone/iPad/PCの切り替えが自由なのが想像の100億倍良いなあ、と。音質面でも悪くないし、Apple Musicの空間オーディオとの相性は抜群でこれはめちゃくちゃいいし、さすがのヘッドフォン型なのでAirPods Proよりも音がいい。デジタルクラウンによる音量調整は最高に便利。ゲーム用に&lt;a href="https://www.dolby.com/jp/ja/apps/access.html"&gt;Dolby Access&lt;/a&gt;入れてDolby Atmos for Headphonesを有効化してますが、これもなかなか良い。&lt;/p&gt;
&lt;p&gt;スピーカーも置いてたんですが、撤去しました。簡単なものはモニタ内蔵のしょぼいスピーカーで済ませる。ちゃんと聴きたい場合はAirPods Max。それでいいや、と。割り切ったら、全然それでいいじゃん、という気になりました。そもそもあまりデスクトップのスピーカーを稼働させてないしなあ、というのもありますが。&lt;/p&gt;
&lt;h2&gt;時代は無線&lt;/h2&gt;
&lt;p&gt;スピーカー撤去の代わりに、じゃないのですが、今年はホームシアターシステムとして&lt;a href="https://www.sony.jp/home-theater/products/HT-A9/"&gt;HT-A9&lt;/a&gt;を導入したのですが、これも満足度高い。何がいいって、設置が無線で自由度高い。なんか今年は無線化の年ですね、時代は無線。&lt;/p&gt;
&lt;p&gt;昔は9.1chにしてたり5.1chだったりでスピーカー並べてたのですが、諸事情あってここ数年はサウンドバーを使ってたんですが、とにかくその音質には不満だったんですね。かといってリアスピーカー並べる気力も起きずというか、そのスペースも確保できない状態なのでどうしたものか、と思っていたところに出たのが、フル無線4.1chシステムのHT-A9。360 Spatial Sound MappingでDolby Atomos時代なサラウンドにするという謳い文句もいいし、設置レイアウトが自由というのがいい。オフィシャルサイトのこの画像を見て購入を決めました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/147816734-1c61b5b5-3150-47e0-b4f1-23aa0973f436.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;HT-A9の画像、どれもフロントスピーカーの置き方が「わざとらしく」でたらめなんですよね、高さを絶対揃えない。これは、メーカーが別に高さ揃えなくていいんですよ、と推奨してるということなんですが、実際うちでの設置環境もフロントの高さは揃ってないです。揃えられないので。リアも位置も高さもグチャグチャで、適当における棚に置いてるだけって感じです。フロントもリアも無線スピーカーなので、そういう適当配置がめっちゃやりやすい。&lt;/p&gt;
&lt;p&gt;それでもちゃんとサウランドするし、360 Spatialな音は心地良い。ただたんに音楽鳴らすだけにも使ってますね、起動も早いのでSpotify Connectでよく流してます。&lt;/p&gt;
&lt;p&gt;アンプのサイズが小さい(Apple TVが一回り大きくなった程度)というのも設置が楽になった要因で、いやほんとよく出来てますね。確かに、全部無線なのでスピーカーを駆動するアンプは各スピーカー内蔵状態だから、本体をAVアンプあるあるなクソデカサイズにしなくてもいいんですね。そういうところにも無線の良さが出てますね。&lt;/p&gt;
&lt;h2&gt;来年に向けてのC#&lt;/h2&gt;
&lt;p&gt;こうしてダラダラと文章書いたり、そもそもこの12月はやたら記事量産しているなあ、というのは、ブログ書く環境が変わったからです！10年前のWordPressから&lt;a href="https://neue.cc/2021/11/21.html"&gt;自家製サイトジェネレーターへの変更&lt;/a&gt;によって快適度上がったからですね。いやあ、書きやすいと書く気になります。環境大事。&lt;/p&gt;
&lt;p&gt;そんなわけでCysharpはC#はの環境を良くすることに今年一年もちゃんと務められたんじゃないでしょーか。Cysharpからの新規リリース/大型更新は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ProcessX"&gt;ProcessX Zx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MessagePipe"&gt;MessagePipe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Kokuban"&gt;Kokuban&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/CsprojModifier"&gt;CsprojModifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/NativeMemoryArray"&gt;NativeMemoryArray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework/"&gt;ConsoleAppFramework v4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ObservableCollections"&gt;ObservableCollections&lt;/a&gt; ←ReadMe/解説がまだな仕掛品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MessagePipeが大きめかな？&lt;/p&gt;
&lt;p&gt;こうした公開していく姿勢、足を少しでも止めてはダメだという思いがあるので、作ろうと思ったらできるだけ勢い持って作りきるようにしています（もちろん途中で止まってしまったものも幾つかありはしますが）。毎年継続的に、Cysharp全体としても既に20個以上公開していて、ヒット作もそれなりの量を出し続けていられる状態は中々のことだと思います。&lt;/p&gt;
&lt;p&gt;と、いうわけで、OSSを通じてCysharpをアピールしていくという方向では、良い点をあげてもいいかな、と思うのですが、反面、他の仕事に集中しきれていないのではないかというのが散見していたのは個人的にはマイナスです。今年は「世の中の開発生産性を革命的に改善するプロダクト」の作成に着手し（構想は前からあったのですがようやく始動）、徐々に人も集めだしてCysharpが割とまともな（？）会社っぽく動き出した頃合いでもあるんですが、私がボトルネックになりがち、な状況になりがちなのが、まぁいくないですねえ、と。これはグラニの頃もそうだったので、なんかもうそういうもの感もあるんですが、今回は私が主導してやってるので尻拭いしてくれる人もいないので純粋に良くない！&lt;/p&gt;
&lt;p&gt;というわけで、来年の中旬までにその「世の中の開発生産性を革命的に改善するプロダクト」をリリースするために全力でやっていくぞ、というのが目標です。実際出来上がってきて、かなりいいものになりそうな手応えはあるので、早く世の中に出して評価されたいものです。&lt;/p&gt;
&lt;p&gt;まぁ、そんなわけで大きな何かがあったわけではないですが、確実に前進した年だと思うので、来年は爆発させる年にしましょう。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-12-31T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/12/30.html</guid>
      <link>https://neue.cc/2021/12/30.html</link>
      <title>ConsoleAppFramework v4 - Minimal API for CommandLine tool</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/12/30.html"&gt;ConsoleAppFramework v4 - Minimal API for CommandLine tool&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-12-30&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;皆さん .NET 6で追加された&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/minimal-apis"&gt;Minimal API&lt;/a&gt;使ってみました？最初は別にいらんやろ、とか思ってたんですが、いや、これ正直めっちゃ凄い、いい。まぁDelegateベースで書くかどうかは別として（書かないかなー）、謎Startupを葬り去ってBuilder/Runが素直に繋がった形が美しい。Top level statementとの相性も良いので、もうこっちのAPI以外で作る気しないなあ。&lt;/p&gt;
&lt;p&gt;さて、ところでConsoleAppFrameworkです。今までクラスが必要だったんですよね、たった一個のメソッドを実装するにも。それがTop level statementとの相性が悪い。Top level statementだけで完結できるとき、クラスって作りたくないんですよね。と、いうわけで、そろそろ大改修が必要かなーと思っていたところにMinimal APIですよ。特にその場でラムダ式でばしばしAPI作っていくスタイルは、むしろコマンドラインツールのほうがマッチするじゃんどう考えても？&lt;/p&gt;
&lt;p&gt;と、いうわけで大改修して、Minimal APIベースになったv4、作りました。何が凄いって、一行でコマンドライン引数をパースしてハンドラー定義できちゃうんですね。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/147662718-f7756523-67a9-4295-b090-3cfc94203017.png" alt="" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ConsoleApp.Run(args, (string name) =&amp;gt; Console.WriteLine($&amp;quot;Hello {name}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは嘘偽りなくNuGetからダウンロードしたら、そのままでこう書けます。C# 10.0のglobal using(をNuGetのライブラリ側に埋め込むというEvilな手法を使ってます)と、ラムダ式の推論の向上によって実現しました。内側では、Minimal APIの実現のために Microsoft.Extensions.* 側にもかなり改修が入っていたので、それをそっくりそのまま利用できました。そういう意味で、 .NET 6になった今だからようやく作れた形になりますね。もちろんv1~v3までの蓄積のお陰というところもあります。集大成……！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework/"&gt;Cysharp/ConsoleAppFramework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、Runはちょっとウケ狙いなところもあるんですが、それ以外のAPIもBuilderベースになったので、だいぶ様変わりしています。ただし特徴としてGeneric Hostの上に乗っているというのは変わらないので、DbContext埋めたりappconfig.jsonから取ったりというのは、変わらずスムーズにできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// You can use full feature of Generic Host(same as ASP.NET Core).

var builder = ConsoleApp.CreateBuilder(args);
builder.ConfigureServices((ctx,services) =&amp;gt;
{
    // Register EntityFramework database context
    services.AddDbContext&amp;lt;MyDbContext&amp;gt;();

    // Register appconfig.json to IOption&amp;lt;MyConfig&amp;gt;
    services.Configure&amp;lt;MyConfig&amp;gt;(ctx.Configuration);

    // Using Cysharp/ZLogger for logging to file
    services.AddLogging(logging =&amp;gt;
    {
        logging.AddZLoggerFile(&amp;quot;log.txt&amp;quot;);
    });
});

var app = builder.Build();

// setup many command, async, short-name/description option, subcommand, DI
app.AddCommand(&amp;quot;calc-sum&amp;quot;, (int x, int y) =&amp;gt; Console.WriteLine(x + y));
app.AddCommand(&amp;quot;sleep&amp;quot;, async ([Option(&amp;quot;t&amp;quot;, &amp;quot;seconds of sleep time.&amp;quot;)] int time) =&amp;gt;
{
    await Task.Delay(TimeSpan.FromSeconds(time));
});
app.AddSubCommand(&amp;quot;verb&amp;quot;, &amp;quot;childverb&amp;quot;, () =&amp;gt; Console.WriteLine(&amp;quot;called via 'verb childverb'&amp;quot;));

// You can insert all public methods as sub command =&amp;gt; db select / db insert
// or AddCommand&amp;lt;T&amp;gt;() all public methods as command =&amp;gt; select / insert
app.AddSubCommands&amp;lt;DatabaseApp&amp;gt;();

app.Run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;単独のコマンドラインツール用に使ってもいいのですが、ASP.NETのウェブアプリが他にあって、それのバッチを作りたいみたいなときに、こうしたコンフィグの共通化はめっちゃ便利に使えるはずです。ConfigureServicesのコードはまんま一緒にできて、そのままDIできますからね。&lt;/p&gt;
&lt;p&gt;また、引き続き &lt;code&gt;AddCommands&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;AddAllCommandType&lt;/code&gt; によって、メソッド定義するだけで大量のコマンドを一括追加も可能になっています。&lt;/p&gt;
&lt;h2&gt;v3 -&amp;gt; v4の破壊的変更&lt;/h2&gt;
&lt;p&gt;破壊的変更、は沢山あるのですが、基本的に今までの使い方をしている場合は互換オプションで動くようにしたので、アップデートしたから壊れるということはない、はずです。v4からは&lt;code&gt;ConsoleApp.Create/CreateBuilder&lt;/code&gt; 経由で作るのが基本なのですが、v3は &lt;code&gt;Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&amp;lt;T&amp;gt;()&lt;/code&gt; 経由なので、ちょうど互換性オプションを突っ込むのに都合が良かったんですね。なお、&lt;code&gt;RunConsoleAppFrameworkAsync&lt;/code&gt;はエディタから見えないようにしてます。今後は非推奨で、本当に互換のためだけに残してます。&lt;/p&gt;
&lt;p&gt;まず変わったところは、デフォルトで長いオプション名が&lt;code&gt;--&lt;/code&gt;、短いオプション名が&lt;code&gt;-&lt;/code&gt;になりました。v3では&lt;code&gt;-&lt;/code&gt;が幾つついていてもいいというゆるふわマッチングだったのですが、(dotonet toolsと同じように)厳格化しています。&lt;/p&gt;
&lt;p&gt;また、デフォルトのコマンド/オプション名の変換ルールが単純なlower化から、hoge-hugaというlowerなkebab-caseになりました。これもdotnet tools合わせですね。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;AddCommands&amp;lt;T&amp;gt;&lt;/code&gt;した場合の挙動(v3では&lt;code&gt;RunConsoleAppFrameworkAsync&amp;lt;T&amp;gt;&lt;/code&gt;した場合)が、全てのpublicメソッドをコマンドとして追加するようになりました。デフォルト(ルート)コマンドにしたい場合は&lt;code&gt;[RootCommand]&lt;/code&gt;属性を付与してくださいということで。これは&lt;code&gt;AddSubCommand&amp;lt;T&amp;gt;&lt;/code&gt;した時と挙動を合わせたかったからです、違うと一貫性がなくて戸惑うので。&lt;/p&gt;
&lt;p&gt;と、いうわけで、互換性モードで動かした場合は&lt;code&gt;ConsoleAppOptions&lt;/code&gt;は以下のような変更で動くようになっています。よきかなよきかな。（それとargsのコマンド名でHoge.Hugaが来てたらHoge Hugaに分解するのも、この互換性モードだけの挙動です）&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;options.StrictOption = false;
options.NoAttributeCommandAsImplicitlyDefault = true;
options.NameConverter = x =&amp;gt; x.ToLower();
options.ReplaceToUseSimpleConsoleLogger = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そうだ、それとCtrl+Cした場合に、正しくCancellationTokenをハンドリングしていない場合でも、タイムアウトをハンドリングしてabortするようになりました。これは、なんか強制終了できなくてウゼーってなりがちというか、私自身よく引っかかってヤバかったので。むしろこれは今までがバグに近くて、正しく&lt;code&gt;HostOptions.ShutdownTimeout&lt;/code&gt;を処理していないせいでした。&lt;/p&gt;
&lt;p&gt;ちなみにこのタイムアウト時間はデフォルトは5秒で、ConfigureHostOptions(地味にこれは.NET 6(というかMicrosoft.Extensionsのv6)からの新API)で変更できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.CreateBuilder(args)
    .ConfigureHostOptions(options =&amp;gt;
    {
        // change timeout.
        options.ShutdownTimeout = TimeSpan.FromMinutes(30);
    })
    .Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;無計画にアドホックに作っていったせいで、どうにもクソコードすぎて、改修にめっちゃ手間取ったというか内部的にはほぼ作り直した……。弄るのだるくて嫌だなあと内心実際今まで思ってたんですが、やはりとても嫌なコードであった。v1の時の最初の発想が Class.Method にパラメータ分解してバッチを大量に作りたい(そもそもライブラリ名もMicroBatchFrameworkだったし)というものだけだったのが、徐々に汎用コマンドラインツールに進化していって、都度、適当に追加していった結果ではある。&lt;/p&gt;
&lt;p&gt;今回がっつし仕切り直したので、しばらくはメンテが楽になれるかなあ、という感じで、よきかなよきかな。&lt;/p&gt;
&lt;p&gt;まぁしかしC# 10.0は地味にヤバいですよ！使えば使うほど味が出てくるというか、最近ようやく手に馴染んで、よくわかってきた感じです。なんというか、とにかく、めっちゃいい。それとC# 10.0 + ConsoleAppFrameworkは全言語見渡しても最強のコマンドラインツール作成ライブラリじゃないです？いや、API自体のできの良さはほとんど ASP .NET CoreのMinimal APIのコピーにすぎないんですが、まぁしかしそれでもやっぱ、これはかなり良い感じじゃないかという手応えがあります。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-12-30T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/12/22.html</guid>
      <link>https://neue.cc/2021/12/22.html</link>
      <title>NativeMemoryArray - .NET 6 APIをフル活用した2GB超えの巨大データを扱うライブラリ</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/12/22.html"&gt;NativeMemoryArray - .NET 6 APIをフル活用した2GB超えの巨大データを扱うライブラリ&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-12-22&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2021/microsoft"&gt;.NET 6 Advent Calendar 2021&lt;/a&gt;の12日の代理投稿となります。プレゼント付きですと！？&lt;a href="https://www.balmuda.com/jp/brew/special-model"&gt;BALMUDA The Brew STARBUCKS RESERVE LIMITED EDITION&lt;/a&gt;が欲しいです！&lt;/p&gt;
&lt;p&gt;さて、先程NativeMemoryArrayという新しいライブラリを作成し、公開しました。.NET Standard 2.0でも動作しますが、全体的に .NET 6 の新API群(NativeMemory, Scatter/Gather I/O)を活かすための作りになっていますので、今回のAdvent Calendarにもピッタリ。実用性も、ある……！あります……！もちろんUnity版も用意してあります（NativeArrayと何が違うって？まぁ違うと言えば違います）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/NativeMemoryArray"&gt;GitHub - Cysharp/NativeMemoryArray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C#には配列、特にbyte[]を扱う上で大きな制約が一つあります。それは、一次元配列の上限値が0x7FFFFFC7(2,147,483,591)ということ。int.MaxValueよりちょっと小さめに設定されていて、ようするにざっくり2GBちょいが限界値になっています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;この限界値は、正確には .NET 6 でひっそり破壊的変更が行われましたので、.NET 6とそれ以外で少し異なります。詳しくは後で述べます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;この2GBという値は、int Lengthの都合上しょうがない(intの限界値に引っ張られている)のですが、昨今は4K/8Kビデオや、ディープラーニングの大容量データセットや、3Dスキャンの巨大点群データなどで、大きな値を扱うことも決して少ないわけではないため、2GB制約は正直厳しいです。そして、この制約は&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;であっても変わりません(Lengthがintのため)。&lt;/p&gt;
&lt;p&gt;ちなみに&lt;code&gt;LongLength&lt;/code&gt;は多次元配列における全次元の総数を返すためのAPIのため、一次元配列においては特に意味をなしません。.NET Frameworkの設定である&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element"&gt;gcAllowVeryLargeObjects&lt;/a&gt;も、構造体などを入れた場合の大きなサイズを許容するものであり(例えば4バイト構造体の配列ならば、2GB*4のサイズになる)、要素数の限界は超えられないため、byte[]としては2GBが限界であることに変わりはありません。&lt;/p&gt;
&lt;p&gt;こうした限界に突き当たった場合は、ストリーミング処理に切り替えるか、またはポインタを使って扱うかになりますが、どちらもあまり処理しやすいとは言えませんし、必ずしもインメモリで行っていた操作が代替できるわけではありません（ポインタなら頑張れば最終的にはなんとでもなりますが）。&lt;/p&gt;
&lt;p&gt;そこで、2GB制約を超えつつも、新しいAPI群(&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;RandomAccess.Write/Read&lt;/code&gt;, &lt;code&gt;System.IO.Pipelines&lt;/code&gt;など)と親和性の高いネイティブメモリを裏側に持つ配列（みたいな何か）を作りました。&lt;/p&gt;
&lt;p&gt;これによって、例えば巨大データの読み込み/書き込みも、 .NET 6の新Scatter/Gather APIの&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0"&gt;RandomAccess&lt;/a&gt;を用いると、簡単に処理できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// for example, load large file.
using var handle = File.OpenHandle(&amp;quot;4GBfile.bin&amp;quot;, FileMode.Open, FileAccess.Read, options: FileOptions.Asynchronous);
var size = RandomAccess.GetLength(handle);

// via .NET 6 Scatter/Gather API
using var array = new NativeMemoryArray&amp;lt;byte&amp;gt;(size);
await RandomAccess.ReadAsync(handle, array.AsMemoryList(), 0);

// iterate Span&amp;lt;byte&amp;gt; as chunk
foreach (var chunk in array)
{
    Console.WriteLine(chunk.Length);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Scatter/Gather APIに馴染みがなくても、&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;や &lt;code&gt;IEnumerable&amp;lt;Memory&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; を経由してStreamで処理する手法も選べます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static async Task ReadFromAsync(NativeMemoryArray&amp;lt;byte&amp;gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    var writer = buffer.CreateBufferWriter();

    int read;
    while ((read = await stream.ReadAsync(writer.GetMemory(), cancellationToken).ConfigureAwait(false)) != 0)
    {
        writer.Advance(read);
    }
}

public static async Task WriteToAsync(NativeMemoryArray&amp;lt;byte&amp;gt; buffer, Stream stream, CancellationToken cancellationToken = default)
{
    foreach (var item in buffer.AsMemorySequence())
    {
        await stream.WriteAsync(item, cancellationToken);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あるいは&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;のSliceを取り出して処理してもいいし、&lt;code&gt;ref T this[long index]&lt;/code&gt;によるインデクサアクセスやポインタの取り出しもできます。 .NET 6時代に完全にマッチしたAPIを揃えることで、標準の配列と同等、もしくはそれ以上の使い心地に仕上げることによって、C#の限界をまた一つ超える提供できたと思っています。&lt;/p&gt;
&lt;p&gt;とはいえもちろん、 .NET Standard 2.0/2.1 にも対応しているので、非 .NET 6なAPIでも大丈夫です、というかScatter/Gather API以外は別に今までもありますし普通に使えますので。&lt;/p&gt;
&lt;p&gt;普通の配列的にも使えます。GC避けには、こうした普通のAPIを使っていくのでも便利でしょう、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// call ctor with length, when Dispose free memory.
using var buffer = new NativeMemoryArray&amp;lt;byte&amp;gt;(10);

buffer[0] = 100;
buffer[1] = 100;

// T allows all unmanaged(struct that not includes reference type) type.
using var mesh = new NativeMemoryArray&amp;lt;Vector3&amp;gt;(100);

// AsSpan() can create Span view so you can use all Span APIs(CopyTo/From, Write/Read etc.).
var otherMeshArray = new Vector3[100];
otherMeshArray.CopyTo(mesh.AsSpan());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;はwhere T : unmanagedです。つまり、参照型を含まない構造体にしか使えません。まぁ巨大配列なんて使う場合には参照型含めたものなんて含めてんじゃねーよなので、いいでしょうきっと。巨大配列で使えることを念頭においてはいますが、別に普通のサイズの配列として使っても構いません。ネイティブメモリに確保するので、ヒープを汚さないため、適切な管理が行える箇所では便利に使えるはずです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;との違いですが、&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;そのものはクラスなので、フィールドに置けます。&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;と違って、ある程度の長寿命の確保が可能ということです。&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;のSliceが作れるため、Async系のメソッドに投げ込むこともできます。また、もちろん、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;の長さの限界はint.MaxValueまで(ざっくり2GB)なので、それ以上の大きさも確保できます。&lt;/p&gt;
&lt;p&gt;Unityにおける&lt;code&gt;NativeArray&amp;lt;T&amp;gt;&lt;/code&gt;との違いですが、&lt;code&gt;NativeArray&amp;lt;T&amp;gt;&lt;/code&gt;はUnity Engine側との効率的なやりとりのための入れ物なので、あくまでC#側で使うための&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;とは全然役割が異なります。まぁ、必要に思えない状況ならば、おそらく必要ではありません。&lt;/p&gt;
&lt;p&gt;主な長所は、以下になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ネイティブメモリから確保するためヒープを汚さない&lt;/li&gt;
&lt;li&gt;2GBの制限がなく、メモリの許す限り無限大の長さを確保できる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt; 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonWriter, System.IO.Pipelinesなどから直接読み込み可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt; 経由で、MessagePackSerializer, System.Text.Json.Utf8JsonReaderなどへ直接データを渡すことが可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IReadOnlyList&amp;lt;Memory&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;IReadOnlyList&amp;lt;ReadOnlyMemory&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 経由で &lt;code&gt;RandomAccess&lt;/code&gt;(Scatter/Gather API)に巨大データを直接渡すことが可能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あまりピンと来ない、かもしれませんが、使ってみてもらえれば分かる、かも。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;の全APIは以下のようになっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NativeMemoryArray(long length, bool skipZeroClear = false, bool addMemoryPressure = false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long Length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref T this[long index]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref T GetPinnableReference()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Span&amp;lt;T&amp;gt; AsSpan()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Span&amp;lt;T&amp;gt; AsSpan(long start)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Span&amp;lt;T&amp;gt; AsSpan(long start, int length)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt; AsMemory()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt; AsMemory(long start)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt; AsMemory(long start, int length)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool TryGetFullSpan(out Span&amp;lt;T&amp;gt; span)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt; CreateBufferWriter()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpanSequence AsSpanSequence(int chunkSize = int.MaxValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MemorySequence AsMemorySequence(int chunkSize = int.MaxValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IReadOnlyList&amp;lt;Memory&amp;lt;T&amp;gt;&amp;gt; AsMemoryList(int chunkSize = int.MaxValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IReadOnlyList&amp;lt;ReadOnlyMemory&amp;lt;T&amp;gt;&amp;gt; AsReadOnlyMemoryList(int chunkSize = int.MaxValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt; AsReadOnlySequence(int chunkSize = int.MaxValue)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpanSequence GetEnumerator()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void Dispose()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;AsSpan()&lt;/code&gt;, &lt;code&gt;AsMemory()&lt;/code&gt;はスライスのためのAPIです。取得したSpanやMemoryは書き込みも可能なため、 .NET 5以降に急増したSpan系のAPIに渡せます。SpanやMemoryには最大値(int.MaxValue)の限界があるため、lengthの指定がない場合は、例外が発生する可能性もあります。そこで&lt;code&gt;TryGetFullSpan()&lt;/code&gt;を使うと、単一Spanでフル取得が可能かどうか判定できます。また、&lt;code&gt;AsSpanSequence()&lt;/code&gt;, &lt;code&gt;AsMemorySequence()&lt;/code&gt;でチャンク毎のforeachで全要素を列挙することが可能です。直接foreachした場合は、&lt;code&gt;AsSpanSequence()&lt;/code&gt;と同様の結果となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;long written = 0;
foreach (var chunk in array)
{
    // do anything
    written += chunk.Length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ポインタの取得は、配列とほぼ同様に、そのまま渡せば0から(これは&lt;code&gt;GetPinnableReference()&lt;/code&gt;の実装によって実現できます)、インデクサ付きで渡せばそこから取れます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;fixed (byte* p = buffer)
{
}

fixed (byte* p = &amp;amp;buffer[42])
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CreateBufferWriter()&lt;/code&gt; によって &lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;を取得できます。これは&lt;code&gt;MessagePackSerializer.Serialize&lt;/code&gt;などに直接渡すこともできるほかに、先の例でも出しましたがStreamからの読み込みのように、先頭からチャンク毎に取得して書き込んでいくようなケースで便利に使えるAPIとなっています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsReadOnlySequence()&lt;/code&gt; で取得できる&lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt;は、&lt;code&gt;MessagePackSerializer.Deserialize&lt;/code&gt;などに直接渡すこともできるほかに .NET 5から登場した &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers.sequencereader-1?view=net-6.0"&gt;SequenceReader&lt;/a&gt;に通すことで、長大なデータのストリーミング処理をいい具合に行える余地があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsMemoryList()&lt;/code&gt;, &lt;code&gt;AsReadOnlySequence()&lt;/code&gt;は .NET 6から登場した&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0"&gt;RandomAccess&lt;/a&gt;の&lt;code&gt;Read/Write&lt;/code&gt;に渡すのに都合の良いデータ構造です。プリミティブな処理なので使いにくいと思いきや、意外とすっきりと処理できるので、File経由の処理だったらStreamよりもいっそもうこちらのほうがいいかもしれません。&lt;/p&gt;
&lt;h2&gt;NativeMemory&lt;/h2&gt;
&lt;p&gt;.NET 6から&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.nativememory?view=net-6.0"&gt;NativeMemory&lt;/a&gt;というクラスが新たに追加されました。その名の通り、ネイティブメモリを扱いやすくするものです。今までも&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=net-6.0"&gt;Marshal.AllocHGlobal&lt;/a&gt;といったメソッド経由でネイティブメモリを確保することは可能であったので、何が違うのか、というと、何も違いません。実際NativeMemoryArrayの .NET 6以前版はMarshalを使ってますし。そして .NET 6 では Marshal.AllocHGlobal は NativeMemory.Alloc を呼ぶので、完全に同一です。&lt;/p&gt;
&lt;p&gt;ただしもちろん .NET 6 実装時にいい感じに整理された、ということではあるので、NativeMemory、いいですよ。NativeMemory.Allocがmalloc、NativeMemory.AllocZeroedがcalloc、NativeMemory.Freeがfreeと対応。わかりやすいですし。&lt;/p&gt;
&lt;p&gt;ちなみにゼロ初期化する NativeMemory.AllocZeroed に相当するものはMarshalにはないので、その点でも良くなったところです。&lt;code&gt;NativeMemoryArray&amp;lt;T&amp;gt;&lt;/code&gt;では、コンストラクタのskipZeroClear(&lt;code&gt;public NativeMemoryArray(long length, bool skipZeroClear = false)&lt;/code&gt;)によってゼロ初期化する/しないを選べます。デフォルトは（危ないので）初期化しています。非.NET 6版では、メモリ確保後に&lt;code&gt;Span&amp;lt;T&amp;gt;.Clear()&lt;/code&gt;経由で初期化処理を入れています。&lt;/p&gt;
&lt;h2&gt;真のArray.MaxValue&lt;/h2&gt;
&lt;p&gt;.NET 6以前では、配列の要素数はバイト配列(1バイト構造体の配列)と、それ以外の配列で異なる値がリミットに設定されていました。例えば&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array?view=net-6.0"&gt;System.Arrayのドキュメント&lt;/a&gt;を引いてくると&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配列のサイズは、合計で40億の要素に制限され、任意の次元の0X7FEFFFFF の最大インデックス (バイト配列の場合は0X7FFFFFC7、1バイト構造体の配列の場合) に制限されます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;つまり、0X7FFFFFC7の場合と、0X7FEFFFFFの場合がある、と。&lt;/p&gt;
&lt;p&gt;と、いうはずだったのですが、.NET 6から&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.maxlength"&gt;Array.MaxLength&lt;/a&gt;というプロパティが新規に追加されて、これは単一の定数を返します。その値は、0X7FFFFFC7です。よって、いつのまにかひっそりと配列の限界値は(ちょびっと大きい方に)大統一されました。&lt;/p&gt;
&lt;p&gt;この変更は意外とカジュアルに行われ、まず最大値を取得する、ただし単一じゃないため型によって結果の変わる &lt;code&gt;Array.GetMaxLength&amp;lt;T&amp;gt;()&lt;/code&gt; を入れよう、&lt;a href="https://github.com/dotnet/runtime/pull/43301"&gt;という実装があがってきました&lt;/a&gt;。そうしたら、そのPR上での議論で、そもそも当初は最適化を期待したけど別にそんなことなかったし、統一しちゃってよくね？という話になり、そのまま限界値は統一されました。そして新規APIも無事、Array.MaxLengthという定数返しプロパティになりました。&lt;/p&gt;
&lt;p&gt;まぁ、シンプルになって良いですけどね。大きい方で統一されたので実害も特にないでしょうし。前述のSystem.Arrayのドキュメントは更新されてないということで、正しくは、.NET 6からは0x7FFFFFC7が限界で、その値はArray.MaxLengthで取れる。ということになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;の限界値はint.MaxValueなので、限界に詰め込んだ&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;をそのままToArray()すると死ぬ、という微妙な問題が発生することがあるんですが、まぁそこはしょうがないね。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;NativeArrayという名前にしたかったのですがUnityと被ってしまうので避けました。しょーがない。&lt;/p&gt;
&lt;p&gt;着手当時はマネージド配列のチャンクベースで作っていたのですが(&lt;a href="https://gist.github.com/neuecc/e6293b1d88244cf942753d6408b3e966"&gt;LargeArray.cs&lt;/a&gt;)、Sliceが作りづらいし、ネイティブメモリでやったほうが出来ること多くて何もかもが圧倒的にいいじゃん、ということに作業進めている最中に気づいて、破棄しました。参照型の配列が作れるという点で利点はありますが、まぁ参照型で巨大配列なんて作らねーだろ、思うと、わざわざ実装増やして提供するメリットもないかな、とは。&lt;/p&gt;
&lt;p&gt;配列はもう昔からあるのでint Lengthなのはしょうがないのですが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;のLengthはlongであって欲しかったかなー、とは少し思っています。&lt;a href="https://github.com/dotnet/apireviews/tree/main/2016/11-04-SpanOfT#spant-and-64-bit"&gt;2016年の段階でのSpanのAPIどうするかドキュメント&lt;/a&gt;によると、候補は幾つかあったけど、結果的に配列踏襲のint Lengthになったそうで。2GBでも別に十分だろ、みたいなことも書いてありますが、いや、そうかなー？年にそこそこの回数でたまによく引っかかるんだけどねー？&lt;/p&gt;
&lt;p&gt;そして2016年の議論時点ではなかった、C# 9.0で&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/nint-nuint"&gt;nuint, nuint&lt;/a&gt;が追加されたので、&lt;code&gt;nuint Span&amp;lt;T&amp;gt;/Memory&amp;lt;T&amp;gt;.Length&lt;/code&gt;はありなんじゃないかな、と。&lt;/p&gt;
&lt;p&gt;ただNativeMemoryArrayの開発当初は&lt;code&gt;nuint Length&lt;/code&gt;で作っていたのですが、&lt;code&gt;AsSpan(nuint start, nuint length)&lt;/code&gt;みたいなAPIは、カジュアルにintやlongを突っ込めなくて死ぬほど使いづらかったので、最終的にlongで統一することにしました。ので、&lt;code&gt;nuint Length&lt;/code&gt;は、なしかな。つまり一周回って現状維持。そんなものかー、そんなもんですねー。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-12-22T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/12/04.html</guid>
      <link>https://neue.cc/2021/12/04.html</link>
      <title>.NET 6とAngleSharpによるC#でのスクレイピング技法</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/12/04.html"&gt;.NET 6とAngleSharpによるC#でのスクレイピング技法&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-12-04&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2021/csharplang"&gt;C# Advent Calendar 2021&lt;/a&gt;の参加記事となっています。去年は2個エントリーしたあげく、1個すっぽかした（！）という有様だったので、今年は反省してちゃんと書きます。&lt;/p&gt;
&lt;p&gt;スクレイピングに関しては10年前に&lt;a href="https://neue.cc/2010/03/02_244.html"&gt;C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法&lt;/a&gt;という記事でSGMLReaderを使ったやり方を紹介していたのですが、10年前ですよ、10年前！さすがにもう古臭くて、現在ではもっとずっと効率的に簡単にできるようになってます。&lt;/p&gt;
&lt;p&gt;今回メインで使うのは&lt;a href="https://anglesharp.github.io/"&gt;AngleSharp&lt;/a&gt;というライブラリです。AngleSharp自体は2015年ぐらいからもう既に定番ライブラリとして、日本でも紹介記事が幾つかあります。が、いまいち踏み込んで書かれているものがない気がするので、今回はもう少しがっつりと紹介していきたいと思っています。それと直近Visual StudioのWatchウィンドウの使い方を知らん、みたいな話を聞いたりしたので、デバッグ方法の手順みたいなものを厚めに紹介したいなあ、という気持ちがあります！&lt;/p&gt;
&lt;p&gt;AngleSharpの良いところは、まずはHTMLをパースしてCSSセレクターで抽出できるところです。以前はLINQ(to DOM)があればCSSセレクターじゃなくてもいいっす、WhereとSelectManyとDescendantsでやってきますよ、とか言ってましたが、そんなにきちんと構造化されてるわけじゃないHTMLを相手にするのにあたっては、CSSセレクターのほうが100億倍楽！CSSセレクターの文法なんて大したことないので、普通に覚えて使えってやつですね。SQLと正規表現とCSSセレクターは三大言語関係なく覚えておく教養、と。&lt;/p&gt;
&lt;p&gt;もう一つは、それ自体でネットワークリクエストが可能なこと。FormへのSubmitなどもサポートして、Cookieも保持し続けるとかが出来るので、ログインして会員ページを弄る、といったようなクローラーが簡単に書けるんですね。この辺非常に良く出来ていて、もう自前クローラーなんて投げ捨てるしかないです。また、&lt;a href="https://github.com/sebastienros/jint"&gt;Jint&lt;/a&gt;というPure C#なJavaScriptインタプリタと統合したプラグインも用意されているので、JavaScriptがDOMをガリガリっと弄ってくる今風のサイトにも、すんなり対応できます。&lt;/p&gt;
&lt;p&gt;AngleSharpの紹介記事では、よくHttpClientなどで別途HTMLを取ってきたから、それをAngleSharpのHtmlParserに読み込ませる、というやり方が書かれていることが多いのですが、取得も含めて全てAngleSharp上で行ったほうが基本的には良いでしょう。&lt;/p&gt;
&lt;p&gt;ここまで来るとPure C#の軽量なヘッドレスブラウザとしても動作する、ということになるので、カジュアルなE2Eテストの実装基盤にもなり得ます。普通のユニットテストと並べて &lt;code&gt;dotnet test&lt;/code&gt; だけでその辺もある程度まかなえたら、とても素敵なことですよね？がっつりとしたE2Eテストを書きたい場合は&lt;a href="https://github.com/microsoft/playwright"&gt;Playwright&lt;/a&gt;などを使わなければ、ということになってしまいますが、まずは軽い感じから始めたい、という時にうってつけです。C#で書けるし。いいことです。&lt;/p&gt;
&lt;h2&gt;BrowingContextとQuerySelectorの基本&lt;/h2&gt;
&lt;p&gt;まずはシンプルなHTMLのダウンロードと解析を。基本は &lt;code&gt;BrowsingContext&lt;/code&gt; を作って、それをひたすら操作していくことになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// この辺で色々設定する
var config = Configuration.Default
    .WithDefaultLoader(); // LoaderはデフォではいないのでOpenAsyncする場合につける

// Headless Browser的なものを作る
using var context = BrowsingContext.New(config);

// とりあえずこのサイトの、右のArchivesのリンクを全部取ってみる
var doc = await context.OpenAsync(&amp;quot;https://neue.cc&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OpenAsyncで取得できた &lt;code&gt;IDocument&lt;/code&gt; をよしなにCSSセレクターで解析していくわけですが、ここで絞り込みクエリー作成に使うのがVisual StudioのWatchウィンドウ。（Chromeのデベロッパーツールなどで機械的に取得したい要素のCSSセレクターを取得できたりしますが、手セレクターのほうがブレなくルールは作りやすいかな、と）。&lt;/p&gt;
&lt;p&gt;デバッガーを起動して、とりあえずウォッチウィンドウを開いておもむろに、Nameのところでコードを書きます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144583627-0c7982e4-4933-41f7-ba04-81836f10da8c.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;ウォッチウィンドウは見たい変数を並べておく、お気に入り的な機能、と思いきや本質的にはそうじゃなくて、式を自由に書いて、結果を保持する、ついでに式自体も保持できるという、実質REPLなのです。代入もラムダ式もLINQも自由に書けるし、入力補完も普通に出てくる。Immediate Windowよりも結果が遥かに見やすいので、Immediate Windowは正直不要です。&lt;/p&gt;
&lt;p&gt;デバッガー上で動いているので実データを自由に扱えるというところがいいですね。というわけで、ToHtml()でHTMLを見て、QuerySelectorAllをゆっくり評価しながら書いていきましょう。まずはサイドバーにあるので &lt;code&gt;.side_body&lt;/code&gt; を出してみると、あれ、二個あるの？と。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144582934-371930f2-dbff-4341-9f92-87e27c56d477.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;中開けてInnerHtml見ると、なるほどProfile部分とArchive部分、と。とりあえず後ろのほうで固定のはずなのでlast-childね、というところで一旦評価して大丈夫なのを確認した後に、あとはa、と。でここまでで期待通りの結果が取れていれば、コピペる。よし。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// 基本、QuerySelectorかQuerySelectorAllでDOMを絞り込む
var anchors = doc.QuerySelectorAll(&amp;quot;.side_body:last-child a&amp;quot;)
    .Cast&amp;lt;IHtmlAnchorElement&amp;gt;() // AngleSharp.Html.Dom
    .Select(x =&amp;gt; x.Href)
    .ToArray();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;単一の要素に絞り込んだ場合は、 &lt;code&gt;IHtml***&lt;/code&gt; にキャストしてあげると扱いやすくなります(attributeのhrefのtextを取得、みたいにしなくていい)。頻出パターンなので、&lt;code&gt;QuerySelectorAll&amp;lt;T&amp;gt;&lt;/code&gt;でCastもセットになってすっきり。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;doc.QuerySelectorAll&amp;lt;IHtmlAnchorElement&amp;gt;(&amp;quot;.side_body:last-child a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;せっかくなので、年に何本記事を書いていたかの集計を出してみたいと思います！URLから正規表現で年と月を取り出すので、とりあえずここでもウォッチウィンドウです。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144590970-34c3bff4-0f0b-4db3-a259-f37a6f1e5f40.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;anchrosの[0]を確認して、これをデータソースとしてRegex.Matchを書いて、どのGroupに収まったのかを見ます。この程度だったら特にミスらないでしょー、と思いきや普通に割とミスったりするのが正規表現なので、こういうので確認しながらやっていけるのはいいですね。&lt;/p&gt;
&lt;p&gt;後は普通の（？）LINQコード。グルーピングした後に、ひたすら全ページをOpenAsyncしていきます。記事の本数を数えるのはh1の数をチェックするだけなので、特に複雑なCSSセレクターは必要なし。本来はページングの考慮は必要ですが、一月単位だとページングが出てくるほどの記事量がないので、そこも考慮なしで。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var yearGrouped = anchors
    .Select(x =&amp;gt;
    {
        var match = Regex.Match(x, @&amp;quot;(\d+)/(\d+)&amp;quot;);
        return new
        {
            Url = x,
            Year = int.Parse(match.Groups[1].Value),
            Month = int.Parse(match.Groups[2].Value)
        };
    })
    .GroupBy(x =&amp;gt; x.Year);

foreach (var year in yearGrouped.OrderBy(x =&amp;gt; x.Key))
{
    var postCount = 0;
    foreach (var month in year)
    {
        var html = await context.OpenAsync(month.Url);
        postCount += html.QuerySelectorAll(&amp;quot;h1&amp;quot;).Count(); // h1 == 記事ヘッダー
    }
    Console.WriteLine($&amp;quot;{year.Key}年記事更新数: {postCount}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結果は&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2009年記事更新数: 92
2010年記事更新数: 61
2011年記事更新数: 66
2012年記事更新数: 30
2013年記事更新数: 33
2014年記事更新数: 22
2015年記事更新数: 19
2016年記事更新数: 24
2017年記事更新数: 13
2018年記事更新数: 11
2019年記事更新数: 14
2020年記事更新数: 11
2021年記事更新数: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ということで右肩下がりでした、メデタシメデタシ。今年は特に書いてないなあ、せめて2ヶ月に1本は書きたいところ……。&lt;/p&gt;
&lt;p&gt;なお、&lt;a href="https://neue.cc/2021/11/21.html"&gt;C#による自家製静的サイトジェネレーターに移行した話&lt;/a&gt;
で紹介しているのですが、このサイトは完全に&lt;a href="https://github.com/neuecc/Blog2/tree/master/articles"&gt;GitHub上に.mdがフラットに並んで.mdが管理されている&lt;/a&gt;ので、こういうの出すなら別にスクレイピングは不要です。&lt;/p&gt;
&lt;h2&gt;UserAgentを変更する&lt;/h2&gt;
&lt;p&gt;スクレイピングといったらログインしてごにょごにょする。というわけで、そうしたログイン処理をさくっとやってくれるのがAngleSharpの良いところです。ので紹介していきたいのですが、まずはやましいことをするので（？）、UserAgentを偽装しましょう。&lt;/p&gt;
&lt;p&gt;AngleSharpが現在何を送っているのかを確認するために、とりあえずダミーのサーバーを立てます。その際には .NET 6 のASP .NET から搭載されたMinimal APIが非常に便利です！そしてそれを&lt;a href="https://www.linqpad.net/"&gt;LINQPad&lt;/a&gt;で動かすと、テスト用サーバーを立てるのにめっちゃ便利です！やってみましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144586706-aa067b51-d8d3-44ac-91b3-552c62e7ce6d.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;たった三行でサーバーが立ちます。便利。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;await context.OpenAsync(&amp;quot;http://localhost:5000/headers&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でアクセスして、 &lt;code&gt;AngleSharp/1.0.0.0&lt;/code&gt; で送られていることが確認できました。&lt;/p&gt;
&lt;p&gt;なお、LINQPadでASP.NETのライブラリを使うには、Referene ASP.NET Core assembliesのチェックを入れておく必要があります。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144586956-fddb4821-59a3-4f37-9086-1624d471ed36.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;他、よく使うNuGetライブラリや名前空間なども設定したうえで、&lt;code&gt;Set as default for new queries&lt;/code&gt;しておくと非常に捗ります。&lt;/p&gt;
&lt;p&gt;さて、で、このUser-Agentのカスタマイズの方法ですが、AngleSharpはServicesに機能が詰まっているようなDI、というかService Locatorパターンの設計になっているので、ロードされてるServicesを(Watch Windowで)一通り見ます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144601687-3ee78e1d-2f95-404f-b2f9-162deb8eeda0.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;型に限らず全Serviceを取得するメソッドが用意されていない場合でも、&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;で取ってやると全部出てくるような実装は割と多い（ほんと）ので、とりあえずやってみるのはオススメです。今回も無事それで取れました。&lt;/p&gt;
&lt;p&gt;で、型名を眺めてそれっぽそうなのを見ると &lt;code&gt;DefaultHttpRequester&lt;/code&gt; というのがかなりそれっぽく、その中身を見るとHeadersという輩がいるので、これを書き換えればいいんじゃないだろうかと当たりがつきます。&lt;/p&gt;
&lt;p&gt;ここはやましい気持ちがあるので（？）Chromeに偽装しておきましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var requester = context.GetService&amp;lt;DefaultHttpRequester&amp;gt;();
requester.Headers[&amp;quot;User-Agent&amp;quot;] = &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再びOpenAsyncしてLINQPadの表示を見て、変更されてること確認できました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144602382-aba63413-2065-46ed-bd52-f4adf65bd30f.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;ちなみに、DefaultじゃないHttpRequesterをConfigurationに登録しておく、ということも出来ますが、よほどカスタムでやりたいことがなければ、デフォルトのものをちょっと弄るぐらいの方向性でやっていったほうが楽です。&lt;/p&gt;
&lt;h2&gt;FormにSubmitする&lt;/h2&gt;
&lt;p&gt;クローラーと言ったらFormにSubmit、つまりログイン！そしてクッキーをいただく！認証！&lt;/p&gt;
&lt;p&gt;さて、が、まぁ認証付きの何かを例にするのはアレなので、googleの検索フォームを例にさせていただきたいと思います。先にまずはコード全体像と結果を。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom; // 拡張メソッドとかで有効化されたりするのでusing大事
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies(); // login form的なものの場合これでクッキーを持ち歩く

using var context = BrowsingContext.New(config);

// お行儀悪いので（？）前述のこれやっておく
var requester = context.GetService&amp;lt;DefaultHttpRequester&amp;gt;();
requester.Headers[&amp;quot;User-Agent&amp;quot;] = &amp;quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&amp;quot;;

var doc = await context.OpenAsync(&amp;quot;https://google.com/&amp;quot;);
var form = doc.Forms[0];
var result = await form.SubmitAsync(new { q = &amp;quot;AngleSharp&amp;quot; }); // name = valueは匿名型が使える

// とりあえず結果を表示しておく
var titles = result.QuerySelectorAll&amp;lt;IHtmlHeadingElement&amp;gt;(&amp;quot;h3&amp;quot;).Select(x =&amp;gt; x.TextContent);
var i = 1;
foreach (var item in titles)
{
    Console.WriteLine($&amp;quot;{i++:00}: {item}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144704506-b0d7038f-ad26-42e4-b8dd-b63b250759c5.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WithDefaultLoader&lt;/code&gt; と、そして認証クッキー持ち歩きのために &lt;code&gt;WithDefaultCookies&lt;/code&gt; をコンフィギュレーションに足しておくことが事前準備として必須です。User-Agentの書き換えはご自由に、ただやましいこと、ではなくてUA判定をもとにして処理する、みたいなサイトも少なからずあるので、余計ないこと考えなくて済む対策としてはUAをChromeに偽装しておくのはアリです。&lt;/p&gt;
&lt;p&gt;FormへのSubmit自体は3行というか2行です。ページをOpenしてFormに対してSubmitするだけ。超簡単。 &lt;code&gt;.Forms&lt;/code&gt; で &lt;code&gt;IHtmlElementForms&lt;/code&gt;がすっと取れるので、あとは単純にSubmitするだけです。渡す値は &lt;code&gt;{ name = value }&lt;/code&gt;の匿名型で投げ込めばOK。&lt;/p&gt;
&lt;p&gt;度々出てくるウォッチウィンドウの宣伝ですが、この何の値を投げればいいのか、を調べるのにHTMLとニラメッコではなく、ウォッチウィンドウで調査していきます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/146650708-d2f1beb1-c21b-4a0a-851b-d0e78628bc00.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;まず(&amp;quot;input&amp;quot;)を拾うのですが、9個ある。多いね、で、まぁこれはほとんどtype = &amp;quot;hidden&amp;quot;なので無視して良い（AngleSharpがSubmitAsync時にちゃんと自動でつけて送信してくれる）。値を入れる必要があるのはhiddden以外のものなので、それをウォッチで普通にLINQで書けば、3件に絞れました。で、中身見ると必要っぽいのはqだけなので、 new { q = &amp;quot;hogemoge&amp;quot; } を投下、と。&lt;/p&gt;
&lt;p&gt;認証が必要なサイトでは、これでBrowingContextに認証クッキーがセットされた状態になるので、以降のこのContextでのOpenや画像、動画リクエストは認証付きになります。&lt;/p&gt;
&lt;h2&gt;画像や動画を拾う&lt;/h2&gt;
&lt;p&gt;スクレイピングといったら画像集めマンです（？）。AngleSharpでのそうしたリソース取得のやり方には幾つかあるのですが、私が最も良いかな、と思っているのはIDocumentLoader経由でのフェッチです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// BrowsingContextから引っ張る。Contextが認証クッキー取得済みなら認証が必要なものもダウンロードできる。
var loader = context.GetService&amp;lt;IDocumentLoader&amp;gt;();

// とりあえず適当にこのブログの画像を引っ張る
var response = await loader.FetchAsync(new DocumentRequest(new Url(&amp;quot;https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png&amp;quot;))).Task;

using var ms = new MemoryStream();
await response.Content.CopyToAsync(ms);

var bytes = ms.ToArray(); // あとは適当にFile.WriteAllBytesでもなんでもどうぞ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部用なので少し引数やAPIが冗長なところもありますが、それは後述しますが別になんとでもなるところなので、どちらかというと生のStreamが取れたりといった柔軟性のところがプラスだと思っています。普通にHttpClientで自前で取るのと比べると、認証周りやってくれた状態で始められるのが楽ですね。&lt;/p&gt;
&lt;p&gt;並列ダウンロードもいけます、例えば、このブログの全画像を引っ張るコードを、↑に書いた全ページ取得コードを発展させてやってみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&amp;lt;DefaultHttpRequester&amp;gt;();
requester.Headers[&amp;quot;User-Agent&amp;quot;] = &amp;quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&amp;quot;;

var doc = await context.OpenAsync(&amp;quot;https://neue.cc/&amp;quot;);
var loader = context.GetService&amp;lt;IDocumentLoader&amp;gt;();

foreach (var arvhives in doc.QuerySelectorAll&amp;lt;IHtmlAnchorElement&amp;gt;(&amp;quot;.side_body:last-child a&amp;quot;))
{
    var page = await context.OpenAsync(arvhives.Href);

    // content(ページ本体)下のimgを全部。
    // 今回はページ単位で5並列ダウンロードすることにする(粒度の考え方は色々ある)
    var imgs = page.QuerySelectorAll&amp;lt;IHtmlImageElement&amp;gt;(&amp;quot;#content img&amp;quot;);
    await Parallel.ForEachAsync(imgs, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (img, ct) =&amp;gt;
     {
         var url = new Url(img.Source);
         var response = await loader.FetchAsync(new DocumentRequest(url)).Task;

         // とりあえず雑にFile書き出し。
         Console.WriteLine($&amp;quot;Downloading {url.Path}&amp;quot;);
         using (var fs = new FileStream(@$&amp;quot;C:\temp\neuecc\{url.Path.Replace('/', '_')}&amp;quot;, FileMode.Create))
         {
             await response.Content.CopyToAsync(fs, ct);
         }
     });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET 6から &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.parallel.foreachasync"&gt;Parallel.ForEachAsync&lt;/a&gt; が追加されたので、asyncコードを並列数(MaxDegreeOfParallelism)で制御した並列実行が容易に書けるようになりました。async/await以降、Parallel系の出番は圧倒的に減ったのは確かなのですが、Task.WhenAllだけだと並列に走りすぎてしまって逆に非効率となってしまって、そこを制御するコードを自前で用意する必要が出てきていたりと面倒なものも残っていました。それが、このParallel.ForEachAsyncで解消されたと思います。&lt;/p&gt;
&lt;h2&gt;Kurukuru Progress&lt;/h2&gt;
&lt;p&gt;数GBの動画をダウンロードする時などは、プログレスがないとちゃんと動いているのか確認できなくて不便です。しかし、ただ単にConsole.WriteLineするだけだとログが凄い勢いで流れていってしまって見辛くて困りものです。そこを解決するC#ライブラリが&lt;a href="https://github.com/mayuki/Kurukuru"&gt;Kurukuru&lt;/a&gt;で、見ればどんなものかすぐわかるので、まずは実行結果を見てもらいましょう（素の回線だと一瞬でダウンロード終わってしまったので回線の低速シミュレーションしてます）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/144711389-7fa99e14-3f77-4fef-a7e7-5d12724aacd1.gif" alt="guruguru" /&gt;&lt;/p&gt;
&lt;p&gt;一行だけを随時書き換えていってくれるので、見た目も非常に分かりやすくて良い感じです。これはとても良い。Kurukuru、今すぐ使いましょう。ちなみに今回の記事で一番時間がかかったのは、Kurukuruの並列リクエスト対応だったりして（対応していなかったのでコード書いてPR上げて、今日リリースしてもらいましたできたてほやほやコード）。&lt;/p&gt;
&lt;p&gt;AngleSharp側のコードですが、この例は&lt;a href="https://file-examples.com/index.php/sample-video-files/sample-mp4-files/"&gt;File Examples
&lt;/a&gt;のMP4を並列で全部取るというものです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using AngleSharp;
using AngleSharp.Dom;
using AngleSharp.Html.Dom;
using AngleSharp.Io;
using Kurukuru;
using System.Text;

// Kurukuruを使う上で大事なおまじない
// え、デフォルトのEncodingがUTF8じゃないシェルがあるんです！？←Windows
Console.OutputEncoding = Encoding.UTF8;

var config = Configuration.Default
    .WithDefaultLoader()
    .WithDefaultCookies();

using var context = BrowsingContext.New(config);

var requester = context.GetService&amp;lt;DefaultHttpRequester&amp;gt;();
requester.Headers[&amp;quot;User-Agent&amp;quot;] = &amp;quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36&amp;quot;;

var doc = await context.OpenAsync(&amp;quot;https://file-examples.com/index.php/sample-video-files/sample-mp4-files/&amp;quot;);
var loader = context.GetService&amp;lt;IDocumentLoader&amp;gt;();

// ここから本体
var mp4s = doc.QuerySelectorAll&amp;lt;IHtmlAnchorElement&amp;gt;(&amp;quot;a&amp;quot;).Where(x =&amp;gt; x.Href.EndsWith(&amp;quot;.mp4&amp;quot;));
Console.WriteLine(&amp;quot;Download sample-mp4-files&amp;quot;);
await Parallel.ForEachAsync(mp4s, new ParallelOptions { MaxDegreeOfParallelism = 5 }, async (mp4, ct) =&amp;gt;
{
    var bin = await loader.FetchBytesAsync(mp4.Href);
    // あとはFile.WriteAllBytesするとか好きにして
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ポイントは &lt;code&gt;var bin = await loader.FetchBytesAsync(mp4.Href);&lt;/code&gt; で、これは拡張メソッドです。loaderにProgress付きでbyte[]返すメソッドを生やしたことで、随分シンプルに書けるようになりました。StreamのままFileStreamに書いたほうがメモリ節約的にはいいんですが、中途半端なところでコケたりした場合のケアが面倒くさいので、ガチガチなパフォーマンスが重視される場合ではないならbyte[]のまま受けちゃってもいいでしょう。1つ4GBの動画を5並列なんですが？という場合でも、たかがメモリ20GB程度なので普通にメモリ積んで処理すればいいっしょ。&lt;/p&gt;
&lt;p&gt;FetchBytesAsyncの中身は以下のようなコードになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class DocumentLoaderExtensions
{
    public static async Task&amp;lt;byte[]&amp;gt; FetchBytesAsync(this IDocumentLoader loader, string address, CancellationToken cancellationToken = default)
    {
        var url = new AngleSharp.Url(address);
        var response = await loader.FetchAsync(new DocumentRequest(url)).Task;
        if (response.StatusCode != System.Net.HttpStatusCode.OK)
        {
            return Array.Empty&amp;lt;byte&amp;gt;(); // return empty instead of throws error(ここをどういう挙動させるかは好みで……。)
        }

        // Content-Lengthが取れない場合は死でいいということにする
        var contentLength = int.Parse(response.Headers[&amp;quot;Content-Length&amp;quot;]);

        using var progress = new ProgressSpinner(url.Path.Split('/').Last(), contentLength);
        try
        {
            return await ReadAllDataAsync(response.Content, contentLength, progress, cancellationToken);
        }
        catch
        {
            progress.Cancel();
            throw;
        }
    }

    static async Task&amp;lt;byte[]&amp;gt; ReadAllDataAsync(Stream stream, int contentLength, IProgress&amp;lt;int&amp;gt; progress, CancellationToken cancellationToken)
    {
        var buffer = new byte[contentLength];
        var readBuffer = buffer.AsMemory();
        var len = 0;
        while ((len = await stream.ReadAsync(readBuffer, cancellationToken)) &amp;gt; 0)
        {
            progress.Report(len);
            readBuffer = readBuffer.Slice(len);
        }
        return buffer;
    }
}

public class ProgressSpinner : IProgress&amp;lt;int&amp;gt;, IDisposable
{
    readonly Spinner spinner;
    readonly string fileName;
    readonly int? totalBytes;
    int received = 0;

    public ProgressSpinner(string fileName, int? totalBytes)
    {
        this.totalBytes = totalBytes;
        this.fileName = fileName;
        this.spinner = new Spinner($&amp;quot;Downloading {fileName}&amp;quot;);
        this.spinner.Start();
    }

    public void Report(int value)
    {
        received += value;
        if (totalBytes != null)
        {
            var percent = (received / (double)totalBytes) * 100;
            spinner.Text = $&amp;quot;Downloading {fileName} {ToHumanReadableBytes(received)} / {ToHumanReadableBytes(totalBytes.Value)} ( {Math.Floor(percent)}% )&amp;quot;;
        }
        else
        {
            spinner.Text = $&amp;quot;Downloading {fileName} {ToHumanReadableBytes(received)}&amp;quot;;
        }
    }

    public void Cancel()
    {
        spinner.Fail($&amp;quot;Canceled {fileName}: {ToHumanReadableBytes(received)}&amp;quot;);
        spinner.Dispose();
    }

    public void Dispose()
    {
        spinner.Succeed($&amp;quot;Downloaded {fileName}: {ToHumanReadableBytes(received)}&amp;quot;);
        spinner.Dispose();
    }

    static string ToHumanReadableBytes(int bytes)
    {
        var b = (double)bytes;
        if (b &amp;lt; 1024) return $&amp;quot;{b:0.00} B&amp;quot;;
        b /= 1024;

        if (b &amp;lt; 1024) return $&amp;quot;{b:0.00} KB&amp;quot;;
        b /= 1024;

        if (b &amp;lt; 1024) return $&amp;quot;{b:0.00} MB&amp;quot;;
        b /= 1024;

        if (b &amp;lt; 1024) return $&amp;quot;{b:0.00} GB&amp;quot;;
        b /= 1024;

        if (b &amp;lt; 1024) return $&amp;quot;{b:0.00} TB&amp;quot;;
        b /= 1024;

        return $&amp;quot;{0:0.00} PB&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;KurukuruのSpinnerを内包した &lt;code&gt;IProgress&amp;lt;T&amp;gt;&lt;/code&gt; を作ってあげて、その中でよしなにやってあげるということにしました。まぁちょっと長いですが、一回用意すれば後はコピペするだけなので全然いいでしょう。みなさんもこのProgressSpinner、使ってやってください。&lt;/p&gt;
&lt;h2&gt;コマンド引数やロギング処理やオプション取得&lt;/h2&gt;
&lt;p&gt;クローラーとしてガッツシやりたいなら、モードの切り替えとかロギングとか入れたいです、というか入れます。そこで私が定形として使っているのは&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt;と&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;。Cysharpの提供です。ワシが作った。それと今回のようなケースだと&lt;a href="https://github.com/Cysharp/Kokuban"&gt;Kokuban&lt;/a&gt;も便利なので入れます。やはりCysharpの提供です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;AngleSharp&amp;quot; Version=&amp;quot;1.0.0-alpha-844&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Kurukuru&amp;quot; Version=&amp;quot;1.4.0&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;ConsoleAppFramework&amp;quot; Version=&amp;quot;3.3.2&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;ZLogger&amp;quot; Version=&amp;quot;1.6.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Kokuban&amp;quot; Version=&amp;quot;0.2.0&amp;quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この場合Program.csは以下のような感じになります。割と短いですよ！&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Text;
using ZLogger;

Console.OutputEncoding = Encoding.UTF8;

await Host.CreateDefaultBuilder()
    .ConfigureLogging(x =&amp;gt;
    {
        x.ClearProviders();
        x.AddZLoggerConsole();
        x.AddZLoggerFile($&amp;quot;logs/{args[0]}-{DateTime.Now.ToString(&amp;quot;yyyMMddHHmmss&amp;quot;)}.log&amp;quot;);
    })
    .ConfigureServices((hostContext, services) =&amp;gt;
    {
        services.Configure&amp;lt;NanikaOptions&amp;gt;(hostContext.Configuration.GetSection(&amp;quot;Nanika&amp;quot;));
    })
    .RunConsoleAppFrameworkAsync(args);

public class NanikaOptions
{
    public string UserId { get; set; } = default!;
    public string Password { get; set; } = default!;
    public string SaveDirectory { get; set; } = default!;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンソールログだけだとウィンドウ閉じちゃったときにチッとかなったりするので（？）、ファイルログあると安心します。ZLoggerは秘伝のxmlコンフィグなどを用意する必要なく、これだけで有効化されるのが楽でいいところです。それでいてパフォーマンスも抜群に良いので。&lt;/p&gt;
&lt;p&gt;ConsoleAppFrameworkはGenericHostと統合されているので、コンフィグの読み込みもOptionsで行います。appsettings.jsonを用意して&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;Nanika&amp;quot;: {
    &amp;quot;UserId&amp;quot;: &amp;quot;hugahuga&amp;quot;,
    &amp;quot;Password&amp;quot;: &amp;quot;takotako&amp;quot;,
    &amp;quot;SaveDirectory&amp;quot;: &amp;quot;C:\\temp\\dir&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.csprojのほうに&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;None Update=&amp;quot;appsettings.json&amp;quot;&amp;gt;
    &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
    &amp;lt;/None&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;と書いてあげれば、自動で読み込まれるようになるという仕様です。そして本体のコードは&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class NanikaDownloader : ConsoleAppBase
{
    readonly ILogger&amp;lt;NanikaDownloader&amp;gt; logger;
    readonly NanikaOptions options;

    // コンストラクタインジェクションでOptionsを受け取る
    public NanikaDownloader(ILogger&amp;lt;NanikaDownloader&amp;gt; logger, IOptions&amp;lt;NanikaOptions&amp;gt; options)
    {
        this.logger = logger;
        this.options = options.Value;
    }

    public async Task DownloadAre()
    {
        // Context.CancellationTokenを渡すのを忘れないように！(Ctrl+Cのキャンセル対応に必須)
        await loader.FecthAsyncBytes(&amp;quot;...&amp;quot;, Context.CancellationToken)
    }

    public async Task DownloadSore(int initialPage)
    {
        // Kokubanを使うとConsoleに出す文字列の色分けが簡単にできる！( `Chalk.Color +` だけで色が付く)
        logger.LogInformation(Chalk.Green + $&amp;quot;Download sore {initialPage} start&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように書きます。これの場合は、引数で &lt;code&gt;NanikaDownloader.DownloadAre&lt;/code&gt;, &lt;code&gt;NanikaDownloader.DownloadSore -initialPage *&lt;/code&gt; の実行切り替えができるようになるわけですね……！&lt;/p&gt;
&lt;p&gt;また、文字色が一色だけだとコンソール上のログはかなり見づらいわけですが、Kokubanを使うことで色の出し分けが可能になります。これは、地味にめちゃくちゃ便利なのでおすすめ。別にバッチ系に限らず、コンソールログの色を調整するのってめっちゃ大事だと、最近実感しているところです。&lt;/p&gt;
&lt;p&gt;ASP .NET Core(とかMagicOnionとか)で、ZLoggerでエラーを赤くしたい！とか、フレームワークが吐いてくる重要でない情報はグレーにして目立たなくしたい！とかの場合は、ZLoggerのPrefix/SuffixFormatterを使うのをオススメしてます(Kokubanのようにさっくり書けはしないのですが、まぁConfigurationのところで一回やるだけなので)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;logging.AddZLoggerConsole(options =&amp;gt;
{
#if DEBUG
    // \u001b[31m =&amp;gt; Red(ANSI Escape Code)
    // \u001b[0m =&amp;gt; Reset
    // \u001b[38;5;***m =&amp;gt; 256 Colors(08 is Gray)
    options.PrefixFormatter = (writer, info) =&amp;gt;
    {
        if (info.LogLevel == LogLevel.Error)
        {
            ZString.Utf8Format(writer, &amp;quot;\u001b[31m[{0}]&amp;quot;, info.LogLevel);
        }
        else
        {
            if (!info.CategoryName.StartsWith(&amp;quot;MyApp&amp;quot;)) // your application namespace.
            {
                ZString.Utf8Format(writer, &amp;quot;\u001b[38;5;08m[{0}]&amp;quot;, info.LogLevel);
            }
            else
            {
                ZString.Utf8Format(writer, &amp;quot;[{0}]&amp;quot;, info.LogLevel);
            }
        }
    };
    options.SuffixFormatter = (writer, info) =&amp;gt;
    {
        if (info.LogLevel == LogLevel.Error || !info.CategoryName.StartsWith(&amp;quot;MyApp&amp;quot;))
        {
            ZString.Utf8Format(writer, &amp;quot;\u001b[0m&amp;quot;, &amp;quot;&amp;quot;);
        }
    };
#endif

}, configureEnableAnsiEscapeCode: true); // configureEnableAnsiEscapeCode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こういうの、地味に開発効率に響くので超大事です。やっていきましょう。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;AngleSharpにかこつけてウォッチウィンドウをとにかく紹介したかったのです！ウォッチウィンドウ最強！値の変化があると赤くなってくれたりするのも便利ですね、使いこなしていきましょう。別にUnityとかでもクソ便利ですからね？&lt;/p&gt;
&lt;p&gt;あ、で、AngleSharpはめっちゃいいと思います。他の言語のスクレピングライブラリ(Beautiful Soupとか)と比べても、全然張り合えるんじゃないかな。冒頭に書きましたがE2Eテストへの応用なども考えられるので、使いこなし覚えるのとてもいいんじゃないかと思います。ドキュメントが色々書いてあるようで実は別にほとんど大したこと書いてなくて役に立たないというのは若干問題アリなんですが、まぁ触って覚えるでもなんとかなるので、大丈夫大丈夫。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-12-04T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/11/21.html</guid>
      <link>https://neue.cc/2021/11/21.html</link>
      <title>C#による自家製静的サイトジェネレーターに移行した話</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/11/21.html"&gt;C#による自家製静的サイトジェネレーターに移行した話&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-11-21&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;見た目はほとんど変わっていませんが(とはいえ横幅広くしたので印象は結構変わったかも)、このサイト、フルリニューアルしました。内部構造が。完全に。別物に。元々はWordPressだったのですが、今回から自作の静的サイトジェネレーターでhtmlを生成し、GitHub Pagesでホストするようにしました。元になるソース(&lt;code&gt;.md&lt;/code&gt;)もGitHub上に置き、GitHub ActionsでビルドしてGitHub Pagesでホスティングされるという、完全GitHub完結ソリューション。また、記事を書くエディタも&lt;a href="https://docs.github.com/ja/codespaces/the-githubdev-web-based-editor"&gt;GitHub web-based editor&lt;/a&gt;(リポジトリのトップで&lt;code&gt;.&lt;/code&gt;を打つと、VS Codeそのものが起動するやつ)を利用することで、非常に快適で、というかMarkdownエディタとしては最高品質のものが乗っかっていて、たかがブログ書くにしては面倒くさいPush/Pullもなくダイレクトコミットで反映出来てしまうというのがとても良い体験になっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/neuecc/Blog2/"&gt;neuecc/Blog2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt;でエディタを起動して、&lt;a href="https://github.com/neuecc/Blog2/tree/master/articles"&gt;articles&lt;/a&gt;配下に&lt;code&gt;YYYY-MM-DD.md&lt;/code&gt;ファイルを新規作成。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/142737666-ec09db39-d517-4fb9-aa9f-b61bfb2cbfe7.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;完全にVS Codeそのものでデスクトップアプリのものと全く区別が付かないレベルで、これを超える品質のエディタを普通のサイトに乗せることは不可能でしょう。当然もちろん画像のプレビューもできますし、なんだったら拡張すら入る。&lt;/p&gt;
&lt;p&gt;GitHub管理だと画像置き場（アップロード）が面倒くさい問題があるのですが、これはIssueを画像アップローダーとして使うことで回避しています。Issueの入力フォームは、画像をCtrl+Vでそのままアップロードが可能です。そして嬉しいことに、マークダウンに変換してくれているのでコピペするだけでOK。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/142736683-d2b2acac-8523-4f54-a325-c1dbb12aa959.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/142736700-18928390-e53b-4014-a931-9cd974afcf56.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;上がった先の&lt;code&gt;user-images.githubusercontent&lt;/code&gt;は別にIssueそのものと紐付いているわけではないので、 アップローダ用に使ったIssueはSubmitすることなくポイ、です。そうしてどこにも紐付いていない&lt;code&gt;user-images.githubusercontent&lt;/code&gt;ですが、別にだからといって削除されることもなく永続的に上がり続けているので、遠慮なく使わせてもらうことにします。まぁちゃんとGitHub上に上げてるコンテンツ用に使っているので、許されるでしょう、きっと。多分。&lt;/p&gt;
&lt;p&gt;そうして出来上がった記事は、そのままエディタ上のgit UIからコミットすると、自身が作業している領域は直接サーバー上のmaster(main)なので、プッシュ不要で反映されます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/142736833-55f36246-cb7f-4b62-addf-0e18b3fa6d07.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;こうなると、もうWordPressで投稿をポスト、するのと変わらないわけです。ブログ記事程度でcloneしてpullしてstagingしてpushしてというのは地味に重たいので、このぐらい身軽で行きたいですね。（実際、投稿後に編集ラッシュとかよくあるので、ちょっと手数が増えるだけで猛烈に嫌気がさす）&lt;/p&gt;
&lt;p&gt;ジェネレートは&lt;a href="https://github.com/neuecc/Blog2/blob/master/.github/workflows/build.yml"&gt;workflows/buildy.yml&lt;/a&gt;で、このリポジトリ内に配置されてるC#プロジェクトを直接ビルド/実行することで生成処理をしています。&lt;code&gt;dotnet run&lt;/code&gt;便利。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;build-blog:
runs-on: ubuntu-latest
steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.x
    - run: dotnet run --project ./src/Blog2/Blog2.csproj -c Release -- ./articles ./publish
    - uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./publish
        keep_files: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成されたファイルは&lt;a href="https://github.com/peaceiris/actions-gh-pages"&gt;peaceiris/actions-gh-pages&lt;/a&gt;を使って&lt;code&gt;gh-pages&lt;/code&gt;ブランチと同期します。その際、デフォルトでは既に上がってるファイルを全削除してしまうので、今回はstyleやassetを、同期とは別に置いてあるので削除されると困るので、&lt;code&gt;keep_files: true&lt;/code&gt;も指定しています。そうすると記事の削除がしづらくなるんですが、記事の削除はしない or どうしても削除しなかったら二重に(articlesとgh-pages)削除すればいいだけ、という運用で回避。&lt;/p&gt;
&lt;p&gt;と、いうわけでシステム的には満足です。&lt;/p&gt;
&lt;p&gt;C#でも&lt;a href="https://www.statiq.dev/"&gt;Statiq&lt;/a&gt;などといった静的サイトジェネレーターは存在するのですが、あえて自作した理由は、サイトのシステムをそっくり移行するという都合上、URLを前のものと完璧に合わせたかったというのがあります。&lt;a href="https://github.com/neuecc/Blog2/tree/gh-pages"&gt;生成結果のファイル一覧&lt;/a&gt;が若干変というかクドいというか、といったところがあるのですが、これは前のWordPressでやっていたルーティングをそのまんま再現するためということで。WordPressからのエクスポートも、DB直接見てC#でそのままテーブルダンプから作ったので、まぁ別に大したコードが必要なわけでもないので一気に作っちゃえという気になったというのもあります。&lt;/p&gt;
&lt;p&gt;外部ライブラリとしてはMarkdownのHTML化に&lt;a href="https://github.com/xoofx/markdig"&gt;Markdig&lt;/a&gt;を採用しました。色々高機能ではあるのですが、今回は &lt;code&gt;Markdown.ToHtml(input)&lt;/code&gt; しか使っていませんけれど、感触的にはとても良かったです。&lt;/p&gt;
&lt;p&gt;シンタックスハイライトには&lt;a href="https://prismjs.com/"&gt;Prism.js&lt;/a&gt;を用いました。Markdigの出力する```csharpの変換を、特に何も意識せずとも対象にしてくれるのが良かったですね。プラグインはautoloaderとnormalize-whitespaceを合わせて投下しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;script src=&amp;quot;&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;最近ブログ投稿がだいぶ減ってしまっていたのですが、システムも一新したことでやる気が出てきたのでいいことです。まぁ見た目は本当にあんま全然変わってないんですが……！&lt;/p&gt;
&lt;p&gt;なお、反映に必要な所要時間は30秒弱。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/142737556-eac40d7a-46c8-4534-96de-38895104d4cb.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;遅いっちゃあ遅いですが、許容できるといえば許容できますね。サイトジェネレートプログラムの実行時間自体は1秒以下で、別に全然時間かかってないんで、CIセットアップとか、それ以外の時間が何かとかかっちゃってます。GitHub Actionsの仕組み的にしょうがないといえばしょうがないんですが、もう少しなんとかなってほしいかなあ。あとGitHub Pages自体が反映が若干遅い。遅い上に進捗が分からないのが地味にストレスフル。とはいえとはいえ、良いんじゃあないでしょうか。良さの殆どはGitHub web-based editorから来てますね、これは本当に革命的に良い。というわけで、このweb-based editorを活かすシステムを作っていくという手段と目的を逆転させた思考が最終的に実際良いんじゃないかと思ってます！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-11-21T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2021/08/23_602.html</guid>
      <link>https://neue.cc/2021/08/23_602.html</link>
      <title>C#でgoogle/zx風にシェルスクリプトを書く</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2021/08/23_602.html"&gt;C#でgoogle/zx風にシェルスクリプトを書く&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2021-08-23&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;あまりシェルスクリプトを書かない私なのですが（小物でもなんでも書き捨てC#で書くスタイル）、CI だの .NET Core だのなんなので、全く書かないというわけにもいかない昨今です。まぁしかしcmdは嫌だし今更(？)PowerShellもなぁという感じもあり、bashねぇ、とかブツブツ言いながらしょっぱいスクリプトを書く羽目になるわけです。&lt;/p&gt;
&lt;p&gt;そこに颯爽と現れたのが &lt;a href="https://github.com/google/zx"&gt;google/zx&lt;/a&gt;。素敵そうだなーと思いつつJavaScriptを日常的に書くわけでもないのでスルーしてたのですが、こないだも&lt;a href="https://scrapbox.io/lacolaco-engineering/%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E8%A4%87%E9%9B%91%E3%81%AA%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92JavaScript%E3%81%A7%E6%9B%B8%E3%81%8F"&gt;ちょっと複雑なシェルスクリプトをJavaScriptで書く&lt;/a&gt;で紹介されていて、なるほど色物じゃなくて便利なのか、そうだよね便利だよね！と思い、私は日常的にC#を書くので、C#だったら便利だな、同じ感じで書けるなら、と、思い至ったのでした。&lt;/p&gt;
&lt;p&gt;というかまぁzx見て思ったのが、これぐらいの内部DSL、C#でもいけるよ、ということであり……。そして以下のようなものが誕生しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/130373766-0f16e9ad-57ba-446b-81ee-c255c7149035.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;もともと&lt;a href="http://neue.cc/2020/01/30_590.html"&gt;ProcessX - C#でProcessを C# 8.0非同期ストリームで簡単に扱うライブラリ&lt;/a&gt;というものを公開していたので、更にそれをDSL風味に、zxっぽくシンタックスを弄りました。C# 5.0 async/awaitの拡張性、C# 6.0 using static、C# 6.0 String Interpolation、そしてC# 9.0のTop level statementsと、C#も内部DSLを容易にする構文がどんどん足されています。現在previewのC# 10.0でも、Improvement Interpolated Stringsとして、InterpolatedStringHandlerによって$&amp;quot;&amp;quot;の生成時の挙動そのものを生で弄ることが可能になり、よりますます表現のハックが可能になり、色々と期待が持てます。&lt;/p&gt;
&lt;p&gt;さて、で、これが使いやすいかというと、見た通りで、使いやすい、です……！stringをawaitしていることに一瞬違和感はめちゃくちゃあるでしょうが、DSLだと思って慣れれば全然自然です（そうか？）。なんか言われてもgoogle/zxなもんです、で逃げれば説得力マシマシになった（そうか？）のが最高ですね。cmd/PowerShell/bashに対する利点は、google/zxの利点と同じように&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型が効いてる(C#なので)&lt;/li&gt;
&lt;li&gt;async/awaitが便利(C#なので)&lt;/li&gt;
&lt;li&gt;フォーマッタもある(C#なので)&lt;/li&gt;
&lt;li&gt;エディタ支援が最高(C#なので)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ということで、ぜひぜひお試しください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ProcessX"&gt;https://github.com/Cysharp/ProcessX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PM&amp;gt; Install-Package ProcessX&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;csx vs new csproj vs ConsoleAppFramework&lt;/h2&gt;
&lt;p&gt;C#には.csxという失われしC#スクリプティングな構文が用意されていて、まさに1ファイルでC#の実行が完結するのでこうしたシェルスクリプト風味に最適、と思いきや、実行もエディッティング環境も貧弱で、まさに失われしテクノロジーになっているので、見なかったことにしておきましょう。実際、より良いC#スクリプティング的なシンプルC#の提案が &lt;a href="https://github.com/dotnet/designs/pull/213"&gt;Add Simple C# Programs&lt;/a&gt; として出ています(つまりcsxは完全に産廃、NO FUTURE……)。提案(&lt;a href="https://github.com/dotnet/designs/blob/a27fd42a68370f315bc2293dc748145f4075697f/proposed/simple-csharp-programs.md"&gt;proposed/simple-csharp-pgorams.md&lt;/a&gt;)読むと面白いですが、ちょっと少し時間かかりそうですね。&lt;/p&gt;
&lt;p&gt;というわけで、csprojとProgram.csの2ファイル構成が良いんじゃないかと思います。ちょっと冗長ではあるけれど、しょーがないね。実行に関しては dotnet run でビルドと実行がその場でできるので、ビルドなしの直接スクリプト実行みたいな雰囲気にはできます。これは普通に便利で、CIとかでもgit pullしている状態のリポジトリ内のスクリプトに対して一行でdotnet run書くだけで動かせるので、非常に良い。こうした .NET Core以降のシンプルになったcsprojとdotnetコマンドの充実から、csxの価値がどんどん消えていったんですねえ。&lt;/p&gt;
&lt;p&gt;さて、実際のプロジェクトなどでは、そもそもシェルスクリプト（に限らずバッチなんかも）は一つどころか大量にあったりすることもあるでしょう。そこでCysharpの提供している&lt;a href="https://github.com/Cysharp/ConsoleAppFramework/"&gt;Cysharp/ConsoleAppFramework&lt;/a&gt;を使うと、クラスを定義するだけで簡単に実行対象を増やしていけるので、大量のスクリプトの管理を1csprojでまかなうことが可能になります。実行は dotnet run -- foo/bar のようにすればいいだけです。非常におすすめ。シェルスクリプト的なものは、ConsoleAppFramework + ProcessX/zx で書いて回るのは、悪くない選択になると思います。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0900</pubDate>
      <a10:updated>2021-08-23T00:00:00+09:00</a10:updated>
    </item>
  </channel>
</rss>