<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>neue cc</title>
    <link>http://neue.cc/</link>
    <description>C# Technical Blog</description>
    <language>ja</language>
    <lastBuildDate>Fri, 20 Dec 2024 18:30:08 +0900</lastBuildDate>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/20_mastermemory_v3.html</guid>
      <link>https://neue.cc/2024/12/20_mastermemory_v3.html</link>
      <title>MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-20" data-pagefind-meta="published:2024-12-20"&gt;&lt;a href="https://neue.cc/2024/12/20_mastermemory_v3.html"&gt;MasterMemory v3 - Source Generator化したC#用の高速な読み込み専用インメモリデータベース&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-20&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/MasterMemory"&gt;MasterMemory&lt;/a&gt; v3出しました！ついにSource Generator化されました！&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/e804fa52-f6a5-4972-a510-0b3b17a31230" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;MasterMemoryはC#のインメモリデータベースで、高速で、メモリ消費量が少なく、タイプセーフ。というライブラリです。SQLiteを素朴に使うよりも &lt;em&gt;4700&lt;/em&gt;倍高速だぞ、と。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61031896-61890800-a3fb-11e9-86b7-84c821d347a4.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;もともとMasterMemoryはC#コードからC#コードを生成するという先進的な設計思想を持ったシステムだったため、Source Generatorとの親和性は高いものでした。今回移植してみて、あまりにもスムーズに移植できるし、旧来のコードも全く手を付けずにそのまま動いたので我ながら感心しました。やっと時代が追い付いたか……。&lt;/p&gt;
&lt;p&gt;というわけで、以下のようなC#定義からデータベース構築のためのコードと、クエリ部分がSource Generatorによって自動生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MemoryTable(&amp;quot;person&amp;quot;), MessagePackObject(true)]
public record Person
{
    [PrimaryKey]
    public required int PersonId { get; init; }
    
    [SecondaryKey(0), NonUnique]
    [SecondaryKey(1, keyOrder: 1), NonUnique]
    public required int Age { get; init; }

    [SecondaryKey(2), NonUnique]
    [SecondaryKey(1, keyOrder: 0), NonUnique]
    public required Gender Gender { get; init; }

    public required string Name { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/61035808-cb58e000-a402-11e9-9209-d51665d1cd56.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;C#コードとして生成されるので、クエリが全て入力補完も効くし戻り値も型付けされていてタイプセーフなのはもちろん、パフォーマンスの良さにも寄与しています。&lt;/p&gt;
&lt;p&gt;読み取り専用データベースとして使うので、クラス定義はイミュータブルのほうがいいわけですが、最近のC#は &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;required&lt;/code&gt; といった機能が提供されているので、Readonly Databaseとしての使い勝手が更に上がりました。Unityでは&lt;code&gt;required&lt;/code&gt;は使えませんが&lt;code&gt;record&lt;/code&gt;と&lt;code&gt;init&lt;/code&gt;は使えるので、Unityでも問題ありません。&lt;/p&gt;
&lt;p&gt;なお、Unity版は今回からNuGetForUnityでの提供となります。また、MessagePack for C#もSource Generator対応のv3を要求します。&lt;/p&gt;
&lt;h2&gt;Next&lt;/h2&gt;
&lt;p&gt;MasterMemory、実は結構使われています。ゲームでも採用されているものを割と見かけるようになりました。なので、外部ツール由来のコード生成の面倒さにはだいぶ心を痛めていたので、ようやく解消できて本当に嬉しい！&lt;/p&gt;
&lt;p&gt;v2からv3へのマイグレーションもそんなに大変ではない、はずです。あえて生成コードの品質や、コアの関数、メソッドシグネチャなどには一切手を加えていないので、今までコマンドラインツールを叩いていた部分を削除するだけで、そのまま動き出すぐらいの代物になっています。名前空間の設定だけ、アセンブリ属性で行ってください。&lt;/p&gt;
&lt;p&gt;そのうえでrecord対応（今までしてなかった！）や#nullable enable対応（今までしてなかった！）を追加しているので、生成部分以外の使い勝手も上がっているはずです。&lt;/p&gt;
&lt;p&gt;今後は&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;対応や、そもそものAPIの更なるモダン化（現状はnetstandard2.0なので古い）、全体的に改修したいところ(ImmutableBuilderなど生成コードの差し替え部分)、などなどやれること自体はめっちゃありますので、折を見て手を入れていけるといいかなあ、と思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 20 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-20T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</guid>
      <link>https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html</link>
      <title>ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-16" data-pagefind-meta="published:2024-12-16"&gt;&lt;a href="https://neue.cc/2024/12/16_ConsoleAppFramewrok_v5_3_0.html"&gt;ConsoleAppFramework v5.3.0 - NuGet参照状況からのメソッド自動生成によるDI統合の強化、など&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-16&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt; v5の比較的アップデートをしました！v5自体の詳細は以前に書いた&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;を参照ください。v5はかなり面白いコンセプトになっていて、そして支持されたと思っているのですが、幾つか使い勝手を犠牲にした点があったので、今回それらをケアしました。というわけで使い勝手がかなり上がった、と思います……！&lt;/p&gt;
&lt;h2&gt;名前の自動変換を無効にする&lt;/h2&gt;
&lt;p&gt;コマンドネームとオプションネームは、デフォルトでは自動的にkebab-caseに変換されます。これはコマンドラインツールの標準的な命名規則に従うものですが、内部アプリケーションで使うバッチファイルの作成に使ったりする場合などには、変換されるほうが煩わしく感じるかもしれません。そこで、アセンブリ単位でオフにする機能を今回追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;

[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]

var app = ConsoleApp.Create();
app.Add&amp;lt;MyProjectCommand&amp;gt;();
app.Run(args);

public class MyProjectCommand
{
    public void Execute(string fooBarBaz)
    {
        Console.WriteLine(fooBarBaz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]&lt;/code&gt;によって自動変換が無効になります。この例では &lt;code&gt;ExecuteCommand --fooBarBaz&lt;/code&gt; がコマンドとなります。&lt;/p&gt;
&lt;p&gt;実装面でいうと、Source Generatorにコンフィグを与えるのはAdditionalFilesにjsonや独自書式のファイル(例えばBannedApiAnalyzersのBannedSymbols.txt)を置くパターンが多いですが、ファイルを使うのは結構手間が多くて面倒なんですよね。boolの1つや2つを設定するぐらいなら、アセンブリ属性を使うのが一番楽だと思います。&lt;/p&gt;
&lt;p&gt;実装手法としては&lt;code&gt;CompilationProvider&lt;/code&gt;から&lt;code&gt;Assembly.GetAttributes&lt;/code&gt;で引っ張ってこれます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var generatorOptions = context.CompilationProvider.Select((compilation, token) =&amp;gt;
{
    foreach (var attr in compilation.Assembly.GetAttributes())
    {
        if (attr.AttributeClass?.Name == &amp;quot;ConsoleAppFrameworkGeneratorOptionsAttribute&amp;quot;)
        {
            var args = attr.NamedArguments;
            var disableNamingConversion = args.FirstOrDefault(x =&amp;gt; x.Key == &amp;quot;DisableNamingConversion&amp;quot;).Value.Value as bool? ?? false;
            return new ConsoleAppFrameworkGeneratorOptions(disableNamingConversion);
        }
    }

    return new ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion: false);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを他のSyntaxProviderからのSourceとCombineしてやれば、生成時に属性の値を参照できるようになります。&lt;/p&gt;
&lt;h2&gt;ConfigureServices/ConfigureLogging/ConfigureConfiguration&lt;/h2&gt;
&lt;p&gt;ゼロディペンデンシーを掲げている都合上、特定のライブラリに依存したコードを生成することができないという制約がConsoleAppFramework v5にはありました。そのため、DIとの統合時に自分でServiceProviderをビルドしなければならないなの、利用には一手間必要でした。そこで、NuGetでのDLLの参照状況を解析し、&lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;が参照されていると、&lt;code&gt;ConfigureServices&lt;/code&gt;メソッドが&lt;code&gt;ConsoleAppBuilder&lt;/code&gt;から使えるという実装を追加しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create()
    .ConfigureServices(service =&amp;gt;
    {
        service.AddTransient&amp;lt;MyService&amp;gt;();
    });

app.Add(&amp;quot;&amp;quot;, ([FromServices] MyService service, int x, int y) =&amp;gt; Console.WriteLine(x + y));

app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりフレームワークそのものはゼロディペンデンシーでありながら、ライブラリ依存のコードも生成することができるという、新しい体験を提供します。これは&lt;code&gt;MetadataReferencesProvider&lt;/code&gt;から引っ張ってきて生成処理に回すことで実現しました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var hasDependencyInjection = context.MetadataReferencesProvider
    .Collect()
    .Select((xs, _) =&amp;gt;
    {
        var hasDependencyInjection = false;

        foreach (var x in xs)
        {
            var name = x.Display;
            if (name == null) continue;

            if (!hasDependencyInjection &amp;amp;&amp;amp; name.EndsWith(&amp;quot;Microsoft.Extensions.DependencyInjection.dll&amp;quot;))
            {
                hasDependencyInjection = true;
                continue;
            }

            // etc...
        }

        return new DllReference(hasDependencyInjection, hasLogging, hasConfiguration, hasJsonConfiguration, hasHost);
    });

context.RegisterSourceOutput(hasDependencyInjection, EmitConsoleAppConfigure);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参照の解析は複数のものに対して行っていて、他にも&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt;が参照されていれば&lt;code&gt;ConfigureLogging&lt;/code&gt;が使えるようになります。なので&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;と組み合わせれば&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: ZLogger
var app = ConsoleApp.Create()
    .ConfigureLogging(x =&amp;gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&amp;quot;log.txt&amp;quot;);
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject logger to constructor
public class MyCommand(ILogger&amp;lt;MyCommand&amp;gt; logger)
{
    public void Echo(string msg)
    {
        logger.ZLogInformation($&amp;quot;Message is {msg}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように、比較的すっきりと設定が統合できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appsettings.json&lt;/code&gt;から設定ファイルを引っ張ってくるというのも最近では定番パターンですが、これも&lt;code&gt;Microsoft.Extensions.Configuration.Json&lt;/code&gt;を参照していると&lt;code&gt;ConfigureDefaultConfiguration&lt;/code&gt;が使えるようになり、これは&lt;code&gt;SetBasePath(System.IO.Directory.GetCurrentDirectory())&lt;/code&gt;と&lt;code&gt;AddJsonFile(&amp;quot;appsettings.json&amp;quot;, optional: true)&lt;/code&gt;を自動的に行います（追加でActionでconfigureすることも可能、また、ConfigureEmptyConfigurationもあります）。&lt;/p&gt;
&lt;p&gt;なのでコンフィグを読み込んでクラスにバインドしてコマンドにDIで渡す、などといった処理もシンプルに書けるようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Configuration.Json
var app = ConsoleApp.Create()
    .ConfigureDefaultConfiguration()
    .ConfigureServices((configuration, services) =&amp;gt;
    {
        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions
        services.Configure&amp;lt;PositionOptions&amp;gt;(configuration.GetSection(&amp;quot;Position&amp;quot;));
    });

app.Add&amp;lt;MyCommand&amp;gt;();
app.Run(args);

// inject options
public class MyCommand(IOptions&amp;lt;PositionOptions&amp;gt; options)
{
    public void Echo(string msg)
    {
        ConsoleApp.Log($&amp;quot;Binded Option: {options.Value.Title} {options.Value.Name}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt;でビルドしたい場合は、&lt;code&gt;ToConsoleAppBuilder&lt;/code&gt;が、これも&lt;code&gt;Microsoft.Externsions.Hosting&lt;/code&gt;を参照すると追加されるようになっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Package Import: Microsoft.Extensions.Hosting
var app = Host.CreateApplicationBuilder()
    .ToConsoleAppBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、今回から設定されている&lt;code&gt;IServiceProvider&lt;/code&gt;は&lt;code&gt;Run&lt;/code&gt;または&lt;code&gt;RunAsync&lt;/code&gt;終了後に自動的にDisposeするようになりました。&lt;/p&gt;
&lt;h2&gt;RegisterCommands from Attribute&lt;/h2&gt;
&lt;p&gt;コマンドの追加は&lt;code&gt;Add&lt;/code&gt;または&lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;が必要でしたが、クラスに属性を付与することで自動的に追加される機能をいれました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands]
public class Foo
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}

[RegisterCommands(&amp;quot;bar&amp;quot;)]
public class Bar
{
    public void Baz(int x)
    {
        Console.Write(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらは自動で追加されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create();

// Commands:
//   baz
//   bar baz
app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらとは別に追加で&lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Add&amp;lt;T&amp;gt;&lt;/code&gt;することも可能です。&lt;/p&gt;
&lt;p&gt;なお、実装の当初予定では任意の属性を使えるようにする予定だったのですが、&lt;code&gt;IncrementalGenerator&lt;/code&gt;のAPIの都合上難しくて、固定の&lt;code&gt;RegisterCommands&lt;/code&gt;属性のみを対象としています。また、継承することもできません……。なので独自の処理用属性がある場合は、組み合わせてもらう必要があります。例えば以下のように。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[RegisterCommands, Batch(&amp;quot;0 10 * * *&amp;quot;)]
public class MyCommands
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この辺は&lt;a href="https://qiita.com/omt_teruki/items/dae315c7e86722fe05e6"&gt;ConsoleAppFrameworkとAWS CDKで爆速バッチ開発&lt;/a&gt;を読んで、うーん、v5を使ってもらいたい！なんとかしたい！と思って色々考えたのですが、この辺が現状の限界でした……。名前変換オフりたいのもわかるー、とか今回の更新内容はこの記事での利用例を参考にさせていただきました、ありがとうございます！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;v5のリリース以降もフィルターを外部アセンブリに定義できるようになったり、Incremental Generatorの実装を見直して高速化するなど、Improvmentは続いています！非常に良いフレームワークに仕上がってきました！&lt;/p&gt;
&lt;p&gt;ところで&lt;a href="https://github.com/dotnet/command-line-api/"&gt;System.CommandLine&lt;/a&gt;、現状うまくいってないから&lt;a href="https://github.com/dotnet/command-line-api/issues/2338"&gt;Resettting System.CommandLine&lt;/a&gt;だ！と言ったのが今年の3月。例によって想像通り進捗は無です。知ってた。そうなると思ってた。何も期待しないほうがいいし、普通にConsoleAppFramework使っていくで良いでしょう。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-16T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/06_MessagePack_v3.html</guid>
      <link>https://neue.cc/2024/12/06_MessagePack_v3.html</link>
      <title>SourceGenerator対応のMessagePack for C# v3リリースと今後について</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-06" data-pagefind-meta="published:2024-12-06"&gt;&lt;a href="https://neue.cc/2024/12/06_MessagePack_v3.html"&gt;SourceGenerator対応のMessagePack for C# v3リリースと今後について&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-06&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;先月&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#プロジェクト&lt;/a&gt;は &lt;a href="https://dotnetfoundation.org/"&gt;.NET Foundation&lt;/a&gt;に参加しました！より安定した視点で利用していただけるという一助になればいいと思っています。&lt;/p&gt;
&lt;p&gt;そして、長く開発を続けていたメジャーバージョンアップ、v3がリリースされました。コア部分はv2とはほぼ変わらずですが、Source Generatorを全面的に導入しています。引き続きIL動的生成も存在するため、IL動的生成とSource Generatorのハイブリッドなシリアライザーとなります。v3にはSource GeneratorとAnalyzerがビルトインで同梱されていて、今までのコードはv3でコンパイルするだけで自動的にSource Generator化されます。v2 -&amp;gt; v3アップデートでSource Generator対応するために追加でユーザーがコードを記述する必要はありません！&lt;/p&gt;
&lt;p&gt;挙動を詳しく見ていきましょう。例えば、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MyTestClass
{
    [Key(0)]
    public int MyProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というコードを書くと、自動的に以下のコードがSource Generatorによって内部的に生成されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial class GeneratedMessagePackResolver
{
    internal sealed class MyTestClassFormatter : IMessagePackFormatter&amp;lt;MyTestClass&amp;gt;
    {
        public void Serialize(ref MessagePackWriter writer, MyTestClass value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(1);
            writer.Write(value.MyProperty);
        }

        public MyTestClass Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var ____result = new MyTestClass();

            for (int i = 0; i &amp;lt; length; i++)
            {
                switch (i)
                {
                    case 0:
                        ____result.MyProperty = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            reader.Depth--;
            return ____result;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、このGeneratedMessagePackResolverはデフォルトのオプション(StandardResolverなど)に最初から登録されているため、&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static readonly IFormatterResolver[] DefaultResolvers = [
    BuiltinResolver.Instance,
    AttributeFormatterResolver.Instance,
    SourceGeneratedFormatterResolver.Instance, // here
    ImmutableCollection.ImmutableCollectionResolver.Instance,
    CompositeResolver.Create(ExpandoObjectFormatter.Instance),
    DynamicGenericResolver.Instance, // only enable for RuntimeFeature.IsDynamicCodeSupported
    DynamicUnionResolver.Instance];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザーコードのアセンブリに含まれているシリアライズ対象クラスは、Source Generatorによって生成されたコードが優先的に使われることになります。GeneratedMessagePackResolverは既定の名前空間や名前を変えたり、生成フォーマッターをmapベースに変更するなど、幾つかのカスタマイズポイントも用意されています。より詳しくは新しいドキュメントを見てください。また、v2 -&amp;gt; v3の変更箇所の詳細を知りたい人は&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/develop/doc/migrating_v2-v3.md"&gt;Migration Guide v2 -&amp;gt; v3&lt;/a&gt;をチェックしてください。&lt;/p&gt;
&lt;p&gt;Unityにおいては導入方法が大きく変わりました。コアライブラリは .NET 版と共通になりNuGetからのインストールが必要となります。そのうえでUPMでUnity用の追加コードをダウンロードする必要があります。詳しくは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/#unity-support"&gt;MessagePack-CSharp#unity-support&lt;/a&gt;のセクションを確認してください。&lt;/p&gt;
&lt;p&gt;.unitypackageの提供は廃止されています。また、IL2CPP対応のために要求していたmpcはなくなりました。完全にSource Generatorに移行されます。そのため、Unityのサポートバージョンは &lt;code&gt;2022.3.12f1&lt;/code&gt; からとなります。Source Generatorに関してはNuGetForUnityでのコアライブラリインストール時に自動的に有効化されるため、追加の作業は必要ありません。&lt;/p&gt;
&lt;h2&gt;History and Next&lt;/h2&gt;
&lt;p&gt;MessagePack for C#のオリジナル(v1)は私(Yoshifumi Kawai/@neuecc)によって、2017年にリリースしました。当時開発していたゲームのパフォーマンス問題を解決するために、2016年時点で存在していた(バイナリ)シリアライザーでは需要を満たせなかったため、パフォーマンスを最重要視したバイナリシリアライザーとして作成しました。合わせて、同じくネットワークシステムとして作成したgRPCベースのRPCフレームワーク&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;もリリースしています。&lt;/p&gt;
&lt;p&gt;v1リリース当時は&lt;code&gt;byte[]&lt;/code&gt;のみを対象としていましたが、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt;など、.NETには次々と新しいI/O系のAPIが追加されていったため、v2ではそれらに焦点を当てた新しいデザインが導入されました。この実装はMicrosoftのEngineerである&lt;a href="https://github.com/AArnott"&gt;Andrew Arnott / @AArnott&lt;/a&gt;氏によって主導され、リリースしています。&lt;/p&gt;
&lt;p&gt;以降、共同のメンテナンス体制として、そして私の個人リポジトリ(neuecc/MessagePack-CSharp)からオーガナイゼーション(MessagePack-CSharp/MessagePack-CSharp)して今に至ります。Visual Studio内部での利用や&lt;a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol"&gt;SignalRのバイナリープロトコル&lt;/a&gt;、Blazor Serverのプロトコルなど大きなMicrosoftのプロダクトでも使用され、GitHubでのスター数は.NETのバイナリーシリアライザーとしては最も大きなスターを集めています。&lt;a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-migration-guide/"&gt;.NET 9で廃止されたBinaryFormatter&lt;/a&gt;の移行先の一つとしても推奨されています。&lt;/p&gt;
&lt;p&gt;v3ではSource Generatorに対応することで、より高いパフォーマンスと柔軟性、AOT対応への第一段階に踏み出すことができました。&lt;/p&gt;
&lt;p&gt;MessagePack for C#プロジェクトは大きな成功を収めたと考えていますが、しかし現在、AArnott氏は個人の新しいMessagePackプロジェクトの開発を開始しています。私もその間、&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;という異なるフォーマットのシリアライザーをリリースしています。そのため、MessagePack for C#の今後と、その特性について、ある程度説明する必要があると思います。&lt;/p&gt;
&lt;p&gt;引き続きメンテナンス体制は2人だと考えていますが、アクティブな活動に関しては、再び私が担うことになるかもしれません。私はMessagePackとMemoryPackとでは異なる性質を持ったフォーマットであるため、どちらも重要であるという認識で動いています。オリジナルの実装であるMessagePack for C#も気に入ってますし、現在においても決して引けを取ることのないものだと思っています。&lt;/p&gt;
&lt;p&gt;AArnott氏の別のMessagePackシリアライザーとは根本的な哲学が若干異なります。その点で、私はそれはより良く改善されたシリアライザーではなく、別の個性のシリアライザーだと認識しています。そこで、違いについて説明させてください。&lt;/p&gt;
&lt;h2&gt;Binary spec, default settings and performance&lt;/h2&gt;
&lt;p&gt;シリアライザーのパフォーマンスに重要なのは、「仕様と実装」の両方です。例えばテキストフォーマットのJSONよりもバイナリフォーマットのほうが一般的には速いでしょう。しかし、よくできたJSONシリアライザーは、中途半端な実装のバイナリシリアライザーよりも高速です（私はそれを&lt;a href="https://github.com/neuecc/Utf8Json"&gt;Utf8Json&lt;/a&gt;というシリアライザーを作成することで実証したことがあります）。なので、仕様も大事だし、実装も大事です。どちらも兼ねることができれば、それがベストなパフォーマンスのシリアライザーとなります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://msgpack.org/"&gt;MessagePackのバイナリ仕様&lt;/a&gt;は &amp;quot;It's like JSON. but fast and small.&amp;quot; を標語にしている通り、JSONのバイナリ化としてあらわされています。ところが、MessagePack for C#のデフォルトは必ずしもJSON likeを狙っているわけではありません。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject]
public class MsgPackSchema
{
    [Key(0)]
    public bool Compact { get; set; }
    [Key(1)]
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このクラスをシリアライズした場合は、JSONで表現すると&lt;code&gt;[true, 0]&lt;/code&gt;のようになります。これはオブジェクトをarrayベースでシリアライズしているからで、mapベースでシリアライズすると&lt;code&gt;{&amp;quot;Compact&amp;quot;:true,&amp;quot;Schema&amp;quot;:0}&lt;/code&gt;のような表現になります。&lt;/p&gt;
&lt;p&gt;arrayベースの利点は見た通りに、バイナリ容量として、よりコンパクトになります。容量がコンパクトなことは処理量が少なくなるためシリアライズの速度にも良い影響を与えます。また、デシリアライズにおいては、文字列を比較してデシリアライズするプロパティを探索する必要がなくなるため、より高速なデシリアライズ速度が期待できます。&lt;/p&gt;
&lt;p&gt;なお、arrayベースのシリアライズはMessagePackの仕様策定者である Sadayuki Furuhashi 氏によるリファレンス実装であるmsgpack-javaなどでも採用されているため、決して異端のやり方というわけではありません。&lt;/p&gt;
&lt;p&gt;MessagePack-CSharpではJSONライクなmapベースでシリアライズしたい場合は&lt;code&gt;[MessagePackObject(true)]&lt;/code&gt;と記述することができます。また、Source Generatorの場合はResolver単位でオーバーライドして強制的にmapベースにすることも可能です。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;[MessagePackObject(keyAsPropertyName: true)]
public class MsgPackSchema
{
    public bool Compact { get; set; }
    public int Schema { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapの利点は、柔軟なスキーマエボリューションの実現と、他言語との疎通する際にコミュニケーションが取りやすいこと、バイナリそのものの自己記述性が高いことです。デメリットは容量とパフォーマンスへの悪影響、特にオブジェクトの配列においては一要素毎にプロパティ名が含まれることになってしまい、かなりの無駄となります。&lt;/p&gt;
&lt;p&gt;デフォルトをarrayにしているのは、コンパクトさとパフォーマンスの追求のためです。私はMessagePackをJSON likeの前に、高いパフォーマンスを実現可能なバイナリ仕様として考えました。もちろん、mapも重要なので、その上で比較的簡単にmapモードを実現するために属性に&lt;code&gt;(true)&lt;/code&gt;を追加するだけで可能にしました。&lt;/p&gt;
&lt;p&gt;arrayモードの場合はKey属性を全てのプロパティに付与する必要があります。これは、例えばProtocol Buffersなどでも数値タグを必要とするように、プロパティ名そのものをキーとするわけではなければ、必須だと考えています。もちろん、連番で自動採番させることも可能ですが、バイナリフォーマットのキーを暗黙的に処理するのはリスクが大きすぎる(順番を弄ったりするだけでバイナリ互換性が壊れることになる)と判断しています。つまり、明示的がデフォルト、ということです。大きなプロジェクト開発ではシニアメンバーからジュニアメンバーまでコードを触ることになるでしょう、全てを理解している人だけがコードを触るわけではありません。なので、暗黙的な挙動は避けるべきで、明示的にすべきだという強い意志で、この設計を選んでいます。&lt;/p&gt;
&lt;p&gt;ただしKeyを全てのプロパティに付与する作業はとても苦痛です(私はMessagePack-CSharp開発以前には、DataContractやprotobuf-netで辛い思いをしました)。そこで、Analyzer + Code Fixによって、自動的に付与する機能を用意しました。これにより明示的であることの苦痛は和らげられ、良いとこどりができているのだと考えています。&lt;/p&gt;
&lt;p&gt;別のMessagePackシリアライザーのデフォルトはmapのようです。これは&lt;a href="https://github.com/eiriktsarpalis/PolyType"&gt;PolyType&lt;/a&gt;というSource Generatorベースのライブラリ作成のための抽象化ライブラリがベースとしているためでもあり、また、そちらのほうを好んでいるという明示的な判断でもあるようです。&lt;/p&gt;
&lt;p&gt;「デフォルト」はライブラリで一つしか選べません。どちらのモードで処理することができたとしても、「デフォルト」はただ一つです。改めて言うと、私はバイナリフォーマットとしての「コンパクトとパフォーマンス」を好み、優先しています。&lt;/p&gt;
&lt;p&gt;皆さんはPolyTypeについて初めて知ったかもしれません。私はPolyTypeはあまり好意的には考えていません。ちょっとしたものを作るには非常に便利だとは思いますが、ベストなパフォーマンスを狙ったり、ベストなアイディアを表現するには、抽象層であることの制限が大きすぎると考えています。なので、MessagePack for C#で採用することはありませんし、他の何かを作る際にも採用することはないでしょう。&lt;/p&gt;
&lt;h2&gt;Unity(multiplatform) Support&lt;/h2&gt;
&lt;p&gt;MessagePack for C#ではv1の時代からゲームエンジンUnityの1st classのサポートを実行してきました。これは私が&lt;a href="https://en.wikipedia.org/wiki/Cygames"&gt;Cygames&lt;/a&gt;という日本のゲーム会社の関連会社(&lt;a href="https://cysharp.com/"&gt;Cysharp&lt;/a&gt;)のCEOを務めていて、ビデオゲームインダストリーと関係性が深いという都合もあります。自分たちで実際にUnityで動くものを作り、使ってきました。もちろん、サーバーサイドやデスクトップアプリケーションでも使っています。&lt;/p&gt;
&lt;p&gt;UnityにはIL2CPPという独自のAOTシステムがあり、特にiOSなどモバイルプラットフォームでのリリースには必須なのですが、それもSource Generatorが存在しなかった時代から、mpcというRoslynを使ったコードジェネレートツールを作り、提供してきました。数百のモバイルゲームでMessagePackが使われているのは、これら私の熱心なサポートのお陰といっても過言ではないでしょう。v3ではついにSource Generatorベースになったことにより、ワークフローが大きく簡易化されることとなります！&lt;/p&gt;
&lt;p&gt;一般的に、.NETコミュニティにおいてはUnityサポートはかなり軽視されていました。また、外から見ているとMicrosoftやMicrosoftの従業員もそのようで、自社のプラットフォーム以外への関心は薄そうです。こうした態度は、あまり好ましいとは思っていませんし、せっかくの .NET の可能性を狭めていることにもなっています。Xamarinがうまく成長軌道に乗らなかったのも、そのようなMicrosoft自体の冷たい視線のせいだとも思っています。&lt;/p&gt;
&lt;p&gt;私は、私の作るライブラリはなるべくUnityにもしっかり対応できるように気を付けて作っています（最新は新しいReactive Extensionsライブラリーである&lt;a href="https://github.com/Cysharp/R3"&gt;Cysharp/R3&lt;/a&gt;）。別のMessagePackシリアライザーに関しては、あまりしっかりした対応はされなさそうですが……。&lt;/p&gt;
&lt;h2&gt;Beyond v3&lt;/h2&gt;
&lt;p&gt;v3のNative AOT Supportは完全ではありません。Source Generatorにするだけでは完全なNative AOT対応とはならないのは難しいところです。これはUnityのAOTであるIL2CPPでは完璧に動作しているだけに、正直不可解なことでもあり、また、Microsoftのよくない癖が出ているな、とも思っています。つまり、完璧な対応をするために、複雑なものを提供している。それが現在のNative AOTです。複雑怪奇な属性やフローは、理解できるところもありますが、もう少し簡略化すべきだったと思います。まぁ、もう修正されることもないのでしょうが……。&lt;/p&gt;
&lt;p&gt;パフォーマンス面でもv1からv2で退化してしまった点もあるので、最新の知見を元に、実装面での改善を施す必要があります。特にReadOnlySequenceの利用幅が大きいことは、かなりの制約を生み出していて、不満があります。&lt;/p&gt;
&lt;p&gt;.NET 9でPipeReader/PipeWriterが標準化されたことによる、より良い非同期APIや、パフォーマンスを両立したストリーミング対応というのも、大きなトピックとなるかもしれません。&lt;/p&gt;
&lt;p&gt;MessagePack for C#は広く使われているが故に、破壊的変更はしづらいし、互換性の維持は最重要トピックスです。しかし、世の中が変わっていく以上、進化しないことを選んだら、それは滅びる道でしかありません。やれることはまだまだあると思っていますので、.NETにおける最先端の、最高のバイナリシリアライザーであり続けたいと思っています（&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;もね……！)&lt;/p&gt;
&lt;p&gt;まずは、v3のSource Generatorをぜひ試してみてください。皆の力でより良いものを作っていけるというのも、OSSの良さだと思っています。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 06 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-06T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/12/03_SharpFuzz.html</guid>
      <link>https://neue.cc/2024/12/03_SharpFuzz.html</link>
      <title>Fuzzing in .NET: Introducing SharpFuzz</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-12-03" data-pagefind-meta="published:2024-12-03"&gt;&lt;a href="https://neue.cc/2024/12/03_SharpFuzz.html"&gt;Fuzzing in .NET: Introducing SharpFuzz&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-12-03&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;この記事は&lt;a href="https://qiita.com/advent-calendar/2024/csharplang"&gt;C# Advent Calendar 2024&lt;/a&gt;に参加しています。また、先月開催された&lt;a href="https://dotnetnew.connpass.com/event/335955/"&gt;dotnet new&lt;/a&gt;というイベントでの発表のフォローアップ、のつもりだったのですがコロナ感染につき登壇断念……。というわけで、セッション資料はないので普通にブログ記事とします！&lt;/p&gt;
&lt;h2&gt;dotnet/runtime と Fuzzing&lt;/h2&gt;
&lt;p&gt;今年に入ってからdotnet/runtimeにFuzzingテストが追加されています。&lt;a href="https://github.com/dotnet/runtime/tree/main/src/libraries/Fuzzing"&gt;dotnet/runtime/Fuzzing&lt;/a&gt;。というわけで、実はfuzzingは非常に最近のトピックスなのです……！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0"&gt;ファジング&lt;/a&gt;とはなんなのか、ザックリとはランダムな入力値を大量に投げつけることによって不具合や脆弱性を発見するためのテストツールです。エッジケースのテスト、やはりどうしても抜けちゃいがちだし、ましてや脆弱性になりうる絶妙な不正データを人為的に作るのも難しいので、ここはツール頼みで行きましょう。&lt;/p&gt;
&lt;p&gt;Goでは1.18(2022年)から標準でgo fuzzコマンドとして追加されたらしいので、
&lt;a href="https://future-architect.github.io/articles/20220214a/"&gt;Go1.18から追加されたFuzzingとは&lt;/a&gt;のような解説記事を読むのもイメージを掴みやすいです。&lt;/p&gt;
&lt;p&gt;さて、dotnet/runtimeのFuzzingでは現状&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AssemblyNameInfoFuzzer&lt;/li&gt;
&lt;li&gt;Base64Fuzzer&lt;/li&gt;
&lt;li&gt;Base64UrlFuzzer&lt;/li&gt;
&lt;li&gt;HttpHeadersFuzzer&lt;/li&gt;
&lt;li&gt;JsonDocumentFuzzer&lt;/li&gt;
&lt;li&gt;NrbfDecoderFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesByteCharFuzzer&lt;/li&gt;
&lt;li&gt;SearchValuesStringFuzzer&lt;/li&gt;
&lt;li&gt;TextEncodingFuzzer&lt;/li&gt;
&lt;li&gt;TypeNameFuzzer&lt;/li&gt;
&lt;li&gt;UTF8Fuzzer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というのものが用意されてます。わかるようなわからないような。だいたいデータのパース系によく使われるものなので、その通りのところに用意されています。一番わかりやすいJsonDocumentFuzzerを見てみましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal sealed class JsonDocumentFuzzer : IFuzzer
{
    public string[] TargetAssemblies { get; } = [&amp;quot;System.Text.Json&amp;quot;];
    public string[] TargetCoreLibPrefixes =&amp;gt; [];
    public string Dictionary =&amp;gt; &amp;quot;json.dict&amp;quot;;

    // fuzzerからのランダムなバイト列が入力
    public void FuzzTarget(ReadOnlySpan&amp;lt;byte&amp;gt; bytes)
    {
        if (bytes.IsEmpty)
        {
            return;
        }

        // The first byte is used to select various options.
        // The rest of the input is used as the UTF-8 JSON payload.
        byte optionsByte = bytes[0];
        bytes = bytes.Slice(1);

        var options = new JsonDocumentOptions
        {
            AllowTrailingCommas = (optionsByte &amp;amp; 1) != 0,
            CommentHandling = (optionsByte &amp;amp; 2) != 0 ? JsonCommentHandling.Skip : JsonCommentHandling.Disallow,
        };

        using var poisonAfter = PooledBoundedMemory&amp;lt;byte&amp;gt;.Rent(bytes, PoisonPagePlacement.After);

        try
        {
            // それをParseに投げて、もし不正な例外が来たらなんかバグっていたということで
            JsonDocument.Parse(poisonAfter.Memory, options);
        }
        catch (JsonException) { }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ようは想定外のデータ入力で&lt;code&gt;JsonDocument.Parse&lt;/code&gt;が失敗しないことを祈る、といったものですね。正常に認識しているinvalidな値なら&lt;code&gt;JsonException&lt;/code&gt;をthrowするはずですが、&lt;code&gt;ArgumentException&lt;/code&gt;とか&lt;code&gt;StackOverflowException&lt;/code&gt;とかが出てきちゃった場合は認識できていない不正パターンなので、ちゃんとしたハンドリングが必要になってきます。&lt;/p&gt;
&lt;p&gt;では、これを参考にやっていきましょう、とはなりません。えー。まず、dotnet/runtimeのFuzzingではSharpFuzz, libFuzzer, そしてOneFuzzが使用されていると書いてあるのですが、OneFuzzはMicrosoft内部ツールなので外部では使用できません。正確には&lt;a href="https://www.publickey1.jp/blog/20/project_onefuzzwindowsmicorosoft_edge.html"&gt;2020年にオープンソース公開&lt;/a&gt;したものの、&lt;a href="https://github.com/microsoft/onefuzz"&gt;2023年にはクローズドに戻している&lt;/a&gt;状態です。まぁ事情は色々ある。しょーがない。&lt;/p&gt;
&lt;p&gt;というわけで、これはMicrosoft内部で動かすためのOneFuzzや、dotnet/runtimeで動かすために調整してある&lt;code&gt;IFuzzer&lt;/code&gt;といったフレームワーク部分が含まれているので、小規模な自分たちのコードをfuzzingするにあたっては、不要ですし、ぶっちゃけあまり参考にはなりません！解散！&lt;/p&gt;
&lt;h2&gt;Introducing SharpFuzz&lt;/h2&gt;
&lt;p&gt;そんなわけでdotnet/runtimeのFuzzingでも使われている&lt;a href="https://github.com/Metalnem/sharpfuzz"&gt;Metalnem/sharpfuzz: AFL-based fuzz testing for .NET&lt;/a&gt;を直接使っていきます。sharpfuzzは&lt;a href="https://lcamtuf.coredump.cx/afl/"&gt;afl-fuzz&lt;/a&gt;と連動して動くように作られている .NETライブラリです。3rd Partyライブラリですが作者はMicrosoftの人です（dotnet/runtimeで採用されている理由でもあるでしょう）。ReadMeのTrophiesでは色々なもののバグを見つけてやったぜ、と書いてあります。AngleSharpとかGoogle.ProtobufとかGraphQL-ParserとかMarkdigとかMessagePack for C#とImageSharpとか。まぁ、やはり用途としてはパーサーのバグを見つけるのには適切、という感じです。&lt;/p&gt;
&lt;p&gt;AFL(American Fuzzy Lop)ってなに？ということなのですが、そもそもファジングの「ランダムな入力値を大量に投げつける」行為は、完全なランダムデータを投げつけていくわけではありません。完全ランダムだとあまりにも時間がかかりすぎるため、脆弱性発見において実用的とは言えない。そこでAFLはシード値からのミューテーションと、カバレッジをトレースしながら効率よくデータを生成していきます。Wikipediaから引用すると&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;テスト対象のプログラム（テスト項目）のソースコードをインストルメント化することにより、afl-fuzzは、ソフトウェアのどのブロックが特定のテスト刺激で実行されたかを後で確認できる。そのため、AFLはグレーボックステストに使用することができる。遺伝的手法による検査データの生成に関連して、ファザーはテストデータをより適切に生成できるため、このメソッドを使用しない他のファザーよりも、処理中に以前は使用されていなかったコードブロックが実行される。その結果、コードカバレッジは比較的短い時間で比較的高い結果が得られる。この方法は、生成されたデータ内の構造を独立して（つまり、事前の情報なしで）生成することができる。このプロパティは、テストカバレッジの高いテストコーパス（テストケースのコレクション）を生成するためにも使用される。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;というわけでdotnet testのようにテストコードを渡したら全自動でやってくれる、というほど甘くはなくて、多少の下準備が必要になってきます。SharpFuzzは一連の処理をある程度やってくれるようにはなっていますが、そもそもに実行までに二段階の処理が必要になっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharpfazzコマンド(dotnet tool)でdllにトレースポイントを注入する&lt;/li&gt;
&lt;li&gt;その注入されたdll(とexe)をネイティブのfuzzing実行プロセス(afl-fuzzなど)に渡す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dllにトレースポイントを注入はお馴染みの&lt;a href="https://github.com/jbevain/cecil"&gt;Cecil&lt;/a&gt;でビルド済みのDLLのILを弄ってトレースポイントを仕込みます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/c3b43b60-8526-44cd-8482-6f1185206b65" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これは注入済みのdllですが、Trace.SharedMemとかTrace.PrevLocationとか、分岐点に対して明らかに注入している様が見えます。そうしたトレースポイントとの通信や実行データ生成などは外部プロセスが行うので、SharpFuzzというライブラリは、それ自体は実行ツールではなくて、それらとの橋渡しをするためのシステムということです。&lt;/p&gt;
&lt;p&gt;ではやっていきましょう！色々なシステムが絡んでくる分、ちょっとややこしく面倒くさいのと、ReadMeの例をそのままやると罠が多いので、少しアレンジしていきます。&lt;/p&gt;
&lt;p&gt;まずはRequirementsですが、実行機であるAFLがWindowsでは動きません(Linux, macOSでは動く)。なのでWSL上で動かしましょうという話になってくるのですが、それはあんまりにもやりづらいので、&lt;a href="https://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt;というLLVMが開発しているAFL互換のFuzzingツールを使っていくことにします。これはWindowsでビルドできます。&lt;/p&gt;
&lt;p&gt;自分でビルドする必要はなく、SharpFuzzの作者が連携して使うことを意識して用意してくれている&lt;a href="https://github.com/Metalnem/libfuzzer-dotnet/releases"&gt;libfuzzer-dotnetのReleasesページ&lt;/a&gt;から、バイナリを直接落としてきましょう。&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;次に、IL書き換えを行うツール&lt;code&gt;SharpFuzz.CommandLine&lt;/code&gt;を .NET toolで入れていきましょう。これはglobalでいいかな、と思います。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet tool install --global SharpFuzz.CommandLine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、今回は&lt;a href="https://github.com/kevin-montrose/Jil"&gt;Jil&lt;/a&gt;という、今はもうあまり使われることもないJsonシリアライザーをターゲットとしてやっていこうということなので、JilとSharpFuzzをインストールします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code&gt;dotnet add package Jil --version 2.15.4
dotnet add package SharpFuzz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで注意が必要なのは、Jilの最新バージョンはSharpFuzzにより発見されたバグが修正されているので、最新版を入れるとチュートリアルにはなりません！というわけでここは必ずバージョン下げて入れましょう。&lt;/p&gt;
&lt;p&gt;新規のConsoleApplicationで、コードは以下のようにします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;
using SharpFuzz;

// 実行機としてlibFuzzerを使う(引数はReadOnlySpan&amp;lt;byte&amp;gt;)
Fuzzer.LibFuzzer.Run(span =&amp;gt;
{
    try
    {
        using var stream = new MemoryStream(span.ToArray());
        using var reader = new StreamReader(stream);
        JSON.DeserializeDynamic(reader); // このメソッドが正しく動作してくれるかをテスト
    }
    catch (Jil.DeserializationException)
    {
        // Jil.DeserializationExceptionは既知の例外（正しくハンドリングできてる）なので握り潰し
        // それ以外の例外が発生したらルート側にthrowされて問題が検知される
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今度はベースになるテストデータを用意します。名前とかはなんでもいいんですが、&lt;code&gt;Testcases&lt;/code&gt;フォルダに&lt;code&gt;Test.json&lt;/code&gt;を追加しました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/606cede7-9a20-4efe-8e58-642330ced8d5" alt="image" /&gt;&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;click&amp;quot;:&amp;quot;Close()&amp;quot;}]}}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このデータを元にしてfuzzerは値を変形させていくことになります。&lt;/p&gt;
&lt;p&gt;では実行しましょう！実行するためには、ビルドしてILポストプロセスしてlibFuzzer経由で動かす……。という一連の定型の流れが必要になるため、作者の用意してくれているPowerShellスクリプト&lt;a href="https://raw.githubusercontent.com/Metalnem/sharpfuzz/master/scripts/fuzz-libfuzzer.ps1"&gt;fuzz-libfuzzer.ps1&lt;/a&gt;をダウンロードしてきて使いましょう。&lt;/p&gt;
&lt;p&gt;とりあえず&lt;code&gt;fuzz-libfuzzer.ps1&lt;/code&gt;と&lt;code&gt;libfuzzer-dotnet-windows.exe&lt;/code&gt;をcsprojと同じディレクトリに配置して、以下のコマンドを実行します。&lt;code&gt;ConsoleApp24.csproj&lt;/code&gt;の部分だけ適当に変えてください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;動かすと、見つかった場合はいい感じに止まってくれます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/1ce45aa1-2d50-46f2-8f86-947db39406d6" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;なお、見つからなかった場合は無限に探し続けるので、なんとなくもう見つかりそうにないなあ、と思ったら途中で自分でとめる(Ctrl+C)必要があります。&lt;/p&gt;
&lt;p&gt;Testcasesには途中の残骸と、クラッシュした場合は&lt;code&gt;crash-id&lt;/code&gt;でクラッシュ時のデータが拾えます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/d90f5bb1-4509-41b6-a139-16789a5a501c" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;今回見つかったクラッシュデータは&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-json"&gt;{&amp;quot;menu&amp;quot;:{&amp;quot;id&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;popid&amp;quot;:1,&amp;quot;val&amp;quot;:&amp;quot;X&amp;quot;,&amp;quot;pop&amp;quot;:{&amp;quot;a&amp;quot;:[{&amp;quot;click&amp;quot;:&amp;quot;Open()&amp;quot;},{&amp;quot;c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でした。実際このデータを使って再現できます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Jil;

//  クラッシュファイルのプロパティでデータはCopy to Output Directoryしてしまう
//  &amp;lt;None Update=&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;&amp;gt;
//    &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
//  &amp;lt;/None&amp;gt;
var crash = File.ReadAllBytes(&amp;quot;crash-c57462e70fb60e86e8c41cd18b70624bd1e89822&amp;quot;);
var span = crash.AsSpan();

// Fuzzing時と同じコード
using var stream = new MemoryStream(span.ToArray());
using var reader = new StreamReader(stream);
JSON.DeserializeDynamic(reader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上！完璧！便利！一度手順を理解してしまえば、そこまで難しいことではないので、是非ハンズオンでやってみることをお薦めします。なお、ps1のスクリプトは実行対象自身へのインジェクトは除外されるようになっているので、小規模な自分のコードでfuzzingを試してみたいと思った場合は、対象コードはexeとは異なるプロジェクトに分離しておく必要があります。&lt;/p&gt;
&lt;p&gt;ところで、AFLにはdictionaryという仕組みがあり、既知のキーワード集がある場合は生成速度を大幅に上昇させることが可能です。例えば&lt;a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/json.dict"&gt;json.dict&lt;/a&gt;を使う場合は&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-cmd"&gt;PowerShell -ExecutionPolicy Bypass ./fuzz-libfuzzer.ps1 -libFuzzer &amp;quot;./libfuzzer-dotnet-windows.exe&amp;quot; -project &amp;quot;ConsoleApp24.csproj&amp;quot; -corpus &amp;quot;Testcases&amp;quot; -dict ./json.dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように指定します。JSONとかYAMLとかXMLとかZipとか、一般的な形式は&lt;a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries"&gt;AFLplusplus/dictionaries&lt;/a&gt;などに沢山転がっています。独自に作ることも可能で、例えばdotnet/runtimeのFuzzingではBinaryFormatterのテストが置いてありますが、これは&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/serialization/binaryformatter-migration-guide/read-nrbf-payloads"&gt;NRBF(.NET Remoting Binary Format)&lt;/a&gt;の辞書、&lt;a href="https://github.com/dotnet/runtime/blob/main/src/libraries/Fuzzing/DotnetFuzzing/Dictionaries/nrbfdecoder.dict"&gt;nrbfdecoder.dict&lt;/a&gt;を用意しているようでした。&lt;/p&gt;
&lt;p&gt;もちろん、なしでも動かすことはできますが、用意できそうなら用意しておくとよいでしょう。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;でも実際バグ見つかってたりするので、この手のライブラリを作る人だったら覚えておいて損はないです。シリアライザーに限らずパーサーに関わるものだったらネットワークプロトコルでも、なんでも適用可能です。ただし現状、入力が&lt;code&gt;byte[]&lt;/code&gt;に制限されているので、応用性自体はあるようで、なかったりはします。これがintとか受け入れてくれると、様々なメソッドに対してカジュアルに使えて、より便利な気もしますが……(実際go fuzzは&lt;code&gt;byte[]&lt;/code&gt;だけじゃなくて基本的なプリミティブの生成に対応している)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;列から適当に切り出してintとして使う、といったような処理だと、ミューテーションやカバレッジの関係上、適切な値を取得しにくいので、あまりうまくやれません。libFuzzerでは&lt;a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md"&gt;Structure-Aware Fuzzing with libFuzzer&lt;/a&gt;といったような手法が考案されていて、protocol buffersの構造を与えるとか、gRPCの構造を与えるとかでうまく活用している事例はあるようです。この辺はSharpFuzzの対応次第となります(いつかやりたい、とは書いてありましたが、現実的にいつ来るかというと、あまり期待しないほうが良いでしょう)&lt;/p&gt;
&lt;p&gt;Rustにも&lt;a href="https://github.com/rust-fuzz/cargo-fuzz"&gt;cargo fuzz&lt;/a&gt;といったcrateがあり、それなりに使われているようです。&lt;/p&gt;
&lt;p&gt;Fuzzingは適用範囲が限定的であることと下準備の手間などがあり、一般的なアプリケーション開発者においては、あまりメジャーなテスト手法ではないというのが現状だと思いますが、使えるところはないようで意外とあるとも思うので、ぜひぜひ試してみてください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-12-03T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/11/19_cysharp_oss.html</guid>
      <link>https://neue.cc/2024/11/19_cysharp_oss.html</link>
      <title>CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-11-19" data-pagefind-meta="published:2024-11-19"&gt;&lt;a href="https://neue.cc/2024/11/19_cysharp_oss.html"&gt;CysharpのOSS Top10まとめ / Ulid vs .NET 9 UUID v7 / MagicOnion&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-11-19&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;「CysharpのOSS群から見るModern C#の現在地」というタイトルでセッションしてきました。&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="73bfd578c3324a6e8ce74457445fe9c0" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;作りっぱなし、というわけではないですが（比較的メンテナンスしてるとは思います！）、リリースから年月が経ったライブラリをどう思っているかは見えないところありますよね、というわけで、その辺を軽く伝えられたのは良かったのではないかと思います。&lt;/p&gt;
&lt;p&gt;この中だと非推奨に近くなっているのが&lt;a href="https://github.com/Cysharp/ZString"&gt;ZString&lt;/a&gt;と&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;でしょうか。&lt;/p&gt;
&lt;h2&gt;Ulid vs .NET 9 UUID v7&lt;/h2&gt;
&lt;p&gt;スライドにも書きましたが、ULIDをそこそこ使ってきての感想としては、「Guidではないこと」が辛いな、と。独自文字列形式とか要らないし。そんなわけで私はむしろUUID v7のほうを薦めたいレベルだったりはします。.NET 9から&lt;code&gt;Guid.CreateVersion7()&lt;/code&gt;という形で、標準で生成できるようになりました。&lt;/p&gt;
&lt;p&gt;パフォーマンス的なところは些細なことなので問題ないのですが、 .NET 9未満との互換性が取れないのは厳しいところかもしれません。というわけで、自作のV7実装を用意してあげるといいでしょう。以下に置いておきますのでどうぞ（コードのベースはdotnet/runtimeのCCreateVersion7です）&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-Csharp"&gt;public static class GuidEx
{
    private const byte Variant10xxMask = 0xC0;
    private const byte Variant10xxValue = 0x80;
    private const ushort VersionMask = 0xF000;
    private const ushort Version7Value = 0x7000;

    public static Guid CreateVersion7() =&amp;gt; CreateVersion7(DateTimeOffset.UtcNow);

    public static Guid CreateVersion7(DateTimeOffset timestamp)
    {
        // 普通にGUIDを作る
        Guid result = Guid.NewGuid();

        // 先頭48bitをいい感じに埋める
        var unix_ts_ms = timestamp.ToUnixTimeMilliseconds();

        // GUID layout is int _a; short _b; short _c, byte _d;
        Unsafe.As&amp;lt;Guid, int&amp;gt;(ref Unsafe.AsRef(ref result)) = (int)(unix_ts_ms &amp;gt;&amp;gt; 16); // _a
        Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 2) = (short)(unix_ts_ms); // _b

        ref var c = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, short&amp;gt;(ref Unsafe.AsRef(ref result)), 3);
        c = (short)((c &amp;amp; ~VersionMask) | Version7Value);

        ref var d = ref Unsafe.Add(ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(ref result)), 8);
        d = (byte)((d &amp;amp; ~Variant10xxMask) | Variant10xxValue);

        return result;
    }

    // GuidにはTimestamp部分を取り出すメソッドがないので、これも用意してあげると便利
    public static DateTimeOffset GetTimestamp(in Guid guid)
    {
        // エンディアンについては特に考慮してません
        ref var p = ref Unsafe.As&amp;lt;Guid, byte&amp;gt;(ref Unsafe.AsRef(in guid));
        var lower = Unsafe.ReadUnaligned&amp;lt;uint&amp;gt;(ref p);
        var upper = Unsafe.ReadUnaligned&amp;lt;ushort&amp;gt;(ref Unsafe.Add(ref p, 4));
        var time = (long)upper + (((long)lower) &amp;lt;&amp;lt; 16);
        return DateTimeOffset.FromUnixTimeMilliseconds(time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UUID v7のよくあるユースケースはDBの主キーにGUID(UUID v4)の代わりに使う、ということです。UUID v4だとランダムに配置されるので断片化して、auto incrementの主キーに比べると色々と遅くなる。それがv7だとランダムの性質を持ちつつも配置場所はタイムスタンプベースなのでauto incrementと同様になるため性能劣化がない。&lt;/p&gt;
&lt;p&gt;という理屈を踏まえたうえで、.NETのUUID v7事情を踏まえると単純に置き換えるだけで良い、とはなりません。&lt;/p&gt;
&lt;p&gt;GUIDは内部的なバイナリデータとしてはリトルエンディアンで保持していて、出力時に切り分けるというデザインになっています(無指定の場合はlittleEndianでの出力)。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public readonly struct Guid
{
    public byte[] ToByteArray()
    public byte[] ToByteArray(bool bigEndian)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination)
    public bool TryWriteBytes(Span&amp;lt;byte&amp;gt; destination, bool bigEndian, out int bytesWritten)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String(char36)として格納するなら気にしなくてもいいのですが、GUID型やバイナリ型としてデータベースに格納する時は、UUID v7に関してはビッグエンディアンで書き出さないと、ソート可能にならない非常に都合が悪い。これのハンドリングは言語のデータベースドライバーライブラリの責務となっています。&lt;/p&gt;
&lt;p&gt;代表的なライブラリを見ていくと、MySQLの&lt;a href="https://mysqlconnector.net/connection-options/"&gt;mysqlconnector-netはコネクションストリング&lt;/a&gt;で &lt;code&gt;GuidFormat=Binary16&lt;/code&gt; を指定することでbig-endianでBINARY(16)に書き込む設定となります。&lt;/p&gt;
&lt;p&gt;PostgreSQLの場合、&lt;a href="https://github.com/npgsql/npgsql/blob/94de20fed2e7e64a1eb6f26c9fc044131a362958/src/Npgsql/Internal/Converters/Primitive/GuidUuidConverter.cs#L29"&gt;npgsqlのGuidUuidConverter&lt;/a&gt;が常にbigEndianとして処理するようになっているようです。&lt;/p&gt;
&lt;p&gt;ではMicrosoft SQL Serverはどうかというと、ばっちしlittle-endianです。ダメです。というわけで、性能を期待してCreateVersion7を使うと、逆に断片化して遅くなるような憂き目にあいます。&lt;/p&gt;
&lt;p&gt;こちらは&lt;a href="https://github.com/dotnet/SqlClient/discussions/2999"&gt;dotnet/SqlClientのdiscussions#2999&lt;/a&gt;で議論されているようなので、成り行きに注目ということで。今までとの互換性などを考えると一括でbigにしてしまえばいいじゃん、というわけにもいかないしで、中々素直にはいかないかもしれませんね……。&lt;/p&gt;
&lt;p&gt;なお、このことは別に.NET 9がリリースされる前にもわかっていたことなのに（私でもダメだという状況は把握していた）、リリースされるまでアクションが全く起きないというところに、今のSQL Serverへのやる気を感じたりなかったり。&lt;/p&gt;
&lt;h2&gt;MagicOnion&lt;/h2&gt;
&lt;p&gt;イベントではCysharpの @mayuki さんからMagicOnionの入門セッションもありました！&lt;/p&gt;
&lt;script defer class="speakerdeck-embed" data-id="d5b4ad47f5cd4e9f984022e64d623d51" data-ratio="1.7777777777777777" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
&lt;p&gt;MagicOnionも2016年の初リリース、2018年のリブート(v2)、googleのgRPC C Coreからgrpc-dotnetベースへの変更、クライアントのHttpClientベースへの変更など、内部的には色々変わってきたし機能面でも磨かれてきています。まだまだ次のアップデートが控えている、最前線で戦える強力なフレームワークとなっています！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 19 Nov 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-11-19T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/08/29_AlternateLookup.html</guid>
      <link>https://neue.cc/2024/08/29_AlternateLookup.html</link>
      <title>.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-08-29" data-pagefind-meta="published:2024-08-29"&gt;&lt;a href="https://neue.cc/2024/08/29_AlternateLookup.html"&gt;.NET 9 AlternateLookup によるC# 13時代のUTF8文字列の高速なDictionary参照&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-08-29&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;.NET 9 から辞書系のクラス、&lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;ConcurrentDictionary&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, &lt;code&gt;FrozenDictionary&lt;/code&gt;, &lt;code&gt;FrozenSet&lt;/code&gt;に &lt;code&gt;GetAlternateLookup&amp;lt;TKey, TValue, TAlternate&amp;gt;()&lt;/code&gt; というメソッドが追加されました。今までDictionaryの操作はTKey経由でしかできませんでした。それは当たり前、なのですが、困るのが文字列キーで、これはstringでも操作したいし、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;でも操作したくなります。今までは&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;しか手元にない場合はToStringでstring化が必須でした、ただたんにDictionaryの値を参照したいだけなのに！&lt;/p&gt;
&lt;p&gt;その問題も、.NET 9から追加された&lt;code&gt;GetAlternateLookup&lt;/code&gt;を使うと、辞書に別の検索キーを持たせることが出来るようになりました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var dict = new Dictionary&amp;lt;string, int&amp;gt;
{
    { &amp;quot;foo&amp;quot;, 10 },
    { &amp;quot;bar&amp;quot;, 20 },
    { &amp;quot;baz&amp;quot;, 30 }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;char&amp;gt;&amp;gt;();

var keys = &amp;quot;foo, bar, baz&amp;quot;;

// .NET 9 SpanSplitEnumerator
foreach (Range range in keys.AsSpan().Split(','))
{
    ReadOnlySpan&amp;lt;char&amp;gt; key = keys.AsSpan(range).Trim();

    // ReadOnlySpan&amp;lt;char&amp;gt;でstring keyの辞書のGet/Add/Removeできる
    int value = lookup[key];
    Console.WriteLine(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ところでSplitは、通常のstringのSplitは配列とそれぞれ区切られたstringをアロケーションしてしまいますが、.NET 8から、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;に対して固定個数のSplitができる&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.memoryextensions.split"&gt;MemoryExtensions.Split&lt;/a&gt;が追加されました。.NET 9では、更にSpanSplitEnumeratorを返すSplitが新たに追加されています。これにより一切の追加のアロケーションなく、元の文字列から&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;を切り出すことができます。&lt;/p&gt;
&lt;p&gt;そうして取り出した&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;のキーで参照するために、&lt;code&gt;GetAlternateLookup&lt;/code&gt;が必要になってくるわけです。&lt;/p&gt;
&lt;p&gt;使い道としては、例えばシリアライザーは頻繁にキーと値のルックアップが必要になります。私の開発している&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#&lt;/a&gt;では、高速でアロケーションフリーなデシリアライズのために、複数の戦略を採用しています。その一つはUTF8の文字列を8バイトずつの&lt;a href="https://en.wikipedia.org/wiki/Automata_theory"&gt;オートマトン&lt;/a&gt;として扱う&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs"&gt;AutomataDictionary&lt;/a&gt;、この部分は更にIL EmitやSource Generatorではインライン化して埋め込まれて辞書検索もなくしています。もう一つは&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp/blob/5793c81/src/MessagePack/Internal/AsymmetricKeyHashTable.cs"&gt;AsymmetricKeyHashTable&lt;/a&gt;という機構で、これは同一の対象を表す2つのキーで検索可能にしようというもので、内部的には &lt;code&gt;byte[]&lt;/code&gt; と &lt;code&gt;ArraySegment&amp;lt;byte&amp;gt;&lt;/code&gt; で検索できるような辞書を作っていました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// MessagePack for C#のもの
internal interface IAsymmetricEqualityComparer&amp;lt;TKey1, TKey2&amp;gt;
{
    int GetHashCode(TKey1 key1);
    int GetHashCode(TKey2 key2);
    bool Equals(TKey1 x, TKey1 y);
    bool Equals(TKey1 x, TKey2 y); // TKey1とTKey2での比較
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり、今までは、こうした別の検索キーを持った辞書が必要なシチュエーションでは、辞書そのものの自作が必要だったし、パフォーマンスのためには基礎的なデータ構造すら自作を厭わない必要がありましたが、.NET 9からはついに標準でそれが実現するようになりました。&lt;/p&gt;
&lt;p&gt;AlternateLookupでも必要なのは&lt;code&gt;IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;&lt;/code&gt;で、以下のような定義になっています。(&lt;code&gt;IAsymmetricEqualityComparer&lt;/code&gt;と似たような定義なので、また時代を10年先取りしてしまったか)&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface IAlternateEqualityComparer&amp;lt;in TAlternate, T&amp;gt;
    where TAlternate : allows ref struct
    where T : allows ref struct
{
    bool Equals(TAlternate alternate, T other);
    int GetHashCode(TAlternate alternate);
    T Create(TAlternate alternate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C# 13から追加された言語機能 &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/ref-struct"&gt;allows ref struct&lt;/a&gt; によってref struct、つまり&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;などをジェネリクスの型引数にすることができるようになりました。&lt;/p&gt;
&lt;p&gt;基本的にはこれは&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;とセットで実装する必要があります。実際、&lt;code&gt;Dictionary.GetAlternateLookup&lt;/code&gt;ではDictionaryの&lt;code&gt;IEqualityComparer&lt;/code&gt;が&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していないと実行時例外が出ます（コンパイル時チェックではありません！）また、EqualityComparerなのに&lt;code&gt;Create&lt;/code&gt;があるのが少し奇妙ですが、これはAdd操作のために必要だからです。&lt;/p&gt;
&lt;p&gt;現状、標準では&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;は&lt;code&gt;string&lt;/code&gt;用しかありません。stringで標準的に使われるEqualityComparerは&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を実装していて、&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;で操作できますが、それ以外は用意されていません。&lt;/p&gt;
&lt;p&gt;しかし、現代において現実的に必要なのはUTF8です、&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;です。シリアライザーのルックアップで使う、と言いましたが、現代のシリアライザーの入力はUTF8です。&lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt;の出番なんてありません。というわけで、以下のような&lt;code&gt;IAlternateEqualityComparer&lt;/code&gt;を用意しましょう！&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public sealed class Utf8StringEqualityComparer : IEqualityComparer&amp;lt;byte[]&amp;gt;, IAlternateEqualityComparer&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;, byte[]&amp;gt;
{
    public static IEqualityComparer&amp;lt;byte[]&amp;gt; Default { get; } = new Utf8StringEqualityComparer();

    // IEqualityComparer

    public bool Equals(byte[]? x, byte[]? y)
    {
        if (x == null &amp;amp;&amp;amp; y == null) return true;
        if (x == null || y == null) return false;

        return x.AsSpan().SequenceEqual(y);
    }

    public int GetHashCode([DisallowNull] byte[] obj)
    {
        return GetHashCode(obj.AsSpan());
    }

    // IAlternateEqualityComparer

    public byte[] Create(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        return alternate.ToArray();
    }

    public bool Equals(ReadOnlySpan&amp;lt;byte&amp;gt; alternate, byte[] other)
    {
        return other.AsSpan().SequenceEqual(alternate);
    }

    public int GetHashCode(ReadOnlySpan&amp;lt;byte&amp;gt; alternate)
    {
        // System.IO.Hashing package, cast to int is safe for hashing
        return unchecked((int)XxHash3.HashToUInt64(alternate));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;byte[]&lt;/code&gt;は標準では参照比較になってしまいますが、データの一致で比較したいので、&lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;.SequenceEqual&lt;/code&gt; を使います。これは、特にTが幾つかのプリミティブの場合はSIMDを活用して高速な比較が実現されています。ハッシュコードの算出は、高速なアルゴリズム&lt;a href="https://github.com/Cyan4973/xxHash"&gt;xxHash&lt;/a&gt;シリーズの最新版であるXXH3の.NET実装である&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3"&gt;XxHash3&lt;/a&gt;を用いるのがベストでしょう。これはNuGetから&lt;code&gt;System.IO.Hashing&lt;/code&gt;をインポートする必要があります。64ビットで算出するため戻り値はulongですが、32ビット値が必要な場合はxxHashの作者より、ただたんに切り落とすだけで問題ないと言明されているため、intにキャストするだけで済まします。&lt;/p&gt;
&lt;p&gt;使う場合の例は、こんな感じです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// Utf8StringEqualityComparerを設定した辞書を作る

var dict = new Dictionary&amp;lt;byte[], bool&amp;gt;(Utf8StringEqualityComparer.Default)
{
    { &amp;quot;foo&amp;quot;u8.ToArray(), true },
    { &amp;quot;bar&amp;quot;u8.ToArray(), false },
    { &amp;quot;baz&amp;quot;u8.ToArray(), false }
};

var lookup = dict.GetAlternateLookup&amp;lt;ReadOnlySpan&amp;lt;byte&amp;gt;&amp;gt;();

// こんな入力があるとする

ReadOnlySpan&amp;lt;byte&amp;gt; json = &amp;quot;&amp;quot;&amp;quot;    
{
    &amp;quot;foo&amp;quot;: 0,
    &amp;quot;bar&amp;quot;: 0,
    &amp;quot;baz&amp;quot;: 0
}
&amp;quot;&amp;quot;&amp;quot;u8;

// System.Text.Json
var reader = new Utf8JsonReader(json);

while (reader.Read())
{
    if (reader.TokenType == JsonTokenType.PropertyName)
    {
        // 切り出したKeyで検索できる
        ReadOnlySpan&amp;lt;byte&amp;gt; key = reader.ValueSpan;
        var flag = lookup[key];
        
        Console.WriteLine(flag);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一つ注意なのは、&lt;code&gt;string&lt;/code&gt;と&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;でAlternateKeyを作ろうとするのはやめたほうが良いでしょう。それだと、常にエンコードが必要になり、悪いとこどりのようになってしまいます(&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.rune"&gt;Rune&lt;/a&gt;を使ってアロケーションレスで処理するにしても、どちらにせよバイナリ比較だけで済ませられる&lt;code&gt;byte[]&lt;/code&gt;キーとは比較になりません）。どうしても両方の検索が必要なら、辞書を二つ用意するほうがマシです。&lt;/p&gt;
&lt;p&gt;ともあれ、これは私にとっては念願の機能です！色々なバリエーションで、Span対応のためにジェネリクスにもできずに決め打ちで辞書を何度も作ってきました、汎用的に使えるようになったのは大歓迎です。&lt;code&gt;allows ref struct&lt;/code&gt;はジェネリクス定義での煩わしさもありますが（自動判定での付与でも良かったような？）、言語としては重要な進歩です。.NET 9, C# 13、使っていきましょう。現状はまだプレビューですが、11月に正式版がリリースされるはずです。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 29 Aug 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-08-29T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/07/11_mvp-renew14.html</guid>
      <link>https://neue.cc/2024/07/11_mvp-renew14.html</link>
      <title>Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-07-11" data-pagefind-meta="published:2024-07-11"&gt;&lt;a href="https://neue.cc/2024/07/11_mvp-renew14.html"&gt;Microsoft MVP for Developer Technologies(.NET)を再々々々々々々々々々々々々受賞しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-07-11&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Microsoft MVPは一年ごとに再審査されるのですが、今年も更新しました。2011年から初めて14回目ということで、長い！のですが、引き続きC#の最前線に立ち続けられていると思います。以下、審査用書類に出した、審査期間での実績一覧です。&lt;/p&gt;
&lt;h2&gt;OSS New&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;MagicPhysX&lt;/a&gt;&lt;br /&gt;
.NET PhysX 5 binding to all platforms(win, osx, linux) for 3D engine, deep learning, dedicated server of gaming.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/PrivateProxy"&gt;PrivateProxy&lt;/a&gt;&lt;br /&gt;
Source Generator and .NET 8 UnsafeAccessor based high-performance strongly-typed private accessor for unit testing and runtime.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Utf8StringInterpolation&lt;/a&gt;&lt;br /&gt;
Successor of ZString; UTF8 based zero allocation high-peformance String Interpolation and StringBuilder.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;&lt;br /&gt;
The new future of dotnet/reactive and UniRx.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Claudia"&gt;Claudia&lt;/a&gt;&lt;br /&gt;
Unofficial Anthropic Claude API client for .NET.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StreamReader"&gt;Utf8StreamReader&lt;/a&gt;&lt;br /&gt;
Utf8 based StreamReader for high performance text processing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OSS Update&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/StructureOfArraysGenerator"&gt;StructureOfArraysGenerator&lt;/a&gt;&lt;br /&gt;
Structure of arrays source generator to make CPU Cache and SIMD friendly data structure for high-performance code in .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Ulid"&gt;Ulid&lt;/a&gt;&lt;br /&gt;
Fast .NET C# Implementation of ULID for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;&lt;br /&gt;
Zero Allocation Text/Structured Logger for .NET with StringInterpolation and Source Generator, built on top of a Microsoft.Extensions.Logging.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZString/"&gt;ZString&lt;/a&gt;&lt;br /&gt;
Zero Allocation StringBuilder for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack-CSharp&lt;/a&gt;&lt;br /&gt;
Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin).&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ObservableCollections"&gt;ObservableCollections&lt;/a&gt;&lt;br /&gt;
High performance observable collections and synchronized views, for WPF, Blazor, Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UnitGenerator/"&gt;UnitGenerator&lt;/a&gt;&lt;br /&gt;
C# Source Generator to create value-object, inspired by units of measure.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;&lt;br /&gt;
Zero encoding extreme performance binary serializer for C# and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;&lt;br /&gt;
Generate C# FFI from Rust for automatically brings native code and C native library to .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/DFrame"&gt;DFrame&lt;/a&gt;&lt;br /&gt;
Distributed load testing framework for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MessagePipe"&gt;MessagePipe&lt;/a&gt;&lt;br /&gt;
High performance in-memory/distributed messaging pipeline for .NET and Unity.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/UniTask"&gt;UniTask&lt;/a&gt;&lt;br /&gt;
Provides an efficient allocation free async/await integration for Unity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Speaker&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition"&gt;CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/pulse1923/metabasupuratutohuomu-inspix-world-haphpmoc-plus-plus-momatometec-number-nitong-magiconiongazhi-erubatukuendozui-shi-hua-shou-fa"&gt;メタバースプラットフォーム 「INSPIX WORLD」はPHPもC++もまとめてC#に統一！ ～MagicOnionが支えるバックエンド最適化手法～ - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/ta-yan-yu-gameinnochang-he-norustnohuo-yong-fa-csbindgenniyoruc-number-x-rust-ffishi-jian-shi-li"&gt;他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例 - Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Book&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.jp/dp/4862465900"&gt;Unityプログラミング・バイブル R6号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;世界中見てもこんだけ叩き出してる人間いないので、これだけやってれば、満場一致で更新でいいでしょう。はい。自分で言うのもあれですが。あれ。&lt;/p&gt;
&lt;p&gt;期間中で言うと&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;が大型タイトル（？）です。また、Updateのほうも大型リニューアルとして&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger v2&lt;/a&gt;は相当力の入ったものになっています。今年の範囲だと、こないだ出した&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework v5&lt;/a&gt;や、近いうちにリリースされる（はず）の&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C# v3&lt;/a&gt;といった計画も控えています。なお、&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;は現在メンテナーじゃないので実績に含めてはいないのですが、引き続きアクティブに開発されています！&lt;/p&gt;
&lt;p&gt;ところで、このサイトも地味に更新されていて（自作のC#製静的サイトジェネレーターで作られています、ハンドメイド！）、ついに全文検索が搭載されました！上のほうのインプットボックスがそれになっているので、ぜひ試してみてください。ちょっと引っ掛かり方が変な可能性も高いですが、そこは検索ライブラリの仕様なので、いつか改善されるでしょう。多分きっと。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-07-11T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html</guid>
      <link>https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html</link>
      <title>ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-06-13" data-pagefind-meta="published:2024-06-13"&gt;&lt;a href="https://neue.cc/2024/06/13_ConsoleAppFramework_v5.html"&gt;ConsoleAppFramework v5 - ゼロオーバーヘッド・Native AOT対応のC#用CLIフレームワーク&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-06-13&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/ConsoleAppFramework"&gt;ConsoleAppFramework&lt;/a&gt;の完全に新しいバージョンをリリースしました。完全に設計しなおして実装も完全に作り直された、何もかもが新しいフレームワークになっています。設計指針として「Zero Dependency, Zero Overhead, Zero Reflection, Zero Allocation, AOT Safe」を掲げ、もちろん、他を圧倒的に引き離すパフォーマンスを実現しています。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ConsoleAppFramework/assets/46207/db4bf599-9fe0-4ce4-801f-0003f44d5628" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これはコールドスタートアップ・ウォームアップなしでのベンチマークとなっていて、CLIアプリケーションでの実際での利用に最も即したものだと考えています。System.CommandLineと比較すれば280倍！メモリアロケーション量もほかのフレームワークの100~1000倍少なくなっています(表示されている400Bはほぼシステム自体のallocなのでフレームワーク自体は0です)。&lt;/p&gt;
&lt;p&gt;このパフォーマンスは、全てをSource Generatorで生成することで実現しました。例えば以下のようなコード。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using ConsoleAppFramework;

// args: ./cmd --foo 10 --bar 20
ConsoleApp.Run(args, (int foo, int bar) =&amp;gt; Console.WriteLine($&amp;quot;Sum: {foo + bar}&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ConsoleAppFrameworkはSource GeneratorがRunで与えられているラムダ式の引数を解析して、Runメソッドそのものを生成します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal static partial class ConsoleApp
{
    // Generate the Run method itself with arguments and body to match the lambda expression
    public static void Run(string[] args, Action&amp;lt;int, int&amp;gt; command)
    {
        // code body
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常C#のSource Generatorは属性をクラスかメソッドに与えて、それを元に生成されますが、ConsoleAppFrameworkはメソッドの呼び出しを監視して生成のキーにしています。これはRustのマクロから発想を得ていて、Rustには&lt;a href="https://doc.rust-lang.org/book/ch19-06-macros.html"&gt;Attribute-like macros and Function-like macros&lt;/a&gt;といったような分類がありますが、今回のやりかたはFunction-likeなスタイルと言えるでしょう。&lt;/p&gt;
&lt;p&gt;実際の生成されるコード全体は以下のようなものになります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal static partial class ConsoleApp
{
    public static void Run(string[] args, Action&amp;lt;int, int&amp;gt; command)
    {
        if (TryShowHelpOrVersion(args, 2, -1)) return;

        var arg0 = default(int);
        var arg0Parsed = false;
        var arg1 = default(int);
        var arg1Parsed = false;

        try
        {
            for (int i = 0; i &amp;lt; args.Length; i++)
            {
                var name = args[i];

                switch (name)
                {
                    case &amp;quot;--foo&amp;quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg0)) { ThrowArgumentParseFailed(&amp;quot;foo&amp;quot;, args[i]); }
                        arg0Parsed = true;
                        break;
                    }
                    case &amp;quot;--bar&amp;quot;:
                    {
                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg1)) { ThrowArgumentParseFailed(&amp;quot;bar&amp;quot;, args[i]); }
                        arg1Parsed = true;
                        break;
                    }
                    default:
                        // omit...(case-insensitive compare codes)
                        ThrowArgumentNameNotFound(name);
                        break;
                }
            }
            if (!arg0Parsed) ThrowRequiredArgumentNotParsed(&amp;quot;foo&amp;quot;);
            if (!arg1Parsed) ThrowRequiredArgumentNotParsed(&amp;quot;bar&amp;quot;);

            command(arg0!, arg1!);
        }
        catch (Exception ex)
        {
            Environment.ExitCode = 1;
            if (ex is ValidationException or ArgumentParseFailedException)
            {
                LogError(ex.Message);
            }
            else
            {
                LogError(ex.ToString());
            }
        }
    }

    static partial void ShowHelp(int helpId)
    {
        Log(&amp;quot;&amp;quot;&amp;quot;
Usage: [options...] [-h|--help] [--version]

Options:
  --foo &amp;lt;int&amp;gt;     (Required)
  --bar &amp;lt;int&amp;gt;     (Required)
&amp;quot;&amp;quot;&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特にひねりもなさそうなド直球ドシンプルなコードに見えるのではないでしょうか。それが大事です！単純なコードであればあるほど速い！フレームワークなのに単純、だから速い。というのが目指している姿です。余計なコードはいっさいなく、メソッド本体に全ての処理が集約されているので、フレームワークとしてゼロ・オーバーヘッド、最適化した手書きコードと同等の速度を実現しました。&lt;/p&gt;
&lt;p&gt;CLIアプリケーションは通常、コールドスタートからの単発の実行になるため、動的コード生成(IL.EmitやExpression.Compile)やキャッシュ(ArrayPoolやDictionary生成による以降のマッチング高速化)が効きにくい分野です。それらを作ったほうがオーバーヘッドが大きいですから。かといってリフレクションなどをそのまま使うのは、それはそれで低速です。ConsoleAppFrameworkは全ての必要な処理をインライン生成することによって、単発実行での速度が圧倒的に高速化されています。&lt;/p&gt;
&lt;p&gt;リフレクションもないのでNative AOTとの親和性も圧倒的に高く、コールドスタートアップ速度におけるC#の欠点は一切なくなります。&lt;/p&gt;
&lt;p&gt;もう一つ特徴として、&lt;code&gt;ConsoleApp&lt;/code&gt;クラスを含めて、全てがSource Generatorによって生成されるために、ConsoleAppFramework自体も含めて依存が全くありません。&lt;/p&gt;
&lt;p&gt;コンソールアプリケーションを作るシチュエーションは多用です。多数の依存を持った大きなバッチアプリケーションの場合もあれば、超単機能の小さなコマンドの場合もあります。小さなコマンドを作りたい時には、少しも追加の依存を入れたくはないでしょう。それこそ &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; を参照すると、それだけで数十個の依存DLLが追加されてしまいます！ConsoleAppFrameworkなら、自身も含めて依存ゼロです。&lt;/p&gt;
&lt;p&gt;依存ゼロの良いところは明らかにバイナリサイズが小さくなることです。特にNative AOTではバイナリサイズは気になるところですが、ConsoleAppFrameworkなら追加のコストはほぼゼロです。&lt;/p&gt;
&lt;p&gt;そしてもちろん、単機能ではフレームワークとしては物足りない、ということで以下のような機能が実現されています。十分に充実した機能群は、他のフレームワークと比べても全く見劣りしないはずです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIGINT/SIGTERM(Ctrl+C) handling with gracefully shutdown via &lt;code&gt;CancellationToken&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter(middleware) pipeline to intercept before/after execution&lt;/li&gt;
&lt;li&gt;Exit code management&lt;/li&gt;
&lt;li&gt;Support for async commands&lt;/li&gt;
&lt;li&gt;Registration of multiple commands&lt;/li&gt;
&lt;li&gt;Registration of nested commands&lt;/li&gt;
&lt;li&gt;Setting option aliases and descriptions from code document comment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.ComponentModel.DataAnnotations&lt;/code&gt; attribute-based Validation&lt;/li&gt;
&lt;li&gt;Dependency Injection for command registration by type and public methods&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.Extensions&lt;/code&gt;(Logging, Configuration, etc...) integration&lt;/li&gt;
&lt;li&gt;High performance value parsing via &lt;code&gt;ISpanParsable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Parsing of params arrays&lt;/li&gt;
&lt;li&gt;Parsing of JSON arguments&lt;/li&gt;
&lt;li&gt;Help(&lt;code&gt;-h|--help&lt;/code&gt;) option builder&lt;/li&gt;
&lt;li&gt;Default show version(&lt;code&gt;--version&lt;/code&gt;) option&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成されるコードはモジュール化されていて、コードが使用する機能によって変化し、常にその機能の実現において最小のコードが生成されるようになっています。それにより多機能と高速さを両立しています。また、どの機能も最速で実行できるよう念入りに調整してあるため、全機能が有効化されてもなお、他とは比較にならないほどに高速です。&lt;/p&gt;
&lt;p&gt;余談ですが、デリゲートはデリゲート生成というアロケーションがあります。つまり真のゼロアロケーション・ゼロオーバーヘッドじゃないじゃん、と言うことができます。しかし、ちゃんとConsoleAppFrameworkは真のゼロアロケーションを実現する仕組みもちゃんと用意されています。以下のように静的関数をfunction pointerとして渡してください。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;unsafe
{
    ConsoleApp.Run(args, &amp;amp;Sum);
}

static void Sum(int x, int y) =&amp;gt; Console.Write(x + y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すると、以下のような &lt;code&gt;delegate* managed&amp;lt;&amp;gt;&lt;/code&gt; （あまり見慣れないと思いますが、managed function pointerという言語機能がC#には追加されているのです）の引数を持ったメソッドの実体を生成します。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static unsafe void Run(string[] args, delegate* managed&amp;lt;int, int, void&amp;gt; command)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これならもう完全に文句なくゼロアロケーション・ゼロオーバーヘッドです！&lt;/p&gt;
&lt;p&gt;実用的には別にデリゲートでも全く関係ないレベルですが、完全に完璧を目指す執拗な姿勢により、対応を入れました。これでどの角度からも絶対に文句は付けられないでしょう。&lt;/p&gt;
&lt;h2&gt;高速な値変換&lt;/h2&gt;
&lt;p&gt;文字列からC#の値に変換する最速の手段はなんでしょうか？intだったら &lt;code&gt;int.TryParse&lt;/code&gt; ですよね。では、他は？intは決め打ちだからいいとして、string -&amp;gt; T(あるいはobject)を汎用的にするには？というと少し難しい話になってきて、昔は&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.componentmodel.typeconverter?view=net-8.0"&gt;TypeConverter&lt;/a&gt;というものが使われてきました。もちろん、パフォーマンスは悪いです。&lt;/p&gt;
&lt;p&gt;あるいは最近はJsonSerializerが標準搭載されているから、それに丸投げしてみるというのもアリでしょう。もちろん、パフォーマンスは決して良くはありません。特にコールドスタートアップで考えるとJsonSerializerのキャッシュ処理が必要になってきて、単発実行においてはかなりのオーバーヘッドが足されてしまいます。&lt;/p&gt;
&lt;p&gt;ConsoleAppFrameworkでは&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.iparsable-1?view=net-8.0"&gt;IParsable&lt;/a&gt;, &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1?view=net-8.0"&gt;ISpanParsable&lt;/a&gt;を採用しています。これは .NET 7から追加され、C# 11で追加されたstatic abstract interfaceが使用されています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public interface IParsable&amp;lt;TSelf&amp;gt; where TSelf : IParsable&amp;lt;TSelf&amp;gt;?
{
	static abstract TSelf Parse(string s, IFormatProvider? provider);
	static abstract bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out TSelf result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C# 11になってようやく汎用的な 「文字列 -&amp;gt; 値」変換処理が実現するようになったのです！ ConsoleAppFrameworkでは .NET 8/C# 12 を最小実行可能環境としているため、問答無用で採用しました。HalfやInt128などの .NET 8で登場した新しい型や、自分で定義する方も&lt;code&gt;IParsable&amp;lt;T&amp;gt;&lt;/code&gt;を実装すればそれを使って高速に処理されます！&lt;/p&gt;
&lt;p&gt;とはいえ、intなどの基本型はそもそもSource Generatorがintであることを知っているので、直接int.TryParseのように直接実行されるようになっていたりはします。&lt;/p&gt;
&lt;p&gt;なお、値のバインディングに関してはparams arrayやデフォルト値にも対応しています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;ConsoleApp.Run(args, (
    [Argument]DateTime dateTime,  // Argument
    [Argument]Guid guidvalue,     // 
    int intVar,                   // required
    bool boolFlag,                // flag
    MyEnum enumValue,             // enum
    int[] array,                  // array
    MyClass obj,                  // object
    string optional = &amp;quot;abcde&amp;quot;,    // optional
    double? nullableValue = null, // nullable
    params string[] paramsArray 
    ) =&amp;gt; { });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちょうどC# 12から&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression"&gt;ラムダ式にデフォルト値やparamsが使用できるようになりました&lt;/a&gt;、ということが反映されています。&lt;/p&gt;
&lt;h2&gt;ドキュメントコメントによる定義&lt;/h2&gt;
&lt;p&gt;DescriptionやAliasの追加は、今までは、あるいは他のフレームワークでは属性を使って記述していました。しかし、それは少しメソッドの各パラメーターに属性、更にかなり長めの文字列を付与するのは、メソッドとしてかなり読みづらくなります。&lt;/p&gt;
&lt;p&gt;そこでConsoleAppFrameworkではドキュメントコメントを活用することにしました。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;class Commands
{
    /// &amp;lt;summary&amp;gt;
    /// Display Hello.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&amp;quot;message&amp;quot;&amp;gt;-m, Message to show.&amp;lt;/param&amp;gt;
    public static void Hello(string message) =&amp;gt; Console.Write($&amp;quot;Hello, {message}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-txt"&gt;Usage: [options...] [-h|--help] [--version]

Display Hello.

Options:
  -m|--message &amp;lt;string&amp;gt;    Message to show. (Required)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;というコマンドになります。ドキュメントコメントであれば、多くの引数があっても自然な見た目を保つことが可能です。この手法が取れるのはSource Generatorで生成するため.xmlは不要でコードから直接読み取れることの強みでもありますね。（ただしSource Generatorでドキュメントコメントをあらゆる環境で読み取れるようにするには若干のハックが必要でした）&lt;/p&gt;
&lt;h2&gt;複数コマンドの追加&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConsoleApp.Run&lt;/code&gt;は単独コマンドのためのショートカットでしたが、複数のコマンドやネストされているサブコマンドの追加も可能です。例えば以下のような設定を行った場合の生成を例を見ていきます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create();

app.Add(&amp;quot;foo&amp;quot;, () =&amp;gt; { });
app.Add(&amp;quot;foo bar&amp;quot;, (int x, int y) =&amp;gt; { });
app.Add(&amp;quot;foo bar barbaz&amp;quot;, (DateTime dateTime) =&amp;gt; { });
app.Add(&amp;quot;foo baz&amp;quot;, async (string foo = &amp;quot;test&amp;quot;, CancellationToken cancellationToken = default) =&amp;gt; { });

app.Run(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードのAddは、まず以下のように展開されます。Source Generatorが全てのAddされるラムダ式の型を知っているので、それぞれ固有の型を持ったフィールドに割り当てます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial struct ConsoleAppBuilder
{
    Action command0 = default!;
    Action&amp;lt;int, int&amp;gt; command1 = default!;
    Action&amp;lt;global::System.DateTime&amp;gt; command2 = default!;
    Func&amp;lt;string, global::System.Threading.CancellationToken, Task&amp;gt; command3 = default!;

    partial void AddCore(string commandName, Delegate command)
    {
        switch (commandName)
        {
            case &amp;quot;foo&amp;quot;:
                this.command0 = Unsafe.As&amp;lt;Action&amp;gt;(command);
                break;
            case &amp;quot;foo bar&amp;quot;:
                this.command1 = Unsafe.As&amp;lt;Action&amp;lt;int, int&amp;gt;&amp;gt;(command);
                break;
            case &amp;quot;foo bar barbaz&amp;quot;:
                this.command2 = Unsafe.As&amp;lt;Action&amp;lt;global::System.DateTime&amp;gt;&amp;gt;(command);
                break;
            case &amp;quot;foo baz&amp;quot;:
                this.command3 = Unsafe.As&amp;lt;Func&amp;lt;string, global::System.Threading.CancellationToken, Task&amp;gt;&amp;gt;(command);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりDelegateを保持しておくための配列や、DelegateのままInvokeするリフレクション/ボクシングが防げています。&lt;/p&gt;
&lt;p&gt;Runでは、&lt;code&gt;string[] args&lt;/code&gt;からコマンドを選択するために定数文字列のswitchが埋め込まれます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;partial void RunCore(string[] args)
{
    if (args.Length == 0)
    {
        ShowHelp(-1);
        return;
    }
    switch (args[0])
    {
        case &amp;quot;foo&amp;quot;:
            if (args.Length == 1)
            {
                RunCommand0(args, args.AsSpan(1), command0);
                return;
            }
            switch (args[1])
            {
                case &amp;quot;bar&amp;quot;:
                    if (args.Length == 2)
                    {
                        RunCommand1(args, args.AsSpan(2), command1);
                        return;
                    }
                    switch (args[2])
                    {
                        case &amp;quot;barbaz&amp;quot;:
                            RunCommand2(args, args.AsSpan(3), command2);
                            break;
                        default:
                            RunCommand1(args, args.AsSpan(2), command1);
                            break;
                    }
                    break;
                case &amp;quot;baz&amp;quot;:
                    RunCommand3(args, args.AsSpan(2), command3);
                    break;
                default:
                    RunCommand0(args, args.AsSpan(1), command0);
                    break;
            }
            break;
        default:
            ShowHelp(-1);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C#で文字列から特定のコードにジャンプする最速の手段は、switchで文字列定数を使うことです。展開されるアルゴリズムは何度か修正されていて、C# 12では&lt;a href="https://github.com/dotnet/roslyn/issues/56374"&gt;Performance: faster switch over string objects · Issue #56374 · dotnet/roslyn&lt;/a&gt;として、まず長さをチェックした後に、差が存在する1文字だけを絞るといった形でマッチさせます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dictionary&amp;lt;string, T&amp;gt;&lt;/code&gt;からのマッチなどよりも高速で初期化時間もアロケーションもないのが、C#コンパイラの助けを借りれる強みであり、そうした処理ができるのはC#コードそのものを出力するSource Generator方式だけです。なので絶対に最速なわけです。&lt;/p&gt;
&lt;h2&gt;DIとCancellationTokenとライフタイム&lt;/h2&gt;
&lt;p&gt;引数にはコマンドのパラメーターとして有効になるもの以外に、DI経由で渡したいもの(例えば&lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;など)や、特別扱いする型として&lt;code&gt;ConsoleAppContext&lt;/code&gt;と&lt;code&gt;CancellationToken&lt;/code&gt;を定義することができます。&lt;/p&gt;
&lt;p&gt;DIによる受取は、コンソールアプリケーションがASP.NETのプロジェクトなどと設定ファイルを共有したいようなシチュエーションで有効でしょう。そうした場合のために、 Microsoft.Extensions.Hosting と連動させることが可能です。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;CancellationToken&lt;/code&gt;を渡した場合は、SIGINT/SIGTERM/SIGKILL(Ctrl+C)をフックするコンソールアプリケーションとしてのライフタイム管理が働くようになります。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;await ConsoleApp.RunAsync(args, async (int foo, CancellationToken cancellationToken) =&amp;gt;
{
    await Task.Delay(TimeSpan.FromSeconds(5), cancellationToken);
    Console.WriteLine($&amp;quot;Foo: {foo}&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードは以下のように展開されます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using var posixSignalHandler = PosixSignalHandler.Register(ConsoleApp.Timeout);
var arg0 = posixSignalHandler.Token;

await Task.Run(() =&amp;gt; command(arg0!)).WaitAsync(posixSignalHandler.TimeoutToken);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET 6から追加された&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration?view=net-8.0"&gt;PosixSignalRegistration&lt;/a&gt;を使って、SIGINT/SIGTERM/SIGKILLがフックし、CancellationTokenをキャンセルの状態にします。と同時に、即時終了を抑制します(通常Ctrl + Cを押すと即座にAbortされますが、Abortされなくなります)。&lt;/p&gt;
&lt;p&gt;それによりアプリケーションがCancellationTokenを正常にハンドリングする余地を残しています。&lt;/p&gt;
&lt;p&gt;ただしCancellationTokenをハンドリングしないと終了命令を無視するだけになってしまい、それはそれで困るので、強制的に終了するタイムアウト時間が設けられています。デフォルトでは5秒に設定されていますが、これは &lt;code&gt;ConsoleApp.Timeout&lt;/code&gt; プロパティで自由に変更できます。もし強制終了をオフにしたい場合は &lt;code&gt;ConsoleApp.Timeout = Timeout.InfiniteTimeSpan&lt;/code&gt; を指定すると良いでしょう。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.waitasync?view=net-8.0"&gt;Task.WaitAsync&lt;/a&gt;は .NET 6 からです。TimeSpanを渡す以外に、CancellationTokenを渡すことも可能なので、単純な数秒後ではなく、WaitAsyncの発火するタイミングをPosixSignalRegistrationが発火した後にTimeout後、といった条件を作ることができました。&lt;/p&gt;
&lt;h2&gt;フィルターパイプライン&lt;/h2&gt;
&lt;p&gt;実行の前後をフックする仕組みとしてConsoleAppFrameworkではFilterを採用しています。ミドルウェアパターンとも呼ばれて、特にasync/awaitが使える言語ではよく見かけるパターンだと思います。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;internal class NopFilter(ConsoleAppFilter next) : ConsoleAppFilter(next) // ctor needs `ConsoleAppFilter next` and call base(next)
{
    // implement InvokeAsync as filter body
    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        try
        {
            /* on before */
            await Next.InvokeAsync(context, cancellationToken); // invoke next filter or command body
            /* on after */
        }
        catch
        {
            /* on error */
            throw;
        }
        finally
        {
            /* on finally */
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この設計パターンは本当に優れていて、実行をフックしたいような仕組みを用意したい場合は、このパターンを採用することを絶対にお薦めします。GoFの時代にasync/awaitがあったら、重要なデザインパターンとして載っていたことでしょう。&lt;/p&gt;
&lt;p&gt;ReadMeにはフィルターでできることとして、実行時間のロギング・ExitCodeのカスタマイズ・多重実行禁止・認証処理などを紹介しています。&lt;code&gt;Task InvokeAsync&lt;/code&gt;一つで様々な処理を実現できる素晴らしさ。誰がこのパターンを最初に発見したんでしょうね？&lt;/p&gt;
&lt;p&gt;フィルターの設計にも色々な手法があるのですが、ConsoleAppFrameworkでは最もパフォーマンスの出る方法を選びました。コンストラクターでNextを受け取ることと、コードジェネレート時に静的に全ての利用するフィルターが決定するので（動的な追加は許可していません）、全てを埋め込んで組み立てています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();
app.UseFilter&amp;lt;NopFilter&amp;gt;();

// The above code will generate the following code:

sealed class Command0Invoker(string[] args, Action command) : ConsoleAppFilter(null!)
{
    public ConsoleAppFilter BuildFilter()
    {
        var filter0 = new NopFilter(this);
        var filter1 = new NopFilter(filter0);
        var filter2 = new NopFilter(filter1);
        var filter3 = new NopFilter(filter2);
        var filter4 = new NopFilter(filter3);
        return filter4;
    }

    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)
    {
        return RunCommand0Async(context.Arguments, args, command, context, cancellationToken);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これにより、中間の配列のアロケーションや、ラムダ式のキャプチャのアロケーションは発生せず、フィルターの個数 + 1(メソッド本体のラップ)の追加のアロケーションのみが追加のコストとなります。また、戻り値のTaskは、同期的に完了する場合はTask.Completed相当のものが使われることになるため、これをValueTaskにする必要はありません。&lt;/p&gt;
&lt;p&gt;コンストラクターでNextを受け取ってbaseに渡すだけのコードも、primary constructorのお陰で簡単に書けるようになりました。&lt;/p&gt;
&lt;h2&gt;コマンドライン引数の構文について&lt;/h2&gt;
&lt;p&gt;コマンドライン引数はスペース区切りで&lt;code&gt;string[] args&lt;/code&gt;に渡されるということ以外は、完全に自由です。なんとなく &lt;code&gt;--&lt;/code&gt;や&lt;code&gt;-&lt;/code&gt;がパラメーター識別子だと思われていますが、実際はなんでもいいし、なんだったらWindowsは&lt;code&gt;/&lt;/code&gt;が使われることも多かった。&lt;/p&gt;
&lt;p&gt;とはいえ、ある程度標準的なルールは存在します。代表的なものは&lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html"&gt;POSIX規格&lt;/a&gt;と、その拡張である&lt;a href="https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html"&gt;GNU Coding Standards&lt;/a&gt;でしょうか。ConsoleAppFrameworkでも、POSIX規格にある程度は従いつつ、GNU Coding Stadardsで定義されている &lt;code&gt;--version&lt;/code&gt; と &lt;code&gt;--help&lt;/code&gt; を組み込みのオプションとしています。名前も &lt;code&gt;--lower-kebab-case&lt;/code&gt; がデフォルトです。&lt;/p&gt;
&lt;p&gt;「ある程度」というのは、つまり、完全に従っているというわけではありません。規格にせよ伝統的な慣習にせよ、古いルールは現代的な観点から許容すべきでないルールも少なくありません。例えば&lt;code&gt;-x&lt;/code&gt;と&lt;code&gt;-X&lt;/code&gt;が区別されて異なる挙動をするというのは絶対にナシでしょう。あるいは広く使われているものでもバンドリング、&lt;code&gt;-fdx&lt;/code&gt;は&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;と解釈されるといったものも、あまり良いとは思えません。バンドリングに関しては、パフォーマンス上でも、パース処理を複雑化させるため問題があります。&lt;/p&gt;
&lt;p&gt;ConsoleAppFrameworkで優先しているのはパフォーマンスであるため、パフォーマンス上問題を引き起こす可能性のあるルールに関しては採用していません。大文字小文字の区別はしないようにしていますが、これは小文字のマッチングを先に行った後、フォールバックとしてcase-insensitiveのマッチングを行うため、実用上のパフォーマンスの低下は起こらないと考えています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/commandline/syntax"&gt;System.CommandLine のコマンド ライン構文の概要 - .NET | Microsoft Learn&lt;/a&gt;を見ると、System.CommandLineがかなり柔軟な構文解釈を可能にしていることがわかるでしょう。それはとても良いことです！良いことではあるのですが、パフォーマンス劣化を引き起こしているなら問題です。そして実際、System.CommandLineの性能はベンチマーク結果から明らかなとおり、非常に悪い。これはちょっといただけません。&lt;/p&gt;
&lt;p&gt;迷走を続けている&lt;a href="https://github.com/dotnet/command-line-api"&gt;System.CommandLine&lt;/a&gt;は、どうやら再度分解されて実装を変更するようです。&lt;a href="https://github.com/dotnet/command-line-api/issues/2338"&gt;Resetting System.CommandLine&lt;/a&gt;ということで、POSIX規格のパーサーとしての小さなコアを.NET 9 あるいは .NET 10で標準採用されることを目指している、ようです。&lt;/p&gt;
&lt;p&gt;もしそれらが標準採用されたとしても、パフォーマンスの観点からは、ConsoleAppFrameworkを超えることは絶対にないでしょう。&lt;/p&gt;
&lt;h2&gt;v4からの互換性について&lt;/h2&gt;
&lt;p&gt;破壊的変更！破壊的変更を厭わないことはいいことです、イノベーションを妨げない、常に先端的であり続けるために必要なことです。C#の先端を走り続けるのはCysharpのアイデンティティでもあります。と、同時に、もちろん大迷惑なことです。今回の v4 -&amp;gt; v5 に関しては .NET Frameworkから.NET Coreに変わったような、 ASP.NET から ASP.NET Coreに変わったような、そんな変革なのでしょうがない、どうしても必要な変化だったのだ……。&lt;/p&gt;
&lt;p&gt;ただし、実際のところは別にそこまで大きく変わっているわけではなかったりもします。名前変換処理(lower-kebab-case)のロジックは同じものを使っているため、名前がズレてしまうといったこともないので、コンパイルエラー出たメソッド名をマッピングするだけ、ではあります。そのぐらいのことはよくある、よね？&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;var app = ConsoleApp.Create(args); app.Run(); -&amp;gt; var app = ConsoleApp.Create(); app.Run(args);
app.AddCommand/AddSubCommand -&amp;gt; app.Add(string commandName)
app.AddRootCommand -&amp;gt; app.Add(&amp;quot;&amp;quot;)
app.AddCommands&amp;lt;T&amp;gt; -&amp;gt; app.Add&amp;lt;T&amp;gt;
app.AddSubCommands&amp;lt;T&amp;gt; -&amp;gt; app.Add&amp;lt;T&amp;gt;(string commandPath)
app.AddAllCommandType -&amp;gt; NotSupported(use Add&amp;lt;T&amp;gt; manually)
[Option(int index)] -&amp;gt; [Argument]
[Option(string shortName, string description)] -&amp;gt; Xml Document Comment
ConsoleAppFilter.Order -&amp;gt; NotSupported(global -&amp;gt; class -&amp;gt; method declrative order)
ConsoleAppOptions.GlobalFilters -&amp;gt; app.UseFilter&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全体的には、より単純化された、ようするに「良くなった」と思ってもらえる仕様変更だとは思います。&lt;/p&gt;
&lt;p&gt;また、標準で &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; に乗っからなくなったというのは大きな違いですが、これは一行追加するだけで解決します。Hostingの上に乗っかるというのは、つまりはHostingで生成するServiceProviderを使う、それだけのことなのだ、と。実際はLifetime管理もありますが、それはConsoleAppFrameworkが自前でやっているので、DIのためのServiceProviderだけ渡してやれば実用上の違いはありません。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using var host = Host.CreateDefaultBuilder().Build(); // use using for host lifetime
ConsoleApp.ServiceProvider = host.ServiceProvider;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;v4では&lt;code&gt;ConsoleAppBase&lt;/code&gt;を継承させていましたが、v5ではPOCOでよくなりました。代わりに&lt;code&gt;ConsoleAppContext&lt;/code&gt;や&lt;code&gt;CancellationToken&lt;/code&gt;に関してはコンストラクタインジェクションで受け取ってください。これも、C# 12のprimary constructorのお陰でそんなに手間じゃなくなりました。これもベースクラスを必要とする仕組みをやめた理由の一つになります。&lt;/p&gt;
&lt;h2&gt;真のIncremental Generator&lt;/h2&gt;
&lt;p&gt;Incremental Generatorって、ただたんに何も考えずに作るとIncrementalにならないのです。というのは知識として知ってはいたのですが、今まで見て見ぬふりをしていました！ありがたいことに指摘が入ったので、重い腰を上げてちゃんと抜本的な対応を取ることにしました。&lt;/p&gt;
&lt;p&gt;まず最初にやらなければならないのは、Incrementalであるかどうかを視認できるようにすることです。普通に動かしていても内部状態は全く見えないので、ユニットテストで状態をチェックできるようにすることが大事です。例えばこんなユニットテストが書かれています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;    [Fact]
    public void RunLambda()
    {
        var step1 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&amp;gt; 0);
&amp;quot;&amp;quot;&amp;quot;;

        var step2 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int () =&amp;gt; 100); // body change

Console.WriteLine(&amp;quot;foo&amp;quot;); // unrelated line
&amp;quot;&amp;quot;&amp;quot;;

        var step3 = &amp;quot;&amp;quot;&amp;quot;
using ConsoleAppFramework;

ConsoleApp.Run(args, int (int x, int y) =&amp;gt; 100); // change signature

Console.WriteLine(&amp;quot;foo&amp;quot;);
&amp;quot;&amp;quot;&amp;quot;;

        var reasons = CSharpGeneratorRunner.GetIncrementalGeneratorTrackedStepsReasons(&amp;quot;ConsoleApp.Run.&amp;quot;, step1, step2, step3);

        reasons[0][0].Reasons.Should().Be(&amp;quot;New&amp;quot;);
        reasons[1][0].Reasons.Should().Be(&amp;quot;Unchanged&amp;quot;);
        reasons[2][0].Reasons.Should().Be(&amp;quot;Modified&amp;quot;);

        VerifySourceOutputReasonIsCached(reasons[1]);
        VerifySourceOutputReasonIsNotCached(reasons[2]);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Incremental Generatorは &lt;code&gt;trackIncrementalGeneratorSteps: true&lt;/code&gt; というオプションを渡してDriverを動かすと、各ステップの状態の結果が見えるようになります。&lt;code&gt;IncrementalStepRunReason&lt;/code&gt;には&lt;code&gt;New&lt;/code&gt;, &lt;code&gt;Unchanged&lt;/code&gt;, &lt;code&gt;Modified&lt;/code&gt;, &lt;code&gt;Cached&lt;/code&gt;, &lt;code&gt;Removed&lt;/code&gt; という状態があり、最終出力の手前が&lt;code&gt;Unchanged&lt;/code&gt;か&lt;code&gt;Cached&lt;/code&gt;なら、出力処理がスキップされます。&lt;/p&gt;
&lt;p&gt;上のユニットテストではstep2では出力コードに変更のない箇所に変更が加わっただけなので、Unchangedです。なので最終段ではCachedになっていました。step3は再生成が必要な変更が加わっているのでModifiedとなり、ソースコード生成処理まで走ります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IncrementalStepRunReason&lt;/code&gt;は&lt;code&gt;TrackedSteps&lt;/code&gt;から取り出すことが出来るのですが、そのままだとちょっと読みづらすぎるので、確認しやすいように整形しています、というのが&lt;code&gt;GetIncrementalGeneratorTrackedStepsReasons&lt;/code&gt;というユーティリティメソッドです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static (string Key, string Reasons)[][] GetIncrementalGeneratorTrackedStepsReasons(string keyPrefixFilter, params string[] sources)
{
    var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp12); // 12
    var driver = CSharpGeneratorDriver.Create(
        [new ConsoleAppGenerator().AsSourceGenerator()],
        driverOptions: new GeneratorDriverOptions(IncrementalGeneratorOutputKind.None, trackIncrementalGeneratorSteps: true))
        .WithUpdatedParseOptions(parseOptions);

    var generatorResults = sources
        .Select(source =&amp;gt;
        {
            var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));
            driver = driver.RunGenerators(compilation);
            return driver.GetRunResult().Results[0];
        })
        .ToArray();

    var reasons = generatorResults
        .Select(x =&amp;gt; x.TrackedSteps
            .Where(x =&amp;gt; x.Key.StartsWith(keyPrefixFilter) || x.Key == &amp;quot;SourceOutput&amp;quot;)
            .Select(x =&amp;gt;
            {
                if (x.Key == &amp;quot;SourceOutput&amp;quot;)
                {
                    var values = x.Value.Where(x =&amp;gt; x.Inputs[0].Source.Name?.StartsWith(keyPrefixFilter) ?? false);
                    return (
                        x.Key,
                        Reasons: string.Join(&amp;quot;, &amp;quot;, values.SelectMany(x =&amp;gt; x.Outputs).Select(x =&amp;gt; x.Reason).ToArray())
                    );
                }
                else
                {
                    return (
                        Key: x.Key.Substring(keyPrefixFilter.Length),
                        Reasons: string.Join(&amp;quot;, &amp;quot;, x.Value.SelectMany(x =&amp;gt; x.Outputs).Select(x =&amp;gt; x.Reason).ToArray())
                    );
                }
            })
            .OrderBy(x =&amp;gt; x.Key)
            .ToArray())
        .ToArray();

    return reasons;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ごちゃごちゃしてよくわからないという感じですが、つまりそのままだと本当によくわからない代物ということで。Keyに関しては各ステップで &lt;code&gt;.WithTrackingName(&amp;quot;ConsoleApp.Run.0_CreateSyntaxProvider&amp;quot;)&lt;/code&gt; のような命名規則で付与しています。TrackedStepsが&lt;code&gt;ImmutableDictionary&lt;/code&gt;のため列挙の順番が順不同でイマイチ確認しづらいので、番号振ってソートするようにしました。また、複数のRegisterSourceOutputが走っていると(ConsoleAppFrameworkではRun系とBuilder系の2種が動いてる)混線してわかりづらくなるため、keyPrefixとしてフィルタリングするようにしています。&lt;/p&gt;
&lt;p&gt;注意すべき点とか、いい感じに作る方法とか、色々説明しておかなければならないことが多いのですが、めちゃくちゃ長くなるので、それはまたの機会ということで……！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;もともとConsoleAppFrameworkはCysharpの製品ラインでは珍しく、パフォーマンスを重視していたわけではない、という成り立ちがあります。どちらかというと機能面、当時それなりに珍しかったHostingと融合してCLIフレームワークを作るといったコンセプトの立証を主軸に作り上げ、そして一定の成果を挙げました。何回かの改修でHelpがリッチになったりMinimal APIっぽく書けるようになったりもしましたが、どうしても古くささが目立ってきました。&lt;/p&gt;
&lt;p&gt;特に&lt;a href="https://github.com/mayuki/Cocona"&gt;Cocona&lt;/a&gt;は、ConsoleAppFrameworkの影響を受けつつも、より柔軟で、より強力な機能を備えていてとても素晴らしいライブラリです。このままではConsoleAppFrameworkはただの劣化版ではないか、という意識もありました。自信をもってベストであると薦められないのは心苦しい。というかCoconaを作っているのはCysharpの同僚ですしですの。&lt;/p&gt;
&lt;p&gt;なので、今回APIの幾つかは逆にCoconaからの影響を受けつつ(&lt;code&gt;[Argument]&lt;/code&gt;など)、全く異なるキャラクターを持ったフレームワークとなるように腐心しました。パースについての項目で説明したように、ConsoleAppFramework v5は柔軟性をある程度犠牲にしているため、豊富な機能が必要ならば、System.CommandLineやCoconaを使用することをお薦めします。&lt;/p&gt;
&lt;p&gt;また、パフォーマンスの観点から言うと、本体の実行時間が長ければ長いほどフレームワークのオーバーヘッドなんてどうでもよくはなります。10分、1分、いや、10秒ぐらいかかる処理であるなら、フレームワーク部分が1msだろうと50msだろうと誤差みたいなものでしょう。それはそもそもJITコンパイルにも言えることではありますが。とはいえ、Native AOTだのコールドスタートアップ速度だのがやいやい言われる昨今では、別にそんなもの無視できる程度の話だろう、と一刀両断できるわけでもなく、早いに越したことはないのは間違いないとも言えます。&lt;/p&gt;
&lt;p&gt;パフォーマンスや依存性なしといったメリットはもちろんですが、アプローチや設計面でも特異で面白いものになっていると思いますので、是非お試しください！もちろん、実用性もめちゃくちゃ高く、文句なしに必須ライブラリと考えてもらってもいいのではないでしょうか！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-06-13T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/05/01_R3_Presentation.html</guid>
      <link>https://neue.cc/2024/05/01_R3_Presentation.html</link>
      <title>R3のコードから見るC#パフォーマンス最適化技法実例とTimeProviderについて</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-05-01" data-pagefind-meta="published:2024-05-01"&gt;&lt;a href="https://neue.cc/2024/05/01_R3_Presentation.html"&gt;R3のコードから見るC#パフォーマンス最適化技法実例とTimeProviderについて&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-05-01&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;4/27に大阪で開催された&lt;a href="https://cs-reading.connpass.com/event/309714/"&gt;C#パフォーマンス勉強会&lt;/a&gt;で「R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例」という題でセッションしてきました！&lt;/p&gt;
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/205627770b434599925567dbfeca229c" title="R3のコードから見る実践LINQ実装最適化・コンカレントプログラミング実例" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"&gt;&lt;/iframe&gt;
&lt;p&gt;タイトル的にあまりLINQでもコンカレントでもなかったかな、とは思いますが、&lt;a href="https://github.com/Cysharp/R3"&gt;R3&lt;/a&gt;を題材に、具体的なコードをもとにした最適化技法の紹介という点では面白みはあったのではないかと思います。&lt;/p&gt;
&lt;h2&gt;Rxの定義&lt;/h2&gt;
&lt;p&gt;R3は、やや挑発的な内容を掲げていることもあり、R3は「Rxではない」みたいなことを言われることもあります。なるほど！では、そもそも何をもってRxと呼ぶのか、呼べるのか。私は「Push型でLINQ風のオペレーターが適用できればRx」というぐらいの温度感で考えています。もちろん、R3はそれを満たしています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mutable struct&lt;/code&gt;の扱いと同じく、あまり教条主義的にならず、時代に合わせて、柔軟により良いシステムを考えていきましょう。コンピュータープログラミングにおいて、伝統や歴史を守ることは別に大して重要なことではないはずです。&lt;/p&gt;
&lt;h2&gt;TimeProvider DeepDive&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0"&gt;TimeProvider&lt;/a&gt;について、セッションでも話しましたが、大事なことなのでもう少し詳しくいきましょう。TimeProviderにまず期待するところとしては、ほとんどが&lt;code&gt;SystemClock.Now&lt;/code&gt;、つまりオレオレ&lt;code&gt;DateTime.Now&lt;/code&gt;生成器の代わりを求めているでしょう。それを期待しているとTimeProviderの定義は無駄に複雑に見えます。しかし&lt;code&gt;TimeProvider&lt;/code&gt;を分解してみると、これは4つの時間を司るクラスの抽象層になっています。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public abstract class TimeProvider
{
    // TimeZoneInfo
    public virtual TimeZoneInfo LocalTimeZone =&amp;gt; TimeZoneInfo.Local;

    // DateTimeOffset
    public virtual DateTimeOffset GetUtcNow() =&amp;gt; DateTimeOffset.UtcNow;
    public DateTimeOffset GetLocalNow() =&amp;gt;

    // Stopwatch
    public virtual long TimestampFrequency =&amp;gt; Stopwatch.Frequency;
    public virtual long GetTimestamp() =&amp;gt; Stopwatch.GetTimestamp();
    public TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp) =&amp;gt; 
    public TimeSpan GetElapsedTime(long startingTimestamp) =&amp;gt; GetElapsedTime(startingTimestamp, GetTimestamp());

    // System.Threading.Timer
    public virtual ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period) =&amp;gt;
}

public interface ITimer : IDisposable, IAsyncDisposable
{
    bool Change(TimeSpan dueTime, TimeSpan period);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4つの時間を司るクラス、すなわち&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timezoneinfo?view=net-8.0"&gt;TimeZoneInfo&lt;/a&gt;、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.datetimeoffset?view=net-8.0"&gt;DateTimeOffset&lt;/a&gt;、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch?view=net-8.0"&gt;Stopwatch&lt;/a&gt;、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.threading.timer?view=net-8.0"&gt;System.Threading.Timer&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;この造りになっているからこそ、あらゆる時間にまつわる挙動を任意に変更することができるのです。&lt;/p&gt;
&lt;p&gt;挙動を任意に変更するというとユニットテストでの時間のモックにばかり意識が向きますが（実際、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.time.testing.faketimeprovider?view=net-8.0"&gt;FakeTimeProvider&lt;/a&gt;はとても有益です）、別にユニットテストに限らず、優れた時間の抽象化層として使うことができます。ということを実装とともに証明したのがR3で、特にR3では&lt;code&gt;CreateTimer&lt;/code&gt;をかなり弄っていて、WPFではDispatcherTimerを使うことで自動的にUIスレッドにディスパッチしたり、UnityではPlayerLoopベースのタイマーとしてScaledとUnsacledでTimescaleの影響を受けるタイマー・受けないタイマーなどといった実行時のカスタマイズ性を実現しました。&lt;/p&gt;
&lt;p&gt;セッションではStopwatchについてフォーカスしました。二点の時刻の経過時間を求めるのにDateTimeの引き算、つまり&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;DateTime now = DateTime.UtcNow;
/* do something... */
TimeSpan elapesed = DateTime.UtcNow - now;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったコードを書くのはよくあることですが、これはバッドプラクティスです。DateTimeの取得はタダではありません。では、なるほどStopwatchですね？ということで&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;Stopwatch sw = Stopwatch.StartNew();
/* do something... */
TimeSpan elapsed = sw.Elapsed;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、Stopwatchがclassなのでアロケーションがあります。うまく使いまわしてあげる必要があります。
使いまわしができないシチュエーションのために、アロケーションを避けるためにstructのStopwatch、ValueStopwatchといったカスタム型を作ることもありますが、待ってください、そもそもStopwatchが不要です。&lt;/p&gt;
&lt;p&gt;二点の経過時間を求めるなら、時計による時刻も不要で、その地点の何らかのタイムスタンプが取れればそれで十分なのです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;// .NET 7以降での手法(GetElapsedTimeが追加された)
long timestamp = Stopwatch.GetTimestamp();
/* do something... */
TimeSpan elapsed = Stopwatch.GetElapsedTime(timestamp);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このlongは、通常は高解像度タイムスタンプ、Windowsでは&lt;a href="https://learn.microsoft.com/ja-jp/windows/win32/sysinfo/acquiring-high-resolution-time-stamps"&gt;QueryPerformanceCounter&lt;/a&gt;が使われています。TimeSpanでよく使うTicksではないことに注意してください。&lt;/p&gt;
&lt;p&gt;ベンチマークを取ってみましょう。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using BenchmarkDotNet.Attributes;
using System.Diagnostics;

BenchmarkDotNet.Running.BenchmarkRunner.Run&amp;lt;TimestampBenchmark&amp;gt;();

public class TimestampBenchmark
{
    [Benchmark]
    public long Stopwatch_GetTimestamp()
    {
        return Stopwatch.GetTimestamp();
    }

    [Benchmark]
    public DateTime DateTime_UtcNow()
    {
        return DateTime.UtcNow;
    }

    [Benchmark]
    public DateTime DateTime_Now()
    {
        return DateTime.Now;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/R3/assets/46207/75122cc7-c303-493f-bc78-40388529cf60" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;NowではUtcNowに加えてTimeZoneからのオフセット算出が入るために更にもう一段遅くなります。&lt;/p&gt;
&lt;p&gt;ちなみに、2点間の時間の算出にDateTimeではなくTimestampを使うもう一つの利点としては、システム時間の変更の影響を受けないという点があります。dotnet/reactiveではISchedulerがDateTimeOffsetベースで作られていたため、ISchedulerインターフェイスそのものがこの問題の影響を避けられないために、内部的にゴチャゴチャしたハックが繰り返され、パフォーマンスの大幅な劣化にも繋がっていました。&lt;/p&gt;
&lt;p&gt;なお、マイクロベンチマークを取るときは必ず&lt;a href="https://github.com/dotnet/BenchmarkDotNet"&gt;BenchmarkDotNet&lt;/a&gt;を使ってください。(micro)benchmark is hard、です。Stopwatchで測られても、あらゆる要因から誤差が出まくるし、そもそも指標もよくわからないしで、数字を見ても何もわかりません。私はそういう数字の記事とかを見た場合、役に立たないと判断して無視します。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;セッション資料に盛り込めた最適化技法の紹介は極一部ではありますが、R3がどれだけ気合い入れて作られているかが伝わりましたでしょうか？10年の時を経て、私自身の成長とC#の成長が合わさり、UniRxからクオリティが桁違いです。&lt;/p&gt;
&lt;p&gt;これからも足を止めずにやっていきますし、みなさんも是非モダンC#やっていきましょう……！（Unityも十分モダンC#の仲間入りで良いです！）&lt;/p&gt;
&lt;p&gt;そういえばブログに貼り付けるのを忘れてたのですが3月末にはこんなセッションもしていました。&lt;/p&gt;
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/c5a8898ac7c4464584068b0ee3180e94" title=".NETの非同期戦略とUnityとの相互運用" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"&gt;&lt;/iframe&gt;
&lt;p&gt;ええ、ええ。Unityもモダンですよ！大丈夫！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Wed, 01 May 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-05-01T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/03/19_Garnet.html</guid>
      <link>https://neue.cc/2024/03/19_Garnet.html</link>
      <title>Redis互換の超高速インメモリデータストア「Garnet」にC# CustomCommandを実装してコマンドを拡張する</title>
      <description>&lt;h1 data-pagefind-sort="date:2024-03-19" data-pagefind-meta="published:2024-03-19"&gt;&lt;a href="https://neue.cc/2024/03/19_Garnet.html"&gt;Redis互換の超高速インメモリデータストア「Garnet」にC# CustomCommandを実装してコマンドを拡張する&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-03-19&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Microsoftから&lt;a href="https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/"&gt;Introducing Garnet – an open-source, next-generation, faster cache-store for accelerating applications and services&lt;/a&gt;という記事が今日公開されて、Garnetという新しいインメモリデータストアがOSSとして公開されました。Microsoft Researchで&lt;a href="https://github.com/microsoft/FASTER"&gt;FASTER&lt;/a&gt;を手掛けていたチームによるもので、FASTERはC#実装の高速なキーバリューストアでした。今回のGarnetはその発展形のようなもので、FASTERベースのストレージと、Redis互換のプロトコルによる、インメモリデータストアになっています。詳しくはGarnetのほうのブログ&lt;a href="https://microsoft.github.io/garnet/blog/brief-history"&gt;A Brief History of Garnet&lt;/a&gt;で。GarnetもC#で作られています。&lt;/p&gt;
&lt;p&gt;ベンチマークによると、Redisはもちろんのこと、DragonflyというRedis互換の世界最速のインメモリデータストア（を公式で謳ってる）&lt;a href="https://www.dragonflydb.io/"&gt;Dragonfly&lt;/a&gt;よりも高速、だそうで。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/neuecc/Blog2/assets/46207/f6192d51-f100-403b-a49d-94012b046110" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;このグラフ、そこまで大きな差がないように見えますが対数グラフになっていて、Redisが1,000.00 kops/sec に対して、100,000.00 kops/secって言ってます。100倍です！えー。&lt;/p&gt;
&lt;p&gt;そもそもRedisの速度に関していうと、シングルスレッドベースであることなどから、たまによくそこまで速くはないというのは言われてきていて、先述のDragonflyは&lt;a href="https://www.publickey1.jp/blog/22/redis25dragonfly2022.html"&gt;Redis互換で25倍高速とする「Dragonfly」が登場。2022年の最新技術でインメモリデータストアを実装&lt;/a&gt;などというリリースとともに、現代の技術で作り直せばもっともっと速くなる、とはされてきました。とはいえ、単純なGET/SETだけのメモリキャッシュとは比較にならない豊富なデータ型など利便性がとても高く、いうて別にそこまで遅いというわけでもないので、特に気にすることなく使われ続けているのではないでしょうか。&lt;/p&gt;
&lt;p&gt;GarnetはC#で作られていますが、当然ながらC#専用ではなく、汎用的なRedisサーバーとして動作するため、既存のRedisクライアントで直接繋げることができます。Redisはそのプロトコル&lt;a href="https://redis.io/docs/reference/protocol-spec/"&gt;Redis serialization protocol(RESP)&lt;/a&gt;の仕様を公開しているため、互換サーバーが作りやすいというわけですね、素晴らしい……！&lt;/p&gt;
&lt;p&gt;C#から使う場合は&lt;a href="https://github.com/StackExchange/StackExchange.Redis"&gt;StackExchange.Redis&lt;/a&gt;と、Garnet同梱のGarent Clientのどちらかが使えます。パッとGarnet Clientを見た限り、現状現実的に使うならStackExchange.Redisですね。最低限は用意されているけれど、Redisクライアントとして使うには、しんどみがありそうです。ただ、性能面ではGarnet Clientのほうが良さそうです。StackExchange.Redisも、前身のBookSleeveから数えると初期設計が10年以上前のものになっているので、現代の観点から見ると設計は古く、パフォーマンス的にも、この実装は悪そうだな、と思えるところがかなりあります。なのでロマンを追いかけるならGarnet Clientを使うのも面白くはあります……！&lt;/p&gt;
&lt;h2&gt;C#でカスタムコマンドを実装する&lt;/h2&gt;
&lt;p&gt;普通にRedis互換サーバーとして立てて使うのもいいのですが、C#使いなら面白い点があって、Garnetをライブラリとして参照して(NuGet: Microsoft.Garnet)、アプリケーションに組み込んでのセルフホストができます。例えばロガーとして&lt;a href="https://github.com/Cysharp/ZLogger/"&gt;ZLogger&lt;/a&gt;を差し込んでVerboseでログを出してみたりとか、ちょっと使いやすくていい感じです。ローカル開発とかだったらDockerでRedis動かして、などではなく、ソリューションにGarnetをそのまま組み込んで&lt;a href="https://github.com/dotnet/aspire"&gt;.NET Aspire&lt;/a&gt;で同時起動させるとかもいい感じでしょう。RedisはWindowsでは動かないので(大昔にMicrosoftがForkして動かせるようにしたプロジェクトがありましたが！)、ちゃんと動く互換サーバーが出てきたこと自体がとても嬉しかったりもします。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Garnet;
using Microsoft.Extensions.Logging;
using ZLogger;

try
{
    var loggerFactory = LoggerFactory.Create(x =&amp;gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole(options =&amp;gt;
        {
            options.UsePlainTextFormatter(formatter =&amp;gt;
            {
                formatter.SetPrefixFormatter($&amp;quot;[{0}]&amp;quot;, (in MessageTemplate template, in LogInfo info) =&amp;gt; template.Format(info.Category));
            });
        });
    });

    using var server = new GarnetServer(args, loggerFactory);

    // Optional: register custom extensions
    RegisterExtensions(server);

    // Start the server
    server.Start();
    Thread.Sleep(Timeout.Infinite);
}
catch (Exception ex)
{
    Console.WriteLine($&amp;quot;Unable to initialize server due to exception: {ex.Message}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もう一つは、カスタムコマンドを実装できることです……！C#で……！&lt;/p&gt;
&lt;p&gt;Redis上でちょっと複雑な実行をしたいことはよくあり、Redisの場合は&lt;a href="https://redis.io/docs/interact/programmability/eval-intro/"&gt;Lua Script&lt;/a&gt;で処理していましたが、GarnetではC#でカスタムコマンドを実装して組み込むことができます。LUAだとパフォーマンス上どうか、あるいはLUAではできないかなり複雑なことをしたい、といった場合に、パフォーマンス上のデメリットなく使えます。もっとさらに嬉しい点としては、サーバー側で用意した拡張コマンドは、RESPに従っているので、クライアントはC#専用ではなく、PHPからでもGoからでも呼べます。&lt;/p&gt;
&lt;p&gt;というわけで、サンプルということで単純な、「SETLCLAMP」というSET時にclampするカスタムコマンドを早速作っていきましょう。作る前に、先に↑のコードで欠けてるRegisterExtensionsの部分を。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;static void RegisterExtensions(GarnetServer server)
{
    // ClampLongCustomCommandというカスタムコマンドをSETLCLAMPというコマンド名で登録する。
    // これはMath.Clampを呼び出すので、パラメーター数は3(long value, long min, long max)
    server.Register.NewCommand(&amp;quot;SETLCLAMP&amp;quot;, 3, CommandType.ReadModifyWrite, new ClampLongCustomCommand());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;カスタムコマンドの登録自体は非常に簡単で、&lt;code&gt;CustomRawStringFunctions&lt;/code&gt;, &lt;code&gt;CustomTransactionProcedure&lt;/code&gt; または &lt;code&gt;CustomObjectFactory&lt;/code&gt; を実装したクラスをコマンド名と共に追加するだけです。&lt;/p&gt;
&lt;p&gt;カスタムコマンドの実装も簡単……？まぁ、理解すればそれなりぐらいに。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;using Garnet.server;
using System.Buffers;
using System.Buffers.Binary;
using Tsavorite.core;

sealed class ClampLongCustomCommand : CustomRawStringFunctions
{
    // trueの場合はKeyが空の時の動作(GetInitialLength, InitilUpdate)を呼びに行く
    public override bool NeedInitialUpdate(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output) =&amp;gt; true;

    // UpdaterのSpan&amp;lt;byte&amp;gt; value（書き込みたいメモリデータ）の長さを決める
    public override int GetInitialLength(ReadOnlySpan&amp;lt;byte&amp;gt; input)
    {
        // 今回はlongだけなので決め打ち8
        return 8;
    }

    public override bool InitialUpdater(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, Span&amp;lt;byte&amp;gt; value, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output, ref RMWInfo rmwInfo)
    {
        // inputに対してGetNextArgを連続して呼ぶとパラメーターの取得。これは定型句。
        int offset = 0;
        var arg1 = GetNextArg(input, ref offset);
        var arg2 = GetNextArg(input, ref offset);
        var arg3 = GetNextArg(input, ref offset);

        // ClientはWriteInt64LittleEndianでシリアライズしてきてるので、Readでデシリアライズ
        var v = BinaryPrimitives.ReadInt64LittleEndian(arg1);
        var min = BinaryPrimitives.ReadInt64LittleEndian(arg2);
        var max = BinaryPrimitives.ReadInt64LittleEndian(arg3);

        var result = Math.Clamp(v, min, max);

        // valueに対して値を書くことで値のセットになる
        BinaryPrimitives.WriteInt64LittleEndian(value, result);

        // 戻り値とかエラーを書きたい場合はoutputを使う(RespWriteUtilsに色々Utilityが揃ってる)
        // WriteIntegerAsBulkStringなどを使うと&amp;quot;String&amp;quot;としての結果になることに注意
        // 今回はlongをバイナリとして出力する
        unsafe
        {
            var len = 8 + 6; // $8\r\n{value}\r\n
            var pool = MemoryPool.Rent(len);
            using var memory = pool.Memory.Pin();
            var begin = (byte*)memory.Pointer;
            var end = begin + len;
            RespWriteUtils.WriteBulkString(value, ref begin, end);
            output = (pool, len);
        }

        return true;
    }

    // 同じメモリ領域を再利用する(置換する値の長さが同値なら再利用可能)かどうかを決める
    public override bool NeedCopyUpdate(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, ReadOnlySpan&amp;lt;byte&amp;gt; oldValue, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output) =&amp;gt; false;

    // 置換時に再利用する場合
    public override bool InPlaceUpdater(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, Span&amp;lt;byte&amp;gt; value, ref int valueLength, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output, ref RMWInfo rmwInfo)
    {
        // 置換するvalueの長さが一緒(あるいは小さい)の場合は
        // valueにはoldValueが入ってきてる。
        // 今回は特に考慮しないのでそのまんま書く。

        int offset = 0;
        var v = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var min = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));
        var max = BinaryPrimitives.ReadInt64LittleEndian(GetNextArg(input, ref offset));

        var result = Math.Clamp(v, min, max);

        BinaryPrimitives.WriteInt64LittleEndian(value, result);
        unsafe
        {
            var len = 8 + 6; // $8\r\n{value}\r\n
            var pool = MemoryPool.Rent(len);
            using var memory = pool.Memory.Pin();
            var begin = (byte*)memory.Pointer;
            var end = begin + len;
            RespWriteUtils.WriteBulkString(value, ref begin, end);
            output = (pool, len);
        }

        return true;
    }

    // 置換時に別のメモリ領域を確保する場合

    public override int GetLength(ReadOnlySpan&amp;lt;byte&amp;gt; value, ReadOnlySpan&amp;lt;byte&amp;gt; input) =&amp;gt; 8;

    public override bool CopyUpdater(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, ReadOnlySpan&amp;lt;byte&amp;gt; oldValue, Span&amp;lt;byte&amp;gt; newValue, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output, ref RMWInfo rmwInfo) =&amp;gt; throw new NotImplementedException();


    // 読み込み処理用
    public override bool Reader(ReadOnlySpan&amp;lt;byte&amp;gt; key, ReadOnlySpan&amp;lt;byte&amp;gt; input, ReadOnlySpan&amp;lt;byte&amp;gt; value, ref (IMemoryOwner&amp;lt;byte&amp;gt;, int) output, ref ReadInfo readInfo) =&amp;gt; throw new NotImplementedException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今回はRedisでいうところのStringベースで作るので &lt;code&gt;CustomRawStringFunctions&lt;/code&gt; を使います。RedisのStringは文字列型じゃなくて、どちらかというとバイナリ型で、バイナリシリアライズできるものなら、なんでも突っ込めるイメージです。私もゲームサーバーを作っていたときはMessagePackのバイナリを突っ込みまくってましたし、開発時には雑に画像データのバイナリを投げ込んで画像DB代わりに使ったりとかもありました。&lt;/p&gt;
&lt;p&gt;オーバーライドするメソッドの数が多いことと、パラメーターが&lt;code&gt;Span&amp;lt;byte&amp;gt;&lt;/code&gt;だらけで一瞬圧倒されちゃうんですが、冷静に追ってみるとそこまで難しいことは言ってないことに気づきます。追加時(Add)・置換時(Replace)が、最適化のため同じサイズか違うサイズかで2択、それとRead時用。といった別れ方をしています。&lt;/p&gt;
&lt;p&gt;key, input, valueが全て&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;なのは、まぁそりゃそうでしょう(ここでstringとか出てきたら逆に良くない！)&lt;/p&gt;
&lt;p&gt;inputをパラメーターに分解するのは&lt;code&gt;GetNextArg&lt;/code&gt;というヘルパーメソッドを使います。当然それも出てくるのは&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;なので、あとは適当に、もしJSONとかMessagePackとか&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;でシリアライズしたデータだったらシリアライザを使って戻すのもいいし、プリミティブの値だったら&lt;code&gt;BinaryPrimitives&lt;/code&gt;が恐らく適役です。MemoryPackでValueTupleにまとめちゃうのがArgumentが分かれないので最速かつ簡単かもしれません。&lt;/p&gt;
&lt;p&gt;結果は&lt;code&gt;Span&amp;lt;byte&amp;gt; value&lt;/code&gt;に書きます。この出力先のSpanの長さは事前に&lt;code&gt;GetLength&lt;/code&gt;または&lt;code&gt;GetInitialLength&lt;/code&gt;で求めておく必要があります。outputはクライアント側に戻すときの値で、RESPに則った形式で出力する必要があるので色々注意がいります。まずはRESPの仕様を簡単にでも頭に入れたほうがつまずかないで済むかもしれません、ここを分かってないとイマイチ書きづらいと思います。&lt;/p&gt;
&lt;p&gt;と、いうわけで、バイナリ操作がそこそこ混ざることを除けば、それなりに素直に書けるのではないでしょうか。雰囲気は理解しました！ある程度なんでもは出来ますが(&lt;code&gt;CustomTransactionProcedure&lt;/code&gt; や &lt;code&gt;CustomObjectFactory&lt;/code&gt; でもまた色々出来る)、同期メソッドしかないように、DB呼んだりHTTP通信したりはご法度です。当たり前ですが。当たり前ですが。計算量もGarnetサーバーのCPUにストレートに影響を与えるので、そんなに無茶なことを書くことはないと思いますがお気をつけを。それでも、LUAを走らせるよりもずっと軽いんじゃないかなという予感はさせてくれます。実際これただのC#のメソッドそのものですしね。&lt;/p&gt;
&lt;p&gt;クライアントから呼び出す場合は、こんなメソッドを用意してみます。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;public static class GarnetClientExtensions
{
    // RESPプロトコルにのっとってOpCodeを用意する
    // RESPのBlukStringの仕様: https://redis.io/docs/reference/protocol-spec/#bulk-strings
    // $&amp;lt;length&amp;gt;\r\n&amp;lt;data&amp;gt;\r\n
    readonly static Memory&amp;lt;byte&amp;gt; OpCode_SETLCLAMP = Encoding.ASCII.GetBytes(&amp;quot;$9\r\nSETLCLAMP\r\n&amp;quot;);

    public static async Task&amp;lt;long&amp;gt; ClampAsync(this GarnetClient client, Memory&amp;lt;byte&amp;gt; key, long value, long min, long max, CancellationToken cancellationToken = default)
    {
        var parameters = new byte[24];

        var valSpan = parameters[0..8];
        var minSpan = parameters[8..16];
        var maxSpan = parameters[16..24];

        BinaryPrimitives.WriteInt64LittleEndian(valSpan, value);
        BinaryPrimitives.WriteInt64LittleEndian(minSpan, min);
        BinaryPrimitives.WriteInt64LittleEndian(maxSpan, max);

        // key + (value, min, max)
        // 戻り値のMemoryResultはArrayPoolから借りてる状態なのでDisposeでReturnする
        using var result = await client.ExecuteForMemoryResultWithCancellationAsync(OpCode_SETLCLAMP, new Memory&amp;lt;byte&amp;gt;[] { key, valSpan, minSpan, maxSpan }, cancellationToken);
        
        return BinaryPrimitives.ReadInt64LittleEndian(result.Span);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サーバー側で用意した拡張コマンドは、ちゃんとRESPに従っているので、クライアントはC#専用ではありませんし、Garnet Client専用でもありません。StackExchange.Redisであれば、&lt;code&gt;db.Execute(&amp;quot;SETLCLAMP&amp;quot;, ...)&lt;/code&gt; で呼べます。&lt;/p&gt;
&lt;p&gt;実際に動かしてみるとこんな感じです。&lt;/p&gt;
&lt;pre data-pagefind-ignore="all"&gt;&lt;code class="language-csharp"&gt;static async Task RunClientAsync(ILoggerFactory loggerFactory)
{
    var logger = loggerFactory.CreateLogger(&amp;quot;Client&amp;quot;);

    var client = new GarnetClient(&amp;quot;localhost&amp;quot;, 3278, logger: logger);

    logger.ZLogInformation($&amp;quot;Client Connecting.&amp;quot;);
    await client.ConnectAsync();
    logger.ZLogInformation($&amp;quot;Success Connect.&amp;quot;);

    var key = Encoding.UTF8.GetBytes(&amp;quot;foo&amp;quot;);

    var v1 = await client.ClampAsync(key, 12345, min: 0, max: 100);
    Console.WriteLine(v1); // 100

    // String系のGET/SET/DELなどは普通に呼べる
    using var v2 = await client.StringGetAsMemoryAsync(key);
    Console.WriteLine(BinaryPrimitives.ReadInt64LittleEndian(v2.Span)); // 100

    var isDelete = await client.KeyDeleteAsync(key);
    Console.WriteLine(isDelete); // True
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;いいですね！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;さすがに公開されてまだ10時間経ってないぐらいなのでザックリとした理解なのですが、かなりいいんじゃないかと！&lt;/p&gt;
&lt;p&gt;どうしてもMemachedとかRedisとかは、クラウドのマネージドサービスが用意されてないと嫌だー、という思考に陥りがちなのですが、C#でガリガリ拡張できるとなれば、まぁマネージドがなくてもしょうがないな！という気持ちになれ、る、でしょうかね……？&lt;/p&gt;
&lt;p&gt;まぁそうじゃなくても、あまりマネージド指向になりすぎるのも良くないかな、とは思っています。私は最近はPubSubに&lt;a href="https://nats.io/"&gt;NATS&lt;/a&gt;をお薦めしてクライアントも作ったりしてたわけですが、もちろんマネージドサービスはありません。で、だから、諦めます、というのは違うかな、と。もったいないと思うんですよね。&lt;/p&gt;
&lt;p&gt;なので、必要あれば、いや、必要じゃなくても（？）気持ちがあるなら、自前に立てるというのも否定しちゃあいけないと思ってます。特にC#アプリケーションを作ったことがある人なら、C#で組み込んでホスティングすること自体は別に難しくもない、なんだったらいつもやってることの延長線上でいけますし。もちろん、そこからインフラ安定させるとかデータどうするなとかリカバリどうするとか、そういうのは別問題の話ではありますが……！&lt;/p&gt;
&lt;p&gt;ともあれかなり面白いし使える予感があるので、やっていきましょう！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 19 Mar 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-03-19T00:00:00+09:00</a10:updated>
    </item>
  </channel>
</rss>