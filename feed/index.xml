<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>neue cc</title>
    <link>http://neue.cc/</link>
    <description>C# Technical Blog</description>
    <language>ja</language>
    <lastBuildDate>Tue, 27 Feb 2024 08:31:44 +0900</lastBuildDate>
    <item>
      <guid isPermaLink="true">https://neue.cc/2024/01/15_shareprojectinunity.html</guid>
      <link>https://neue.cc/2024/01/15_shareprojectinunity.html</link>
      <title>.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2024/01/15_shareprojectinunity.html"&gt;.NETプロジェクトとUnityプロジェクトのソースコード共有最新手法&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2024-01-15&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://github.com/Cysharp/MagicOnion/"&gt;MagicOnionのv6&lt;/a&gt;が先日リリースされました。&lt;/p&gt;
&lt;p&gt;メジャーバージョンアップとして大きな違いは、&lt;a href="https://github.com/Cysharp/YetAnotherHttpHandler"&gt;Cysharp/YetAnotherHttpHandler&lt;/a&gt;を正式リリースし、これを通信層の標準ライブラリ化しました。インストール手順も複雑で、サポートも切れていたgRPC C-Coreとはさようならです。正式リリースにあたってプレビューに存在していたクラッシュ問題などが解消されています。&lt;/p&gt;
&lt;p&gt;もう一つはクライアント生成においてコマンドラインツールが削除され、Source Generatorベースになりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[MagicOnionClientGeneration(typeof(MyApp.Shared.Services.IGreeterService))]
partial class MagicOnionGeneratedClientInitializer {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これだけでコンパイル時にジェネレートされます。コマンドラインツールには、インストールしている.NETのバージョンによって動作したりしなかったりや、生成ファイルの管理をどうするかや、ビルドプロセスの複雑化など、問題が多くありましたがSource Generator化によって全て解決しました。&lt;/p&gt;
&lt;p&gt;残念ながらまだMessagePack for C#がコマンドラインツールを必要としているため、完全なコマンドラインツール不要化には至っていませんが、そちらの改善も着手中のため、近いうちにはアプリケーション全体の完全なSource Generator化が果たせるのではないかと思います。それに合わせて&lt;a href="https://github.com/Cysharp/MasterMemory/"&gt;Cysharp/MasterMemory&lt;/a&gt;のSource Generator化も行いたいと思っています。&lt;/p&gt;
&lt;h2&gt;.NETプロジェクトとUnityプロジェクト間でのコード共有&lt;/h2&gt;
&lt;p&gt;MagicOnionに限らずですが、.NETとUnityとの間でソースコードをどのように共有すればいいのか問題があります。昔のやり方では、Unity側で実態を持っていて.NET側で参照を拾ってくるとか、.NET側のビルド時にUnity側にコピーをばらまく、シンボリックリンクで参照する、などといった方法を提案していたのですが、すべて正直イマイチでした。&lt;/p&gt;
&lt;p&gt;というわけで令和最新版の方法を紹介します。先に結論をいうと、.NET側に普通の共有用クラスライブラリプロジェクトを作って、Unity側ではUPMのローカルパッケージ参照でソースコードを引っ張ってくるのが現状のベストだと考えています。ただしそのままやると幾つか面倒なことが発生するので、しっかりした手順をここに書いておきます。&lt;/p&gt;
&lt;p&gt;まずは.NET側のプロジェクトとして、.NET Standard 2.0/2.1, LangVersion 9のクラスライブラリプロジェクトを作ります。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/MagicOnion/assets/46207/0019a2b0-ec2c-4786-9d1d-0078e8dc0295" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;そして&lt;code&gt;Directory.Build.props&lt;/code&gt;を配置します。これは複数のcsprojにまたがって共有した設定が行えるやつなのですが、今回は単独のcsprojに適用する場合にも使います。そんな&lt;code&gt;Directory.Build.props&lt;/code&gt;の中身はこれです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project ToolsVersion=&amp;quot;15.0&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;!-- Unity ignores . prefix folder --&amp;gt;
    &amp;lt;ArtifactsPath&amp;gt;$(MSBuildThisFileDirectory).artifacts&amp;lt;/ArtifactsPath&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最新手法と銘打った理由として.NET 8(以降に同梱されてるコンパイラ)は&lt;a href="https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output"&gt;成果物の出力レイアウトを変更する&lt;/a&gt;ことができるようになりました。なぜこれが必要かというと、通常、ビルドするとbin, objがcsprojのディレクトリに吐かれるわけですが、Unityでパッケージ参照するとそのbin, objまで取り込んでしまって大問題なんですね。ArtifactsPathを設定することでbin, objの出力場所を変更できます、そして&lt;a href="https://docs.unity3d.com/Manual/SpecialFolders.html"&gt;Unityのアセットインポートにおける命名規則&lt;/a&gt;のうち&lt;code&gt;.&lt;/code&gt;か&lt;code&gt;~&lt;/code&gt;で始まってるファイルまたはフォルダは無視されます。というわけで、bin, objの出力場所を&lt;code&gt;.artifacts&lt;/code&gt;に変えることで、Unityから参照しても問題ない構成になりました。&lt;/p&gt;
&lt;p&gt;もう少し作業が必要で、次にcsprojを開いて、以下の行を追加しておきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;&amp;lt;ItemGroup&amp;gt;
  &amp;lt;None Remove=&amp;quot;**\package.json&amp;quot; /&amp;gt;
  &amp;lt;None Remove=&amp;quot;**\*.asmdef&amp;quot; /&amp;gt;
  &amp;lt;None Remove=&amp;quot;**\*.meta&amp;quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、Unityからパッケージ参照すると.metaが大量にばらまかれてウザいので、少なくともcsprojの見た目からは消しておきます。package.jsonとasmdefも同様に.NETプロジェクトとしては不要なので管理外へ。&lt;/p&gt;
&lt;p&gt;というわけで最後に、package.jsonとasmdefをこのディレクトリに置いておきましょう。これがないとUnity側から正しく参照できないので。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/MagicOnion/assets/46207/54c9564d-c6f2-44ec-b86c-bec19ecfb040" alt="image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;com.cysharp.magiconion.samples.chatapp.shared.unity&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;displayName&amp;quot;: &amp;quot;ChatApp.Shared.Unity&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;ChatApp.Shared.Unity&amp;quot;,
  &amp;quot;unity&amp;quot;: &amp;quot;2019.1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;ChatApp.Shared.Unity&amp;quot;,
    &amp;quot;references&amp;quot;: [
        &amp;quot;MessagePack&amp;quot;,
        &amp;quot;MagicOnion.Abstractions&amp;quot;
    ],
    &amp;quot;optionalUnityReferences&amp;quot;: [],
    &amp;quot;includePlatforms&amp;quot;: [],
    &amp;quot;excludePlatforms&amp;quot;: [],
    &amp;quot;allowUnsafeCode&amp;quot;: false,
    &amp;quot;overrideReferences&amp;quot;: false,
    &amp;quot;precompiledReferences&amp;quot;: [],
    &amp;quot;autoReferenced&amp;quot;: true,
    &amp;quot;defineConstraints&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;referencesとかはお好きな感じで。&lt;/p&gt;
&lt;p&gt;これでほぼ準備は完了です！とはもうUnity側ではPackage Managerを開いてAdd package from diskで先ほどの共有プロジェクトのディレクトリを指定すればOK。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/MagicOnion/assets/46207/a46813ab-72fb-44b3-ac8e-241451f9128f" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;ただし、これで参照すると絶対パスが書かれているので、&lt;code&gt;manifest.json&lt;/code&gt;を開いて相対パスに手動で書き換えましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;com.cysharp.magiconion.samples.chatapp.shared.unity&amp;quot;: &amp;quot;file:../../ChatApp.Shared&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでいい具合に取り扱うことができました！&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/R3/assets/46207/ed8c1d20-fd8a-4e6c-afe5-2350d3fa2860" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;さらに一歩進んで、サーバー側のslnでUnity側のcsprojも一緒に管理したいんだよなあ、とかやりたい場合は&lt;a href="https://github.com/Cysharp/SlnMerge/"&gt;Cysharp/SlnMerge&lt;/a&gt;を使うとよいでしょう。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/SlnMerge/assets/46207/6b70bfda-5f80-42c0-9acc-ca3922f22c52" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;単一slnで管理すると、Unity側での作業時に共有プロジェクトのコードを弄りやすくなりますし、サーバー/クライアントを超えたデバッグのステップ実行ができるようになるなど、かなり作りやすくなるので、あわせて是非設定しておくことをお薦めします。&lt;/p&gt;
&lt;h2&gt;Unity用ライブラリのNuGet配布のための開発時環境設定&lt;/h2&gt;
&lt;p&gt;先日&lt;a href="https://github.com/Cysharp/R3/"&gt;R3&lt;/a&gt;というUniRxの進化版みたいなのをリリースしましたが、これはコアライブラリはNuGetで配布するようにしました。ちょっと前まで私はNuGet配布に関して否定的で、Unity向けにはソースコードをちゃんと配らないと、みたいに思ってたんですが、今はNuGet配布にたいして超ポジティブです。というか、逆にNuGet配布じゃないとマズいような状況もあるので、今後のものは全てNuGet配布にするほか、既存のものも随時NuGet配布に切り替えると思います。まずはMessagePack for C#が近いうちにそうなります……！&lt;/p&gt;
&lt;p&gt;それはいいんですが、Unity用に開発している際に.NETライブラリとして作られているコードを参照したい、んですよね、というか参照できないとUnity向け拡張(R3.Unity)が作れないし。&lt;/p&gt;
&lt;p&gt;で、じゃあ上のやり方みたいローカルパッケージ参照でソースコードを持ってきてやろう、と思ったんですが、ダメでした。というのもR3の本体はC# 12で書かれていたのだ……！DLLとして配布するので別に言語バージョンは問題ない(コンパイルしてIL化すると.NETのバージョンは関係ありますが言語バージョンは関係なくなる)ので、Unityで使うことが前提ながら普通にC# 12で書いていたので、ソースコードとしての参照はできない。&lt;/p&gt;
&lt;p&gt;ビルド時の成果物をUnity側にコピーするようにしても、まぁいいっちゃあいいんですが、作業中のちょっと書き換える度にコミットされるのでリポジトリが無駄に膨らむから嫌だなー、と。&lt;/p&gt;
&lt;p&gt;で、そこで、やはりローカルパッケージ参照です。ただし今回は&lt;code&gt;package.json&lt;/code&gt;のみで、asmdefは配りません。そして&lt;code&gt;bin/Debug/netstandard2.0&lt;/code&gt;(2.1でもいい)にpackage.jsonを置いて、package.jsonとpackage.json.metaのみgitの管理下に置きます。&lt;/p&gt;
&lt;p&gt;実際のリポジトリ: &lt;a href="https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0"&gt;https://github.com/Cysharp/R3/tree/main/src/R3/bin/Debug/netstandard2.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手元のフォルダの状況:&lt;br /&gt;
&lt;img src="https://github.com/Cysharp/MagicOnion/assets/46207/2c8f7cb4-08ea-459c-abcc-6a251a063cb2" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;これを同じようにローカルパッケージ参照すると、開発用のdllだけをUnityに引っ張ってくることができました。別にパッケージの中にソースコードがなくてもいいわけですね……！&lt;/p&gt;
&lt;p&gt;なお、普通のゲーム開発でもC# 12で書きたいんだよー、という人は、ソースコード参照じゃなくてこっちのやり方を使っても成立はします。全然、アリです。ただし、.NET側でビルドしないと反映されないとか、デバッグビルドとリリースビルドどっち参照させます？とかいうところを考えなきゃいけないので、まぁお好みで、というところでしょうか。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;というわけで、2024年になってようやく満足いく共有手法にたどり着けました。これはC#大統一理論元年……！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 15 Jan 2024 00:00:00 +0900</pubDate>
      <a10:updated>2024-01-15T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/12/30_year.html</guid>
      <link>https://neue.cc/2023/12/30_year.html</link>
      <title>2023年を振り返る</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/12/30_year.html"&gt;2023年を振り返る&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-12-30&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;今年も相変わらずC#関連で色々やっていきました……！というわけなんですが、一番大きかったのはcsbindgenでしょうか。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/03/09-csbindgen.html"&gt;csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私のスタンスとして、今までとにかくPure C#でなんとかする！という姿勢ではあったんですが、より柔軟にネイティブコードを取り入れていくという変化になりました。そのほうが、より「C#の可能性を切り開いていく」という&lt;a href="https://cysharp.co.jp/"&gt;Cysharp&lt;/a&gt;のミッションにも近づけているわけで、かなり良い変化をもたらせたと思っています。発展して&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html"&gt;Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といったような有意義なライブラリを生み出せるキッカケにもなれましたし。とはいえ改めてネイティブはネイティブで大変なのは変わらないので、C#最高、みたいな思いも強くなりましたが……！&lt;/p&gt;
&lt;p&gt;私個人のスキルとしても、Rustを取り入れられるようになったのはかなり良かったことですね。Rustから学ぶことも多く、より良いC#のコードを書くことにも役立ちます。&lt;/p&gt;
&lt;p&gt;OSSの後半戦ではZLogger v2は傑作だと思っています……！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/12/19_zlogger2.html"&gt;ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思っているので、ちょっと普及活動頑張りたいと思っています、NLog、Serilogと同列に並んで検討対象になってくれると嬉しいのですけれどねー。まぁ、まずはReadMeから、ですが。なんとまだ工事中！よくない！&lt;/p&gt;
&lt;p&gt;その他小粒の新規OSS郡もありました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/01/30-SimdLinq.html"&gt;SimdLinq - LINQをそのままSIMD対応して超高速化するライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/01/27_StructureOfArraysGenerator.html"&gt;StructureOfArraysGenerator - C#でSoAを簡単に利用するためのSource Generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/07/04_MagicPhysX.html"&gt;MagicPhysX - .NET用のクロスプラットフォーム物理エンジン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html"&gt;UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;こう見ると、今年もなんだかんだで色々やってはいましたね！&lt;/p&gt;
&lt;p&gt;そして久々にCEDECでの発表もしてきました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition"&gt;CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;近年の総決算のつもりであったのですが、ちょっとシリアライザ的なもの(Stream)に偏りすぎではあった、かな？また5年後ぐらいには別の切り口で話せるといいかなーとは思ってます。&lt;/p&gt;
&lt;p&gt;さて、ここ数年は「自称革命的なサービス（？）を来年こそはリリースする」と言い続けていたのですが、それは頓挫しました！革命的なサービスは出ない！しょーがない。csbindgenとかはそれの副産物なので、成果は無、というわけではないんですが、頓挫はやはり悲しくはあります。。。&lt;/p&gt;
&lt;p&gt;そんなわけで、来年は別のネタを探しつつも、一つだけ、来年初頭というか1月の頭というか、あともう一週間ないぐらいに、大型のOSSを(プレビュー)リリースしたいと思って、ここ一ヶ月ぐらいは延々と集中してコード書いてます。かなり本気でやっているので、それは是非楽しみにしてください……！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Sat, 30 Dec 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-12-30T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/12/19_zlogger2.html</guid>
      <link>https://neue.cc/2023/12/19_zlogger2.html</link>
      <title>ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/12/19_zlogger2.html"&gt;ZLogger v2 による .NET 8活用事例 と Unity C# 11対応の紹介&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-12-19&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;C#用の新しい超高速＆低アロケーションの.NET用ロギングライブラリ、ZLogger v2を公開しました。v1からは何もかもを完全に作り替えた、最新のC#に合わせた新設計になっています。対応プラットフォームは.NET 8が最良ですが .NET Standard 2.0 以上、また Unity 2022.2 以上にも対応しています。.NET / Unityどちらもテキストメッセージと構造化ログの両方に対応しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/ZLogger"&gt;Cysharp/ZLogger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新設計のキーポイントはString Interpolationの全面採用によるクリーンなシンタックスとパフォーマンスの両立です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;logger.ZLogInformation($&amp;quot;Hello my name is {name}, {age} years old.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったように書いたコードは&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if (logger.IsEnabled(LogLvel.Information))
{
    var handler = new ZLoggerInformationInterpolatedStringHandler(30, 2, logger);
    handler.AppendLiteral(&amp;quot;Hello my name is &amp;quot;);
    handler.AppendFormatted&amp;lt;string&amp;gt;(name, 0, null, &amp;quot;name&amp;quot;);
    handler.AppendLiteral(&amp;quot;, &amp;quot;);
    handler.AppendFormatted&amp;lt;int&amp;gt;(age, 0, null, &amp;quot;age&amp;quot;);
    handler.AppendLiteral(&amp;quot; years old.&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のようにコンパイル時に分解されます。フォーマット文字列を実行時ではなくコンパイル時に展開すること、パラメーターは&lt;code&gt;AppendFormatted&amp;lt;T&amp;gt;&lt;/code&gt;の形でジェネリクスで受け取ることによりボクシングが発生しないなど、コードからも明らかに効率的なことが見てとれます。ちなみにコンストラクターの30は文字列の長さ、2はパラメーターの数を指していて、ここから必要な初期バッファ数を算出していることも効率化の一つに繋がっています。&lt;/p&gt;
&lt;p&gt;String Interpolation自体はC# 6.0から搭載されている機能ですが、文法上同じながら&lt;a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/"&gt;C# 10.0から強化されたString Interpolation&lt;/a&gt;が搭載されていて、カスタムのString Interpolationを提供することも可能になりました。&lt;/p&gt;
&lt;p&gt;こうして得られた文字列断片とパラメーターは、最終的には&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Cysharp/Utf8StringInterpolation&lt;/a&gt;を通して文字列化せずに、直接UTF8としてStreamに書き込むことによって、高速化と低アロケーションを実現しています。&lt;/p&gt;
&lt;p&gt;また、Structured Loggingにおいても、System.Text.JsonのUtf8JsonWriterとタイトに結びつくことにより&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// 例えば {&amp;quot;name&amp;quot;:&amp;quot;foo&amp;quot;,age:33} のようにUtf8JsonWriterに書き込む

// Source Generator版、実際どうなってるかのイメージがとても分かりやすい。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    writer.WriteString(_jsonParameter_name, this.name);
    writer.WriteNumber(_jsonParameter_age, this.age);
}

// StringInterpolation版、ちょっと遠回りな感じですがやってることは一緒。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    for (var i = 0; i &amp;lt; ParameterCount; i++)
    {
        ref var p = ref parameters[i];
        writer.WritePropertyName(p.Name.AsSpan());
        // MagicalBoxの説明は後述
        if (!magicalBox.TryReadTo(p.Type, p.BoxOffset, jsonWriter, jsonSerializerOptions))
        {
            // ....
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;やはり直接UTF8として書き込みます。Structured Loggingは最近のトレンドなので、色々な言語のロガーに実装されていますが、パフォーマンスを両立しつつ、ここまでクリーンなシンタックスで実現できているものは他にない！という感じなのでかなり良いのではないでしょうか。&lt;/p&gt;
&lt;p&gt;では実際ベンチマーク結果でどれぐらい？というと、アロケーションは少なくとも圧倒的です。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/ZLogger/assets/46207/ab9c1f8b-a3b4-44fc-86aa-ba8dd6bdbe40" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;アロケーションは、という歯切れの悪い言い方をしているのは、念入りに高速になるよう設定したNLogが思ったよりも速かったせいですね、ぐぬぬ……。&lt;/p&gt;
&lt;p&gt;さて、ZLoggerの特徴のもう一つは、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logging"&gt;Microsoft.Extensions.Logging&lt;/a&gt;の上に直接構築していることです。通常のロガーは独自のシステムを持っていて、Microsoft.Extensions.Loggingと繋げる場合はブリッジを通します。現実的なアプリケーションでは ASP .NETを使う場合などMicrosoft.Extensions.Loggingを避けることはほぼ不可能です。.NET 8からはOpenTelemetry対応の強化や&lt;a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview"&gt;Aspire&lt;/a&gt;など、ますますMicrosoft.Extensions.Loggingの重要性は増しています。ZLogger v1と異なり、v2ではScopeなど、Microsoft.Extensions.Loggingの全機能に対応しています。&lt;/p&gt;
&lt;p&gt;そして例えばSerilogのブリッジライブラリの品質は（ソースコードも確認しましたが）かなり低く、実際のパフォーマンスの数字にも現れています。ZLoggerはそうしたオーバーヘッドが一切かかりません。&lt;/p&gt;
&lt;p&gt;また、デフォルトの設定も非常に重要です。ほとんどのロガーの標準設定は、例えばファイルストリームに書く場合は都度Flushするなど、かなり遅い設定が標準になっています。それを高速化するにはasync, bufferedを適切に調整する必要があり、かつ、取りこぼさないように終了時に確実にFlushさせる必要があるのですが、かなり難しいので、ほとんど標準設定のままの人も多いのではないでしょうか？ZLoggerではデフォルトで最高速になるように調整してあり、かつ、Microsoft.ExtensionsのDIのライフサイクルで最後のFlushも自動でかかるようになっているので、ApplicationBuilderなどでアプリケーションを構築した場合は何も意識しなくても取りこぼしは発生しません。&lt;/p&gt;
&lt;p&gt;なお、都度Flushのパフォーマンスはストレージの書き込み性能に強く依存するため、例えば最近のマシンのM.2 SSDは非常に高速なため、ローカルでベンチマークすると意外と遅くない、といったことを確認できるかもしれません。ただし、実際にアプリケーションを配置する、例えばクラウドサーバーのストレージ性能がそこまで高いことはないので、ローカルでの結果を過信しないほうがいいでしょう。&lt;/p&gt;
&lt;h2&gt;MagicalBox&lt;/h2&gt;
&lt;p&gt;ここからは、パフォーマンスを実現した幾つかのトリックを紹介します。v1から引き継いでいるのは&lt;a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"&gt;System.Threading.Channels&lt;/a&gt;を活用したasyncな非同期書き込みプロセスの作成と、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.ibufferwriter-1"&gt;&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;&lt;/a&gt;による効率的なbufferedの利用による、Streamへの書き込み最適化ですが、説明は割愛します。&lt;/p&gt;
&lt;p&gt;JSON化のために、パラメーターはInterpolatedStringHandlerで、一時的に値として保持します。その場合に、&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;の値をどのように保持するか、という問題がでてきます。普通に考えると、&lt;code&gt;List&amp;lt;object&amp;gt;&lt;/code&gt;といったようなobject型で保持することになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // あらゆる&amp;lt;T&amp;gt;の型を格納するためにobjectを使う、ボクシングが発生するので良くはない。
    List&amp;lt;object&amp;gt; parameters = new ();

    public void AppendFormatted&amp;lt;T&amp;gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&amp;quot;value&amp;quot;)] string? argumentName = null)
    {
        parameters.Add((object)value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;それを避けるために、ZLoggerではMagicalBoxという仕組みを用意しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // 魔法の箱に無限に詰め込む
    MagicalBox magicalBox;
    List&amp;lt;int&amp;gt; boxOffsets = new (); // 実際はこの辺は入念にキャッシュされています

    public void AppendFormatted&amp;lt;T&amp;gt;(T value, int alignment = 0, string? format = null, [CallerArgumentExpression(&amp;quot;value&amp;quot;)] string? argumentName = null)
    {
        if(magicalBox.TryWrite(value, out var offset)) // boxingが発生しない！
        {
            boxOffsets.Add(offset);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MagicalBoxはどんな型(unmanaged型に限る)でも、ボクシングなしに書き込むことができる。というコンセプトで、その実態は&lt;code&gt;byte[]&lt;/code&gt;にUnsafe.Write、offsetを元にUnsafe.Readするというだけの代物です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal unsafe partial struct MagicalBox
{
    byte[] storage;
    int written;

    public MagicalBox(byte[] storage)
    {
        this.storage = storage;
    }

    public bool TryWrite&amp;lt;T&amp;gt;(T value, out int offset)
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences&amp;lt;T&amp;gt;())
        {
            offset = 0;
            return false;
        }

        Unsafe.WriteUnaligned(ref storage[written], value);
        offset = written;
        written += Unsafe.SizeOf&amp;lt;T&amp;gt;();
        return true;
    }

    public bool TryRead&amp;lt;T&amp;gt;(int offset, out T value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences&amp;lt;T&amp;gt;())
        {
            value = default!;
            return false;
        }

        value = Unsafe.ReadUnaligned&amp;lt;T&amp;gt;(ref storage[offset]);
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この辺は&lt;a href="https://github.com/Cysharp/MemoryPack"&gt;MemoryPack&lt;/a&gt;での実装経験が元になっていて、うまく機能しています。&lt;/p&gt;
&lt;p&gt;なお、実際のコードでは&lt;code&gt;byte[] storage&lt;/code&gt;の効率的な再利用や非ジェネリクスなRead対応、Enumへの特別対応が入ったりなど、もう少し&lt;a href="https://github.com/Cysharp/ZLogger/blob/ccc3b0e6/src/ZLogger/Internal/MagicalBox.cs"&gt;複雑なコード&lt;/a&gt;になってはいます。さすがに。&lt;/p&gt;
&lt;h2&gt;カスタムフォーマット文字列&lt;/h2&gt;
&lt;p&gt;ZLoggerのString Interpolationのいいところは、パラメーター値にメソッド呼び出しを含めると、LogLevelのチェックが入った後に呼び出されるので無駄な実行を防げるところです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// これは
logger.ZLogDebug($&amp;quot;Id {obj.GetId()}: Data: {obj.GetData()}.&amp;quot;);

// このようにLogLevelが有効かどうかチェックした後にメソッドが呼ばれる
if (logger.IsEnabled(LogLvel.Debug))
{
    // snip...
    writer.AppendFormatterd(obj.GetId());
    writer.AppendFormatterd(obj.GetData());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし、メソッド呼び出しをStructured Loggingに出力した場合、ZLoggerはC# 10.0以降から追加された&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.compilerservices.callerargumentexpressionattribute?view=net-8.0"&gt;CallerArgumentExpression&lt;/a&gt;でパラメーター名を取得しているため、メソッド呼び出しの場合は &amp;quot;obj.GetId()&amp;quot; という微妙極まりない名前で出力されてしまいます。そこで、特殊なカスタムフォーマット文字列で別名を指定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// @name で別名を付けられる
logger.ZLogDebug($&amp;quot;Id {obj.GetId():@id}: Data: {obj.GetData():@data}.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ZLoggerでは、String Interpolationの本来の式に従って、&amp;quot;,&amp;quot;でアラインメント、&amp;quot;:&amp;quot;でフォーマット文字列を指定することができます。それに加えて特殊な指定として、フォーマット文字列を@から始めた場合はパラメーター名として出力します。&lt;/p&gt;
&lt;p&gt;@によるパラメーター名指定とフォーマット文字列は併用することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Today is 2023-12-19.
// {&amp;quot;date&amp;quot;:&amp;quot;2023-12-19T11:25:34.3642389+09:00&amp;quot;}
logger.ZLogDebug($&amp;quot;Today is {DateTime.Now:@date:yyyy-MM-dd}.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もう一つ、共通の特殊なフォーマット文字列として&amp;quot;json&amp;quot;を指定するとJsonSerializeした形で出力できます（この辺はSerilogの持つ機能からインスパイアされました）&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var position = new { Latitude = 25, Longitude = 134 };
var elapsed = 34;

// {&amp;quot;position&amp;quot;:{&amp;quot;Latitude&amp;quot;:25,&amp;quot;Longitude&amp;quot;:134},&amp;quot;elapsed&amp;quot;:34}
// Processed {&amp;quot;Latitude&amp;quot;:25,&amp;quot;Longitude&amp;quot;:134} in 034 ms.
logger.ZLogInformation($&amp;quot;Processed {position:json} in {elapsed:000} ms.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊フォーマット文字列は、例えばログレベルやカテゴリー、日付を先頭/末尾に付与するためのPrefixFormatter/SuffixFormatterにも幾つか用意してあります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;logging.AddZLoggerConsole(options =&amp;gt;
{
    options.UsePlainTextFormatter(formatter =&amp;gt;
    {
        // 2023-12-19 02:46:14.289 [DBG]......
        formatter.SetPrefixFormatter($&amp;quot;{0:utc-longdate} [{1:short}]&amp;quot;, (template, info) =&amp;gt; template.Format(info.Timestamp, info.LogLevel));
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Timestampには&lt;code&gt;longdate&lt;/code&gt;, &lt;code&gt;utc-longdate&lt;/code&gt;, &lt;code&gt;dateonly&lt;/code&gt;など。LogLevelには&lt;code&gt;short&lt;/code&gt;で3文字ログレベル表記(先頭の長さが一致するのでエディタで開いた時に読みやすくなる)へと変換されます。これら組み込みの特殊フォーマット文字列は、パフォーマンス最適化という意味合いもあります。例えばLogLevelは以下のようなコードになっているので、手で書式を作るよりも、事前組み込みのUTF8文字列で書き込むことで、絶対的に効率がよくなっています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void AppendLogLevel(ref Utf8StringWriter&amp;lt;IBufferWriter&amp;lt;byte&amp;gt;&amp;gt; writer, ref LogLevel value, ref MessageTemplateChunk chunk)
{
    if (!chunk.NoAlignmentAndFormat)
    {
        if (chunk.Format == &amp;quot;short&amp;quot;)
        {
            switch (value)
            {
                case LogLevel.Trace:
                    writer.AppendUtf8(&amp;quot;TRC&amp;quot;u8);
                    return;
                case LogLevel.Debug:
                    writer.AppendUtf8(&amp;quot;DBG&amp;quot;u8);
                    return;
                case LogLevel.Information:
                    writer.AppendUtf8(&amp;quot;INF&amp;quot;u8);
                    return;
                case LogLevel.Warning:
                    writer.AppendUtf8(&amp;quot;WRN&amp;quot;u8);
                    return;
                case LogLevel.Error:
                    writer.AppendUtf8(&amp;quot;ERR&amp;quot;u8);
                    return;
                case LogLevel.Critical:
                    writer.AppendUtf8(&amp;quot;CRI&amp;quot;u8);
                    return;
                case LogLevel.None:
                    writer.AppendUtf8(&amp;quot;NON&amp;quot;u8);
                    return;
                default:
                    break;
            }
        }

        writer.AppendFormatted(value, chunk.Alignment, chunk.Format);
        return;
    }

    switch (value)
    {
        case LogLevel.Trace:
            writer.AppendUtf8(&amp;quot;Trace&amp;quot;u8);
            break;
        case LogLevel.Debug:
            writer.AppendUtf8(&amp;quot;Debug&amp;quot;u8);
            break;
        case LogLevel.Information:
            writer.AppendUtf8(&amp;quot;Information&amp;quot;u8);
            break;
        case LogLevel.Warning:
            writer.AppendUtf8(&amp;quot;Warning&amp;quot;u8);
            break;
        case LogLevel.Error:
            writer.AppendUtf8(&amp;quot;Error&amp;quot;u8);
            break;
        case LogLevel.Critical:
            writer.AppendUtf8(&amp;quot;Critical&amp;quot;u8);
            break;
        case LogLevel.None:
            writer.AppendUtf8(&amp;quot;None&amp;quot;u8);
            break;
        default:
            writer.AppendFormatted(value);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;.NET 8 XxHash3 + Non-GC Heap&lt;/h2&gt;
&lt;p&gt;.NET 8から&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.io.hashing.xxhash3"&gt;XxHash3&lt;/a&gt;が追加されました。最速のハッシュアルゴリズムである&lt;a href="https://github.com/Cyan4973/xxHash/"&gt;XxHash&lt;/a&gt;の最新シリーズで、小さいデータから大きいデータまで、迷ったらほぼこれ一択で問題ないだろうという性能になっています。なお、利用にはNuGetから&lt;code&gt;System.IO.Hashing&lt;/code&gt;が必要なので、逆に.NET 8ではなくNET Standard 2.0でも使えます。&lt;/p&gt;
&lt;p&gt;ZLoggerでも複数箇所で使っているのですが、その中から一例として、String Interpolationの文字列リテラルからキャッシュを取り出す処理の例を。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// $&amp;quot;Hello my name is {name}, {age} years old.&amp;quot; が生成する文字列リテラルの並び(LiteralList)
// [&amp;quot;Hello my name is &amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;, &amp;quot;, &amp;quot;age&amp;quot;, &amp;quot; years old.&amp;quot;]
// これからUTF8変換済みのキャッシュ(MessageSequence)を取り出すという処理
static readonly ConcurrentDictionary&amp;lt;LiteralList, MessageSequence&amp;gt; cache = new();

// 非.NET 8版
#if !NET8_0_OR_GREATER

struct LiteralList(List&amp;lt;string?&amp;gt; literals) : IEquatable&amp;lt;LiteralList&amp;gt;
{
    [ThreadStatic]
    static XxHash3? xxhash;

    public override int GetHashCode()
    {
        var h = xxhash;
        if (h == null)
        {
            h = xxhash = new XxHash3();
        }
        else
        {
            h.Reset();
        }

        var span = CollectionsMarshal.AsSpan(literals);
        foreach (var item in span)
        {
            h.Append(MemoryMarshal.AsBytes(item.AsSpan()));
        }

        // https://github.com/Cyan4973/xxHash/issues/453
        // XXH3 64bit -&amp;gt; 32bit, okay to simple cast answered by XXH3 author.
        return unchecked((int)h.GetCurrentHashAsUInt64());
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        if (xs.Length == ys.Length)
        {
            for (int i = 0; i &amp;lt; xs.Length; i++)
            {
                if (xs[i] != ys[i]) return false;
            }
            return true;
        }

        return false;
    }
}

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;XxHash3はclassなので(&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.hashcode?view=net-8.0"&gt;System.HashCode&lt;/a&gt;みたいにstructが良かったなあ)、ThreadStaticで使いまわしつつ、GetHashCodeを生成しています。XxHash3はulongの出力しかありませんが、作者によると、32bitに落とす場合は特にXORとかかけることもなく直接落として問題ないそうです。&lt;/p&gt;
&lt;p&gt;ここまでが普通の使い方ですが、.NET 8版ではエクストリームな最適化を入れました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#if NET8_0_OR_GREATER

struct LiteralList(List&amp;lt;string?&amp;gt; literals) : IEquatable&amp;lt;LiteralList&amp;gt;
{
    // literals are all const string, in .NET 8 it is allocated in Non-GC Heap so can compare by address.
    // https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#non-gc-heap
    static ReadOnlySpan&amp;lt;byte&amp;gt; AsBytes(ReadOnlySpan&amp;lt;string?&amp;gt; literals)
    {
        return MemoryMarshal.CreateSpan(
            ref Unsafe.As&amp;lt;string?, byte&amp;gt;(ref MemoryMarshal.GetReference(literals)),
            literals.Length * Unsafe.SizeOf&amp;lt;string&amp;gt;());
    }

    public override int GetHashCode()
    {
        return unchecked((int)XxHash3.HashToUInt64(AsBytes(CollectionsMarshal.AsSpan(literals))));
    }

    public bool Equals(LiteralList other)
    {
        var xs = CollectionsMarshal.AsSpan(literals);
        var ys = CollectionsMarshal.AsSpan(other.literals);

        return AsBytes(xs).SequenceEqual(AsBytes(ys));
    }
}

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;string&amp;gt;?&lt;/code&gt;を&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;に変換して、それでXxHash3.HashToUInt64やSeqeunceEqualを一発で呼んでます。見るからにこちらのほうが効率的なわけですが、しかし、そもそも&lt;code&gt;List&amp;lt;string&amp;gt;?&lt;/code&gt;を&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;に変換するのは合法なのか？と。この場合のstringの変換は、&lt;code&gt;ReadOnlySpan&amp;lt;IntPtr&amp;gt;&lt;/code&gt;への変換という意味合いで、つまりヒープにあるstringのアドレスのリストへと変換しているという意図になります。&lt;/p&gt;
&lt;p&gt;そこまではいいとして、問題はアドレスの比較は危険すぎないか、ということです。まず第一に、stringは文字列として同一であっても実態は別のアドレスにある場合も多い。第二に、ヒープにあるstringのアドレスは固定されていない、移動することがあるということです。辞書のキーとしてGetHashCodeやEqualsを求めるなら、アプリケーション実行中は完全に固定されていなければなりません。&lt;/p&gt;
&lt;p&gt;ところが今回の利用例に着目すると、String Inteprolationで呼ばれるAppendLiteralはコンパイル時に &lt;code&gt;handler.AppendLiteral(&amp;quot;Hello my name is &amp;quot;);&lt;/code&gt; のように、必ず定数で渡されています。そのため同じ実体を指すことが保証されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    public void AppendLiteral([ConstantExpected] string s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一応保険として、.NET 8から有効化されている&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.codeanalysis.constantexpectedattribute?view=net-8.0"&gt;ConstantExpected&lt;/a&gt;によって、定数だけが渡されることを明示しています。&lt;/p&gt;
&lt;p&gt;もう一つは、そうした定数の文字列は最初からインターン化されているのですが、そのインターン化された場所が移動しないことは.NET 8まで保証されていませんでした。ところが、.NET 8からはNon-GC Heapが導入されたため、移動しないことが保証されている、といえます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// .NET 8からは定数のGC.GetGenerationの結果がint.MaxValue(Non-GC Heapにいる)
var str = &amp;quot;foo&amp;quot;;
Console.WriteLine(GC.GetGeneration(str)); // 2147483647
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによって、C#だとどうしても避けられないUTF16 StringからUTF8 Stringへの変換を、限界まで高速化することができました。なお、Source Generator版ではこのルックアップコスト自体を削れているため、ベンチマーク結果が最速であった通り、より高速です。&lt;/p&gt;
&lt;h2&gt;.NET 8 IUtf8SpanFormattable&lt;/h2&gt;
&lt;p&gt;ZLoggerでは値を文字列を通さずUTF8に直接書き込むことをパフォーマンスの柱にしています。.NET 8から&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0"&gt;IUtf8SpanFormattable&lt;/a&gt;という、値の汎用的なUTF8への直接変換を可能にしたインターフェイスが追加されました。ZLoggerは.NET 8以前の.NET Standard 2.0にも対応させるために、intやdoubleなど基本的なプリミティブは特殊な対応によって、UTF8への直接書き込みを実現していますが、.NET 8の場合は対応範囲がより広がるため、できれば.NET 8がお薦めです。&lt;/p&gt;
&lt;p&gt;なお、IUtf8SpanFormattableはフォーマット文字列のalignmentには関知しないため、分離しているライブラリである&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Cysharp/Utf8StringInterpolation&lt;/a&gt;では.NET Standard 2.0対応と同時に、alignment対応の機能も追加されたライブラリとなっています。&lt;/p&gt;
&lt;h2&gt;.NET 8 TimeProvider&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.timeprovider?view=net-8.0"&gt;TimeProvider&lt;/a&gt;は.NET 8から追加された時間に関するAPIの抽象化(TimeZone, Timerなども含む)となっていて、ユニットテスト等でも非常に役に立つ、今後の必須クラスです。TimeProviderは.NET 8未満でも&lt;a href="https://www.nuget.org/packages/Microsoft.Bcl.TimeProvider/"&gt;Microsoft.Bcl.TimeProvider&lt;/a&gt;を通して提供されているため、.NET Standard 2.0やUnityでも利用可能です。&lt;/p&gt;
&lt;p&gt;そこでZLoggerではZLoggerOptionsにTimerProviderを指定することで、ログ出力の時間を固定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Microsoft.Extensions.TimeProvider.TestingのFakeTimeProviderを使うとよりよい
class FakeTime : TimeProvider
{
    public override DateTimeOffset GetUtcNow()
    {
        return new DateTimeOffset(1999, 12, 30, 11, 12, 33, TimeSpan.Zero);
    }

    public override TimeZoneInfo LocalTimeZone =&amp;gt; TimeZoneInfo.Utc;
}

public class TimestampTest
{
    [Fact]
    public void LogInfoTimestamp()
    {
        var result = new List&amp;lt;string&amp;gt;();
        using var factory = LoggerFactory.Create(builder =&amp;gt;
        {
            builder.AddZLoggerInMemory((options, _) =&amp;gt;
            {
                options.TimeProvider = new FakeTime(); // TimeProviderをカスタムのものに設定
                options.UsePlainTextFormatter(formatter =&amp;gt;
                {
                    // Timestampを先頭に付与
                    formatter.SetPrefixFormatter($&amp;quot;{0} | &amp;quot;, (template, info) =&amp;gt; template.Format(info.Timestamp));
                });
            }, x =&amp;gt;
            {
                x.MessageReceived += msg =&amp;gt; result.Add(msg);
            });
        });

        var logger = factory.CreateLogger&amp;lt;TimestampTest&amp;gt;();
        logger.ZLogInformation($&amp;quot;Foo&amp;quot;);

        Assert.Equal(&amp;quot;1999-12-30 11:12:33.000 | Foo&amp;quot;, result[0]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ログ出力の完全一致でのテストが必要……！などといった場合に有効に使うことができます。&lt;/p&gt;
&lt;h2&gt;Source Generator&lt;/h2&gt;
&lt;p&gt;Microsoft.Extensions.Loggingではハイパフォーマンスなログ出力のために&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logger-message-generator"&gt;LoggerMessageAttribute&lt;/a&gt;とSource Generatorが標準で提供されています。&lt;/p&gt;
&lt;p&gt;これは確かにUTF16文字列の生成では非常に優秀ですが、Structured Logging生成部分に関しては疑問符がつきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// このpartial methodは
[LoggerMessage(LogLevel.Information, &amp;quot;My name is {name}, age is {age}.&amp;quot;)]
public static partial void MSLog(this ILogger logger, string name, int age, int other);

// このクラスを生成する
private readonly struct __MSLogStruct : global::System.Collections.Generic.IReadOnlyList&amp;lt;global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;&amp;gt;
{
    private readonly global::System.String _name;
    private readonly global::System.Int32 _age;

    public __MSLogStruct(global::System.String name, global::System.Int32 age)
    {
        this._name = name;
        this._age = age;
    }

    public override string ToString()
    {
        var name = this._name;
        var age = this._age;

        return $&amp;quot;My name is {name}, age is {age}.&amp;quot;; // 文字列生成は高速そう（C# 10.0のString Interpolation Improvementsにベタ乗りなので言うことなし！）
    }

    public static readonly global::System.Func&amp;lt;__MSLogStruct, global::System.Exception?, string&amp;gt; Format = (state, ex) =&amp;gt; state.ToString();

    public int Count =&amp;gt; 4;

    // こちらがStrcuted Loggingのコードですが、ん……？
    public global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt; this[int index]
    {
        get =&amp;gt; index switch
        {
            0 =&amp;gt; new global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;(&amp;quot;name&amp;quot;, this._name),
            1 =&amp;gt; new global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;(&amp;quot;age&amp;quot;, this._age),
            2 =&amp;gt; new global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;(&amp;quot;other&amp;quot;, this._other),
            3 =&amp;gt; new global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;(&amp;quot;{OriginalFormat}&amp;quot;, &amp;quot;My name is {name}, age is {age}.&amp;quot;),

            _ =&amp;gt; throw new global::System.IndexOutOfRangeException(nameof(index)),  // return the same exception LoggerMessage.Define returns in this case
        };
    }

    public global::System.Collections.Generic.IEnumerator&amp;lt;global::System.Collections.Generic.KeyValuePair&amp;lt;string, object?&amp;gt;&amp;gt; GetEnumerator()
    {
        for (int i = 0; i &amp;lt; 4; i++)
        {
            yield return this[i];
        }
    }

    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();
}

[global::System.CodeDom.Compiler.GeneratedCodeAttribute(&amp;quot;Microsoft.Extensions.Logging.Generators&amp;quot;, &amp;quot;8.0.9.3103&amp;quot;)]
public static partial void MSLog(this global::Microsoft.Extensions.Logging.ILogger logger, global::System.String name, global::System.Int32 age)
{
    if (logger.IsEnabled(global::Microsoft.Extensions.Logging.LogLevel.Information))
    {
        logger.Log(
            global::Microsoft.Extensions.Logging.LogLevel.Information,
            new global::Microsoft.Extensions.Logging.EventId(764917357, nameof(MSLog)),
            new __MSLogStruct(name, age),
            null,
            __MSLogStruct.Format);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;KeyValuePair&amp;lt;string, object?&amp;gt;&lt;/code&gt; ということで、基本的に普通に作るとボクシングは避けられません、しょーがない。&lt;/p&gt;
&lt;p&gt;そこで、ZLoggerでは似たようなSource Generator属性である&lt;code&gt;ZLoggerMessageAttribute&lt;/code&gt;を提供しています。これにより、UTF8最適化、ボクシングレスなJSONロギングを可能にしています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// LoggerMessageをZLoggerMessageに変えるだけ
// なお、ZLoggerMessageのフォーマット文字列部分では、String Interpolation版と同じように@による別名やjsonによるJSON化も可能
[ZLoggerMessage(LogLevel.Information, &amp;quot;My name is {name}, age is {age}.&amp;quot;)]
static partial void ZLoggerLog(this ILogger logger, string name, int age);

// このようなコードが生成される
readonly struct ZLoggerLogState : IZLoggerFormattable
{
    // JSON用にJsonEncodedTextを事前生成
    static readonly JsonEncodedText _jsonParameter_name = JsonEncodedText.Encode(&amp;quot;name&amp;quot;);
    static readonly JsonEncodedText _jsonParameter_age = JsonEncodedText.Encode(&amp;quot;age&amp;quot;);

    readonly string name;
    readonly int age;

    public ZLoggerLogState(string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public IZLoggerEntry CreateEntry(LogInfo info)
    {
        return ZLoggerEntry&amp;lt;ZLoggerLogState&amp;gt;.Create(info, this);
    }
    
    public int ParameterCount =&amp;gt; 2;
    public bool IsSupportUtf8ParameterKey =&amp;gt; true;
    public override string ToString() =&amp;gt; $&amp;quot;My name is {name}, age is {age}.&amp;quot;;

    // テキストメッセージはUTF8への直接書き込み
    public void ToString(IBufferWriter&amp;lt;byte&amp;gt; writer)
    {
        var stringWriter = new Utf8StringWriter&amp;lt;IBufferWriter&amp;lt;byte&amp;gt;&amp;gt;(literalLength: 21, formattedCount: 2, bufferWriter: writer);

        stringWriter.AppendUtf8(&amp;quot;My name is &amp;quot;u8); // u8でリテラルは直接書き込み
        stringWriter.AppendFormatted(name, 0, null);
        stringWriter.AppendUtf8(&amp;quot;, age is &amp;quot;u8);
        stringWriter.AppendFormatted(age, 0, null);
        stringWriter.AppendUtf8(&amp;quot;.&amp;quot;u8);            

        stringWriter.Flush();
    }

    // JSON出力の場合はUtf8JsonWriterに直接書き込むことで完全にボクシング避け
    public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null)
    {
        // 型によって呼び出すメソッドは異なる(WriteString, WriteNumber, etc...)
        writer.WriteString(_jsonParameter_name, this.name);
        writer.WriteNumber(_jsonParameter_age, this.age);
    }

    // 以下にMessagePack対応などの拡張用のメソッドが実際には生成されますが省略
} 

static partial void ZLoggerLog(this global::Microsoft.Extensions.Logging.ILogger logger, string name, int age)
{
    if (!logger.IsEnabled(LogLevel.Information)) return;
    logger.Log(
        LogLevel.Information,
        new EventId(-1, nameof(ZLoggerLog)),
        new ZLoggerLogState(name, age),
        null,
        (state, ex) =&amp;gt; state.ToString()
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utf8JsonWriterに直接書く、また、キー名はJsonEncodedTextを事前に生成して持っておく、という仕様によってJSON化のパフォーマンスを最大化しています。&lt;/p&gt;
&lt;p&gt;また、Structured LoggingはJSONに限らず他のフォーマットもありえます。例えばMessagePackを利用することで、より小さく、より高速にすることができるでしょう。ZLoggerでは、そうしたJSON特化のようなビルトインではないプロトコルへの出力においてもボクシングを避けるためのインターフェイスが定義されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IZLoggerFormattable : IZLoggerEntryCreatable
{
    int ParameterCount { get; }

    // メッセージ出力に使う
    void ToString(IBufferWriter&amp;lt;byte&amp;gt; writer);

    // JSON出力に使う
    void WriteJsonParameterKeyValues(Utf8JsonWriter jsonWriter, JsonSerializerOptions jsonSerializerOptions, IKeyNameMutator? keyNameMutator = null);

    // それ以外の構造化ログ出力に使う
    ReadOnlySpan&amp;lt;byte&amp;gt; GetParameterKey(int index);
    ReadOnlySpan&amp;lt;char&amp;gt; GetParameterKeyAsString(int index);
    object? GetParameterValue(int index);
    T? GetParameterValue&amp;lt;T&amp;gt;(int index);
    Type GetParameterType(int index);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちょっと変わったインターフェイスになっていますが、以下のようなループを回すことでボクシングの発生をなくせます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;for (var i in ParameterCount)
{
    var key = GetParameterKey(i);
    var value = GetParameterValue&amp;lt;int&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こうした設計はADO.NETのIDataRecordの使い方と同じ設計です。また、Unityでもネイティブ→マネージドでの配列のアロケーションを避けるために、インデックス経由で取得することがよくあります。&lt;/p&gt;
&lt;h2&gt;Unity&lt;/h2&gt;
&lt;p&gt;UnityはUnity 2023の時点でも正式な対応C#のバージョンは9.0です。ZLoggerはC# 10.0以上のString Interpolationが大前提となっているので、普通は動きません。普通は。ところが、正式にアナウンスはされていないのですが &lt;code&gt;Unity 2022.2&lt;/code&gt; から同梱されているコンパイラのバージョンが上がっていて、内部的にはC# 10.0でコンパイル可能になっていることを発見しました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csc.rsp&lt;/code&gt; ファイルによってコンパイラオプションを渡すことができるので、そこで明示的に言語バージョンを指定してあげると、C# 10.0の全ての文法が利用可能になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;-langVersion:10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このままだと出力されるcsprojには依然として&lt;code&gt;&amp;lt;LangVersion&amp;gt;9.0&amp;lt;/LangVersion&amp;gt;&lt;/code&gt;が指定されているため、IDE上ではC# 10.0で書けません。そこで&lt;a href="https://github.com/Cysharp/CsprojModifier"&gt;Cysharp/CsprojModifier&lt;/a&gt;を用いて、LangVersionを上書きしてしまいましょう。以下のような&lt;code&gt;LangVersion.props&lt;/code&gt;というファイルを作成して、CsprojModifierに混ぜてもらえば、IDE上でもC# 10.0として記述できるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;LangVersion&amp;gt;10&amp;lt;/LangVersion&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unity向けには&lt;code&gt;AddZLoggerUnityDebug&lt;/code&gt;という拡張を追加してあるので、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// こんなグローバルのユーティリティーを用意してあげて
public static class LogManager
{
    static ILoggerFactory loggerFactory;

    public static ILogger&amp;lt;T&amp;gt; CreateLogger&amp;lt;T&amp;gt;() =&amp;gt; loggerFactory.CreateLogger&amp;lt;T&amp;gt;();
    public static readonly Microsoft.Extensions.Logging.ILogger Global;

    static LogManager()
    {
        loggerFactory = LoggerFactory.Create(logging =&amp;gt;
        {
            logging.SetMinimumLevel(LogLevel.Trace);
            logging.AddZLoggerUnityDebug(); // log to UnityDebug
        });
        Global = loggerFactory.CreateLogger(&amp;quot;Logger&amp;quot;);

        Application.exitCancellationToken.Register(() =&amp;gt;
        {
            loggerFactory.Dispose(); // flush when application exit.
        });
    }
}

// 例えばこんな感じに使ってみる
public class NewBehaviourScript : MonoBehaviour
{
    static readonly ILogger&amp;lt;NewBehaviourScript&amp;gt; logger = LogManager.CreateLogger&amp;lt;NewBehaviourScript&amp;gt;();

    void Start()
    {
        var name = &amp;quot;foo&amp;quot;;
        var hp = 100;
        logger.ZLogInformation($&amp;quot;{name} HP is {hp}.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;なお、C# 10.0のString Interpolation性能向上の恩恵を受けれるのはZLogを使った場合のみの話で、通常のString生成にString Interpolationを使っても性能向上はしません。string生成の性能向上にはランタイムにDefaultInterpolatedStringHandlerが必要で、これは .NET 6 以上にのみ同梱されているからです。DefaultInterpolatedStringHandlerが存在しない場合は今まで通りのstring.Formatにフォールバックされるため、普通にボクシングされます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JSONによる構造化ログや出力のカスタマイズ、ファイルへの出力などにも全て対応しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var loggerFactory = LoggerFactory.Create(logging =&amp;gt;
{
    logging.AddZLoggerFile(&amp;quot;/path/to/logfile&amp;quot;, options =&amp;gt;
    {
        options.UseJsonFormatter();
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そしてもう一つボーナスとして、&lt;code&gt;Unity 2022.3.12f1&lt;/code&gt; 以上だとC#のコンパイラバージョンがもう少し上がっていて、&lt;code&gt;-langVersion:preview&lt;/code&gt;を指定するとC# 11.0が使えます。また、ZLoggerのSource Generatorが自動で有効になっているので、&lt;code&gt;[ZLoggerMessage]&lt;/code&gt;を使って生成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static partial class LogExtensions
{
    [ZLoggerMessage(LogLevel.Debug, &amp;quot;Hello, {name}&amp;quot;)]
    public static partial void Hello(this ILogger&amp;lt;NewBehaviourScript&amp;gt; logger, string name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Source Generatorの生成するコードがC# 11.0を要求するので(UTF8 String Literalなどを多用しているため)、&lt;code&gt;[ZLoggerMessage]&lt;/code&gt;が使えるのは&lt;code&gt;Unity 2022.3.12f1&lt;/code&gt; 以上限定となります。&lt;/p&gt;
&lt;p&gt;なお、Unityには同種の標準ロギングライブラリとして&lt;a href="https://docs.unity3d.com/Packages/com.unity.logging@1.2/manual/index.html"&gt;com.unity.logging&lt;/a&gt;がリリースされています。同じように構造化ロギングやファイル出力が可能なほか、Source Generatorを使ってクラスそのものを自動生成して、メソッドのオーバーロードを引数に応じて生成することで値のボクシング避けをするといった、面白い設計をしていました。Burst云々という話がよく出てきますが、このSource Generatorの大胆な使い方のほうがパフォーマンスの肝だと思います。ZLoggerはC# 10.0のString Interpolationを活用しているわけですが、そういうアプローチでの回避策というのはちょっと考えたことがなかったので、かなり目から鱗です。パフォーマンス的にもかなり練られています。&lt;/p&gt;
&lt;p&gt;ZLoggerのほうがString Interpolationによる書き味は上、パフォーマンスは、まぁいい勝負するんじゃないかなとは思いたいんですが、どうでしょうね……？&lt;/p&gt;
&lt;h2&gt;NuGetForUnity&lt;/h2&gt;
&lt;p&gt;今回Unityへのライブラリの配布は&lt;a href="https://github.com/GlitchEnzo/NuGetForUnity"&gt;NuGetForUnity&lt;/a&gt;を採用しました。これは普通の.NETライブラリへの依存が多いものへの配布に非常に便利で、NuGetForUnityを入れたあとに、GUIでZLoggerをこうして入れると&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/5ce038b8-85be-4bed-97ec-17aec260fa84" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;こんなように依存関係も解決して、Assets/Packagesの下にDLLがばらまかれます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/Cysharp/Utf8StringInterpolation/assets/46207/62a71516-874e-4bc2-bc75-29bf0fac9dd8" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;Source Generatorが含まれている場合は、ちゃんと&lt;code&gt;RoslynAnalyzer&lt;/code&gt;のラベルも付与してくれるので、そのままSource GeneratorもUnity上で有効化されています。&lt;/p&gt;
&lt;p&gt;良い点としては、やはり大量のマネージドDLLの管理を一括でやってくれることと、動作がシンプル（基本的には解決したファイルをAssets/Packagesにばらまくだけ)なのでやっていることがイメージつきやすいところです。同じようなツールとして&lt;a href="https://github.com/xoofx/unitynuget"&gt;UnityNuGet&lt;/a&gt;というものがあるのですが、そちらは独自レジストリに配布しているファイルを引っ張ってくるという作りなので、NuGetForUnity(MS公式のNuGetのレジストリから引っ張ってくる)のほうが素直な挙動で好ましく思います。&lt;/p&gt;
&lt;p&gt;反面、UnityEngine.dllに依存したコードやUnityのバージョンで分岐するコードは配りにくいところがあります。ZLoggerではそのためのファイル(ZLoggerUnityDebugLoggerProvider)は別途git参照で引っ張ってくるハイブリッド方式での配布としました。かなりバランスの良いやり方かなと思うんですがどうでしょう……？特にCysharpのライブラリはコア部分はUnity非依存のものが多いので、問題なければ今後のCysharpのライブラリはこの形式での配布を基本としていきたいところです。&lt;/p&gt;
&lt;p&gt;ライブラリ作者側としては、コア部分はDLLで配ることになるのでC# 12のままで良い（今まではUnityのためにC# 9にダウングレードさせて書いたりしてた）のが、とにかくとても楽ですね……！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;この記事は&lt;a href="https://qiita.com/advent-calendar/2023/csharplang"&gt;C# Advent Calendar 2023&lt;/a&gt;の12月3日分の記事となります。すごい遅刻ですが間に合ったので（？）よし。よくない。&lt;/p&gt;
&lt;p&gt;なお、ZLogger v2の作成にあたっては &lt;a href="https://github.com/hadashiA/VContainer"&gt;VContainer&lt;/a&gt; や &lt;a href="https://github.com/hadashiA/VYaml"&gt;VYaml&lt;/a&gt; で有名な &lt;a href="https://twitter.com/hadashiA"&gt;@hadashiA&lt;/a&gt; さんに、アイディア出しから細かい実装、度重なる仕様のちゃぶ台返しに付き合ってもらいました。今回のv2は非常に完成度高くなったと思うのですが、自分一人ではここまで達しなかったので大変感謝です。&lt;/p&gt;
&lt;p&gt;ともあれZLoggerは使いやすさでもパフォーマンスでも最強！のロガーに仕上がったと思いますので、是非使ってみてください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 19 Dec 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-12-19T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/10/23_rusttokyo.html</guid>
      <link>https://neue.cc/2023/10/23_rusttokyo.html</link>
      <title>他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/10/23_rusttokyo.html"&gt;他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-10-23&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://rust.tokyo/2023"&gt;Rust.Tokyo 2023&lt;/a&gt;というRustのカンファレンスで、「他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例」と題して&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;周りの話をしてきました。&lt;/p&gt;
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/fca414aeffb9486ab2f738466df6da02" title="他言語がメインの場合のRustの活用法 - csbindgenによるC# x Rust FFI実践事例" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"&gt;&lt;/iframe&gt;
&lt;p&gt;タイトルが若干かなり回りっくどい雰囲気になってしまいましたが、Rustのカンファレンスということで、あまりC#に寄り過ぎないように、という意識があったのですが、どうでしょう……？&lt;/p&gt;
&lt;p&gt;会場での質問含めて何点かフォローアップを。&lt;/p&gt;
&lt;h2&gt;FFIとパフォーマンス&lt;/h2&gt;
&lt;p&gt;Rustは速い！FFIは速い！ということが常に当てはまるわけでもなく、例えばGoのcgoはかなり遅いという話があったりします。&lt;a href="https://speakerdeck.com/filosottile/why-cgo-is-slow-at-capitalgo-2018"&gt;Why cgo is slow @ CapitalGo 2018&lt;/a&gt;。このことは直近のRustのasyncの話&lt;a href="https://without.boats/blog/why-async-rust/"&gt;Why async Rust?&lt;/a&gt;でも触れられていて、cgoの遅さはGoroutine(Green Thread)が影響を及ぼしているところもある、とされています。.NET でも&lt;a href="https://github.com/dotnet/runtimelab/blob/bec51070f1071d83f686be347d160ea864828ef8/docs/design/features/greenthreads.md"&gt;Green Threadを実験的に実装してみたというレポート&lt;/a&gt;がついこないだ出ていたのですが、FFIの問題とか、まぁ諸々あってasync/awaitでいいじゃろ、という結論になっています。技術はなんでもトレードオフなので、過剰にGreen Threadを持ち上げるのもどうかな、とは思いますね。&lt;/p&gt;
&lt;p&gt;で、C#のFFI速度ですが、こちらの&lt;a href="https://vancan1ty.com/blog/post/52"&gt;Testing FFI Hot Loop Overhead - Java, C#, PHP, and Go&lt;/a&gt;という記事での比較ではFFIにおいては圧勝ということになっているので、まぁ、実際C#のFFIは速いほうということでいいんじゃないでしょーか（昔からWin32 APIを何かと叩く必要があったりとかいう事情もありますし）。&lt;/p&gt;
&lt;p&gt;とはいえ、原則Pure C#実装のほうがいいなあ、という気持ちはめっちゃあります。パフォーマンスのためのネイティブライブラリ採用というのは、本当に限定的な局面だけではありますね。そんなわけで、その限定的な局面であるところのコンプレッションライブラリを鋭意開発中です、来月に乞うご期待。&lt;/p&gt;
&lt;h2&gt;Zig, C++&lt;/h2&gt;
&lt;p&gt;FFI目的でunsafeなRust中心になるぐらいなら&lt;a href="https://ziglang.org/ja/"&gt;Zig&lt;/a&gt;のほうがいいんじゃない？というのは一理ある。というか最初はそう思ってZigを試したんですが、今回は見送らせていただきます、と。一理ある部分に関しては一理あるんですが、それ以外のところではRustのほうが上だという判断で、総合的にはRustを採用すべきだと至りました。&lt;/p&gt;
&lt;p&gt;具体的には資料の中のRustの利点、これは資料中ではC++との比較という体にしていますが、Zigとの比較という意味もあります。標準公式のパッケージマネージャーがないし、開発環境の乏しさは、たとえZigが言語的にRustよりイージーだとしても、体感は正直言ってRustよりもハードでした。コンパイルエラーもRustは圧倒的にわかりやすいんですが、Zigはめちゃくちゃ厳しい……。Rustはイージーとは言わないですが、開発環境の助けやcargoコマンドのシンプルさ、技術情報（本・ブログ・FAQ）の多さによって、入り口は意外と大変ではない、むしろ入りやすい部類とすら言える感じです。&lt;/p&gt;
&lt;p&gt;また、ZigはZigでありC/C++ではない。これはRustも同じでRustはRustでC/C++ではない、つまりCとZig(Rust)を連動させるには&lt;a href="https://github.com/rust-lang/rust-bindgen"&gt;bindgen&lt;/a&gt;のようなものが必要なのですが、Zigのそれの安定性がかなり低い、パースできない.hが普通にチラホラある。rust-bindgenのIssue見ていると本当に色々なケースに対応させる努力を延々と続けていて、それがbindgenの信頼性（と実用性）に繋がっているわけで、Zigはまだまだその域には達していないな、と。&lt;/p&gt;
&lt;p&gt;Cはまだいいとしても、C++のエコシステムを使うという点では、ZigもRustも難しい。セッションの中では&lt;a href="https://github.com/NVIDIA-Omniverse/PhysX"&gt;PhysX 5&lt;/a&gt;を例に出しましたが、物理エンジンはOSSどころだと&lt;a href="https://github.com/bulletphysics/bullet3"&gt;Bullet Physics&lt;/a&gt;も&lt;a href="https://github.com/jrouwe/JoltPhysics"&gt;Jolt Physics&lt;/a&gt;も、SDKそのままそのものはC++だけなんですよね。これをC++以外の言語に持ち込むのは非常に骨の折れる仕事が必要になってきます。Rustに関してはEmbark Studiosが&lt;a href="https://github.com/EmbarkStudios/physx-rs"&gt;physx-rs&lt;/a&gt;を作ってくれたのである程度現実的ではありますが、何れにせよ大仕事が必要で、そのままでは持ち込めないというのが現実です。&lt;/p&gt;
&lt;p&gt;physx-rsではC++のPhysXをRustで動かすために、まずC APIのPhysXを自動生成してそれ経由でRustから呼び出す、という話をしましたが、ZigもC++のものを呼び出すには、概ね同様のアプローチを取る必要があり、例えばZigでJolt Physicsを動かす&lt;a href="https://github.com/michal-z/zig-gamedev"&gt;zphysics&lt;/a&gt;というプロジェクトでは、C++のJoltに対して、C APIで公開するJoltCという部分を作って、それ経由でZigから呼び出すという手法を取っています。&lt;/p&gt;
&lt;p&gt;この辺のことは&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;MagicPhysX&lt;/a&gt;を作る時にめちゃくちゃ迷走して色々作りかけてたので痛感しています。そう、最初はZigでBullet Physicsを動かしてC#から呼び出すMagicBulletというプロジェクトだったこともあったのだ……。&lt;/p&gt;
&lt;p&gt;最後発C++後継系言語であるところの&lt;a href="https://github.com/carbon-language/carbon-lang"&gt;Carbon Language&lt;/a&gt;は、C++におけるTypeScriptというのを標榜しているので、そうしたC++との連携を最優先に考えた言語になっているんじゃないかなー、と思います（触ってないので知らんですけど！）。C++の後継はRust(やZig)があるからいらんやろー、とはならない、C++の資産を活かしながらもモダンな言語仕様を使えるようにする、という絶妙な立ち位置を狙っているんじゃないかなー、と。どのぐらい盛り上がっていくのかわかりませんが……！&lt;/p&gt;
&lt;h2&gt;C++/CLI&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ja.wikipedia.org/wiki/C%2B%2B/CLI"&gt;C++/CLI&lt;/a&gt;は使わないんですか？という質問がありました。.NETとC++ライブラリの連携という点で、C++/CLIはたしかに良いソリューションで、C++のライブラリをC#のために公開するブリッジとしては最高に使いやすい代物でした。.NET Frameworkの時代までは。&lt;/p&gt;
&lt;p&gt;C++/CLIの問題は「.NET Core の C++/CLI サポートは Windows のみ」ということで、特にライブラリがLinuxサポートしないというのはありえないので、.NET Core以降にC++/CLIを新規採用するのは基本ありえない、といった状態になっています。こういった問題があるので、 .NET Framework時代に作られていたC++ライブラリをC#で使える系ライブラリはほとんど使えなくなりました。例えばPhysX 4の.NETバインディングである&lt;a href="https://github.com/stilldesign/PhysX.Net"&gt;PhysX.NET&lt;/a&gt;は、C++/CLIでバインディングが作られているため、.NET 5対応はしていますが、サポートプラットフォームはWindowsのみです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;は、そうした.NET / C連携での空白地帯にちょうどうまくはまったライブラリなのではないかと思います。C++連携については頑張るしかないですが、そこはしょうがないね……！ ただ、Rustはエコシステムがうまく動いているので、Pure Rustライブラリであったり、RustでC++バインディングが作られているものを経由してC#バインディングを作る、といった手法でうまく回せる場合も多いんじゃないかなあー、というところがいいところです。それと、近年のライブラリ事情でいうと、物理エンジンみたいな老舗系はC++で作られていますが、例えば暗号通貨系のライブラリなんかは最初からRust実装だったりするものも多いので、RustからC#への持ち込み、のほうが今後の実用性としても高いんじゃないかと踏んでいます。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-10-23T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/10/13_Utf8StringInterpolation.html</guid>
      <link>https://neue.cc/2023/10/13_Utf8StringInterpolation.html</link>
      <title>UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/10/13_Utf8StringInterpolation.html"&gt;UTF8文字列生成を最適化するライブラリ Utf8StringInterpolation を公開しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-10-13&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Utf8StringInterpolationという新しいライブラリを公開しました！UTF8文字列の生成と書き込みに特化していて、動作をカスタマイズした文字列補間式によるC#コンパイラの機能を活用した生成と、StringBuilder的な連続的な書き込みの両方をサポートします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/Utf8StringInterpolation"&gt;Cysharp/Utf8StringInterpolation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的な流れはこんな感じで、Stringを生成するのと同じように、UTF8を生成/書き込みできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using Utf8StringInterpolation;

// Create UTF8 encoded string directly(without encoding).
byte[] utf8 = Utf8String.Format($&amp;quot;Hello, {name}, Your id is {id}!&amp;quot;);

// write to IBufferWriter&amp;lt;byte&amp;gt;(for example ASP.NET HttpResponse.BodyWriter)
Utf8String.Format(bufferWriter, $&amp;quot;Today is {DateTime.Now:yyyy-MM-dd}&amp;quot;); // support format

// like a StringBuilder
var writer = Utf8String.CreateWriter(bufferWriter);
writer.Append(&amp;quot;My Name...&amp;quot;);
writer.AppendFormat($&amp;quot;is...? {name}&amp;quot;);
writer.AppendLine();
writer.Flush();

// Join, Concat methods
var seq = Enumerable.Range(1, 10);
byte[] utf8seq = Utf8String.Join(&amp;quot;, &amp;quot;, seq);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cysharpから公開している &lt;a href="https://github.com/Cysharp/ZString/"&gt;ZString&lt;/a&gt; と非常に近いのですが、ZStringがString(UTF16), UTF8をサポートしていたのに対して、UTF8側のみを取り出して強化したようなイメージになります。何が強化なのかというと、C# 10.0から&lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md"&gt;Improved Interpolated Strings&lt;/a&gt;として、文字列補間式($&amp;quot;foo{bar}baz&amp;quot;)のパフォーマンスが大きく向上しました。具体的には、コンパイラが文字列補間式の構造を分解して、値が埋め込まれている箇所はGenericsのまま渡すようになりボクシングが消滅しました。つまりZStringでやっていたことではあるのですが、ZStringはC# 10.0以前のものですからね……！逆に言えば、これによってZStringは半分は不要となったわけです。&lt;/p&gt;
&lt;p&gt;もう半分、UTF8側に関しては依然として標準のサポートは薄い、というかほぼない状態です。しかし、Improved Interpolated Strings は文字列補間式での挙動を自由にカスタマイズできるという性質も追加されています。というわけで、文字列補間式を利用してUTF8を組み立てられるようにすればいいのではないか、というのがUtf8StringInterpolationのコンセプトであり、正しくZLoggerの後継として位置づけていることでもあります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// こういう文字列補間式を渡すと:
// Utf8String.Format(ref Utf8StringWriter format)
Utf8String.Format($&amp;quot;Hello, {name}, Your id is {id}!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// コンパイラが「コンパイル時」にこのような形に展開します。
var writer = new Utf8StringWriter(literalLength: 20, formattedCount: 2);
writer.AppendLiteral(&amp;quot;Hello, &amp;quot;);
writer.AppendFormatted&amp;lt;string&amp;gt;(name);
writer.AppendLiteral(&amp;quot;, You id is &amp;quot;);
writer.AppendFormatted&amp;lt;int&amp;gt;(id);
writer.AppendLiteral(&amp;quot;!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンパイル時に展開してくれるというのは性能上非常に重要で、つまり&lt;code&gt;String.Format&lt;/code&gt;のように実行時に文字列式のパースをしないで済む、わけです。また、ボクシングなしに全ての値を書き込みに呼んでくれます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[InterpolatedStringHandler]&lt;/code&gt;を付与している&lt;code&gt;ref Utf8StringWriter&lt;/code&gt; に &lt;code&gt;$&amp;quot;{}&amp;quot;&lt;/code&gt;を渡すと、自動的に展開してくれるという仕様になっています。そのUtf8StringWriterは以下のような実装になっています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// internal struct writer write value to utf8 directly without boxing.
[InterpolatedStringHandler]
public ref struct Utf8StringWriter&amp;lt;TBufferWriter&amp;gt; where TBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    TBufferWriter bufferWriter; // when buffer is full, advance and get more buffer
    Span&amp;lt;byte&amp;gt; buffer;          // current write buffer

    public void AppendLiteral(string value)
    {
        // encode string literal to Utf8 buffer directly
        var bytesWritten = Encoding.UTF8.GetBytes(value, buffer);
        buffer = buffer.Slice(bytesWritten);
    }

    public void AppendFormatted&amp;lt;T&amp;gt;(T value, int alignment = 0, string? format = null)
        where T : IUtf8SpanFormattable
    {
        // write value to Utf8 buffer directly
        while (!value.TryFormat(buffer, out bytesWritten, format))
        {
            Grow();
        }
        buffer = buffer.Slice(bytesWritten);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET 8 の場合は、値が &lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.iutf8spanformattable?view=net-8.0"&gt;IUtf8SpanFormattable&lt;/a&gt; という.NET 8から追加されたインターフェイスを実装している場合(intなど標準のプリミティブはほぼ実装されています）、直接TryFormatによりUTF8としてSpanに書き込みます。&lt;/p&gt;
&lt;p&gt;さすがに .NET 8 にしか対応していません！というのはエクストリームすぎるので、 .NET Standard 2.1, .NET 6(.NET 7)では &lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=net-7.0"&gt;Utf8Formatter.TryFormat&lt;/a&gt; を使うことで、同様の性能を担保しています。&lt;/p&gt;
&lt;h2&gt;Builder vs Writer&lt;/h2&gt;
&lt;p&gt;ZStringのときはStringBuilderに引っ張られすぎていて、Builderとして内部でバッファを抱えるようにしていたのですが、ちょっとUTF8的な利用ではイマイチだということが徐々に分かってきました。今の .NET の基本は &lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt; である。というのはついこないだのCEDEC 2023での発表 &lt;a href="https://speakerdeck.com/neuecc/cedec-2023-modanhaipahuomansuc-number-2023-edition"&gt;モダンハイパフォーマンスC# 2023 Edition&lt;/a&gt; でかなり語らせていただいたのですが&lt;/p&gt;
&lt;iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/055c0df858f44aafb4b017bb9c03c2e6" title="CEDEC 2023 モダンハイパフォーマンスC# 2023 Edition" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"&gt;&lt;/iframe&gt;
&lt;p&gt;BuilderというよりもWriterとして構築すべきだな、ということに至りました。そこで &lt;code&gt;Utf8StringWriter&lt;/code&gt; は基本的に&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;を受け取ってそれに書き込むという仕様となりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public ref partial struct Utf8StringWriter&amp;lt;TBufferWriter&amp;gt;
    where TBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    Span&amp;lt;byte&amp;gt; destination;
    TBufferWriter bufferWriter;
    int currentWritten;

    public Utf8StringWriter(TBufferWriter bufferWriter)
    {
        this.bufferWriter = bufferWriter;
        this.destination = bufferWriter.GetSpan();
    }

    public void Flush()
    {
        if (currentWritten != 0)
        {
            bufferWriter.Advance(currentWritten);
            currentWritten = 0;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;バッファが足りなくなったときは拡大するのではなくて、Advanceして新たにGetSpanを呼んで新しいバッファを確保しにいくという形を取りました。StringBuilderと違ってFlushの概念が必要になってしまいましたが、パフォーマンス的には大きな向上を果たしています。&lt;/p&gt;
&lt;p&gt;Flushが必要ということを除けば、StringBuilderのように扱うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var writer = Utf8String.CreateWriter(bufferWriter);

// call each append methods.
writer.Append(&amp;quot;foo&amp;quot;);
writer.AppendFormat($&amp;quot;bar {Guid.NewGuid()}&amp;quot;);
writer.AppendLine();

// finally call Flush(or Dispose)
writer.Flush();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、ちょっとStringBuilder的に使いたいだけの時に &lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt; を用意するのは面倒くさい！という場合のために、内部でプーリングを行っているバッファを使えるオーバーロードも用意しています。戻り値がバッファのコントローラーになっていて、ToArrayや他の&lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt;にコピーしたり&lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;の取得ができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// buffer must Dispose after used(recommend to use using)
using var buffer = Utf8String.CreateWriter(out var writer);

// call each append methods.
writer.Append(&amp;quot;foo&amp;quot;);
writer.AppendFormat($&amp;quot;bar {Guid.NewGuid()}&amp;quot;);
writer.AppendLine();

// finally call Flush(no need to call Dispose for writer)
writer.Flush();

// copy to written byte[]
var bytes = buffer.ToArray();

// or copy to other IBufferWriter&amp;lt;byte&amp;gt;, get ReadOnlySpan&amp;lt;byte&amp;gt;
buffer.CopyTo(otherBufferWriter);
var writtenData = buffer.WrittenSpan;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その他、&lt;code&gt;Format&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;Concat&lt;/code&gt; メソッドなども &lt;code&gt;IBufferWriter&amp;lt;byte&amp;gt;&lt;/code&gt; を受け取るオーバーロードと &lt;code&gt;byte[]&lt;/code&gt;を返すオーバーロードの2種を用意しています。&lt;/p&gt;
&lt;h2&gt;.NET 8 と StandardFormat&lt;/h2&gt;
&lt;p&gt;値のフォーマット書式は、特にDateTimeでよく使うと思いますが、数値型などでも多くの書式が用意されています。&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/formatting-types"&gt;.NET の数値、日付、列挙、その他の型の書式を設定する方法&lt;/a&gt; や各種カスタム書式指定文字列は非常に便利です。&lt;/p&gt;
&lt;p&gt;しかし、UTF8に値を直接書き込む手段として従来用意されていた&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat"&gt;Utf8Formatter.TryFormat&lt;/a&gt;では、その標準的な書式指定文字列は使えませんでした！代わりに用意されたのが&lt;a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.standardformat"&gt;StandardFormat&lt;/a&gt;なのですが、恐ろしく限定的なことしかできず(例えば'G', 'D', or 'X'のような一文字charの指定しかできない)、使い物にならないといっても過言ではないぐらいでした。&lt;/p&gt;
&lt;p&gt;ところが .NET 8 から追加された IUtf8SpanFormattable.TryFormat では、通常の書式指定文字列が帰ってきました！&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Utf8Formatter.TryFormat
static bool TryFormat (int value, Span&amp;lt;byte&amp;gt; destination, out int bytesWritten, System.Buffers.StandardFormat format = default);

// .NET 8 IUtf8SpanFormattable.TryFormat
bool TryFormat (Span&amp;lt;byte&amp;gt; utf8Destination, out int bytesWritten, ReadOnlySpan&amp;lt;char&amp;gt; format, IFormatProvider? provider);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パラメーターは非常に似ていますが、formatを文字列で受け取るようになっています。実際に比較してみるとこんな感じです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Span&amp;lt;byte&amp;gt; dest = stackalloc byte[16];
int written = 0;

// ParseできなくてExceptionがthrowされるので表現できない
Utf8Formatter.TryFormat(123.456789, dest, out written, StandardFormat.Parse(&amp;quot;.###&amp;quot;));

// 123.456
123.456123.TryFormat(dest, out written, &amp;quot;.###&amp;quot;);


// カスタム書式文字列は指定できないので例外！サポートしてるのは `G`, `R`, `l`, `O` だけ！
Utf8Formatter.TryFormat(DateTime.Now, dest, out written, StandardFormat.Parse(&amp;quot;yyyy-MM-dd&amp;quot;));

// もちろんちゃんと動作する
DateTime.Now.TryFormat(dest, out written, &amp;quot;yyyy-MM-dd&amp;quot;);

Console.WriteLine(Encoding.UTF8.GetString(dest.Slice(0, written)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;良かった、やと普通の世界が到達した……！これは ZString や、それを内部に使っていた &lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;で最もフラストレーションを感じていた点です。&lt;/p&gt;
&lt;p&gt;Utf8StringInterpolationは .NET 8 では全て IUtf8SpanFormattable で変換するようにしています。しかし、 .NET Standard 2.1, .NET 6, .NET 7では残念ながらUtf8Formatter利用となっているので、書式指定に関しては制限があります。数値に関してはターゲットプラットフォームによって動作したりしなかったりが発生します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// .NET 8 supports all numeric custom format string but .NET Standard 2.1, .NET 6(.NET 7) does not.
Utf8String.Format($&amp;quot;Double value is {123.456789:.###}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ただし、 &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;DateTimeOffset&lt;/code&gt;, &lt;code&gt;TimeSpan&lt;/code&gt; に関しては &lt;code&gt;Utf8Formatter&lt;/code&gt; を使わない処理をしているため、全てのターゲットプラットフォームでカスタム書式指定が利用可能です！&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// DateTime, DateTimeOffset, TimeSpan support custom format string on all target plaftorms.
// https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
Utf8String.Format($&amp;quot;Today is {DateTime.Now:yyyy-MM-dd}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とにかくDateTimeの書式指定がまともに出来ないのはZString/ZLoggerで一番辛かったところなので、それを改善できてとても良かった……。ただしこの対応により、DateTimeの変換性能が落ちているため、性能が最大限引き出せるのは .NET 8 となります。&lt;/p&gt;
&lt;h2&gt;Unity&lt;/h2&gt;
&lt;p&gt;Unity対応はありません！いや、可能な限り私は .NET と Unityの両対応のライブラリを作りたいと思っていて、実際今までもそうしてきているわけですが、今回ばかりはどうにもならないのです。そもそもImproved Interpolated Stringsが C# 10.0 からで、Unityの現在のC#のバージョンは C# 9.0……！さすがにそれはどうにもならない。&lt;/p&gt;
&lt;p&gt;C# 9.0で止まってから結構長いんですよね。別にランタイムのバージョンは上げなくてもいいから、コンパイラのバージョンだけ上げて欲しいと切実に思いますが、まぁC# 10.0にしたらDefaultInterpolatedStringHandlerがなくて動作しないじゃんとかなるだろうから、結局はランタイムのバージョンアップもセットでやらなければならない……。&lt;/p&gt;
&lt;p&gt;Unityが C# 10.0 に対応したらすぐに対応させるつもりではあります！待ってます！&lt;/p&gt;
&lt;h2&gt;Next&lt;/h2&gt;
&lt;p&gt;さて、とはいえ、UTF8文字列を直接扱わなければならないケースというのは、別にそんなに多くはないでしょう。実際、私も本命は&lt;a href="https://github.com/Cysharp/ZLogger"&gt;ZLogger&lt;/a&gt;の大型バージョンアップでの利用を考えています。ZLoggerは今まではZStringベースでしたが、根本からデザインをやり直した新しいものを開発中です。その中の文字列化にUtf8StringInterpolationを使っています。&lt;/p&gt;
&lt;p&gt;といったように、アプリケーションの基盤レイヤーに差し込んであげると有効に機能するシチュエーションは色々あると思います。もちろん、直接使ってもらってもいいのですが……！？&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 13 Oct 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-10-13T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/09/21_privateproxy.html</guid>
      <link>https://neue.cc/2023/09/21_privateproxy.html</link>
      <title>.NET 8 UnsafeAccessor を活用したライブラリ PrivateProxy を公開しました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/09/21_privateproxy.html"&gt;.NET 8 UnsafeAccessor を活用したライブラリ PrivateProxy を公開しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-09-21&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;PrivateProxyというライブラリを公開しました。つまるところ、privateフィールド/プロパティ/メソッドにアクセスするライブラリなのですが、.NET 8 のUnsafeAccessorという新機能を活用することでNo Reflection、ハイパフォーマンス、AOTセーフになっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/PrivateProxy"&gt;Cysharp/PrivateProxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もちろん .NET 8 でしか動きません！ので、.NET 8が正式リリースされた頃に思い出して使ってみてください。エクストリームな人は今すぐ試しましょう。&lt;/p&gt;
&lt;p&gt;雰囲気としては、privateメンバーにアクセスしたい型があったとして、&lt;code&gt;[GeneratePrivateProxy(type)]&lt;/code&gt;をつけた型を用意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using PrivateProxy;

public class Sample
{
    int _field1;
    int PrivateAdd(int x, int y) =&amp;gt; x + y;
}

[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すると、いい感じにアクセスできるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// You can access like this.
var sample = new Sample();
sample.AsPrivateProxy()._field1 = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;いいところとしては、 Source Generatorベースの生成なので、型がついていて入力補完も効くし、変数名を変更したらコンパイルエラーで検出可能です。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/269376472-f6dd22e1-e82e-4acc-ba6e-8895c8c8734b.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;ここまではSource Generatorベースで作れば、今まででもやれないことはなかったのですが、UnsafeAccessorのいいところとして、objectが一切出てこないで元のメソッドそのままの型がそのまま使えることです。生成されたコードを見ると、こうなっています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Source Generator generate this type
partial struct SampleProxy(Sample target)
{
    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = &amp;quot;_field1&amp;quot;)]
    static extern ref int ___field1__(Sample target);

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &amp;quot;PrivateAdd&amp;quot;)]
    static extern int __PrivateAdd__(Sample target, int x, int y);

    public ref int _field1 =&amp;gt; ref ___field1__(target);
    public int PrivateAdd(int x, int y) =&amp;gt; __PrivateAdd__(target, x, y);
}

public static class SamplePrivateProxyExtensions
{
    public static SampleProxy AsPrivateProxy(this Sample target)
    {
        return new SampleProxy(target);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによって &lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;readonly&lt;/code&gt; などの言語機能をそのまま反映できたり、mutableなstructの対応が自然にできたり、そして何よりパフォーマンスの低下も一切ありません。&lt;/p&gt;
&lt;p&gt;使い道は、主にユニットテスト用になるとは思いますので、なのでパフォーマンスはそこまで重要ではないといえばないのですが、性能的にはアプリケーションの実行時に使っても問題ないものとなっています。&lt;/p&gt;
&lt;p&gt;私は昔&lt;a href="https://github.com/neuecc/ChainingAssertion"&gt;Chaining Assertion&lt;/a&gt;というユニットテスト用のライブラリを作っていたのですが、現在は&lt;a href="https://fluentassertions.com/"&gt;Fluent Assertions&lt;/a&gt;という別のライブラリを使っています。ほとんどの機能は概ねなんとかなっているのですが、&lt;code&gt;AsDynamic()&lt;/code&gt;を呼ぶと、移行はprivateフィールドやメソッドにアクセスし放題という機能は結構便利で、そしてそれがFluent Assertionsにないのは若干不便と思ってたんですね。今回、やっとそれの進化系を作れたのでメデタシメデタシです。&lt;/p&gt;
&lt;h2&gt;C# 12&lt;/h2&gt;
&lt;p&gt;ところで、冒頭のSampleProxyの書き方、地味にこれはC# 12の記法を使っています。どこだかわかりますか？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[GeneratePrivateProxy(typeof(Sample))]
public partial struct SampleProxy;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SampleProxy;&lt;/code&gt; の部分で、空のクラスを作る際に &lt;code&gt;{ }&lt;/code&gt; じゃなくて &lt;code&gt;;&lt;/code&gt; だけで済ませられるようになりました。これは地味ですがかなりいい機能で、というのもSource Generatorだと空クラスに割り当てることが多かったんですよね。そして、たった2文字が1文字に変わっただけ、ではあるのですが、 &lt;code&gt;{ }&lt;/code&gt; だとコードフォーマットに影響があります。改行して3行で表現するのか、後ろにつけるのか。そうした判断のブレが &lt;code&gt;;&lt;/code&gt; だとなくなります。だから2文字が1文字に変わっただけ、以上のインパクトがある、良い機能追加だと思います。&lt;/p&gt;
&lt;h2&gt;ref field&lt;/h2&gt;
&lt;p&gt;PrivateProxyはstaticメソッドにも対応していますし、そしてmutable structにも対応しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using PrivateProxy;

public struct MutableStructSample
{
    int _counter;
    void Increment() =&amp;gt; _counter++;

    // static and ref sample
    static ref int GetInstanceCounter(ref MutableStructSample sample) =&amp;gt; ref sample._counter;
}

// use ref partial struct
[GeneratePrivateProxy(typeof(MutableStructSample))]
public ref partial struct MutableStructSampleProxy;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var sample = new MutableStructSample();
var proxy = sample.AsPrivateProxy();
proxy.Increment();
proxy.Increment();
proxy.Increment();

// call private static method.
ref var counter = ref MutableStructSampleProxy.GetInstanceCounter(ref sample);

Console.WriteLine(counter); // 3
counter = 9999;
Console.WriteLine(proxy._counter); // 9999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mutable structの対応って結構難しい話で、というのもフィールドにstructを保持するとコピーが渡されることになるので、普通に書いていると変更が元のstructに反映されないんですね。この問題をPrivateProxyではC# 11 ref fieldで解決しました。&lt;/p&gt;
&lt;p&gt;MutableStructSampleProxyはSource Generatorによって以下のようなコードが生成されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref partial struct MutableStructSampleProxy
{
    ref MutableStructSample target;

    public MutableStructSampleProxy(ref MutableStructSample target)
    {
        this.target = ref target;
    }

    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = &amp;quot;Increment&amp;quot;)]
    static extern void __Increment__(ref MutableStructSample target);
    
    public void Increment() =&amp;gt; __Increment__(ref this.target);
}

public static class MutableStructSamplePrivateProxyExtensions
{
    public static MutableStructSampleProxy AsPrivateProxy(this ref MutableStructSample target)
    {
        return new MutableStructSampleProxy(ref target);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AsPrivateProxy(これはthis refですが、拡張メソッドの場合、予備側はrefを書かなくていいので自然に使えます)で渡されたstructは、そのままずっとrefのまま保持されています。これにより、メソッド呼び出しでstructの状態に変更があった場合も問題なく変更が共有されています。&lt;/p&gt;
&lt;h2&gt;privateメソッドの単体テスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://t-wada.hatenablog.jp/entry/should-we-test-private-methods"&gt;プライベートメソッドのテストは書かない&lt;/a&gt;みたいな流儀も世の中にはありますが、私は何言ってんの？と思ってます。パブリックメソッドのテストでprivateメソッドの確認が内包されるから不要というなら、はぁー？だったら全部E2Eテストでいいんじゃないですかー？真の振る舞いがテストされますよー？&lt;/p&gt;
&lt;p&gt;もちろんそれは非現実的で、E2Eでパブリックメソッドのロジックを全て通過させるのは手間とコストがかかりすぎる。というのと同じ話で、privateメソッドのエッジケースを全てチェックする時に、public経由だとやりにくいことは往々にある。場合によってはコード通すためにモックを仕込まなければならないかもしれない。そこまでいくとアホらしいですよね、privateメソッドを直接テストすればすむだけの話なのに？メソッドは小さければ小さいほど良いし、テストもしやすい。そしてprivateを内包したpublicよりもprivateそのもののほうが小さく、テストしやすい。&lt;/p&gt;
&lt;p&gt;ようするにコスト面を考えて境界をどこに置くかというだけの話で。そして、privateメソッドのテストそのものは、C#の場合reflection呼び出しだと、変更コストがかかるなど、コスパは悪い部類に入ってしまう。でもそれはただの言語からの制約であって、だからプライベートメソッドのテストは不要みたいなしょーもない理屈をこねて絶対視するほどのことでもない。リフレクション使うとコスパ感が合わないから原則publicで済ませること、ぐらいだったらいいけど、変な教義立てるのはおかしいでしょ。&lt;/p&gt;
&lt;p&gt;チェックしたいがためにprivateであるべきものをinternalにする（たまによくやる、internalならInternalsVisibleToをテストプロジェクトに指定することで、ユニットテストプロジェクトで参照できるようになる）こともありますが、あまりお行儀の良いことではない。そもそもinternalなので同一アセンブリ内では不要に可視レベル上がっちゃってるし。&lt;/p&gt;
&lt;p&gt;と、いうわけで、PrivateProxyは比較的低コストでprivateメソッドをテスト対象にすることができるので、全然使っちゃっていいし、テストも書いちゃって良い、わけです。&lt;/p&gt;
&lt;h2&gt;UnsafeAccessor for InternalCall&lt;/h2&gt;
&lt;p&gt;UnsafeAccessor の使い道として、corelibの InternalCall を強引に呼べることはかなりいいこと（？）だと思ってます。例えば string の生成には大元に &lt;a href="https://source.dot.net/#System.Private.CoreLib/src/System/String.CoreCLR.cs,12"&gt;FastAllocateString&lt;/a&gt; というのがあって、通常ユーザーはこれを呼ぶことはできないのですが&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = &amp;quot;FastAllocateString&amp;quot;)]
static extern string FastAllocateString(string _, int length);

var rawString = FastAllocateString(null!, 10);
var mutableSpan = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(rawString.AsSpan()), rawString.Length);

&amp;quot;abcde&amp;quot;.CopyTo(mutableSpan);
&amp;quot;fghij&amp;quot;.CopyTo(mutableSpan.Slice(5));

Console.WriteLine(rawString); // abcdefghij
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;といったようにUnsafeAccessorを通せばやりたい放題できます。&lt;/p&gt;
&lt;p&gt;Stringに関しては、やりたい放題させないために、&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.string.create"&gt;String.Create&lt;/a&gt;というメソッドが用意されていて、Actionのコールバックで変更して、不変のStringを返すというものが用意されてはいるのですが、ActionだとTStateに&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;を渡せないとか、使えないケースがそれなりにあります、というか使いたいシチュエーションに限って使えないことが多い……。&lt;/p&gt;
&lt;p&gt;なお、こういうFastAllocateStringを呼んでStringに変更をかけるというのは、&lt;a href="https://github.com/dotnet/runtime/issues/36989"&gt;dotnet/runtime#36989 Make string.FastAllocateString public&lt;/a&gt;で見事に却下されています。つまり、やるな、ということです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is never safe or supported to mutate the contents of a returned string instance.
If you mutate a string instance within your own library or application, you are entering unsupported territory.
A future framework update could break you. Or - more likely - you'll encounter memory corruption that will be very painful for you or your customers to diagnose.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;お怒りはご尤もです。しかしString.CreateでAction渡す口あるんだからそれでいいだろーというのはお粗末すぎだと思うんですよねー、どうせやってること一緒なんだから弄るの許可してよ、というのもそれはそれで理解してもらいたいです（私は弄りたいほうの人間なので！）。というわけで、自己責任で、やっていきましょう、つまりやっていくということです……！&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;.NET 8でしか動きません！11月に .NET 8 がリリースされるので、その時まで忘れないでください！&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 21 Sep 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-09-21T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/07/28_yetanotherhttphandler.html</guid>
      <link>https://neue.cc/2023/07/28_yetanotherhttphandler.html</link>
      <title>Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/07/28_yetanotherhttphandler.html"&gt;Unity用のHTTP/2(gRPC) Client、YetAnotherHttpHandlerを公開しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-07-28&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;Cysharpから(主に)Unity用のHTTP/2, gRPC, MagicOnion用の通信ネットワーククライアントを公開しました。実装者は週刊.NET情報配信&lt;a href="https://weekref.net/"&gt;WeekRef.NET&lt;/a&gt;を運営している&lt;a href="https://twitter.com/mayuki"&gt;@mayuki&lt;/a&gt;さんです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/YetAnotherHttpHandler"&gt;Cysharp/YetAnotherHttpHandler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;何故これが必要なのかの背景情報としては、&lt;a href="https://synamon.hatenablog.com/entry/grpc-dotnet-unity"&gt;Synamon’s Engineer blog - Unityでもgrpc-dotnetを使ったgRPCがしたい&lt;/a&gt; が詳しいのですが、まず、.NETには2つのgRPC実装があります。googleが提供してきたgRPCのネイティブバインディングのGrpc.Core(C-Core)と、Microsoftが提供しているPure C#実装のgrpc-dotnet。現在.NETのgRPCはサーバーもクライアントも完全にPure C#実装のほうに寄っていて、&lt;a href="https://github.com/Cysharp/MagicOnion/"&gt;MagicOnion&lt;/a&gt;もサーバーはPure C#実装のものを使っています。&lt;/p&gt;
&lt;p&gt;しかしクライアントに関しては、諸事情によりUnityでは動かない（TLS関連の問題など）ため、ずっとC-Coreを推奨してきました。更に、Unity用のビルドは元々experimentalだったうえに、とっくにメンテナンスモードに入り、そしてついに今年5月にサポート期限も切れて完全に宜しくない気配が漂っていました。また、古いx64ビルドなので最近のMac(M1, M2チップ)では動かないためUnity Editorで使うのにも難儀するといった問題も出てきていました。&lt;/p&gt;
&lt;p&gt;と、いうわけで、CysharpではUnityで使うgRPCを推奨してきたということもあり、Unityで問題なく使えるgRPC実装としてYetAnotherHttpHandlerを開発・リリースしました。HttpClientの通信レイヤーであるHttpHandlerを差し替えるという形で実装してあるので、ほとんど通常の .NET でのgRPCと同様に扱えます。&lt;/p&gt;
&lt;p&gt;内部実装としてはPure Rust実装のHTTP/2ライブラリ&lt;a href="https://hyper.rs/"&gt;hyper&lt;/a&gt;とPure RustのTLSライブラリ&lt;a href="https://github.com/rustls/rustls"&gt;rustls&lt;/a&gt;を基盤として作ったネイティブライブラリに対して、&lt;a href="https://github.com/Cysharp/csbindgen"&gt;Cysharp/csbindgen&lt;/a&gt;で生成したC#バインディングを通して通信する形になっています。&lt;/p&gt;
&lt;h2&gt;余談&lt;/h2&gt;
&lt;p&gt;YetAnotherHttpHandlerはgRPCやMagicOnionに限らず、Unityで自由に使える HTTP/2 Clientなので、アセットダウンロードの高速化にHTTP/2を用いる、といったような使い道も考えられます。既にモバイルゲームでも幾つかのタイトルでHTTP/2でアセットダウンロードしているタイトルは確認できていまして、例えばセガさんは&lt;a href="https://speakerdeck.com/segadevtech/cedec2021-taunrotoshi-jian-woda-fu-jian-da-liang-falseasetutowosahakugao-su-nashi-zhuang-toyun-yong-shi-li-falsegong-you"&gt;CEDEC2021 ダウンロード時間を大幅減！～大量のアセットをさばく高速な実装と運用事例の共有～&lt;/a&gt;のような発表もされています。ネイティブプラグインを自前でビルドして持ち込むというのはだいぶ敷居が高い話でしたが、YetAnotherHttpHandlerを入れるだけでいいなら、だいぶやれるんじゃないか感も出てくるんじゃないでしょうか……？&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 28 Jul 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-07-28T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/07/20_nats_client_v2.html</guid>
      <link>https://neue.cc/2023/07/20_nats_client_v2.html</link>
      <title>AlterNats は 公式の NATS .NET Client v2 に引き継がれました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/07/20_nats_client_v2.html"&gt;AlterNats は 公式の NATS .NET Client v2 に引き継がれました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-07-20&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;&lt;a href="https://nats.io/"&gt;NATS&lt;/a&gt;のサードパーティー(alternative)クライアントであった&lt;a href="https://github.com/Cysharp/AlterNats"&gt;AlterNats&lt;/a&gt;は、公式に引き取られて&lt;a href="https://github.com/nats-io/nats.net.v2"&gt;NATS.NET V2&lt;/a&gt;となりました。v2の詳細に関してはNATS公式からのブログ&lt;a href="https://nats.io/blog/nats-dotnet-v2-alpha-release/"&gt;NATS .NET Client v2 Alpha Released with Core NATS Support&lt;/a&gt;を参照ください。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NATS community members started to take note, and develop client libraries for NATS based on modern .NET APIs. One notable client library that emerged was the AlterNats library by Cysharp, which includes a fully asynchronous API, leverages Span&lt;T&gt; , and supports client-side WebSockets from browsers in Blazor . NATS maintainers and AlterNats maintainers agreed that AlterNats would make a great starting point for NATS.Client v2!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NATSに関してはAlterNatsリリース時の記事 &lt;a href="https://neue.cc/2022/05/11_AlterNats.html"&gt;AlterNats - ハイパフォーマンスな.NET PubSubクライアントと、その実装に見る.NET 6時代のSocketプログラミング最適化のTips、或いはMagicOnionを絡めたメタバース構築のアーキテクチャについて&lt;/a&gt;に色々書きましたが、&lt;a href="https://www.cncf.io/"&gt;Cloud Native Computing Foundation&lt;/a&gt;配下のPubSubミドルウェアで、RedisなどでのPubSubに比べるとパフォーマンスを始めとして多くのメリットがあります。&lt;/p&gt;
&lt;p&gt;ただしこういうものはサーバー実装も重要ですがクライアント実装も重要であり、そして当時のNATSの公式クライアント(v1)は正直酷かった！せっかくの素晴らしいミドルウェアが.NETでは活かされない、また、RedisでのPubSubには不満があり、そもそも.NETでのベストなPubSubのソリューションがないことに危機意識を感じていたので、独自に実装を進めたのがAlterNatsでした。&lt;/p&gt;
&lt;p&gt;ただし、枯れたプロトコルならまだしも、進化が早いミドルウェアのクライアントが乱立しているのは決して良いことでもないでしょう。新機能への追随速度やメンテナンスの保証という点でも、サードパーティクライアントとして進んでいくよりも、公式に統合されることのほうが絶対に良いはずです。&lt;/p&gt;
&lt;p&gt;というわけで今回の流れは大変ポジティブなことだし、野良実装にとって最高の道を辿れたんじゃないかと思っています。私自身は実装から一歩引きますが、使っていく上で気になるところがあれば積極的にPR上げていくつもりではあります。&lt;/p&gt;
&lt;p&gt;なお、NATSに関しては来月CEDEC 2023でのセッション&lt;a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3"&gt;メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～&lt;/a&gt;で触れる、かもしれません、多分。というわけでぜひ聞きに来てください……！&lt;/p&gt;
&lt;p&gt;メタバース関連では、今年の5月にTGS VRなどを手掛けている&lt;a href="https://ambr.co.jp/"&gt;ambr&lt;/a&gt;さんのテックブログにて&lt;a href="https://ambr-inc.hatenablog.com/entry/20230512/1683882000"&gt;VRメタバースのリアルタイム通信サーバーの技術にMagicOnionとNATSを選んだ話&lt;/a&gt;という紹介もしていただいていました。&lt;/p&gt;
&lt;h2&gt;OSSとメンテナンスの引き継ぎ&lt;/h2&gt;
&lt;p&gt;権限の移管は何度か経験があって&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mihaifm/linq"&gt;linq.js&lt;/a&gt;、&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/runceel/ReactiveProperty"&gt;ReactiveProperty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/xin9le/CloudStructures"&gt;CloudStructures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;は完全に手放しています。ほか、&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;はCysharp名義に移ったうえで、現在の開発リードは私ではありません。また、最近では&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack for C#&lt;/a&gt;はMessagePack-CSharp Organizationに移していて共同のOwner権限になっています。&lt;/p&gt;
&lt;p&gt;どうしても常に100%の力を一つのOSSに注ぐことはできないので、本来はうまく移管していけるのが良いわけですが、いつもうまくできるわけじゃなくて、&lt;a href="https://github.com/neuecc/Utf8Json"&gt;Utf8Json&lt;/a&gt;なんかはうまく移管できないままarchivedにしてしまっています。&lt;/p&gt;
&lt;p&gt;やっぱ出した当時は自分が手綱を握っていたいという気持ちがとても強いわけですが、関心が徐々に薄れていくタイミングと他の人に渡せるタイミングがうまく噛み合わないと、死蔵になってしまうというところがあり、まぁ、難しいです。これだけやっていても上手くできないなあ、と……。&lt;/p&gt;
&lt;p&gt;今回のは大変良い経験だったので、作ってメンテナンスを続ける、そしてその先についても考えてやっていきたいところですね。&lt;/p&gt;
&lt;p&gt;ともあれ、良い事例を一つ作れた＆素晴らしいライブラリをC#に一つ持ち込むことができたということで、とても気分がよいですです。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-07-20T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/07/07_mvp-renew13.html</guid>
      <link>https://neue.cc/2023/07/07_mvp-renew13.html</link>
      <title>Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/07/07_mvp-renew13.html"&gt;Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々々々々受賞しました&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-07-07&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;13回目です！一年ごとに再審査での更新で、変わらずC#の最前線に立てています。&lt;/p&gt;
&lt;p&gt;活動の中心は引き続きOSSですが、&lt;a href="https://github.com/Cysharp"&gt;github/Cysharp&lt;/a&gt;でのスター数は変わらず他を圧倒していると思いますし、毎年の新規の公開数の勢いも変わらずで新しいアイディアを出し続けています。&lt;/p&gt;
&lt;p&gt;今年は&lt;a href="https://github.com/Cysharp/csbindgen"&gt;csbindgen&lt;/a&gt;を起点にしてRustを活用してC#の活用幅をより広げていくことを狙っています。先日公開した&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;MagicPhysX&lt;/a&gt;の他にも色々計画がって、かなり面白いインパクトが出せるんじゃないかと思っています。&lt;/p&gt;
&lt;p&gt;MessagePack for C#も&lt;a href="https://github.com/MessagePack-CSharp/MessagePack-CSharp"&gt;MessagePack-CSharp/MessagePack-CSharp&lt;/a&gt;と、organization名義に移したことで（変わらず私はOwnerなので権限を手放したわけではありません）より中立的に発展させていきます。直近ではSource Generator対応が予定されています(preview版を公開中）。&lt;/p&gt;
&lt;p&gt;というわけで、これはもう満場一致でC#に貢献しているということでいいんじゃないでしょうかね……？&lt;/p&gt;
&lt;p&gt;ここ最近は登壇していなかったのですが、去年は&lt;a href="https://speakerdeck.com/neuecc/c-number-11-niyorushi-jie-zui-su-bainarisiriaraiza-memorypack-nozuo-rifang"&gt;C#11 による世界最速バイナリシリアライザー「MemoryPack」の作り方&lt;/a&gt;というセッションをしました。その流れということで、今年の8月にCEDEC 2023にて&lt;a href="https://cedec.cesa.or.jp/2023/session/detail/s642165615a6b5"&gt;モダンハイパフォーマンスC# 2023 Edition&lt;/a&gt;、それと共同講演で&lt;a href="https://cedec.cesa.or.jp/2023/session/detail/s64258612468b3"&gt;メタバースプラットフォーム「INSPIX WORLD」はPHPもC++もまとめてC#に統一！～MagicOnionが支えるバックエンド最適化手法～&lt;/a&gt;という2つの登壇予定があるので、ぜひ見に来てください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Fri, 07 Jul 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-07-07T00:00:00+09:00</a10:updated>
    </item>
    <item>
      <guid isPermaLink="true">https://neue.cc/2023/07/04_MagicPhysX.html</guid>
      <link>https://neue.cc/2023/07/04_MagicPhysX.html</link>
      <title>MagicPhysX - .NET用のクロスプラットフォーム物理エンジン</title>
      <description>&lt;h1&gt;&lt;a href="https://neue.cc/2023/07/04_MagicPhysX.html"&gt;MagicPhysX - .NET用のクロスプラットフォーム物理エンジン&lt;/a&gt;&lt;/h1&gt;
&lt;ul class="date"&gt;&lt;li&gt;2023-07-04&lt;/li&gt;&lt;/ul&gt;
&lt;div class="entry_body"&gt;&lt;p&gt;MagicPhysXというライブラリを新しく公開しました！.NETで物理エンジンを動かすというもので、その名の通り、&lt;a href="https://github.com/NVIDIA-Omniverse/PhysX"&gt;NVIDIA PhysX
&lt;/a&gt;のC#バインディングとなっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MagicPhysX"&gt;Cysharp/MagicPhysX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使い道としては&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUIアプリケーションの3D部分&lt;/li&gt;
&lt;li&gt;自作ゲームエンジンへの物理エンジン組み込み&lt;/li&gt;
&lt;li&gt;ディープラーニングのためのシミュレーション&lt;/li&gt;
&lt;li&gt;リアルタイム通信におけるサーバーサイド物理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といったことが考えられます。&lt;/p&gt;
&lt;p&gt;.NET用のPhysXバインディングは他にも存在しますが、C++/CLIでバインディングを生成している都合上Windowsでしか動かせなかったり、バージョンが最新ではない4.xベースだったりしますが、MagicPhysXは最新のPhysX 5ベースで、かつ、Windows, MacOS, Linuxの全てで動きます！(win-x64, osx-x64, osx-arm64, linux-x64, linux-arm64)。これはバインディングの作り方としてクロスプラットフォームコンパイルに強いRustと、&lt;a href="https://github.com/Cysharp/csbindgen"&gt;Cysharp/csbindgen&lt;/a&gt;によってC#のバインディングの自動生成をしているからです。&lt;/p&gt;
&lt;p&gt;先にアーキテクチャの話をしましょう。MagicPhysXは&lt;a href="https://www.embark-studios.com/"&gt;EmbarkStudios&lt;/a&gt;による&lt;a href="https://github.com/EmbarkStudios/physx-rs"&gt;physx-rs&lt;/a&gt;をビルド元に使っています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EmbarkStudiosはEA DICEで&lt;a href="https://www.ea.com/frostbite"&gt;Frostbite&lt;/a&gt;ゲームエンジン(Battlefield)を作っていた人たちが独立して立ち上げたスタジオで、Rustによるゲームエンジンを作成中です。また、その過程で生まれたRustのライブラリをOSSとして積極的に公開しています。一覧は&lt;a href="https://embark.dev/"&gt;Embark Studios Open Source&lt;/a&gt;にあります。必見！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PhysXのライブラリはC++で出来ていて、他の言語で使うことは考慮されていません。そのために他の言語に持ち込むためには、C++上で別言語で使うためのブリッジ部分を作った上で、バインディングを用意するという二度手間が必要になってきます。それはRustであっても例外ではありません。また、二度手間というだけではなく、PhysXのソースコードはかなり大きいため、その作業量も膨大です。&lt;/p&gt;
&lt;p&gt;以前に&lt;a href="https://neue.cc/2023/03/09-csbindgen.html"&gt;csbindgen - C#のためのネイティブコード呼び出し自動生成、或いはC#からのネイティブコード呼び出しの現代的手法について&lt;/a&gt;で紹介しましたが、&lt;a href="https://www.swig.org/"&gt;SWIG&lt;/a&gt;などのC++からの自動生成、Rustであれば&lt;a href="https://cxx.rs/"&gt;cxx&lt;/a&gt;、&lt;a href="https://github.com/google/autocxx"&gt;autocxx&lt;/a&gt;のような自動化プロジェクトも存在しますが、C++そのものの複雑さからいっても、求めるものを全自動で出力するのは難しかったりします。&lt;/p&gt;
&lt;p&gt;physx-rsでは&lt;a href="https://www.youtube.com/watch?v=RxtXGeDHu0w"&gt;An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)&lt;/a&gt;というセッションでPhysXをRustに持ち込むための手段の候補、実際に採用した手段についての解説があります。最終的に採用された手段について端的に言うと、PhysXに特化してコード解析してC APIを生成する独自ジェネレーターを用意した、といったところでしょうか。そしてつまり、physx-rsには他言語でもバインディング手段として使えるPhysXのC APIを作ってくれたということにもなります！&lt;/p&gt;
&lt;p&gt;更にcsbindgenには、rsファイル内のextern &amp;quot;C&amp;quot;の関数からC#を自動生成する機能が備わっているので、Rustを経由することでC++のPhysXをC#に持ち込めるというビルドパイプラインとなりました。&lt;/p&gt;
&lt;p&gt;そういう成り立ちであるため、MagicPhysXのAPIはPhysXのAPIそのものになっています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using MagicPhysX; // for enable Extension Methods.
using static MagicPhysX.NativeMethods; // recommend to use C API.

// create foundation(allocator, logging, etc...)
var foundation = physx_create_foundation();

// create physics system
var physics = physx_create_physics(foundation);

// create physics scene settings
var sceneDesc = PxSceneDesc_new(PxPhysics_getTolerancesScale(physics));

// you can create PhysX primitive(PxVec3, etc...) by C# struct
sceneDesc.gravity = new PxVec3 { x = 0.0f, y = -9.81f, z = 0.0f };

var dispatcher = phys_PxDefaultCpuDispatcherCreate(1, null, PxDefaultCpuDispatcherWaitForWorkMode.WaitForWork, 0);
sceneDesc.cpuDispatcher = (PxCpuDispatcher*)dispatcher;
sceneDesc.filterShader = get_default_simulation_filter_shader();

// create physics scene
var scene = physics-&amp;gt;CreateSceneMut(&amp;amp;sceneDesc);

var material = physics-&amp;gt;CreateMaterialMut(0.5f, 0.5f, 0.6f);

// create plane and add to scene
var plane = PxPlane_new_1(0.0f, 1.0f, 0.0f, 0.0f);
var groundPlane = physics-&amp;gt;PhysPxCreatePlane(&amp;amp;plane, material);
scene-&amp;gt;AddActorMut((PxActor*)groundPlane, null);

// create sphere and add to scene
var sphereGeo = PxSphereGeometry_new(10.0f);
var vec3 = new PxVec3 { x = 0.0f, y = 40.0f, z = 100.0f };
var transform = PxTransform_new_1(&amp;amp;vec3);
var identity = PxTransform_new_2(PxIDENTITY.PxIdentity);
var sphere = physics-&amp;gt;PhysPxCreateDynamic(&amp;amp;transform, (PxGeometry*)&amp;amp;sphereGeo, material, 10.0f, &amp;amp;identity);
PxRigidBody_setAngularDamping_mut((PxRigidBody*)sphere, 0.5f);
scene-&amp;gt;AddActorMut((PxActor*)sphere, null);

// simulate scene
for (int i = 0; i &amp;lt; 200; i++)
{
    // 30fps update
    scene-&amp;gt;SimulateMut(1.0f / 30.0f, null, null, 0, true);
    uint error = 0;
    scene-&amp;gt;FetchResultsMut(true, &amp;amp;error);

    // output to console(frame-count: position-y)
    var pose = PxRigidActor_getGlobalPose((PxRigidActor*)sphere);
    Console.WriteLine($&amp;quot;{i:000}: {pose.p.y}&amp;quot;);
}

// release resources
PxScene_release_mut(scene);
PxDefaultCpuDispatcher_release_mut(dispatcher);
PxPhysics_release_mut(physics);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり、そのままでは決して扱いやすくはないです。部分的に動かすだけではなく、本格的にアプリケーションを作るなら、ある程度C#に沿った高レベルなフレームワークを用意する必要があるでしょう。MagicPhysX内ではそうしたサンプルを用意しています。それによって上のコードはこのぐらいシンプルになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using MagicPhysX.Toolkit;
using System.Numerics;

unsafe
{
    using var physics = new PhysicsSystem(enablePvd: false);
    using var scene = physics.CreateScene();

    var material = physics.CreateMaterial(0.5f, 0.5f, 0.6f);

    var plane = scene.AddStaticPlane(0.0f, 1.0f, 0.0f, 0.0f, new Vector3(0, 0, 0), Quaternion.Identity, material);
    var sphere = scene.AddDynamicSphere(1.0f, new Vector3(0.0f, 10.0f, 0.0f), Quaternion.Identity, 10.0f, material);

    for (var i = 0; i &amp;lt; 200; i++)
    {
        scene.Update(1.0f / 30.0f);

        var position = sphere.transform.position;
        Console.WriteLine($&amp;quot;{i:D2} : x={position.X:F6}, y={position.Y:F6}, z={position.Z:F6}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ただしあくまでサンプルなので、参考にしてもらいつつも、必要な部分は自分で作ってもらう必要があります。&lt;/p&gt;
&lt;p&gt;Unityのようなエディターがないと可視化されてなくて物理エンジンが正しい挙動になっているのか確認できない、ということがありますが、PhysXにはPhysX Visual Debuggerというツールが用意されていて、MagicPhysXでも設定することでこれと連動させることが可能です。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46207/250030945-2018e821-41c4-44a2-aac6-f0705993ab9b.png" alt="" /&gt;&lt;/p&gt;
&lt;h2&gt;Dedicated Server&lt;/h2&gt;
&lt;p&gt;Cysharpでは&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;や&lt;a href="https://github.com/Cysharp/LogicLooper"&gt;LogicLooper&lt;/a&gt;といったサーバーサイドでゲームのロジックを動かすためのライブラリを開発しています。その路線から行って物理エンジンが必要なゲームでさえも通常の .NET サーバーで動かしたいという欲求が出てくるのは至極当然でしょう……（？）&lt;/p&gt;
&lt;p&gt;UEやUnityのDedicated Serverの構成だとヘッドレスなUE/Unityアプリケーションをサーバー用ビルドしてホスティングすることになりますが、サーバー用のフレームワークではないので、あまり作りやすいとは言えないんですよね。通常用サーバー向けのライブラリとの互換性、ライフサイクルの違い、ランタイムとしてのパフォーマンスの低さ、などなど。&lt;/p&gt;
&lt;p&gt;というわけで、MagicOnionのようなサーバー向けフレームワークを使ったほうがいいのですが、物理エンジンだけはどうにもならない。今までは……？&lt;/p&gt;
&lt;p&gt;と、言いたいのですが、まずちゃんとしっかり言っておきたいのですが、現実的には少々（かなり）難しいでしょう！コライダーどう持ってくるの？とかAPIが違う（Unityの物理エンジンはPhysXですが、API的に1:1の写しではないので細かいところに差異がある）のでそもそも挙動を合わせられないし、でもこういう構成ならサーバーだけじゃなくクライアントでも動かしたい、そもそもそうじゃないとデバッガビリティが違いすぎる。&lt;/p&gt;
&lt;p&gt;と、ようするに、もしゲーム自体にある程度、物理エンジンに寄せた挙動が必要なら、「物理エンジン大統一」が必須だと。MagicPhysXは残念ながらそうではありません。実のところ当初はそれを目指していました、Unityとほぼ同一挙動でほぼ同一APIになるのでシームレスに持ち込むことができるライブラリなのだ、と。しかし現状はそうではないということは留意してください。また、その当初予定である互換APIを作り込む予定もありません。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;このライブラリ、かなり迷走したプロジェクトでもあって、そもそも最初は&lt;a href="https://github.com/bulletphysics/bullet3"&gt;Bullet Physics&lt;/a&gt;を採用する予定でした。ライブラリ名が先に決めてあってMagicBulletってカッコイイじゃん、みたいな。その後に&lt;a href="https://github.com/jrouwe/JoltPhysics"&gt;Jolt Physics&lt;/a&gt;を使おうとして、これもバインディングをある程度作って動く状態にしたのですが、「物理エンジン大統一」のためにPhysXにすべきだろうな、という流れで最終的にPhysXを使って作ることにしました。&lt;/p&gt;
&lt;p&gt;形になって良かったというのはありますが（そしてcsbindgenの実用性！）、「物理エンジン大統一」を果たせなかったのは少々残念ではあります。最初の完成予想図ではもっともっと革命的なもののはずだったのですが……！&lt;/p&gt;
&lt;p&gt;とはいえ、PhysX 5をクロスプラットフォームで.NETに持ち込んだということだけでも十分に難易度が高く新しいことだと思っているので、試す機会があれば、是非触って見ください。&lt;/p&gt;
&lt;/div&gt;</description>
      <pubDate>Tue, 04 Jul 2023 00:00:00 +0900</pubDate>
      <a10:updated>2023-07-04T00:00:00+09:00</a10:updated>
    </item>
  </channel>
</rss>