<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2010-06</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2010/06/29_264.html">linq.js ver.2.2.0.0 - 配列最適化, QUnitテスト, RxJSバインディング</a></h1>
<ul class="date"><li>2010-06-29</li></ul>
<div class="entry_body"><p><a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">CodePlex - linq.js - LINQ for JavaScript</a></p>
<p>linq.jsをver 2.2に更新しました。変更事項は、メソッドの追加、配列ラッピング時の動作最適化、ユニットテストのQUnitへの移行、RxJSバインディング追加の4つです(あと、若干のバグフィックスと、RxJS用vsdoc生成プログラムの同梱)。まずは、追加した二つのメソッドについて。</p>
<pre><code class="language-javascript">var seq = Enumerable.From([1, 5, 10, 4, 3, 2, 99]);

// TakeFromLastは末尾からn個の値を取得する
var r1 = seq.TakeFromLast(3).ToArray(); // [3, 2, 99]
// 2.0から追加されているTakeExceptLast(末尾からn個を除く)と対になっています
var r2 = seq.TakeExceptLast(3).ToArray(); // [1, 5, 10, 4]

// ToJSONはjson文字列化します(列挙をJSON化なので必ず配列の形になります)
// JSON.stringifyによるJSON化のため、
// ネイティブJSON対応ブラウザ(IE8以降, Firefox, Chrome, Opera...)
// もしくはjson2.jsをインポートしていないと動作しません
var objs = [{ hoge: &quot;huga&quot; }, { tako: 3}];
var json = Enumerable.From(objs).ToJSON(); // [{&quot;hoge&quot;:&quot;huga&quot;},{&quot;tako&quot;:3}]
</code></pre>
<p>TakeFromLast/TakeExceptLastはRxからの移植です(Rxについては後でまた少し書きます)。RxではTakeLast, SkipLastという名前ですが、諸般の都合により名前は異なります。より説明的なので悪くはないかな、と。</p>
<p>もう一つはToJSONの復活。ver 1.xにはあったのですが、2.xでばっさり削ってたました。復活といっても、実装は大きく違います。1.xでは自前でシリアライズしていたのですが、今回はJSON.stringifyに丸投げしています。と、いうのも、IE8やそれ以外のブラウザはJSONのネイティブ実装があるので、それに投げた方が速いし安全。ネイティブ実装は<a href="http://www.json.org/js.html">json2.js</a>と互換性があるので、IE6とかネイティブ実装に対応していないブラウザに対しては、json2.jsを読み込んでおくことでToJSONは動作します。</p>
<p>json2.jsはネイティブ実装がある場合は上書きせずネイティブ実装を優先するようになっているので、JSON使う場合は何も考えずとりあえず読み込んでおくといいですね。</p>
<h2>配列ラップ時の最適化</h2>
<p>Any, Count, ElementAt, ElementAtOrDefault, First, FirstOrDefault, Last, LastOrDefault, Skip, SequenceEqual, TakeExceptLast, TakeFromLast, Reverse, ToString。</p>
<p>Enumerable.From(array)の直後に、以上のメソッドを呼んだ際は最適化された挙動を取るように変更しました。各メソッドに共通するのは、lengthが使えるメソッドということです。Linqは基本的に長さの情報を持っていない(無限リストとか扱えるから)ため、例えばCountだったら最後まで列挙して長さを取っていました。しかし、lengthが分かっているのならば、Countはlengthに置き換えられるし、Reverseは[length - 1]から逆順に列挙すればいい。ElementAt(n)はまんま[n]だしLastは[length - 1]だし、などなど、lengthを使うことで計算量が大幅に低減されます。</p>
<p>C#でも同様のことをやっている(ということは以前に<a href="http://neue.cc/2009/07/21_178.html">LinqとCountの効率</a>という記事で書いてあったりはする)のですが、今になってようやく再現。先の記事にあるように、C#では中でisやasを使ってIEnumerableの型を調べて分岐させてますが、linq.jsでは Enumerable.FromでEnumerableを生成する際に、今まではEnumerableを返していたところを、ArrayEnumerable(継承して配列用にメソッドをオーバーライドしたもの)を返す、という形を取っています。</p>
<p>これが嬉しいかどうかというと、そこまで気にするほどではありません。C#では array.Last() のように使えますが、linq.jsではわざわざ Enumerable.From(array).Last() と、ラップしなきゃいけませんから、それならarray[array.length - 1]でいいよ、という。ちなみに当然ですがFrom(array).Where().Count()とか、他のLinqメソッドを挟むと、ArrayEnumerableじゃなくEnumerableになるため最適化的なものは消滅します。</p>
<p>でもまあ、意味はあるといえばあります。配列を包んだだけのEnumerableは割と色々なところで出てきます。例えばGroupJoin。これのresultSelectorの引数のEnumerableは、配列をラップしただけです。又は、ToLookup。Lookupを生成後、Getで取得した際の戻り値のEnumerableは配列を包んだだけです。GroupByの列挙(Grouping)もそう。特にGroupingで、グループの個数を使うってシーンは多いように思います。そこで今まではCount()で全件列挙が廻っていたのが、一度も列挙せずに値が取れるというのは精神衛生上喜ばしい。</p>
<h2>パフォーマンス？</h2>
<p>このArrayへの最適化は勿論パフォーマンスのためなのですが、じゃあ全体的にlinq.jsのパフォーマンスはどうなの？というと、遅いよ！少し列挙するだけで山のように関数呼び出しが間に入りますから、速そうな要素が一つもない。ただ、遅さがクリティカルに影響するほどのものかは、場合によりけりなので分かりません。遅い遅いと言っても、jQueryでセレクタ使って抽出してDOM弄りするのとどちらが重いかといったら、(データ量にもよりますが)圧倒的にDOM弄りですよね？的な。</p>
<p>JavaScriptは、どうでもいいようなレベルの高速化記事がはてブなんかにも良く上がってくるんですが、つまらない目先に囚われず、全体を見てボトルネックをしっかり掴んでそこを直すべきだと思うんですよね。「１万回の要素追加で9msの高速化」とか、意味無いだろそれ絶対と思うのですが……。</p>
<p>ただ、アプリケーションとライブラリだと話は別で、ライブラリならば1msでも速いにこしたことはないのは事実です。linq.jsは仕組み的には遅いの確定なのはしょうがないとしても、もう少しぐらいは、速度に気を使って努力すべきな気はとてもします。今後の課題。</p>
<h2>コードスニペット</h2>
<p>無名関数書くのに、毎回function(x) { return って書くの、面倒くさいですよね。ということで、Visual Studio用のコードスニペットを同梱しました。func1-&gt;Tab-&gt;Tabで、linq.jsで頻繁に使う一行の無名関数 function(x){ return /* キャレットここ */ } を生成してくれます。これは激しく便利で、C#の快適さの3割ぐらいを占めていると言っても過言ではないぐらいに便利なのですが、動画じゃないと伝わらないー、けれど動画撮ってる体力的余裕がないので省略。</p>
<p>func0, func1, func2, action0, action1, action2を定義しています。0だの1だのは引数の数。funcはreturn付き、actionはreturn無しのスニペットです。また、Enumerable.RangeとEnumerable.Fromにもスニペットを用意しました。erange, efromで展開されます。jQueryプラグイン版の場合はjqrange, jqfromになります。</p>
<p>インストールは、Visual Studio 2010でツール→コードスニペットマネージャーを開いてインポートでsnipetts/.snippetを全部インポート。</p>
<h2>binding for RxJS</h2>
<p><a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">RxJS -Reactive Extensions for JavaScript</a>と接続出来るようになりました。ToObservableとToEnumerableです(jQuery版のTojQueryとtoEnumerableと同じ感覚)。</p>
<pre><code class="language-javascript">// enumerable sequence to observable
var source = Enumerable.Range(1, 10)
    .Shuffle()
    .ToObservable()
    .Publish();

source.Where(function (x) { return x % 2 == 0 })
    .Subscribe(function (x) { document.writeln(&quot;Even:&quot; + x + &quot;&lt;br&gt;&quot;) });

source.Where(function (x) { return x % 2 != 0 })
    .Subscribe(function (x) { document.writeln(&quot;Odd:&quot; + x + &quot;&lt;br&gt;&quot;) });

source.Connect();

// observable to enumerable
var subject = new Rx.ReplaySubject();

subject.OnNext(&quot;I&quot;);
subject.OnNext(4);
subject.OnNext(&quot;B&quot;);
subject.OnNext(2);
subject.OnNext(&quot;M&quot;);

var result = subject.ToEnumerable()
    .OfType(String)
    .Select(function (x) { return x.charCodeAt() - 1 })
    .Select(function (x) { return String.fromCharCode(x) })
    .ToString(&quot;-&quot;);

alert(result); // H-A-L
</code></pre>
<p>ToObservableでは、<a href="http://neue.cc/2010/06/24_263.html" title="neue cc - Reactive Extensions for .NET (Rx) メソッド探訪第7回:IEnumerable vs IObservable">こないだ例に出したPublishによる分配</a>を。ToEnumerableは、例が全然浮かばなかったので適当にOnNextを発火させた奴をEnumerable化出来ますねー、と。なお、cold限定です。hotに対して適用すると空シーケンスが返ってくるだけです(ちなみにC#版のRxでhotに対してToEnumerableするとスレッドをロックして無限待機になる)</p>
<p>それと、RxVSDocGeneratorの最新版を同梱してあります。<a href="http://neue.cc/2010/03/26_248.html" title="neue cc - RxJS用IntelliSense生成プログラム(と、VisualStudioのJavaScript用vsdocの書き方)">以前に公開していた</a>のは、RxJSのバージョンアップと同時に動かなくなっちゃってたのよね。というわけで、修正したうえで同梱商法してみました。</p>
<h2>プレースホルダの拡張</h2>
<p>無名関数のプレースホルダが少し拡張されました。今までは引数が一つの時のみ$が使えたのですが、今回から二引数目は$$、三引数目は$$$、四引数目は$$$$が使えるようになりました。</p>
<pre><code class="language-javascript">// 連続した重複がある場合最初の値だけを取る
// (RxのDistinctUntilChangedをlinq.jsでやる場合)
// 1, 5, 4, 3, 4
Enumerable.From([1, 1, 5, 4, 4, 3, 4, 4])
    .PartitionBy(&quot;&quot;, &quot;&quot;, &quot;key,group=&gt;group.First()&quot;)
// $$でニ引数目も指定出来るようになった
Enumerable.From([1, 1, 5, 4, 4, 3, 4, 4])
    .PartitionBy(&quot;&quot;, &quot;&quot;, &quot;$$.First()&quot;)
</code></pre>
<p>便利といえば便利ですが、あまりやりすぎると見た目がヤバくなるので適度に抑えながらでどうぞ。なお、以前からある機能ですが&quot;&quot;は&quot;x=&gt;x&quot;の省略形です。PartitionByでは、それぞれkeySelectorとelementSelector。</p>
<h2>入門QUnit</h2>
<p>今までlinq.jsのユニットテストはJSUnitを使用していたんですが、相当使いにくくてやってられなかったため、QUnitに移しました。QUnitはjQueryの作者、John Resigの作成したテストフレームワークで、流石としか言いようがない出来です。物凄く書きやすい。JSUnitだとテストが書きづらくて、だから苦痛でしかなかった。テストドリブンとか言うなら、まずはテストが書きやすい環境じゃないとダメだ。</p>
<p>JSUnitのダメな点―― 導入が非常に面倒。大量のファイルを抱えたテスト実行環境が必要だし、クエリストリングでファイル名を渡さなければならなかったり、しかも素ではFirefox3で動かなかったりと(Firefox側のオプションを調整)下準備が大変。面倒くささには面倒くささなりのメリット(Java系の開発環境との連携とかあるらしいけど知らない)があるようですが、俺はただテスト書いて実行したいだけなんだよ！というには些か重たすぎる。一方、QUnitはCSSとJSとHTMLだけで済む。</p>
<p>また、JSUnitはアサーションのメソッドが微妙。大量にあるんだけど、逆に何が何だか分からない。assertObjectEqualsとかassertArrayEqualsとか。ArrayEqualsはオブジェクトの配列を値比較してくれない上に、それならせめて失敗してくれればいいものの成功として出されるから役に立たなかったり、ね……。QUnitは基本、equal(参照比較)とdeepEqual(値比較)だけという分かりやすさ。deepEqualはしっかりオブジェクト/配列をバラして再帰的に比較してくれるという信頼感があります。</p>
<p>テスト結果画面の分かりやすさもQUnitに軍配が上がる。というかJSUnitは致命的に分かりづらい。一つのテスト関数の中に複数のアサートを入れると、どれが失敗したか分からないという有様。なのでJSUnitではtestHoge1, testHoge2といった形にせざるを得ないのだけど、大変面倒。更に、JSUnitのテスト実行は遅くて数百件あるとイライラする。</p>
<p>そもそもJSUnitはコードベースが古いし最近更新されてるかも微妙(GitHubに移って開発は進んでるようですが)。というわけで今からJavaScriptでユニットテストやるならQUnitがいいよ！残念ながらか、ネットを見ると古い紹介記事ばかりが見当たるので、ていうかオフィシャルのドキュメントまで古かったりしてアレゲなので、簡単に解説します。と、思ってたのですが、一月程前に素晴らしいQUnitの記事が出ていました。なので基本無用なのですが、文章を書いてしまってあったので(これ書いてたのは4月頃なのです)出します、とほほ。</p>
<p>まず、<a href="http://docs.jquery.com/QUnit">QUnit - jQuery JavaScript Library</a>のUsing QUnitのところにあるqunit.jsとqunit.cssを落とし、下記のテンプレHTMLは自前で作る。ファイル名はなんでもいいんですが、私はtestrunner.htmとでもしておきました。</p>
<pre><code class="language-xml">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;linq.js test&lt;/title&gt;
    &lt;link href=&quot;qunit.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
    &lt;script src=&quot;qunit.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;!-- テストに必要な外部ライブラリは好きに読み込む --&gt;
    &lt;script src=&quot;linq.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;!-- ここにテスト直書きもアリだし --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        test(&quot;Range&quot;, function()
        {
            deepEqual(Enumerable.Range(1, 3).ToArray(), [1, 2, 3]);
        });
        // 自動的にロード後に実行されるので、これも問題なく動く
        test(&quot;hoge&quot;, function ()
        {
            var h2 = document.getElementsByTagName(&quot;h2&quot;);
            equal(h2.length, 2);
        });
    &lt;/script&gt;
    &lt;!-- 外部jsファイルにして読み込むのもアリ --&gt;
    &lt;script src=&quot;testEnumerable.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;testProjection.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 id=&quot;qunit-header&quot;&gt;linq.js test&lt;/h1&gt;
    &lt;h2 id=&quot;qunit-banner&quot;&gt;&lt;/h2&gt;
    &lt;h2 id=&quot;qunit-userAgent&quot;&gt;&lt;/h2&gt;
    &lt;ol id=&quot;qunit-tests&quot;&gt;&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>実行用のHTMLにqunit.jsとqunit.cssを読み込み、body以下の4行を記述すれば準備は完了(bodyの4行はid決め打ちで面倒だし、どうせ空なので、qunit.js側で動的に生成してくれてもいいような気がする、というか昔はそうだった気がするけどjQuery依存をなくした際になくしたのかしらん)。</p>
<p>あとは、test(&quot;テスト名&quot;, 実行される関数) を書いていけばいいだけ。そうそう、test関数はHTMLが全てロードされてから実行が始まるので、jQuery読み込んでjQuery.readyで囲む必要とかは特にありません。testProjection.jsは大体↓のような感じ。</p>
<pre><code class="language-javascript">/// &lt;reference path=&quot;testrunner.htm&quot;/&gt;

module(&quot;Projection&quot;);

test(&quot;Select&quot;, function ()
{
    actual = Enumerable.Range(1, 10).Select(&quot;i=&gt;i*10&quot;).ToArray();
    deepEqual(actual, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]);
    actual = Enumerable.Range(1, 10).Select(&quot;i,index=&gt;i*10+index&quot;).ToArray();
    deepEqual(actual,[10, 21, 32, 43, 54, 65, 76, 87, 98, 109]);
});
</code></pre>
<p>reference pathはVisualStudio用のパスなのであんま気にせずにー。詳細は<a href="http://neue.cc/2010/05/24_260.html">JavaScriptエディタとしてのVisual Studioの使い方入門</a>のほうで。読み込み元のHTMLを指定しておくとIntelliSenseが効いて、書くのが楽になります。</p>
<p>actual(実行結果)は私は別変数で受けてますが、当然、直書きでも構いません。アサーション関数は、基本は(actual, expected(期待する結果), message(省略可能)) の順番になっています。</p>
<pre><code class="language-javascript">equal(1, &quot;1&quot;); // okay - 参照比較(==)
notEqual
strictEqual(1, &quot;1&quot;); // failed - 厳密な比較(===)
notStrictEqual
deepEqual([1], [1]); // okay - 値比較
notDeepEqual
ok(1 == &quot;1&quot;); // okay - boolean
ok(1 !== &quot;1&quot;);  // okay - notの場合は!で
</code></pre>
<p>基本的に使う関数はこれらだけです。ドキュメントへの記載はないのですが、以前にあったequalsとsameはequalとdeepEqualに置き換わっています。後方互換性のためにequals/sameは残っていますが、notと対称が取れるという点で、equal/deepEqualを使ったほうが良いんじゃないかと思います。</p>
<p>非同期テストとかは、またそのうちに。</p>
<h2>まとめ</h2>
<p>linq.js ver.2出したときには、もう当分更新することなんてないよなあ、なんて思っていたのですが、普通にポコポコと見つかったり。でもさすがに、もうないと思いたい。C#との挙動互換性も、私の知る限りでは今回の配列最適化が最後で、やり残しはない。そして今回がラストだー、とばかりに思いつく要素を全部突っ込んでやりました。</p>
<p>そんなわけなので、使ってやってください。私がVisualStudio使いなのでVS関連の補助が多めですが、別にVS必須というわけじゃなくプラスアルファ的なもの(入力補完ドキュメントだのコードスニペットだの)でしかないので、エディタ書きでも何ら問題なく使える、かな、きっと。</p>
</div>
<h1><a href="https://neue.cc/2010/06/24_263.html">Reactive Extensions for .NET (Rx) メソッド探訪第7回:IEnumerable vs IObservable</a></h1>
<ul class="date"><li>2010-06-24</li></ul>
<div class="entry_body"><p>物凄く期間を開けてしまいましたが、<a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx" title="Reactive Extensions for .NET (Rx)">Reactive Extensions for .NET (Rx)</a>紹介を再開していきます。もはやRxってなんだっけ？という感じなので、今回は最も基本である、IObservableについて扱います。ボケーッとしている間にIQbservable(IQueryableのデュアル)とか出てきてて置いてかれちゃってるし。</p>
<p>そんなこんなで、IObservableはIEnumerableのデュアルなんだよ、とか言われてもぶっちゃけさっぱり分かりません。なので、その辺のことはスルーして普通にコードで対比させながら見ていくことにします。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
<param name="source" value="http://neue.cc/wp-content/uploads/silverlight/IEvsIO.xap"/>
<param name="background" value="white" />
<param name="minRuntimeVersion" value="4.0.50401.0" />
<param name="initparams" value="Start=1" />
<a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=4.0.50401.0" style="text-decoration:none">
 	<img src="http://go.microsoft.com/fwlink/?LinkId=161376" alt="Microsoft Silverlight の取得" style="border-style:none"/>
</a>
</object>
</p>
<pre><code class="language-csharp">// IEnumerable (RunはForEachです、ようするに)
Enumerable.Range(1, 10)
    .Where(i =&gt; i % 2 == 0)
    .Select(i =&gt; i * 2)
    .Run(Console.WriteLine, () =&gt; Console.WriteLine(&quot;completed!&quot;));

// IObservable
Observable.Range(1, 10)
    .Where(i =&gt; i % 2 == 0)
    .Select(i =&gt; i * 2)
    .Subscribe(Console.WriteLine, () =&gt; Console.WriteLine(&quot;completed!&quot;));
</code></pre>
<p>ボタンを押して確認する、までもなく同じ結果です。1から10までを偶数だけ通して二倍して出力。見た目は同じですが、中身は丸っきり違います。見た目が一緒すぎて言葉で表現出来ないので図に表してみました。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_pullandpush.jpg">
</p>
<p>何という下手っぴな図、さっぱり伝わらん。……。というのはおいておいて、矢印の向きに注目。IEnumerableの連鎖は、列挙を消費する時にIEnumeratorの伝搬に変わります。Run-&gt;Select-&gt;Where-&gt;RangeとMoveNextが駆け上がったら、今度はRange-&gt;Where-&gt;Select-&gt;RunとCurrentが降りていきます。末尾(Run)が値を要求(MoveNext)して値(Current)を取り出すという連鎖。末端から根元の値を引っ張ってくる(Pull)ようなイメージ。</p>
<p>IObservableは、根元自体が値を押し出していく(Push)ようなイメージ。こちらはIObserverの連鎖になっていて、根元からOnNextで値を伝えていきます。</p>
<h2>Pushのメリット</h2>
<p>Observable.Rangeのような、もしくはEunmerableに対してToObservableした時のような、普通のPull型シーケンスをPush型に変換することのメリットは？イベントや非同期など、他の形式から生成されたIObservableと連携出来る、というのは当然一番の話ですが、もう一つ、要素を分配出来るようになります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_pullandpush_2.jpg">
</p>
<p>このイミフな図の言わんとしていることが伝わる、わけはないので説明。Pull型はソースと1対1の関係である必要があるため、複数の列挙の消費者(RunだったりCountだったりSumだったりLastだったり)がいる場合、接続した回数だけ列挙が最初から回ることになります。かたやPush型は、1対多の関係を持つことが出来るため、一度の列挙で全ての消費者に値を配分することが可能です。</p>
<h2>Hot vs Cold</h2>
<p>同じように見えるIObservableにも、HotとColdという性質があります。それはyield returnで作る遅延評価のIEnumerableと、配列のように既に値が生成済みのIEnumerableとの違い、のようなものかもしれません。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
<param name="source" value="http://neue.cc/wp-content/uploads/silverlight/IEvsIO.xap"/>
<param name="background" value="white" />
<param name="minRuntimeVersion" value="4.0.50401.0" />
<param name="initparams" value="Start=2" />
<a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=4.0.50401.0" style="text-decoration:none">
 	<img src="http://go.microsoft.com/fwlink/?LinkId=161376" alt="Microsoft Silverlight の取得" style="border-style:none"/>
</a>
</object>
</p>
<pre><code class="language-csharp">var seq = Observable.Range(1, 5)
    .Do(i =&gt; Console.WriteLine(&quot;source -&gt; &quot; + i));

button1.Click += (sender, e) =&gt;
    seq.Subscribe(i =&gt; Console.WriteLine(&quot;button1 -&gt; &quot; + i));

button2.Click += (sender, e) =&gt;
    seq.Subscribe(i =&gt; Console.WriteLine(&quot;button2 -&gt; &quot; + i));
</code></pre>
<p>Doは、列挙に通ったものを取り出しつつも素通しします。つまり、 Select(i =&gt; { action(i); return i; }) です。今回は列挙がその箇所を通ったかどうかを書き出しています。余談ですが、IEnumerableならNyaRuRuさんの作成されたAchiralには<a href="http://d.hatena.ne.jp/NyaRuRu/20080131/p1">Hookというメソッド</a>があって、細かい列挙中のモニタリングが出来るようになっています。</p>
<p>実行結果を見てみると、ボタンを押す=Subsribeを繋げると、即座に列挙が開始されていて、これだとIEnumerableのforeachと何も変わません。よって、このIObservableはColdです。もう値は生成され終わっているので。Subscribeの度に即座に全ての値をPushします。</p>
<p>ではHotは？</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
<param name="source" value="http://neue.cc/wp-content/uploads/silverlight/IEvsIO.xap"/>
<param name="background" value="white" />
<param name="minRuntimeVersion" value="4.0.50401.0" />
<param name="initparams" value="Start=3" />
<a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=4.0.50401.0" style="text-decoration:none">
 	<img src="http://go.microsoft.com/fwlink/?LinkId=161376" alt="Microsoft Silverlight の取得" style="border-style:none"/>
</a>
</object>
</p>
<pre><code class="language-csharp">// FromEvent(canvas,&quot;MouseMove&quot;)は手軽ですが、丁寧にこう書くほうが理想的かしら
Func&lt;IObservable&lt;Point&gt;&gt; GetMouseMovePosition = () =&gt;
    Observable.FromEvent&lt;MouseEventHandler, MouseEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(sender, e),
            h =&gt; canvas.MouseMove += h,
            h =&gt; canvas.MouseMove -= h)
        .Select(e =&gt; e.EventArgs.GetPosition(canvas));

// ICollection&lt;IDisposable&gt;です。
var disposables = new CompositeDisposable();

evenButton.Click += (sender, e) =&gt;
{
    disposables.Add(
        GetMouseMovePosition()
            .Where(p =&gt; p.X % 2 == 0 &amp;&amp; p.Y % 2 == 0)
            .Subscribe(p =&gt; Console.WriteLine(&quot;Even -&gt; &quot; + p.X + &quot;:&quot; + p.Y)));
};

oddButton.Click += (sender, e) =&gt;
{
    disposables.Add(
        GetMouseMovePosition()
            .Where(p =&gt; p.X % 2 != 0 &amp;&amp; p.Y % 2 != 0)
            .Subscribe(p =&gt; Console.WriteLine(&quot;Odd -&gt; &quot; + p.X + &quot;:&quot; + p.Y)));
};

disposeButton.Click += (sender, e) =&gt;
{
    // Disposeでイベントのデタッチ + 再登録不可
    // Clearでイベントのデタッチ + 再登録可
    disposables.Clear();
};
</code></pre>
<p>例えばマウスイベント。クリックの度にOnNextに値を送る、ムーブの度に値を送るといったイベントをIObservable化するFromEventはHot。無限リスト状態になっているものは、接続しただけでは値が送られてこないとも言えるので、幾つでもSubscribeすることが出来ます。サンプルでは、ボタンをクリックすればしただけ、右側のログ表示に同内容のものが連続して表示されるのが確認出来ます。</p>
<p>両者が混ざったような挙動をするIObservableもあります(例えばReplaySubject)ので、HotなのかColdなのか両方なのか。というのを意識してみると理解が深まるかもしれません。また、メソッドの動作確認などの際にHotとColdを区別せずにいると、思わぬ挙動で混乱するかもしれないので注意。というか、私はよくやります……。Observable.Rangeばかりで確認していてイミフ！と思ったら、FromEventでチェックしたら何て分かりやすいこと！というのが何度も。</p>
<h2>CompositeDisposable</h2>
<p>本題と離れますがTips。イベントのデタッチが簡単なのもRxのメリットの一つです。さて、複数イベントをデタッチする場合はどうしましょうか？List&lt;IDisposable&gt;に格納してforeachで列挙してDispose、というのも悪くないですが、そういう用途で使うためのCompositeDisposableというICollection&lt;IDisposable&gt;なクラスが用意されているので、そちらを使ったほうがよりスマートに書けます。</p>
<p>上のSilverlightのHotのサンプルコードでは、ボタンを押す(=Subscribeする=イベントを登録する)度にCompositeDisposableにAdd。そしてDisposeAllボタンでまとめてデタッチしています。</p>
<pre><code class="language-csharp">var subject = new Subject&lt;int&gt;();
var d1 = subject.Subscribe(i =&gt; Console.WriteLine(i));
var d2 = subject.Subscribe(i =&gt; Console.WriteLine(i * i));
using (new CompositeDisposable(d1, d2))
{
    subject.OnNext(2); // 2, 4
    subject.OnNext(3); // 3, 9
}
subject.OnNext(2); // usingを抜けデタッチ済みなので何も起こらない
</code></pre>
<p>List&lt;IDisposable&gt;に対するCompositeDisposableのメリットは、Disposeで解除出来るということ。つまり、using構文に放りこむことが可能です。多段Usingよりも綺麗に見えるのでお薦め。</p>
<p>上の例にコソッと出したSubjectクラスはPush型シーケンスの大本で、OnNextやOnCompletedを後続に送ることが出来ます。イベントのラップじゃなく、Rxネイティブなクラスを作る場合に使います。Subjectはちゃんと詳しく書かなきゃいけない大事なクラスの一つなので、また次にでもきっちり紹介する予定は未定。</p>
<h2>列挙の分配</h2>
<p>Pushのメリットとして分配可能なことを挙げたのに、Coldなので分配出来ません。以上終了。で終わるわけは当然ないわけで、Cold to Hot変換メソッドが使えます。Publishです。Publishの戻り値はIConnectableObservable。</p>
<pre><code class="language-csharp">public interface IConnectableObservable&lt;out T&gt; : IObservable&lt;T&gt;
{
    IDisposable Connect();
}
</code></pre>
<p>IObservableなのでメソッドチェインを繋げることが出来ます。そして、Subscribeしても列挙は始まりません。Connectを呼んだ時に、一度だけ列挙することが出来ます(二度以降Connectを呼んでも何もしない)</p>
<p>私はダムの堰止をイメージしています。何もしないとドバドバと水が流れてしまうのでPublishで一時的に止めて、Connectで放水。放水後は空っぽ。みたいな。</p>
<h2>Max/Sumなど集計系</h2>
<p>インターフェイスを挙げただけじゃよく分からないので実例を。SumやMaxといった集計系メソッドと合わせて使ってみます。そこら中にモニタリング用のDoが入っていてコードが若干分かりづらいですが、実行結果で、どのタイミングで値が通過するのかを確認してみてください。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
<param name="source" value="http://neue.cc/wp-content/uploads/silverlight/IEvsIO.xap"/>
<param name="background" value="white" />
<param name="minRuntimeVersion" value="4.0.50401.0" />
<param name="initparams" value="Start=4" />
<a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=4.0.50401.0" style="text-decoration:none">
 	<img src="http://go.microsoft.com/fwlink/?LinkId=161376" alt="Microsoft Silverlight の取得" style="border-style:none"/>
</a>
</object>
</p>
<pre><code class="language-csharp">var source = Enumerable.Range(1, 5)
    .Do(i =&gt; Console.WriteLine(&quot;Source -&gt; &quot; + i));

enumerableButton.Click += (sender, e) =&gt;
{
    var sum = source.Sum();
    var max = source.Max();
    var all = source.All(i =&gt; i &lt; 3);
    Console.WriteLine(&quot;sum = &quot; + sum);
    Console.WriteLine(&quot;max = &quot; + max);
    Console.WriteLine(&quot;all = &quot; + all);
};

observableButton.Click += (sender, e) =&gt;
{
    var connectable = source.ToObservable().Publish();

    connectable.Subscribe(_ =&gt; { }, () =&gt; Console.WriteLine(&quot;OnCompleted&quot;));

    var sum = default(int);
    connectable
        .Do(i =&gt; Console.WriteLine(&quot;BeforeSum -&gt; &quot; + i))
        .Sum()
        .Do(i =&gt; Console.WriteLine(&quot;AfterSum -&gt; &quot; + i))
        .Subscribe(i =&gt; sum = i);

    var max = default(int);
    connectable
        .Do(i =&gt; Console.WriteLine(&quot;BeforeMax -&gt; &quot; + i))
        .Max()
        .Do(i =&gt; Console.WriteLine(&quot;AfterMax -&gt; &quot; + i))
        .Subscribe(i =&gt; max = i);

    var all = default(bool);
    connectable
        .Do(i =&gt; Console.WriteLine(&quot;BeforeAll -&gt; &quot; + i))
        .All(i =&gt; i &lt; 3)
        .Do(b =&gt; Console.WriteLine(&quot;AfterAll -&gt; &quot; + b))
        .Subscribe(b =&gt; all = b);

    connectable.Connect();
    Console.WriteLine(&quot;sum = &quot; + sum);
    Console.WriteLine(&quot;max = &quot; + max);
    Console.WriteLine(&quot;all = &quot; + all);
};
</code></pre>
<p>値が確定した時、Allならば全ての列挙が完了した(OnCompletedを受信する)か、条件がfalseのものが見つかったときに、1つだけSubscribeに値が届きます。SumやMaxは、全ての列挙が完了しないと算出出来ないので、全て完了したとき。こういった結果の確定するタイミングは、Enumerableでの場合と変わりません。</p>
<p>このような動作(戻り値が長さ1のIObservable)をするものには、 Aggreagte, Count, Any... 、ようするにIEnumerableにもあって戻り値がIEnumerableじゃないメソッドは全てそうです。全部似たりよったりなので具体的な紹介は省きます。</p>
<h2>Pushのデメリット</h2>
<p>IObservable便利すぎてIEnumerableいらなくネ？ と、言いたいところですが、例えばこれら集計系メソッドは全て長さ1のIObservableになります。Sumの場合、欲しいのはintであってIObservableではありません。長さ1のIObservableは、いつConnectされるか分からないのでSubscribeで外の値に受け渡してやらなければならないわけですが、見た目が美しくなく宣言も冗長になる。</p>
<p>また、集計するのに複数回列挙は確かに格好悪いな！よし、そういう場合はRx使おう。と思った場合はとりあえず待った。ただの配列からの列挙程度の場合は、ふつーに複数回列挙したほうがPublishで分岐させるよりも遥かに速かったりします。元ソースが複雑にLinqで繋いであって重たかったり、ファイルやネットワーク経由だったりで複数呼び出しを避けたい、副作用があって複数回呼びだすと内容が変化している、という場合はRxです。が、一旦ToListしてキャッシュすれば済むシーンならば、キャッシュした方が分かりやすく速い場合が多かったりします。</p>
<p>Publishの具体的な使い処としては、以前に、<a href="http://neue.cc/2010/04/29_255.html" title="neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions">TwitterのStreamAPIをRxを使って分配する</a>という記事で紹介しました。</p>
<h2>まとめ</h2>
<p>PullとPushは、むしろ動作的にはPushのほうが素直で分かりやすい雰囲気。難解だと思って避けていたそこのアナタ、さあ、Rxを使おう！ しかしColdとHotは大いなる罠。初見ではきっとつまづく。この区別は本当に大事。Rxが難解っぽいとしたら、Cold/Hotのせい。挙動がまるっと変わるんだもの。でも、ゆっくり紐解けば全然大丈夫。さあ、Rxを使おう！Publishや集計系はそんなには使わないかもですが、覚えておくと便利な時も割とある。さあ、Rxを(ry</p>
<p>個人的にRxの特色・使いどころは「イベントの合成」「タイマー・ネットワーク・スレッドなど非同期処理の一元化」「シーケンスの分配」の3つだと思っているのですが、このブログでは、延々とシーケンス分配という、3つの中で一番どうでもいい機能しか紹介していない！という酷い事実に気がつきました。そんなんじゃRxのポテンシャルを全然伝えられない。</p>
<p>というわけで、次回はタイマー辺りを紹介したいと思います予定は未定。というか計画ではObservableの合流周りとMarble Diagramについてを書く予定。Rxの知名度も徐々に上がってきているようなので、しっかり紹介していきたいですし、他の人も書いて欲すぃ。</p>
</div>
<h1><a href="https://neue.cc/2010/06/08_262.html">Linq雑話</a></h1>
<ul class="date"><li>2010-06-08</li></ul>
<div class="entry_body"><p>ここ数日Twitterで見た/出したLinqネタまとめ。私の広くない観測範囲(<a href="http://twitter.com/neuecc" title="neuecc (neuecc) on Twitter">@neuecc</a>)での話ですが。</p>
<h2>SelectManyとクエリ構文でUsing</h2>
<p>ネタ元、コード元は<a href="http://marcgravell.blogspot.com/2009/11/selectmany-combining-idisposable-and.html">Code, code and more code.: SelectMany; combining IDisposable and LINQ</a>から。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    var firstLines =
        from path in new[] { &quot;foo.txt&quot;, &quot;bar.txt&quot; }
        from stream in File.OpenRead(path)
        from reader in new StreamReader(stream)
        select path + &quot;\t&quot; + reader.ReadLine();
}

public static IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TDisposable, TResult&gt;(
    this IEnumerable&lt;TSource&gt; source,
    Func&lt;TSource, TDisposable&gt; disposableSelector,
    Func&lt;TSource, TDisposable, TResult&gt; resultSelector) where TDisposable : IDisposable
{
    foreach (var item in source)
    {
        using (var disposableItem = disposableSelector(item))
            yield return resultSelector(item, disposableItem);
    }
}
</code></pre>
<p>自前定義の拡張メソッドはメソッド構文だけのものと思っていませんでしたか？私はそう思っていました。でも、クエリ構文でも同名のものがあれば拡張メソッドが使用されるんです、というお話。それを利用してusingのネストをクエリ構文で華麗に表現してやったぜー、というサンプルで、確かにこれはクール！素晴らしすぎる。</p>
<p>でも、クエリ構文使いたいかというと、そんなことはなく変わらずメソッド構文派です、私は。クエリ構文自体は悪いとは思わないし、良さがあるのも分かるんですが、他の拡張メソッドに繋げる時に前後にカッコで括ると途端に書き/読みにくくなることと、拡張性の乏しさが如何ともし難い。クエリ構文とメソッド構文のちゃんぽんになるぐらいなら、メソッド構文だけで書いたほうが美しいよね、と思ってしまう。あと、クエリ構文の存在が「LINQ = SQLみたいなの」という図式を産んでしまっているくさいのも、憎んでしまいますね……。</p>
<h2>ラムダ式の引数の名前とシャッフルについて</h2>
<p>お馴染み感溢れるOrderByでのシャッフル。</p>
<pre><code class="language-csharp">var rand = new Random();
var shuffle = Enumerable.Range(1, 10).OrderBy(_ =&gt; rand.Next());
</code></pre>
<p>それはそれとして、ラムダ式の引数の名前どうする？というお話が。私は、引数を使わない場合は _ を、使う場合は型の1～2文字(i(Int32)とかs(String)とかa(AnonymousType)とか、考えるの面倒なときはx、配列系はarかxs)という自分ルールを敷いています。以前に<a href="http://neue.cc/2009/10/05_207.html">ラムダ式の引数の名前</a>という記事を書いたのですが、その時から変わっていません。ですが、最近ネットで見かけるコードでは全部_でまかなう例もよく見るね、と。Scalaでは匿名関数の引数として_が使える(プレースホルダ構文って言うんですね、名前知らなかった)ようなので、_をダメとは言い辛いのですけど、私はちょち苦手(linq.jsで$をゴリゴリ使ってるくせに、って話ではあるけど) 。</p>
<p>C#にもプレースホルダ構文みたいなの欲しいね、というのは、若干ある。プロパティの「value」とか最初からそこにある良く分からない変数、みたいなのはあるし。ただ、IntelliSenseとの兼ね合いもあるし、そういうのが入れられるか、入って本当に幸せになれるのかどうかの判断は保留。短絡的に欲しい！って言うのは簡単だけど、それの及ぼす影響となると分からないものだ。</p>
<p>それともう一つ。OrderByの引数は比較関数ではなくキーセレクターにすぎないのでちゃんとシャッフルされる、とか言ったりなどした私ですが、そうじゃなくて<a href="http://blog.livedoor.jp/dankogai/archives/50615442.html">シャッフルの精度はランダムの範囲に影響される</a>ね(実際上は問題ないとしても)、という話が。完全に頭から抜け落ちていて、かつ、全くもってその通りで恥ずかしかったりしたのですが確認できてよかったです、感謝。</p>
<h2>OrderByのComparison</h2>
<p>全然使わないけどOrderByの第二引数。</p>
<pre><code class="language-csharp">class MyClass
{
    public int Hoge { get; set; }
    public int Fuga { get; set; }
}
static void Main(string[] args)
{
    var array = new[] { new MyClass(), new MyClass() };
    // コンパイルは通るけど例外出る
    var ordered = array.OrderBy(x =&gt; x).ToArray();
    // 上のはこれに等しい(当然、例外出る)
    array.OrderBy(x =&gt; x, Comparer&lt;MyClass&gt;.Default);
    // AnonymousComparerを使えばComparisonを使った比較が出来る
    array.OrderBy(x =&gt; x, (x, y) =&gt; x.Fuga - y.Hoge);
}
</code></pre>
<p>OrderByついでですが、キーセレクターは制約かかってないので別にIComparableじゃなくても動いたりします。そういう時はComparer&lt;T&gt;.Defaultが指定されることになって、例外出て死ぬだけです。意味ナイネ。</p>
<p>DescendingとThenByがあるので滅多に使わないであろう第二引数はIComparer。一々クラス作ってnewですってよ、C#らしくないですね。Comparisonじゃないなんて！大変ウザい。そんな人のための<a href="http://linqcomparer.codeplex.com/">AnonymousComparer</a>。ラムダ式でIEqualityComparer/IComparerを作ることが出来ます。また、Linq標準演算子への拡張メソッドとしてOrderBy/ThenByのオーバーロードとしてComparisonが使えるようになります。便利ですね！是非使ってください、という宣伝。</p>
<h2>Empty -&gt; Sum</h2>
<p>Empty.Sum()は0。言われてみれば当たり前といえば当たり前なのですが……。</p>
<pre><code class="language-csharp">// SumはAggregateで表現出来る
var sum = Enumerable.Range(1, 10).Aggregate((x, y) =&gt; x + y); // 55
// でもEmptyで例外出るから表現出来ない(ｷﾘｯ
sum = Enumerable.Empty&lt;int&gt;().Sum(); // 0
sum = Enumerable.Empty&lt;int&gt;().Aggregate((x, y) =&gt; x + y); // 例外
// 実はseed与えればおk
sum = Enumerable.Empty&lt;int&gt;().Aggregate(0, (x, y) =&gt; x + y); // 0
</code></pre>
<p>SumやMax, Minなどは全てAggregateで表現出来ます。でも、Sumは空シーケンスの時はゼロ出すけど(MaxやAverageは例外)Aggregateを使うと例外が出てしまうので表現出来ない、とか言ったのですが0を最初に与えとけばいいよね、という話が。ぬお、そうでした！</p>
<p>発端は<a href="http://linqjs.codeplex.com/">linq.js</a>でこの問題(というかC#と互換が取れてないこと)に気づいたことで、linq.jsではAggregateでやってるため、AggregateはScan.LastだからScan.LastOrDefault(0)にするー、なんて考えてたんですが、初項0で済むというシンプルさを完全に失念。標準演算子外のメソッドを大量に用意してあるので、そっち側で解決しちゃおうとしてしまう姿勢は、ちょっと頭硬直化しちゃってる、全くもってよろしくない。</p>
<p>シャッフルの話といい、Aggregateの話といい、最近はLinqに慣れすぎて逆に見方が定型的になりすぎていると実感したので、少し気を引き締めないと。あ、で、そんなこんなでlinq.jsの空シーケンスでのSumの問題は次のリリースで直します。他にもバグがあったり(MemoizeAllが少しマズい)、加えたいことが数点あったりするので、もう少し先になりますが。</p>
<h2>世の中の主流はまだVS2005ですか？</h2>
<blockquote>
<p>開発言語としてのJavaとC＃を10の視点から比較<br />
共通点が多いが、今後は違いが大きくなるかも<br />
しかし近年のC#はLINQ（Language Integrated Query：言語統合クエリ）プロジェクトが重視されています。これはクエリ、集合操作、変換、および型推測などのデータ指向機能の多くを直接的にC#言語に統合しようとするものです。今後は違いがさらに大きくなっていくかもしれません。<br />
<a href="http://www.atmarkit.co.jp/fjava/rensai4/java_dotnet01/03.html">プログラマが知っておきたいJavaと.NETの違い (3/4) - ＠IT</a></p>
</blockquote>
<p>Linqは、VS2008出たのは3年前だよね(プレビュー版から言えばどれだけ前なのかしら)。今後は違いが大きくなるかも、じゃなくて既に違いは大きすぎるような。そして10の比較というけれど、最大の違いはデリゲートの有無では？特に、匿名メソッド/ラムダ式の有無。<a href="http://www.asahi-net.or.jp/%7Edp8h-izn/delegate.html">A.R.N [ Top &gt; 書庫 &gt; Microsoftの「Delegate」について ]</a>にある、Javaには無名クラスがあるからdelegateは不要、とは10年以上前のSunの言で、さすがに10年以上も前のを持ち出してどうこう言ってもしょうがないのですが(比較対象に匿名メソッドないし)、価値観は移り変わっていくものなのだと思わずにはいられない。匿名クラスで代用出来るって、いやまあ出来なくもないのは分かりますがUglyすぎ。今、クロージャなんて不要、とか言ったらフルボッコなはず。</p>
<p>言語面で見ると、Java5から進化の足を止めている(そしてJava7延期しすぎ)ように見えるJavaと、ひたすら貪欲に(無節操に)取り込み続けるC#。スタート時には似たようなものだったとして、今はもうコードの見た目からして全然似てるようには見えない。Java畑の人は、今でもC#はJavaに似たようなもの、という認識なのかしら。
確かに、古典的に書けば似てますが……。そして、他の言語を考えれば、やっぱ似てるといえば似てるのですが。しかし……。ふむ。そろそろModern C# Designが出版されるべき。 <a href="http://community.bartdesmet.net/blogs/bart/Default.aspx">Bart De Smet</a>が書く<a href="http://www.amazon.co.jp/gp/product/0672330792?ie=UTF8&tag=ilsgeometrati-22&linkCode=as2&camp=247&creative=7399&creativeASIN=0672330792">C# 4.0 Unleashed</a><img src="http://www.assoc-amazon.jp/e/ir?t=ilsgeometrati-22&l=as2&o=9&a=0672330792" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
には超期待。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
