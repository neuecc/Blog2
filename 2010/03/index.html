<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2010-03</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2010/03/26_248.html">RxJS用IntelliSense生成プログラム(と、VisualStudioのJavaScript用vsdocの書き方)</a></h1>
<ul class="date"><li>2010-03-26</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_intellisense.jpg">
</p>
<p>先日、<a href="http://neue.cc/2010/03/18_247.html" title="neue cc - Reactive Extensions for JavaScript">Reactive Extensions for JavaScript(RxJS)の記事を書いた</a>わけですが、触っていて困るのは、どのメソッドが使えるの？ということ。リファレンスもない中で、C#版の記憶を頼りに手打ちでメソッド名を探るなんて、無理。ましてやそんな状況じゃあ人に薦められないよ！というわけで、必要なのはIntelliSense(入力補完)です。rx.jsはある。rx-vsdoc.jsはない。ないものは、作ればいいぢゃない。そこで諦めてメソッド全部暗記してやるぜ、とか思うのはどうかしてる。諦めたら試合終了ですよ。楽するために手間を掛けるのです＜プログラマの三大美徳。というわけで、作りました。</p>
<ul>
<li><a href="http://apps.neue.cc/RxVSDocGenerator/RxVSDocGenerator.zip">RxVSDocGenerator.zip</a> (source and binary)</li>
</ul>
<p>vsdocファイルをそのまま配布するのはライセンスの問題が出そうなので、生成プログラムを配布します。手作業じゃなく自動生成で作ったので(面倒くさくて手作業なんてやってられるか！)。Rxをインストールしたフォルダ(デフォルトだとProgramFiles\Microsoft Reactive Extensions)のScriptSharpフォルダの下のRxJS.dllとRxJS.xmlを、生成プログラムと同じ階層に置いて実行すると、rx-vsdoc.jsが生成されます。</p>
<p>利用するには<a href="http://code.msdn.microsoft.com/KB958502/Release/ProjectReleases.aspx?ReleaseId=1736">vsdoc対応パッチ</a>をあてたVisualStudio 2008 SP1(VS2010はパッチをあてなくても対応しています)を用意して、rx.jsと同じ階層に置くだけです。HTMLで使う場合はscript src=&quot;rx.js&quot;で読み込むだけ、独立したjsファイルで補完を使う場合は、行頭に/// &lt;reference path=&quot;rx.js&quot; /&gt;と記述すれば補完が読み込まれます。この辺は、以前に<a href="http://neue.cc/2009/06/06_164.html">最もタメになる「初心者用言語」はVisualStudio(言語?)</a>という記事を書いたときに補完愛してる愛してる愛してると連呼しながら解説してました。jQueryのドットで補完効かせながらのメソッドチェーンは気持ちイイんだって！</p>
<p>折角作ったので海外の人にも利用してもらおうと、また、標準でvsdocも同梱して欲しいと訴えるためにもと<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/5168db3f-b29a-4fa5-b1d5-46bfb3a48e77">Rxの公式フォーラムでスレ立てた</a>けど、奇怪英語(機械翻訳英語)が恥ずかしいです……。ニュアンスをミジンコほどにも伝えられた気がしません。英語読めない書けないプログラマなんて小学生までだよねー、とかいう自己啓発系ブログ記事は山のようにあるわけですが、ふん、どうせ英語読めませんよ書けませんよ、ぐぐる先生による機械翻訳さえ超進化してくれれば小学生でも生きていけるもん！(ちなみに私はヤフー翻訳派です)</p>
<p>MIX10の発表によるとMicrosoftはAjax関連はjQueryに一本化する、ということで、C#erもますますJavaScriptを書かなければならないシーンは増えていきそうなので、せっかくなのでJavaScript用のvsdocの書き方を解説します。ついでに、LinqまみれなRxVSDocGeneratorのコードの解説も若干します。Mono.Cecil.dll使ってたりするんですよー(モジュールの参照用にしか使っていないので些かオーバースペック)。</p>
<h2>C#と比較するJavaScriptの構造</h2>
<p>JavaScriptは割とヒネクレた書き方が幾らでも出来るわけですが、VisualStudioの入力補完は、素の状態だと素直に書かないとついてきてくれません。というわけで素直に書きましょう。素直に書けば素直なIntelliSenseが手に入ります。以下、10秒でわかるC#とJavaScriptとの構造比較。</p>
<pre><code class="language-javascript">// 名前空間、もしくは静的クラス
Rx = {}
Rx.Disposable = {}
// クラス(コンストラクタ)
Rx.Observable = function(){ }
// 継承
Rx.AsyncSubject.prototype = new Rx.Observable;
// 静的フィールド
Rx.Disposable.Empty = null;
// インスタンスフィールド
Rx.GroupedObservable.prototype.Key = null;
// 静的メソッド
Rx.Observable.Range = function(start, count, scheduler){ }
// インスタンスメソッド
Rx.Observable.prototype.Select = function(selector){ }
</code></pre>
<p>ヒネクレたことさえしなければ、JavaScriptはシンプルです。オブジェクトとファンクションしか存在しない。シンプルさ故の制限を回避するために、また、幾らでも回避可能なためバッドノウハウのようなヒネクレた手段が大量に溢れていて、シンプルさとは無縁の奇怪な代物と成り果てていますが(JSはシンプルだよ、初心者にお薦め！というそばからクロージャがどうのapplyがどうのと言うのはどうなのよ、勿論、その柔軟さもまたJSの魅力の一つだとは思いますが、それをシンプルとは言わない)、素直に見れば、シンプルです。</p>
<p>そしてまあ、C#と割と似てます。構文似てるし。単一継承だし。prototypeに後からメソッドを足せるのは拡張メソッドのよう。違いは、privateはないしプロパティはないしインターフェイスはないしオーバーロードもない(但し引数は省略可能)、いつでも簡単に全てが変更可能(不注意に扱えばすぐ構造をぶっ壊せる←だからライブラリの衝突の問題がある)。といった問題は、若干ヒネクレればある程度は回避可能です、privateとか。でも、素直に書いた方が良いと思います。JavaScriptにprivateはない。と、割り切ってしまうと非常に楽になれます。良いか悪いかはともかく。</p>
<p>ただ、素直に書こうと、素のJavaScriptでは、補完は簡単に限界がきます。例えば以下のコード。</p>
<pre><code class="language-javascript">var func = function(bool) {
    return (bool) ? &quot;string&quot; : [4, 5, 2, 3, 1];
}

var b = Math.random() &lt; 0.5; // true or false
func(b).toUpperCase();
func(b).sort(); // どちらかで必ずエラー
</code></pre>
<p>引数の型が自由なら、戻り値の型もまた自由。じゃあどうするの？というと、どうにもなりません。戻り値の型はなるべく統一しましょう、IntelliSenseに優しくするために。これもまた素直の一つでしょうか、さてはて。</p>
<h2>vsdoc.js入門</h2>
<p>素直に素直に、と言ったところで何処かで破綻する。だいたい、JavaScriptの言語としての柔軟さを生かさないでどうする！という話は尤もなこと。そこで、VisualStudioはJavaScriptの入力補完に気の利いた仕組みを用意しています。ファイル名-vsdoc.jsが同階層にある場合、vsdoc.jsの構造を利用して入力補完を行います。なので、オリジナルに手を加える事なく補完を利用することが出来ますし、また、オリジナルが補完生成し辛い構造をしていても問題はありません。最終的にユーザーが利用するPublicの構造というのは、上で書いた素直なJavaScriptで再現出来るわけなので、それで構築すればいいだけです。勿論、別箇に構造を作成するというのは手間が増えるので、可能な限りは素直な構造にしておいたほうが無難です。</p>
<p>「IntelliSenseに候補が出ないものは存在しないに等しい」。これは<a href="http://www.amazon.co.jp/gp/product/4891006765?ie=UTF8&amp;tag=ilsgeometrati-22&amp;linkCode=as2&amp;camp=247&amp;creative=7399&amp;creativeASIN=4891006765">.NETのクラスライブラリ設計</a>という本に書かれている言葉なのですが(神本なので未読の人は絶対購入しましょう)、候補を出しさえしなければ、利用者にとって存在しないようなものに見えます。実際はpublicであっても、補完候補から削ってしまえばprivateに見える。擬似的なprivateの表現としては、中々スマートではないですか？</p>
<p>そんなvsdocですが、ちゃんとしたドキュメントが今ひとつ見あたらないので、<a href="http://docs.jquery.com/Downloading_jQuery">jQuery用のvsdoc</a>を参考にすると良いでしょう。色々な属性が用意されているようですが、実際の入力補完に利用されるものは少ししかありません。optional属性なんて、オーバーロード的なものの表現に使えるのでは？と期待をかけたのですがそんなことはなくて、IntelliSense用には動作しませんでした。よって、summary, param, returnsだけ抑えておけば良いです。</p>
<pre><code class="language-javascript">var sum = function(x, y) {
    /// &lt;summary&gt;足し算&lt;/summary&gt;
    /// &lt;param type='Number' name='x'&gt;引数1&lt;/param&gt;
    /// &lt;param type='Number' name='y'&gt;引数2&lt;/param&gt;
    /// &lt;returns type='Number'&gt;&lt;/returns&gt;
}

Rx.Disposable.Empty = new IDisposable;
</code></pre>
<p>C#と違ってfunctionの「下」にドキュメントコメントを書きます。また、ドキュメントコメントを使う場合は、関数本体はあってもなくても無視されるので、不要です。なお、ドキュメントコメントは-vsdoc.jsだけで有効なわけではなく、普通のjsファイルでも有効です。summary, paramは面倒くさかったら書かなくてもそんなに害はなさそうですが(但し引数違いのオーバーロードがある場合はsummaryで伝えてあげると使う人に優しい)、returns typeだけは欠かさず書いておきたい。これを書いておくと戻り値の型がVisualStudioに認識されるので、IntelliSenseを途絶さず利用できます。</p>
<p>制限事項としては関数のみにドキュメントコメントを埋め込むことが出来ます。vsdocを作る際にフィールドの型も認識させたい場合は、ダミーの変数を与えてあげればOK。</p>
<h2>ジェネレータの解説</h2>
<p>と、いった基本を抑えておけば、どんなライブラリに対してもvsdocを作れるね！じゃあ、rx-vsdoc.jsも手作業で作ろうか。と、思った時もありました。構造自体はjs自体をダンプでなんとかなる(と、いいなあ)だろうし、summaryやparamは諦めるとしてreturns typeだけを手作業で書くなら、どうせほとんどRx.Observableなので手間もそんなでもない。けど、rx.jsは難読化されていて引数の名前がイミフ、例えばRx.Observable.Range(k0, l0, m0)というんじゃ苦しい……。やっぱsummaryもparamも必要。でもどうすれば……？</p>
<p>そこで、インストールディレクトリを見てみるとScriptSharpなんてフォルダがあるんですよ。そう、RxJSは<a href="http://projects.nikhilk.net/ScriptSharp">Script#</a>でC#コードから生成されたJavaScriptライブラリだったのだよ、ナンダッテー！そして、ScriptSharp用のRxJS.dllには当然、完全なクラス構造と、引数の名前と型が保存されているし、更にはsummary用のxmlも用意されていた。つまり、ここからrx-vsdoc.jsを生成すればいいわけです。</p>
<p>というわけでリフレクション。型情報を取るため、早速Assembly.LoadFrom(&quot;RxJS.dll&quot;).GetTypes()とすると、落ちる。はあ、ScriptSharpのdllに依存してるのでそっちもないとダメなのね。というわけでScriptSharpのdllを幾つか参照に加えると、なんかうまく動かせない。ScriptSharpのdllはmscorlibの代替となってる(JSに変換可能なもののみに制限を加えてる？)から、一緒には動かせないとかそんな感じなのかなー、よくわからないけどとにかく動かせない、諦める。南無。無念。</p>
<p>そもそもLoadするからダメなわけで、Loadしなくていいよ、型情報だけ取れればそれでいいんだって。でも標準ライブラリには、それを可能にするのはないっぽい。けど、Monoにはあった。<a href="http://www.mono-project.com/Cecil">Cecil - Mono</a>。参照も書き換えも出来るようですが、今回は参照のみで。色々出来そうなので、いつかもう少し触ってみたいですね。私は今回はじめてMono.Cecil.dllを使ったのですが、リファレンスの類も見てない(あるのか知らない)し、チュートリアルの類も見てない(ていうか日本語の情報がない)。でも、IntelliSenseでドット打ってれば何とかなりました。しっかりした構造とちゃんとしたメソッド名とIntelliSenseがあれば、リファレンスがなくても問題なく使えるわけです。すばらしきこのせかい！</p>
<h2>Mono.Cecil</h2>
<p>型情報を取ってくるだけなら簡単で、というかSystem.Reflectionと大して変わりません。</p>
<pre><code class="language-csharp">var rxjsTypes = AssemblyFactory.GetAssembly(&quot;RxJS.dll&quot;)
    .MainModule.Types.Cast&lt;TypeDefinition&gt;()
</code></pre>
<p>TypeDefinition, MethodDefinition, ParameterDefinitionといったのが個の要素。そして、対応するコレクションHogeCollectionが用意されています。HogeCollectionは残念ながらジェネリックではないため、Linqに流すためにはCastが必要になります。今回はParameterDefinitionCollectionのSelectを多用することが多かったので、Cast無しで使えるよう拡張メソッドを定義しちゃいました。</p>
<pre><code class="language-csharp">static IEnumerable&lt;T&gt; Select&lt;T&gt;(this ParameterDefinitionCollection source, Func&lt;ParameterDefinition, T&gt; selector)
{
    return source.Cast&lt;ParameterDefinition&gt;().Select(selector);
}
</code></pre>
<p>この手のレガシーなコレクションに対するアドホックな対応は、例えば正規表現のMatchCollectionなんかにも使えそうです(と、いった発想の元ネタは<a href="http://d.hatena.ne.jp/NyaRuRu/20080115/p1">Achiral</a>から)</p>
<h2>テンプレート置換</h2>
<p>必要なJSの構造は上のほうで書いた通り決まったパターンがあるので、雛形を元に置換するのが楽。テンプレートエンジン、なんていう大仰なものは必要ないけれど、string.Formatでも{5}とか出てくると引数の管理が面倒だし、順番の変更にも弱い。なので簡易置換用の拡張メソッドを用意してみました。</p>
<pre><code class="language-csharp">static string TemplateReplace(this string template, object replacement)
{
    var dict = replacement.GetType().GetProperties()
        .ToDictionary(pi =&gt; pi.Name, pi =&gt; pi.GetValue(replacement, null).ToString());

    return Regex.Replace(template,
        &quot;{(&quot; + string.Join(&quot;|&quot;, dict.Select(kvp =&gt; Regex.Escape(kvp.Key)).ToArray()) + &quot;)}&quot;,
        m =&gt; dict[m.Groups[1].Value]);
}
</code></pre>
<p>オブジェクトを渡すと、{プロパティ名}の部分をプロパティの値に置換します。オブジェクトなのでクラスインスタンスでもいいのですが、匿名型も使えます。例えば</p>
<pre><code class="language-csharp">const string classTemplate = @&quot;
{FullName} = function({Parameters})
{
    /// &lt;summary&gt;{Summary}&lt;/summary&gt;
{Param}
}&quot;;

var r = classTemplate.TemplateReplace(new
{
    FullName = &quot;Rx.Notification&quot;,
    Parameters = &quot;kind&quot;,
    Summary = &quot;Represents a notification to an observer.&quot;,
    Param = &quot;    /// &lt;param type='String' name='kind'&gt;&lt;/param&gt;&quot;
});

Console.WriteLine(r);
</code></pre>
<p>割と便利。たった9行なので、ちょっと気の利いた置換が欲しいなあ、って時にササッとコピペして取り出せるのが魅力です。最近、コピペに優しいプログラミングをよく考えてる。というのはともかくとして、実際どんな風に使っているかというと、</p>
<pre><code class="language-csharp">var classes = rxjsTypes
    .Where(t =&gt; t.Constructors.Count &gt; 0)
    .Select(t =&gt; new
    {
        t.FullName,
        Parameters = t.Constructors.Cast&lt;MethodDefinition&gt;()
            .Select(m =&gt; m.Parameters)
            .MaxBy(p =&gt; p.Count)
            .Select(p =&gt; p.Name)
            .ToJoinedString(&quot;, &quot;),
        Summary = summaries[t.FullName] + &quot; &quot; + t.Constructors.Cast&lt;MethodDefinition&gt;()
            .OrderBy(m =&gt; m.Parameters.Count)
            .Select(m =&gt; m.Parameters.Select(p =&gt; p.Name).ToJoinedString(&quot;, &quot;))
            .Select((s, i) =&gt; string.Format(&quot;{0}:({1})&quot;, i + 1, s))
            .ToJoinedString(&quot;, &quot;),
        Param = t.Constructors.Cast&lt;MethodDefinition&gt;()
            .MaxBy(m =&gt; m.Parameters.Count)
            .Parameters
            .Select(p =&gt; string.Format(Template.Param, p.ParameterType.ToJSName(), p.Name))
            .ToJoinedString(Environment.NewLine),
    })
    .Select(a =&gt; Template.Class.TemplateReplace(a));
</code></pre>
<p>前段階で匿名型を生成して、最後のSelectで置換をかけてます。Select二段にしないでもいんじゃね？というとYESですが、このほうが見やすいと思うので。それにしてもリフレクションなわけで、Linqと非常に相性が良い。というか、Linqなしだと大量のforループとifで涙を流すことになりそう。なので、昔はリフレクションって結構敷居が高かったのですが、今はもうLinqでサクサクとWhereで切って捨ててSelectで繋げて繋げて、って出来るので書く分には楽チンです。これがLinq以前のC#2.0だったら、考えたくないなあ。</p>
<h2>出力</h2>
<p>クラス、継承、オブジェクト、メソッド、プロパティは全部バラバラに抽出しています。そして、全部IEnumerable&lt;string&gt;で止めています。最後にそれらをまとめて、テキストとして出力。</p>
<pre><code class="language-csharp">var vsdoc = Enumerable.Repeat(string.Format(Template.Object, RootNamespace), 1)
    .Concat(classes)
    .Concat(inheritance)
    .Concat(objects)
    .Concat(methods)
    .Concat(properties)
    .ToJoinedString(Environment.NewLine);

File.WriteAllText(&quot;rx-vsdoc.js&quot;, vsdoc, Encoding.UTF8);
</code></pre>
<p>せっかくクエリ遅延評価にさせているので、書き出しも一度stringに貯めないでストリームで書きだせば高効率ですねー。でも、一度文字列に出した方が書くの楽なので。せいぜい1000行程度なので、ケチッても意味ないですな。</p>
<p>全部rxjsTypesをルートにして生成しているので、クエリ構文を使って巨大な一塊にしてみたら面白かったかな、なんて思いますが若干悪趣味な気もするのでやめておきます。そもそも、このドットだらけ、Selectだらけの時点で若干どうよ、といった趣が漂っているのは間違いない。いやいや、ドット素敵です。Linq素敵なんだって、本当に。こういうの書いてるとC#2.0と3.0は別物だろ常識的に考えて、と思わなくもない。セミコロン率は物凄く低くなりましたね……。あと、LinqとSQLを関連付けるのはそろそろやめようぜー、的な思いがふと過ぎったり。Twitterのpublic検索でlinqをキーワードに毎日眺めてるんですが、今でも割とそういう印象持ってる人多いんだなー、と。だからどうしたとかどうなるってこともないですが。</p>
<h2>まとめ</h2>
<p>IntelliSenseでLinqはより楽しくなる。メソッドチェインはIntelliSenseでより楽しくなる。そして、VisualStudioはJavaScriptエディタとしても優秀なので皆VisualStudio使おう！インストールが面倒？<a href="http://www.microsoft.com/japan/msdn/vstudio/express/">Microsoft Visual Studio 2008 Express Edition</a>からWeb インストールをクリックするだけでオールインワンでダウンロード含めて10分ぐらいで全部やってくれる。時間がかかるというのは正しいですが、意外と面倒くさくはないんです。それと、このExpress Editionは無料です。</p>
<p>入力補完だけじゃなく、コード整形やデバッガ(開発環境と完全統合されているためFirebugよりもずっと使いやすい)などもあるし、ある程度は裏でインタプリタをぶん回して変数名間違いなどのエラーを補足してくれるので、IDE無しでJavaScript書くなんて、そんな苦労、しなくてもいいんだよ……。</p>
</div>
<h1><a href="https://neue.cc/2010/03/18_247.html">Reactive Extensions for JavaScript</a></h1>
<ul class="date"><li>2010-03-18</li></ul>
<div class="entry_body"><p>MIX10終了しましたねー。何はともかく皆してIE9の話題ばかりで、ああ、InternetExplorerは愛されてるなあ（色々な意味で）、などというのを横目に、私にとっての最大のニュースは<a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx" title="Reactive Extensions for .NET (Rx)">Reactive Extensions for JavaScript(RxJS)</a>です。Reactive Extensions(Rx)はこのサイトでも<a href="http://neue.cc/category/programming/rxframework" title="neue cc - Rx Framework">カテゴリーを作ってメソッド探訪</a>なんてやってるぐらいに注目していたわけで、当然MIX10でJavaScript版出すという話を聞いた時からwktkが止まらなかったわけですが、全く期待を裏切らなかった！というか、こいつはヤバいですよ？</p>
<p>Reactive Extensionsとは何ぞや、というと、LinqというC#の関数型言語みたいなリスト処理ライブラリ(語弊ありまくり)のイベントとか非同期版です。イベントや非同期処理にたいしてmapとかfilterとかfoldとか、お馴染みなリスト操作関数が使えちゃうという、その発想はなかったわ、なライブラリです。C#版は去年の夏ぐらいにプレビュー版が出て、いまも精力的に開発が続いているのですが、今回はJavaScript移植版が出た、という話です。イベント(onclick！onclick！)や非同期(XMLHttpRequest！)ってのは、勿論C#でも大事なのですが、JavaScriptなんてそれが主役というぐらいなわけなので、C#版よりもインパクトは大きいです。何よりも、C#は言語やライブラリが強力なので別にRx使わなくてもって感じなのですが、JavaScriptは違う。あまりにも貧弱。なので、優れたイベント/非同期処理ライブラリの重要度はC#の比ではなく高い。</p>
<p>RxJSの面白いところはjQueryに対抗するものではなく、むしろ協調動作するように作られていることです。DOM操作はjQuery、イベントや非同期処理はRxJS、二つの強力なライブラリを組み合わせることで、JavaScriptプログラミングは次のパラダイムへ向かおうとしています。御託は、もういいですね、とりあえずサンプルを。</p>
<script type="text/javascript" src="http://neue.cc/rx.js"></script>
<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.1.min.js" type="text/javascript"></script>
<script type="text/javascript">
var O = Rx.Observable; // using

$(function()
{
    var doc = $(document);
    var area = $("#dragArea");

    O.FromJQueryEvent(area, "mousedown")
        .Select(function(e)
        {
            var offset = $(e.target).offset();
            return { X: e.pageX - offset.left, Y: e.pageY - offset.top }
        })
        .SelectMany(function(offset)
        {
            return O.FromJQueryEvent(doc, "mousemove")
                .TakeUntil(O.FromJQueryEvent(doc, "mouseup"))
                .Select(function(e) { return { X: e.pageX - offset.X, Y: e.pageY - offset.Y }; })
        })
        .Subscribe(function(a) { area.css({ left: a.X, top: a.Y }) });
});
</script>
<div style="background-color:white;height:100px;">
<div id="dragArea" style="position: absolute; background-color: Teal; width: 50px; height: 50px;cursor:move;"></div>
</div>
<p>マウスをクリックして四角形を掴んで、マウスを動かして、放すという、ごく普通のドラッグアンドドロップ。素の JavaScriptではどうやって実装しますか？グローバルに状態管理用のオブジェクトを置いて、オフセット用の変数置いて、マウスの状態を監視して、うーん、考えたくない。あまり綺麗に出来そうにない。それがRxJSを使ってみると――</p>
<pre><code class="language-javascript">var O = Rx.Observable; // using

$(function()
{
    var doc = $(document);
    var area = $(&quot;#dragArea&quot;);

    O.FromJQueryEvent(area, &quot;mousedown&quot;)
        .Select(function(e)
        {
            var offset = $(e.target).offset();
            return { X: e.pageX - offset.left, Y: e.pageY - offset.top }
        })
        .SelectMany(function(offset)
        {
            return O.FromJQueryEvent(doc, &quot;mousemove&quot;)
                .TakeUntil(O.FromJQueryEvent(doc, &quot;mouseup&quot;))
                .Select(function(e) { return { X: e.pageX - offset.X, Y: e.pageY - offset.Y }; })
        })
        .Subscribe(function(a) { area.css({ left: a.X, top: a.Y }) });
});
</code></pre>
<p>状態管理変数は使いませんし、全て一連のメソッドチェーンだけで完結します。以下解説。</p>
<p>Rx.Observable.FromJQueryEventは、イベントをRxオブジェクトに変換します。これはjQueryの$などと同じものだと思ってください。FromJQueryEventと同様の動作をするものにFromHtmlEventというものがあります。ほとんど同様ですが、jQueryオブジェクトを使う場合はFromJQueryEvent、getElementByIdなどで得られたネイティブの要素を使う場合はFromHtmlEventを使いましょう。基本的には、クロスブラウザ回りの面倒事を任せられるjQueryとの併用がお薦めです。</p>
<p>Rxオブジェクトに変換後は、多数のメソッドをjQueryのようにチェーンさせて記述していきます。どれだけ多数かというと、ここに並べてみます。</p>
<blockquote>
<p>Subscribe, Select, Let, MergeObservable, Concat, Merge, Catch, OnErrorResumeNext, Zip, CombineLatest, Switch, TakeUntil, SkipUntil, Scan1, Scan, Finally, Do, Where, Take, GroupBy, TakeWhile, SkipWhile, Skip, SelectMany, TimeInterval, RemoveInterval, Timestamp, RemoveTimestamp, Materialize, Dematerialize, AsObservable, Delay, Throttle, Timeout, Sample, Repeat, Retry, BufferWithTime, BufferWithCount, StartWith, DistinctUntilChanged, Publish, Prune, Replay</p>
</blockquote>
<p>何も一気に全部を知る必要はないので、あまり圧倒されずに、少しずつ学んでいければいいかな？ 私もちょいちょいとブログ記事で紹介していきたいと思っています(やるやる詐欺ばかりですが……)。そうそう、ソースコードが圧縮されていて実際の名称は不明なのでRxオブジェクトと呼んでますが、それであってるかは今のところ謎です。C#ではIObservableなので、IObservableでいいかな、という気はしますが。</p>
<h2>イベント as リスト</h2>
<p>もう少しFromJQueryEventの動きを考えますか。イベントが発生すると、後ろのメソッドにイベントオブジェクトが渡されます。再度クリックすると、またイベントが発生しイベントオブジェクトが渡されます。再度（以下略）。つまりは、[event, event, event...]。終りのない配列。無限リスト。まるでイテレータのような……。そう、ObserverパターンとIteratorパターンは同じなのだよ、ナンダッテー！よく分からない？確かに。こういう時は他の人の言葉を借りてしまおう。最近<a href="http://d.hatena.ne.jp/yuroyoro/20100317/1268819400" title="Scala的な考え方 - Scalaがとっつきにくいと思っている人へ - ゆろよろ日記">Scalaの入門記事</a>が注目を集めました。「神は言われた。「リストあれ。」」。そうです、イベントもまた、Rxの手にかかればリストになってしまうのです。Rxは関数型言語のリスト操作のようにイベントを高階関数で処理できます。それがもたらす世界、想像するとワクワクしませんか？なお、JavaScriptで配列やDOMに対してリスト操作を行うライブラリとして<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library">linq.js</a>というがありますのでよろしくお願いします←宣伝(作ってるの私なので)。</p>
<h2>ドラッグアンドドロップの構造</h2>
<p>mousedownでイベントが発動しても、本当に必要なイベントはdownじゃなくてmove。なので、downはイベント発動とオフセット算出にだけ使って、実際に後ろに流す情報は別のところから得ます。そこで、mousedownとmousemoveを合流させなければなりません。シーケンス（Rxによりリストのような何かになっているので、Sequenceが言葉として適切な気がします）の結合はMergeやCombineLatest、Zipなど、用途に応じて色々あるのですが、ここは一(mousedown)から多(mousemove)の状態を作ることが可能なSelectManyを使用します。SelectManyに渡す高階関数の戻り値(Rxオブジェクト)が、更に平たくされて後ろのメソッドに渡されていくことになります。</p>
<p>TakeUntilは、「～まで取得する」。引数のイベントが発動されるまでシーケンスを流し、発動されたら一切流さなくなる。つまりFrom(mousemove).TakeUntil(mouseup)は、mouseupされるまでmousemoveイベントを発行するということ。驚くほど簡単にドラッグアンドドロップの構造が記述出来てしまいました。これはヤバい。Rxヤバい。簡潔すぎるだろ常識的に考えて。</p>
<p>Selectは多くの関数型言語やRubyなどで言うところのmapで、要素を変形して返すもの。ここではeventからclientX, clientYだけのオブジェクトを作っています。mapがあるということは、勿論filterもあります(メソッド名はWhere)。この辺は<a href="http://neue.cc/2009/04/04_145.html" title="neue cc - linq.js - JavaScript用LINQライブラリ">linq.jsの解説</a>がそのまんま適用出来ます。何故かというと、Observerパターン(RxJS)とIteratorパターン(linq.js)は（以下略）。</p>
<h2>Subscribe</h2>
<p>シーケンスを変形していったら、最後に登録してやる必要があります。それがSubscribe。Subscribeを呼んで、初めてイベント(mousedownなど)に関連付けられます(addEventListenerです、ようするに)。このSubscribeは感覚的にはforeachのようなもので、無名関数の第一引数に今までに変形させた変数が入っているので、それを取り出して何らかのアクションを取る。今回はstyleを弄って四角形の座標を変更してやりました。</p>
<p>addEventListenerということは、デタッチもあるの？というと、ありますあります。Subscribeの戻り値はvoidではなく、IDisposableオブジェクトというものになっています。この戻り値のIDisposableオブジェクトを取っておけば、デタッチさせたい時にDisposeメソッドを呼んでデタッチさせられます。</p>
<h2>Rx.Observable</h2>
<p>Rxオブジェクトのメソッド一覧は書きましたが、Rx.ObservableにはFromHogeHoge以外にも色々なメソッドがあるよ。イベントだけじゃなく、あらゆる方向からRxオブジェクトを作り出す驚異のメソッド群はこれだ！</p>
<blockquote>
<p>Amb, Catch, Concat, Create, CreateWithDisposable, Defer, Empty, FromArray, FromDOMEvent, FromHtmlEvent, FromIEEvent, FromJQueryEvent, Generate, GenerateWithTime, Interval, Merge, Never, OnErrorResumeNext, Range, Repeat, Return, Start, Throw, Timer, ToAsync, Using, XmlHttpRequest</p>
</blockquote>
<p>いっぱいありますねー。名前から想像つくものからつかないものまで。XmlHttpRequestとか興味をひくところです。そう、Rxはイベントだけではなく、非同期通信までリストに変換し統一的な操作を可能にしてしまうわけです。こっちも重要なので、後日サンプル書きます。</p>
<h2>結論</h2>
<p>jQueryあるからRxJSなんてイラね、というわけじゃあないんですよ！ふたり揃ってプリキュア。最初の方にも書きましたが、jQueryのDOM操作は素晴らしいのでおまかせでいいです。イベントや非同期処理はjQueryだけじゃ足りないところがあります。そこはRxJSで補います。ついでに通常のリスト操作（配列やDOM Elements）は全然足りてません。prototype.jsはあんなにイけてたのに、jQueryになってからリスト処理がシンドいですね。そこは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library">linq.js</a>です（宣伝しつこい）。これでもうJavaScriptに死角はなくなった……、勝った、HTML5時代バンザイ！（でも私はC# + Silverlight4に期待をかけるけどね）</p>
<h2>参考リンク</h2>
<ul>
<li><a href="http://blogs.msdn.com/jeffva/archive/2010/03/17/reactive-extensions-for-javascript-the-time-flies-like-an-arrow-sample.aspx">Jeffrey rambles about Rx, .NET and programming in general. : Reactive Extensions for JavaScript: The Time flies like an arrow sample</a></li>
</ul>
<p>Rxチームの一員であるJeffrey van Goghによる、Rxをインストールしたディレクトリに置いてある、TimeFilesサンプルの解説。forループがダサいので<a href="http://gyazo.com/a61c70995e0647600e6f2e0ecd9ce9c3.png">linq.jsを使って書き直して</a>Twitterに流したんですが、そうしたら<a href="http://twitter.com/jvgogh/status/10673555205">Jeffrey van Goghに言及してもらった！</a>。これは嬉しい。</p>
<ul>
<li><a href="http://codebetter.com/blogs/matthew.podwysocki/archive/2010/03/17/the-reactive-extensions-for-javascript-released.aspx">The Reactive Extensions for JavaScript Released - Matthew Podwysocki - CodeBetter.Com - Stuff you need to Code Better!</a></li>
</ul>
<p>Matthew PodwysockiによるRxJSの解説シリーズ。From(mousemove).TakeUntil(mouseup)のネタ元はここだったりして。最高にクール！</p>
</div>
<h1><a href="https://neue.cc/2010/03/09_246.html">はてなダイアリー to HTML</a></h1>
<ul class="date"><li>2010-03-09</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/hatenadiarytohtml.jpg">
</p>
<ul>
<li><a href="http://apps.neue.cc/HatenaDiaryToHTML/0001.zip">ダウンロード ver.0.0.0.1(zip)</a></li>
</ul>
<p>はてなダイアリーの記事を根こそぎ取得してローカルHTMLに保存するアプリケーションです。過去ログを全部取得して昇順に並び替えます。カテゴリ指定も可。
本文抽出アルゴリズムだなんて高尚なことはせず、HTMLをそのまま切り出しているだけのはてなダイアリー完全特化なぶんだけ、デザインやsyntax-highlightなどもそのままで見ることができます。上の画像は<a href="http://d.hatena.ne.jp/NyaRuRu/" title="NyaRuRuの日記">NyaRuRuの日記</a>(勝手に貼ってすみません)の.NETカテゴリーを抽出しているところ。私がC#やLinqを覚えられたのはNyaRuRuさんの日記のお陰といっても過言ではなく、しかも読み返す度に新しい発見があって本当に素晴らしい。ので、度々読み返しているのですが、はてな重い。重い。なら全部ぶっこぬけばいいぢゃない。というのが作った理由でして……。</p>
<p>あと、最近こそこそごそごそとC++も勉強中なので、 <a href="http://d.hatena.ne.jp/Cryolite/searchdiary?word=%2A%5BC%2B%2B%5D" title="[C++] - Cry’s Diary">[C++] - Cry’s Diary</a>や <a href="http://d.hatena.ne.jp/faith_and_brave/searchdiary?word=%2A%5BC%2B%2B%5D" title="[C++] - Faith and Brave - C++で遊ぼう">[C++] - Faith and Brave - C++で遊ぼう</a>を読むと、(大体は全く分からないのですが)勉強になります。なお、Permalinkは相対パスになってしまい使えないのですが、日付の部分は絶対パスなので、コメント見たくなったりPermalinkを取りたくなったら日付から辿れます。</p>
<p>こうしてHTMLを自炊(？)すると、電子ブックリーダー欲しくなりますね。それと、リーダーはやっぱブラウザが載ってないとダメよねー。PDF(と独自形式？)だけ見れても嬉しくぁない。そんなに本には興味ない。HTMLが見たいのです。Twitterのログが見たいのです。2chまとめサイトが見たいのです。海外の技術書は結構PDFで買える感じなのでそれはそれで気になるところですが――。</p>
<p>以下ソースコード。↑のzipにも同梱してありますが。コンパイルには<a href="http://neue.cc/2010/03/02_244.html" title="neue cc - C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法">SGMLReader</a>が必要です。</p>
<pre><code class="language-csharp">static class Program
{
    static IEnumerable&lt;T&gt; Unfold&lt;T&gt;(T seed, Func&lt;T, T&gt; func)
    {
        for (var value = seed; ; value = func(value))
        {
            yield return value;
        }
    }

    const string HatenaUrl = &quot;http://d.hatena.ne.jp&quot;;

    static void Main()
    {
        Thread.GetDomain().UnhandledException += (sender, e) =&gt;
        {
            Console.WriteLine(e.ExceptionObject);
            Console.ReadLine();
        };

        Console.WriteLine(&quot;抽出対象のはてなIDを入力してください&quot;);
        var id = Console.ReadLine();
        Console.WriteLine(&quot;カテゴリを入力してください(全ての場合は空白)&quot;);
        var word = Console.ReadLine();
        Console.WriteLine(&quot;出力ファイル名を入力してください&quot;);
        var fileName = Console.ReadLine();

        // 抽出クエリ！
        var root = XElement.Load(new SgmlReader { Href = HatenaUrl + &quot;/&quot; + id + ((word == &quot;&quot;) ? &quot;&quot; : &quot;/searchdiary?word=*[&quot; + Uri.EscapeDataString(word) + &quot;]&quot;) });
        var contents = Unfold(root,
            x =&gt;
            {
                var prev = x.Element(&quot;head&quot;).Elements(&quot;link&quot;)
                    .FirstOrDefault(e =&gt; e.Attribute(&quot;rel&quot;) != null &amp;&amp; e.Attribute(&quot;rel&quot;).Value == &quot;prev&quot;);
                if (prev == null) return null;
            retry:
                try
                {
                    var url = HatenaUrl + prev.Attribute(&quot;href&quot;).Value;
                    Console.WriteLine(url); // こういうの挟むのビミョーではある
                    return XElement.Load(new SgmlReader { Href = url });
                }
                catch (WebException) // タイムアウトするので
                {
                    Console.WriteLine(&quot;Timeout at &quot; + DateTime.Now.ToString() + &quot; wait 15 seconds...&quot;);
                    Thread.Sleep(TimeSpan.FromSeconds(15)); // とりあえず15秒待つ
                    goto retry; // 何となくGOTO使いたい人
                }
            })
            .TakeWhile(x =&gt; x != null)
            .SelectMany(x =&gt; x
                .Descendants(&quot;div&quot;)
                .Where(e =&gt; e.Attribute(&quot;class&quot;) != null &amp;&amp; e.Attribute(&quot;class&quot;).Value == &quot;day&quot;))
            .TakeWhile(e =&gt; !Regex.IsMatch(e.Value, @&quot;^「\*\[.+\]」に一致する記事はありませんでした。検索語を変えて再度検索してみてください。$&quot;)) // 間違ったカテゴリ入力した時対策
            .Reverse(); // 古いのから順に見たいので

        // style抽出
        var styles = root.Element(&quot;head&quot;).Elements(&quot;link&quot;)
            .Where(e =&gt; e.Attribute(&quot;rel&quot;).Value == &quot;stylesheet&quot;)
            .Select(e =&gt; { e.SetAttributeValue(&quot;href&quot;, HatenaUrl + e.Attribute(&quot;href&quot;).Value); return e; }) // 副作用ダサい
            .Concat(root.Element(&quot;head&quot;).Elements(&quot;style&quot;));

        // HTML組み立て！
        var html = new XStreamingElement(&quot;html&quot;, // まあ、Reverseでバッファに貯めるので焼け石に水ですけどね、XStreamingElement
            new XStreamingElement(&quot;head&quot;, styles),
            new XStreamingElement(&quot;body&quot;,
            // new XElement(&quot;div&quot;, new XAttribute(&quot;class&quot;, &quot;hatena-body&quot;), サイドバーとか邪魔なので無視
            // new XElement(&quot;div&quot;, new XAttribute(&quot;class&quot;, &quot;main&quot;),
                new XStreamingElement(&quot;div&quot;, new XAttribute(&quot;id&quot;, &quot;days&quot;),
                    contents)));

        // 保存
        var path = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().FullName), fileName + &quot;.html&quot;);
        var xws = new XmlWriterSettings { Indent = true, CheckCharacters = false }; // 不正な文字のあるサイトを書き出すと落ちるので防止
        using (var xw = XmlWriter.Create(path, xws))
        {
            html.Save(xw);
        }
    }
}
</code></pre>
<p>try-catchが出るとゴチャついて嫌。なのだけど、しょうがないか。それと
Unfoldはどうしたものかねえ。極力、標準演算子のみで済ませたいんですが、今回はちょっと使わざるを得なかったと思っています。次のページのURLを得るには、取得したHTMLから解析しなければならない。下流で解析し取得した次のURLは、上流に渡さなきゃいけない。のですが、通常は下から上に渡せないのがLinqなのよね。そんな場合、外部変数を介して渡すか、Unfoldか、場合によってはScanなんかを使うかになるわけで、とにかく外部変数は避けたかったのでUnfoldを使いました。</p>
<p>HTMLへの書き出し部分では物珍しい
XStreamingElementを使ってみました。今回はただ単に書き出すだけなので、通常のXElementのようにメモリ内にツリーを保持する必要はないし、相当大きいXmlを扱うため効率も気になってくるところ。そこで遅延ストリーム書き込みを可能にするXStreamingElementの出番です。詳しくは <a href="http://msdn.microsoft.com/ja-jp/library/bb387013.aspx" title="方法: 大きな XML ドキュメントのストリーミング変換を実行する">方法: 大きな XML ドキュメントのストリーミング変換を実行する</a> をどうぞ。とはいっても、このプログラムでは反転させるためReverseでバッファに全て溜め込んでいるので、まあ……。XStreamingElementって言いたいだけちゃうんか、みたいな。</p>
<p>デザインはdiv class=hatena-bodyとdiv class=mainを抜いているので(不必要なサイドバーの描画を除去するため)、この二つに依存するCSSが書かれているサイトの場合はデザインが崩れることがあります。ちなみに<a href="http://d.hatena.ne.jp/neuecc/" title="neuecc clip">neuecc clip</a>はこの二つどころか、その他にもwrapperを置いているというデタラメなCSS構造をしているため、デザインは保存出来ません。全くもって酷い。もっとスクレイピングに優しいHTMLを書かないとダメですな。</p>
<p>HTMLへの書き出し部分ははまりどころでした。最初Save(fileName)で保存していたんですが、特定のサイトの特定の部分で落ちてしまって困りました。具体的には <a href="http://d.hatena.ne.jp/faith_and_brave/20080723">2008-07-23 - Faith and Brave - C++で遊ぼう</a> で(例に出してすみません)、Protocol Bufferによる出力結果がInvalidXmlCharに引っかかってアウト、のようです。回避する方法は、XmlWriterSettingsのCheckCharactersをfalseに設定したXmlWriterを生成して書き出せばOK。</p>
</div>
<h1><a href="https://neue.cc/2010/03/06_245.html">XboxInfoTwit - ver.2.2.0.0</a></h1>
<ul class="date"><li>2010-03-06</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>今回の更新は、HTMLをXMLに変換するライブラリをTidy.NetからSGMLReaderに変更しました。数日前に<a href="http://neue.cc/2010/03/02_244.html" title="neue cc - C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法">SGMLReaderでLinq to Html最高</a>なんてエントリーを上げていたので、早速実戦投入というわけです。内部コードが割と変わったため、ver2.1系列から2.2へとアップ。利用者的にはぶっちゃけどうでもいい話です。すみません。</p>
<p>ユーザーに関係ある変更点は、先日発売されたばかりのBioShock2で実績が取得出来てなかったので、それを直しました。私はBioShock2でしか確認していないのですが、「カルドセプト」や「のーふぇいと！」も実績が取得出来ないという報告が上がっていたので、今回の修正によって取得出来るようになった、かもしれません。分かりません。カルドセプトやのーふぇいと！を持っている方は実績取れたよー、と教えていただけると助かります。一応Twitter検索で追っかけてはいるんですけど、最近投稿量が多くて（認証者数は1400行きました、ありがとうございます）全然目を通せていなかったりして。</p>
<p>追記：「カルドセプト」、「のーふぇいと！」ともに実績取得出来ているようです。確認していただいた方、ありがとうございました。</p>
</div>
<h1><a href="https://neue.cc/2010/03/02_244.html">C#でスクレイピング:HTMLパース(Linq to Html)のためのSGMLReader利用法</a></h1>
<ul class="date"><li>2010-03-02</li></ul>
<div class="entry_body"><p>Linq to XmlがあるならLinq to Htmlもあればいいのに！と思った皆様こんばんは。まあ、DOMでしょ？ツリーでしょ？XHTMLならそのままXDocument.Loadで行けるよね？XDocument.Parseで行けるよね？ ええ、ええ、行けますとも。XHTMLなら、ね、ValidなXHTMLならね。世の中のXHTML詐称の99.99%がそのまま解析出来るわけがなく普通に落ちてくれるので、XDocumentにそのまま流しこむことは出来ないわけです(もちろん、うちのサイトも詐称ですよ！ていうかこのサイトのHTMLは酷すぎるのでそのうち何とかしたい……)。</p>
<p>そこでHtmlを整形してXmlに変換するツールの出番なわけですが、まず名前が上がるのがTidy、の.NET移植である<a href="http://sourceforge.jp/projects/sfnet_tidynet/" title="Tidy.NET プロジェクト日本語トップページ - SourceForge.JP">Tidy.NET</a>で、これは論外。とにかく面倒くさい上に、パースしきれてなくてXDocumentに流すと平然と落ちたりする。おまけにXDocumentに入れるには文字列にしてから入れる必要があって二度手間感がある、などなど全くお薦めできません。<a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">XboxInfoTwit</a>はTidy使ってますが、後悔してますよ……。</p>
<p>次に<a href="http://journal.mycom.co.jp/articles/2009/12/15/htmlagility/index.html" title="【ハウツー】.NET向けHTMLパーサー「Html Agility Pack」で簡単スクレイピング (1) Html Agility Packとは | エンタープライズ | マイコミジャーナル">Html Agility Pack</a>で、これは中々良いです。Linq to Xml風で大変使いやすい。のですが、あくまで風味であって、なんで本物のLinq to Xmlが目の前にあるのに、それっぽく模したものを覚えなきゃいけないの？二度手間で面倒くさいよ。</p>
<p>そこで、第三の選択として<a href="http://developer.mindtouch.com/en/docs/SgmlReader">SGMLReader</a>を使うという方法を提案します。SGML Reader自体は古くからあるのですが、日本語での情報はあまりないみたいだしLinq to Xmlと組み合わせたスクレイピング用途、に至っては皆無のようなので、ここで紹介しましょう。とりあえず例を。</p>
<pre><code class="language-csharp">// たったこれだけのメソッドを用意しておけば
static XDocument ParseHtml(TextReader reader)
{
    using (var sgmlReader = new SgmlReader { DocType = &quot;HTML&quot;, CaseFolding = CaseFolding.ToLower })
    {
        sgmlReader.InputStream = reader; // ↑の初期化子にくっつけても構いません
        return XDocument.Load(sgmlReader);
    }
}

static void Main(string[] args)
{
    using (var stream = new WebClient().OpenRead(&quot;http://www.bing.com/search?cc=jp&amp;q=linq&quot;))
    using (var sr = new StreamReader(stream, Encoding.UTF8))
    {
        var xml = ParseHtml(sr); // これだけでHtml to Xml完了。あとはLinq to Xmlで操作。

        XNamespace ns = &quot;http://www.w3.org/1999/xhtml&quot;;
        foreach (var item in xml.Descendants(ns + &quot;h3&quot;))
        {
            Console.WriteLine(item.Value); // bingでlinqを検索した結果のタイトルを列挙
        }
    }
}
</code></pre>
<p>見たとおり、信じられないほど簡単です。SgmlReaderはXmlReaderを継承しているため、XDocument.Load(xmlReader)にそのまま流し込めます。また、SgmlReader自体もDocTypeとInputStreamを設定するだけという超簡単設計になっているため、楽にHtml to Xmlが実現。HtmlはXDocumentになってしまえさえすれば、あとは慣れ親しんだLinq to Xmlの操作で抽出していけます。</p>
<p>例では、BingでLinqを検索した結果の検索結果見出し部分を抽出しています。見出しはh3で囲まれているので、Descendants(ns + &quot;h3&quot;)。以上。超簡単。C#のスクレイピングの簡単さはRubyも超えたね！</p>
<p>残る問題は、日本語を扱う際はエンコーディング周りの設定が面倒くさい（間違ったエンコーディングだと文字化けする）、ということなのですが、そのWebClientのエンコーディング問題は、.NET Framework 4.0から修正された <a href="http://connect.microsoft.com/VisualStudioJapan/feedback/details/495816/system-net-webclient-http-encoding">System.Net.WebClient は、HTTP ヘッダーから Encoding を自動的に認識してほしい | Microsoft Connect</a> らしいです。素晴らしい！提案して頂いたbiacさんに感謝。</p>
<h2>追記(2014/3/26)</h2>
<p>いつのバージョンからか、TimeoutでWebExceptionが出るようになってたかもしれません。これはdtdを読みに行こうとしているのが原因のようなので、 IgnoreDtd = true を足してやれば回避できます。</p>
<pre><code class="language-csharp">using (var sgmlReader = new SgmlReader { DocType = &quot;HTML&quot;, CaseFolding = CaseFolding.ToLower, IgnoreDtd = true })
</code></pre>
<p>ということです。</p>
<h2>追記(より簡単に)</h2>
<p>上の記事を書いてから気づいたのですが、HrefプロパティにURLを指定するだけで、中でStream類を作って自動的にHtmlだと判別してくれるようです。更には、エンコーディングもContentTypeを見て自動調整してくれます(詳しくはSgmlParser.csのOpenメソッドを参照)。よって、もっとずっと簡単に書けます。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    XDocument xml;
    using (var sgml = new SgmlReader() { Href = &quot;http://www.xbox.com/ja-JP/games/calendar.aspx&quot; })
    {
        xml = XDocument.Load(sgml); // たった3行でHtml to Xml
    }

    // Xboxの発売スケジュールからタイトルと発売日を抜き出してみる
    var ns = xml.Root.Name.Namespace;
    var query = xml.Descendants(ns + &quot;table&quot;)
        .Last()
        .Descendants(ns + &quot;tr&quot;)
        .Skip(1) // テーブル一行目は項目説明なので飛ばす
        .Select(e =&gt; e.Elements(ns + &quot;td&quot;).ToList())
        .Select(es =&gt; new
        {
            Title = es.First().Value,
            ReleaseDate = es.Last().Value
        });

    // 書き出し
    foreach (var item in query)
    {
        Console.WriteLine(item.Title + &quot; - &quot; + item.ReleaseDate);
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/linqxbox.jpg">
</p>
<p>usingの辺りが若干鬱陶しいので、最初の例のようにメソッドに切り出してもいいかもしれません(CaseFolding.ToLowerも付けたいし)。Loadし終わったらストリームはもう不要です。XDocumentはメモリ内に全部構築するタイプのもので、実質XmlDocument(DOMツリー)の代替となっています。抽出時のXml名前空間ですが、サイトによってついていたりついていなかったりするので、var ns = xml.Root.Name.Namespaceとしておくと、全てのサイトに対応出来ます。</p>
<h2>抽出のテクニック</h2>
<p>上の例は <a href="http://www.xbox.com/ja-JP/games/calendar.aspx">Xbox.com | Xbox ゲームソフト 発売スケジュール</a>からタイトルと発売日を抽出するというものです。定期的にページを監視して、更新されたらTwitterに投稿するXbox発売予定BOTとか作れますね！Xmlで取れるAPIさえあれば……なんてことはなくなりました！これからは
全てのサイトが易々とスクレイピング可能な代物として浮き上がってきますな。</p>
<p>ただし、元がHTMLのものはAPIとして用意されているXMLと違って、抽出に優しくない構造をしています。
Descendants一発でOk、というわけにもいかないので若干の慣れは必要かもしれません。今回の例の抽出コードが何やってるかよくわからない、という人はHTMLソースと見比べてみてください。目的のTableに辿り着くにも、いくつかの方法があります。決め打ち成分が入ってしまうのはどうにもならないのですが、何を決め打ちにするのがスッキリ書けるのか、となると色々です。今回はTableがLastである、という点を使いましたが、他の方法を考えてみると</p>
<pre><code class="language-csharp">var case2 = xml.Descendants(ns + &quot;div&quot;)
    .Where(e =&gt; e.Attribute(&quot;class&quot;) != null &amp;&amp; e.Attribute(&quot;class&quot;).Value == &quot;XbcWpFreeForm1&quot;)
    .SelectMany(e =&gt; e.Descendants(ns + &quot;tr&quot;));

var case3 = xml.Descendants(ns + &quot;table&quot;)
    .First(x =&gt; x.Ancestors().Any(e =&gt; e.Attribute(&quot;class&quot;) != null &amp;&amp; e.Attribute(&quot;class&quot;).Value == &quot;XbcWpFreeForm1&quot;))
    .Descendants(ns + &quot;tr&quot;);
</code></pre>
<p>目的のTableを囲むdivのclassが
XbcWpFreeForm1であり、XbcWpFreeForm1が適用されているdivは一つしかない、ということに着目するとこうなります。case2は、divを全て列挙して探し出す方法。First(predicate)ではなくWhere.SelectManyにすることで、目的のTableが複数個ある場合でも対応出来ます。case3はTableに絞った上で、そのTableの上位階層(Ancestors)にXbcWpFreeForm1が含まれるかを探し当てる方法。Last、という決め打ちが難しい(場合により変動するケース)場合には有効でしょう。この、上位階層(Ancestors)や下位階層(Descendants)の要素に特異な要素はないか(Any)、と探す手法は、ターゲット自体に特徴がなく抽出し難い場合に活用出来ます。</p>
<p>そもそもDescendantsなんて富豪すぎて許せん、実行効率命！という人はElement(&quot;body&quot;).Element(&quot;div&quot;)....とトップから掘っていってもいいわけですが、さすがにElementの連続はダルいのでXPathを使うのもよいでしょう。Linq to XmlでのXPathの利用法は、以前<a href="http://neue.cc/2009/04/17_151.html">neue cc - そしてXPathに戻る</a>に書きました。XPathは、複雑なことを書こうとすると暗号めいた感じになるから余りすきじゃないですね。私は多少冗長なぐらいでもLinqで書くのが好きだなあ。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
