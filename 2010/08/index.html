<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2010-08</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="./pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2010-08-30" data-pagefind-meta="published:2010-08-30"><a href="https://neue.cc/2010/08/30_273.html">T4による不変オブジェクト生成のためのテンプレート</a></h1>
<ul class="date"><li>2010-08-30</li></ul>
<div class="entry_body"><p>不変欲しい！const欲しい！readonlyをローカル変数にもつけたい！という要望をたまに見かけるこの頃。もし、そういった再代入不可というマークがローカル変数に導入されるとしたら、readonlyの使い回しだけは勘弁です。何故って、ローカル変数なんて大抵は再代入しないので、readonly推奨ということになるでしょう、そのうちreadonly付けろreadonly付けろというreadonly厨が出てくるのは目に見えています。</p>
<p>良いことなら付ければいいじゃない、というのはもっともですが、Uglyですよ、視覚的に。readonly var hoge = 3 だなんて、見たくはない。頻繁に使うほうがオプションで醜く面倒くさいってのは、良くないことです。let hoge = 3 といったように、let、もしくはその他のキーワード(valとか？)を導入するならば、いいかな、とは思いますが。</p>
<p>それに、ただ単にマークしただけじゃあ不変を保証するわけでもない……。例えばListなんてClearしてAddRangeしたのと再代入とは、どう違うの？的な。難しいねえ。そんなimmutableの分類に関しては<a href="http://ufcpp.spaces.live.com/blog/cns!5C622397E11C979D!931.entry">ufcppさんのimmutable</a>という記事が、コメント欄含め参考になりました。</p>
<p>そうはいっても、そんなにガチに捉えなくても、不変にしたいシチュエーションはいっぱいあります。<a href="http://d.hatena.ne.jp/zecl/20100531/p1">実はオブジェクト指向ってしっくりきすぎるんです！ 不変オブジェクトのすゝめ。 - Bug Catharsis</a>。おお、すすめられたい。ところでしかし、こういう時にいつも疑問に思っているのは、生成どうすればいいのだろう、ということ。今のところ現実解としてあるのはreadonly、つまり、コンストラクタに渡すしかないのですが……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public Hoge(int a, int b, int c, string d, string e, DateTime f, .....
</code></pre>
<p>破綻してる。こんなクソ長いコンストラクタ見かけたら殺していいと思う。全くもって酷い。さて、どうしましょう。こういう場合はビルダーを使いましょう、とはEffective Javaが言ってますので(私、この本あんま好きじゃないんだよねー、とかはどうでもいいんですがー)とりあえずストレートに従ってみます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// あまり行数使うのもアレなので短くしますが、実際は10行ぐらいあると思ってください
Hoge hoge = new HogeBuilder()
  .Age(10)
  .Name(&quot;hogehoge&quot;)
  .Build();
</code></pre>
<p>まあ、悪くない、ですって？いえいえ、これはBuilder作るの面倒くさいし、第一Java臭い。メソッドチェーンだからモダンで素敵、と脳が直結してる人は考えが一歩足らない。むしろ古臭い。最近は流れるようなインターフェイスとかも割と懐疑的で、私は。頂くのはアイディアだけであって、書き方に関しては、各言語にきっちり馴染ませるべき。先頭の大文字小文字だけ整えて移植だとか、愚かな話。というわけで、C#ならオブジェクト初期化子を使おう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var hoge = new HogeBuilder
{
    Age = 10,
    Name = &quot;hogehoge&quot;
}.Build();

// 暗黙的な型変換を使えばBuildメソッドも不要になる(私はvarのほうが好みですが)
Hoge hoge = new HogeBuilder
{
    Age = 10,
    Name = &quot;hogehoge&quot;
};
</code></pre>
<p>ええ、これなら悪くない。オブジェクト初期化子は大変素晴らしい(本当にそろそろModern C# Designをですね……)。ビルダーを作る手間もJava方式に比べ大幅に軽減されます(set専用の自動プロパティを用意するだけ)。それにIntelliSenseのサポートも効きます。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/objectinitializer_intellisense.jpg">
</p>
<p>未代入のもののみリストアップしてくれる(Ctrl+Space押しだと全部出てきたりする、バグですかね、困った困った)。そういえばで、これは、不変である匿名型の記法とも似ています。余分なのは.Build()だけで、書く手間的にはそんな変わらない。</p>
<p>前説が長ったらしくなりました。本題は「匿名型のような楽な記法で不変型を生成したい」が目標です。C#の現在の記法では、それは無い。欲しいなあ。名前付き引数使えば似たような雰囲気になると言えばなるんですが、アレ使うと「省略可」な雰囲気が出てダメ。ビルダーで作りたいのは、原則「省略不可」なので。</p>
<p>なければ作ればいいじゃない、オブジェクト初期化子を使って.Buildで生成させるビルダーを作れば似たような感じになる。あとは、手動でそれ定義するの非常に面倒なので、そう、T4で自動生成しちゃえばいいぢゃない。</p>
<p>以下コード。例によってパブリックドメインで。別にブログにベタ貼りなコードは自明でいいんじゃないかって気もするんですが、宣言は一応しておいたほうがいいのかなー、と。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ assembly Name=&quot;System.Core.dll&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text.RegularExpressions&quot; #&gt;
&lt;#@ output extension=&quot;Generated.cs&quot; #&gt;
&lt;#
    // 設定：クラス名はそのまま文字列で入力
    // クラスの持つ変数は、コンストラクタに書くみたいにdeffinesに
    // &quot;string hoge&quot;,&quot;int huga&quot; といった形で並べてください
    // usingとnamespaceは、直下の出力部を直に弄ってください
    // partial classなので、これをベースにメソッドを足す場合は別ファイルにpartialで定義することを推奨します
    // Code Contractsに関わる部分は(ContractVerification属性とContract.EndContractBlock())は、
    // 対象がWindows Phone 7などContractが入っていない環境下では削除してください（通常の.NET 4環境では放置で大丈夫）

    var className = &quot;Person&quot;;
    var deffines = new DeffineList {
        &quot;string name&quot;,
        &quot;DateTime birth&quot;,
        &quot;string address&quot;
    };
#&gt;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace Neue.Test
{
    [DebuggerDisplay(@&quot;&lt;#= deffines.DebuggerDisplay #&gt;&quot;, Type = &quot;&lt;#= className #&gt;&quot;)]
    public partial class &lt;#= className #&gt; : IEquatable&lt;&lt;#= className #&gt;&gt;
    {
&lt;# foreach(var x in deffines) {#&gt;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly &lt;#= x.TypeName #&gt; &lt;#= x.FieldName #&gt;;
        public &lt;#= x.TypeName #&gt; &lt;#= x.PropName #&gt; { get { return &lt;#= x.FieldName #&gt;; } }
&lt;# } #&gt;

        private &lt;#= className #&gt;(&lt;#= deffines.Constructor #&gt;)
        {
&lt;# foreach(var x in deffines) {#&gt;
            this.&lt;#= x.FieldName #&gt; = &lt;#= x.FieldName #&gt;;
&lt;# } #&gt;
        }
        
        [ContractVerification(false)]
        public static implicit operator Person(Builder builder)
        {
            return builder.Build();
        }

        public bool Equals(&lt;#= className #&gt; other)
        {
            if (other == null || GetType() != other.GetType()) return false;
            if (ReferenceEquals(this, other)) return true;
            return EqualityComparer&lt;&lt;#= deffines.First().TypeName #&gt;&gt;.Default.Equals(&lt;#= deffines.First().FieldName #&gt;, other.&lt;#= deffines.First().FieldName #&gt;)
&lt;# foreach(var x in deffines.Skip(1)) {#&gt;
                &amp;&amp; EqualityComparer&lt;&lt;#= x.TypeName #&gt;&gt;.Default.Equals(&lt;#= x.FieldName #&gt;, other.&lt;#= x.FieldName #&gt;)
&lt;# } #&gt;
                ;
        }

        public override bool Equals(object obj)
        {
            var other = obj as &lt;#= className #&gt;;
            return (other != null) ? Equals(other) : false;
        }

        public override int GetHashCode()
        {
            var hash = 0xf937b6f;
&lt;# foreach(var x in deffines) {#&gt;
            hash = (-1521134295 * hash) + EqualityComparer&lt;&lt;#= x.TypeName #&gt;&gt;.Default.GetHashCode(&lt;#= x.FieldName #&gt;);
&lt;# } #&gt;
            return hash;
        }

        public override string ToString()
        {
            return &quot;{ &quot; + &quot;&lt;#= deffines.First().PropName #&gt; = &quot; + &lt;#= deffines.First().FieldName #&gt; +
&lt;# foreach(var x in deffines.Skip(1)) {#&gt;
                &quot;, &lt;#= x.PropName #&gt; = &quot; + &lt;#= x.FieldName #&gt; +
&lt;# } #&gt;
                &quot; }&quot;;
        }

        public class Builder
        {
&lt;# foreach(var x in deffines) {#&gt;
            public &lt;#= x.TypeName #&gt; &lt;#= x.PropName #&gt; { private get; set; }
&lt;# } #&gt;

            public &lt;#= className #&gt; Build()
            {
&lt;# foreach(var x in deffines) {#&gt;
                if ((object)&lt;#= x.PropName #&gt; == null) throw new ArgumentNullException(&quot;&lt;#= x.PropName #&gt;&quot;);
&lt;# } #&gt;
                Contract.EndContractBlock();
                return new &lt;#= className #&gt;(&lt;#= string.Join(&quot;, &quot;, deffines.Select(d =&gt; d.PropName)) #&gt;);
            }
        }
    }
}
&lt;#+
    class Deffine
    {
        public string TypeName, FieldName, PropName;

        public Deffine(string constructorParam)
        {
            var split = constructorParam.Split(' ');
            this.TypeName = split.First();
            this.FieldName = Regex.Replace(split.Last(),  &quot;^(.)&quot;, m =&gt; m.Groups[1].Value.ToLower());
            this.PropName = Regex.Replace(FieldName, &quot;^(.)&quot;, m =&gt; m.Groups[1].Value.ToUpper());
        }
    }

    class DeffineList : IEnumerable&lt;Deffine&gt;
    {
        private List&lt;Deffine&gt; list = new List&lt;Deffine&gt;();

        public void Add(string constructorParam)
        {
            list.Add(new Deffine(constructorParam));
        }        
        
        public string DebuggerDisplay
        {
            get
            {
                return &quot;\\{ &quot; + string.Join(&quot;, &quot;, list.Select(d =&gt;
                    string.Format(&quot;{0} = {{{1}}}&quot;, d.PropName, d.FieldName))) + &quot; }&quot;;
            }
        }

        public string Constructor
        {
            get { return string.Join(&quot;, &quot;, list.Select(d =&gt; d.TypeName + &quot; &quot; + d.FieldName)); }
        }

        public IEnumerator&lt;Deffine&gt; GetEnumerator()
        {
            return list.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
#&gt;
</code></pre>
<p>以下のようなのが出力されます（長いねー）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace Neue.Test
{
    [DebuggerDisplay(@&quot;\{ Name = {name}, Birth = {birth}, Address = {address} }&quot;, Type = &quot;Person&quot;)]
    public partial class Person : IEquatable&lt;Person&gt;
    {
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly string name;
        public string Name { get { return name; } }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly DateTime birth;
        public DateTime Birth { get { return birth; } }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly string address;
        public string Address { get { return address; } }

        private Person(string name, DateTime birth, string address)
        {
            this.name = name;
            this.birth = birth;
            this.address = address;
        }
        
        [ContractVerification(false)]
        public static implicit operator Person(Builder builder)
        {
            return builder.Build();
        }

        public bool Equals(Person other)
        {
            if (other == null || GetType() != other.GetType()) return false;
            if (ReferenceEquals(this, other)) return true;
            return EqualityComparer&lt;string&gt;.Default.Equals(name, other.name)
                &amp;&amp; EqualityComparer&lt;DateTime&gt;.Default.Equals(birth, other.birth)
                &amp;&amp; EqualityComparer&lt;string&gt;.Default.Equals(address, other.address)
                ;
        }

        public override bool Equals(object obj)
        {
            var other = obj as Person;
            return (other != null) ? Equals(other) : false;
        }

        public override int GetHashCode()
        {
            var hash = 0xf937b6f;
            hash = (-1521134295 * hash) + EqualityComparer&lt;string&gt;.Default.GetHashCode(name);
            hash = (-1521134295 * hash) + EqualityComparer&lt;DateTime&gt;.Default.GetHashCode(birth);
            hash = (-1521134295 * hash) + EqualityComparer&lt;string&gt;.Default.GetHashCode(address);
            return hash;
        }

        public override string ToString()
        {
            return &quot;{ &quot; + &quot;Name = &quot; + name +
                &quot;, Birth = &quot; + birth +
                &quot;, Address = &quot; + address +
                &quot; }&quot;;
        }

        public class Builder
        {
            public string Name { private get; set; }
            public DateTime Birth { private get; set; }
            public string Address { private get; set; }

            public Person Build()
            {
                if ((object)Name == null) throw new ArgumentNullException(&quot;Name&quot;);
                if ((object)Birth == null) throw new ArgumentNullException(&quot;Birth&quot;);
                if ((object)Address == null) throw new ArgumentNullException(&quot;Address&quot;);
                Contract.EndContractBlock();
                return new Person(Name, Birth, Address);
            }
        }
    }
}
</code></pre>
<p>これで、どれだけ引数の多いクラスであろうとも、簡単な記述でイミュータブルオブジェクトを生成させることが出来ます。しかも、普通にクラス作るよりも楽なぐらいです、.ttをコピペって、先頭の方に、コンストラクタに並べる型を書くだけ。後は全部自動生成任せ。もし積極的に使うなら、Generated.csのほうを消して.ttのみにした状態で、ファイル→テンプレートのエクスポートで項目のエクスポートをすると使い回しやすくて素敵と思われます、項目名はImmutableObjectとかで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 書くときはこんな風にやります
var person1 = new Person.Builder
{
    Name = &quot;hoge&quot;,
    Birth = new DateTime(1999, 12, 12),
    Address = &quot;Tokyo&quot;
}.Build();

// 暗黙的な型変換も実装されているので、.Buildメソッドの省略も可
Person person2 = new Person.Builder
{
    Name = &quot;hoge&quot;,
    Birth = new DateTime(1999, 12, 12),
    Address = &quot;Tokyo&quot;
};

// 参照ではなく、全てのフィールドの値の同値性で比較される
Console.WriteLine(person1.Equals(person2)); // true
</code></pre>
<p>匿名型の再現なので、EqualsやGetHashCodeもオーバーライドされて、フィールドの値で比較を行うようになっています。この辺はもう手動だと書いてられないですよね。ReSharperなどを入れて生成をお任せする、という手はありますが。</p>
<p>==はオーバーライドされていません。これもまた匿名型の再現なので……。Tupleもされてないですしね。これは、フィールドをreadonlyで統一しようと「変更可能」な可能性が含まれるので==は不適切、というガイドライン的なもの(と解釈しました)に従った結果です。変更可能云々は、下の方で解説します。</p>
<h2>Code Contracts</h2>
<p>更に、<a href="http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx" title="Code Contracts">Code Contracts</a>を入れれば、値の未代入に対するコンパイラからの静的チェックまで得られます！下記画像のは、Addressが未入力で、通常は実行時に例外が飛ぶことで検出するしかないですが、Code Contractsが静的チェックで実行前にnullだと警告してくれています。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/codecontracts_build.jpg">
</p>
<p>ビルダーの欠点は未代入の検出が実行時まで出来なかったりすること。インターフェイスで細工することで、順番を規定したり、必ず代入しなければならないものを定義し終えるまでは.BuildメソッドがIntelliSenseに出てこないようにする。などが出来ますが、手間がかかりすぎて理想論に留まっている気がします。</p>
<p>簡単であることってのはとても大事で、過剰な手間暇や複雑な設計だったりってのは、必ず無理が生じます。手間がかかること、複雑であることは、それ自体が良くない性質の一つであり、メリットがよほど上回らない限りは机上の空論にすぎない。</p>
<p>今回、Code Contractsのパワーにより、シンプルなオブジェクト初期化子を使ったビルダーでも未代入の静的チェックをかませる、という素敵機構が実現しました。残念ながらCode Contractsは要求環境が厳しいです。アドインを入れてない/入れられない(Express)場合はどうなるのか、というと、.NET 4にクラス群は入っているので、コンパイル通らないということはありません。普通にArgumentNullExceptionがthrowされるという形になります。</p>
<p>私が考えるに、.NET 4でクラスが入ったのって、Code Contractsのインストールの有無に関係なくコードが共有出来るように、という配慮でしかない予感。ExpressでContractクラスを使う意味は、あまりなさそうですね。Windows Phone 7環境など、Contractクラスそのものがないような場合では、T4のBuilderクラスBuildメソッドのContract.EndContractBlock();の一行とimplict operatorのContractVerification属性を削除してください。自分で好きに簡単に書き換えられるのもT4の良さです。</p>
<p>今回はnullチェックしかしていないので、つまり値型の未代入には無効です。何とかして入れたいとは思ったんですが、例えば対策として値型をNullableにするにせよType情報が必要で、そのためにはAssembly参照が必要で、と設定への手間が増えてしまうので今回は止めました(このT4はただ文字列を展開しているだけで、完全にリフレクション未使用)</p>
<p>Code Contractsに関しては、事前条件のnullチェックにしか使っていなくて真価の1%も発揮されていないので、詳しくは<a href="http://d.hatena.ne.jp/zecl/20100131/p1">とある契約の備忘目録。契約による設計(Design by Contract)で信頼性の高いソフトウェアを構築しよう。 - Bug Catharsis</a>などなどを。不変オブジェクトに関してもそうだけれど、zeclさんの記事は素晴らしいです。</p>
<p>Code Contracts自体は、メソッド本体の上の方で、コントラクトの記述が膨れ上がるのは好きでないかも。従来型の、if-then-throwでの引数チェックも、5行を超えるぐらいになるとウンザリしますね。ご丁寧に{で改行して、if-then-throwの一個のチェックに4行も使って、それが5個ぐらい連なって20行も使いやがったりするコードを見ると発狂します。そういう場合に限ってメソッド本体は一行で他のメソッド呼んでるだけで、更にその、他のメソッドの行頭にも大量の引数チェックがあったりすると、死ねと言いたくなる。コードは視覚的に、横領域の節約も少しは大事だけど、縦も大事なんだよ、分かってよね……。メソッド本体が1000行とか書く人じゃなく、100行超えたら罰金(ｷﾘｯ とか言ってる人だけど、それならガード句が10行超えたら罰金だよこっちとしては。</p>
<p>話が脱線した。つまるところ、コントラクトはライブラリレベルで頑張るよりも、言語側でのサポートが必要な概念ですね、ということで。実際rewriterとか、ライブラリレベル超えて無茶しやがって、の領域に踏み込んでいますし＜Code Contracts。</p>
<h2>プラスアルファ</h2>
<p>partial classで生成されるので(デフォルトではクラス名.Generated.cs)、別ファイルにクラスを作ることで、フィールドの増減などでT4を後で修正しても、影響を受けることなくメソッドを追加することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Person.csという形で別ファイルで追加
using System;

namespace Neue.Test
{
    public partial class Person
    {
        public int GetAge(DateTime target)
        {
            return (target.Year - birth.Year);
        }
    }
}
</code></pre>
<p>それと、nullチェックだけじゃなくきっちりBuildに前提条件入れたい(もしくはnullを許容したい)場合は、T4のBuildメソッドの部分に直に条件を書いてしまうか、それも何だか不自然に感じる場合は生成後のファイルをT4と切り離してしまうのも良いかもですね。自由なので好きにどうぞですます。</p>
<h2>で、本当に不変なの？</h2>
<p>何をもってどこまでを不変というのかはむつかしいところですが、Equalsが、GetHashCodeが変化するなら、可変かしら？ 単純に全ての含まれる型のゲッターが常に同一の値を返さなければ不変ではない、でも良いですが。冒頭でも言いましたが、そう見るとreadonlyだけでは不変を厳密には保証しきれていません。匿名型で例を出すと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class MyClass
{
   public int i;

   public override int GetHashCode()
   {
       return i;
   }
}

static void Main(string[] args)
{
   var anon = new { MC = new MyClass { i = 100 } };
   var hashCode1 = anon.GetHashCode();

   anon.MC.i = 1000; // 変更
   var hashCode2 = anon.GetHashCode();

   Console.WriteLine(hashCode1 == hashCode2); // false
   Console.WriteLine(hashCode1);
   Console.WriteLine(hashCode2);
}
</code></pre>
<p>参照しているMyClassのインスタンスの中身が変化可能で、それが変化してしまえば、違う値になってしまいます。厳密に不変であるためには、中のクラス全てが不変でなければなりません。これは今の言語仕様的には制限かけるのは無理かなー、といったところ。T4なのでリフレクションで全部バラして、参照している型が本当の意味で不変なのかどうか検証して、可変の型を含む場合はジェネレートしない、という形でチェックかけるのは原理的には可能かもしれません、が、やはり色々無理があるかなあ。</p>
<h2>まとめ</h2>
<p>プログラミングの楽しさの源は、書きやすく見た目が美しいことです。私はLinq to Objects/Linq to Xmlでプログラミングを学んだようなものなので、Linqの成し遂げたこと(究極のIntelliSenseフレンドリーなモデル・使いづらいDOMの大破壊)というのが、設計の理想と思っているところが相当あります。C#は言語そのものが素晴らしいお手本。匿名型素晴らしいよ(一年ぐらい前は匿名型も可変ならいいのに、とか口走っていた時期があった気がしますが忘れた、いやまあ、可変だと楽なシチュエーションってのもそれなりにいっぱいあるんですよね)。</p>
<p>T4の標準搭載はC#にとって非常に大きい。T4標準搭載によって、出来る事の幅がもう一段階広がった気がします。partial class素晴らしい。自動生成って素敵。T4はただのテキストテンプレートじゃなくて「VSと密接に結びついていて」「なおかつ標準搭載」「もはやC#の一部といってもいい」ことが、全く違った価値をもたらしていると思います。自動生成前提のパターンを作っても/使ってもいいんだよ、と。言語的に足らない部分の迂回策が、また一つ加わった。</p>
<p>見た目上若干Uglyになっても自動生成でなんとかする、というのはJava + Eclipseもそうですが、それと違うのはpartialでUglyな部分を隔離出来る(隔離によって自動生成の修正が容易になることも見逃せない)ことと、自動生成部分をユーザーが簡単に書けること、ですね。Eclipseの自動生成のプラグインを書くのは敷居が高すぎですが、T4を書く、書くまではしなくても修正する、というのは相当容易でしょう。</p>
<p>最近本当にT4好きですねー。色々と弄ってしまいます。こーどじぇねれーと素晴らしい。あとは、T4自体のUglyさが少し軽減されればな、といったところでしょうか。テンプレートエンジンとしてRazorに切り替えられたりを望みたいなあ。</p>
</div>
<h1 data-pagefind-sort="date:2010-08-19" data-pagefind-meta="published:2010-08-19"><a href="https://neue.cc/2010/08/19_272.html">Reactive ExtensionsのFromEventをT4 Templateで自動生成する</a></h1>
<ul class="date"><li>2010-08-19</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx" title="Reactive Extensions for .NET (Rx)">Rx</a>で面倒くさいのが、毎回書かなければならないFromEvent。F#ならイベントがファーストクラスで、そのままストリーム処理に流せるという素敵仕様なのですが、残念ながらC#のeventはかなり雁字搦めな感があります。しかし、そこは豊富な周辺環境で何とか出来てしまうのがC#というものです。F#では form.MouseMove |&gt; Event.filter と書けますが、 form.MouseMoveAsObservable().Where と書けるならば、似たようなものですよね？</p>
<p>というわけで、T4です。FromEventを自動生成しましょう！と、いうネタは散々既出で海外のサイトにも幾つかあるし、日本にもid:kettlerさんが<a href="http://d.hatena.ne.jp/kettler/20100424">FromEventが面倒なので自動生成させてみた2</a>として既に書かれているのですが、私も書いてみました。書くにあたってid:kettlerさんのコードを大変参考にさせていただきました、ありがとうございます。</p>
<p>私の書いたもののメリットですが、リフレクションを使用しないFromEventで生成しているため、実行コストが最小に抑えられています。リフレクションを使わないFromEventは書くのが面倒でダルいのですが、その辺自動生成の威力発揮ということで。それと、命名規則をGetEventではなくEventAsObservableという形にしています。これは、サフィックスのほうがIntelliSenseに優しいため。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rxclickasobservable.jpg">
</p>
<p>んね？この命名規則は、RxJSのほうで公式に採用されているものなので(例えばrx.jQuery.jsのanimateAsObservable)、俺々規則というわけじゃないので普通に従っていいと思われます。</p>
<p>以下コード。利用改変その他ご自由にどうぞ、パブリックドメインで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ assembly Name=&quot;System.Core.dll&quot; #&gt;
&lt;#@ assembly Name=&quot;System.Windows.Forms.dll&quot; #&gt;
&lt;#@ assembly Name=&quot;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client\System.Xaml.dll&quot; #&gt;
&lt;#@ assembly Name=&quot;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client\PresentationCore.dll&quot; #&gt;
&lt;#@ assembly Name=&quot;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client\PresentationFramework.dll&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text.RegularExpressions&quot; #&gt;
&lt;#@ import namespace=&quot;System.Reflection&quot; #&gt;
&lt;#
    // 設定：ここに生成したいクラス(のTypeをFullNameで)を足してください(以下の4つは例)
    // クラスによってはassemblyの増減が必要です、WPF/Silverlightなどはフルパス直書きしてください
    var types = new[] {
        typeof(System.Collections.ObjectModel.ObservableCollection&lt;&gt;),
        typeof(System.Windows.Forms.Button),
        typeof(System.Windows.Controls.Primitives.TextBoxBase),
        typeof(System.Windows.Controls.Primitives.ButtonBase)
    };
#&gt;
using System.Linq;
using System.Collections.Generic;

&lt;# foreach(var x in GenerateTemplates(types)) {#&gt;

namespace &lt;#= x.Namespace #&gt;
{
    &lt;# foreach(var ct in x.ClassTemplates) {#&gt;

    internal static class &lt;#= ct.Classname #&gt;EventExtensions
    {
        &lt;# foreach(var ev in ct.EventTemplates) {#&gt;
		
        public static IObservable&lt;IEvent&lt;&lt;#= ev.Args #&gt;&gt;&gt; &lt;#= ev.Name #&gt;AsObservable&lt;#= ct.GenericArgs #&gt;(this &lt;#= ct.Classname #&gt;&lt;#= ct.GenericArgs #&gt; source)
        {
            return Observable.FromEvent&lt;&lt;#= ev.Handler + (ev.IsGeneric ? &quot;&lt;&quot; + ev.Args + &quot;&gt;&quot; : &quot;&quot;) #&gt;, &lt;#= ev.Args #&gt;&gt;(
                h =&gt; &lt;#= ev.IsGeneric ? &quot;h&quot; : &quot;new &quot; + ev.Handler + &quot;(h)&quot; #&gt;,
                h =&gt; source.&lt;#= ev.Name #&gt; += h,
                h =&gt; source.&lt;#= ev.Name #&gt; -= h);
        }
        &lt;# } #&gt;
    }
    &lt;# }#&gt;
}
&lt;# }#&gt;
&lt;#+
    IEnumerable&lt;T&gt; TraverseNode&lt;T&gt;(T root, Func&lt;T, T&gt; selector)
    {
        var current = root;
        while (current != null)
        {
            yield return current;
            current = selector(current);
        }
    }

    IEnumerable&lt;ObservableTemplate&gt; GenerateTemplates(Type[] types)
    {
        return types.SelectMany(t =&gt; TraverseNode(t, x =&gt; x.BaseType))
            .Distinct()
            .GroupBy(t =&gt; t.Namespace)
            .Select(g =&gt; new ObservableTemplate
            {
                Namespace = g.Key,
                ClassTemplates = g.Select(t =&gt; new ClassTemplate(t))
                    .Where(t =&gt; t.EventTemplates.Any())
                    .ToArray()
            })
            .Where(a =&gt; a.ClassTemplates.Any())
            .OrderBy(a =&gt; a.Namespace);
    }

    class ObservableTemplate
    {
        public string Namespace;
        public ClassTemplate[] ClassTemplates;
    }

    class ClassTemplate
    {
        public string Classname, GenericArgs;
        public EventTemplate[] EventTemplates;

        public ClassTemplate(Type type)
        {
            Classname = Regex.Replace(type.Name, &quot;`.*$&quot;, &quot;&quot;);
            GenericArgs = type.IsGenericType
                ? &quot;&lt;&quot; + string.Join(&quot;,&quot;, type.GetGenericArguments().Select((_, i) =&gt; &quot;T&quot; + (i + 1))) + &quot;&gt;&quot;
                : &quot;&quot;;
            EventTemplates = type.GetEvents(BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.DeclaredOnly | BindingFlags.Instance)
                .Select(ei =&gt; new { EventInfo = ei, Args = ei.EventHandlerType.GetMethod(&quot;Invoke&quot;).GetParameters().Last().ParameterType })
                .Where(a =&gt; a.Args == typeof(EventArgs) || a.Args.IsSubclassOf(typeof(EventArgs)))
                .Select(a =&gt; new EventTemplate
                {
                    Name = a.EventInfo.Name,
                    Handler = Regex.Replace(a.EventInfo.EventHandlerType.FullName, &quot;`.*$&quot;, &quot;&quot;),
                    Args = a.Args.FullName,
                    IsGeneric = a.EventInfo.EventHandlerType.IsGenericType
                })
                .ToArray();
        }
    }

    class EventTemplate
    {
        public string Name, Args, Handler;
        public bool IsGeneric;
    }
#&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなのが生成されます

namespace System.Collections.ObjectModel
{
    internal static class ObservableCollectionEventExtensions
    {
        public static IObservable&lt;IEvent&lt;System.Collections.Specialized.NotifyCollectionChangedEventArgs&gt;&gt; CollectionChangedAsObservable&lt;T1&gt;(this ObservableCollection&lt;T1&gt; source)
        {
            return Observable.FromEvent&lt;System.Collections.Specialized.NotifyCollectionChangedEventHandler, System.Collections.Specialized.NotifyCollectionChangedEventArgs&gt;(
                h =&gt; new System.Collections.Specialized.NotifyCollectionChangedEventHandler(h),
                h =&gt; source.CollectionChanged += h,
                h =&gt; source.CollectionChanged -= h);
        }
    }
}

namespace System.ComponentModel
{
    internal static class ComponentEventExtensions
    {
        public static IObservable&lt;IEvent&lt;System.EventArgs&gt;&gt; DisposedAsObservable(this Component source)
        {
            return Observable.FromEvent&lt;System.EventHandler, System.EventArgs&gt;(
                h =&gt; new System.EventHandler(h),
                h =&gt; source.Disposed += h,
                h =&gt; source.Disposed -= h);
        }
    }

    // 以下略
</code></pre>
<p>使い方ですが、RxGenerator.ttとか、名前はなんでもいいのですがコピペって、上の方のvar typesに設定したい型を並べてください。一緒に並べたものの場合は、全て継承関係を見て重複を省くようになっています。WPFとかSilverlightのクラスから生成する場合は、assembly Nameに直にDLLのパスを書いてやってくださいな。コード的には、例によってLinq大活躍というかLinqなかったら死ぬというか。リフレクションxLINQxT4は鉄板すぎる。</p>
<p>一つ難点があって、名前空間をそのクラスの属している空間にきっちりと分けたせいで、例えばWPFのbutton.ClickAsObservableはSystem.Windows.Controls.Primitivesをusingしないと出てこないという、微妙に分かりづらいことになっちゃっています……。これ普通にHogeHogeExtensionsとかいう任意の名前空間にフラットに配置したほうが良かったのかなあ。ちょっと悩ましいところ。</p>
<h2>T4の書き方</h2>
<p>漠然と書いてると汚いんですよね、T4。読みにくくてダメだし読みにくいということは書きにくいということでダメだ。というわけで、今回からは書き方を変えました。ASP.NETのRepeater的というかデータバインド的にというかで、入れ物クラスを作って、パブリックフィールド(自動プロパティじゃないのって？そんな大袈裟なものは要りません)を参照させるという形にしました。foreachや閉じカッコ(&quot;}&quot;)は一行にする。&lt;% %&gt;で囲まれる範囲を最小限に抑えることで、ある程度の可読性が確保出来ているんじゃないかと思います。</p>
<p>といったようなアイディアは</p>
<blockquote>
<p>よく訓練されたT4使いは　「何を元に作るか」　「何を作るか」　だけを考える。<br />
何を元に作るかはきっと from ... select になるでしょう。 何を作るかの中では　&lt;#=o.Property#&gt; で値を出力する事ができます。<br />
<a href="http://aka-kazuk.spaces.live.com/blog/cns!EB33514F53BAF4B3!259.entry">csproj.user を作るための T4 テンプレート</a></p>
</blockquote>
<p>からです。「何を元に作るか」　「何を作るか」　。聞いてみれば当たり前のようだけれど、本当にコロンブスの卵というか(前も同じこと書いた気がする)、脳みそガツーンと叩かれた感じで、うぉぉぉぉぉ、と叫んで納得でした。はい。それと、T4は書きやすいと言っても書きにくい（？）ので、囲む範囲を最小にするってことは、普通のコードでじっくり書いてからT4に移植しやすいってことでもあるんですね。</p>
<h2>まとめ</h2>
<p>最近F#勉強中なのです。Expert F# 2.0買ったので。と思ったらプログラミングF#が翻訳されて発売されるだとー！もうすぐ。あと一週間後。くぉ、英語にひいこらしながら読んでいるというのにー。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=1430224312" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=4873114667" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>F#すげーなー、と知れば知るほど確かに思うわけですが、しかし何故か同時に、C#への期待感もまた高まっていきます。必ずや「良さ」を吟味して取り込んでくれるという信頼感があります、C#には。そしてまた、ライブラリレベルで強烈に何とか出来る地力がある、例えばイベントをストリームに見立てた処理には、Reactive Extensionsが登場してC#でも実現出来ちゃったり。Scalaと対比され緩やかに死んでいくJavaと比べると、F#と対比しても元気に対抗していくC#の頼もしさといったらない。</p>
<p>といっても、F#も全然まだ表面ぐらいしか見えてないし、突っつけば突っつくほど応えてくれる奥の深い言語な感じなので、今の程度の知識で比較してどうこうってのはないです。Java7のクロージャにたいし、Javaにそんなものはいらない、とか頑な態度を取っている人を見るとみっともないな、と思うわけですが、いつか私もC#に拘泥してC#にそんなものはいらない、的なことを言い出すようだと嫌だなー、とかってのは思ってます。進化を受け入れられなくなったら、終わり。</p>
<p>マルチパラダイム言語の勝利→C++/CLI大勝利ですか？→いやそれは多分違う。的なこともあるので何もかもを受け入れろ、ひたすら取り込んで鈍重な恐竜になれ(最後に絶滅する)、とは言いません。この辺のバランス感覚が、きっと言語設計にとって難しいことであり、そして今のC#は外から見れば恐竜のようにラムダ式だのdynamicだのを取り入れてるように見えるでしょうが、決してそうではなく、素晴らしいバランスに立っています。機能の追加が恐竜への道になっていない。むしろ追加によって過去の機能を互換性を保ちつつ捨てているんですよね、例えば、もうdelegateというキーワードは書くどころか目にすることもほとんどない←なのでC#を学習する場合、C#1.0-&gt;2.0-&gt;3.0-&gt;4.0という順番を辿るのは良くなくて、最新のものから降りていったほうがいい。</p>
<p>何が言いたいかっていったらC#愛してるってことですな。うはは。5.0にも当然期待していますし、Anders Hejlsbergの手腕には絶対的に信頼を寄せています。4.0は言語的な飛躍はあまりなかっただけに、5.0は凄いことになるに違いない。</p>
</div>
<h1 data-pagefind-sort="date:2010-08-11" data-pagefind-meta="published:2010-08-11"><a href="https://neue.cc/2010/08/11_271.html">linq.jsやRxJSのベンチマーク</a></h1>
<ul class="date"><li>2010-08-11</li></ul>
<div class="entry_body"><p>どうも、定期的<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js - LINQ for JavaScript</a>宣伝の会がやってまいりました。最近はページビューも絶好調、なのだけどDL数はそこまで伸びない（でも同種のライブラリよりもDL数多かったりするので需要が限界値と思われる）などなどな近況ですがこんばんわ。乱立するLinqのJavaScript実装……。などと言うほどに乱立はしてないし、そもそも2009/04に最後発で私が出したのが最後で、それ以降の新顔は見かけないのですが(しいて言えばRxJS)、ちょうどjLinqを実装した人が、<a href="http://somewebguy.wordpress.com/2010/08/08/jlinq-reloaded/">ベンチ結果がボロボロだった、作り直してる</a>という記事を出したので、ほぅほぅとそのベンチマークを見て、ちょっと改良して色々なLinq実装で比較してみました。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/jorderbench.jpg">
</p>
<blockquote>
<p><a href="http://act.neue.cc/bench/" title="jOrder benchmark page">jOrderのベンチに色々足したもの</a></p>
</blockquote>
<p>左のがIE8、重ねて後ろ側のがChrome。この画像は77件のJSONをGroupIDが107か185のもののみをフィルタして配列を返すという処理を1000回試行したもの。毎度思いますが、V8恐ろしく速い。そりゃnode.jsとか普通に現実的な話ですよね、大変素晴らしい。</p>
<h2>jOrderについて</h2>
<p>このベンチマークは、もとは<a href="http://wiki.github.com/danstocker/jorder/" title="Home - jorder - GitHub">jOrder</a>という、Linq……ではなくてSQL風のもので(SQLっぽいのは結構いっぱいあります)、巨大なJSONを効率よく抽出するために、先にインデックス的なのを作ってそれから処理すれば速くなるよ！というライブラリが先々月ぐらいに出来たばっからしいのですが、それがjLinqと比較してこれだけ速いぜ！とやっていたようです。結果見る限りはjLinqクソ遅くてjOrderクソ速くて凄ー、となったのですが、なんかどーにも胡散臭さが拭えないわけですよ、ベンチ詐欺に片足突っ込んでいるというか。</p>
<p>jOrderは初回にインデックスっぽいものを作成するので、二回目以降の抽出は爆速、というのがウリ（っぽい）ようで、ベンチは確かに速い。で、その初回のインデックス生成は何時やってるんでしょうか？このベンチのソースを見ると、ボタンを押してからじゃなくて、ページのロード時にやってますね……。あの、それも立派なコストなのですが、無視ですか？無視ですか？そりゃあ試行回数を1000でベンチ取るならば無視出来るほどに小さいかもですね？でも、Test Cycles 1とか用意しているわけですが、どうなんでしょうね、インデックス作成時間を無視するのは、ちょっと卑怯すぎやしませんか？そもそも対象にひぢょーに遅いjLinq「だけ」を選んでいるというところがやらしい。</p>
<p>というわけで、オリジナルのベンチにはないのですがwith create indexというボタン押してからインデックスを作成する項目を足しました。1000回の試行では、コンセプトに乗っ取るなら1回のインデックス作成にすべきなんでしょうが、普通に1000回インデックス作成に走るのでクソ遅いです。あ、いや、別にアンチキャンペーン張ろうってわけじゃあないんですが、単純に面倒なので……。インデックス作成コストは試行回数1にすれば分かる。</p>
<p>ベンチ結果を見ると、まず、インデックス的なものの作成には非常にコストがかかってる。そして、わざわざコストをかけて生成したところで、Small table(77件のJSON)では、フィルタリングに関してはjQueryの$.grep、つまりは何も手をかけてないシンプルなフィルタリングと同じ速度でしかなくて、あまり意味が無い。Large table（1000件のJSON）ではそれなりな効果が出ているようですが、インデックス作成コストをペイするまでの試行回数を考えると、やはりあまり意味がなさそうな……。コンセプトは面白いんですが、それ止まりかなあ。機能的には、このインデックス生成一点勝負なところがあるので、他のLinq系ライブラリのような多機能なクエリ手段があるわけでもないし。</p>
<h2>その他のライブラリについて</h2>
<p>どれも似たり寄ったりで同じことが出来ますが、処理内容は全然違います。linq.jsは遅延評価であることと、列挙終了時にDisposeすることを中心に据えているので、シンプルにフィルタするだけのもの(jQueryの$.grepとか)よりも遥かに遅くなっています。JSINQも同じく遅延評価で、実装も大体似てます。なので、計測結果もほぼ同じですが、linq.jsのほうが遅い。これは、jsinqはDisposeがないため、その分の速度差が出ています（それ以外にも、単純にlinq.jsのほうが色々処理挟んでて遅め）。</p>
<p>LINQ to JavaScript(JSLINQ)はLINQの名を冠していますが、即時評価で、中身はただの配列のラッパーです。その分だけ単純な実装になっているので、単純なことをこなすには速い。jQueryの$.grepも同じく、普通に配列をグルッとループ回してifで弾いて、新しい配列にpushして、新しい配列を返すもの。というわけで、両者はほとんど同じ速度です。ただ、若干jQueryのほうが速いようで。これは、JSLINQはthis.itemsという形で対象の配列にアクセスしていて、それが速度差になってる模様。var items = this.itemsと列挙の前に置いてやれば、jQueryとほぼ同じ速度になる。1000回の試行だと20msecぐらいの差にはなるようですね。これが気にするほどかは、どうでしょう……。私は全く気にしません。</p>
<p>残念なことにめっちゃ遅いjLinqは、うーん、中はevalだらけだそうで、それが響いたそうです。と、作者が言ってるのでそうなのでしょう（適当）。RxJSも割と遅いんですが、これはしょうがないね！C#でもToObservableで変換かけたものの速度は割と遅くなるし。構造的に中間にいっぱい処理が入るので、そういうものだということで。</p>
<h2>速度ねえ……</h2>
<p>jLinqはさすがにアレゲなのですが、それ以外は別に普通に使う範囲ではそんな致命的に低速ってわけでもないんで、あまり気にしなくても良くね？と、かなり思ってます。linq.jsは速度を犠牲にして遅延評価だのDisposeだの入れてるわけですが、勿論、犠牲にしたなりのメリットはある（表現できる幅がとっても広がる）し。その辺はトレードオフ。配列をSelectしてToArrayするだけ、とかWhereしてToArrayするだけならば、、どうせjQueryも一緒に使うでしょ？的に考えて、jQueryの$.map, $.grepを使えば精神衛生上良いかもしれません。これは、C#で言うところのArray.ConvertAllは化石メソッドだけど、SelectしてToArrayならばConvertAllのほうが高効率なんだぜ(内心はどうでもいーんだけど)、といったようなノリで補えば良いでしょう。</p>
<p>それにしても、何でjQueryは$.eachの引数がmapやgrepと逆(eachだけindexが第一引数で値が第二引数)なんですかね。これ、統一してたほうが良いし、だいたいがして値が第一引数のほうが使いやすいのに。もう今更変えられない、ということなのかしらん。</p>
<p>そういえばで、せっかくなので「表現できる幅」の例として、ベンチには第一ソートキーにCurrency、それが重複してた場合の第二ソートキーにTotalを指定してみた例(OrderBy.ThenBy)とか（linq.js無しで書くとちょびっと面倒だよ！）、GroupIDでグルーピングした後にTotal値を合計といった集計演算（これもlinq.js無しだと面倒だよ！）とかを入れておいたので、良ければ見といてください。はい。まあ、別にこの辺はeager evaluationでも出来るというかソートもグルーピングも一度バッファに貯めちゃってるんですけどね！</p>
<h2>まとめ</h2>
<p>JSINQは良く出来てると思うのよ。ほんと（私はただのLinqマニアなので、基本的に他の実装は割と読んでますですよ）。ベンチ的にもlinq.jsより速いし(Disposeないからね、でもDispose使うシーンがそもそもあんまないという)、文字列クエリ式も(使わないけど)使えるし。じゃあ、JSINQじゃなくてlinq.jsがイイ！というような押しは、そこまであるかないか、どうなんでしょうね。1.メソッドの数が全然違う 2.ラムダ式的な文字列セレクターが使える 3.Dispose対応 4.RxJSにも対応 5.jQueryにも対応 6.WSHにも対応 7.VS用IntelliSense完備。ふむ、結構ありますね。というわけでlinq.jsお薦め。冒頭でも言いましたが最近のCodePlex上でのページビュー/ダウンロード数を見ると、競合のlinq移植ライブラリの中でもトップなんですよ、えへへ。まあ、4DL/dayとかいうショボい戦いなのですが。</p>
<p>jLinqの人が、パフォーマンス改善のついでにLinqという名前をやめてブランディングやり直すって言ってますが、きっと正しいと思う。「Linq」という名前がつく限りは「.NETの～」という印象が避けられないし、そのせいで敬遠されるというのは、間違いなくある。jLinqは、中身全然Linqじゃない独特な感じのなので、名前変えるのは、きっと良い選択。</p>
<p>linq.jsは100% Linqなので名前がどうこうってのはないですが、しかし、RxJSもそうなのだけど、.NET以外の人にも使って欲しいなって気持ちはとてもあります。やれる限りは頑張ってるつもりなんですが、中々どうして。<a href="http://neue.cc/2010/05/24_260.html">JavaScriptエディタとしてのVisual Studioの使い方入門</a>は100ブクマまであとちょい！な感じで、そういうとこに混ぜて宣伝とかいうセコい策を取ってはいるものの(いや、別にそういうつもりでやったわけでもないですが)色々と難すぃー。海外へも少しは知名度伸ばせたようなのだけど、そこでも基本的には.NET圏のみって雰囲気で、どうしたものかしらん。</p>
<p>つまるところ、そろそろ御託はどうでもいいから、RealWorldな実例出せよって話ですね！</p>
</div>
<h1 data-pagefind-sort="date:2010-08-02" data-pagefind-meta="published:2010-08-02"><a href="https://neue.cc/2010/08/02_270.html">テストを簡単にするほんの少しの拡張メソッド</a></h1>
<ul class="date"><li>2010-08-02</li></ul>
<div class="entry_body"><p>テストドリブンしてますか？私は勿論してません。え……。別に赤が緑になっても嬉しくないし。コード先でテスト後のほうが書きやすくていいなあ。でもそうなると、テスト書かなくなってしまって、溜まるともっと書かなくなってしまっての悪循環。</p>
<p>そんな普段あまりテスト書かないクソッタレな人間なわけですが(レガシーコード殺害ガイドが泣いている)、普段テスト書かないだけに書こうとすると単純なものですらイライライライラしてしまって大変よくない。しかし、それはそもそもテストツールが悪いんじゃね？という気だってする。言い訳じゃなく、ふつーにバッチイですよ、テストコード。こんなの書くのはそりゃ苦痛ってものです。</p>
<h2>Before</h2>
<p>例えば、こういうどうでもいいクラスがあったとします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MyClass
{
    public string GetString(string unya)
    {
        return (unya == &quot;unya&quot;) ? null : &quot;hoge&quot;;
    }
    public IEnumerable&lt;int&gt; GetEnumerable()
    {
        yield return 1;
        yield return 2;
        yield return 3;
    }
}
</code></pre>
<p>ウィザードで生成されたのをベースに書くとこうなる(MSTestを使っています)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod()] 
public void GetStringTest() 
{ 
    MyClass target = new MyClass(); 
    string unya = &quot;unya&quot;; 
    string expected = null; 
    string actual; 
    actual = target.GetString(unya); 
    Assert.AreEqual(expected, actual); 

    expected = &quot;hoge&quot;; 
    actual = target.GetString(&quot;aaaaa&quot;); 
    Assert.AreEqual(expected, actual); 
} 

[TestMethod()] 
public void GetEnumerableTest() 
{ 
    MyClass target = new MyClass(); 
    IEnumerable&lt;int&gt; expected = new[] { 1, 2, 3 }; 
    IEnumerable&lt;int&gt; actual; 
    actual = target.GetEnumerable(); 
    CollectionAssert.AreEqual(expected.ToArray(), actual.ToArray()); 
}
</code></pre>
<p>何だこりゃ。超面倒くさい。むしろテストがレガシーすぎて死にたい。CollectionAssertはIEnumerableに対応してないし。泣きたい。こんなの書いてられない。吐き気がする。</p>
<h2>After</h2>
<p>JavaScriptのQUnitは、大抵EqualとDeepEqualで済む簡単さで、それがテストへの面倒くささを大いに下げてる。見習いたい。シンプルイズベスト。ごてごてしたAssert関数なんて悪しき伝統にすぎないのではなかろうか？と思ったので、もうアサート関数なんてIsだけでいいぢゃん、ついでにactualの後ろに拡張メソッドでそのままexpected書けると楽ぢゃん、と開き直ることにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[TestMethod()]
public void GetStringTest()
{
    // 1. 全オブジェクトに対して拡張メソッドIsが定義されててAssert.AreEqualされる
    // 2. ラムダ式も使えるので、andやorや複雑な比較などはラムダ式でまかなえる
    // 3. nullはIs()で（本当はIs(null)でやりたかったのだけど、都合上断念)
    new MyClass().GetString(&quot;aaaaa&quot;).Is(&quot;hoge&quot;);
    new MyClass().GetString(&quot;aaaaa&quot;).Is(s =&gt; s.StartsWith(&quot;h&quot;) &amp;&amp; s.EndsWith(&quot;e&quot;));
    new MyClass().GetString(&quot;unya&quot;).Is();
}

[TestMethod()]
public void GetEnumerableTest()
{
    // 対象がIEnumerableの場合はCollectionAssert.Equalsで比較されます
    // 可変長配列を受け入れることが出来るので直書き可
    new MyClass().GetEnumerable().Is(1, 2, 3);
}
</code></pre>
<p>すんごく、すっきり。メソッドはIsだけ、ですがそれなりのオーバーロードが仕込まれているので、ほとんどのことが一つだけで表現出来ます。IsNullはIs()でいいし（表現的には分かりにくくて嫌なのですが、Is(null)だとオーバーロードの解決ができなくてIs((型)null)と書かなくて面倒くさいので、泣く泣く引数無しをIsNullとしました）し、IsTrueはIs(true)でいい。複雑な条件で比較したいときはラムダ式を渡せばいい。Is.EqualTo().Within().And() とか、全然分かりやすくないよね。流れるようなインターフェイスは悪くないけれど、別に自然言語的である必要なんて全然なくて、ラムダ一発で済ませられるならそちらのほうがずっと良い。<a href="http://sharptestex.codeplex.com/">.Should().Not.Be.Null()</a>なんてまで来ると、もう馬鹿かと思った。</p>
<p>大事なのはシンプルに気持良く書けることであって、形式主義に陥っちゃいけないのさあ。</p>
<p>コレクション比較もIsだけですませます。IEnumerableを渡すことも出来るし、可変長引数による値の直書きも出来る。なお、Isのみなのでコレクション同士の参照比較はありません。コレクションだったら有無をいわさず要素比較にします。だって、別に参照比較したいシーンなんてほとんどないでしょ？そういう例外的な状況は素直にAssert.AreEqual使えばいい。また、CollectionAssertには色々なメソッドがありますが、それ全部Linqで前処理すればいいよね？例えばCollectionAsert.IsEmptyはAny().Is(false)で済ませられるので不要。他のも大体はLinqで何とかできるので大概不要です。</p>
<p>ところで、このぐらいだとウィザードが冗長というだけで</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Assert.AreEqual(new MyClass().GetString(&quot;aaaaa&quot;), &quot;hoge&quot;);
</code></pre>
<p>って書けるじゃないかって突っ込みは、そのとおり。でも、少し長くなると、引数に押し込めるの大変になってきますよね。そうなると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var expected = &quot;hoge&quot;;
var actual = new MyClass().GetString(&quot;aaaaa&quot;)
Assert.AreEqual(expected, actual);
</code></pre>
<p>といった具合に、変数名が必要になって大変かったるい。ので、余計な一時変数なしで流し込める方が圧倒的に楽です。そもそもに、Assert.AreEqualだと、毎回どっちがactualでどっちがexpectedだか悩むのがイライラしてしまって良くない。まあ、逆でもいいんですが。よくないんですが。</p>
<h2>パラメータ違いのテストケース</h2>
<p>ついでに面倒くさいのは、パラメータが違うだけにすぎない、同じようなAssertの量産。テストなんてとっとと書いてナンボなので大体コピペで取り回しちゃうわけですが、どう考えてもクソ対応です本当にありがとうございました。そういうことやると、テストの書き直しが出来なくなって身重になってしまって良くない。コードはサクッと書き直せるべきだし、テストもサクッと書き直せるべきだ。といったわけで、NUnitには属性を足すだけでパラメータ違いのテストを実行出来るそうですがMSTestにはなさそう。うーん、でも、Linqがあれば何でも出来るよ？Linq万能神理論。ということで、Linqをベースにしてパラメータ違いを渡せるクラスを書いてみました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// コレクション初期化子を使ってパラメータを生成します
new Test.Case&lt;int, int, int&gt;
{
    {1, 2, 3},
    {100, 200, 500},
    {10000, 20, 30}
}
.Select(t =&gt; t.Item1 + t.Item2 + t.Item3)
.Is(6, 800, 10050);
</code></pre>
<p>複数の値はTupleに突っ込めばいい。あとはSelectでactualを作って、最後にIsの可変長引数使って期待値と比較させれば出来上がり。Tupleは、C#には匿名型があるため、あまり活用のシーンがないのですが、こういうところでは便利。このTest.Caseは7引数のTupleまで対応しています(それ以上？そもそも標準のTupleの限界がそれまでなので)。使い方はnewしてコレクション初期化子でパラメータを並べるだけ。</p>
<p>つまるところTest.CaseクラスはただのTupleCollectionです。Tupleの配列を作るには、普通だと new[]{Tuple.Create, Tuple.Create...} と書かなければならず、死ぬほど面倒。そこで出てくるのがコレクション初期化子。これなら複数引数を受け入れるのが楽に記述できる。というわけで、コレクション初期化子を使いたいがためだけに、クラスを立てました。唯一の難点はnewしなければならない、つまりジェネリクスの型引数を書かなければならない、ということでしょうか。</p>
<p>そうそう、コレクション初期化子のおさらいをすると、IEnumerable&lt;T&gt;かつAddメソッド(名前で決め打ちされてる)があると呼び出せます。複数引数時も、波括弧で要素をくくることで対応できます(Dictionaryなどで使えるね)。</p>
<h2>ソースコード</h2>
<p>長々と長々してましたがソースを。Test.CaseのTupleの量産が面倒なのでT4 Templateにしました。Test.ttとかって名前にしてテストプロジェクトに突っ込んでください。中は完全に固定だから、取り回すなら生成後のTest.csを使っていくと良いかもですね。ご利用はご自由にどうぞ。パブリックドメインで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ assembly Name=&quot;System.Core.dll&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Microsoft.VisualStudio.TestTools.UnitTesting
{
    public static class Test
    {
        // extensions

        /// &lt;summary&gt;IsNull&lt;/summary&gt;
        public static void Is&lt;T&gt;(this T value)
        {
            Assert.IsNull(value);
        }

        public static void Is&lt;T&gt;(this T actual, T expected, string message = &quot;&quot;)
        {
            Assert.AreEqual(expected, actual, message);
        }

        public static void Is&lt;T&gt;(this T actual, Func&lt;T, bool&gt; expected, string message = &quot;&quot;)
        {
            Assert.IsTrue(expected(actual), message);
        }

        public static void Is&lt;T&gt;(this IEnumerable&lt;T&gt; actual, IEnumerable&lt;T&gt; expected, string message = &quot;&quot;)
        {
            CollectionAssert.AreEqual(expected.ToArray(), actual.ToArray(), message);
        }

        public static void Is&lt;T&gt;(this IEnumerable&lt;T&gt; actual, params T[] expected)
        {
            Is(actual, expected.AsEnumerable());
        }

        public static void Is&lt;T&gt;(this IEnumerable&lt;T&gt; actual, IEnumerable&lt;Func&lt;T, bool&gt;&gt; expected)
        {
            var count = 0;
            foreach (var cond in actual.Zip(expected, (v, pred) =&gt; pred(v)))
            {
                Assert.IsTrue(cond, &quot;Index = &quot; + count++);
            }
        }

        public static void Is&lt;T&gt;(this IEnumerable&lt;T&gt; actual, params Func&lt;T, bool&gt;[] expected)
        {
            Is(actual, expected.AsEnumerable());
        }

        // generator

&lt;#
for(var i = 1; i &lt; 8; i++)
{
#&gt;

        public class Case&lt;#= MakeT(i) #&gt; : IEnumerable&lt;Tuple&lt;#= MakeT(i) #&gt;&gt;
        {
            List&lt;Tuple&lt;#= MakeT(i) #&gt;&gt; tuples = new List&lt;Tuple&lt;#= MakeT(i) #&gt;&gt;();
 
            public void Add(&lt;#= MakeArgs(i) #&gt;)
            {
                tuples.Add(Tuple.Create(&lt;#= MakeParams(i) #&gt;));
            }
 
            public IEnumerator&lt;Tuple&lt;#= MakeT(i) #&gt;&gt; GetEnumerator() { return tuples.GetEnumerator(); }
            IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }
        }
&lt;#
}
#&gt;
    }
}
&lt;#+
     string MakeT(int count)
     {
          return &quot;&lt;&quot; + String.Join(&quot;, &quot;, Enumerable.Range(1, count).Select(i =&gt; &quot;T&quot; + i)) + &quot;&gt;&quot;;
     }

     string MakeArgs(int count)
     {
          return String.Join(&quot;, &quot;, Enumerable.Range(1, count).Select(i =&gt; &quot;T&quot; + i + &quot; item&quot; + i));
     }

     string MakeParams(int count)
     {
          return String.Join(&quot;, &quot;, Enumerable.Range(1, count).Select(i =&gt; &quot;item&quot; + i));
     }
#&gt;
</code></pre>
<p>オプション引数のお陰で、こういうちょっとしたのが書くの楽になりましたね(C#4.0 からの新機能)。あとは、可変長引数が配列だけじゃなくてIEnumerableも受け付けてくれれば、AsEnumerableで渡すだけの余計なオーバーロードを作らないで済むんだよね。C# 5.0に期待しますか。</p>
<h2>まとめ</h2>
<p>テストのないコードはレガシーコード。と、名著が言ってる(1/4ぐらいしかまだ読んでませんが！)のでテストは書いたほうがいいっす。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as1&m=amazon&f=ifr&md=1X69VDGQCMF7Z30FM082&asins=4798116831" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>でも、コード書きってのは気持良くなければならない。気持ち良ければ自然に書くんです。書かない、抵抗感があるってのは、環境が悪いんです。「テスト書きは苦痛だけど良いことだから、赤が緑に変わると嬉しいから書こうぜ！」とかありえない。そんな自己啓発っぽいのは無理。というわけで、拡張メソッドで環境を変えて、気持よく生きましょうー。</p>
<p>JsUnit（非常にイマイチ）もそうだったんだけど、Java由来(xUnitはSmalltalkのー、とかって話は分かってます）のライブラリとかは、Java的な思考に引き摺られすぎ。もっと言語に合わせたしなやかなAPIってものがあると思うんですよね。MSTestはVS2010で、色々刷新してLinqや拡張メソッドを生かしたものを用意すべきだったと思います。C#2.0的なコードは読むのも書くのも、もう苦痛。レガシーコードとは何か？C#2.0的なコードです。いやほんと。生理的な問題で。</p>
<h2>追記</h2>
<p>ここで例として出したものを、より洗練させてライブラリとしてまとめました。<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion for MSTest">Chaining Assertion for MSTest</a> よければこちらもどうぞ。</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
