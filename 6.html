<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2016/05/23_530.html">MarkdownGenerator - C#におけるAPI Reference生成のためのドキュメントツール</a></h1>
<ul class="date"><li>2016-05-23</li></ul>
<div class="entry_body"><p>APIリファレンス作りたい？<a href="https://github.com/EWSoftware/SHFB">Sandcastle</a>。以上。終了。あるいは<a href="https://github.com/dotnet/docfx">dotnet/docfx</a>が良いのではないでしょうか。こいつはdotnet配下にあるように、MSの今後のOSS系のはこれでドキュメント生成されていく可能性があります。</p>
<p>というのは置いといて、私的には実のところ、あんまり重要視していませんでした、ドキュメントツール。.chmにはいい思い出がなくて、というか別に見ないじゃん？htmlで出力してもなー、なんかゴチャゴチャしてて汚いしなー。一方でJavaScriptなんかは様々な格好良くフォーマットされた形式で色々出てるのであった。いいじゃん。いいね。</p>
<p>さて、もう一つ。HTMLで出力しても置き場にこまる。GitHub Pagesにはそんないい思い出がない。別にあんなところをフロントにするよりもリポジトリのアドレス直のほうが断然いいじゃん、みたいな。というわけでアレだ、GitHub Wikiだ。あそこをゴミ置き場にすればいいんだ。という発想で、まずUniRxのリファレンスをGitHub Wikiに置いてみました。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx/wiki">UniRx/Wiki</a></li>
</ul>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/15460956/9b897c32-20f1-11e6-8520-c31b0035dd01.png" />
</p>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/15460939/73c76088-20f1-11e6-8fb7-a483383ab9a1.png" />
</p>
<p>UniRxは、namespaceを意図的にある程度平ったくしてるので、ちょっとごちゃってますが、まぁまぁいいんじゃない？それなりに見れる。悪くはない。少なくともないよりは100億倍良い。</p>
<p>私的にはIntelliSenseがドキュメントだ！みたいな意識がそれなりにあって、最初のチュートリアルみたいなドキュメントがあったら、あとはそれを手がかりにあとはIntelliSenseでなんとかしようぜ、的なところが。実際<a href="https://github.com/dotnet/roslyn">Roslyn</a>なんかはそんな感じがする。Getting Startedはそれなりに厚い、けど全貌からは程遠い。でもAPIドキュメントはない。さあ、IntelliSenseで宝探しだ。って。肯定もしないけれど否定もしない、そういうのも今風よね。でも、まあこの程度のAPIリファレンスでも生成してやると、それはそれで良いな、って思ったのだ。です。</p>
<h2>MarkdownGenerator</h2>
<p>生成は自家製こんそーるあぷりで行ってます。というわけで公開しました。</p>
<ul>
<li><a href="https://github.com/neuecc/MarkdownGenerator">MarkdownGenerator</a></li>
</ul>
<p>dllとxmlを渡すとmdと目次用のHome.mdをばらまくので、GitHub Wikiに投げ込みます。そう、GitHub Wikiはご存じの方も多い通り、それ自体がgitで管理されててCloneできるのです。さいこー。というわけでそのままPushするだけ。Good。完璧。これなら、CIなんかでフックして毎回生成して投げ飛ばしてあげてもいい。よね。</p>
<p>生成結果のStyleはちょっとまだまだ試行錯誤中。まあでも割とこんなもんでいいんちゃうんちゃうん？ユースケースの9割ぐらいはカバーできているでしょう。それ以上はノイズということで。</p>
<h2>その他ツール</h2>
<p>Sandcastleはそもそも出力をカスタマイズできるので、もう少し真面目というかガッチリしたものが必要ならば、<a href="https://github.com/maxtoroq/sandcastle-md">maxtoroq/sandcastle-md</a>あたりを使ってMarkdownを出力してやると良いでしょう。これなら、きっちりとSandcastleで出力される情報が全部そのまま入ってるので、ちゃんとしてる感は圧倒的に高いです。また、繰り返しますけれど<a href="https://github.com/dotnet/docfx">DocFX</a>は今からやるなら最有力候補な気がします。DLLからじゃなくてRoslynでプロジェクトファイルから解析したりとか今風。あくまでstatic file generatorなのでmdじゃなくてhtml出力なので、Wikiに投げ飛ばす用途には向かないのと、ちょっと複雑、使いこなすのは難しい、かな、まあ相応には良さそうかとは。</p>
<p>MarkdownGeneratorは、ちゃんとしてないなりに、私的に重要視してる情報がパッと一覧で見やすくする、ということを重視しているので……。あと、なんかSandcastle使いたくないんだよねー、心理的に。なんだろうね、レガシー臭するからなのかな。食わず嫌いなだけって話でもあるのだけれど。</p>
<p>何れにせよ、GitHubであってもなくてもいいだろうけれど、API Referenceを投げ飛ばす場としては、そういうところ（どういうところ？）がいいですね。独立してるよりもリポジトリに近い場所のほうが素敵度は高い。気がする。あとはなんのかんのでGitHubに慣れきってるというのもあって、GitHubにあると情報がスムースに受け取れる気がするんだよね。これもなんでだろうね。でもそういうのってあるよね。</p>
</div>
<h1><a href="https://neue.cc/2016/05/14_529.html">Unityにおけるコルーチンの省メモリと高速化について、或いはUniRx 5.3.0でのその反映</a></h1>
<ul class="date"><li>2016-05-14</li></ul>
<div class="entry_body"><p>UniRx 5.3.0をリリースしました！今回のアップデートは、内部的な最適化、です。最適化は、もうそろそろあんまやるところ残ってないよね、なんて思ってたんですが、じっくり考えるとそんなことなく割とあったので埋めました。それが表題のコルーチンの省メモリと高速化です。使い方次第ではありますが、場合によっては今回のアップデートでものすごく恩恵に授かる人もいればそこそこの人もいるかもです。ともあれ基本的に内部的に変更してるだけなので、入れるだけでそれなりに高速化したりする可能性がそれなりにあります。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub/UniRx</a></li>
<li><a href="https://www.assetstore.unity3d.com/jp/#!/content/17276">AssetStore/UniRx</a></li>
</ul>
<p>前回が2月だったので3ヶ月ぶりですね。あまりオペレータ追加がないので、次はオペレータ追加に集中したい気もする。なんか優先的に欲しいのあればリクエストもどうぞ(Observable.Windowとかいい加減そろそろ入れろよって話なんですが）</p>
<h2>MicroCoroutine</h2>
<p>今回の大きい変化はMicroCoroutine(と、自称してる)の導入です。特に大量にEveryUpdateやEveryValueChangedを呼んでるシチュエーションにおいて10倍、というのは場合によりで大雑把なのですが、相当速くなります。</p>
<pre><code class="language-csharp">void Start()
{
    // Start 10000 Coroutines
    for (int i = 0; i &lt; 10000; i++)
    {
        // Standard Unity Coroutine
        // StartCoroutine(Counter());

        // Use UniRx 5.3 - MicroCoroutine
        MainThreadDispatcher
          .StartUpdateMicroCoroutine(Counter());
    }
}

IEnumerator Counter()
{
    while (true)
    {
        count++;
        yield return null;
    }
}
</code></pre>
<p>こんな10000個、単純なコルーチンを起動するコードがあったとして</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15267997/86e9ed5c-1a0c-11e6-8371-14b61a09c72c.png" alt="image" /></p>
<p>大きく違いがでます。ちょっと恣意的すぎではあるんですが、UniRxはコルーチンを簡単にかけるが故に、これに近いシチュエーションってのが意図せず起こりがちではありました。また、Resources.LoadAsyncなど非同期系APIからの取得に関しても、一時的に多くのコルーチンを起動するシチュエーションはあり得るのではないでしょうか。</p>
<p>性能改善した理由は、基本的にはUnityの公式ブログ<a href="http://blogs.unity3d.com/jp/2015/12/23/1k-update-calls/">UPDATE()を10000回呼ぶ</a>で紹介されていることの話で、10000個のUpdateは遅くて、配列に詰めて直接ループで呼ぼうぜ、と。どうせUpdate内のメソッドは呼ばれてC#の領域で実行されるんだから、マネージド(C#)-アンマネージド(C++)の繋ぎのレイヤーは純粋にオーバーヘッドになってくるよ、と。なるほどそうだねそりゃそうだねぇ。それはStartCoroutineにも言えて、というかコルーチンのほうがもっと性能劣化度が大きいんですよね。</p>
<p>この記事は非常に素晴らしくて、大量にモノ出して速度遅くなってるのがスクリプト起因なら、マネージャー立ててまとめて、あとUpdateに限らずマネージド-アンマネージドの繋ぎをやってる部分が遅いだろうからそこを適切に取り除ける限り除けば、全然まだまだそれなりに捌ける余裕は残ってるぜ。ということで、むしろ希望に満ちていていい感じです。実際、ハイパフォーマンスを謳うDOTweeenとかのライブラリもそんな感じですね、動かすものそれぞれにUpdateするコンポーネントを挿したりはしない、中央管理で動かすのだ、と。</p>
<p>さて、UniRxでは幾つかのメソッドはコルーチン依存でループを回しています。Observable.EveryUpdateとかEveryValueChangedとか。少しに使う分にはいいんですが、気楽に使えるが故に、大量に使うと、10000個とまではいかなくてもやっぱり、それぞれがコルーチンを起動することによるマネージド-アンマネージドオーバーヘッドがそのまま乗っかってきてしまいます。というわけで、やはりコルーチン自前管理の道を進むしかない……。幸い、自前管理で問題になる機能面での低下に関しては、UniRx自体がコルーチンを凌ぐだけの機能を提供しているので、気にしないでよし。というわけで純粋にいかにコルーチン(IEnumerator)を高速に回転させ、高速にメンテナンスするかにだけ集中すればよし。</p>
<p>回転させるのはforループ回すだけの話なんですが、マネージャー作ろうぜ、となった時に、Listに詰めるのはいいんですが、面倒くさいのは削除。削除は要注意で、単純にListのRemoveやって済ませたりするのは結構アレです(Removeは相当高コストな操作です)。かといってDictionaryやSet、LinkedListでやるなんていうのは論外で（列挙の性能が死ぬので本末転倒）、基本的に配列で頑張るべきなんですが、さてはて。結局、その辺のめんどーを見るのがめんどーだからUpdateやStartCoroutineでぶん回すのだ。割と本気で。</p>
<p>ではどうしたか、というと、UniRxのMicroCoroutineのアプローチはRemoveしない。です。しない。空いた部分はnullで埋めて純粋にスキップするだけにする。多少の空きなら、いちいち削るよりもスキップさせたほうが速い。しかし、それだけだとブヨブヨと膨らみ続けてしまうので、xフレーム毎に空きスペースに詰めなおして小さくします。縮める際も前の方に整列させるんじゃなくて、空きスペースに対して後ろから埋めるようにするので、順番はグチャグチャになります。その代わり余計な配列へのセットが発生しないので速い。そして膨らんだ配列は放置して膨らんだままにします、終端のインデックスだけ記録して管理するのみ（ところでアセットストアにアップデート申請出してから気づいたのですが、この配列の使い方なら定期的なお掃除じゃなくて、動かしながら埋めるようなコードにするのも可能っぽい感、なので次回アップデートでそうします）</p>
<p>というわけで、UniRxのMicroCoroutineは中央集権的なので多少膨らむことが許される（でしょう！）ことを利用して、とにかく高速にコルーチンを捌く、ということだけに集中してます。ので速い。下手に自前管理するよりも速いかもしれませんし、Updateで監視するよりもObserveEveryValueChangedのほうがむしろ速い、Rxで書いたほうが速い、みたいな逆転現象も全然発生しうるような話になります。</p>
<pre><code class="language-txt">ObserveEveryValueChanged
EveryUpdate 
EveryFixedUpdate
EveryEndOfFrame
NextFrame
TimerFrame 
IntervalFrame
DelayFrame 
SampleFrame
ThrottleFrame
ThrottleFirstFrame
TimeoutFrame
</code></pre>
<p>この辺りのメソッドを使った場合、内部の実装がMicroCoroutineに差し替わったので自動的に恩恵に預かれます。コルーチン -&gt; Observable変換に関しては FromMicroCoroutine が追加されました。基本的にはFromCoroutineと一緒なのですが、MicroCoroutineではyield returnするのはnullだけにしてください、それ以外には対応してません（UnityEditor上ではWarning出して警告します）。MicroCoroutineの制約はそれなんですが、なんだかんだで、8割ぐらいはyield return nullだけで成立するんちゃうんちゃうん、みたいな。賢くやろうとすればもう少しは出来なくもないんですが、シンプルで高速なコルーチンの回転を損ねちゃうのでナシ。IEnuemrator.Currentの呼び出しや、その型チェックすら省きたい。残り2割ぐらいなら普通にStartCoroutineすればいいじゃん、ということで。実際、UniRxの↑のメソッドはそれでかなり置き換えることが出来る、ということを発見できたので、全面的に導入する気になったのです。</p>
<p>また、最悪待ちたい場合は、isDoneのループを回すようにToYieldInstruction経由でIObservableを待てるので、大抵のことはなんでもできます。</p>
<pre><code class="language-csharp">IEnumerator MicroCoroutineWithToYieldInstruction()
{
    var www = ObservableWWW.Get(&quot;http://aaa&quot;).ToYieldInstruction();
    while (!(www.HasResult || www.IsCanceled || www.HasError)) // 3つもプロパティ並べるのダルいので次回アップデートでIsDoneを追加します予定
    {
        yield return null;
    }

    if (www.HasResult)
    {
        UnityEngine.Debug.Log(www.Result);
    }
}
</code></pre>
<p>もっとプリミティブに直接利用したい場合は、StartCoroutineの代わりにMainThreadDispatcherに3つ生やしてあります。</p>
<pre><code class="language-txt">MainThreadDispatcher.StartUpdateMicroCoroutine
MainThreadDispatcher.StartFixedUpdateMicroCoroutine
MainThreadDispatcher.StartEndOfFrameMicroCoroutine
</code></pre>
<p>それぞれがコルーチンを消費するタイミングで、まぁ普通はStartUpdateMicroCoroutineを使えばよいでしょふ。もし大量のStartCoroutineがプログラム中にあるのなら、これに差し替えるだけで本当にすっごく速くなるでしょう。ほんと。</p>
<h2>SubscribeWithState</h2>
<p>ここから先はUniRxのアップデートの話だけ。そして本当にMicro Micro Microな最適化であんま意味はないんですが、まず、SubcribeWithStateを追加しました。これによって何が変わるか、というと、例えば……</p>
<pre><code class="language-csharp">// Before
public static IDisposable SubscribeToText(this IObservable&lt;string&gt; source, Text text)
{
    return source.Subscribe(x =&gt; text.text = x);
}

// After
public static IDisposable SubscribeToText(this IObservable&lt;string&gt; source, Text text)
{
    return source.SubscribeWithState(text, (x, t) =&gt; t.text = x);
}
</code></pre>
<p>という感じの使い方ができます。どういう違いが出るのかというと、以前に<a href="http://neue.cc/2016/01/06_525.html">Unityでのボクシングの殺し方、或いはラムダ式における見えないnewの見極め方</a>という記事の中で説明したのですが、ラムダ式はその中身によってコンパイル時に生成されるコードがかなり変わってきます。で、最速なのはそのメソッド内だけで完結していて外部の変数等には一切触っていない状態。onNextはActionなので、副作用かける際にどうしても外部変数をキャプチャしてしまうことが多いんですよね。そこでSubscribeWithStateを使うと、必要な変数を閉じ込めることができるので最速ゴミなしの形で記述できます。</p>
<p>ただまぁ、これやると、じゃあSelectやWhereなんかもState取れたほうがいいんですか？（理屈上はそうです）、とか、ああクロージャ殺さなきゃ死ね死ね死ね、とか思ったりしそうなのですけれど、Subscribeの回数ってパイプライン内の実行頻度に比べれば圧倒的に少なくなるはずなんですよね。だから全体のバランスで見たら無視できるといっても過言ではないはず、特にクロージャでちょっとゴミが出る程度の話は。</p>
<p>なのであんま神経質にやることはないんですが、↑のSubscribeToTextのようなそんな手間もかからないし、UIとかシーンの初期化時にいっぱい登録される可能性があるようなものでライブラリ的な部分でカバーできる質のものならば、少しだけ気を使ってあげると気は安らぐかもしれません。</p>
<h2>ReactiveCommand</h2>
<p>ReactiveCommandは.NET版のReactiveProeprtyにあった、最後のパーツなんですが、どうなんでしょうね、本来はViewModelのレイヤーのためなんですが、UnityだとPresenterにUI要素がセリ出してきてるのでイマイチベンリかどうか分からなくて入れてなかったんですが。一応、こんな風に使えます。</p>
<pre><code class="language-csharp">public class Player
{
   public ReactiveProperty&lt;int&gt; Hp;
   public ReactiveCommand Resurrect;

   public Player()
   {
        Hp = new ReactiveProperty&lt;int&gt;(1000);

        // If dead, can not execute.
        Resurrect = Hp.Select(x =&gt; x &lt;= 0).ToReactiveCommand();
        // Execute when clicked
        Resurrect.Subscribe(_ =&gt;
        {
             Hp.Value = 1000;
        }); 
    }
}

public class Presenter
{
    public Button resurrectButton;

    Player player;

    void Start()
    {
      player = new Player();

      // If Hp &lt;= 0, can't press button.
      player.Resurrect.BindTo(resurrectButton);
    }
}
</code></pre>
<p>buttonのinteractableとonClickが抽象化されたもの、って感じですね。</p>
<h2>その他</h2>
<p>リリースノートから。</p>
<pre><code class="language-txt">Add : ReactiveCommand
Add : MainThreadDispatcher.StartUpdateMicroCoroutine, StartFixedUpdateMicroCoroutine, StartEndOfFrameMicroCoroutine
Add : Scheduler.MainThreadFixedUpdate, MainThreadEndOfFrame
Add : ToYieldInstruction(cancellationToken)
Add : Observer.Create(onNext/onNext, onError/onNext, onCompleted) overload
Add : IReadOnlyReactiveProperty.SkipLatestValueOnSubscribe
Add : Observable.WhenAll overload (IObservable&lt;Unit&gt;(params IObservable&lt;Unit&gt;[] sources), this becomes breaking changes)
Add : Observable.FromMicroCoroutine
Add : Observable.AsSingleUnitObservable
Add : Observable.SubscribeWithState
Add : Observable.CreateWithState
Add : Disposable.CreateWithState
Improvement : Use MicroCoroutine on `ObserveEveryValueChanged`, `EveryUpdate`, `EveryFixedUpdate`, `EveryEndOfFrame`, `NextFrame`, `TimerFrame`, `IntervalFrame`, `DelayFrame`, `SampleFrame`, `ThrottleFrame`, `ThrottleFirstFrame`, `TimeoutFrame`
Improvement : Performance improvement for Observable.Range, Repeat when scheduler is Scheduler.Immediate
Improvement : Use Time.unscaledDeltaTime in IgnoreTimeScaleMainThreadScheduler
Fix : ReadOnlyReactiveProperty(source, initialValue) does not publish initial value on subscribe
Fix : IReadOnlyCollection has set indexer
Fix : Ambigious property of IReactiveCollection.Count, Indexer
Fix : Throw invalid error when ObservableWWW.LoadFromCacheOrDownload failed.
Breaking Changes : Added IReadOnlyReactiveProperty.HasValue
Breaking Changes : AsyncConvertsion scheduler to Scheduler.MainThread on WebGL build(WebGL doesn't support ThreadPool)
Other : Update UniRxAnalyzer 1.4.0.1 https://www.nuget.org/packages/UniRxAnalyzer
</code></pre>
<p>ToYieldInstructionは<a href="http://neue.cc/2015/12/21_523.html">UniRx 5.0 - 完全書き直しによるパフォーマンス向上とヒューマンリーダブルなスタックトレース生成</a>で説明しているのですが、Unity 5.3以降のCustomYieldInstuctionを応用したもので、IObservableをコルーチンで処理できるようにするやつで、結構お薦め機能です。MicroCoroutineで回すための補助にもなりますし。</p>
<p>SchedulerにMainThreadFixedUpdateとMainThreadEndOfFrameを足しました。ObserveOnやTimerなどで、その辺の細かい制動をしたい方にどうぞ。</p>
<p>(ReadOnly)ReactivePropertyへのSkipLatestValueOnSubscribe拡張メソッドの追加。これは、(UniRxの)ReactivePropertyはSubscribe時に必ず値をプッシュするようになってるんですが、そういった初期値を無視したいって局面は少なからずあるんですよね。Rx.NET用のReactivePropertyでは、コンストラクタでReactiveProeprtyModeとして、None | RaiseLatestValueOnSubscribe | DistinctUntilChanged を指定できるようなデザインを選んでいるのですが（というのも、Viewにデータバインディングするため構築時の初期値はnullであることが確定している、というシチュエーションが割とあるため）、UniRxのReactivePropertyではSubscribe側が選ぶというデザインにしています。この辺はフレームワークの性質の違いに合わせてるのですが、ともあれ、初期値を無視したい場合は rxProp.SkipLatestValueOnSubscribe().Subscribe() としてもらえれば。</p>
<p>Observable.WhenAllを、IObservable[Unit][]が相手の場合はIObservable[Unit]を返すようにしました。これは、別にUnit[]が返されても何の意味もないからというのと、それによって余計な配列確保をしないという最適化も入れています。この方が絶対に良いんですが、しかし戻り値の型が変わってしまったので破壊的変更にはなっています。最初から気づいておけば良かったですね、すびばせん。</p>
<p>AsSingleUnitObservableは LastOrDefault().AsUnitObservable() みたいな変換をかけるやつで、Async的な保証をかけるのにベンリというあれそれ。</p>
<p>あとは、んー、使ってる人は、<a href="http://grani.jp/">うちの社内</a>以外にないのでは疑惑も感じてますが、UniRxAnalyzerを更新してます。コンストラクタにIObservableを突っ込んでいた場合に誤検出していたのを修正しています。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/VSAnalyzer.jpg" alt="" /></p>
<p>これ、Visual Studio 2015を使って開発している人は絶対に入れたほうがいいですよ！Subscribe忘れて発火しないのに気づかなかったー、みたいなポカミスが圧倒的に防げますので。</p>
<h2>まとめ</h2>
<p>性能面でより気にせずにカジュアルに色々使えるようになった、というのはいいことかなー。性能面で問題出た際に「そういう使いかた想定してないから」といった却下の仕方って、あんましたくないですからね。聞いてていいものでは全くない。デザインとしてカジュアルに使えるようになっているなら、性能もちゃんと担保していかないし、そういうのが頻発するならライブラリの設計が悪い。と、思ってるので、今回のでよりちゃんと自然に使えるようになったかな、と。ObserveEveryValueChangedは個人的には最高にクールな機能だと思ってるので、気兼ねなく使って欲しいし、やっと本当に気兼ねなく使えるようになりました。</p>
<p>ObservableUpdateTrigger(UpdateAsObservable), Observable.EveryUpdate, Observable.EveryGameObjectUpdate とUpdateのハンドリングも3択、性能特性も三者三様。混乱との対話！別に特に何をレコメンドすることもなく、まあ素直に書くならUpdateTriggerが素直でよく。自身のUpdateループで周りますしね。EveryUpdateはMicroCoroutineなので性能特性的には良さげ、どうせAddTo(this)するならループのライフサイクルもUpdateTriggerと別に変わりはしないし(UpdateTriggerだとDisableでUpdateが回らなくなるので、まぁその辺で挙動に違いは出る)。EveryGameObjectUpdateはMainThreadDispatcherのSubjectに積まれるもので、UpdateTriggerが使える状況なら非推奨かな、あんまりSubjectに頻繁にAdd, Removeするのは性能特性的に悪手なので。UpdateTriggerもSubjectが駆動するのですが、性質的にグローバルじゃないのでAdd, Removeは局所化されるからそこまででは、に通常はなるでしょう、的な。</p>
<p>そんなこんなで、少なくともRxが性能面のネックでー、と言われるのは悔しい話なので、大きいものから小さいものまで、最適化ネタは常に考えてます。利用事例としても、結構ヒットしてる某社の某ゲーム（とは）や最近でた前作に続いてヒットの予感のする某ゲーム（とは）など、かなり使いこなしてる事例もあって（個人的にはとても感動した！）、ちゃんと実用的といってもいいレベルになってると思われます。弊社の開発中タイトルである<a href="https://kuro-kishi.jp/">黒騎士と白の魔王</a>でもガッツリ使っているので、ご興味ある方は<a href="http://grani.jp/recruit">中途採用</a>は絶賛募集中です:) 当たり前ですがドッグフーディングは凄く大事で、さすがにデカいバグは出てこないにしても軽微なものはちょいちょい上がってくるので、日々、堅牢さは担保されているな、とかかんとか。あと、使いすぎてるほどに使いすぎてるので、常に性能面でネックになってはいけない、性能面でネックになってはいけない、とマントラを唱えるプレッシャーになってるのもいいことです、多分きっと。</p>
<p>今回のアップデートでツメが甘かった案件としてはAsyncOperation.AsObservableやObservableWWWが内部的にまだFromCoroutine利用なので、FromMicroCoroutineに可能なら差し替えようかな、と。効果のほどとしては、やっぱり場合によりけりですが、初期化とかで大量に回る時は大きく変わるかも。しれない。ともあれ次回アップデートにご期待を。ただyield return wwwやasyncOperationした場合とyield return nullでisDoneチェックする場合とで、戻ってくるタイミングが異なるので、そこのルールを統一させないとかなあ。</p>
</div>
<h1><a href="https://neue.cc/2016/04/01_528.html">Microsoft MVP for Visual Studio and Development Technologies(C#)を再々々々々受賞しました</a></h1>
<ul class="date"><li>2016-04-01</li></ul>
<div class="entry_body"><p>今年の受賞で、6年目です。エキスパタイズとしてはVisual Studio and Development Technologiesという微妙な感じなので、C#です。C#です、と言わせてください。</p>
<p>春はあけぼの、というわけで会社も新たなステージに入りました。原点を振り返りつつも、新たな創業として、より強固な姿を掲示できればいいかな、と思います。</p>
<p>去年に私は</p>
<blockquote>
<p>私が主に力を入れているのはUnityと、そのReactive Extensions実装のUniRxで、特にUniRxはかなりヒットさせられたとは思います。が、まだまだ兆しといったところなので、確固たるものにしなければならない。また、それを基盤にして、C#の強さというのを、ただの今までの.NETコミュニティにだけに留まらず、幅広い世界に届ける、伝えていきたい。</p>
</blockquote>
<p>と言ってましたが、それは達成できました（いやほんと）。しかし、よくよく考えると、なんだか小粒です。今年はもう少し大きなヴィジョンで行きたいですね。最近のMicrosoftのメッセージとしても、C#の強さがより一層際立ってきました。それをしっかりと補強し、力強く、Real World C#というのを示し続けていきます。そう、Real Worldで。どういうことかといえば、そういうことです。今年はね。</p>
<p>引き続き主戦場はC#とUnityです。Unityも.NET Foundation加入やHololensやVRの最有力の開発環境であったりと、変わらず非常に魅力的で、強力な環境ですす。いろいろな形で、刺激的なことを掲示し続けられればいいかな、と思っています。</p>
<p>そんなわけで引き続き、今年もよろしくお願いします。</p>
</div>
<h1><a href="https://neue.cc/2016/03/30_527.html">Roslyn Analyzerでコンフィグを読み込ませて挙動を変更する</a></h1>
<ul class="date"><li>2016-03-30</li></ul>
<div class="entry_body"><p>方法。が、欲すぃ。例えば採番する時に0ベースなのか1ベースなのかプロジェクトによって変えたい。例えばCodeFix時の名前変更のルールを先頭アンスコ付けるのか付けないのかを自由に変えさせたい。<a href="http://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a>の時は、専用のAttributeを使うので、その中のインターフェイスを書き換えてコンフィグ代わりにしてね、という方法を取ったのですが、専用の属性が使えなきゃ適用できない手法で、全然汎用的っぽくないし、当然ながら全然イケてない。</p>
<p>ではどうするか。実は、Additional Filesという仕組みが用意されているので、それを用いることでコンフィグを読みこませることができます！詳細は<a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">roslyn/Using Additional Files.md</a>に書かれていますが、任意のテキストファイルを色々な手法（コマンドラインの引数やcsprojの定義としてなど）でプロジェクトに設定し、Analyzer側では AnalyzerOptions.AdditionalFiles で読めます。</p>
<p>では、やってみましょう。</p>
<pre><code class="language-csharp">[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class AdditionalFileAnalyzer : DiagnosticAnalyzer
{
    static DiagnosticDescriptor Rule = new DiagnosticDescriptor(&quot;AdditionalFileAnalyzer&quot;, &quot;AdditionalFileテスト&quot;, &quot;AdditionalFiles:{0}&quot;, &quot;Usage&quot;, DiagnosticSeverity.Error, isEnabledByDefault: true);
    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSymbolAction(Analyze, SymbolKind.NamedType);
    }

    private static void Analyze(SymbolAnalysisContext context)
    {
        // AnalyzerOptionsにAdditionalFilesがある。
        // CodeFixContextの場合はProjectに生えてるので、 context.Document.Project.AnalyzerOptions で取得可能。
        var additionalFiles = context.Options.AdditionalFiles;

        // Pathから引っ掛けて取る
        var config = additionalFiles.FirstOrDefault(x =&gt; System.IO.Path.GetFileName(x.Path) == &quot;config.json&quot;);
        if (config != null)
        {
            // GetText().ToString()で文字列が取れるので、あとはJsonConvertでデシリアライズするなりなんなりどうぞご自由に……。
            var text = config.GetText().ToString();
            context.ReportDiagnostic(Diagnostic.Create(Rule, context.Symbol.Locations[0], text));
        }
        else
        {
            context.ReportDiagnostic(Diagnostic.Create(Rule, context.Symbol.Locations[0], &quot;JSONが見つかってないぞ&quot;));
        }
    }
}
</code></pre>
<p>これでJSONが見つかってないぞ、と怒られまくります。ファイルを追加するには、まずプロジェクトの適当なところにconfig.jsonを足して、Build Actionを AdditionalFiles に変更します。が、変更しようとするとやっぱり怒られるので、しょうがないからcsprojを手動で書き換えます。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;AdditionalFiles Include=&quot;config.json&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>これで、以下の様な結果が得られます。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/14132223/6463302e-f67e-11e5-8b98-3645b82bf4fd.png" alt="image" /></p>
<p>うん、ちゃんと読めてる！</p>
<p>コンフィグとして使うには、まぁイマドキのJSONでコンフィグだったらJSON.NETでJsonConvert.DeserializeObjectなんかでサクッと復元してやるのが楽でしょう。外部DLL読み込むのが嫌だという場合は、XMLにしてLINQ to XMLやXmlSerializer使うのも全然お手軽でいいとは思います。</p>
<p>コンフィグなんてほぼほぼ固定になるのに毎回デシリアライズ走らせるのは嫌だなあ、って場合はstaticオブジェクトにキャッシュしちゃうのも悪くない手だと思います。その場合は、書き換えた場合はプロジェクト再読み込み（or VS再起動)になってしまいますが、実用的には全然問題ないはず。といいたいのですが、複数のプロジェクト跨ぎで共有されちゃうと厄介だったりするので注意が必要なので、まぁちょっとDeserializeするぐらい大したことねーよということで、毎度Deserializeするのも全然構わないかな、とは。</p>
<p>このコンフィグを読み込む手法は<a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md">StyleCopAnalyzer/Configuration.md</a>でも採用されているし、これがスタンダードのやり方だと思って良さそうです。</p>
</div>
<h1><a href="https://neue.cc/2016/03/21_526.html">SerializableDictionary - Unityで高速に辞書復元するためのライブラリ</a></h1>
<ul class="date"><li>2016-03-21</li></ul>
<div class="entry_body"><p>という、ScriptableObjectとかJsonUtilityとか、そもそもSerializeFieldとかでシリアライズできるDictionaryを作りました。</p>
<ul>
<li><a href="https://github.com/neuecc/SerializableDictionary">GitHub - neuecc/SerializableDictionary</a></li>
</ul>
<p>もともとDictionaryはシリアライズできないのですが、ISerializationCallbackReceiverを用いてシリアライズ/デシリアライズのタイミングでKeyの配列、Valueの配列に戻してやるなどで保存すること自体は全然可能でした。のですが、速度的には問題あるな、というのに直面しました。</p>
<p>その前に、JSONから復元するのがまず遅かった。じゃあMsgPackやProtobufに変更したら速いかといえば、別にそこまでそうではなかった。これはつまり、C#のレイヤーで大量の何かを舐めて何かを作るという行為そのものが遅い。ではScriptableObject化すればどうだろう、確かにデシリアライズのプロセスがUnityネイティブ（実体は不明）と化して、確かに速い。が、そこからDictionaryに変換してやるのをC#で書いたらやっぱりそこが遅い。</p>
<p>遅い、というとアレで、量次第ですけどね。今回、量がやたら多かったので結構かなり相当引っ張られてた。初期化のタイミングなどで大量のDictionaryを捌くような場合に、無視できない程度に結構引っかかる遅さを醸し出してる。結局、配列からであっても、C#のレイヤーで大量の何かを舐めて何かを作るという行為そのものが遅い。という悲しい現実をつきつけられるのであった。</p>
<p>というわけで、SerializableDictionaryはDictionaryの内部構造をシリアライズすることで、ネイティブプロセスのみで完結して爆速で復元します。</p>
<p>SerializableDictionaryではSerializableDictionary, SerializableLookup(MultiDictinary), SerializableTupleの3つを提供します。今のとこアセットストアに公開するつもりはそんなないので、使いたい場合はソースコードをZipでダウンロードするなりGitで落とすなりしてプロジェクトに投げ込んでください。</p>
<h2>SerializableDictionary</h2>
<p>例えばキーがint、値がstringの辞書を保存したい場合は、まず、継承したクラスを作ります。</p>
<pre><code class="language-csharp">[Serializable]
public class IntStringSerializableDictionary : SerializableDictionary&lt;int, string&gt;
{

}
</code></pre>
<p>わざわざ継承しなきゃいけない理由は、ジェネリックな型はシリアライズできないからです！しょうがないね。別にゆうてそんなに大量の型があるわけでもないでしょうし、素直にそれぐらいは作りましょう。あとは、普通に使えば普通にシリアライズ可能になってます。メデタシメデタシ。</p>
<p>インスペクタに表示するためのPropertyDrawerも用意してあります（こちらも定義しないとインスペクタに何も表示されなくて不安になる）。使う場合は、SerializableDictionaryPropertyDrawerを継承した型を一つ作って、そこに属性でひたすらぶら下げます。</p>
<pre><code class="language-csharp">#if UNITY_EDITOR

[UnityEditor.CustomPropertyDrawer(typeof(IntStringSerializableDictionary))]
[UnityEditor.CustomPropertyDrawer(typeof(IntDoubleSerializableDictionary))]
[UnityEditor.CustomPropertyDrawer(typeof(IntIntStringSerializableDictionary))]
public class ExtendedSerializableDictionaryPropertyDrawer : SerializableDictionaryPropertyDrawer
{

}

#endif
</code></pre>
<p>これを定義すれば、インスペクタ上では</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/13866974/da6f9fac-ec77-11e5-93a7-a8eb43c08680.png" alt="image" /></p>
<p>なんとKeyとValueの確認しか用意されてなくて、エディット不能！ただのDump！うーん、気が向いたらエディット可能にします。そのうち（多分やらない）。</p>
<h2>複数キーの辞書</h2>
<p>Int + Intの組み合わせでキーにしたいとか、辞書にはよくあるケースです。そして、そういったよくあるケースではKeyにTupleを使うことが多いです。が、UnityにはTupleはありません。<a href="https://github.com/neuecc/UniRx">UniRx</a>にTupleがあります、が、それはシリアライズ可能ではありません(Genericだからねー、structなので継承もできない)。と、いうわけで、辞書のキーにしたいよね専用にSerializableTupleを用意しておきました。使う場合はもちろんまずは継承してジェネリックを消すとこからはじめます。</p>
<pre><code class="language-csharp">[Serializable]
public class IntIntTuple : SerializableTuple&lt;int, int&gt;
{
    public IntIntTuple()
    {

    }

    public IntIntTuple(int item1, int item2)
        : base(item1, item2)
    {

    }
}

[Serializable]
public class IntIntStringSerializableDictionary : SerializableDictionary&lt;IntIntTuple, string&gt;
{

}
</code></pre>
<p>あとは普通にキーに使ってもらえれば、普通に使えます。ちょっと手間ですが、そこまで多いわけでもないでしょうし我慢できる範囲内。だといいかな。</p>
<h2>SerializableLookup</h2>
<p>ILookupは、Keyに対してValue側が複数になっている辞書です。Dictionary[Key, Value[]] みたいなイメージ。通常のILookupはLINQのToLookup経由でしか作成できない、Readonlyなシロモノです。これ、非常に便利な型でして、よく使います。ToLookupしらない人は覚えましょう。ただ、勿論シリアライズできないのでAddを加えたSerializableLookupを用意しました（Removeはありません！つまりBuilderのほうがイメージ近いかもしれません。Removeがない理由は実装しててバグッたからとりあえず消してるだけなのでそのうち入れるかもしれないかもしれない）</p>
<p>使い方はDictionaryと同様。</p>
<pre><code class="language-csharp">[Serializable]
public class IntIntSerializableLookup : SerializableLookup&lt;int, int&gt;
{
}

#if UNITY_EDITOR

[UnityEditor.CustomPropertyDrawer(typeof(IntIntSerializableLookup))]
public class ExtendedSerializableLookupPropertyDrawer : SerializableLookupPropertyDrawer
{

}

#endif
</code></pre>
<p>ちなみに中身は面倒くさいんでSerializableDictionaryの一部を改変して辻褄合わせてるだけなので、実効速度的な意味ではToLookupで生成したものに比べるとやや劣るかなー、といったところ。まぁハッシュキーの衝突具合とかにもよるので、いうほどそこまでではないと思います。実装の雑さは気にしてるのでそのうち直したい（絶対やらない）</p>
<h2>TrimExcess</h2>
<p>ListにせよDictionaryにせよ、任意個数をAdd可能なものは、内部である程度余分なバッファを持っています。しかし、ScriptableObjectなどにしてAssetBundleに載せたい場合は、その後の追加なども特になく個数は固定である可能性も少なくないはずです。と、いうわけで、TrimExcessメソッドを呼ぶことで余分なバッファを切り落とすことができます。もし個数が固定であることが見えているなら、事前にSerialize前に呼んであげておくことで、メモリ節約につながります。</p>
<h2>Unityでシリアライズ可能なもの</h2>
<p>内部構造の話なのですが、その前にUnityでシリアライズ可能なものの制限についておさらい。</p>
<ul>
<li>[Serializable]のついた非ジェネリックな具象型</li>
<li>UnityEngine.Objectを継承した型</li>
<li>public、または[SerializeField]のついたインスタンスフィールド</li>
<li>int, float, double, bool, stringなどのプリミティブなデータ型</li>
<li>配列、もしくはList[T]</li>
</ul>
<p>Dictionaryに非対応なのは勿論ですが、Nullable[T]に非対応が割と痛かったりするかな！また、トップレベル以外でnullをサポートしていなかったりして、ちょっと複雑な型を作った場合、nullを入れたと思ったら全部0が入った謎データに置き換わっていた、とかが生じます。それらの制限の回避策としては、SerializableDictionaryと同じようにSerializableNullableのようなそれっぽい似非な型を自前で作ってあげればなんとかなります。nullのほうも同様にNullableClass（なんじゃそりゃ）を作ってあげることにより、nullかそうでないかの区別を可能にできます。面倒くさくはあるんですが、どうしても必要な場合はそうして回避できなくもないよ、ということで。</p>
<p>SerializableDictionaryは、Dictionaryの内部構造を、Unityでシリアライズ可能な範囲（ようするにひたすら単純な配列まみれにする）に修正することで実現しています。オリジナルのDictionary自体は<a href="https://github.com/dotnet/corefx">dotonet/corefx</a>のものです。</p>
<h2>ハッシュコードを永続化することの安全性</h2>
<p>ハッシュコードを永続化することは、推奨されないことが明言されています。というのも、そのオブジェクトに対するハッシュコードが一意であるかが、どのスコープまで保たれるかというのは、全くもって不明瞭だからです。参照型などはアプリケーション起動毎に異なってなにの役にも立たなくなる、では数字は？文字列は？保証はないんですねー。</p>
<p>実用的な意味では、問題ないと判断しても構わないと思っています。しかし、まず、monoと.NET Frameworkのような環境が違うもので生成したもの同士の互換性はないと考えたほうがいいでしょう（実際ない）。また、.NET Framework内だけでも、バージョンが異なれば、違うハッシュアルゴリズムが使われることにより異なるハッシュコードが使われる可能性は全然あります。今後も、Unityのバージョンアップ＋（もしあるのなら）monoのバージョンアップが発生した際などは、互換性が崩れる可能性があります。最悪そうなった場合は、任意のComparerを挟み込めるようになっているので、そこで互換性を保ったハッシュコードを返してやることにより、一応大丈夫とはいえます。一応。</p>
<p>とはいえまあ、実用的な意味では大丈夫でしょう。タブンネ。まぁしかし、この辺グレーゾーンなきらいもあるから、Unity公式でサポートってのは難しいんじゃないかなあ、というのはしょうがないかなー。</p>
<h2>まとめ</h2>
<p>Unityって結局どこで動いているものなのよ、ってのを改めて突きつけられた感じがしました。C++のエンジンがあくまでも主だな、と。また、シリアライズを通して考えると、一見不思議なMonoBehaviourやpublic fieldなども納得がいくように見えてきて、ようするにネイティブとの境界線を接続している場所なんですね。COMとdynamicでやり取りするように、ネイティブレイヤーとフィールドでやり取りする。そう思えば、何もかも腑に落ちてきた気がします（悟り！）。</p>
<p>C#のレイヤーでいかに仕事をさせないかがキモで、そのためにC#を書く。ってのも、まぁ悪くない話だし、Unityアプリケーションとしての整合感やパフォーマンスが最も求めるべきことなのだ。というのは認識しておきたいな、なんて改めて思わさせられました。</p>
</div>
<h1><a href="https://neue.cc/2016/01/06_525.html">Unityでのボクシングの殺し方、或いはラムダ式における見えないnewの見極め方</a></h1>
<ul class="date"><li>2016-01-06</li></ul>
<div class="entry_body"><p>Happy boxing! UniRxの<a href="http://neue.cc/2015/12/21_523.html">前回リリース(UniRx 5.0.0)</a>でパフォーマンス向上を果たしたと書きましたが、まだやり残したことがありました。それが<a href="https://msdn.microsoft.com/ja-jp/library/yz2be5wk.aspx">ボックス化</a>(boxing)の殺害です。ボックス化は単純に言うと、せっかくの値型が箱に入っちゃってGCゴミが発生してGCがーーー、というもの。避けれるなら避けるべし。あ、ちなみに今回の内容は特に別にUnityに限らないふつーのC#の話です。</p>
<p>それと、というわけかで<a href="https://github.com/neuecc/UniRx">UniRx</a> 5.1.0リリースしました、アセットストアから落とせます。基本的な内容は以下に解説するボックス化を徹底的に殺害したことによるパフォーマンス向上です。</p>
<h2>ボックス化とジェネリクス</h2>
<p>GCって、別に見えてるnewだけで発生するわけでもありません。見えてるものを警戒するのは大事ですが、見えないものを見てないのは片手落ち感が否めない。そんな見えないものの代表例がボックス化です。実際どういう時に発生するのかというと</p>
<pre><code class="language-csharp">var x = (object)10;
</code></pre>
<p>みんな大好きint(ValueType)がobject(ReferenceType)に！これがボックス化の害です。なるほど、避けたほうが良さそうだ。とはいえこんなのやらないって？ですよね。ではこれは？</p>
<pre><code class="language-csharp">void Hoge(object o)
{
}

Hoge(10);
</code></pre>
<p>まぁまぁやらないかもしれませんが、まぁまぁやるといえなくもないです。というかやる時はあります。ではこれは？</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2)
{
    return t1.Equals(t2);
}
</code></pre>
<p>一見何も悪くないのですが、実は悪いです。どこが？</p>
<pre><code class="language-csharp">public virtual bool Equals(Object obj);
</code></pre>
<p>ここが。ようするにEqualsはobjectになった後に比較されてしまうのです。というわけでボックス化が発生します。ジェネリクスは基本的にボックス化を避けれるのですが、一部のObjectに生えてるメソッド、というかようするにEqualsですが、を触る場合、気をつけないとうっかりしがちです。他に t1.GetType() と書いてもボックス化が発生します。その場合、 typeof(T) と書くことで避けられます。</p>
<h2>EqualityComparer&lt;T&gt;を使う</h2>
<p>ボックス化を避けた比較を行うインターフェイスに<a href="https://msdn.microsoft.com/ja-jp/library/ms131187(v=vs.110).aspx">IEquatable&lt;T&gt;</a>があります。</p>
<pre><code class="language-csharp">public interface IEquatable&lt;T&gt;
{
    bool Equals(T other);
}
</code></pre>
<p>これを使い、つまり</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2) where T : IEquatable&lt;T&gt;
{
    return t1.Equals(t2);
}
</code></pre>
<p>にすればボックス化は避けれる問題なし。ではあるんですが、これでは不便すぎます（さすがにintとかはIEquatable&lt;T&gt;を実装してはいますが、普通の参照型はほとんど実装していないでしょう）。同じなのかどうかとりあえずチェックしたい、Equalsを普通に呼びたいケースは沢山あります。そこでEqualsを外部から渡せる<a href="https://msdn.microsoft.com/ja-jp/library/ms132151(v=vs.110).aspx">IEqualityComparer&lt;T&gt;</a>インターフェイスと、デフォルト実装を取得するEqualityComparer&lt;T&gt;.Defaultが使えます。</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2)
{
    return EqualityComparer&lt;T&gt;.Default.Equals(t1, t2);
}
</code></pre>
<p>EqualityComparer&lt;T&gt;.Defaultは、TがIEquatable&lt;T&gt;を実装していればTがIEquatable&lt;T&gt;のEquals(T other)を、実装してなければEquals(object other)を呼んで比較します。これによりめでたく値型のボックス化が避けれました！UniRxでもDistinct、DistinctUntilChanged、ObserveEveryValueChanged、そしてReactivePropertyのSetValueでボックス化が発生していたのですが、UniRx 5.1.0からは発生しなくなっています。なんで今まで発生していたのかというと、EqualityComparer&lt;T&gt;がiOS/AOTで怪しくてあえて避けてたんですが、5.0.0からAOTサポートはきってIL2CPPのみにしたので無事性能向上を果たせました。</p>
<h2>UnityとIEquatable&lt;T&gt;</h2>
<p>Unityにおいては、それだけでメデタシではなく、もう少し話に続きがあります。Unityにおける代表的な値型であるVector2やRectなどは、全て、IEquatable&lt;T&gt;を実装して、いません。へー。==はオーバーライドされているので、素のままで扱って比較している限りは問題ないのですが、ジェネリックの要素として、また、DictionaryのKeyとして使った場合などでもボックス化が発生しています。</p>
<p>これが地味に困る話で、UniRxにおいてもObserveEveryValueChangedなどでVector2などが流れてくるたびにボックス化が発生したらちょっとよろしくない。</p>
<p>そこで、その対策として今回のUniRx 5.1.0では UnityEqualityComparer.Vector2/Vector3/Vector4/Color/Rect/Bounds/Quaternion というものを用意しました。これら代表的なUnityの値型に関しては、専用のEquals/GetHashCodeを実装してあります。また、 UnityEqualityComparer.GetDefault[T] により、それらが型から取り出せます。普通にUniRxを使っている範囲では(Distinct、DistinctUntilChanged、ObserveEveryValueChangedなど) IEqualityComparer の取得は UnityEqualityComparer.GetDefault[T] を通すようにしているため、極力ボックス化が発生しないようになっています。</p>
<h2>ラムダ式と見えないnew</h2>
<p>ボックス化、見えないGCゴミの話を書いたので、ついでにもう一つ見えないゴミを発生させるラムダ式について。ラムダ式は実際のところコンパイラ生成の塊みたいなもの、かつ、中身によってかなり生成物が変わってきます。ざっと6通りのパターンを用意してみました。</p>
<pre><code class="language-csharp">static int DoubleStatic(int x)
{
    return x * 2;
}

int DoubleInstance(int x)
{
    return x * 2;
}

void Run()
{
    var two = int.Parse(&quot;2&quot;);

    Enumerable.Range(1, 1).Select(DoubleStatic);           // 1
    Enumerable.Range(1, 2).Select(DoubleInstance);         // 2
    Enumerable.Range(1, 3).Select(x =&gt; x * 2);             // 3
    Enumerable.Range(1, 4).Select(x =&gt; x * two);           // 4
    Enumerable.Range(1, 5).Select(x =&gt; DoubleStatic(x));   // 5
    Enumerable.Range(1, 6).Select(x =&gt; DoubleInstance(x)); // 6
}
</code></pre>
<p>どんな感じになるか想像できました？では、答え合わせ。ちょっと簡略化しているので正確にはもう少しこんがらがった機会生成になっていますが、概ねこんな感じになってます。</p>
<pre><code class="language-csharp">static Func&lt;int, int&gt; cacheA;
static Func&lt;int, int&gt; cacheB;

internal static int LambdaA(int x)
{
	return x * 2;
}

class Closure
{
    internal int two;
    
    internal int LambdaB(int x)
    {
        return x * two;
    }
}

internal static int LambdaC(int x)
{
	return DoubleStatic(x);
}

internal static int LambdaD(int x)
{
	return DoubleInstance(x);
}

void Run()
{
    var two = int.Parse(&quot;2&quot;);

    // 1 - Select(DoubleStatic)
    Enumerable.Range(1, 1).Select(new Func&lt;int, int&gt;(DoubleStatic));
    
    // 2 - Select(DoubleInstance)
    Enumerable.Range(1, 2).Select(new Func&lt;int, int&gt;(DoubleInstance));
    
    // 3 - Select(x =&gt; x * 2)
    if(cacheA != null)
    {
        cacheA = new Func&lt;int, int&gt;(LambdaA);
    }
    Enumerable.Range(1, 3).Select(cacheA);
    
    // 4 - Select(x =&gt; x * two)
    var closure = new Closure();
    closure.two = two;
    Enumerable.Range(1, 4).Select(new Func&lt;int, int&gt;(closure.LambdaB));
    
    // 5 - Select(x =&gt; DoubleStatic(x))
    if(cacheB != null)
    {
        cacheB = new Func&lt;int, int&gt;(LambdaC);
    }
    Enumerable.Range(1, 5).Select(cacheB);
    
    // 6 - Select(x =&gt; DoubleInstance(x))
    Enumerable.Range(1, 6).Select(new Func&lt;int, int&gt;(LambdaD));
}	
</code></pre>
<p>それぞれ似ているような違うような、ですよね？一つ一つ見ていきましょう。</p>
<p>パターン1、パターン2はメソッドを直接突っ込む場合。この場合、実際のところはデリゲートを生成して包んでます。そしてこのデリゲートはGCゴミになります。なります。全く見えないんですが地味にそうなってます。と、いうわけで、それを回避するには静的メソッドなら静的フィールドに静的コンストラクタででも事前に作ってキャッシュしておく、インスタンスメソッドの場合は、もし使うシーンがループの内側などの場合は外側で作っておくことで、生成は最小限に抑えられるでしょう。</p>
<p>パターン3は、恐らく最もよく使うラムダ式の形式で、使う値が全てラムダ式の中だけで完結している場合。この場合、自動的に静的にキャッシュを生成してそれを未来永劫使いまわしてくれるので、非常に効率的です。一番良く使う形式が効率的というのは嬉しい、遠慮無くどんどん使おう。</p>
<p>パターン4も、まぁよく使う形式、でしょう。ローカル変数をラムダ式内で使っている（キャプチャ）した場合。この場合、普通にクラスがnewされて、そこにラムダ式内部で使われる値を詰め込み、その自動生成のクラスのインスタンスメソッドを呼ぶ形に変換されます。というわけで、パターン4は見た目は人畜無害ですが、中身はそれなりのゴミ発生器です！いや、まぁたかがクラス一個。であり、されどクラス一個。画面上に大量に配置されるGameObjectのUpdateなどで無自覚に使っていたりすると危なっかしいので、それなりに気を留めておくと精神安定上良いでしょう。</p>
<p>パターン5、パターン6は内部でメソッドを使っている場合。ちなみにここではメソッドにしましたが、フィールドやプロパティでも同じ生成結果になります。抱え込む対象がstaticかinstanceかで変わってきて、staticの場合ならキャッシュされるので少しだけ有利です。</p>
<p>なお、この挙動は現時点でのVisual Studio 2015のC#コンパイラによって吐かれるコードであり(Unityの今のmonoもほぼ一緒、のはず、です、確か多分）、将来的にはそれぞれもう少し効率的になるかもしれません（メソッドを直接突っ込む場合のキャッシュとかは手を加える余地がある気がする）。とはいえ原理を考えたら、外部変数をキャプチャするラムダ式はどうやってもこうなるしかなさそうだったりなので、大筋で変わることはないと思います。</p>
<h2>まとめ</h2>
<p>正直なところ今回書いたのは細かい話です！別に気にしすぎてもしょうがないし、というかこんなの細部まで気にして避けながら書くのは不可能です。ギチギチに避けてラムダ式禁止だのLINQ禁止だの言い出すなら、早すぎる最適化の一種で、かなり愚かしい話です。が、ゲームの中にはひじょーにタイトな部分は存在するはずで、そこで無自覚に使ってしまうのも大きなダメージです。私だってタイトになることが想定されるUpdateループの中でLINQを貫くならやめろバカであり、普通にペタペタとforで書けとは思いますよ。</p>
<p>あんまりゼロイチで考えないで、柔軟に対処したいところですねえ。どこに使うべきで、使うべきでないか。まぁその見極めがむつかしいから全面禁止とかって話になるのは実際のところ非常によくわかる！のですが、それこそプロファイラで問題発見されてからでもいいじゃん、ぐらいの牧歌的な考えではいます。いやだって、そんなたかがLINQやラムダ式ぐらいであらゆるところがボトルネックになるわけないぢゃん？そんなのより大事なとこ沢山あるでしょう。それに比べたらLINQを普通に使えることのほうが、UniRxを普通に使えることのほうが100億倍素晴らしい。もちろん、地味な積み重ねでダメージが出てくるところであり、そして一個一個は地味だったりするから見つけづらくて辛いとかって話もありつつ。</p>
<p>そんなわけでUniRxは、かなり厳し目に考慮しながら作っているので、比較的概ね性能面でも安心して使えるはずです！まだもう少しやれることが残ってはいるんですが、ちょっと踏み込んで書いてみると謎のuNET weaver errorに見舞われて回避不能で死んでいるので、当面はこの辺が限界です（ほんとuNET絡みのエラーはなんとかして欲しい、理不尽極まりない）。とはいえ、何かネタがあれば継続してより良くしていきますので、よろしくおねがいします。</p>
<p>そういえば第一回Unityアセットコンテストでは、<a href="http://blogs.unity3d.com/jp/2015/12/24/unityassetcontestjp1st/">セミファイナリスト頂きました</a>。ほぼほぼスクリプトのみの地味 of 地味なアセットであることを考えると全然上等で、嬉しい話です。</p>
</div>
<h1><a href="https://neue.cc/2015/12/31_524.html">2015年を振り返る</a></h1>
<ul class="date"><li>2015-12-31</li></ul>
<div class="entry_body"><p>振り返るシリーズ第四弾。去年の目標は</p>
<blockquote>
<p>テーマは「クライアントサイドとサーバーサイドをC#で統一することのメリットの実証」「さらにリアルタイムネットワークもC#で統一」「のためのヒットアプリケーションの創出」です。指向はあんま変わってないんですが、より具体的に。来年は動く年かな、といったところ</p>
</blockquote>
<p>ようするに会社(<a href="http://grani.jp/">グラニ</a>/CTO)でゲーム出して実証する。であり、結果としては……。はい。なので、本当に来年こそはね。というところです。</p>
<h2>C#</h2>
<p>今年はVS2015のリリースということもあり、かなりRoslynに傾倒しました。その集大成としてのまとめは<a href="http://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a>にスライドで出してますが、その後にもAnalyzerだけではなく、<a href="http://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a>や<a href="http://neue.cc/2015/12/21_523.html">Workspace APIを使ったプロジェクトコードからのT4生成での応用例</a>といった形で、ただたんに触ってみた、ではなくて、実用的にどう使えるのか、の応用例をきっちり掲示できたんじゃないかと思います。これらの話は実際に使っているもので、便利、かつ世界が広がったのは確かなので、Roslynはこれからどんどん応用的に使われるといいかな。</p>
<p>また、いつになくライブラリ書いてました。会社で必要だから作ってったという面も大きいんですけれど、こうして並べると、実際結構やりましたね、えらいえらい。</p>
<p>まずAPIサーバーとして<a href="https://github.com/neuecc/LightNode">LightNode</a>という自家製フレームワークを採用しているので、<a href="http://neue.cc/2015/02/16_505.html">Glimpse対応</a>と<a href="http://neue.cc/2015/04/19_511.html">Swagger対応</a>を入れてます。この対応は大正解で、もはやGlimpseとSwaggerなしでAPI開発していくのは無理ゲーとすら思える。超絶便利。Glimpseは主要開発者がMicrosoft入りしてより専任して開発することになったのと、Swaggerはもはやウェッブ標準といってもいい立ち位置を確立したということで、どちらもメジャーなテクノロジとなったことも含めて、技術選定にも成功したと言えるでせう。ASP.NET 5がまだまだ時間かかるので様子見したのも含めて、現状での最適解ではあるんじゃないかな、と。</p>
<p>Redisライブラリの<a href="https://github.com/neuecc/CloudStructures">CloudStructures</a>もGlimpse対応とStackExchange.Redis対応によって、相当リッチなものになりました。特にGlimpseのは相当気合入れたので充実してて実用度超絶高い。とはいえ本体部分は原則的には薄いラッパーなので、粛々とやってきます、というところですね。</p>
<p><a href="https://github.com/neuecc/LINQ-to-BigQuery">LINQ to BigQuery</a>はLINQPad Driverを作りました！これで実用度が飛躍的に上がりました。世間的にもデータ分析はBigQueryで決まりだよね！という流れが出来上がった年なわけですが、ここも乗り遅れずというか、むしろ引っ張る側に回れたのではないかと自負するところです。あとLINQPadにも相当詳しくなった。</p>
<p>今年最後の新顔は<a href="https://github.com/neuecc/EtwStream">EtwStream</a>で、↑でLINQPadに詳しくなった結果、応用例が頭に浮かんで一気に実用に載せられました。ETW(Event Tracing for Windows)のビューアーとしてまともに使える世界唯一の解といっても過言ではない（むしろ今までのフベンサがヤバすぎた……）。年末にはRoslyn C# Scriptingによる実行できるコンフィグというコンセプトを打ち出したOut-of-Process Serviceも追加していて、来年はこれの稼働実績を作っていきたいところです。</p>
<p>変わり種だけど誰にとっても実用度100億なのは<a href="https://github.com/neuecc/Open-on-GitHub">Open on GitHub</a>というVS拡張で、もはやこれなしでぎっはぶでコミュニケーションを取るのは無理なのでは疑惑もあるほどに神拡張。地味に12/29にVer 1.4.0のアップデート出してます。</p>
<p>そして<a href="https://github.com/neuecc/UniRx">UniRx</a>。今年はお陰様で大躍進の年で、<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;ref=searchresults&amp;s=stars&amp;type=Repositories">GitHubスター順</a>でも、GitHubで公開されてるUnity用ライブラリでは世界4位と、中々に中々の感じで、いやほんと良かった。</p>
<p>年の始めではReacitvePropertyやPresenterBaseの導入によるModel-View-(Reactive)Presenterというコンセプトの確立が地味に大きめ（ちなみに私は設計とかってこのレベルの話こそ最も大事だと思ってて、コードを小奇麗にするようなレベルの話は設計、ですかねえ？とは思ってる）。真ん中でObservableTriggers、そして年末駆け込みの<a href="http://neue.cc/2015/12/21_523.html">UniRx 5.0</a>で完全書き直しによるパフォーマンスとデバッガビリティの向上。もはやUniRxなしで書けと言われると困りすぎるぐらいに必要不可欠な存在となれました。</p>
<p>UniRxが成功したポイントは、Reactive Extensions自体が素晴らしいコンセプトで実績もある、というのも勿論そうなんですが、UniRx自体の、Unityへフィットさせるための繋ぎ方の工夫の面も大きいとは自負してます。あまり頭でっかちにならずに柔軟に作り込めたのが良かった。ReacitvePropertyなんかも、実装はシンプルですが、（.NET版を作った時の）コンセプト立証と実装には普通に時間かけてたし、そもそもコロンブスの卵的なところもありましたし、更にそのUnity化でも、削ぎ落とし方には相当神経使ってます（ゴテゴテ足すだけが設計ではない）。</p>
<p>また、お陰様でUnityのスクリプティングと、そしてRxには詳しすぎるほどに詳しくなれました、というかRxに関しては実際隅から隅まで理解した……。</p>
<p>現在未公開だけど予定があるものとしては<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>というUnity/Photon Server用の非同期RPCフレームワークがあります。これは来年の初頭に公開できればな、ですかねー。</p>
<h2>お仕事</h2>
<p>書いたライブラリは基本的に会社でフルに使ってるものなので、成果っちゃあ成果です。が、集中力散漫な年でした。成果として些かライブラリ過多になったのは、それが時間の捻出が比較的しやすい（土日とかにちょっと徹夜して気合いれればグッと形にできたりするんで）というのが大きいですね。細切れな時間で、いまいちうまくプロダクトそのものにコミットできなかったのは減点度大きめで、非常に良くない。ライブラリ側の成果と相殺してプラマイゼロと言いたくはあるんですが、私的な理想像とは離れたところにあるので、まぁ、60点ぐらい……（ちょっと甘め）</p>
<p>いろいろと白髪が増える、ハゲる。といったぐらいな感じです、うみぅ。来年は100点目指します。</p>
<h2>ゲームとか音楽とか</h2>
<p>今年はライブにまぁまぁ行ったんですが、年末の<a href="http://www.creativeman.co.jp/artist/2015/12kingcrimson/">King Crimsonの来日講演</a>が震えすぎたのでそれが全て。生きててよかったというか生きてるうちに生で聴けることがあるなんて……！内容もばっちしで、いやはやホンモノは永遠にホンモノであり続ける、というかホンモノであり続けようとする姿勢に感服するばかりです。この編成での本気のライブ版が早く出てほすぃ。</p>
<p>面白かったといえば<a href="http://www.beatink.com/Labels/Warp-Records/Squarepusher/BRC-461/">Squarepusherの来日講演</a>も見に行ったのですが、実に面白かった。サイトでは360度動画が公開されてますが、そうした全方位動画やプロジェクションマッピング、VRの未来すら感じられて、思い出すと行けて本当に良かったなぁ。</p>
<p>ゲームは<a href="http://downwellgame.com/">Downwell</a>がオモシロイッス。</p>
<p>漫画は、iPhone 6s Plusを買ってから、スマフォで本や漫画が十分に読めるようになってしまって革命的に体験が変わった。いやあ、大画面スマフォ（ファブレット）は良いですね！一度体験すると、もう小さいのには戻れない。というわけで基本Kindleで買ってiPhoneで読むというインスタントな生活になりました。今年読んだ中だと<a href="http://www.amazon.co.jp/dp/B00U0OMIQA/">ヴァーチャル・レッド</a>が良かったかなぁ、終始、陰鬱な空気が流れていて息苦しいんだけどどこか心地良くもある。気に入りすぎてKindleで読んだ後に実書籍のほうも買ったんですが装丁がよく出来てて、そちらも満足度高し。</p>
<h2>来年</h2>
<p>シンプルに、全力で仕事してゲーム出す。ですね。それ以外なし。もちろん、それはC#を全方面で活かした実証結果として成り得るものです。絶対。これは絶対。</p>
<p>私個人としてはヌルヌルとC#でのスクリプティングにだけ篭もりすぎた感あるので、UniRxも一段落したことだし（ちなみに、もう少し性能向上のためのアップデートが控えていてというか現在審査中なので年明け早々にそれはリリースされるでしょう）、シェーダーをそれなりにすらすら書ける程度にはグラフィック処理もできるようにってのは年頭の宿題にしておきます。</p>
</div>
<h1><a href="https://neue.cc/2015/12/21_523.html">UniRx 5.0 - 完全書き直しによるパフォーマンス向上とヒューマンリーダブルなスタックトレース生成</a></h1>
<ul class="date"><li>2015-12-21</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx(Reactive Extensions for Unity)</a>のVer 5.0が昨日、AssetStoreにリリースされました。前回が4.8.2で6月なので、半年ぶりで、今回はメジャーアップデートとなります。現在の最新であるUnity 5.3（の新機能）に対応というのもあります、が、今回の目玉は書き直しです。半年間なにやっていたかというと、書き直そう！いよいよやっと重い腰を上げてスタックトレースに優しいコードにしよう！と思い立って始めてみたもののメンドウくささが極まって挫折して放置。してたんですが、先月ぐらいに、いい加減に手を付けたくて、ちょっと<a href="http://grani.jp/">うちの会社</a>の仕事時間を貰ってゴリゴリ進めてやっと終わりました。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub - UniRx</a></li>
<li><a href="http://u3d.as/7tT">UnityAssetStore - UniRx</a></li>
</ul>
<p>とりあえず分かりやすい成果としては、スタックトレースです。</p>
<pre><code class="language-csharp">var rp = new ReactiveProperty&lt;int&gt;();

rp.Where(x =&gt; x % 2 == 0)
  .Select(x =&gt; x * x)
  .Take(10)
  .Subscribe(x =&gt; Debug.Log(x));

rp.Value = 100;
</code></pre>
<p>という人畜無害なコードがあるとして、以前のスタックトレースはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917884/404287a0-a75d-11e5-9aee-ebe8d5bb28e3.png" alt="image" /></p>
<p>言ってることはわからんでもないコンパイラ生成の何かと、多量の中間物で埋まっていて、実に読み取りにくい。この程度のメソッドチェーンならまだマシで、もっと長大で、複雑なオペレータが絡んでる場合は困難極まってました。私も何度文句を言われて平謝りしたか分からないぐらいです。しかし、今回のバージョンからはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917889/765ebcf0-a75d-11e5-8117-f2b85a4113af.png" alt="image" /></p>
<p>自動生成コードなし、中間物ナシ。圧倒的な読みやすさ！また、これはそのまま、書いたとおりに動いているということの証左でもあります。実行パイプラインの無駄がスタックトレースに出ているままに皆無になったので、パフォーマンスにも寄与しています（書き換えた今では、もはや前のが厚すぎた説はありますけれど、それはまぁ言わんといてください……）</p>
<p>実装はかなりメンドウで、ラムダ式を使うと問答無用でコンパイラ生成のクラスが吐かれてしまうので、ひたすら名前付きのクラスを作っていくお仕事をしました（一個のオペレーターにつき2~3のクラスを要求する、オーバーロードがあればその分だけ……）。また、Unityのコンソールの出力に合わせた細かい調整を施すことによって（＋通常のスタックトレースへの吐かれ方に対しても調整して）作りました。すっかりスタックトレースのことを考えたプログラミングができる脳みそが出来上がったんですが、基本的に面倒くさ度100なので、ふつーのゲーム側のコードでは考えたくないしやりたくもないしやらなくていいと思ふ。</p>
<h2>性能改善</h2>
<p>じゃあ前のは遅かったのかよ、と言われると、うーん、そんなでもないですよ？、とは言いたいのですけれど、まぁカタログスペック的には実際3~10倍ぐらい速くなってます。これはねぇ、例えばMySQL 5.7が5.6の3倍速い！なるほど、じゃあ5.6はゲロ遅なのか？そうじゃあないっしょー、みたいな話なのですが、実際速くなったのは誰にとっても私にとっても嬉しい話です。</p>
<p>しかし、パフォーマンス低いとか気になるとか、漠然とした話で、何も言ってないに等しいんです。もちろん、3~10倍速くなったというのも何も言っちゃあいないです。プログラムの抱えている範囲に対して広すぎる、漠然としすぎていて何ら指標になっちゃいません。というのは気をつけてください。Rxのパフォーマンスを測るにあたって、フェーズ的に3つあって、</p>
<ul>
<li>Observableを構築するフェーズ(さすがにこれはほとんど無視していい)</li>
<li>Subscribe = Observerを構築するフェーズ</li>
<li>OnNext</li>
</ul>
<p>それぞれは独立して考える必要があります。また、ReactivePropertyはSubscribeと同時にOnNextも一回入るのでSubscribe + OnNextである、などなどがあるので、どこをどう測りたいかを明確にし、どう測るかを考えないとザルな結果になります。</p>
<p>基本的に、Rxのチェーンの寿命は長いのでOnNextの性能を最重要視して見るべきです。ここの区別は非常に大事です、長ければチェーン構築コストは相対的に無視できる範囲に収まるのでマイクロな結果で想像するのは違うってものです。が、初回に大量にSubscribeが発生するといった、ローディング的な意味合いでは、Subscribeのフェーズも鑑みる必要があります。</p>
<p>んで、これもザックリとしすぎでアレなんですが、OnNextは3~5倍ぐらい、Subscribeに関しては10~20倍速くなりました。OnNextは全体的なパイプラインの最適化のオペレーターの実装調整が効いてるんですが、Subscribeは抜本的に最適化/単純化したので、以前と全然違う結果になってます。これは、社内で大量のSubscribeがシーンロード初回に発生するという事案がありまして、Subscribeを改善しない限りロード長過ぎで終わぽ、だったのでなんとかしました、はい、すびばせん今まで手付かずで……（ちなみに本家Rx.NETとやり方変えてるので本家Rx.NETよりも速い）</p>
<p>あとのところはオペレーター次第です。WhereとかSelectとか、単純な奴は実装変わってないんで大差ないんですが、一部のメソッドの実装が素朴でしょっぱかったので、そういうのはきっちり直してるので以前のと全然性能変わってきてます。特にObserveOnが顕著かな。また、Observable.IntervalやTimerなどの一部の時間系メソッドも構造がガラッと変わってるので(MainThreadScheduler/ThreadPoolSchedulerが使われる場合には最適化パスを通るようにしてる)、かなり良好な結果が得られるのではないかと。</p>
<p>全体的にGCゴミも減ってます。まだもう少し減らせるポイントが残ってるので、次のマイナーアップデートではその辺の処理をする予定デス。</p>
<h2>リリースノート</h2>
<p>今回の。</p>
<pre><code class="language-txt">破壊的変更:
iOS/AOTサポートは切りました。IL2CPPしかサポートしません。
Unit/Tuple/CancellationToken/TimeInterval/Timestampedをclassからstructに変えました。
MainThreadDispatcher.Postのメソッドシグネチャが変わり、T stateを要求します。
ObservableMonoBehaviour/TypedMonoBehaviourがObsoleteになりました。
AotSafe Extensions(WrapValueToClass)を消しました。
InputField.OnValueChangeAsObservableをOnValueChangedAsObservableにリネームしています(Unity 5.3の場合。Unity 5.3でInputField側で同様の変更が入っているため)
Subscribe in SubscribeでのException Durabilityを保証します。

追加メソッド/クラス:
Observable.ForEachAsync
Observable.Take(duration)
Observable.Aggregate
Observable.Zip(T3~T7)
Observable.CombineLatest(T3~T7)
Observable.Start(function, timeSpan)
Observable.ToYieldInstruction in Unity 5.3
Observable.DoOnError
Observable.DoOnCompleted
Observable.DoOnTerminate
Observable.DoOnSubscribe
Observable.DoOnCancel
Observable.CreateSafe
Progress
StableCompositeDisposable
MultilineReactivePropertyAttribute

その他色々修正:
色々色々(詳しくはGitHubのとこの正式なリリースノート見てくだしあ)
</code></pre>
<p>破壊的変更といっても、直撃することはないんじゃないかなあ、と思ってます。ただ社内ではUnit/Tupleのstructへの変更で引っかかったりはしました(想定外にもnullが代入されている場合があった！)。それは適切にdefault使うのと、Tupleに関してはTuple?にするなりする程度で対応はできます。struct化はAOTサポートを切ることで躊躇いなくできるようになって、ヨイことだなー、と。コードも全体的にAOTサポートのための余計なコードを順次切り落としています（パフォーマンスロスに繋がっていたので）。その辺はIL2CPPバンザイ、ですかねえ。</p>
<h2>vs IL2CPP - Runtime UnitTest Runnner</h2>
<p>IL2CPP万歳と言ったそばから言うのもアレですが、IL2CPP苦しい……。コンパイル死ぬほど遅いし、というのはおいておいても、まだ地雷は埋まっていて、たまに踏んで死ぬんですよね。その場合IL2CPPのバグなんで報告して直してもらうってことになるんですが、それはそれとして、なんで死ぬのかがAOTの場合は想像ついたし対処も比較的容易だったんですが、IL2CPPは踏むまで地雷かどうかを察知することが不能な上に、踏んだら踏んだで、何を踏んだからこうなったかがイマイチ分からなくて最小ケース作ってバグレポも辛いケースもちらほら。</p>
<p>とはいえ、それなりに安定してきてるのは確かだと思います。偉い。そこは賞賛されるべき。</p>
<p>のはいいんですが、実行するまで分からないじゃ（特にライブラリ側としては）困るので、iOS実機でユニットテストを動かしたいと思いました。Unity 5.3から<a href="http://docs.unity3d.com/Manual/testing-editortestsrunner.html">Editor Test Runner</a>なども標準で入ってきましたが、端的に言えば、欲しいのはそれじゃない。実機で動かしたいの！エディターでの実行はどうでもいいの！</p>
<p>エディター上での実行も大事なんですが、元々UniRxは.NET用ライブラリとしても動くように設計されていて、ユニットテストも.NET用ライブラリとしてMSTestで書かれている（！）という特殊な環境なので、エディターでのテストサポートは完全に不要なのです。いや、だってVSのテストランナー使ったほうがやりやすいじゃん？</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919089/a1042f8e-a78b-11e5-9b65-fbca28a5da13.png" alt="image" /></p>
<p>そうやってユニットテスト自体は書かれてるし、さすがに実機用に別のを書きなおすのは不可能なので、このユニットテストを実機で動かせるように持ってければそれでいいんだよねー。</p>
<p>ここで出てくるのが<a href="https://github.com/dotnet/roslyn">Roslyn</a>。Roslynを使ってユニットテストプロジェクト内のユニットテストを、ソースコードのファイル単位ではなく、解析可能な構文木単位で取得し、<a href="https://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Text Template</a>で整形して吐き出せちゃえばいいんだ、という合わせ技で運搬することに成功しました。VS2015だから出来るハック、VS2015最高……。さすがにコード持ってくだけではMSTestの実体がなくて動かないんですが、そこは適当にモック(Shim)を用意して回避しました。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919143/db2b7fae-a78c-11e5-8dea-6e7e99598bd2.png" alt="image" /></p>
<p>エクストリーム雑なUI。エラーが出た場合は赤くなってExceptionを表示します。これで、ちゃんとiOS/IL2CPPで全部パスしてるのを確認済みです。</p>
<p>ちなみにこのRoslyn + T4でコード生成するテクニック、今回のように別プロジェクトをターゲットにして運搬するというのもいいんですが、自プロジェクトを対象にすることもできます。T4で生成するためのコードのタネって、今まではT4側に書くしかなくて面倒だったんですが、もうその制限はありません。ありとあらゆるソースコードがコード生成のためのタネとして使えます。メタプログラミングの扉をまた一つ開いてしまった。</p>
<p>このテクニックは私の発明じゃなくて<a href="http://www.misuzilla.org/Blog/2015/12/04/UsingRoslynInT4Template">RoslynをT4テンプレート内で使う - ぷろじぇくと、みすじら。</a>から拝借してますので、気になる人はそちらの記事をどうぞ。ｌ</p>
<h2>Unhandled Exception Durability</h2>
<p>UniRx 5.0の変更のうち、ちょっとだけ重要なのがUnhandled Exception Durabilityというコンセプト。です。これは、Rxでイベントハンドリングするのはいいんだけどエラーでるとイベント購読が吹っ飛ぶの困るんだよねー、に対するUniRxからの回答ということで。内容ですが、Subscribe in Subscribe時の例外を外側に伝搬「しない」ことを保証しています（逆に言えば実は4.8では保証されてなくて解除されたりしてました。ちなみにRx.NETでも保証されてなくて解除されたりされなかったりします、ここはUniRx独自で挙動を明言する形に倒しています)。伝搬しない、というのは握りつぶすという意味ではなくて、ObservableのDispose処理を行わない、という意味です（例外自体はグローバルに飛ぶのでUnityのConsoleにExceptionが表示されるし、ログイベントでちゃんと捉えられます）</p>
<pre><code class="language-csharp">button.OnClickAsObservable().Subscribe(_ =&gt;
{
    // もし内側でエラーが発生しても、外側のOnClickがデタッチされることはない
    ObservableWWW.Get(&quot;htttp://error/&quot;).Subscribe(x =&gt;
    {
        Debug.Log(x);
    });
});
</code></pre>
<p>エラーハンドリングは難しい問題で、<a href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling">RxJavaのErrorHandlingの章</a>を読んでも別にそんなワカラナイよね、とかって感じではある。UniRxでは Retry/OnErrorRetry でハンドルできなくはなく、まぁそれがスタンダードなRx Wayではあるんですが<a href="http://qiita.com/bouzuya/items/5e068659d63d9961a260">RxJS の Operators (6) - Observable のエラーハンドリング</a>のまとめコメント「これで本当にエラーハンドリングに十分なのか不安です。」とあるように、実に不安です。</p>
<p>で、入力用のハンドラーが吹っ飛ぶのは致命傷なので、どうしても救いたいその辺のとこに関してはSubscribe in Subscribeで処理するのがいいんじゃないかなー、というのを提唱します。入力イベントを合成したいって局面も多いと思うので、それはそれで合成してもらったうえで（そして、その合成パイプラインに関してはエラーが出ないよう厳重に作る！）、それを入力ストリームだと考えて、そこから先はSubscribe in Subscribe。あまり格好の良いものではないのも事実ですが、現実的っちゃあ現実的かなー、と。ちなみにこの挙動を保証するのはUniRxだけだと思うので他のRx系に持ってっても動きません（多分）</p>
<p>なお、Subscribe in Subscribeでの例外で解除されないのは最上流がHot Observableのものだけです。HotとColdに関しては<a href="http://qiita.com/toRisouP/items/f6088963037bfda658d3">RxのHotとColdについて</a>などを参照するといいと思いますが、とりあえず具体的にHotなのはUniRxデフォルトでは FromEvent/Subject/ReactiveProperty/ObservableTriggers/UnityUI.AsObservable です。ようはイベント的なやつです。Coldなのは Return/Interval/Timer/FromCoroutine などで、これらは例外で解除されます（そうじゃないとTimerとか無限に動き続けられても危なくて困るでしょ？FromCoroutineだって途中でエラーが出てる状態なのに回られても困るでしょ？）</p>
<h2>CustomYieldInstuction</h2>
<p>書き直しはいいんだけど、何か新機能ないと寂しいよなー、ということで、Unity 5.3用に一つ入れました。Unityブログでも<a href="http://blogs.unity3d.com/jp/2015/12/01/custom-coroutines/">カスタムコルーチン</a>として紹介されていますが、Unity 5.3からCustomYieldInstructionが搭載されました。というわけでUniRxもUnity 5.3以上ならToYieldInsturctionメソッドが使えるようになっています。</p>
<pre><code class="language-csharp">IEnumerator TestNewCustomYieldInstruction()
{
    // Rx Observableをyield returnで待ちます.
    yield return Observable.Timer(TimeSpan.FromSeconds(1)).ToYieldInstruction();

    // スケジューラを変える(Time.scaleを無視する)とかも当然可能
    yield return Observable.Timer(TimeSpan.FromSeconds(1), Scheduler.MainThreadIgnoreTimeScale).ToYieldInstruction();

    // 戻り値を得る場合はObservableYieldInstructionを変数に取れば、Result/Errorで受け取れます
    var o = ObservableWWW.Get(&quot;http://unity3d.com/&quot;).ToYieldInstruction(throwOnError: false);
    yield return o;

    if (o.HasError) { Debug.Log(o.Error.ToString()); }
    if (o.HasResult) { Debug.Log(o.Result); }

    // 当然こういう長めのものだって自由に書けます 
    yield return this.transform.ObserveEveryValueChanged(x =&gt; x.position)
        .FirstOrDefault(p =&gt; p.y &gt;= 100)
        .ToYieldInstruction();
}
</code></pre>
<p>今までもToAwaitableEnumerator/StartAsCoroutineというメソッドで同様なことを出来るようにしていたのですが、ToYieldInsturctionのほうが効率的だし、使いやすいです。ToYieldInsturctionによるObservable-&gt;Coroutine変換のオーバーヘッドはないといっても過言ではない！Unity 5.3最高！</p>
<p>ちなみに、このToYieldInsturctionはCustomYieldInstructionクラスを実装してません。Unity 5.3のカスタムコルーチン対応というのは、yield returnでIEnumeratorを受け取ると毎フレームMoveNextを呼び出して待機する、というのが正しい話です。CustomYieldInstructionはあくまでIEnumerator実装のためのちょっとしたヘルパーなので、別にそれにこだわる必要はありません、ということで普通に独自の軽量なIEnumerator実装を刺しています。</p>
<p>ちなみに実行されるタイミングは<a href="http://docs.unity3d.com/530/Documentation/ScriptReference/CustomYieldInstruction.html">CustomYieldInstructionの説明</a>によると after MonoBehaviour.Update and before MonoBehaviour.LateUpdate だそうなので、実行タイミング調整のネタに使えるかもしれません。</p>
<h2>まとめ</h2>
<p>実際のトコver 2.0なんですが、諸事情で4始まりなのでver 5.0です！Unityのメジャーバージョンと偶然揃ったしいっか、という気がしますね！今回のコードはかなり自信あって、パフォーマンスがー、な局面であってもお薦めできます。どうせ、ライトウェイトを冠した超機能限定版の同じようなものを実装するなら、性能面であっても素直にUniRxを使ったほうがいいでしょう。と、言えます。言えます。</p>
<p>今月頭に書いた<a href="http://neue.cc/2015/12/03_521.html">Unity 5.3のMulti Scene EditingをUniRxによるシーンナビゲーションで統合する</a>などのように、UniRxを前提に置くことで、やれることが大幅に広がります。根底から入れれば全体のプログラミングの世界観が（良くも悪くも）大きく変わります。が、まぁそれはエキセントリックすぎるということであれば、触りは単純なところからでも全然アリかな、とは。思います。特に非同期/マルチスレッド関連は、変なライブラリ入れるよりもずっと良いでしょう。</p>
<p>ところで半年前、今年6月に<a href="http://neue.cc/2015/06/20_514.html">第一回UniRx勉強会を開催しました</a>が、第二回の需要ってありますか？もしありましたら、その前に発表者が必要！なので、是非話したい！人は、私のTwitterかメールかに連絡ください。開催するにも発表者いなければ開催もなにもないですからね……！</p>
<p>ついでにもはや触れちゃいけない扱いの気がしなくもない<a href="http://asecon.unity3d.jp/">Unity アセットコンテスト</a>というのに応募していたのですが結果発表……。</p>
</div>
<h1><a href="https://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a></h1>
<ul class="date"><li>2015-12-13</li></ul>
<div class="entry_body"><p>Advent Calendar大遅刻組です。というわけで<a href="http://qiita.com/advent-calendar/2015/csharp">C# Advent Calendar 2015</a>の10日目です！なんで遅刻したかというと、記事のネタのためのライブラリを作るのに思いの外時間がかかってしまったから…… コンセプトも固まってたしプロト実装も済んでたんですが、最終的な形に落としこむのが想定よりちょっと割と大変だった……。すびばせんすびばせん。</p>
<p>どうやらC# Advent Calendarは2011年から書いてるので5回目ですね、へぇー。過去を振り返ると<a href="http://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a>、モダンつってもC# 4.0時代ですが、今ぱっと見直すと別にここで言ってることは今も変わらないですね、これに5.0, 6.0の話を足せばいいだけの話で。2012年は<a href="http://neue.cc/2012/12/03_389.html">MemcachedTranscoder - C#のMemcached用シリアライザライブラリ</a>ということで、このライブラリは別に私自身も使ってないので割とどうでもいー、んですが、まぁシリアライザにまつわる諸々についての知見が少しは入ってる模様。2013年の<a href="http://neue.cc/2013/12/04_435.html">非同期時代のLINQ</a>はいい話だなー、これがC# 5.0のModern Styleの追記差分みたいなもので、実際、今現在においては超絶大事な部分。2014年は<a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a>で、C# 6.0ではないですが、その世代ではAnalyzerは中心になってくるので、これがC# 6.0の差分といってもいいでしょう。多分きっと。</p>
<h2>Roslyn C# Scripting</h2>
<p>Roslyn、Compiler as a Serviceとか言ってましたが、やっぱスクリプティングが華形だと思うのです。が、しかし。が、しかし。今の今までRoslynに関する話題で、Scripting APIに関するお話はあまり上ってませんでした。理由は単純で、今の今まで未完成品だったから。先月末に出たVisual Studio 2015 Update 1でC# Interactiveが、そして同時にNuGetでも<a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting">Microsoft.CodeAnalysis.CSharp.Scripting</a>で、現在は1.1.1が配布されることにより（ところでこれのパッケージ名が中々定まらなくて実際これであってるのか不安だけどLast updatedが2015/12/3なのでこれでいいでしょう、まだDL数が405ですけど！）やっと全てのピースが揃った感じです。</p>
<p>Scriptingについてのドキュメントは、RoslynのWikiにある2つのページを見ておけば十分でしょう。<a href="https://github.com/dotnet/roslyn/wiki/Interactive-Window">Interactive-Window</a>には、csxの仕様っぽいもの、特殊なDirectiveの説明があります(#rとか#loadとか)。<a href="https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples">Scripting-API-Samples</a>にはプログラムから触った時のAPIとしてどんなものを持ってるか、どういう風に使えるかが書いてあります。かなりシンプルなので、そんな難しくなくすぐ使えます。</p>
<p>ちなみにC# Interactiveはまだまだ全然使えないって感じなので、期待するほどのものでもないですね。csxもエディタサポートが実質、シンタックスハイライトぐらいなので厳すぃ。黙って<a href="https://www.linqpad.net/">LINQPad</a>使いましょう、課金しましょう。</p>
<h2>Roslyn時代のコンフィグ</h2>
<p>最近というか数年前からずっと構造化ログにご執心で、<a href="http://neue.cc/2015/11/03_520.html">EtwStream - ETW/EventSourceのRx化 + ビューアーとしてのLINQPad統合</a>というのを作ってたんですが、今回はそれに、ファイル等への出力プラグイン(Sink)と外部サービス(EtwStream.Service)を作りました。アプリケーションから出力されるログは、ETWというWindows内部に流れてる高速なロギングストリーム機構を通して、別プロセスのEtwStream.Serviceで受け取ります。ログは特に最近ではファイル出力など比較的安定性が保証されているものだけでなく、ネットワークを通じて配信するケースも少なくありません。ログの扱いが別プロセスに別れることにより、アプリケーションに与える影響が少なくなるほか、アプリケーションの状態(アプリ自体の終了/デプロイでの入れ替わり等)に気を配る必要もなくなります。</p>
<p>というのが外部サービスであることの意義なのですが、問題はコンフィグです。コンフィグ。元々EtwStreamはObservableEventListenerという、IObservble&lt;LogEvent&gt;の形でログをストリームで受け取り、それをRxで自由にフィルタしたりグルーピングしたりマージしたりなんでも出来ますよね、という究極の自由度がウリでした。しかしコンフィグです、Rxのその柔軟性をコンフィグで実現するのは不可能です。物凄く機能を削った単純なSubscribeで我慢するか、あるいは超絶複雑なXMLでそれっぽいものを構築するか(log4netやNLogのXMLコンフィグが死ぬほど難解で複雑なのは、ログのルーティング自体が複雑で、それをコンフィグで表現することが困難だということなのです）になります。</p>
<p>せっかく、ログを現代的なReactive Extensionで表現することができたのに、外部サービスにした途端に破棄しなければならないのか。それでいいわけがなく、そこでC# Scriptingの出番になります。EtwStream.Serviceはコンフィグをconfiguration.csxとして、以下のように書きます。</p>
<pre><code class="language-csharp">// configuration.csx

// 5秒 or 1000件でバッファリング(ふつーのRxのBufferを利用)
// 出力フォーマットは普通にFunc&lt;TraceEvent, string&gt;で整形できる！
ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
    .Buffer(TimeSpan.FromSeconds(5), 1000, EtwStreamService.TerminateToken)
    .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
    .AddTo(EtwStreamService.Container);
</code></pre>
<p>基本的に完全にC#そのものなので、全てのRxのメソッドが使えて自由に合成・ルーティングが可能です。これはIn-Processで書いてる際（普通のロガーとしてC#コードで埋め込む場合）もOut-Of-Process Serviceでコンフィグとして書く場合も（ほぼ）同じコードで表現できるということです。もちろんC#で書けるということは、 System.Configuration.ConfigurationManager.AppSettings から設定を引っ張ってきたり、ネットワーク通信して何か引っ張ってきたりとかも自由自在やりたいほーだいです。</p>
<p>例えばこれをNLogで表現すると</p>
<pre><code class="language-xml">&lt;targets&gt;
    &lt;default-wrapper xsi:type=&quot;BufferingWrapper&quot; bufferSize=&quot;1000&quot; flushTimeout=&quot;5000&quot; /&gt;
    &lt;target name=&quot;file&quot; xsi:type=&quot;File&quot; fileName=&quot;log.txt&quot; keepFileOpen=&quot;true&quot;
		layout=&quot;[${date:format=yyyy/MM/dd hh\:mm\:ss}][${level}]${message}&quot; /&gt;
&lt;/targets&gt;
&lt;rules&gt;
    &lt;logger name=&quot;*&quot; minlevel=&quot;Debug&quot; writeTo=&quot;file&quot; /&gt;
&lt;/rules&gt;
</code></pre>
<p>になります。NLogの独自フォーマットルールに従って書く必要があるし、メッセージ書式も独自テンプレートになります。とはいえ、これはまだ単体なので遥かにマシで、色々複合的なことをやろうとするとすぐに膨れ上がって意味不明なことになるのは、みんな経験のあることなのではないでしょうか？</p>
<p>バイナリが<a href="https://github.com/neuecc/EtwStream/releases/tag/EtwStream.Service">EtwStream/releases/EtwStream.Service</a>に転がってるので、是非ちょっとだけ遊んでみてくださいな。</p>
<h2>仕組み</h2>
<p>csxをEvaluateしてるだけです。基本的にcsxの実行は即座に終わります、ObservableEventListenerをSubscribeしているだけですから。しかし、csxが終了してもSubscribeは生き続けています！（言われてみると当たり前のようで、最初はそうなの？と違和感はありました）。それにより、流れてくるログは（別スレッド上の)ObservableEventListenerを流れて、csx上のRxを通りcsx上でのSubscribeにより処理され続けます。というわけで、EtwStream.Serviceのcsxは、ただのXMLコンフィグがcsxに変わっただけ、ではなく、このcsxはコンフィグのようでコンフィグじゃなく、実行コードそのものなのです！</p>
<p>終了処理に関しては、ホスト側から渡しているTerminateTokenと、AddToを通してSubscriptionを登録していることにより制御されています。csxの評価としての実行が終わっていても、裏で生き続けている限り同じ参照を持っているので、ホスト側から干渉することが可能です。なので、ServiceのStopイベント時にはTerminateTokenにCancel命令をホストが出すことにより、Rxの残ってるBufferが送り出され、AddToで受け取っているSubscriptionを待つことにより、溜まったログの処理が完了するまで待機するといった、安全な終了処理を可能にしています。この辺はRxをフル活用してパイプライン組んだ成果ということで。</p>
<h2>再びエディタとしてのLINQPad</h2>
<p>さて、csxで書けるところのイイトコロはC#なのでコンパイルエラーも検出できるしシンタックスハイライトもあるし、などなど、なのですが、エディタサポートは……。Visual Studio 2015のUpdate 1によって確かにシンタックスハイライトはついた、が、それだけ……。IntelliSenseもDLL読み込ませたり色々しなければなので実質使えないみたいなもので厳しい……。</p>
<p>そこで出てくるのがLINQPad。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11766813/037c7376-a1db-11e5-9f74-8b4aeec20c5b.png" alt="image" /></p>
<p>EtwStream.LINQPadには、EtwStream.Serviceのcsxで渡されてくるEtwStreamServiceクラスのShim成分が入っているので、csxと互換性があって、LINQPadで実際にコンパイルできる/動かして確認した結果をcsxに持っていくことが可能です。（というようなことが出来るようにAPIを調整したんです……）。C# Interactiveが使い物にならならいなら使い物になるまで我慢する、のではなくて、一時凌ぎでもなんでも、他の現実的な解法を探すのが正すぃ。クソだクソだと文句だけ言ってても何も動きませんしね。必要なのは今この場でどうするか、それだけ。</p>
<h2>Topshelf</h2>
<p>Windowsサービスの実装には<a href="https://github.com/Topshelf/Topshelf">Topshelf</a>というライブラリを用いています。これは、最高に良いです。もはやこれなしでWindowsサービスを実装するのは考えられません！Visual Studioのテンプレートからふつーにサービスを作ると、なんかゴチャゴチャしたのが吐かれてよくわからない上に実行も面倒だし（いちいちinstallしたくないでしょ？）デバッグも困難だし、実にヤバい最低な開発環境。Topshelfで作るとコンソールアプリケーションと同じ感覚で作れます。また、成果物のexeは、そのまんまふつーにコンソールアプリケーションとしても動くので、EtwStream.Serviceの場合、ビューアーとしてLINQPadを要求していましたが、EtwStream.Service.exeを実行すれば普通にビューアーになります(csxで書き出し先をConsole(LogToConsole)にすれば色分けもしてくれる）。サービスとしてのインストールは「install」をつけて実行するだけ。素晴らしい。</p>
<p>日本語では<a href="https://84zume.wordpress.com/2014/03/23/topshelf/">Windowsサービスを楽に開発～TopShelf～</a>や<a href="http://tech.guitarrapc.com/entry/2015/05/13/015406">TopShelf によるWindowsサービスの配置をDSCで自動化してみよう</a>に説明ありますが、本当に簡単なので、サービスを作る機会がある人は是非使ってみてください。超お薦め。</p>
<h2>ファイル出力時のロガーのパフォーマンス</h2>
<p>今回ロガーを全部自作する都合上、さすがに単純なファイル書き出しと、ローテーションするファイル書き出しは用意しとかないとなぁ、ということで作ったんですが(FileSink, RollingFileSink)、作ってる上でなんとなく気づいたことなど。</p>
<p>そもそもファイルに吐くっていうこと自体がレガスィーで好きじゃないんですが、それはそれとしてもやはり重要なのは間違いありませんし、普通に使います。で、特にInProcessでのロギングの場合、これに気を配らないと普通にパフォーマンス上のボトルネックになってしまったりするわけですねー。さて、で、パフォーマンスは設定が全てです。とりあえず、バッファリングと非同期の二つのオプションを探しましょう。まず、ファイルに吐く場合のパフォーマンスはバッファするかしないかで全く変わるし、逆にバッファさえすればよほどタコな実装じゃない限りはそんな差はなくふつーに性能出ます（多分）。もう一点はasyncですね、これは別に大抵は非同期I/Oじゃなくて別スレッドで書くってだけのパターンなんですが、これが有効だとロガーの動作がアプリケーション自体に一切影響しなくなりますので。まぁバッファを有効にしてれば、例えば1000件に一回書く設定だったら1/1000回以外は書き込み処理に時間喰われることはなくなるので、ほぼ無視できてあってもなくても大差なくなるんですが、（起こるかもしれない）ちょっとしたスパイクは抑制できるかもしれません。また、あえてバッファはオフにしてasyncだけオン（+即時Flush)にすれば、ログが中々Flushされなくてリアルタイムで確認したいのにイライラ、というのがなくなって良いかもしれません。この辺は好みとか要件しだいで。</p>
<p>とりあえず言えるのはデフォの設定がどうなってるかはともかく、ノーバッファでノーエーシンクだと当然のように遅いです。更に設定によってはファイルストリームを都度閉じるか開きっぱがオプションになってるものもありますが、これは当然、開きっぱじゃないとゲロ遅いです。そういう項目がオプションにある場合は注意しましょう。デフォが都度閉じるだったりしてね……(NLogがそうです。NLogのデフォルトは安全寄りに倒し過ぎでパフォーマンスがヤヴァいことになってるので、NLog使う場合はそれなりに弄ったほうがいいでしょう。かといって他のロガーもそう変わりはなくて、大抵はそれなりに弄らないと遅いです）</p>
<p>かわりに、バッファや非同期ってのはログの消失の危険性があります。書いた瞬間には保存されてないってことですからね、アプリケーション終了への耐性が低くなります。気の利いたロガーは、可能な限り、終了を検知して(AppDomainが消える時のイベントとかをハンドリングして)、残ってるバッファを出力しに行ったり非同期の終了を待機しに行ってくれたりはしますが、パーフェクトではありません。例えば<a href="https://msdn.microsoft.com/en-us/library/system.appdomain.processexit.aspx">AppDomain.ProcessExit</a>のタイムアウトは既定で2秒です。2秒以内にフラッシュが完了する保証はないわけで、そこで完了できなければログロストです。</p>
<p>それを避けるには、「パフォーマンス低下を承知してバッファや非同期オプションを使わない」というのも手ですが、EtwStreamは更に2つの選択肢を提供してます。一つは「Out-Of-Process Serviceでのログ収集」。ETWへのログ出力はほぼノーコストで即時に吐けるのでアプリケーションへの影響は一切無い上に、それを外部サービスで取り出せば、出力側の終了の影響を全く受けません。ただし当然、受け取る側の外部サービスが死んだらロストするという危険性はありますがね！そこに関しては知らんがなというかshoganaiというか精一杯堅牢性を高めますとしか言い様がないですにぇ。</p>
<p>もう一つは、プログラム的に終了が完全に待機できるSubscriptionシステム。もともとEtwStreamは設定をC#で、Rxで書く必要があるので、購読状態に関して100%コントロールできます。というわけでその辺に仕掛けを入れといて</p>
<pre><code class="language-csharp">static void Main()
{
    // ApplicationStartの部分でこの2つを用意する
    var cts = new CancellationTokenSource();
    var container = new SubscriptionContainer();
    
    // でログの設定する
    ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
        .Buffer(TimeSpan.FromSeconds(5), 1000, cts.Token)
        .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
        .AddTo(container);
        
    // --- 実際にアプリが動いてる部分 --- //
        
    // アプリが終了した時のイベントのところでハンドリングする(Form_ClosedでもApplication_Endでもなんでもいいですが)
    cts.Cancel(); // CancellationTokenのCancelによりBufferの残りが吐き出される
    container.Dispose(); // Subscriptionの完了を待機する
}
</code></pre>
<p>といった風にすれば、100%コントロールされて停止時のログ処理を完了させられます。csxでもEtwStreamService.TerminateTokenとか渡していたのと同じことをやればいいということで。</p>
<p>100%コントロールできる代わりに、逆にEtwStreamは自分でコントロールしないかぎりは、気の利いた終了の検知とか組み込んでないので、待たなければふつーにバッファは消えます。これに関しては、10年前はゴテゴテとブラックボックスの中で気の利いたことをしてくれるのが正義だったかもしれませんが、2015年の現代では仕組みはシンプルに、薄くしたうえで、自分でコントロールさせるのが正義だと思ってます。そういう流儀。どっちが正しいってこともないですが、まぁ、今風なんじゃないかな？</p>
<p>ついでに言えば、EtwStreamのFileSinkやRollingFileSinkのパフォーマンスはバッファしてる前提同士で比較しても、他のよりも高い性能を誇ります。理由は幾つかあって、そもそも性能を意識して書いてるから。というのと、.NET 4.6以外をサポートする気がないのでasync/awaitやTPL全開でコードを書いてるから。オプション自体も同期処理は一切なくて、書き出しは非同期I/Oのみに限定などの割り切り。そして、通常はログフォーマット整形などに独自テンプレート的なのを挟まなきゃいけないところを、csxのお陰でFuncで処理できるため、そもそもコードパスに一切のオーバーヘッドがない。C# Scriptingによるコンフィグはパフォーマンスにも寄与するわけです。</p>
<p>しかしまぁ、Javaでは<a href="https://github.com/Netflix/blitz4j/wiki/Blitz4j-at-a-glance">Blitz4j</a>や<a href="http://logging.apache.org/log4j/2.x/manual/async.html">log4j2のAsynchronous Logger</a>などのスピード競争があるのに、.NETの牧歌的なこと、といった感じは否めませんねぇ。そんなだから私のとりあえずの雑実装でもfastestになってしまうわけで……。</p>
<h2>出力先</h2>
<p>EtwStreamが提唱するのは構造化ログ(Structured/Semantic Log)ですし、テキストログが終着点ではありません！テキストログは無視して、構造化されたペイロードを、そのまま<a href="https://azure.microsoft.com/ja-jp/services/event-hubs/">Azure EventHubs</a>や<a href="https://aws.amazon.com/jp/kinesis/">Amazon Kinesis</a>、<a href="https://cloud.google.com/bigquery/">Google BigQueryのStreaming Insert</a>に流して、ただたんに溜めるのではなくて、即座に分析可能な状態にするのが理想形です。特にお薦めなのは、というか弊社で使ってるのはGoogle BigQueryです。事例として<a href="http://googlecloudplatform-japan.blogspot.jp/2015/12/google-cloud-platform-using-csharp.html">株式会社グラニの Google Cloud Platform 導入事例: 「using CSharp;」という軸と BigQuery の活用で、先進性を求め続ける。</a>を掲載してもらいました:)</p>
<p>今のとこEtwStream用のBigQuerySinkはないんですが（！）そのうち公開するかされるかするんじゃないでしょーか多分きっと。（本当はそれも作って持ってきたかったんですがもう完全に時間切れでして、すでに大遅刻だし……）。そういえばあとFromTraceEventでRegisteredTraceEventが取れるようになりました。これはつい数日前のTraceEventライブラリのアップデートでそうなったから、というだけなんですが、今まで取れてなかったんですよねー。これで大丈夫。というのと、SLABのOut-of-Process Serviceじゃダメな理由に.NET 4.6からEventSourceに追加されたself-describing events（超重要！）に対応してないとか色々あるんですが、そういった話はまたの機会にでも。</p>
<h2>まとめ</h2>
<p>ロガーの未来はこうあるべきだ、という構想自体は1年以上前からあったんですが、Roslyn C# Scripting APIが正式リリースされてやっと作れた！あと、基本的にはMicrosoft Patterns &amp; Practicesの<a href="https://github.com/mspnp/semantic-logging">Semantic Logging Application Block(SLAB)</a>の影響が濃くはあるんですが、更新されなすぎだし、v3はElastic Search + LogStash + Kibana on Azureとか言ってて、マジで終わってるなという感じでもはや見限るしかない……。P&amp;Pは相変わらず本当にやっぱダメですねーという残念さ加減。なにがPatterns &amp; Practicesだよっていう。</p>
<p>csxでコンフィグするライブラリとして<a href="https://github.com/config-r/config-r">ConfigR</a>というのがあるんですが、XMLをcsxで置き換えるだけじゃ、あんま意味がないかな。必要なのは、コンフィグができることじゃなくて、それそのものが実行されて自走することだというのに気づいたので、使うことはなかったし、多分他のアプリケーションでもConfigRを使うことはないと思います。XMLはいうて設定ファイルとしては悪くないんですよねー、XSLTなんかもやり過ぎなければ良い機構ですし。逆にJSONを設定ファイルとして使うのは最低最悪なチョイス(なのでDNXへのやる気が0.1ミリも起きない)</p>
<p>何れにせよ、徐々にではあるでしょうが、csxの面白い活用例というのはどんどん出てくるのではないかと思います、と言いたいんですがfsxが別に対して面白い活用はされてないことを考えるとそんなに出てこないかもしれませんね、とも思いますが、いえいや面白い活用例はやっぱ出てくるかもしれません。batをcsxにしましたとかってだけだと別に面白くもないし意味もそんなにないですからねー、まぁあってもいいけど。もっと本質的に変わるような事例が増えてくれれば何よりです。</p>
</div>
<h1><a href="https://neue.cc/2015/12/03_521.html">Unity 5.3のMulti Scene EditingをUniRxによるシーンナビゲーションで統合する</a></h1>
<ul class="date"><li>2015-12-03</li></ul>
<div class="entry_body"><p>今回は<a href="http://qiita.com/advent-calendar/2015/unity">Unity Advent Calendar 2015</a>のための記事になります。昨日はtsubaki_t1さんによる<a href="http://tsubakit1.hateblo.jp/entry/2015/12/02/212958">Unity初心者を脱するためのデバッグ入門…的なやつ</a>でした。私はとりあえずVisual Studioでアタッチしてステップ実行、でしょうか……。最近はiOSのIL2CPPのスタックトレースが行番号出してくれなくて禿げそうというのが<a href="http://grani.jp/">社内</a>のホットトピックスらすぃ。</p>
<p>去年もUnity Advent Calendarには参加していて、その時は<a href="http://neue.cc/2014/12/18_499.html">Unityのコルーチンの分解、或いはUniRxのMainThreadDispatcherについて</a>という内容でした。今回も引き続き、私の作成している<a href="https://github.com/neuecc/UniRx">UniRx - Reactive Extensions for Unity</a>のお話ということでお願いします。とはいえ、中身的にはMulti Scene Editingや、シーン間での引数渡しをやるのにどうすればいいのか、みたいなところなので、Rxのメソッドは特に説明なくバンバン出てきますが、Rxワカラナイ人はそのへんは雰囲気で流し読みしてもらって、シーン遷移についてのお話を読み取ってもらえれば嬉しいですねん。</p>
<h2>Multi Scene Editing</h2>
<p>Multi Scene Editingは初出が<a href="http://blogs.unity3d.com/jp/2014/08/04/multi-scene-editing/">2014/8/4のUnity Blogの記事</a>でしょうか、1年経ってやっと正式リリース、までまもなく！ですね、5.3から搭載されることになりました。実際どういうことになるかというと、ヒエラルキーウィンドウがこんな感じに。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11536347/744ba910-995b-11e5-8c55-fe18368d3c69.png" alt="image" /></p>
<p>シーン加算で読み込んだシーンがヒエラルキー上でもきっちり分けられます。DontDestroyOnLoadがついたものは専用のところに隔離される。シーンを削除する場合も、そのまま指定してサクッと消したり、マージできたりと、随分とシーン管理がやりやすくなりました。Unity 5.3からはいよいよシーン加算で管理する時代が到来する！</p>
<p>コード的にはUnityEngine.SceneManagement.SceneManagerに全部のAPIがつまってます。基本的にはLoadScene/Asyncか、UnloadSceneぐらいで事足りるのではないでせうか。</p>
<pre><code class="language-csharp">// SceneA -&gt; SceneBへボタン押したら加算
// 別にRx使う必要性はないけど無駄に使うエディション
button.OnClickAsObservable()
  .SelectMany(_ =&gt; SceneManager.LoadSceneAsync(&quot;SceneB&quot;, LoadSceneMode.Additive).AsObservable())
  .Subscribe(_ =&gt; { /* 完了時の処理何かあれば */ });
</code></pre>
<p>この程度だとRx使う必要性はゼロですが、一応、LoadSceneAsyncの戻り値であるAsyncOperationはAsObservableで直接サクッとRx的に変換可能です。</p>
<h2>シーン間に引数を渡す</h2>
<p>どういうこっちゃって話ですが、新しいシーンに遷移なり加算したいってことは、引数を渡したくて然りだと思うのです。そのシーンを表示する際の初期引数が。例えばアイテム一覧画面から、アイテムの詳細画面を出すなら、アイテムのIDを渡したいよね、とかね。別にAndroidやiOSアプリでも、ウェブのURLのクエリストリングなりなんなりでも、そんなのは普通によくある話です。さて、SceneManagerはその辺りのことは、別になにも面倒みてくれません。じゃあグローバル変数を経由してやりとりするのかというと果てしなくビミョウというかスパゲティ化まったなし。せっかく画面画面がシーンで独立しているなら、値の依存関係もシーン内に抑えてやりたい。</p>
<p>というわけで、遷移/加算時に引数を渡せるシーン遷移機構を作りましょう。</p>
<p>材料として使うのはUniRxの<a href="https://github.com/neuecc/UniRx#presenterbase">PresenterBase</a>です。これは何かというと、子要素の初期化の順序をコントロールするのと、値の受け渡しができる仕組みです。ご存知のとおりUnityのGameObjectの初期化順序は不定(Execution Orderでおおまかに指定できるけど、細かいコントロールのために使うものではない)ですが、PresenterBaseの管理下におくことで、Startフェーズにて決められた順序で起動するようにコード上で設定できます。</p>
<p>この性質は、シーンに引数が渡される、つまり全てのルートになるという条件にぴったりです！というわけで、引数を受け取るための基底クラス、SceneBaseをPresenterBaseを継承して作りましょう。</p>
<pre><code class="language-csharp">public abstract class SceneBase : PresenterBase
{
    // これがシーン遷移時にセットされる引数を表す
    public object Argument { get; set; }

    // 受け渡されたかどうかを管理するフラグ
    public bool IsLoaded { get; set; }

    protected override void OnAwake()
    {
        // 初期化が完了した際はロード済みと強制的にマークするおまじない
        this.InitializeAsObservable().Subscribe(_ =&gt; IsLoaded = true);
    }
}
</code></pre>
<p>こんなもので、割とあっさりめに。実際のシーンのクラスは</p>
<pre><code class="language-csharp">// このどうでもいいクラスを引数として渡していくということにする
public class Nanika
{
    public int HogeHoge { get; set; }
    public string Hugahuga { get; set; }
}

// 遷移元クラス、適当なボタン押したらSceneBに遷移する
public class SceneA : SceneBase
{
    public Button button;

    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize()
    {
    }

    protected override void Initialize()
    {
        button.OnClickAsObservable().Subscribe(_ =&gt;
        {
            // 直接SceneManager.LoadSceneAsyncを呼ぶのではなく、
            // 独自に作成したNavigationService.NavigateAsync経由で引数を渡して遷移/加算する
            var arg = new Nanika { HogeHoge = 100, Hugahuga = &quot;Tako&quot; };
            NavigationService.NavigateAsync(&quot;SceneB&quot;, arg, LoadSceneMode.Additive).Subscribe();
        });
    }
}

// 遷移先クラス、Argumentに引数が渡されてきてる
public class SceneB : SceneBase
{
    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize()
    {
    }

    protected override void Initialize()
    {
        // 前のシーンから渡された引数が取れる
        var arg = Argument as Nanika;
        Debug.Log(&quot;HogeHoge:&quot; + arg.HogeHoge + &quot; HugaHuga:&quot; + arg.Hugahuga);
    }
}
</code></pre>
<p>ちょっと長いですが、言いたいのは遷移元ではNavigationService.NavigateAsyncを使って引数を渡して遷移先を指定する。遷移先ではArgumentに渡されたものをキャストして取り出す。といった感じです。</p>
<p>作る上での制約としては、必ず各シーンに単一のSceneBaseがヒエラルキーの頂上にある必要があります。こんな感じに。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11538085/95c4fdfa-9963-11e5-95f4-9b4c1024bfc6.png" alt="image" /></p>
<p>うーん、随分と大きな制約であり不格好ですね……、この手の制約は実際のトコ、ないほうが望ましいです。別に、この手のヘンテコな制約をつけるのがアーキテクチャ、ではないです。自由なほうがよほど良いのです。とはいえしかし、どうにもならなかったので、そこは受け入れるしかなかったということで。この辺が今のところの手札でできる精一杯の形かなぁ。</p>
<h2>NavigationService</h2>
<p>では、肝心要のNavigationServiceの実装を見ましょう！</p>
<pre><code class="language-csharp">public static class NavigationService
{
    public static IObservable&lt;Unit&gt; NavigateAsync(string sceneName, object argument, LoadSceneMode mode = LoadSceneMode.Single)
    {        
        return Observable.FromCoroutine&lt;Unit&gt;(observer =&gt; HyperOptimizedFastAsyncOperationLoad(SceneManager.LoadSceneAsync(sceneName, mode), observer))
            .Do(_ =&gt;
            {
                // 型ベースでたぐり寄せる。Find系は避けたいとはいえ、シーン遷移時に一発だけなのでコスト的には許容できるでしょう。
                var scenes = GameObject.FindObjectsOfType&lt;SceneBase&gt;(); 
                var loadedScene = scenes.Single(x =&gt; !x.IsLoaded); // 一個だけになってるはず #雑
    
                loadedScene.IsLoaded = true;
                loadedScene.Argument = argument; // PresenterBase.BeforeInitializeが走る前にセットする
            });
    }
    
    static IEnumerator HyperOptimizedFastAsyncOperationLoad(AsyncOperation operation, IObserver&lt;Unit&gt; observer)
    {
        if (!operation.isDone) yield return operation;
    
        observer.OnNext(Unit.Default);
        observer.OnCompleted();
    }
}
</code></pre>
<p>なんてことはなく、LoadSceneAsyncが完了した時点でヒエラルキーに新しいシーンがぶちまけられているので、それのBeforeInitializeが走る前にArgumentにセットしておいてやる、というだけの割と単純なものです。ポイントは、BeforeInitializeの走るタイミングはStartということです。順序的に、LaodSceneAsyncが完了した時点で、新しいシーンのGameObjectのAwakeは走っています。なので、Awakeの前にArgumentを渡すのは何をどうやっても不可能です。しかし、Startの前に割り込むことは可能です。そこでルールとして遷移先のシーンでの初期化はStart以降に限定し(PresenterBaseがその辺を抽象化しているので実装者が意識する必要はない)、NavigateAsyncでは可能な限り最速のタイミングでArgumentをセットしにいきます。その秘訣がHyperOptimizedFastAsyncOperationLoadというフザケタ名前のコルーチンです。</p>
<h2>yield return null vs yield return AsyncOperation</h2>
<p>別にHyperOptimizedFastAsyncOperationLoadの中身は、見たまんまの超絶単純な yield return AsyncOperation です。そして、それこそが秘訣なのです。何を言ってるかというと……</p>
<pre><code class="language-csharp">IEnumerator WaitLoadAsyncA(AsyncOperation operation)
{
    while (!operation.isDone)
    {
        yield return null;
        Debug.Log(operation.progress); // 読み込み状態のプログレス通知
    }
}

IEnumerator WaitLoadAsyncB(AsyncOperation operation)
{
    yield return operation;
}
</code></pre>
<p>両者の違い、分かるでしょうか？ WaitLoadAsyncA のほうはプログレスを受け取るためにyield return nullでisDoneを監視するスタイル。WaitLoadAsyncBは直接待つスタイル。結果的に、どちらも待つことができます。プログレス通知は大事なので、WaitLoadAsyncAのようなスタイルを多用するほうが多いのではないかなー、と思います。WWWとか。が、しかし、両者には非常に大きな違いがあります。それは、完了時のタイミング。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11539070/9843e5a0-9968-11e5-82e7-58964692f6b2.png" alt="image" /></p>
<p>わざわざ無駄に画像を作ってまで声を大にして言いたいんですが、直接AsyncOperationをyieldすれば、AwakeとStartの間に割り込めます。yield return nullでは普通に1フレ後になるのでStartまで完了しちゃってます。これは超絶デカい違いです、この微妙なコントロールが死ぬほど大事です。きっと役に立ちます。どこかで。ちなみに一番最初に説明したAsyncOperation.AsObservableという神メソッドはyield return nullで待ってます。クソですね。カスですね。ゴミですね。すみません……（これは次のUniRxのリリースではプログレス通知を使わない場合は直接yieldするように変更します、それまでの間は手動コルーチン作成で対応してください）</p>
<p>もう一つ、コルーチンの駆動を各SceneのStartCoroutineで行うと、LoadSceneMode.Single（遷移）の場合、遷移元シーンが破壊された瞬間に紐付いてるコルーチンも強制的に止まる（そしてDestroyは遷移先シーンのAwakeの前）ため、Argumentを渡すという行為は不可能です。が、UniRxのFromCoroutineで駆動させると、中立であるMainThreadDispatcherによるコルーチン駆動となるため、元のシーンが壊れるとかそういうのとは無関係にコルーチンが動き続けるため、その手の制限と付き合わなくても済みます。この辺は実際UniRx強い。</p>
<h2>シーン表示を遅らせる</h2>
<p>実は、今のとこ別にRx使う必要性はあんまありません、なくても全然出来るレベルです（まぁコルーチンが破壊される件は回避しにくいですが）。それではあんまりなので、もう一歩次のレベルに行きましょう。例えばシーン遷移時に、引数を元にネットワークからデータを読み取って、その間はNow Loadingで待つ。ダウンロードが完了したら表示する。こうした、なんとなく良くありそうな気がする話を、NavigationServiceで対応させてみましょう。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11540034/cba474f0-996d-11e5-9089-1e1d63c1611d.gif" alt="animation" /></p>
<p>この、あんまり良くわからない例、SceneAボタンを押すとヒエラルキーにSceneBが表示されているけれど画面上には表示されていない、実際にはネットワークからデータをダウンロードしていて、それが完了したら、その結果と共にSceneBが表示される。というものです。なるほど……？</p>
<p>まず、SceneBaseにPrepareAsyncメソッドを追加します。</p>
<pre><code class="language-csharp">public abstract class SceneBase : PresenterBase
{
    public object Argument { get; set; }
    public bool IsLoaded { get; set; }

    // このPrepareAsyncメソッドを新設する
    public virtual IObservable&lt;Unit&gt; PrepareAsync()
    {
        return Observable.Return(Unit.Default);
    }

    protected override void OnAwake()
    {
        this.InitializeAsObservable().Subscribe(_ =&gt; IsLoaded = true);
    }
}
</code></pre>
<p>PrepareAsyncが完了するまで表示を待機する、といった感じで、それをIObservableによって表明しています。これで遷移先のSceneBクラスを書き換えると</p>
<pre><code class="language-csharp">public class SceneB : SceneBase
{
    public WwwStringPresenter display; // インスペクターから貼り付けてUnityEngineによるデシリアライズ時にセットされる(Awake前)

    string wwwString = null;

    protected override IPresenter[] Children
    {
        get { return new[] { display }; } // Sceneにぶら下がってる子をここで指定する（コードで！原始的！）
    }

    // 呼ばれる順番はPrepareAsync -&gt; BeforeInitialize -&gt; Initialize

    public override IObservable&lt;Unit&gt; PrepareAsync()
    {
        var url = Argument as string; // 前のシーンからURL、例えば http://unity3d.com/ が送られて来るとする

        // ネットワーク通信が完了するまでこのシーンの表示を待機できる
        // (もし自分で試して効果が分かりにくかったら Observable.Timer(TimeSpan.FromSeconds(5)) とかに差し替えてください、それで5秒後表示になります）
        return ObservableWWW.Get(url)
            .Select(x =&gt; // 本当はForEachAsyncを使いたいのですがまだ未リリース。
            {
                wwwString = x; // 副作用さいこー
                return Unit.Default;
            });
    }

    protected override void BeforeInitialize()
    {
        // この時点で通信が完了してるので、小階層に渡す。
        display.PropagateArgument(wwwString); // PresenterBase.PropagateArgumentで伝搬するルール
    }

    protected override void Initialize()
    {
    }
}
</code></pre>
<p>変えたところは、PrepareAsyncでWWW通信を挟んでいるところ。これが完了するまではシーン全体の表示が始まらない(BeforeInitializeが呼ばれない)です。表示に関しては、この程度の超絶単純な例では直接SceneBにTextをぶら下げたほうがいいんですが、無駄に複雑にするために、ではなくてPropagateArgumentの例として、もう一個、下にUI要素をぶら下げてます。それがWwwStringPresenterで、</p>
<pre><code class="language-csharp">public class WwwStringPresenter : PresenterBase&lt;string&gt;
{
    public Text displayView;

    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize(string argument)
    {
    }

    // 親からPropagteArugmentで渡されてくる
    protected override void Initialize(string argument)
    {
        displayView.text = argument;
    }
}
</code></pre>
<p>こんな感じに、親(この場合だとSceneB)から値が伝搬されます、適切な順序で（ふつーにやってるとGameObjectの生成順序は不定なので、値の伝搬というのは単純なようで深く、やりようが色々あるテーマだったり）。さて、一見複雑というか実際、色々ゴテゴテしてきてアレな気配を醸しだしてきましたが、実際どんな状態なのかというと、こんな感じ。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11540561/c1077148-9970-11e5-9d7b-dd94350d8979.png" alt="image" /></p>
<p>この分かったような分からないような図で言いたいことは、値の流れです。シーン間はNavigateAsyncによりArgumentが引き渡され、シーン内ではPresenterBaseによって構築されたチェーンがPropagateArgumentにより、ヒエラルキーの上流から下流へ流れていきます。これにより、グローバルでの変数保持が不要になり、値の影響範囲が局所化されます。スコープが狭いというのは基本的にいいことです、見通しの良さに繋がりますから。分かっちゃいても実現は中々むつかしい、に対する小道具を色々揃えておくと動きやすい。</p>
<h2>NavigateAsync最終形</h2>
<p>おお、そうだ、PrepareAsyncに対応したNavigateAsyncのコードを出し忘れている！こんな形になりました。</p>
<pre><code class="language-csharp">public static class NavigationService
{
    public static IObservable&lt;Unit&gt; NavigateAsync(string sceneName, object argument, LoadSceneMode mode = LoadSceneMode.Single)
    {
        return Observable.FromCoroutine&lt;Unit&gt;(observer =&gt; HyperOptimizedFastAsyncOperationLoad(SceneManager.LoadSceneAsync(sceneName, mode), observer))
            .SelectMany(_ =&gt;
            {
                var scenes = GameObject.FindObjectsOfType&lt;SceneBase&gt;();
                var loadedScene = scenes.Single(x =&gt; !x.IsLoaded);

                loadedScene.IsLoaded = true;
                loadedScene.Argument = argument;

                loadedScene.gameObject.SetActive(false); // 一旦非Activeにして止める

                return loadedScene.PrepareAsync() // PrepareAsyncが完了するまで待つ
                    .Do(__ =&gt;
                    {
                        loadedScene.gameObject.SetActive(true); // Activeにして動かしはぢめる
                    });
            });
    }

    static IEnumerator HyperOptimizedFastAsyncOperationLoad(AsyncOperation operation, IObserver&lt;Unit&gt; observer)
    {
        if (!operation.isDone) yield return operation;

        observer.OnNext(Unit.Default);
        observer.OnCompleted();
    }
}
</code></pre>
<p>足したコードは、Argumentをセットしたら即座にSetActive(false)ですね。これで画面に非表示になるのは勿論、Startも抑制されます。そうしてStartが止まっている間にPrepareAsyncを呼んでやって、終わったら再度 SetActive(true) にする、ことによりStartが発生しだして、PresenterBaseの初期化機構が自動で上流→下流への起動を開始します。</p>
<h2>まとめ</h2>
<p>実際にはPrepareAsyncだけでは足りなくて、シーンから出る時、シーンから戻ってきた時、機能としてシーンをキャッシュしてやろうとか、遷移でパラメータ渡ってくる前提だと開発時にパラメータが足りなくてダルいので任意で差し込めるようにする/開発用デフォルト用意するとか、色々やれることはあります、し、やったほうがいいでしょふ。それらも全てUniRx上で、IObservableになっていることにより、表現がある程度は容易になるのではないかと思います。非同期を表現する入れ物、が必要だというのは至極当然の答えになるのですけれど、そこにUniRxが一定の答え、定番を提供できているんじゃないかなー、と思いますね！些か長い記事となってしまいましたが、これに限らず応用例の発想に繋がってくれれば何よりです。</p>
<p>Advent Calendarの次は、<a href="http://qiita.com/Miyatin">@Miyatin</a>さんです！</p>
<h2>UniRx vNext</h2>
<p>ところで実はいまものすごい勢いで作り変えています！性能もかなり上が（って）るんですが、割と分かりやすく大きいのは、スタックトレースが物凄く見やすくなります。意味不明度が極まった複雑なスタックトレースはRx名物でデバッガビリティが最低最悪だったのですが、相当まともになってます。例えば、以下の様なふつーのチェーンのDebug.Logで表示されるスタックトレースは</p>
<pre><code class="language-csharp">var rxProp = new ReactiveProperty&lt;int&gt;();
rxProp
    .Where(x =&gt; x % 2 == 0)
    .Select(x =&gt; x)
    .Take(50)
    .Subscribe(x =&gt; Debug.Log(x));

rxProp.Value = 100;
</code></pre>
<p>Before</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11541721/187fc69a-9977-11e5-86f3-b0c2f1938a4a.png" alt="image" /></p>
<p>After</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11541619/7d07daea-9976-11e5-8c5b-9e0a7414b57c.png" alt="image" /></p>
<p>劇的！Unityのスタックトレースの表示形式に100%フォーカスして、読みやすさ第一にハックしたので、圧倒的な読みやすさだと思います。スタックトレース芸極めた。普通にWhere.Select.Take.Subscribeがそのまま表示されてますからね。勿論、メソッドコール数が減っているのは単純に性能にも寄与しています。ここまでやれば文句もないでせう。</p>
<p>そんなvNextの完成時期ですが、今までやるやる詐欺すぎたのですが、そろそろ実際本当に出します。来週ぐらいには本当に出します。これは意地でも仕上げます（想像通りだけれど作業量は多いわコーナーケースの想定が複雑すぎて頭が爆発しそうになるしで辛い……）。というわけでもうちょっとだけ待っててください。</p>
</div>
<h1><a href="https://neue.cc/2015/11/03_520.html">EtwStream - ETW/EventSourceのRx化 + ビューアーとしてのLINQPad統合</a></h1>
<ul class="date"><li>2015-11-03</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/EtwStream">EtwStream</a>というのをリリースしました。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb968803.aspx">ETW(Event Tracing for Windows)</a> + <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.tracing.eventsource.aspx">EventSource</a>が.NETで構造化ログをやる際の決定版というか、ETWの最強度が高すぎてそれ以外考えられないレベルなんですが、しかし、がETWは最強な反面ビューアーがありませんでした。ETWというブラックホールにログを投げ込むのはいいんですが、それが自分自身ですら容易に見れないのは不便すぎる！PerfViewとか骨董品みたいなゴミUIを操ってなんとかして見るのは、無理ゲーなわけで、カジュアルにDumpしたいだけなんだよ！テキストのようなログビューアーが欲しいだけなんだよ！に対する答えです。いや、ほんと自分自身が死ぬほど欲しかったのが、これ。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10905625/cae5a122-825e-11e5-8def-d53feedb879d.gif" alt="etwstreamgif" /></p>
<p>インストールはLINQPadのNuGetで「EtwStream.LinqPad」。だけ。デフォルトにでも登録しとけばLINQPadを立ち上げるだけですぐにビューアーに！</p>
<p>EtwStreamが提供するのは、ETWをIObsevable[TraceEvent]に変換することです。Logs are streamsですから、そしてストリームといったらRxですから。あとは、LINQPadのDumpをそのまま流用して、色付けとか加えてあげただけです。フィルタリングしたい？グルーピングしたい？色々混ぜたい？そんなの全部Rxなんだから、ちょっとクエリ書けばいいだけなのです。最強の柔軟性がある。</p>
<pre><code class="language-csharp">Observable.Merge(
    ObservableEventListener.FromTraceEvent(&quot;LoggerEventSource&quot;),
    ObservableEventListener.FromTraceEvent(&quot;MyCompanyEvent&quot;),
    ObservableEventListener.FromTraceEvent(&quot;PhotonWire&quot;)
)
.DumpWithColor(withProviderName: true);
</code></pre>
<p>EventSourceの提供する構造化ログ(Structured Logging)に関しては<a href="http://www.buildinsider.net/column/kawai-yoshifumi/003">C#における構造化ログの手法、そしてデータ可視化のためのDomoの薦め</a>で書いたのでそっちを見てくださいな。そうしてEventSourceに移行した場合の最大の懸念であるビューアーがなさすぎ問題を、このEtwStreamが解決します。た。</p>
<p>ちなみについでにTailっぽくファイルもIObservable[string]に変換するObservableEventListener.FromFileTailもオマケとして入れといたので、そっちもそっちでログビューアー的に使うならきっとベンリ。</p>
<p>もしEventSourceを使ったロギングをやっていなくても、.NET標準組み込みの、例えばTplEventSourceあたりを眺めてみると、色々な挙動が見えて面白かったりします。あとFromClrTraceEventではGCやThraedPoolの挙動が見れたり、FromKernelTraceEventで普段絶対気にしないカーネルイベントが凄まじい勢いで流れて行ったりが簡単に観測できて、普通に勉強になります。オモチャとしてかなり良いと思いますねー。</p>
<h2>最初のEventSource</h2>
<p>EventSourceって何のことだかさっぱりわからん！という人におすすめなのが<a href="https://msdn.microsoft.com/en-us/library/dn440729.aspx">Logging What You Mean: Using the Semantic Logging Application Block</a>というMSDNに転がってるSLABのドキュメントです。これはさすがにひじょーによく書けてるしいいですね。あと、EtwStreamが提供してるのはObservableEventListenerだけで、ロガー的なファイル書き出しとかは一切ないので、そういうのやりたい人は普通にSLAB「も」使いましょう。という感じです。</p>
<p>さて、EventSourceですが、いきなり構造化ログってのもかなりダルいので、まずは非構造化ログをEventSourceで実現するところから初めてみましょう。いや実際それに、こういういのがちょっとあるとそれはそれでベンリでもありますし。</p>
<pre><code class="language-csharp">[EventSource(Name = &quot;LoggerEventSource&quot;)]
public class LoggerEventSource : EventSource
{
    public static readonly LoggerEventSource Log = new LoggerEventSource();

    public class Keywords
    {
        public const EventKeywords Logging = (EventKeywords)1;
    }

    string FormatPath(string filePath)
    {
        if (filePath == null) return &quot;&quot;;

        var xs = filePath.Split('\\');
        var len = xs.Length;
        if (len &gt;= 3)
        {
            return xs[len - 3] + &quot;/&quot; + xs[len - 2] + &quot;/&quot; + xs[len - 1];
        }
        else if (len == 2)
        {
            return xs[len - 2] + &quot;/&quot; + xs[len - 1];
        }
        else if (len == 1)
        {
            return xs[len - 1];
        }
        else
        {
            return &quot;&quot;;
        }
    }

    [Event(1, Level = EventLevel.LogAlways, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void LogAlways(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(1, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(2, Level = EventLevel.Critical, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Critical(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(2, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(3, Level = EventLevel.Error, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Error(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(3, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(4, Level = EventLevel.Warning, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Warning(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(4, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(5, Level = EventLevel.Informational, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Informational(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(5, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(6, Level = EventLevel.Verbose, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Verbose(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(6, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(7, Level = EventLevel.Error, Keywords = Keywords.Logging, Version = 1)]
    public void Exception(string type, string stackTrace, string message)
    {
        WriteEvent(7, type ?? &quot;&quot;, stackTrace ?? &quot;&quot;, message ?? &quot;&quot;);
    }

    [Conditional(&quot;DEBUG&quot;)]
    [Event(8, Level = EventLevel.Verbose, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Debug(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(8, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [NonEvent]
    public IDisposable MeasureExecution(string label, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        return new StopwatchMonitor(this, label ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(9, Level = EventLevel.Informational, Keywords = Keywords.Logging, Message = &quot;[{0}][{2}:{3}][{1}]{4}ms&quot;)]
    void MeasureExecution(string label, string memberName, string filePath, int line, double duration)
    {
        WriteEvent(9, label ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line, duration);
    }

    class StopwatchMonitor : IDisposable
    {
        readonly LoggerEventSource logger;
        readonly string label;
        readonly string memberName;
        readonly string filePath;
        readonly int line;
        Stopwatch stopwatch;

        public StopwatchMonitor(LoggerEventSource logger, string label, string memberName, string filePath, int line)
        {
            this.logger = logger;
            this.label = label;
            this.memberName = memberName;
            this.filePath = filePath;
            this.line = line;
            stopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            if (stopwatch != null)
            {
                stopwatch.Stop();
                logger.MeasureExecution(label, memberName, filePath, line, stopwatch.Elapsed.TotalMilliseconds);
                stopwatch = null;
            }
        }
    }
}
</code></pre>
<p>ちょっと長いですが、これで</p>
<pre><code class="language-csharp">LoggerEventSource.Log.Debug(&quot;ほげほげ!&quot;);
</code></pre>
<p>とか書いていくだけです。それを書いたアプリを、LINQPadでは</p>
<pre><code class="language-csharp">ObservableEventListener.FromTraceEvent(&quot;LoggerEventSource&quot;).DumpWithColor();
</code></pre>
<p>で、ファイルとかを通さずそのままストリームで外から観測できます。</p>
<h2>Logs are event streams</h2>
<p>脱ファイル。ちなみにETWで流したのは最終的にBigQueryに流すのが超おすすめですね！そして<a href="http://neue.cc/2015/10/25_519.html">LINQ to BigQuery + LINQPad</a>で解析する。完璧！これがC#の次世代ログのあるべき姿だ！と、オモイマス。というか逆にもう以前には戻れないかなあ、やっぱり世代が一つ変わった感あります、便利度が全然違うので。</p>
</div>
<h1><a href="https://neue.cc/2015/10/25_519.html">LINQPad Driver + LINQ to BigQueryによるBigQueryデスクトップGUIクライアント</a></h1>
<ul class="date"><li>2015-10-25</li></ul>
<div class="entry_body"><p>Happy signed！何かというと、長らく署名の付いていなかった<a href="http://google-api-dotnet-client.blogspot.jp/2015/07/announcing-release-of-192.html">Google APIの.NET SDKに署名が付いた</a>のです！署名が付くと何ができるかというと、<a href="http://www.linqpad.net/">LINQPad</a>のDriver(プラグイン)が作れます。LINQPadのDriverは署名なしだと起動できないので……。正直、私ももはや署名とか全然重視してないし100億年前の化石概念の負の異物だろ、ぐらいに思ってなくもないのですが、さすがに、LINQPad Driverを作れない、という事態には随分と嘆いたものでした。が、やっと作ることが出来て感無量。そして、実際動かしてみると相当便利ですね。これがやりたかったんですよ、これがー。</p>
<img src="https://cloud.githubusercontent.com/assets/46207/10714939/78e5bcb8-7b47-11e5-9262-c802040011f8.png" width=640 />
<p><a href="https://github.com/neuecc/LINQ-to-BigQuery">LINQ to BigQuery</a>のLINQPad Driverが可能にする範囲は、</p>
<ul>
<li>サイドバーでのスキーマのツリー表示</li>
<li>thisを読み込んでいるConnectionで認証済みのBigQueryContextに変更</li>
<li>関連するアセンブリと名前空間を自動で読み込み</li>
<li>スキーマに対応するクラスを動的に生成/読み込み</li>
<li>ちょっとしたユーティリティDumpの追加(DumpRun/DumpRunToArray/DumpChart/DumpGroupChart)</li>
<li>もちろんクエリのローカルでの保存/読み込みが可能</li>
</ul>
<p>です。元々のLINQ to BigQueryが提供している機能としては</p>
<ul>
<li>TableDateRangeに対するサポート</li>
<li>DateTimeの自動変換(一部のBigQueryの機能はUnix Timestampで書く必要があり、実質手で書くのは不可能なものもありましたが、自動変換により救われる）</li>
<li>結果セットをローカル時間に自動変換（基本的にUTCで帰ってくるので、ローカル時間で考える際に+9時間しなきゃいけなかったりしますが、C#側でデシリアライズする際にローカルタイムに自動変換する）</li>
<li>全てが型付きで入力補完が全面的に効く</li>
<li>全てのBigQuery関数の入力補完にドキュメント付き</li>
</ul>
<p>があって（この辺の詳しい話は以前に書いた<a href="http://neue.cc/2014/09/24_479.html">LINQ to BigQuery - C#による型付きDSLとLINQPadによるDumpと可視化</a>を見てください）、相乗効果でかなり強まったのではないでしょうか。</p>
<p>公式ウェブコンソールで叩くのとどっちがいいかといったら、まぁ私自身も結構、ウェブから叩くのは多かったりしますので、どっちでもいいといえばいいんですが、それもプラグインを作る前は……かしら。今後は私自身もLINQPad利用が増えるかなー。明らかにウェブから叩くのじゃ提供できない機能というか、素のBigQuery SQLじゃ中々できない機能を多く提供しているわけで、LINQPad + LINQ to BigQUeryにはかなりのアドバンテージがあります。</p>
<h2>Excel統合</h2>
<p>問答無用に愚直なExcel統合があります。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10721962/968632b4-7bee-11e5-9b48-904fcb48e75f.gif" alt="legendary_dump_to_excel" /></p>
<p>そう、DumpToExcel()で実行すると結果セットがダイレクトにExcelで開く……。しかし実際こういうのでいいんだよこういうので感あります。Excelでクエリ書く系の統合は面倒くさい（実際アレはダルいのでない）。いちいちCSVに落として開くのは面倒くさすぎる。LINQPadでクエリ書く、結果がExcelで見れる。あとはピボットテーブルなりで好きに分析できる。そう、そういうことなんですよ、これなんですよ #とは</p>
<h2>入れ方</h2>
<p>ExplorerのAdd Connection→View More Drivers からLINQ to BigQueryを探して、clickでインストールできます。簡単。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10785534/2fcc7f7c-7da8-11e5-9c29-4dc2486aeffe.png" alt="image" /></p>
<p>かなり上の方のいい位置に入れてもらいました！</p>
<h2>using static</h2>
<p>BigQueryの関数はLINQ to BigQueryではBqFunc以下に押し込める形をとっていますが、C# 6.0から(Javaのように)静的メソッドのインポートが可能になりました。また、LINQPad 5でもスクリプトのバックエンドがRoslynになり、C# 6.0にフル対応しています。LINQ to BigQueryのDriverでは、LINQPad 5以上に読み込ませた場合のみ、using static BigQuery.Linq.BqFunc が自動インポートされます。</p>
<p>これにより、クエリを書いた際の見た目がより自然に、というかウザったいBqFuncが完全に消え去りました！関数名を覚えていない、ウロ覚えの時はBqFunc.を押して探せるし</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10714748/f252b694-7b3f-11e5-9658-3bb81032e257.png" alt="image" /></p>
<p>慣れきった関数なら、直接書くことができる。完璧。</p>
<h2>How to make LINQPad Driver</h2>
<p>難しいようで難しくないようで難しいです。<a href="https://www.linqpad.net/extensibility.aspx">しっかりしたドキュメントとサンプル</a>が付属しているので、スタートはそれなりにスムーズに行けるかと思います。一つ、大事なのはプラグイン開発だからってデバッグ環境に妥協しないでください。ふつーの開発と同じように、F5でVisual Studioが立ち上がってすぐにブレークポイント貼ってステップ実行できる環境を築きましょう。細かいハマりどころが多いので、それ出来ないと挫けます。逆に出来てれば、あとは気合、かな……？細かいやり方はここに書くには余白が（以下略</p>
<p>変わったハマりどころとしては、例えば別々に呼ばれるメソッド間で変数渡したいなー、と思ってprivate fieldに置くと、そもそも都度頻繁にコンストラクタが呼ばれて生成されなおすので、共有できない。なるほど、じゃあせめてstatic変数だったらどうだろうか？というと、LINQPadの内部の実行環境の都合上、AppDomainがガンガン切られて飛んで来るので、static fieldすら消える！マジか！なるほどねー厳しいねー、などなど。</p>
<p>ちなみに動的なアセンブリ生成ではCodeDomのCSharpCodeProviderを利用しています。つい先月、<a href="http://neue.cc/2015/09/29_517.html">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a>でCodeDomはオワコン、使わないとか言ってたくせに！舌の根も乾かぬうちに自分で使うことになるとは思わなかった！</p>
<h2>まとめ</h2>
<p>社内でのBigQuery活用法として、定形クエリのダッシュボードは<a href="http://www.buildinsider.net/column/kawai-yoshifumi/003">Domoにより可視化</a>、アドホックなクエリはLINQPad + LINQ to BigQueryによりクエリを色々書いたり、そのままExcelに送り込んで(LINQPadはデスクトップアプリなので、DumpToExcel()メソッドとかを作ることによりシームレスに結果セットをExcelに投げ込んだりできるのも強い)PowerPivotでこねくり回したり、などをしてます。とはいえ、今までは事前にスキーマに対応するクラスを生成して保存しておかなければならないという面倒くささがあったので、イマイチ活用しきれてなかったのも事実。実際、私自身ですらBigQueryの公式ウェブコンソールでクエリ叩いたりが多かったですし。それが、今回のLINQPad Driverにより圧倒的に利便性が上がった（というか前のがもはや原始時代に見える）ので、使える度合いが桁違いに上がったんじゃないかなー、と思います。</p>
<p>デスクトップGUIクライアントの便利さは、例えばMySQLだったらウェブでphpMyAdminよりもHeidiSQLやMySQL Workbenchのほうが100億倍便利なわけでして、良いところ沢山あるんですよね。BigQuery関連だと<a href="https://cloud.google.com/datalab/">Cloud DataLab</a>なんかもちょうど出ましたが、ウェブとデスクトップ、それぞれ良さがあるので、ここはうまく使い分けていきたいところです。</p>
<p>最近のBigQueryのアップデートへの追随だと、新メソッドは全部実装が完了してます。また、GroupByへのRollupなど文法の追加もOK。ただ、大きな目玉であるUDF(User Defined Function)への対応がまだです。別にそんな難しくもないんですが、APIの馴染ませ方どうしようかな、とか思ってる間にLINQPad Driverの作成に時間喰われたので、対応入れるのは近いうちの次回ということで。</p>
</div>
<h1><a href="https://neue.cc/2015/10/23_518.html">同期（風）コードと対比させたUnity+UniRxで非同期を扱う場合のパターン集</a></h1>
<ul class="date"><li>2015-10-23</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx/">UniRx</a>のGitHubのStar数が500行きました！</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10682950/165b9eea-7977-11e5-87ec-9b98269e912a.png" alt="image" /></p>
<p>今のところGitHub上での<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93">Unity + C#</a>でスター順の検索だと、世界5位です。おおー。更に上を狙いたいところですね。最近はちょっと更新が滞っていますが、ネタはあるのでより完成度を高めたい。(滞った理由は、<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>とか色々他のところに手を出していたため……)</p>
<p>さて、本題。イベント結合に使う際はあてはまりませんが、Rx(<a href="https://github.com/neuecc/UniRx/">UniRx</a>)を非同期（長さ1のIOservableシーケンス)として扱う場合、それなりに癖があります。とはいえ、基本的には同期（或いはyield return)で書いていた際と、1:1で対比できるパターン化した形で概ね対応できるので、そのためのチートシートを考えてみました。コード例はC# 5.0のasync/awaitで出しますが、同期コード or IEnumeratorと同じように思ってもらえればいいです。例えば</p>
<pre><code class="language-csharp">public void Sync()
{
    /* before action */
    Method();
    /* after action */
}

public IEnumerator IEnumerator()
{
    /* before action */
    yield return StartCoroutine(Method());
    /* after action */
}

public async Task Task()
{
    /* before action */
    await MethodAsync();
    /* after action */
}
</code></pre>
<p>みたいな感じです、awaitに馴染みのない人も、なんとなくイメージしながら眺めてみてもらえると嬉しいです。</p>
<h2>非同期汚染</h2>
<p>コード例の前に非同期汚染、或いは非同期の伝搬について。まぁ、あんまし汚染という言い方は好きじゃないのですが、基本的に非同期、つまりTaskでもFutureでもPromiseでもIObservableでも、は、下層から上層まで伝搬していきます。メソッドが非同期であるなら戻り値はIObservableであり、そのIObservableを呼ぶメソッドもまた自然と非同期でなければならないので、IObservableになる、と。何故非同期の連鎖でなければならないのか。消費(Subscribe)してしまうと、その瞬間Fire and Forgetになってしまい、戻りを待ったりキャンセルしたりなどの別の操作が行えなくなってしまうからです。別にFire and Forgetしたければ、呼び元がそれを選択(Subscribeして放置)すればいいわけで、呼ばれる側が決定することではない。</p>
<p>もちろん、最終的にはどこかの層で消費(Subscribe)しなければならないので、そこで伝搬は止まるのですけれど、それは、基本的には上層であればあるほどよいということですね。どこが上層やねんって話はあるかもしれませんが、ユーザーインタラクションに近かったり、MonoBehaviourのイベント層に近かったり、あたりがそうですかねー。あとは、ごく一部でしか使わないんだ！という確固たる思いがあれば、早い段階でSubscribeして伝搬を止めるのも策ではあります、その辺はケースバイケースで。</p>
<p>非同期の伝搬に都合の良いメソッドが現状のUniRxには足りてません。実は！というわけで、次期バージョンではForEachAsyncというものを足したいのですが、それまでは以下のものをコピペって代用してください。挙動的にはシーケンスを消費して長さ1のIObservable[Unit]を返すもので、元シーケンスが非同期(長さ1)ならDoやSelectと、概ね一緒です。</p>
<pre><code class="language-csharp">// 次期バージョンに入るので、それまでの代用ということで。
// 元シーケンスが非同期なら .Select(x =&gt; { /* action(); */ return Unit.Default; }) とほぼ同様
namespace UniRx
{
    public static class UniRxExtensions
    {
        public static IObservable&lt;Unit&gt; ForEachAsync&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext)
        {
            return Observable.Create&lt;Unit&gt;(observer =&gt;
            {
                return source.Subscribe(x =&gt;
                {
                    try
                    {
                        onNext(x);
                    }
                    catch (Exception ex)
                    {
                        observer.OnError(ex);
                        return;
                    }
                }, observer.OnError, () =&gt;
                {
                    observer.OnNext(Unit.Default);
                    observer.OnCompleted();
                });
            });
        }
    }
}
</code></pre>
<p>また、副作用（外の変数への代入など）に関しては、あまり気にしないほうが吉です。いや、Rxのパイプラインに押し込めたほうが美しくはあるんですが、それがオブジェクトであるなら、副作用かけてフィールド変数を変えたり、ReactivePropertyに結果を伝えたりとかは、あって然りかな、と。考える際には「もしこれが同期コードだったらどうなのか」を意識したほうがいいかもしれません、同期コードで自然なら、別にRxでそれを行っても、構わないのです。とはいえ、以下に紹介するコードは全部、副作用大前提みたいな説明なので、それはそれで若干の狂気でもありますが、その辺は慣れてきてからでよいかと。</p>
<h2>戻り値のない場合</h2>
<pre><code class="language-csharp">public async Task Demo1_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
}

public IObservable&lt;Unit&gt; Demo1_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .ForEachAsync(_ =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>メソッドに戻り値がない場合は、awaitの位置にForEachAsyncで、その中にactionを書く形になります。RxにおいてはIObservable[Unit]を戻り値のないことの表明として使います。</p>
<h2>内部に複数の非同期がある場合</h2>
<pre><code class="language-csharp">public async Task Demo2_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action 1 */
    var y = await Task.Factory.StartNew(() =&gt; 200);
    /* after action 2 */
}

public IObservable&lt;Unit&gt; Demo2_IO_1Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */

            return Observable.Start(() =&gt; 200);
        })
        .ForEachAsync(y =&gt;
        {
            /* after action 2 */
        });
}
</code></pre>
<p>awaitの位置にSelectManyを置くことで繋げることができます。最後の消費だけForEachAsyncで。</p>
<h2>パイプライン中に複数の値を伝搬したい場合</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y }) // transport argument to next chain
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y } 
        });
}

public IObservable&lt;Unit&gt; Demo2_IO_2_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            var z = SyncMethod();
            return Observable.Start(() =&gt; 200).Select(y =&gt; new { x, y, z });
        })
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>同期コードでは、そのスコープ中の全ての値が使えるわけですが、Rxのメソッドチェーンでは次のパイプラインに送り込める値は一つしかありません。というわけで、匿名型（もしくはUniRx.Tuple）を使って、次のパイプラインへは値をまとめて上げる必要があります。SelectManyには第二引数があり、それにより前の値と次の値をまとめることができます。また、SelectMany内部で作った値を送り込みたい場合は、戻り値のところでSelectを使ってスコープ内でキャプチャして返してあげればいいでしょう。(匿名型、Tupleともにclassなので、気になる場合はstructの入れ物を用意してもいいかもしれない、何か箱を作って運搬しなきゃいけないのは残念ながら仕様です)</p>
<h2>非同期が連鎖する場合</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2_MoreChainAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y })
        .SelectMany(o =&gt;
        {
            /* after action 2 */
            return Observable.Start(() =&gt; 300);
        }, (o, z) =&gt; new { o.x, o.y, z }) // re-construct self
        .ForEachAsync(o =&gt;
        {
            /* after action 3 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>SelectManyの連打になります。また、伝搬する値は自分で分解して付け直してあげる必要があります、これは面倒くさいですね！この辺はクエリ構文を使った場合、Transparent Identifierという仕組みで自動的にコンパイラが行うのですが(<a href="http://www.slideshare.net/neuecc/an-internal-of-linq-to-objects-29200657">An Internal of LINQ to Objects</a>の35P、Rxでクエリ構文は結構頻繁にクエリ構文の範疇を逸脱するのと、副作用をパイプライン途中に書けないためあまり使い勝手は良くないので、面倒くさいながら手作業再構築を薦めます。</p>
<h2>戻り値を返す場合</h2>
<pre><code class="language-csharp">public async Task&lt;int&gt; Demo3_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
    return x; // return value
}

public IObservable&lt;int&gt; Demo3_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Select(x =&gt;
        {
            /* after action */
            return x; // return value
        });
}
</code></pre>
<p>ForEachAsyncではなく、Selectを使っていきましょう。戻り値の型が同一で副作用だけ起こしたいならDoでも構わないのですが、まぁどっちでもいいです。また、awaitが複数になる場合は、SelectManyになります。そのうえでSelectManyのままreturnするか、最後に再びSelect(もしくはDo)を使うかどうかは、状況次第、かな。</p>
<h2>例外をキャッチ</h2>
<pre><code class="language-csharp">public async Task Demo4_TaskAsync()
{
    /* before action */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    catch (Exception ex)
    {
        /* onerror action */
        throw;
    }

    /* after action */
}

public IObservable&lt;Unit&gt; Demo4_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Catch((Exception ex) =&gt;
        {
            /* onerror action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>これはCatchで賄えます。なお、Catchメソッドを使う際は、Catch&lt;T&gt;で例外の型を指定するよりも、ラムダ式の引数側で例外の型を書いたほうが書きやすいです（そうしたほうが型推論の関係上、ソースシーケンスの型を書かなくて済むため）。Catchの戻り値では再スローをObservable.Throw、握りつぶしをObservable.Return/Emptyで表現可能です。</p>
<h2>Finally</h2>
<pre><code class="language-csharp">public async Task Demo5_TaskAsync()
{
    /* before action(1) */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    finally
    {
        /* finally action(2) */
    }

    /* after action(3) */
}

// not equivant try-finally
public IObservable&lt;Unit&gt; Demo5_IO_PseudoAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Finally(() =&gt;
        {
            /* finally action(3) */
        })
        .ForEachAsync(x =&gt;
        {
            /* after action(2) */
        });
}

public IObservable&lt;Unit&gt; Demo5_IO_CorrectLightweightButIsNotDryAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Do(_ =&gt; { /* finally action(2) */}, _ =&gt; {/* same finally action(2) */})
        .ForEachAsync(x =&gt;
        {
            /* after action(3) */
        });
}
</code></pre>
<p>Finallyに関しては、実は同じに扱える表現がありません!RxのFinallyはパイプラインの終了時の実行なので、実行順序がベタtry-finallyで書いた時と異なるんですよねえ。いちおう、DoでOnNextとOnErrorのところに同じコードを書くことでそれっぽい表現は可能ではありますが……。</p>
<h2>並列処理</h2>
<pre><code class="language-csharp">public async Task ParallelAsync()
{
    var a = Task.Factory.StartNew(() =&gt; 100);
    var b = Task.Factory.StartNew(() =&gt; 200);
    var c = Task.Factory.StartNew(() =&gt; 300);
    
    var xs = await Task.WhenAll(a, b, c);
    /* after action */
}


public IObservable&lt;Unit&gt; ParallelIO()
{
    var a = Observable.Start(() =&gt; 100);
    var b = Observable.Start(() =&gt; 200);
    var c = Observable.Start(() =&gt; 300);
    
    return Observable.WhenAll(a, b, c)
        .ForEachAsync(xs =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>並列処理は非同期固有の実行ですが、WhenAllでドバッとまとめるというのが基本方針。</p>
<h2>タイムアウト</h2>
<pre><code class="language-csharp">public async Task TimeoutAsync(TimeSpan timeout)
{
    var task = Task.Factory.StartNew(() =&gt; 100);    
    var delay = Task.Delay(timeout);
    if (await Task.WhenAny(task, delay) == delay)
    {
        /* timeout action */
        throw new TimeoutException();
    }
    /* after action */
}


public IObservable&lt;Unit&gt; TimeoutIO(TimeSpan timeout)
{
    return Observable.Start(() =&gt; 100)
        .Timeout(timeout)
        .Catch((TimeoutException ex) =&gt;
        {
            /* timeout action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>タイマウトも非同期固有の処理。async/awaitの場合、特有のイディオムがあります。UniRxの場合はTimeoutだけでOK。特に例外時に処理するものもないなら、Catchは不要です。</p>
<h2>IEnumeratorに戻す</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo6_IE()
{
    /* before action(1) */
    return Observable.FromCoroutine(() =&gt; Demo6_IECore());
}

IEnumerator Demo6_IECore()
{
    // 戻り値の不要な場合
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine();
    
    int ret;
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine(x =&gt; ret = x);
}
</code></pre>
<p>SelectManyの連打が辛い場合、ふつーのコルーチンに戻して、更にIObservableでラップするという手段も取れます。まあ、この辺は複雑さ度合いで自由に！</p>
<p>だったらもはや最初から全部コルーチンでええやん！Rxでメソッドチェーン複雑だし見た目だけならコルーチン最強にスッキリじゃん！というのは正しい。正しいんですが、例外処理・戻り値・合成可能性・並列処理・マルチスレッド、などといった要素が欠落してるので、コルーチンはコルーチンで苦しいところが多いというか実際のところシンプルなケース以外では相当苦しいので、基本的にはRxのほうが有利です。</p>
<h2>async/awaitは必要？</h2>
<p>みたとーり、必要です。どう考えても。さすがにSelectManyの連打を同期コードほどスッキリと言い張るのは無理があるでしょう。とはいえまぁ、書いて書けないこともないので、今あるツールの中でベストを尽くすのまた良きかな、とは思いますねー。というわけで良き非同期生活を！UniRxでイベントを扱う際のパターン集は、またそのうちにでも！</p>
</div>
<h1><a href="https://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a></h1>
<ul class="date"><li>2015-09-29</li></ul>
<div class="entry_body"><p>Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用、という題で<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>にて話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/pF55iU0qXIeRFv" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/metaprogramming-universe-in-c-ilroslyn" title="Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例" target="_blank">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>現在、PhotonWireというフレームワークを作っているのですが、それで使ったメタプロ技法を紹介しました。ExpressionTree, T4, ILGenerator, Roslyn(Analyzer), Mono.Cecilとそれなりに満遍なく使っているので、それらをどーいう時に使えばいいのかというヒントになれば幸いです。まとめに書きましたが、手法自体は少なくするに越したこたぁないです、メタプロってついやりすぎちゃう傾向にあるんで、目的Firstを忘れないようにしないと本末転倒になりがちです。あと、それぞれは別にそんなに難しくない、というか難しくやらないようにするのが良いですね、そもそも長い式木とか長いILとか書きたくないですし……。</p>
<p>Proxyのvirtual強制は制約強くてゲロなので喪われた技法って感じですが、Roslyn Analyzerでコンパイラエラーに制限できることによって復活したかもしれない気がするかもしれない！あと、Taskは大事ですね、非同期のシグネチャとしてTaskで表明できるようになったのはひじょーーーーーーに大きな事です。これは実際めちゃくちゃ大きなことなのに過小評価してたり勘違いしてたりすると、いくない。もちろん、async/awaitで手軽にハンドリングできるようになったことも大事。RPC Revisitedですよ。そんなわけでごった煮しつつも、私的な独断と偏見に基づくバランス感覚で取捨してます。この辺の感覚はかなり大事だと思うんだな。</p>
<p>なお、書籍では<a href="http://www.amazon.co.jp/dp/4048867741">メタプログラミング.NET</a>が良書なのでオススメです。</p>
<h2>PhotonWire</h2>
<p>題材のPhotonWireは、<a href="http://grani.jp/">グラニ</a>で現在開発中のリアルタイムネットワーク通信用フレームワークです(ところでUnity、特にUniRxをゴリゴリ活用した先端的(エキセントリックともいう)なスクリプティング環境や、クライアントからサーバーまで全てC#で統一したあいそもーふぃっくな開発に興味のある人はいつでもウェルカムで採用募集中です)。といってもレイヤー的には比較的高レベルで、下回りでは<a href="https://www.photonengine.com/">Photon Server</a>というミドルウェアを採用していて、その上のRPCフレームワークを提供という感じです。キャッチコピーは「Typed Asynchronous RPC Layer for Photon Server + Unity」ということで、特にUnityとの繋ぎ込みを重視していて、クライアント-サーバー、サーバー-クライアント、サーバー-サーバーの方向のRPCを提供します。クライアント-クライアントは非サポート（あれは百害あって一利なし）。</p>
<p>クライアント-サーバーはご存知<a href="https://github.com/SignalR/SignalR">SignalR</a>、サーバー-サーバーは<a href="https://github.com/dotnet/orleans">Orleans</a>という分散アクターフレームワークのAPIを参考にしています、が、サーバーの分散に関しては、別に全然賢くないです。というか機能全く無いです。もともとのPhotonがそこに対するサポートがゼロで、PhotonWireでもたいしたサポートを入れてません。私的にはこの素朴な割り切りは結構好きですね。変に透過的に見せるよりも、それぞれのサーバー/それぞれのレイヤーを独立して、ある程度プリミティブな操作を可能にしたほうがはまりどころも少ないし。別に賢くはないんだけど、手堅い。ゲームという用途で考えると、あまりカシコイものよりも、愚直なシステムのほうがマッチしそうな感触があります。必要になったら、まぁ適当に考える。</p>
<p>Photon(+Unity)にはもともとPhoton Unity Network(PUN)という高レベルなクライアントが用意されているのですが、正直あんまり良いものでもない（特にPhoton Serverで自前ロジックを入れてくような場合は）ので、無視です、無視。で、PUNを通さない低レベルのSDKもあって、こちらは相当低レベルで本当に接続とデータ転送しか提供していないので（ただし低レベルSDKとしてはこのぐらいのほうが好ましい、へたに変なのがゴチャゴチャついてるよりも）、サーバーSDK（こちらもかなり低レベル）ともども統一した形で、ちょっと高レベルなもの、ぐらいの位置づけで作り上げてみました。</p>
<p>クラスとメソッドに属性でIDつけさせて、それで振り分けしているのでJSON-RPC的なメソッド名なども送っちゃうのでサイズが大きくなる、ということはなく、通常の転送に較べてもオーバーヘッドは2byteです。別に全然ない。ユーザー定義の型を送る場合（通常のPhotonはこれをサポートしてない）は<a href="https://github.com/msgpack/msgpack-cli">MsgPack-CLI</a>でシリアライズ/デシリアライズするため、その際の容量増大も極小です。また、シリアライザ/デシリアライザはその型に合致したものを事前生成するため、Unityにおいても高速に動作させられます、といったシステムも含まれています。</p>
<p>デバッグ用の専用クライアント（WPF製）なども込み込みで(これのデザイン面の話は<a href="http://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a>に書いてます)、痒い所に手が届きつつも、機能自体は小さく「型付きの非同期RPCの提供」から逸脱しない程度におさめているので、まーまー使いやすいんじゃないかなー、と思いますね。もちろん、クライアント側は<a href="https://github.com/neuecc/UniRx">UniRx</a>前提です。</p>
<p>UniRx同様、GitHub/AssetStoreでの公開予定はあるというか、早く公開したいんですが、Photonの次バージョンのベータ版を使って開発してるので、そっちが正式リリースされないと公開できないので早く出ないかなぁ(ﾁﾗｯ とオモッテマス。</p>
</div>
<h1><a href="https://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a></h1>
<ul class="date"><li>2015-09-10</li></ul>
<div class="entry_body"><p>なんとブログ書くのは3ヶ月ぶり近い！えー、うーん、そんな経っちゃってるのか、こりゃいかん。と、いうわけかでWPFアプリを入り用で作ったんですが、見た目がショボくてゲッソリしてました。WPFでアプリ書いても別に綺麗な見た目にならんのですよね、むしろショボいというか。自分でデザイン作りこんだりなんて出来ないし、でもWPFのテーマ集なんかを適用してもクソダサいテーマしかなかったりして一層ダサくなるだけで全く意味ないとかそんなこんなんで、まぁ割とげっそりだったのですが、<a href="https://github.com/ButchersBoy/MaterialDesignInXamlToolkit">Material Design In XAML Toolkit</a>は相当良い！良かった、のでちょうど手元に作り中のWPFアプリがあって適用してみたんで紹介してきます。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>最終的に↑のような感じになりました。サクサクッとテーマ適用してくだけでこの程度に整えられるならば、上等すぎるかな、と。私的にはマテリアルデザイン、相当気に入りました。WindowsのModern UI風のフラットテーマは普通に適用しただけだと超絶ダサくなるという、センスが要求されすぎてキツかったんですが、マテリアルデザインはそれなりに質感が乗っかってるのでまぁまぁ見れる感じになる。また、画像からは分かりませんが結構細かくアニメーションが設定されていて感触が良い（マテリアルデザインの重要な要素だそうで）のも嬉しい。</p>
<h2>Before</h2>
<p>Beforeはこんな感じです。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml2.jpg' alt='' /></p>
<p>TextBoxとボタンの羅列、実にギョーミーな雰囲気。機能的には私の要件はこれで満たしてるんですが（ちなみにコレが何かは後日紹介するしGitHubで公開もするつもりですが今は本題ではないのでスルーします）、いかんせん見た目が悲しいかな、と。そこで現れたMaterial Design In XAML Toolkit！NuGetからのインストールとコピペ一発で素敵な見た目に……。
なるほど世の中はさすがに甘くなかったですね:)</p>
<p>適用は簡単で、NuGetからMaterialDesignThemesをダウンロード、そしてApp.xaml.csに<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MainDemo.Wpf/App.xaml">このApp.xaml</a>のApplication.Resourcesをコピペ。そしてMainWindowに以下の4項目を貼っつけてあげればできあがり。</p>
<pre><code class="language-xml">&lt;MainWindow
    xmlns:wpf=&quot;clr-namespace:MaterialDesignThemes.Wpf;assembly=MaterialDesignThemes.Wpf&quot;
    TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
    Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
    FontFamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;&gt;
</code></pre>
<p>簡単簡単。これで美しくなるなら素晴らしいですね？そしてその結果がこれ。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml3.jpg' alt='' /></p>
<p>うん、ダメ、理想とは程遠いダサさに溢れてます。Bootstrapを適用しただけじゃ普通にダサいままってのと同じ。ボーダーが吹っ飛んだので境目がわからず使いにくくなったし、やっぱダサ……、なんか一部のボタンは文字埋まっちゃってるし。で、引き返そうと思ったんですが、なんとなく良さそうな気配は感じたのでもう少し粘って作業することにしました。</p>
<h2>デモアプリを見ながら細工</h2>
<p>まずMaterialDesignInXamlToolkitのプロジェクトを落としましょう。CloneしてもいいしDownload Zipでもいいので。で、MainDemo.Wpfをビルドして実行しましょう、特に躓くことなくビルドできるはずですので。このデモアプリが非常によく出来ていて、出来ること全ての解説になってますし、当然それをやりたければそのxamlを開いてコピペすればなんとかなります！</p>
<p>というわけでデモアプリを眺めつつ自分のクソダサアプリのどこから手を入れようか。まず画面の構成要素のうち、上の部分のテキストボックスとボタンが並んでるところはコンフィグに近いので色分けしようかな、と。ヘッダ部分の色分け例はマテリアルデザインでよく見るパターンですしね。よく見るパターンということは、専用のパーツがしっかり用意されています。ColorZoneで囲むことで色がガラッと変わります。</p>
<pre><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Inverted&quot; Padding=&quot;0&quot;&gt;
    ...
&lt;/wpf:ColorZone&gt;
</code></pre>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml4.jpg' alt='' /></p>
<p>ModeのInvertedは逆転した色、というわけで、これだけでまぁまぁ引き締まった雰囲気が出てきました、これはやって正解。また、ボタンの文字が埋まっているのはMargin入れて小さくしてたせいだったので、Heightを設定する形で小さくすることにしました。この状態でちょっとだけ問題があって、コンボボックスの選択時のフォントが通常カラーのままなので色が薄く見えなくなってしまうことに……。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml5.jpg' alt='' /></p>
<p>これはテーマから外れたItemContainerStyleを設定して回避。</p>
<pre><code class="language-xml">&lt;ComboBox ItemsSource=&quot;{Binding UseConnectionType}&quot;&gt;
    &lt;ComboBox.ItemContainerStyle&gt;
        &lt;Style TargetType=&quot;ComboBoxItem&quot;&gt;
            &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Gray&quot; /&gt;
        &lt;/Style&gt;
    &lt;/ComboBox.ItemContainerStyle&gt;
&lt;/ComboBox&gt;
</code></pre>
<p>よくわからんけどこんなんでいいでしょふ、よくわからんけど。真面目にXAML書くの5年ぶりぐらいなんで正直もう全然覚えてないんですよね。</p>
<p>そういえば、オマケコントロール（？）としてTextBoxにウォーターマークがつけれるのが入ってます。使い方はwpf:TextFieldAssist.Hintを入れるだけ。</p>
<pre><code class="language-xml">&lt;TextBox wpf:TextFieldAssist.Hint=&quot;うぉーたーまーく&quot; /&gt;
</code></pre>
<p>かなり綺麗に出て素敵なので最高だと思いました、まる。</p>
<h2>MahAppsの導入</h2>
<p>タイトルウィンドウが乖離しててダサいというか気になってきた。ので、ここを手軽に改変できる<a href="http://mahapps.com/">MahApps</a>を入れましょう。MahAppsだけだと、Metro風ということでこれ単体では別に素敵な見た目に出来ないんですが（ほんとメトロ風はムズカスぃ！）、Material Design In XAML Toolkitと合わせるとお互いの領域をカバーできる。ちゃんとMaterial Design In XAML Toolkit側で統合のための設定が用意されているので組み合わせるのは簡単です。MahAppsの基本的な導入は<a href="http://mahapps.com/guides/quick-start.html">Quick Start</a>に従う通り、まずWindowをMetroWindowに差し替えて</p>
<pre><code class="language-xml">// Xaml 
&lt;Controls:MetroWindow
    xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;&gt;

// CodeBehind
public partial class MainWindow : MahApps.Metro.Controls.MetroWindow
</code></pre>
<p>App.xamlにリソースを投下、なのですが、MaterialDesignInXamlToolkitと統合するためのサンプルがMaterialDesignInXamlToolkit側に用意されているので、リソースは<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MahMaterialDragablzMashUp/App.xaml">MahMaterialDragablzMashUp/App.xaml</a>からコピペってきましょう。DragablzというChromeみたいなドラッグアンドドロップで切り離せるタブのためのライブラリを使わない場合（今回は使いませんでした）は、Dragablzに対する行は削除しておｋ（というか削除しないと動きません）。これで</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml6.jpg' alt='' /></p>
<p>となりました。うーん、よくなってきた！タイトルバーのところにテキストでいい感じなレイアウトで手軽にコマンドを突っ込めるのも嬉しかった。というわけでBeforeではステータスバーのところにやけくそにダサい感じで置いてたDuplicate Windowボタン（ウィンドウを複製する）をタイトルバーに移動。ついでにAlign Window（複数ウィンドウを整列させる）コマンドも追加。ちなみにこのアプリは複数ウィンドウを並べて使うのが前提なので、並べた時に重なって鬱陶しいためウィンドウ枠を光らせるのはあえて切ってるんですが、単体アプリなら光らせたほうが見栄え良いかもですね。入れるの自体は簡単で</p>
<pre><code class="language-xml">&lt;!-- 光らせるところ、GlowBrushを削れば光らない --&gt;
&lt;Controls:MetroWindow
    GlowBrush=&quot;{DynamicResource AccentColorBrush}&quot;&gt;    

    &lt;!-- コマンド入れるところ --&gt;
    &lt;Controls:MetroWindow.RightWindowCommands&gt;
        &lt;Controls:WindowCommands&gt;
            &lt;Button Content=&quot;Align Window&quot; Click=&quot;AlignWindow_Click&quot; /&gt;
            &lt;Button Content=&quot;Duplicate Window&quot; Click=&quot;DuplicateWindow_Click&quot; /&gt;
        &lt;/Controls:WindowCommands&gt;
    &lt;/Controls:MetroWindow.RightWindowCommands&gt;
</code></pre>
<p>をMainWindows.xamlに突っ込むだけです。お手軽素敵。</p>
<h2>最終調整</h2>
<p>Purpleじゃない色調にしたかったのでテーマをデモアプリのパレットから眺めてBlueGrayに決定。テーマはApp.xamlを弄ればヨイデス。MaterialDesignColor.xxx.xamlの部分ですね、他の色とかはデモアプリのPaletteで確認できます。その他Light/Darkの切り替えやSecondaryColourの設定なんかも、xxx.xamlのそれっぽい部分をなんとなく書き換えれば書き換わります。</p>
<pre><code class="language-xml">&lt;!-- include your primary palette --&gt;
&lt;ResourceDictionary.MergedDictionaries&gt;
    &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/MaterialDesignColor.BlueGrey.xaml&quot; /&gt;
&lt;/ResourceDictionary.MergedDictionaries&gt;
</code></pre>
<p>これで全体の色が変わったので、最後に、中央部分がMarginが消えてて区切りめがわからず使いづらいのは変わらずだったので、ここは枠をいれて明確な分離を。最初はボーダー入れて調整とかしてみたんですがイマイチしっくりこなかったんで、まぁ枠かな、と。マテリアルデザイン風のシャドウのある枠はヘッダーで色分けした時と同じく ColorZone で囲むだけです、ModeはStandardを選択。モードがどんなのがあるかもデモアプリを見れば一発で分かります。</p>
<pre><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Standard&quot; Padding=&quot;5&quot; CornerRadius=&quot;3&quot; Effect=&quot;{DynamicResource MaterialDesignShadowDepth1}&quot; Margin=&quot;2&quot;&gt;
    &lt;local:OperationItem /&gt;
&lt;/wpf:ColorZone&gt;
</code></pre>
<p>影の出方はMaterialDesignShadowDepthの1~5で調整可能で、今回は1にしてます。その他の調整として、ログを表示しているテキストボックスのボーダーを上にも出すようにしたり、中身によって拡縮するようになっちゃたのでVerticalContentAlignmentを設定したりとちょっとした調整を少し入れて、最初に出した画像のものになりました。もっかい同じのを載せますけれど。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>アプリの見た目が良くなるってのは純粋にテンション上がるんでいいものですねぇ、機能的には何も変わっちゃいないですが、気分は随分と良いです。まぁギョームコウリツとは関係ないとこなんであんまり手を入れまくってもアレですが、ちょっとテーマ適用して調整するだけで必要最低限整ってくれるのは実に良いです。</p>
<h2>＋アイコン</h2>
<p>あとパラメータのコピペが欲しくなりました、複数ウィンドウ間で貼って回ったりするので。というわけでボタンにアイコンを用意したくて、それもマテリアルデザインなら簡単！</p>
<img src='http://neue.cc/wp-content/uploads/2015/09/materialxamlicon.jpg' alt='' />
<pre><code class="language-xml">&lt;Button Background=&quot;{StaticResource PrimaryHueLightBrush}&quot;
        HorizontalAlignment=&quot;Left&quot;
        Width=&quot;24&quot; Height=&quot;24&quot; Padding=&quot;0&quot; Margin=&quot;5&quot;
        Command=&quot;{Binding PasteCommand}&quot;
        ToolTip=&quot;Paste&quot;&gt;
    &lt;Viewbox Width=&quot;16&quot; Height=&quot;16&quot;&gt;
        &lt;Canvas Width=&quot;24&quot; Height=&quot;24&quot;&gt;
            &lt;Path Data=&quot;M19,20H5V4H7V7H17V4H19M12,2A1,1 0 0,1 13,3A1,1 0 0,1 12,4A1,1 0 0,1 11,3A1,1 0 0,1 12,2M19,2H14.82C14.4,0.84 13.3,0 12,0C10.7,0 9.6,0.84 9.18,2H5A2,2 0 0,0 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V4A2,2 0 0,0 19,2Z&quot;
                     Fill=&quot;{DynamicResource MaterialDesignBody}&quot; /&gt;
        &lt;/Canvas&gt;
    &lt;/Viewbox&gt;
&lt;/Button&gt;
</code></pre>
<p>これは<a href="https://materialdesignicons.com/">Material Design Icons</a>にあるアイコンから取ってきてます。そこにはXAMLのPath Dataも載ってるので、タグをそのまま貼り付けるだけでアイコンとして使えます。これは楽ちんでめっちゃ良い！アイコンは揃えるのどうしても面倒ですからねー、このお手軽さは嬉しすぎます。色とかを用意されてるMaterialDesignのスタイルを入れ込んでやればそれだけで中々見栄えのするアイコンの出来上がり。</p>
<h2>ReactiveCommand</h2>
<p>えむぶいぶいえむ的なのは<a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a>で実装してます。で、ReactivePropertyもいーんですが、私的には昔から結構ReactiveCommand押しなんですよ、ReactiveCommandいいんだけどなー。例えば実際こんなコードになってます。</p>
<pre><code class="language-csharp">// peer = ReactiveProperty&lt;Connection&gt;
// ObserveStatusChangedで状態の変化の監視 + コネクションは切り替わることがあるので前のを破棄するSwitch
// Disconnectが押せるのはStatusがConnectの時だけ
Disconnect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .Select(x =&gt; x == StatusCode.Connect)
    .ToReactiveCommand();

// Disconnectの逆、だけどConnectが押せるのはそれに加えて接続先アドレス入力欄が空でない場合
Connect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .CombineLatest(Address, (x, y) =&gt; x != StatusCode.Connect &amp;&amp; !string.IsNullOrEmpty(y))
    .ToReactiveCommand();
</code></pre>
<p>とか。若干込み入って面倒くさいのがスッキリ + ボタンのCanExecuteとぴったり来る。あとはプロセスを監視してて、存在してれば止めるボタンが押せるというのは、一秒毎のチェックにしていて、Observable.Intervalで繋ぎあわせてます。</p>
<pre><code class="language-csharp">// PhotonSocketServerが存在すれば押せるコマンド、1秒毎のポーリングで監視
KillPhotonProcess = Observable.Interval(TimeSpan.FromSeconds(1))
    .Select(x =&gt; Process.GetProcessesByName(&quot;PhotonSocketServer&quot;).Any()); 
    .ToReactiveCommand();
</code></pre>
<p>こういうの悩まずサクサク書けるのは幸せ度高い。</p>
<h2>で、これ何なの？</h2>
<p>なんなんでしょーねぇ。ということの一端は<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>という勉強会で「IL から Roslyn まで - Metaprogramming Universe in C#」というタイトルでお話しますよ！2015-09-16（水）19:30 - 22:00に渋谷でやりますので、気になる人は是非是非参加くだしあ。内容はRoslyn 20%, C#全般 60%, WPF 10%, Unity 10%ぐらいなイメージですかしらん。このWPFのどこにメタプログラミング要素があるかというと、中身は<a href="https://github.com/jbevain/cecil">Mono.Cecil</a>使ってアセンブリ解析してるからです。へー。とかそういうことを話します。</p>
</div>
<a href="https://neue.cc/5">Prev |</a>
<a href="https://neue.cc/7">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
