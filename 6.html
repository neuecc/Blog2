<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2016/08/03_536.html">UniRx 5.4.0 - Unity 5.4対応とまだまだ最適化</a></h1>
<ul class="date"><li>2016-08-03</li></ul>
<div class="entry_body"><p>UniRx 5.4.0をリリースしました！ちょうどUnity 5.4もリリースされたので、5.4向けの修正(Warning取り除いただけですが)を出せて良かった。というわけで5.4正式対応です。リリースは前回が5月だったので3ヶ月ぶりです。5.2 -&gt; 5.3も3ヶ月だったので、今のとこ3ヶ月スパンになってますが偶然です。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub/UniRx</a></li>
<li><a href="https://www.assetstore.unity3d.com/jp/#!/content/17276">AssetStore/UniRx</a></li>
</ul>
<p>何が変わったのかというと</p>
<pre><code class="language-txt">Add: Observable.FrameInterval
Add: Observable.FrameTimeInterval
Add: Observable.BatchFrame
Add: Observable.Debug(under UniRx.Diagnostics namespace)
Add: ObservableParticleTrigger and OnParticleCollisionAsObservable, OnParticleTriggerAsObservabl(after Unity 5.4) extension methods
Add: UniRx.AsyncReactiveCommand
Add: ReactiveCommand.BindToOnClick, `IObservable&lt;bool&gt;.BindToButtonOnClick`
Add: UniRx.Toolkit.ObjectPool, AsyncObjectPool
Add: UniRx.AsyncMessageBroker, asynchronous variation of MessageBroker
Add: ObserveEveryValueChanged(IEqualityComparer) overload
Add: `Observable.FromCoroutine(Func&lt;CancellationToken, IEnumerator&gt;)` overload
Add: ObservableYieldInstruction.IsDone property
Add: IPresenter.ForceInitialize(object argument)
Improvement: Where().Select(), Select().Where() peformance was optimized that combine funcs at internal
Improvement: MicroCoroutine performance was optimized that prevent refresh spike
Improvement: Observable.Return performance was optimized that reduced memory cost
Improvement: Observable.Return(bool) was optimzied perofmrance that allocate zero memory
Improvement: Observable.ReturnUnit was optimzied perofmrance that allocate zero memory
Improvement: Observable.Empty was optimzied perofmrance that allocate zero memory
Improvement: Observable.Never was optimzied perofmrance that allocate zero memory
Improvement: Observable.DelayFrame performance was optimized
Improvement: UnityEqualityComparer.GetDefault peformance was optimized
Improvement: AddTo(gameObject) dispose when ObservableTrigger is not activated
Improvement: AddTo(gameObject/component) performance was optimized by use inner CompositeDisposable of ObservableDestroyTrigger
Improvement: `FromCoroutine&lt;T&gt;(Func&lt;IObserver&lt;T&gt;, IEnumerator&gt;)` stops coroutine when subscription was disposed
Improvement: ReactiveCollection, ReactiveDictionary implements dispose pattern
Fix: ToYieldInstruction throws exception on MoveNext when reThrowOnError and has error 
Fix: ObserveEveryValueChanged publish value immediately(this is degraded from UniRx 5.3)
Fix: Prevent warning on Unity 5.4 at ObservableMonoBehaviour/TypedMonoBehaviour.OnLevelWasLoaded
Fix: Remove indexer.set of IReadOnlyReactiveDictionary
Breaking Changes: Does not guaranty MicroCoroutine action on same frame
Breaking Changes: UniRx.Diagnostics.LogEntry was changed from class to struct for performance improvement
</code></pre>
<p>相変わらずへっぽこな英語はおいといてもらえるとして、基本的にはパフォーマンス改善、です。</p>
<p><a href="http://neue.cc/2016/05/14_529.html">前回紹介したMicroCoroutine</a>を改良して、配列をお掃除しながら走査する（かつ配列走査速度は極力最高速を維持する）ようになったので、より安定感もましたかな、と。その他メモリ確保しないで済みそうなものは徹底的に確保しないようになど、しつっこく性能改善に努めました。あと新規実装オペレータに関しては性能に対する執拗度がかなり上がっていて、今回でいうとBatchFrameはギチギチに最適化した実装です。既存オペレータも実装甘いものも残ってはいるので、見直せるものは見なおしてみたいですねえ。</p>
<p>また、9/13日に<a href="https://atnd.org/events/80089">Photon勉強会【Photon Server Deep Dive - PhotonWireの実装から見つめるPhoton Serverの基礎と応用、ほか】</a>で登壇するので、<a href="https://github.com/neuecc/PhotonWire">PhotonWire</a>ではUniRxもクライアント側でかなり使っているので、その辺もちょっと話したいなと思っていますので、Photonに興味ある方もない方も是非是非。Photon固有の話も勿論しますが、普通にUnityとリアルタイム通信エンジンについての考えや、UniRx固有の話なども含めていきますので。</p>
<h2>Debug</h2>
<p>Debugという直球な名前のオペレータが追加されました。標準では有効化されていなくて、<code>UniRx.Diagnostics</code>というマイナーな名前空間をusingするようで使えるようになります。実際どんな効果が得られるのかというと</p>
<pre><code class="language-csharp">using UniRx.Diagnostics;

---

// [DebugDump, Normal]OnSubscribe
// [DebugDump, Normal]OnNext(1)
// [DebugDump, Normal]OnNext(10)
// [DebugDump, Normal]OnCompleted()
{
    var subject = new Subject&lt;int&gt;();

    subject.Debug(&quot;DebugDump, Normal&quot;).Subscribe();

    subject.OnNext(1);
    subject.OnNext(10);
    subject.OnCompleted();
}

// [DebugDump, Cancel]OnSubscribe
// [DebugDump, Cancel]OnNext(1)
// [DebugDump, Cancel]OnCancel
{
    var subject = new Subject&lt;int&gt;();

    var d = subject.Debug(&quot;DebugDump, Cancel&quot;).Subscribe();

    subject.OnNext(1);
    d.Dispose();
}

// [DebugDump, Error]OnSubscribe
// [DebugDump, Error]OnNext(1)
// [DebugDump, Error]OnError(System.Exception)
{
    var subject = new Subject&lt;int&gt;();

    subject.Debug(&quot;DebugDump, Error&quot;).Subscribe();

    subject.OnNext(1);
    subject.OnError(new Exception());
}
</code></pre>
<p>シーケンス内で検出可能なアクション（OnNext, OnError, OnCompleted, OnSubscribe, OnCancel）が全てコンソールに出力されます。よくあるのが、何か値が流れてこなくなったんだけど→どこかで誰かがDispose済み(OnCompleted)とか、OnCompletedが実は呼ばれてたとかが見えるようになります。</p>
<p>超絶ベンリな可視化！ってほどではないんですが、こんなものがあるだけでも、Rxで困ったときのデバッグの足しにはなるかなー、と。</p>
<h2>BatchFrame</h2>
<p>BatchFrameは特定タイミング後（例えばEndOfFrameまでコマンドまとめるとか）にまとめて発火するという、Buffer(Frame)のバリエーションみたいなものです。都度処理ではなくてまとめてから発火というのは、パフォーマンス的に有利になるケースが多いので、そのための仕組みです。Bufferでも代用できなくもなかったのですが、Bufferとは、タイマーの回るタイミングがBufferが空の時にスタートして、出力したら止まるというのが大きな違いですね。その挙動に合わせて最適化されています。</p>
<pre><code class="language-csharp">// BatchFrame特定タイミング後にまとめられて発火
// デフォルトは0フレーム, EndOfFrameのタイミング
var s1 = new Subject&lt;Unit&gt;();
var s2 = new Subject&lt;Unit&gt;();

Observable.Merge(s1, s2)
    .BatchFrame()
    .Subscribe(_ =&gt; Debug.Log(Time.frameCount));

Debug.Log(&quot;Before BatchFrame:&quot; + Time.frameCount);

s1.OnNext(Unit.Default);
s2.OnNext(Unit.Default);
</code></pre>
<p>実装的には、まとめる＆発火のTimerはコルーチンで待つようにしているのですが、今回はそのIEnumeratorを手実装して、適宜Resetかけて再利用することで、パイプライン構築後は一切の追加メモリ消費がない状態にしてます。</p>
<h2>Optimize Combination</h2>
<p>オペレータの組み合わせには、幾つかメジャーなものがあります。特に代表的なのはWhere().Select()でしょう。これはリスト内包表記などでも固有記法として存在するように、フィルタして射影。よくありすぎるパターンです。また、Where().Where()などのフィルタの連打やSelect().Select()などの射影の連打、そして射影してフィルタSelect().Where()などもよくみかけます（特にWhere(x =&gt; x != null)みたいなのは頻出すぎる！）。これらは、内部的に一つのオペレータとして最適化した合成が可能です。</p>
<pre><code class="language-csharp">// Select().Select()
onNext(selector1(selector2(x)));

// Where().Where()
if(predicate1(x) &amp;&amp; predicate2(x))
{
    onNext(x);
}

// Where().Select()
if(predicate(x))
{
    onNext(selector(x));
}

// Select().Where()
var v = selector(x);
if(predicate(v))
{
    onNext(v);
}
</code></pre>
<p>と、いうわけで、今回からそれらの結合を検出した場合に、内部的には自動的にデリゲートをまとめた一つのオペレータに変換して返すようになっています。</p>
<h2>MessageBroker, AsyncMessageBroker</h2>
<p>MessageBrokerはRxベースのインメモリPubSubです。Androidで<a href="http://qiita.com/yyaammaa/items/57d8baa1e80346e67e47">OttoからRxJavaへの移行ガイド</a>のような記事があるように、PubSubをRxベースで作るのは珍しいことではなく、それのUniRx版となってます。</p>
<p>UniRxのMessageBrokerは「型」でグルーピングされて分配される仕組みにしています。</p>
<pre><code class="language-csharp">// こんな型があるとして
public class TestArgs
{
    public int Value { get; set; }
}

---

// Subscribe message on global-scope.
MessageBroker.Default.Receive&lt;TestArgs&gt;().Subscribe(x =&gt; UnityEngine.Debug.Log(x));

// Publish message
MessageBroker.Default.Publish(new TestArgs { Value = 1000 });

// AsyncMessageBroker is variation of MessageBroker, can await Publish call.

AsyncMessageBroker.Default.Subscribe&lt;TestArgs&gt;(x =&gt;
{
    // show after 3 seconds.
    return Observable.Timer(TimeSpan.FromSeconds(3))
        .ForEachAsync(_ =&gt;
        {
            UnityEngine.Debug.Log(x);
        });
});

AsyncMessageBroker.Default.PublishAsync(new TestArgs { Value = 3000 })
    .Subscribe(_ =&gt;
    {
        UnityEngine.Debug.Log(&quot;called all subscriber completed&quot;);
    });
</code></pre>
<p>AsyncMessageBrokerはMessageBrokerの非同期のバリエーションで、Publish時に全てのSubscriberに届いて完了したことを待つことができます。例えばアニメーション発行をPublishで投げて、Subscribe側ではそれの完了を単一のObservableで返す、Publish側はObservableになっているので、全ての完了を待ってSubscribe可能。みたいな。文字だけだとちょっと分かりにくいですが、使ってみれば結構簡単です。</p>
<h2>UniRx.Toolkit.ObjectPool/AsyncObjectPool</h2>
<p>UniRx.Toolkit名前空間は、本体とはあんま関係ないけれど、Rx的にベンリな小物置き場という感じのイメージでたまに増やすかもしれません。こういうのはあまり本体に置くべき「ではない」とも思っているのですが、Rxの内部を考慮した最適化を施したコードを書くのはそこそこ難易度が高いので、実用的なサンプル、のような意味合いも込めて、名前空間を隔離したうえで用意していってもいいのかな、と思いました。</p>
<p>というわけで、最初の追加はObjectPoolです。ObjectPoolはどこまで機能を持たせ、どこまで汎用的で、どこまで特化させるべきかという範囲がかなり広くて、実装難易度が高いわけではないですが、好みのものに仕上げるのは難しいところです。なのでまぁプロジェクト毎に作りゃあいいじゃん、と思いつつもそれはそれで面倒だしねー、の微妙なラインなのでちょっと考えつくも入れてみました。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
public class Foobar : MonoBehaviour
{
    public IObservable&lt;Unit&gt; ActionAsync()
    {
        // heavy, heavy, action...
        return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();
    }
}

// それ専用のPoolを&lt;T&gt;で作る
public class FoobarPool : ObjectPool&lt;Foobar&gt;
{
    readonly Foobar prefab;
    readonly Transform hierarchyParent;

    public FoobarPool(Foobar prefab, Transform hierarchyParent)
    {
        this.prefab = prefab;
        this.hierarchyParent = hierarchyParent;
    }

    // 基本的にはこれだけオーバーロード。
    // 初回のインスタンス化の際の処理を書く（特定のtransformに下げたりとかその他色々あるでしょふ）
    protected override Foobar CreateInstance()
    {
        var foobar = GameObject.Instantiate&lt;Foobar&gt;(prefab);
        foobar.transform.SetParent(hierarchyParent);

        return foobar;
    }

    // 他カスタマイズする際はOnBeforeRent, OnBeforeReturn, OnClearをオーバーロードすればおｋ
    // デフォルトでは OnBeforeRent = SetActive(true), OnBeforeReturn = SetActive(false) が実行されます

    // protected override void OnBeforeRent(Foobar instance)
    // protected override void OnBeforeReturn(Foobar instance)
    // protected override void OnClear(Foobar instance)
}

public class Presenter : MonoBehaviour
{
    FoobarPool pool = null;

    public Foobar prefab;
    public Button rentButton;

    void Start()
    {
        pool = new FoobarPool(prefab, this.transform);

        rentButton.OnClickAsObservable().Subscribe(_ =&gt;
        {
            // プールから借りて
            var foobar = pool.Rent();
            foobar.ActionAsync().Subscribe(__ =&gt;
            {
                // 終わったらマニュアルで返す
                pool.Return(foobar);
            });
        });
    }
}
</code></pre>
<p>基本的に手動で返しますし、貸し借りの型には何の手も入ってません！Rent後のトラッキングは一切されてなくて、手でReturnしろ、と。まあ、9割のシチュエーションでそんなんでいいと思うんですよね。賢くやろうとすると基底クラスがばら撒かれることになって、あまり良い兆候とは言えません。パフォーマンス的にも複雑性が増す分、どんどん下がっていきますし。</p>
<p>どこがRxなのかというと、PreloadAsyncというメソッドが用意されていて、事前にプールを広げておくことができます。フリーズを避けるために毎フレームx個ずつ、みたいな指定が可能になっているので、その完了がRxで待機可能ってとこがRxなとこです。</p>
<p>それと同期版の他に非同期版も用意されていて、それは CreateInstance/Rent が非同期になってます。</p>
<p>MessageBrokerと同じくAsyncとそうでないのが分かれているのは、Asyncに統一すべき「ではない」から。統一自体は可能で、というのも同期はObservable.Returnでラップすることで非同期と同じインターフェイスで扱えるから。そのこと自体はいいんですが、パフォーマンス上のペナルティと、そもそもの扱いづらさ（さすがにTのほうがIObservable[T]より遙かに扱いやすい！）を抱えます。</p>
<p>sync over asyncは、UniRx的にはバッドプラクティスになるかなあ。なので、同期版と非同期版とは、あえて分けて用意する。使い分ける。使う場合は極力同期に寄せる。ほうがいいんじゃないかな、というのが最近の見解です。</p>
<p>なお、Rent, Returnというメソッド名はdotnet/corefxの<a href="https://github.com/dotnet/corefx/tree/master/src/System.Buffers">System.Buffers</a>から取っています。</p>
<h2>AsyncReactiveCommand</h2>
<p>というわけでこちらもsync/asyncの別分けパターンで非同期版のReactiveCommandです。ReactiveCommandは何がベンリなのか分からないって話なのですが、実はこっちのAsyncReactiveCommandはかなりベンリです！</p>
<pre><code class="language-csharp">public class Presenter : MonoBehaviour
{
    public UnityEngine.UI.Button button;

    void Start()
    {
        var command = new AsyncReactiveCommand();

        command.Subscribe(_ =&gt;
        {
            // heavy, heavy, heavy method....
            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();
        });

        // after clicked, button shows disable for 3 seconds
        command.BindTo(button);

        // Note:shortcut extension, bind aync onclick directly
        button.BindToOnClick(_ =&gt;
        {
            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();
        });
    }
}
</code></pre>
<p>interactableの状態をコード実行中、というかつまり<code>IO&lt;T&gt;</code>が返されるまでfalseにします。連打防止でThrottleFirstがよく使われますが、それをより正確にコントロールしたり、また、引数にIReactiveProperty[bool]を渡せて、それを複数のAsyncReactiveCommandで共有することで、特定のボタンを実行中は他のボタンも実行できない、のような実行可否のグルーピングが可能になります（例えばグローバルでUI用に一個持っておけば、ゲーム中でUIは単一の実行しか許可されない、的なことが可能になる）</p>
<h2>PresenterBase再考</h2>
<p>PresenterBase、Obsoleteはつけてないのですけれど、GitHub上のReadMeで非推奨の明言を入れました。賢い基底クラスは悪。なのです。POCO。それはUnityにおいても何事においても例外ではない。その原則からするとPresenterBaseは賢すぎたのでナシ of the Year。動きはする、動きはするんですが……。</p>
<p>Model-View-Presenterパターン自体の否定ではなくて（それ自体は機能するとは思っています、ただし関心がModelにばかり向きがちですが、Viewは何か、Presenterは何か、についてもきちんと向き合わないとPresenterが奇形化するかなー、というのは実感としてある。ViewであるものをPresenterとして表現してアレゲになる、とか）、PresenterBaseというフレームワークのミスかな、とは。です。</p>
<p>とりあえずいったん初期化順序が気になるシーンは手でInitializeメソッド立てて、それをAwake, Startの代わりにして、呼ばせる。いじょ。みたいな素朴な奴で十二分かなー、とオモッテマス。結局。メリットよりもデメリットのほうが大きすぎたかな。反省。</p>
<p>この辺りに関してはアイディアはあるので、形にするまで、むー、ちょっと味噌汁で顔洗って出直してきます。</p>
<h2>まとめ</h2>
<p>あんまり大きな機能追加はなく細々とした変化なんですが、着々と良くはなっているかな、と！</p>
<p>Rxに関してもバッドプラクティスを色々考えられるというか反省できる（おうふ……）ようになっては来たので、どっかでまとめておきたいですね。油断するとすぐリアクティブスパゲティ化するのはいくないところではある。強力なツールではあるんですが、やりすぎて自爆するというのは、どんなツールを使っても避けられないことではあるけれど、Rxがその傾向はかなり強くはある。</p>
<p>まぁ、sync over asyncはいくないです。ほんと（思うところいっぱいある）。</p>
<p>というわけかで繰り返しますが、9/13日に<a href="https://atnd.org/events/80089">Photon勉強会【Photon Server Deep Dive - PhotonWireの実装から見つめるPhoton Serverの基礎と応用、ほか】</a>で登壇するので、よければそちらも是非是非です。</p>
</div>
<h1><a href="https://neue.cc/2016/07/28_535.html">LightNode 2 - OWINからASP.NET Coreへの移植実例</a></h1>
<ul class="date"><li>2016-07-28</li></ul>
<div class="entry_body"><p><a href="https://docs.asp.net/en/latest/">ASP.NET Core</a>以前に<a href="https://www.microsoft.com/net/core">.NET Core</a>をガン無視している昨今。というのも、.NET Coreというかようするところ最近の.NETは横、つまりクロスプラットフォームへの広がりなんですよね。それ自体は素晴らしく良いことではあるのですが、縦、つまり機能面での拡充があるのかどうかというと、あんまない気がしています。それは、クロスプラットフォームいうても基本的にはWindowsでしか現状/当分は使わないんだよなー、という私みたいな人間にとってはあまり興味を引かれるものではないのであった。</p>
<p>とかっていつまでも言ってるのもアレなので、とりあえず<a href="http://neuecc.github.io/LightNode/">LightNode</a>(という私の作ってるOwinで動くMicro REST Framework、ようはASP.NET Web APIみたいなやつ)をASP.NET Coreに移植してみました。アプリケーションの移植じゃなくてライブラリの移植なので、むしろ楽です。LightNodeはガチガチにOwinのみで構築していたので、ほとんど単純な置換のみでOKでした。</p>
<ul>
<li><a href="https://www.nuget.org/packages/LightNode/">Install-Package LightNode -Pre</a></li>
</ul>
<p>ASP.NET Coreで動作させるだけなら、OWIN - ASP.NET Coreのブリッジを使うという手もありますが、今回は完全にASP.NET Core向けに書き直しました。せっかくやるなら、ちゃんとしっかりしたものにしたいですしね、HttpContextのほうが望ましいのにIDictionaryなEnvironmentが露出してたりすると嫌じゃん。そんなわけでつまり、OWINに関連する部分は完全にASP.NET Core仕様に変わったので、互換性はありません。</p>
<h2>ASP.NET Coreライブラリ開発の準備と移植手順</h2>
<p>準備として<a href="https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs">Visual Studio 2015 Update 3</a>と<a href="https://www.microsoft.com/net/core">.NET Core SDK</a>を入れればOK。が、しかしいきなり.NET Core SDKがUpdate 3が入ってねーよエラーが出てインストールできなくて泣いた。世の中厳しい。<a href="http://forums.asp.net/t/2099735.aspx?Cannot+install+DotNetCore+1+0+0+VS2015Tools+Preview2">Forumによるとそういう事例多数</a>。対応としては「DotNetCore.1.0.0-VS2015Tools.Preview2.exe SKIP_VSU_CHECK=1」で叩けば入るよって話で、そうして叩くことによってようやく準備OK。幸先は悪い。</p>
<p>そうして入ったらテンプレートに.NET Core系があるので、とりあえずClass Library(.NET Core)を作る。参照してるのは .NETStandard Library 1.6.0。この辺良く分からないんですが、<a href="https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md">corefx/.NET Platform Standard</a>によると.NET 4.6.3ぐらいに相当するそうで。ふーむ、まぁASP.NET Core系がnetcoreapp 1.0で1.6と同じところらしいので、このままでOKっぽい。気がする。とりあえず。UWPとかが視野の場合はちょっと話は違うのでしょうけれど。</p>
<p>次にASP.NET系のライブラリをNuGetで入れる。のですが、どの参照をいれればいいのかがまず分からない:) 今回はOwin的なMiddlewareを作りたかったんですが、ここは<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Http.Abstractions/">Microsoft.AspNetCore.Http.Abstractions</a>が最適のようですね。これでようやくスタートライン。</p>
<p>既存のLightNodeのコードを突っ込むと当然激しくコンパイルエラーが出るのでここからチマチマと直していきました。まず目につくのがリフレクション関連で、IsEnumとかTypeに生えてる判別系のメソッドが片っ端から動いてません。誰しもが通る.NET Coreの洗礼！これは、type.GetTypeInfo() によるTypeInfoのほうにIsEnumなどなどが生えてるので、ひたすら<a href="https://msdn.microsoft.com/ja-jp/library/system.reflection.introspectionextensions.gettypeinfo(v=vs.110).aspx">GetTypeInfo</a>を書き加えるだけの簡単なお仕事をします。GetTypeInfoの嫌なところはSystem.Reflection名前空間への拡張メソッドとして実装されてるので、IntelliSenseに出てこなくてイラッとする率が高いこと……。まぁ、あと実際にひたすらGetTypeInfoを書きまくるのは面倒くさいので、Typeへの拡張メソッドとして GetTypeInfo().IsEnum とかコンパイルエラー出てるものだけ定義してやることで作業量低減（まぁプロパティは()を書かなきゃいけないのでアレですけど。拡張プロパティはよ）</p>
<p>また、Parallel.ForEach がない！これは.NETStandardには含まれてないそうなので、別途<a href="https://www.nuget.org/packages/System.Threading.Tasks.Parallel/">System.Threading.Tasks.Parallel</a>をNuGetから拾ってくる。なんかこう、標準に入ってて当たり前だろ、みたいに思うものが別添えになってるの、不思議な感覚ですね。これだともはやReactive Extensionsが標準にないとかImmutable Collecitonsが標準にないとか、どうでもというか全く大したことない話に見えます。なんせParallel.ForEachすらないんだから！（ところでNuGetのVersion History見ると結構細かくアップデートされてはいるんですが、いったいなにが変わったのかRelease Note出して欲しくはある……）</p>
<p>AppDomain.CurrentDomain.GetAssemblies もない！対象アセンブリ内からControllerがわりのクラスを引っ張ってきたくて、読み込み済みのAssemblyからGetTypesして全部検査したい、というのをやりたいわけですが、ないんですねえ。そして実際、これの代替は今のところないらしい……（というかAppDomainが今のところない）。フレームワーク系の常套手段なのに……。Loaderがどうのこうのとか、あとASP.NET Core側で特化した何かはありそうな気配を感じなくもなかったんですが、今回はGetAssembliesじゃなくても回避可能なので（一手間ではあるんですが、外側からその対象AssemblyのTypeを渡してさえくれればAssembly拾えてGetTypesできる）、Typeを渡してもらう方式のみに制限することでとりあえず回避しました。</p>
<p>ここから先はASP.NET Core的なところ。 <code>IDictionary[string, object]</code> を <code>HttpContext</code>に変える。そして<code>AppFunc</code>を<code>RequestDelegate</code>に変える。だけの簡単なお仕事。OWINとASP.NET Coreの差異はそれだけだし中身一緒なので、機械的に置き換えていくだけ。OWINに関してはどうだのこうだのと一悶着あったりなかったりで色々ありましたが、一番下のレイヤーで触ってる限りは、概念はほんと完全に一緒なので無駄なことは全くなかったですね。上のレイヤーで触っていても、それはそれで何も考えず置き換えられるはずなので、実際のとこOWINは良かったと思ってます。新しい、ASP.NET CoreのHttpContextは、昔のHttpContextというよりかは、OWINのEnvironmentそのものだったりしますからね。</p>
<p>これでコンパイル通ったので、実行確認のためASP.NET Core Web Application(.NET Core)テンプレートから新規プロジェクトを作成。ASP.NET Core的なテンプレートはもちろんEmptyで。Startupに以下のを書いて</p>
<pre><code class="language-csharp">using LightNode;
using LightNode.Server;

public class Startup
{
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        app.UseLightNode(typeof(Startup));
    }
}

public class Toriaezu : LightNodeContract
{
    public string Echo(string x)
    {
        return x;
    }
}
</code></pre>
<p><code>http://localhost:15944/Toriaezu/Echo?x=hoge</code> にアクセスでhogeが出力される。おー、ちゃんとできてますね！当たり前っちゃあ当たり前でしょうけれど、あまりに意外にすんなり動いたので普通に感動した。いやあ、いいじゃんASP.NET Core。</p>
<h2>Swagger Included</h2>
<p>LightNode 1の時は<a href="http://swagger.io/">Swagger</a>は別添えだったんですが、今回はとりあえず一緒に突っ込んじゃいました。JSON.NET使ったJSON出力とかも同梱です（というかデフォルトがそれになってます）。まぁSwaggerに関してはDependencyが増えるわけでもないしいいじゃんといえばいいじゃん、なので。いいかな、と。LightNodeのSwagger統合はビュー(HTMLとかCSSとか画像とか）がDLLに埋め込んでやってたんですが、そうしたリソースを.NET Coreで埋め込むにはどうすればいいのか。今まではPropertiesで埋めてったんですが、.NET Coreではproject.jsonに書くのが正解のようですねー。</p>
<pre><code class="language-json">&quot;buildOptions&quot;: {
        &quot;embed&quot;: [
            &quot;Swagger/SwaggerUI/**&quot;
        ]
}
</code></pre>
<p>buildOptions.embedで指定できるようで、ああ、なるほど、これはこれで知ってれば凄く楽なので、全然良いですね。良いです。いいじゃん.NET Core。</p>
<p>というわけでサクッとSwagger統合も果たせた。</p>
<pre><code class="language-csharp">public class Startup
{
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        app.Map(&quot;/api&quot;, builder =&gt;
        {
            builder.UseLightNode(typeof(Startup));
        });

        app.Map(&quot;/swagger&quot;, builder =&gt;
        {
            var xmlName = &quot;AspNetCoreSample.xml&quot;;
            var xmlPath = Path.Combine(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location), xmlName);

            builder.UseLightNodeSwagger(new LightNode.Swagger.SwaggerOptions(&quot;AspNetCoreSample&quot;, &quot;/api&quot;)
            {
                XmlDocumentPath = xmlPath,
                IsEmitEnumAsString = true
            });
        });
    }
}
</code></pre>
<p>うーん、全然いけますね、じゃあ次行こう、次。</p>
<h2>Glimpse not Included</h2>
<p>LightNodeのウリはSwagger統合と<a href="http://getglimpse.com/">Glimpse</a>統合、特にGlimpseへの診断情報表示は力を入れていて(Glimpseへのハックも含めて）他にここまでやってるフレームワークはないほどでした。ので、当然ASP.NET Coreでもやりたいわけですが、んー、そもそもGlimpseがまだASP.NET Coreに本対応してない……。2.0 Betaで一応対応してるということで、あるだけマシか？と思いきや、かなり古いもので全然動かない。というかGitHubでの開発も(1.x系も2.x系も)なんかもうほとんど動いてない……。<a href="http://blog.getglimpse.com/2015/07/14/glimpse-and-microsoft-join-forces/">メイン開発者2名がMicrosoftに転職</a>ということで、ASP.NET Core対応含めてよりアクティブになるのかなー、とか思ってたら、まさかの大失速……。多分、Microsoft内では別のことやっていて、そっちが忙しくて以前よりもなお作業できなくなってるんでしょうね。しかし、うーん、残念だなあ。</p>
<p>ASP.NET Coreに移れない/移りたくない理由があるとしたら、このGlimpseが全然対応してないってことでしょうかねえ。Glimpse自体はほんと素晴らしいので、なんとか再生してくれればいいのですけれど。</p>
<h2>感想</h2>
<p>.NET CoreにせよASP.NET Coreにせよ、結構コマンド操作がフィーチャーされてて、ゆとりな私には辛いものがあるんですが、さすがに1.0、普通に書いてる限りは、Visual Studio使ってる限りは特にコマンドの必要性もなく、それなりに快適に書けますね。安定してねえー、とか不満に思うことも全然ないので、もう普通に良さそう。いや、思ってたよりも全然いい感じだった。</p>
<p>さて、じゃあASP.NET CoreでもLightNode使おうぜ！になるかというと、うーん、とりあえずまずは普通にASP.NET Core MVCでいいでしょう（笑）。時代がねー、ちょっと違いますからね。LightNodeも3年前ですから。まぁ、でも設計思想とか全然古くなってないというかむしろASP.NET Core MVCがようやく追いついてきたかな、ぐらいの勢いだとは思ってます！例えば<a href="https://docs.asp.net/en/latest/mvc/controllers/filters.html">ASP.NET Core MVCのFilter</a>は完全にLightNodeのフィルターと一緒ですからね。</p>
<pre><code class="language-csharp">// ASP.NET Core MVC
public class SampleAsyncActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        // do something before the action executes
        await next();
        // do something after the action executes
    }
}

// LightNode
public class SampleFilterAttribute : LightNodeFilterAttribute
{
    public override async Task Invoke(OperationContext operationContext, Func&lt;Task&gt; next)
    {
        // do something before the action executes
        await next();
        // do something after the action executes
    }
}
</code></pre>
<p><a href="https://docs.asp.net/en/latest/mvc/controllers/filters.html#filters-vs-middleware">Filters vs. Middleware</a>の話なんかも、それは3年前に全部考えきって実装し実践してますから(ﾎｼﾞﾎｼﾞ。という話なんで、まぁ全然LightNode 2もいいじゃないでしょうか。LightNodeは他に、密接に統合されたクライアント自動生成などもありますしね。かわりにMVC + Web API的な、Razorのビューを返すコントローラーとWeb APIコントローラーとの統合、みたいなのができてないのは痛み。ここ馴染ませられないのは普通に不便だということを最近良く感じてるので、ASP.NET Core MVCいいですね。いいですね。</p>
<p>OWINベースで書いたものの移行はそこそこすんなり行けるだろうなあ、という感触はなんとなく掴めた気がします。逆に、やっぱASP.NET MVC 5あたりからの移行は厳しそう。厳しいでしょう。どうするんでしょうね、どうしようかな、参りましたね……。</p>
<p>ともあれせっかくの新しい.NETの幕開けなので、もう少しポジティブに情報掴んで行こうかなー、という気にはなれたのでめでたしめでたし。</p>
</div>
<h1><a href="https://neue.cc/2016/07/16_534.html">BigQueryを中心としたヴァルハラゲートのログ分析システム</a></h1>
<ul class="date"><li>2016-07-16</li></ul>
<div class="entry_body"><p>というタイトルで<a href="https://events.withgoogle.com/google-for-mobile-game-boot-camp-tokyo/">Google for Mobile | Game Bootcamp</a>で発表しました。4月なので3ヶ月遅れでスライド公開です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/dcoplrKYrwc1hP" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/bigquery-64082920" title="BigQueryを中心としたヴァルハラゲートのログ分析システム" target="_blank">BigQueryを中心としたヴァルハラゲートのログ分析システム</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>なんかあまり上手く話せなかったな、という後悔がなんかかなり残ってます:) スライドもフォント細くて吹き出しの文字が見辛いな！とりあえず、WindowsでBigQueryなシステムとしては一つの参考例にはなるのではないかなー、と思います。第一部完。</p>
<p>第二部は<a href="https://github.com/neuecc/EtwStream">EtwStream</a>への移行と、BigQuerySinkのOSS公開かなー、というところなんですがまだまだまだまだまだ先っぽいのでアレでコレでどうして。できれば誰もが秒速でASP.NETアプリケーションのログをBigQueryに流し込める、みたいな状況にしたいのですけれどねえ、そこはまだまだ遠いかなー、ですね。そのへんの.NETのエコシステムは弱いと言わざるをえない。けれどまぁ、地道に補完していきたいと思ってます。</p>
</div>
<h1><a href="https://neue.cc/2016/06/29_533.html">Japan VR Hackathonに参加し、AMD賞受賞しました</a></h1>
<ul class="date"><li>2016-06-29</li></ul>
<div class="entry_body"><p><a href="https://vrhackathon.co/">Japan VR Hackathon</a>に参加してきました！の<a href="http://mogurapr.hatenablog.com/entry/2016/06/28/235939">結果が昨日発表</a>されまして、AMD賞(Best Graphics)を受賞しました。やったー。事前に決めた5人チームでの参加で、大賞取る！という気概でやってたので、入選できて良かったです。</p>
<p>今回作ったのは「Clash of Oni Online」というゲームで、<a href="https://www.htcvive.com/jp/">HTC Vive</a>用のVRゲームです。テーマである&quot;日本らしさ&quot;を（一応）イメージした（一応）和風の装い。</p>
<p class="noindent">
    <iframe width="640" height="360" src="https://www.youtube.com/embed/yUIe2SWPGZo" frameborder="0" allowfullscreen></iframe>
</p>
<p>飛んで来る岩を</p>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/16436948/610a6a4a-3ddd-11e6-804b-8a16cd7493c6.png" />
</p>
<p>吹っ飛ばす</p>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/16436958/72288d02-3ddd-11e6-9bca-d2ca14f18bf9.png" />
</p>
<p>という、VRバッティングセンター。ViveはVRというだけじゃなくてコントローラーがあるのがいいですねー。</p>
<p>今回、2日間 31時間で242コミット（最初のコミットが2016/06/18 09:13で 最後のコミットが 2016/06/19 16:34）。時間制限のなかでは、ちゃんとゲームしてる（ゲーム性的にもとりあえず爽快に全部打ち倒すパターンと一球一球を狙い撃ちしないパターンを用意）し、グラフィックもまぁ見栄えがするレベルで、オンライン協力プレイも実装（ただしデモ時はオフラインモード）したのは結構頑張った。ハッカソン系参加が全員初めての割には綺麗に収められた感あります。</p>
<p>チーム編成と最終的な役割は</p>
<ul>
<li>私（プログラマ）：プロジェクトセットアップ、敵ボス挙動、サーバーセットアップ、エフェクト発注、雑進行管理、プレゼンスライド作成、動画撮影</li>
<li>プログラマ：マルチプレイプログラム、シーン管理プログラム</li>
<li>プログラマ：Viveプログラム、エフェクト組み込み</li>
<li>プログラマ：企画、地形エディット、サウンド、アセット検索、デモ</li>
<li>テクニカルアーティスト：アセット検索、敵モーション作成、ライティング、エフェクト</li>
</ul>
<p>という感じでした。全員ほぼViveのプログラミング経験はなし(SDK入れて雰囲気掴んだことはあります程度）</p>
<p>最初に入れたアセットは</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">UniRx</a> - ないと無理</li>
<li><a href="https://github.com/neuecc/LINQ-to-GameObject-for-Unity">LINQ to GameObject</a> - ベンリ、だけど今回は別にあまり使わず</li>
<li><a href="https://github.com/neuecc/PhotonWire">PhotonWire</a> - マルチプレイ前提なので。合わせてサーバー側プロジェクトもセットアップ</li>
<li><a href="https://www.assetstore.unity3d.com/jp/#!/content/32647">SteamVR Plugin</a> - Viveがターゲットなので</li>
<li><a href="https://www.assetstore.unity3d.com/jp/#!/content/63141">The Lab Renderer</a> - 使ったことなかったので結局あんま余裕なく使えなかった...</li>
</ul>
<p>という編成から随時アセット追加追加。</p>
<h2>タイムライン</h2>
<p>1週間ぐらい前に参加を決める。3日前ぐらいに「2人マルチ協力プレイ」「背中合わせにして立ちまわる（時代劇にある格好いい感じのアレ）雑魚戦 + デカい鬼を撃退するボス戦というアクションゲーム」「グラフィックで魅せる」を軸にする。というのを決定。和風です、和風。コミュニケーション手段としてSlack（チャット）を前日に立てる。Unityのバージョンを5.4.0b21に決めて全員にインストールしておいてもらうように。持ち込み物としてHTC Viveを2台用意。当日、会場ついてからGitHub（リポジトリ管理）のPrivateリポジトリを立てて全員招待。</p>
<p>雑魚戦＋ボス戦といっても、作りきれるか怪しいので（実際ボス戦で手一杯だった、そりゃそうだ）、ボス戦から先に作っていくように。最初に決めていた役割分担は</p>
<ul>
<li>私（プログラマ）：マルチプレイ</li>
<li>プログラマ：ボスプログラム、プレイヤー行動プログラム</li>
<li>プログラマ：ボスプログラム、プレイヤー行動プログラム</li>
<li>プログラマ：地形アセット購入/組み込み・サウンド購入/組み込み、パーセプションニューロン触る（使えそうなら使う）</li>
<li>テクニカルアーティスト：モデルやらモーションやらエフェクトやら</li>
</ul>
<p>でした。まぁマルチプレイといってもUnity側のプログラムがある程度できないとやることもないんで、まずは自分で持ってきたViveを自前PCのSurface Bookに繋ごうとしたらSurface Bookの出力をViveがうまく認識してくれなくて最終的に諦め（Forumとか見た限りだとノートPCの出力端子とのトラブル事案は結構多い模様なのでshoganaiね)。ということでViveのプログラミングは他の人に完全に任せることにして、ボスのプログラムを作っていこうかなー、ということに。ボス戦は、崖のような場所にボスが立っている（下半身は見せない）というイメージが共有されたので</p>
<p class="noindent">
<img width="640" src="https://cloud.githubusercontent.com/assets/46207/16182516/0484d8f2-36e2-11e6-9f45-813e1915fd4e.gif" />
</p>
<p>迫り来るシリンダー撃退ゲーとして作成。雑に作ったこのシーンは、初日ずっとフル活用されることになったのだった。動画系は常時<a href="http://blog.bahraniapps.com/gifcam/">GifCam</a>で撮ってSlackにあげてました。イメージが瞬時に共有されますし、良い内容だとテンションも上がりますし。</p>
<p>この時点で<a href="https://www.assetstore.unity3d.com/jp/#!/content/3595">LeanTween</a>を追加。マルチプレイできるようにするので、非確定要素をいれないように、というのとそんな凝ることもないしなので弾は全部トゥイーンで制御しようかと。トゥイーンライブラリは色々ありますが、今のとこ私が選ぶなら<a href="http://dotween.demigiant.com/">DOtween</a>かLeanTweenかなぁ。普通だったらDOtween選びます。ただ、今回はLeanTweenにしました、ちょっと慣れておこうかな、と思って。LeanTweenは複数のTweeenの制御とかの補助が入ってないんですが、その辺はUniRxで制御させたので全く問題なし。基本的に完了などのイベントをObservable化すれば既存トゥイーンライブラリとUniRxの統合は容易ですし、かなりいい具合にコントロールできます。実際今回は色々な挙動をそれで組みました。ところで、今ひっそりとUniRx前提のハイパフォーマンスでリアクティブなトゥイーンライブラリを作っているので、それが完成したら基本的にそれしか使いません:) まぁ、というのもあって色々なトゥイーンライブラリを試しているというのもあります。</p>
<p>このシーンをプレイヤー行動プログラム側に渡して、VIVEで弾き返したり防いだりを作ってもらう感じに。パーセプションニューロン触るマンはパーセプションニューロンを触りつつサウンド探しを、テクニカルアーティストはボスのモデル（これ自体は買ったもの）のUnityへのインポートとテクスチャ調整とモーション付けを、私は弾のバリエーションを作ってました。</p>
<p class="noindent">
<img width="640" src="https://cloud.githubusercontent.com/assets/46207/16182927/556a57b6-36e6-11e6-93a1-cedd15ae33b8.gif" /></p>
<p>豪速球を投げ込むバッティングセンター的イメージ。手前で弾が伸びてくるので振りにくい。二者択一（手前のキューブはプレイヤーAとプレイヤーBです、マルチ協力プレイだから！）でどっちに来るか分からないので、なんとなく緊迫感あってゲーム的でもあるよね、ということで最終的なボス行動にも採用。</p>
<p class="noindent">
<img width="640" src="https://cloud.githubusercontent.com/assets/46207/16183060/f90b428a-36e7-11e6-84e6-ce6e6b504536.gif" /></p>
<p>ぶわーっと全方位に出すのが欲しい(VIVEのデモゲームのThe LabにあるXortexという360度シューティングのボス弾のような）というオーダーを受けて。中々いい感じに派手なので、これも採用。</p>
<p>あとはボツ案的な弾を作ったり、その他、この時点ではまだ夢膨らみんぐで、ボスの行動も腕をばちーんと振り下ろしてきてそれを斬撃の連打で防いで弾き返す（協力プレイなので、片方が防いでたらそれに加勢しないとダメ、とか）、などを想定したコードを準備したりAIは少しリッチにしようかな、と<a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)">BehaviorTree</a>のライブラリ書いてたり（ノードエディタなしの基本的なランタイムだけ）、プレイヤープログラム作るチームは盾で防御する処理（最終的に削られたけれど最初は刀と盾の装備のつもりだった）をやってたら、夜0時。うーむ、時間が過ぎるのは早い。</p>
<p>この辺でさすがに未だにシリンダーとキューブが相手で完成形が全く見えてないのはヤヴァいでしょうということで、シーン統合しましょう祭り。特にテストで大量のアセットを抱えていたマップ作るマンがGitHubに中々Pushできないなどなどトラぶりつつも、2時ぐらいにようやく一段落。マップにモーション付きボスモデル配置して、とりあえず弾を出るようにして、でこんな具合に。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/16183468/219560d2-36ed-11e6-9bb9-ef072178f880.gif" alt="ezgif com-resize" /></p>
<p>色々アレですが、しかし中々格好よくてテンションあがりますね！その他プレイヤーのほうも入れこんだりなんなりで床に転がって仮眠とって、朝。キューブにも岩を当てはめてついに出来上がったのは……！</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/16183503/8739926e-36ed-11e6-8954-ef885f0e3300.png" alt="image" /></p>
<p>んー、悪くない。悪くないんだけど、和ではない。雲南省（適当なイメージ）とかそういう中国の高山っぽい気すらする。ここで実際完成させる仕様を概ね確定。</p>
<ul>
<li>マップは明確に和テイストが出るものにリテイク</li>
<li>ボスは殴り攻撃などなし、弾のみ</li>
<li>盾はなし、弾を打ち返してボスにダメージ与えて、一定回数食らわせたらクリア</li>
<li>マルチプレイは諦めないので作業は並走、ただし最終的にはシングルプレイが完全にプレイできるの優先</li>
</ul>
<p>私は、ボスのモーションが二種あって、殴りつけてくるつもりでつけてもらったモーションはボスが弾を投げ飛ばしてくる（つもり）な雰囲気に適当に調整（タイミングは適当にdelayかけて目視で合わせただけでジャストとは程遠いんですが、まぁなんとなくそれっぽく見えなくもないのでヨシとした）したり、もう一個の大技っぽくやってくるモーションは、なんか岩を抱え込んでる感じにできそうな気がしたので、適当にそれっぽく位置合わせして破裂させてみることに。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/16183698/f027a2a0-36ef-11e6-9ebc-649b5f76336c.gif" alt="resize" /></p>
<p>うん、それっぽい。地面にめり込んでってるのとかも、まぁ全然気にならないし。このボス行動は今回のハッカソンで私的な私が作った中では一番よくやりましたしょうでした。全部、偶然素材が揃っただけなんですがうまく噛み合ったということで。</p>
<p>この後は、マップを和テイストに差し替えて常時マップブラッシュアップ、ゲームの要素が確定したので、各種のヒットエフェクトを作ってもらって当て込みや効果音、プレイ感向上のための弾の動きなどの調整、そして諦めてないマルチプレイなどなどを時間ギリギリまで使ってなんとか完成……！（実際、最後の30分でボスのダメージエフェクトがつき、最後の15分前でボスが死ぬようになった程度にギリギリだった）</p>
<p>マルチプレイに関しては、Viveのセンサーが干渉してうまく二台プレイの調整ができなかったのと、もう一台のデスクトップPCを会場の無線LANに繋げなくて、というネットワーク的な問題で断念。いちおう、プログラム側はマルチ想定で動作するように最後まで組んでました、いやほんと。サーバー側、AzureのVMも一時的なものなのでということで、かなりマシンパワーの強いものに変更したりしたんですけどね、というわけでここをお見せできなかったのは残念。なので、最後の5分でマルチプレイ用のログイン待機処理を消して、リリースビルド完成。お疲れ様ー。</p>
<h2>完成形</h2>
<p>出来上がったものは、マップリテイクによって城が追加されたことにより「城下まで迫ってきた赤鬼を、手に持つサムライブレードにより撃退し、城を守る」という設定に。なっていた。完全後付けで。ゲーム名は特に何も考えもなく直前で「Clash of Oni Online」に大決定。</p>
<p>ハッカソンでの評価は特に会場でのプレゼンはなく、体験してもらって審査員が表を付けてく形式とのことで、あとはデモマンがいい感じに来場者に説明してるのを横目に私は会場を見学する:)最後の一秒までドタバタと調整を続けていた割には、目立ったバグもなくスムースにプレイできてて良かった良かった。</p>
<p>最終的には当日の審査ではなく後日の審査ということなので、プレゼン資料を作ったり動画を撮ったりして</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/2PlYr3M2epDy6U" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/clash-of-oni-online-vr-multiplay-sword-action" title="Clash of Oni Online - VR Multiplay Sword Action " target="_blank">Clash of Oni Online - VR Multiplay Sword Action </a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>結果待ち……！そして発表……！受賞……！やったね！</p>
<h2>反省点とか</h2>
<p>当初の想定よりもViveのルームスケールを活かしてない、直立不動のスタイルになったのは、ちょっと想定外。弾を避けたりとか、近寄ったりとかもうちょっとだけアクティブなのをイメージしていたので、しょうがないといえばしょうがないのだけれど、次に何か作るのだったら動くタイプのを作りたいですねぇ。</p>
<p>効果音が足りなかったり、割れてたり。効果音足りないのは、岩の音を、ボス撃破音とか足すべき箇所はいっぱいですよねー。マップリテイクで時間が取れなかったのがその辺の敗因か。Viveコントローラーと刀の位置が微妙にあってなかったり、足が地面に設置してなかったりといった、プレイヤーに対する調整も甘め。shoganai。この辺はViveプログラミングにて慣れてれば、スッと合わせられる話だと思うので、経験値を積もう。ボスの全方位弾が実は全方位じゃなくて左に寄ってるのは普通にロジックのバグ……。リテイク後のマップのクオリティが急ぎで用意しただけあってリテイク前に比べると低い（雑に光源足すためだけの灯籠を並べるとかしたかった）、ボスを遠方に置く形になってしまったのでスケール感が出なかった、など。</p>
<p>とか、まぁアラはいくらでも見つかりますが、基本的にはよくやったと思ってる……！よ！チームメンバーが全員、より良くするために自分の仕事を探して作りきっていったというのは純粋なハッカソンの楽しさという感じで、疲労困憊だけど達成感はありますね。</p>
<p>それとViveでのプログラミングは、結構ゲーム作成入門(Unity入門)にいいかもですね。3Dのプレイヤーの操作ってモーションつけたり色々ハードル高いですが、Viveならすぐに手の動きがキャプチャされて自由に動かせるアクションが作れるので、よくあるシューティングとかブロック崩しとか作っていくよりも楽しいんじゃないかな。（今のVR経験値が少ない現状なら）VRで空間を見て、Viveコントローラーで自由に操作できるというのは、それだけで楽しい体験を作れちゃいますしね。</p>
<p>そんなわけで、家でもViveを設置したしGeforce GTX 1080搭載PCも買ったので、ちょいちょいとVive用に何か作っていきたいという気持ちを強くしました。ので、ちょいちょいと出していければいいですねー。</p>
</div>
<h1><a href="https://neue.cc/2016/06/07_532.html">ObserveEveryValueChanged - 全てをRx化する拡張メソッド</a></h1>
<ul class="date"><li>2016-06-07</li></ul>
<div class="entry_body"><p>ブードゥーの秘術により、INotifyPropertyChanged不要で、値の変更を検知し、IObservable化します。例えばINotifyPropertyChangedじゃないところから、WidthとHeightを引き出してみます。</p>
<pre><code class="language-csharp">using Reactive.Bindings.Extensions;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        this.ObserveEveryValueChanged(x =&gt; x.Width).Subscribe(x =&gt; WidthText.Text = x.ToString());
        this.ObserveEveryValueChanged(x =&gt; x.Height).Subscribe(x =&gt; HeightText.Text = x.ToString());
    }
}
</code></pre>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15827886/1573ff16-2c48-11e6-9876-4e4455d7eced.gif" alt="wpfgif" /></p>
<p>なるほど的確に追随している。ソースコードはGitHub上に公開しました。</p>
<ul>
<li><a href="https://github.com/neuecc/ObserveEveryValueChanged">GitHub - ObserveEveryValueChanged</a></li>
</ul>
<p><a href="https://github.com/runceel/ReactiveProperty/">ReactiveProperty</a>と組み合わせることで、そのままバインダブルに変換することも可能です。</p>
<pre><code class="language-csharp">public class MyClass
{
    public int MyProperty { get; set; }
}

public partial class MainWindow : Window
{
    MyClass model;
    public IReadOnlyReactiveProperty&lt;int&gt; MyClassMyProperty { get; }

    public MainWindow()
    {
        InitializeComponent();

        model = new MyClass();
        this.MyClassMyProperty = model.ObserveEveryValueChanged(x =&gt; x.MyProperty).ToReadOnlyReactiveProperty();
    }
}
</code></pre>
<p>ついでにokazukiさんが、<a href="http://blog.okazuki.jp/entry/2016/06/07/032319">ReactiveProperty v2.7.3</a>に組み込んでくれましたので（今のところ).NET版では是非是非に使えます。UWP用とかXamarin用とかもきっとやってくれるでしょう（他人任せ）</p>
<h2>仕組み</h2>
<p><a href="https://msdn.microsoft.com/ja-jp/library/system.windows.media.compositiontarget.rendering(v=vs.110).aspx">CompositionTarget.Rendering</a>に引っ掛けて、つまり毎フレーム監視を走らせています。もともと<a href="https://github.com/neuecc/UniRx">UniRx</a>のために作った機構を、そのままWPFに持ってきました。CompositionTarget.Renderingは、アニメーション描画などでも叩かれている比較的低下層のイベントで、これより遅いと遅れを人間が検知できちゃうので影響が出るし、これより早くても視認できないので意味がない。という、ぐらいの層です。こういった用途ではベストなところ。</p>
<p>毎フレーム監視がありかなしか。ゲームエンジンだと、そもそもほとんどが毎フレームごとの処理になっているので違和感も罪悪感もないのですけれど、全てがイベントドリブンで構築されている世界にそれはどうなのか。もちろん、原則はNoです。素直にINotifyPropertyChangedを書くべきだし、素直にReactivePropertyを書くべきでしょう。</p>
<p>ただ、アニメーションでも使われるしデバイスのインプット（LeapMotionとか）もその辺に引っ掛けるようなので、ここにちょっとプロパティに変更があるかないかのチェック入れるぐらい別にいいじゃん（どうせCPU有り余ってるんだし）、みたいな開き直りはあります。かなり。割と。</p>
<p>ObserveEveryValueChangedは、毎フレーム回っているような低下層の世界から、イベントドリブン（リアクティブ）な世界に引き上げるためのブリッジとしての役割があります。そう思うと不思議と、よく見えてきませんか？ただ「毎フレームポーリングかよ、ぷぷｗ」とかって一笑するだけだと視野が狭く、もう少しだけ一歩踏み込んで考えてみると思考実験的に面白い。私はコード片に意思を詰め込んでいくのが好きですね。哲学といってもいいし、ポエムでもある。そこには幾重も意味が込められています。</p>
</div>
<h1><a href="https://neue.cc/2016/05/31_531.html">PhotonWire - Photon Server + Unityによる型付き非同期RPCフレームワーク</a></h1>
<ul class="date"><li>2016-05-31</li></ul>
<div class="entry_body"><p>というのを作りました。Unityでネットワークマルチプレイヤーゲーム作るためのフレームワーク。といっても、100%自作じゃなくて、基本的に<a href="https://www.photonengine.com/en/onpremise">Photon Server</a>というミドルウェアの上に乗っかるちょっと高級なレイヤーぐらいの位置づけです。去年の9月ぐらいに作った/作ってるよ、というのは発表していたのですが、それからかれこれ半年以上もpublicにしてないベイパーウェアだったのですが（<a href="http://grani.jp/">グラニ社内</a>では使ってました）、重たい腰を上げてやっと、やっと……、公開。</p>
<ul>
<li><a href="https://github.com/neuecc/PhotonWire">neuecc/PhotonWire</a></li>
</ul>
<p>謳い文句は型付き非同期RPCフレームワークで、サーバー側はC#でasync/awaitを使ったメソッド実装、Unity側はそこから生成されたUniRx利用のメソッドを呼ぶだけで相互に通信できます。それでなにができるかというと、Visual StudioでUnity -&gt; Server -&gt; Unityと完全に一体化してデバッグできます。全部C#で。もうこれだけで最強でしょう。他は比較にならない。勝った。終わった。以上第一部完。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15651046/f0931f46-26b7-11e6-979c-b8a766511617.gif" alt="" /></p>
<p>真面目に特徴、強みを上げると、以下のような感じです。</p>
<ul>
<li>完全タイプセーフ。サーバー-サーバー間は動的プロキシ、クライアント-サーバー間は事前クライアント生成。</li>
<li>IDLレス。C#サーバーコードのバイナリを元にして、クライアントコードを生成するので、普通にサーバーコードを書くだけ。面倒なIDLはゴミ箱ぽい。</li>
<li>高性能。サーバーはasync/awaitで、クライアントは<a href="https://github.com/neuecc/UniRx">UniRx</a>により完全非同期で駆動。特にサーバーのC#コードはIL直書きも厭わずギチギチに最適化済み。</li>
<li>事前生成シリアライザによるMsgPackでのシリアライズ/デシリアライズ。デシリアライズは更にマルチスレッド上で処理してUniRxでメインスレッドにディスパッチするのでフレームレートに一切影響を与えない。</li>
<li>Visual Studioとの完全な統合。高いデバッガビリティと、Analyzer利用を前提にしたフレームワーク構成はVS2015時代の新しい地平線。</li>
<li>外部ツール「PhotonWire.HubInvoker」により外からAPIを直接叩ける。</li>
</ul>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/15658680/4f2fea38-26fa-11e6-95ac-d8de2585a562.png" />
</p>
<p>HubInvokerは私にしては珍しく、ちゃんと見た目にこだわりました。これの外観の作り方は<a href="http://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a>で記事にしてます。</p>
<h2>Photon Serverを選ぶ理由</h2>
<p>Unityでもネットワーク系は色々な選択肢があると思います。</p>
<ul>
<li>UNET</li>
<li>PUN + Photon Cloud</li>
<li>Photon Server(SDK直叩き)</li>
<li>モノビットエンジン</li>
<li>WebSocketで自作</li>
<li>MQTTで自作</li>
</ul>
<p>このあたりは見たことある気がします。そのうちUNETは標準大正義だしAPIもProfilerも充実してる感なのですが、uNet Weaver Errorがムカつくので(コンパイルができなくなるという絶望！特にUniRx使ってると遭遇率が飛躍的に上昇！)、それが直らないかぎりは一ミリも使う気になれない。というのと、サーバーロジックを入れ込みたいどうしてもとにかくむしろそれがマスト、な状況の時にというか割とすぐにそうなると思ってるんですが、Unity純正だと、逆にUnityから出れないのが辛いかな、というのはありますね（ロードマップ的にはその辺もやるとかやらないとかあった気がしますが、まぁ遠い未来ということで）。Unity外で弄れるというのは、サーバーロジックだけじゃなくHubInvokerのようなツールを作れるっていうのも良いところですね。大事。なので、標準大正義は正しくも選べないのです。</p>
<p>モノビットはよく知らないので。C++でサーバーロジックは書きたくないなあ、今はC#も行けるんですっけ？</p>
<p>自作系は、あんまりそのレイヤーの面倒は見たくないので極力避けたい。別に動くの作るのはすぐでも、まともにちゃんと動き続けるの作るのは大変なのは分かりきってる話で。トラブルシュートも泣いちゃう。そこに骨を埋める気はない。あと、自作にするにしてもプロトコルの根底の部分で安定してるライブラリがあるかないかも大事で（そこまで自作は本当に嫌！）、Unityだとただでさえそんなに選択肢のないものが更に狭まるので、結構厳しい気がするのよね。実際。</p>
<p>Photonといって、Photon Cloudの話をしているのかPUN(Photon Unity Network)の話をしているのか、Photon Serverの話をしているのか。どれも違く、はないけれど性質は違うのだから一緒くたに言われてもよくわからない。さて、PUN。PhotonのUnityクライアントは生SDKが低レイヤ、その上に構築されたPUNが高レイヤのような位置づけっぽい感じですが、PUNは個人的にはないですね。秒速でないと思った。PUNの問題点は、標準のUnity Networkに似せたAPIが恐ろしく使いづらいこと。標準のUnity Network自体が別に良いものでもなんでもないレガシー（ついでにUnity自体も新APIであるUNETに移行する）なので、それに似てて嬉しい事なんて、実際のとこ全くないじゃん！もうこの時点でやる気はないんですが、更にPhoton Serverで独自ロジック書いたらそこははみ出すので生SDK触るしかないのだ、なんだ、じゃあいらないじゃん？Client-Client RPCも別になくてもいいし、というかなくていいし。</p>
<p>Photon Server。C++のコアエンジンってのは言ってみればASP.NETにおけるIISみたいなもので、開発者は触るところじゃない、直接触るのはサーバーSDKとクライアントSDKだけで、つまり両方ピュアC#。その上では普通にC#でガリガリと書ける。いいじゃん。両方ピュアC#というのが最高に良い。サーバーはWindowsでホストされる。それも最高に良い。プロトコルとかはゲーム専用で割り切ってる分だけ軽量っぽい。うん、悪くないんじゃないか。</p>
<p>また、ホスティングは結構優秀です。まず、無停止デプロイができる（設定でShadowCopy周りを弄ればOK）。これ、すっごく嬉しい。この手のは常時接続なのでデプロイ時に切断するわけにもいかないし、これ出来ないとデプロイの難易度が跳ね上がっちゃいますからねぇ。また、1サーバーで擬似的に複数台のシミュレートなどが可能です。実際、グラニでは6台構成クラスタのシミュレートという形で常に動かしていて、どうしても分散系のバグを未然に防ぐには重要で、それがサクッと作れるのは嬉しい。脚周りに関しては、かなり優秀と思って良いのではないでしょうか。</p>
<h2>PhotonWireの必要な理由</h2>
<p>Photon Serverがまぁ悪くないとして、なんでその上のレイヤーが必要なのか。これは生SDKを使ったコードを見てもらえれば分かるかしらん。</p>
<pre><code class="language-csharp">// 1. クライアント送信
var peer = new CliendSidePeer(new MyListener());
peer.OpCustom(opCode:10, parameter:new Dictionary&lt;byte, object&gt;());
</code></pre>
<pre><code class="language-csharp">// 2. サーバー受信
protected override void OnOperationRequest(OperationRequest operationRequest, SendParameters sendParameters)
{
    switch (operationRequest.OperationCode)
    {
        case 10:
           // Dictionaryに詰まってる
            var parameter = operationRequest.Parameters;
            HogeMoge(); // なんか処理する
            // 3. 送り返す
            this.SendOperationResponse(new OperationResponse(opCode:5), sendParameters); // 
            break;
        // 以下ケース繰り返し
        default:
            break;
    }
}
</code></pre>
<pre><code class="language-csharp">public class MyListener : IPhotonPeerListener
{
    // 4. クライアント受信
    public void OnOperationResponse(OperationResponse operationResponse)
    {
        // 返ってきたレスポンス
        switch (operationResponse.OperationCode)
        {
            case 5:
                // なんかする
                break;
        }
    }
}
</code></pre>
<p>問題点は明白です。原始的すぎる。byteパラメータ、Dictionaryを送って受け取りそれをswitch、送り返してやっぱswitch。こうなると当然長大なswitchが出来上がってカオスへ。また、クライアント送信とクライアント受信がバラバラ。コネクションで送信した結果を受け取るのが、独立した別のListenerで受け取ることになる、となると、送信時にフラグONで受信側でフラグチェック祭り、Listener側のフラグ制御が大変。送信したメッセージと戻り受信メッセージだという判別する手段がないので、並列リクエストが発生するとバグってしまう。</p>
<p>これをPhotonWireはHubという仕掛け(とUniRx)で解決します。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15657734/bbecb158-26ee-11e6-8058-872826fb98d2.png" alt="image" /></p>
<p>ようするにMVCのControllerみたいな感じで実装できます、ということですね。また、逆に言えば、PhotonWireはそんなに大きな機能を提供しません。あくまで、このswitchやちょっとしたシリアライゼーションを自動化してあげるという、それだけの薄いレイヤーになっています。なので、PhotonWireによるコードが素のPhoton Serverによるものと少し異なるからといって、あまり警戒する必要はありません。実際、薄く作ることは物凄く意識しています。厚いフレームワークは物事の解決と同時に、別のトラブルを呼び込むものですから……。</p>
<p>ちなみにPhotonWireを通すことによる通信のオーバーヘッドは4バイトぐらいです。それだけで圧倒的に使いやすさが向上するので、この4バイトは全然あり、でしょう。</p>
<h2>Hub</h2>
<p>Hubというのは<a href="http://www.asp.net/signalr">ASP.NET SignalR</a>から取っています。というか、PhotonWireのAPIはSignalRからの影響がかなり濃いので、ドキュメントはSignalRのものを漁れば20%ぐらいは合ってます（全然合ってない）</p>
<pre><code class="language-csharp">// Unityクライアント側で受け取るメソッド名はインターフェイスで定義
public interface ITutorialClient
{
    [Operation(0)]
    void GroupBroadcastMessage(string message);
}

[Hub(100)]
public class Tutorial : PhotonWire.Server.Hub&lt;ITutorialClient&gt;
{
    // 足し算するだけのもの。
    [Operation(0)]
    public int Sum(int x, int y)
    {
        return x + y;
    }

    // 非同期も行けます、例えばHTTPアクセスして何か取ってくるとか。
    [Operation(1)]
    public async Task&lt;string&gt; GetHtml(string url)
    {
        var httpClient = new HttpClient();
        var result = await httpClient.GetStringAsync(url);

        // PhotonのStringはサイズ制限があるので注意（デカいの送るとクライアント側で落ちて原因追求が困難）
        // クラスでラップしたのを送るとPhotonの生シリアライズじゃなくてMsgPackを通るようになるので、サイズ制限を超えることは可能 
        var cut = result.Substring(0, Math.Min(result.Length, short.MaxValue - 5000));

        return cut;
    }
    
    [Operation(2)]
    public void BroadcastAll(string message)
    {
        // リクエスト-レスポンスじゃなく全部の接続に対してメッセージを投げる
        this.Clients.All.GroupBroadcastMessage(message);
    }

    [Operation(3)]
    public void RegisterGroup(string groupName)
    {
        // Groupで接続の文字列識別子でのグループ化
        this.Context.Peer.AddGroup(groupName);
    }

    [Operation(4)]
    public void BroadcastTo(string groupName, string message)
    {
        // 対象グループにのみメッセージを投げる
        this.Clients.Group(groupName).GroupBroadcastMessage(message);
    }
}
</code></pre>
<p>async/awaitに全面対応しているので、同期通信APIを混ぜてしまっていて接続が詰まって死亡、みたいなケースをしっかり回避できます。属性をペタペタ張らないといけないルールは、Visual Studio 2015で書くとAnalyzerがエラーにしてくるので、それに従うだけで良いので、かなり楽です。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15641589/f703ccb2-267c-11e6-8aa2-9a919bdbbecd.png" alt="" /></p>
<p>プリミティブな型だけじゃなくて複雑な型を受け渡ししたい場合は、DLLを共有します。</p>
<pre><code class="language-csharp">// こんなクラスをShareプロジェクトに定義して、Server側ではプロジェクト参照、Unity側へはビルド済みDLLをコピーする
public class Person
{
    public int Age { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
</code></pre>
<pre><code class="language-csharp">// サーバーがこんなふうに戻り値を返して
[Operation(1)]
public Person CreatePerson(int seed)
{
    var rand = new Random(seed);

    return new Person
    {
        FirstName = &quot;Yoshifumi&quot;,
        LastName = &quot;Kawai&quot;,
        Age = rand.Next(0, 100)
    };
}
</code></pre>
<pre><code class="language-csharp">// Unity側では普通に受け取れる
proxy.Invoke.CreatePersonAsync(Random.Range(0, 100))
    .Subscribe(x =&gt;
    {
        UnityEngine.Debug.Log(x.FirstName + &quot; &quot; + x.LastName + &quot; Age:&quot; + x.Age);
    });
</code></pre>
<p>プロジェクトの構成はこんな感じ。シームレス。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15658346/385e0ca8-26f6-11e6-8b89-afa6f1c7ed8f.png" alt="image" /></p>
<p>また、オマケ的に、Unity側でのエディタウィンドウではコネクションの接続状況と送受信グラフがついてきます。UNETの立派なProfilerに比べるとショボすぎて話にならないんですが、ないよりはマシかな、と。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15650771/fbdf81d4-26b5-11e6-87d0-811e1e77ca8f.png" alt="" /></p>
<h2>サーバー間通信</h2>
<p>Photon Serverはサーバーとサーバーを接続してクラスタを作れるのですが、その通信もHubを使ったRPCで処理しています。</p>
<pre><code class="language-csharp">// ServerHub(呼ばれる方)
[Hub(54)]
public class MasterTutorial : PhotonWire.Server.ServerToServer.ServerHub
{
    [Operation(0)]
    public virtual async Task&lt;int&gt; Multiply(int x, int y)
    {
        return x * y;
    }
}

// ClientHub（呼ぶ方）
[Hub(99)]
public class Tutorial : Hub
{
    [Operation(0)]
    public async Task&lt;int&gt; ServerToServer(int x, int y)
    {
        var val = await GetServerHubProxy&lt;MasterTutorial&gt;().Single.Multiply(x, y);
        return val;
    }
}
</code></pre>
<p>この見た目、直接呼んでるかのように書けるサーバー間通信は、実行時には以下のように置き換わってネットワーク呼び出しに変換されています。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15658426/78107286-26f7-11e6-9bd0-a8b88eabea0f.png" alt="image" /></p>
<p>なので、ServerHubはかならず戻り値はTaskじゃないとダメです（Analyzerが警告してくれます）。昔はこの手の処理を、メソッド呼び出しのように隠蔽する場合って、同期的になっちゃって、でもネットワーク呼び出しなので時間かかってボトルネックに、みたいなパターンが多かったようですが、今はTask[T]があるので自然に表現できます。このへんも含めてTask[T]が標準であることの意味、async/awaitによる言語サポートは非常に大きい。</p>
<p>この辺りの詳しい話は以下のスライドに書いています。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/pF55iU0qXIeRFv" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/metaprogramming-universe-in-c-ilroslyn" title="Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例" target="_blank">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<h2>ネットワーク構成</h2>
<p>PhotonWireは特に何の既定もしません。Photonが自由に組める通り、どんな組み方もできるし、どんな組み方をしてもPhotonWireでの呼び出しに支障は出ません。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15654243/7d2847aa-26cd-11e6-95cc-4f77c441f213.png" alt="" /></p>
<p>のはいいんですが、その時、ClientPeer, InboundS2SPeer, OutboundS2SPeerの3種類のPeerを持つように、PhotonWireもまたHub, ServerHub, ReceiveServerHubとそれぞれに対応する3種のHubを持っています。3つ、これは複雑で面倒。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15655365/7e9aa98e-26d7-11e6-8bfb-97eeea1330f5.png" alt="" /></p>
<p>しかしPhotonWireはネットワークの複雑さの隠蔽はしません。やろうと思えばできますが、やりません。というのも、これ、やりだすと泥沼だから。賢くやりたきゃあAkkaでもなんでも使ってみればよくて、自分で書いたら一生終わらない。Photonのネットワークは本当に全然賢くなくて、ただたんに直結で繋いでるという、それだけです。そんなんでいい、とまではいいませんが、そうなら、それに関しては受け入れるべきでしょうね。勘違いしちゃあいけなくて、フレームワークは複雑さを隠蔽するもの、ではないのです。</p>
<p>ともあれ、最低限の賢くなさなりに、スケールしそうな感じに組み上げることは可能なので、全然良いとは思ってますよ！</p>
<h2>できないこと</h2>
<p>ポンと貼り付けてtransformが自動同期したり、いい感じに隙間を補完してくれたりするものはありません。ただ、Client-Server RPCがあれば、それは、その上で実装していくものだと思うので（いわゆるNantoka ToolkitとかNantoka Contribの範疇）、しゃーないけれど、自前で作ろうという話にはなってきますね。↑のネットワーク構成の話も、隠蔽とまではいかなくても、決まった構成になるのだったらそれなりにバイパスするいい感じのユーティリティは組んでいけるだろうから、その辺のちょっとした増築は、やったほうがいいでしょう。</p>
<h2>まとめ</h2>
<p>現状実績はないです（今、公開したばかりですからね！）。ただ、<a href="http://grani.jp/">グラニ</a>で開発中の<a href="https://kuro-kishi.jp/">黒騎士と白の魔王</a>というタイトルに投下しています。</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/Tzwk2LPrsSA" frameborder="0" allowfullscreen></iframe>
<p>半年以上は使い続けているので、それなりには叩かれて磨かれてはいるかなあ、と。大丈夫ですよ！と言い切るには弱いですが、本気ですよ！とは間違いなく言えます。DLLシェアや自動生成周りが複数人開発でのコンフリクトを起こしがちで、そこが改善しないと大変かなー、というところもありますが、全般的にはかなり良好です。</p>
<p>ちょっと大掛かりだったり、Windows/C#/Visual Studioベッタリな、時代に逆行するポータビリティのなさが開き直ってはいるんですが、結構使い手はあると思うので試してみてもらえると嬉しいですね！あと、大掛かりといっても、知識ゼロ状態からだったら素のPhoton Server使うよりずっと楽だと思います。そもそもにPhotonWireのGetting Startedのドキュメントのほうがよほど親切ですからねぇ、Visual Studioでのデバッグの仕方とかも懇切丁寧に書いてありますし！</p>
<p>VR時代のマルチプレイヤーって結局どうすんねん、と思ってたんですが、<a href="https://github.com/googlesamples/tango-examples-unity/tree/master/TangoWithMultiplayer">Project Tango</a>のサンプルがPhotonだし<a href="http://altvr.com/">AltspaceVR</a>もPhotonっぽいので、暫くはPhotonでやってみようかなー。という感です。</p>
</div>
<h1><a href="https://neue.cc/2016/05/23_530.html">MarkdownGenerator - C#におけるAPI Reference生成のためのドキュメントツール</a></h1>
<ul class="date"><li>2016-05-23</li></ul>
<div class="entry_body"><p>APIリファレンス作りたい？<a href="https://github.com/EWSoftware/SHFB">Sandcastle</a>。以上。終了。あるいは<a href="https://github.com/dotnet/docfx">dotnet/docfx</a>が良いのではないでしょうか。こいつはdotnet配下にあるように、MSの今後のOSS系のはこれでドキュメント生成されていく可能性があります。</p>
<p>というのは置いといて、私的には実のところ、あんまり重要視していませんでした、ドキュメントツール。.chmにはいい思い出がなくて、というか別に見ないじゃん？htmlで出力してもなー、なんかゴチャゴチャしてて汚いしなー。一方でJavaScriptなんかは様々な格好良くフォーマットされた形式で色々出てるのであった。いいじゃん。いいね。</p>
<p>さて、もう一つ。HTMLで出力しても置き場にこまる。GitHub Pagesにはそんないい思い出がない。別にあんなところをフロントにするよりもリポジトリのアドレス直のほうが断然いいじゃん、みたいな。というわけでアレだ、GitHub Wikiだ。あそこをゴミ置き場にすればいいんだ。という発想で、まずUniRxのリファレンスをGitHub Wikiに置いてみました。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx/wiki">UniRx/Wiki</a></li>
</ul>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/15460956/9b897c32-20f1-11e6-8520-c31b0035dd01.png" />
</p>
<p class="noindent">
<img src="https://cloud.githubusercontent.com/assets/46207/15460939/73c76088-20f1-11e6-8fb7-a483383ab9a1.png" />
</p>
<p>UniRxは、namespaceを意図的にある程度平ったくしてるので、ちょっとごちゃってますが、まぁまぁいいんじゃない？それなりに見れる。悪くはない。少なくともないよりは100億倍良い。</p>
<p>私的にはIntelliSenseがドキュメントだ！みたいな意識がそれなりにあって、最初のチュートリアルみたいなドキュメントがあったら、あとはそれを手がかりにあとはIntelliSenseでなんとかしようぜ、的なところが。実際<a href="https://github.com/dotnet/roslyn">Roslyn</a>なんかはそんな感じがする。Getting Startedはそれなりに厚い、けど全貌からは程遠い。でもAPIドキュメントはない。さあ、IntelliSenseで宝探しだ。って。肯定もしないけれど否定もしない、そういうのも今風よね。でも、まあこの程度のAPIリファレンスでも生成してやると、それはそれで良いな、って思ったのだ。です。</p>
<h2>MarkdownGenerator</h2>
<p>生成は自家製こんそーるあぷりで行ってます。というわけで公開しました。</p>
<ul>
<li><a href="https://github.com/neuecc/MarkdownGenerator">MarkdownGenerator</a></li>
</ul>
<p>dllとxmlを渡すとmdと目次用のHome.mdをばらまくので、GitHub Wikiに投げ込みます。そう、GitHub Wikiはご存じの方も多い通り、それ自体がgitで管理されててCloneできるのです。さいこー。というわけでそのままPushするだけ。Good。完璧。これなら、CIなんかでフックして毎回生成して投げ飛ばしてあげてもいい。よね。</p>
<p>生成結果のStyleはちょっとまだまだ試行錯誤中。まあでも割とこんなもんでいいんちゃうんちゃうん？ユースケースの9割ぐらいはカバーできているでしょう。それ以上はノイズということで。</p>
<h2>その他ツール</h2>
<p>Sandcastleはそもそも出力をカスタマイズできるので、もう少し真面目というかガッチリしたものが必要ならば、<a href="https://github.com/maxtoroq/sandcastle-md">maxtoroq/sandcastle-md</a>あたりを使ってMarkdownを出力してやると良いでしょう。これなら、きっちりとSandcastleで出力される情報が全部そのまま入ってるので、ちゃんとしてる感は圧倒的に高いです。また、繰り返しますけれど<a href="https://github.com/dotnet/docfx">DocFX</a>は今からやるなら最有力候補な気がします。DLLからじゃなくてRoslynでプロジェクトファイルから解析したりとか今風。あくまでstatic file generatorなのでmdじゃなくてhtml出力なので、Wikiに投げ飛ばす用途には向かないのと、ちょっと複雑、使いこなすのは難しい、かな、まあ相応には良さそうかとは。</p>
<p>MarkdownGeneratorは、ちゃんとしてないなりに、私的に重要視してる情報がパッと一覧で見やすくする、ということを重視しているので……。あと、なんかSandcastle使いたくないんだよねー、心理的に。なんだろうね、レガシー臭するからなのかな。食わず嫌いなだけって話でもあるのだけれど。</p>
<p>何れにせよ、GitHubであってもなくてもいいだろうけれど、API Referenceを投げ飛ばす場としては、そういうところ（どういうところ？）がいいですね。独立してるよりもリポジトリに近い場所のほうが素敵度は高い。気がする。あとはなんのかんのでGitHubに慣れきってるというのもあって、GitHubにあると情報がスムースに受け取れる気がするんだよね。これもなんでだろうね。でもそういうのってあるよね。</p>
</div>
<h1><a href="https://neue.cc/2016/05/14_529.html">Unityにおけるコルーチンの省メモリと高速化について、或いはUniRx 5.3.0でのその反映</a></h1>
<ul class="date"><li>2016-05-14</li></ul>
<div class="entry_body"><p>UniRx 5.3.0をリリースしました！今回のアップデートは、内部的な最適化、です。最適化は、もうそろそろあんまやるところ残ってないよね、なんて思ってたんですが、じっくり考えるとそんなことなく割とあったので埋めました。それが表題のコルーチンの省メモリと高速化です。使い方次第ではありますが、場合によっては今回のアップデートでものすごく恩恵に授かる人もいればそこそこの人もいるかもです。ともあれ基本的に内部的に変更してるだけなので、入れるだけでそれなりに高速化したりする可能性がそれなりにあります。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub/UniRx</a></li>
<li><a href="https://www.assetstore.unity3d.com/jp/#!/content/17276">AssetStore/UniRx</a></li>
</ul>
<p>前回が2月だったので3ヶ月ぶりですね。あまりオペレータ追加がないので、次はオペレータ追加に集中したい気もする。なんか優先的に欲しいのあればリクエストもどうぞ(Observable.Windowとかいい加減そろそろ入れろよって話なんですが）</p>
<h2>MicroCoroutine</h2>
<p>今回の大きい変化はMicroCoroutine(と、自称してる)の導入です。特に大量にEveryUpdateやEveryValueChangedを呼んでるシチュエーションにおいて10倍、というのは場合によりで大雑把なのですが、相当速くなります。</p>
<pre><code class="language-csharp">void Start()
{
    // Start 10000 Coroutines
    for (int i = 0; i &lt; 10000; i++)
    {
        // Standard Unity Coroutine
        // StartCoroutine(Counter());

        // Use UniRx 5.3 - MicroCoroutine
        MainThreadDispatcher
          .StartUpdateMicroCoroutine(Counter());
    }
}

IEnumerator Counter()
{
    while (true)
    {
        count++;
        yield return null;
    }
}
</code></pre>
<p>こんな10000個、単純なコルーチンを起動するコードがあったとして</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/15267997/86e9ed5c-1a0c-11e6-8371-14b61a09c72c.png" alt="image" /></p>
<p>大きく違いがでます。ちょっと恣意的すぎではあるんですが、UniRxはコルーチンを簡単にかけるが故に、これに近いシチュエーションってのが意図せず起こりがちではありました。また、Resources.LoadAsyncなど非同期系APIからの取得に関しても、一時的に多くのコルーチンを起動するシチュエーションはあり得るのではないでしょうか。</p>
<p>性能改善した理由は、基本的にはUnityの公式ブログ<a href="http://blogs.unity3d.com/jp/2015/12/23/1k-update-calls/">UPDATE()を10000回呼ぶ</a>で紹介されていることの話で、10000個のUpdateは遅くて、配列に詰めて直接ループで呼ぼうぜ、と。どうせUpdate内のメソッドは呼ばれてC#の領域で実行されるんだから、マネージド(C#)-アンマネージド(C++)の繋ぎのレイヤーは純粋にオーバーヘッドになってくるよ、と。なるほどそうだねそりゃそうだねぇ。それはStartCoroutineにも言えて、というかコルーチンのほうがもっと性能劣化度が大きいんですよね。</p>
<p>この記事は非常に素晴らしくて、大量にモノ出して速度遅くなってるのがスクリプト起因なら、マネージャー立ててまとめて、あとUpdateに限らずマネージド-アンマネージドの繋ぎをやってる部分が遅いだろうからそこを適切に取り除ける限り除けば、全然まだまだそれなりに捌ける余裕は残ってるぜ。ということで、むしろ希望に満ちていていい感じです。実際、ハイパフォーマンスを謳うDOTweeenとかのライブラリもそんな感じですね、動かすものそれぞれにUpdateするコンポーネントを挿したりはしない、中央管理で動かすのだ、と。</p>
<p>さて、UniRxでは幾つかのメソッドはコルーチン依存でループを回しています。Observable.EveryUpdateとかEveryValueChangedとか。少しに使う分にはいいんですが、気楽に使えるが故に、大量に使うと、10000個とまではいかなくてもやっぱり、それぞれがコルーチンを起動することによるマネージド-アンマネージドオーバーヘッドがそのまま乗っかってきてしまいます。というわけで、やはりコルーチン自前管理の道を進むしかない……。幸い、自前管理で問題になる機能面での低下に関しては、UniRx自体がコルーチンを凌ぐだけの機能を提供しているので、気にしないでよし。というわけで純粋にいかにコルーチン(IEnumerator)を高速に回転させ、高速にメンテナンスするかにだけ集中すればよし。</p>
<p>回転させるのはforループ回すだけの話なんですが、マネージャー作ろうぜ、となった時に、Listに詰めるのはいいんですが、面倒くさいのは削除。削除は要注意で、単純にListのRemoveやって済ませたりするのは結構アレです(Removeは相当高コストな操作です)。かといってDictionaryやSet、LinkedListでやるなんていうのは論外で（列挙の性能が死ぬので本末転倒）、基本的に配列で頑張るべきなんですが、さてはて。結局、その辺のめんどーを見るのがめんどーだからUpdateやStartCoroutineでぶん回すのだ。割と本気で。</p>
<p>ではどうしたか、というと、UniRxのMicroCoroutineのアプローチはRemoveしない。です。しない。空いた部分はnullで埋めて純粋にスキップするだけにする。多少の空きなら、いちいち削るよりもスキップさせたほうが速い。しかし、それだけだとブヨブヨと膨らみ続けてしまうので、xフレーム毎に空きスペースに詰めなおして小さくします。縮める際も前の方に整列させるんじゃなくて、空きスペースに対して後ろから埋めるようにするので、順番はグチャグチャになります。その代わり余計な配列へのセットが発生しないので速い。そして膨らんだ配列は放置して膨らんだままにします、終端のインデックスだけ記録して管理するのみ（ところでアセットストアにアップデート申請出してから気づいたのですが、この配列の使い方なら定期的なお掃除じゃなくて、動かしながら埋めるようなコードにするのも可能っぽい感、なので次回アップデートでそうします）</p>
<p>というわけで、UniRxのMicroCoroutineは中央集権的なので多少膨らむことが許される（でしょう！）ことを利用して、とにかく高速にコルーチンを捌く、ということだけに集中してます。ので速い。下手に自前管理するよりも速いかもしれませんし、Updateで監視するよりもObserveEveryValueChangedのほうがむしろ速い、Rxで書いたほうが速い、みたいな逆転現象も全然発生しうるような話になります。</p>
<pre><code class="language-txt">ObserveEveryValueChanged
EveryUpdate 
EveryFixedUpdate
EveryEndOfFrame
NextFrame
TimerFrame 
IntervalFrame
DelayFrame 
SampleFrame
ThrottleFrame
ThrottleFirstFrame
TimeoutFrame
</code></pre>
<p>この辺りのメソッドを使った場合、内部の実装がMicroCoroutineに差し替わったので自動的に恩恵に預かれます。コルーチン -&gt; Observable変換に関しては FromMicroCoroutine が追加されました。基本的にはFromCoroutineと一緒なのですが、MicroCoroutineではyield returnするのはnullだけにしてください、それ以外には対応してません（UnityEditor上ではWarning出して警告します）。MicroCoroutineの制約はそれなんですが、なんだかんだで、8割ぐらいはyield return nullだけで成立するんちゃうんちゃうん、みたいな。賢くやろうとすればもう少しは出来なくもないんですが、シンプルで高速なコルーチンの回転を損ねちゃうのでナシ。IEnuemrator.Currentの呼び出しや、その型チェックすら省きたい。残り2割ぐらいなら普通にStartCoroutineすればいいじゃん、ということで。実際、UniRxの↑のメソッドはそれでかなり置き換えることが出来る、ということを発見できたので、全面的に導入する気になったのです。</p>
<p>また、最悪待ちたい場合は、isDoneのループを回すようにToYieldInstruction経由でIObservableを待てるので、大抵のことはなんでもできます。</p>
<pre><code class="language-csharp">IEnumerator MicroCoroutineWithToYieldInstruction()
{
    var www = ObservableWWW.Get(&quot;http://aaa&quot;).ToYieldInstruction();
    while (!(www.HasResult || www.IsCanceled || www.HasError)) // 3つもプロパティ並べるのダルいので次回アップデートでIsDoneを追加します予定
    {
        yield return null;
    }

    if (www.HasResult)
    {
        UnityEngine.Debug.Log(www.Result);
    }
}
</code></pre>
<p>もっとプリミティブに直接利用したい場合は、StartCoroutineの代わりにMainThreadDispatcherに3つ生やしてあります。</p>
<pre><code class="language-txt">MainThreadDispatcher.StartUpdateMicroCoroutine
MainThreadDispatcher.StartFixedUpdateMicroCoroutine
MainThreadDispatcher.StartEndOfFrameMicroCoroutine
</code></pre>
<p>それぞれがコルーチンを消費するタイミングで、まぁ普通はStartUpdateMicroCoroutineを使えばよいでしょふ。もし大量のStartCoroutineがプログラム中にあるのなら、これに差し替えるだけで本当にすっごく速くなるでしょう。ほんと。</p>
<h2>SubscribeWithState</h2>
<p>ここから先はUniRxのアップデートの話だけ。そして本当にMicro Micro Microな最適化であんま意味はないんですが、まず、SubcribeWithStateを追加しました。これによって何が変わるか、というと、例えば……</p>
<pre><code class="language-csharp">// Before
public static IDisposable SubscribeToText(this IObservable&lt;string&gt; source, Text text)
{
    return source.Subscribe(x =&gt; text.text = x);
}

// After
public static IDisposable SubscribeToText(this IObservable&lt;string&gt; source, Text text)
{
    return source.SubscribeWithState(text, (x, t) =&gt; t.text = x);
}
</code></pre>
<p>という感じの使い方ができます。どういう違いが出るのかというと、以前に<a href="http://neue.cc/2016/01/06_525.html">Unityでのボクシングの殺し方、或いはラムダ式における見えないnewの見極め方</a>という記事の中で説明したのですが、ラムダ式はその中身によってコンパイル時に生成されるコードがかなり変わってきます。で、最速なのはそのメソッド内だけで完結していて外部の変数等には一切触っていない状態。onNextはActionなので、副作用かける際にどうしても外部変数をキャプチャしてしまうことが多いんですよね。そこでSubscribeWithStateを使うと、必要な変数を閉じ込めることができるので最速ゴミなしの形で記述できます。</p>
<p>ただまぁ、これやると、じゃあSelectやWhereなんかもState取れたほうがいいんですか？（理屈上はそうです）、とか、ああクロージャ殺さなきゃ死ね死ね死ね、とか思ったりしそうなのですけれど、Subscribeの回数ってパイプライン内の実行頻度に比べれば圧倒的に少なくなるはずなんですよね。だから全体のバランスで見たら無視できるといっても過言ではないはず、特にクロージャでちょっとゴミが出る程度の話は。</p>
<p>なのであんま神経質にやることはないんですが、↑のSubscribeToTextのようなそんな手間もかからないし、UIとかシーンの初期化時にいっぱい登録される可能性があるようなものでライブラリ的な部分でカバーできる質のものならば、少しだけ気を使ってあげると気は安らぐかもしれません。</p>
<h2>ReactiveCommand</h2>
<p>ReactiveCommandは.NET版のReactiveProeprtyにあった、最後のパーツなんですが、どうなんでしょうね、本来はViewModelのレイヤーのためなんですが、UnityだとPresenterにUI要素がセリ出してきてるのでイマイチベンリかどうか分からなくて入れてなかったんですが。一応、こんな風に使えます。</p>
<pre><code class="language-csharp">public class Player
{
   public ReactiveProperty&lt;int&gt; Hp;
   public ReactiveCommand Resurrect;

   public Player()
   {
        Hp = new ReactiveProperty&lt;int&gt;(1000);

        // If dead, can not execute.
        Resurrect = Hp.Select(x =&gt; x &lt;= 0).ToReactiveCommand();
        // Execute when clicked
        Resurrect.Subscribe(_ =&gt;
        {
             Hp.Value = 1000;
        }); 
    }
}

public class Presenter
{
    public Button resurrectButton;

    Player player;

    void Start()
    {
      player = new Player();

      // If Hp &lt;= 0, can't press button.
      player.Resurrect.BindTo(resurrectButton);
    }
}
</code></pre>
<p>buttonのinteractableとonClickが抽象化されたもの、って感じですね。</p>
<h2>その他</h2>
<p>リリースノートから。</p>
<pre><code class="language-txt">Add : ReactiveCommand
Add : MainThreadDispatcher.StartUpdateMicroCoroutine, StartFixedUpdateMicroCoroutine, StartEndOfFrameMicroCoroutine
Add : Scheduler.MainThreadFixedUpdate, MainThreadEndOfFrame
Add : ToYieldInstruction(cancellationToken)
Add : Observer.Create(onNext/onNext, onError/onNext, onCompleted) overload
Add : IReadOnlyReactiveProperty.SkipLatestValueOnSubscribe
Add : Observable.WhenAll overload (IObservable&lt;Unit&gt;(params IObservable&lt;Unit&gt;[] sources), this becomes breaking changes)
Add : Observable.FromMicroCoroutine
Add : Observable.AsSingleUnitObservable
Add : Observable.SubscribeWithState
Add : Observable.CreateWithState
Add : Disposable.CreateWithState
Improvement : Use MicroCoroutine on `ObserveEveryValueChanged`, `EveryUpdate`, `EveryFixedUpdate`, `EveryEndOfFrame`, `NextFrame`, `TimerFrame`, `IntervalFrame`, `DelayFrame`, `SampleFrame`, `ThrottleFrame`, `ThrottleFirstFrame`, `TimeoutFrame`
Improvement : Performance improvement for Observable.Range, Repeat when scheduler is Scheduler.Immediate
Improvement : Use Time.unscaledDeltaTime in IgnoreTimeScaleMainThreadScheduler
Fix : ReadOnlyReactiveProperty(source, initialValue) does not publish initial value on subscribe
Fix : IReadOnlyCollection has set indexer
Fix : Ambigious property of IReactiveCollection.Count, Indexer
Fix : Throw invalid error when ObservableWWW.LoadFromCacheOrDownload failed.
Breaking Changes : Added IReadOnlyReactiveProperty.HasValue
Breaking Changes : AsyncConvertsion scheduler to Scheduler.MainThread on WebGL build(WebGL doesn't support ThreadPool)
Other : Update UniRxAnalyzer 1.4.0.1 https://www.nuget.org/packages/UniRxAnalyzer
</code></pre>
<p>ToYieldInstructionは<a href="http://neue.cc/2015/12/21_523.html">UniRx 5.0 - 完全書き直しによるパフォーマンス向上とヒューマンリーダブルなスタックトレース生成</a>で説明しているのですが、Unity 5.3以降のCustomYieldInstuctionを応用したもので、IObservableをコルーチンで処理できるようにするやつで、結構お薦め機能です。MicroCoroutineで回すための補助にもなりますし。</p>
<p>SchedulerにMainThreadFixedUpdateとMainThreadEndOfFrameを足しました。ObserveOnやTimerなどで、その辺の細かい制動をしたい方にどうぞ。</p>
<p>(ReadOnly)ReactivePropertyへのSkipLatestValueOnSubscribe拡張メソッドの追加。これは、(UniRxの)ReactivePropertyはSubscribe時に必ず値をプッシュするようになってるんですが、そういった初期値を無視したいって局面は少なからずあるんですよね。Rx.NET用のReactivePropertyでは、コンストラクタでReactiveProeprtyModeとして、None | RaiseLatestValueOnSubscribe | DistinctUntilChanged を指定できるようなデザインを選んでいるのですが（というのも、Viewにデータバインディングするため構築時の初期値はnullであることが確定している、というシチュエーションが割とあるため）、UniRxのReactivePropertyではSubscribe側が選ぶというデザインにしています。この辺はフレームワークの性質の違いに合わせてるのですが、ともあれ、初期値を無視したい場合は rxProp.SkipLatestValueOnSubscribe().Subscribe() としてもらえれば。</p>
<p>Observable.WhenAllを、IObservable[Unit][]が相手の場合はIObservable[Unit]を返すようにしました。これは、別にUnit[]が返されても何の意味もないからというのと、それによって余計な配列確保をしないという最適化も入れています。この方が絶対に良いんですが、しかし戻り値の型が変わってしまったので破壊的変更にはなっています。最初から気づいておけば良かったですね、すびばせん。</p>
<p>AsSingleUnitObservableは LastOrDefault().AsUnitObservable() みたいな変換をかけるやつで、Async的な保証をかけるのにベンリというあれそれ。</p>
<p>あとは、んー、使ってる人は、<a href="http://grani.jp/">うちの社内</a>以外にないのでは疑惑も感じてますが、UniRxAnalyzerを更新してます。コンストラクタにIObservableを突っ込んでいた場合に誤検出していたのを修正しています。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/VSAnalyzer.jpg" alt="" /></p>
<p>これ、Visual Studio 2015を使って開発している人は絶対に入れたほうがいいですよ！Subscribe忘れて発火しないのに気づかなかったー、みたいなポカミスが圧倒的に防げますので。</p>
<h2>まとめ</h2>
<p>性能面でより気にせずにカジュアルに色々使えるようになった、というのはいいことかなー。性能面で問題出た際に「そういう使いかた想定してないから」といった却下の仕方って、あんましたくないですからね。聞いてていいものでは全くない。デザインとしてカジュアルに使えるようになっているなら、性能もちゃんと担保していかないし、そういうのが頻発するならライブラリの設計が悪い。と、思ってるので、今回のでよりちゃんと自然に使えるようになったかな、と。ObserveEveryValueChangedは個人的には最高にクールな機能だと思ってるので、気兼ねなく使って欲しいし、やっと本当に気兼ねなく使えるようになりました。</p>
<p>ObservableUpdateTrigger(UpdateAsObservable), Observable.EveryUpdate, Observable.EveryGameObjectUpdate とUpdateのハンドリングも3択、性能特性も三者三様。混乱との対話！別に特に何をレコメンドすることもなく、まあ素直に書くならUpdateTriggerが素直でよく。自身のUpdateループで周りますしね。EveryUpdateはMicroCoroutineなので性能特性的には良さげ、どうせAddTo(this)するならループのライフサイクルもUpdateTriggerと別に変わりはしないし(UpdateTriggerだとDisableでUpdateが回らなくなるので、まぁその辺で挙動に違いは出る)。EveryGameObjectUpdateはMainThreadDispatcherのSubjectに積まれるもので、UpdateTriggerが使える状況なら非推奨かな、あんまりSubjectに頻繁にAdd, Removeするのは性能特性的に悪手なので。UpdateTriggerもSubjectが駆動するのですが、性質的にグローバルじゃないのでAdd, Removeは局所化されるからそこまででは、に通常はなるでしょう、的な。</p>
<p>そんなこんなで、少なくともRxが性能面のネックでー、と言われるのは悔しい話なので、大きいものから小さいものまで、最適化ネタは常に考えてます。利用事例としても、結構ヒットしてる某社の某ゲーム（とは）や最近でた前作に続いてヒットの予感のする某ゲーム（とは）など、かなり使いこなしてる事例もあって（個人的にはとても感動した！）、ちゃんと実用的といってもいいレベルになってると思われます。弊社の開発中タイトルである<a href="https://kuro-kishi.jp/">黒騎士と白の魔王</a>でもガッツリ使っているので、ご興味ある方は<a href="http://grani.jp/recruit">中途採用</a>は絶賛募集中です:) 当たり前ですがドッグフーディングは凄く大事で、さすがにデカいバグは出てこないにしても軽微なものはちょいちょい上がってくるので、日々、堅牢さは担保されているな、とかかんとか。あと、使いすぎてるほどに使いすぎてるので、常に性能面でネックになってはいけない、性能面でネックになってはいけない、とマントラを唱えるプレッシャーになってるのもいいことです、多分きっと。</p>
<p>今回のアップデートでツメが甘かった案件としてはAsyncOperation.AsObservableやObservableWWWが内部的にまだFromCoroutine利用なので、FromMicroCoroutineに可能なら差し替えようかな、と。効果のほどとしては、やっぱり場合によりけりですが、初期化とかで大量に回る時は大きく変わるかも。しれない。ともあれ次回アップデートにご期待を。ただyield return wwwやasyncOperationした場合とyield return nullでisDoneチェックする場合とで、戻ってくるタイミングが異なるので、そこのルールを統一させないとかなあ。</p>
</div>
<h1><a href="https://neue.cc/2016/04/01_528.html">Microsoft MVP for Visual Studio and Development Technologies(C#)を再々々々々受賞しました</a></h1>
<ul class="date"><li>2016-04-01</li></ul>
<div class="entry_body"><p>今年の受賞で、6年目です。エキスパタイズとしてはVisual Studio and Development Technologiesという微妙な感じなので、C#です。C#です、と言わせてください。</p>
<p>春はあけぼの、というわけで会社も新たなステージに入りました。原点を振り返りつつも、新たな創業として、より強固な姿を掲示できればいいかな、と思います。</p>
<p>去年に私は</p>
<blockquote>
<p>私が主に力を入れているのはUnityと、そのReactive Extensions実装のUniRxで、特にUniRxはかなりヒットさせられたとは思います。が、まだまだ兆しといったところなので、確固たるものにしなければならない。また、それを基盤にして、C#の強さというのを、ただの今までの.NETコミュニティにだけに留まらず、幅広い世界に届ける、伝えていきたい。</p>
</blockquote>
<p>と言ってましたが、それは達成できました（いやほんと）。しかし、よくよく考えると、なんだか小粒です。今年はもう少し大きなヴィジョンで行きたいですね。最近のMicrosoftのメッセージとしても、C#の強さがより一層際立ってきました。それをしっかりと補強し、力強く、Real World C#というのを示し続けていきます。そう、Real Worldで。どういうことかといえば、そういうことです。今年はね。</p>
<p>引き続き主戦場はC#とUnityです。Unityも.NET Foundation加入やHololensやVRの最有力の開発環境であったりと、変わらず非常に魅力的で、強力な環境ですす。いろいろな形で、刺激的なことを掲示し続けられればいいかな、と思っています。</p>
<p>そんなわけで引き続き、今年もよろしくお願いします。</p>
</div>
<h1><a href="https://neue.cc/2016/03/30_527.html">Roslyn Analyzerでコンフィグを読み込ませて挙動を変更する</a></h1>
<ul class="date"><li>2016-03-30</li></ul>
<div class="entry_body"><p>方法。が、欲すぃ。例えば採番する時に0ベースなのか1ベースなのかプロジェクトによって変えたい。例えばCodeFix時の名前変更のルールを先頭アンスコ付けるのか付けないのかを自由に変えさせたい。<a href="http://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a>の時は、専用のAttributeを使うので、その中のインターフェイスを書き換えてコンフィグ代わりにしてね、という方法を取ったのですが、専用の属性が使えなきゃ適用できない手法で、全然汎用的っぽくないし、当然ながら全然イケてない。</p>
<p>ではどうするか。実は、Additional Filesという仕組みが用意されているので、それを用いることでコンフィグを読みこませることができます！詳細は<a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">roslyn/Using Additional Files.md</a>に書かれていますが、任意のテキストファイルを色々な手法（コマンドラインの引数やcsprojの定義としてなど）でプロジェクトに設定し、Analyzer側では AnalyzerOptions.AdditionalFiles で読めます。</p>
<p>では、やってみましょう。</p>
<pre><code class="language-csharp">[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class AdditionalFileAnalyzer : DiagnosticAnalyzer
{
    static DiagnosticDescriptor Rule = new DiagnosticDescriptor(&quot;AdditionalFileAnalyzer&quot;, &quot;AdditionalFileテスト&quot;, &quot;AdditionalFiles:{0}&quot;, &quot;Usage&quot;, DiagnosticSeverity.Error, isEnabledByDefault: true);
    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSymbolAction(Analyze, SymbolKind.NamedType);
    }

    private static void Analyze(SymbolAnalysisContext context)
    {
        // AnalyzerOptionsにAdditionalFilesがある。
        // CodeFixContextの場合はProjectに生えてるので、 context.Document.Project.AnalyzerOptions で取得可能。
        var additionalFiles = context.Options.AdditionalFiles;

        // Pathから引っ掛けて取る
        var config = additionalFiles.FirstOrDefault(x =&gt; System.IO.Path.GetFileName(x.Path) == &quot;config.json&quot;);
        if (config != null)
        {
            // GetText().ToString()で文字列が取れるので、あとはJsonConvertでデシリアライズするなりなんなりどうぞご自由に……。
            var text = config.GetText().ToString();
            context.ReportDiagnostic(Diagnostic.Create(Rule, context.Symbol.Locations[0], text));
        }
        else
        {
            context.ReportDiagnostic(Diagnostic.Create(Rule, context.Symbol.Locations[0], &quot;JSONが見つかってないぞ&quot;));
        }
    }
}
</code></pre>
<p>これでJSONが見つかってないぞ、と怒られまくります。ファイルを追加するには、まずプロジェクトの適当なところにconfig.jsonを足して、Build Actionを AdditionalFiles に変更します。が、変更しようとするとやっぱり怒られるので、しょうがないからcsprojを手動で書き換えます。</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
    &lt;AdditionalFiles Include=&quot;config.json&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>これで、以下の様な結果が得られます。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/14132223/6463302e-f67e-11e5-8b98-3645b82bf4fd.png" alt="image" /></p>
<p>うん、ちゃんと読めてる！</p>
<p>コンフィグとして使うには、まぁイマドキのJSONでコンフィグだったらJSON.NETでJsonConvert.DeserializeObjectなんかでサクッと復元してやるのが楽でしょう。外部DLL読み込むのが嫌だという場合は、XMLにしてLINQ to XMLやXmlSerializer使うのも全然お手軽でいいとは思います。</p>
<p>コンフィグなんてほぼほぼ固定になるのに毎回デシリアライズ走らせるのは嫌だなあ、って場合はstaticオブジェクトにキャッシュしちゃうのも悪くない手だと思います。その場合は、書き換えた場合はプロジェクト再読み込み（or VS再起動)になってしまいますが、実用的には全然問題ないはず。といいたいのですが、複数のプロジェクト跨ぎで共有されちゃうと厄介だったりするので注意が必要なので、まぁちょっとDeserializeするぐらい大したことねーよということで、毎度Deserializeするのも全然構わないかな、とは。</p>
<p>このコンフィグを読み込む手法は<a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md">StyleCopAnalyzer/Configuration.md</a>でも採用されているし、これがスタンダードのやり方だと思って良さそうです。</p>
</div>
<h1><a href="https://neue.cc/2016/03/21_526.html">SerializableDictionary - Unityで高速に辞書復元するためのライブラリ</a></h1>
<ul class="date"><li>2016-03-21</li></ul>
<div class="entry_body"><p>という、ScriptableObjectとかJsonUtilityとか、そもそもSerializeFieldとかでシリアライズできるDictionaryを作りました。</p>
<ul>
<li><a href="https://github.com/neuecc/SerializableDictionary">GitHub - neuecc/SerializableDictionary</a></li>
</ul>
<p>もともとDictionaryはシリアライズできないのですが、ISerializationCallbackReceiverを用いてシリアライズ/デシリアライズのタイミングでKeyの配列、Valueの配列に戻してやるなどで保存すること自体は全然可能でした。のですが、速度的には問題あるな、というのに直面しました。</p>
<p>その前に、JSONから復元するのがまず遅かった。じゃあMsgPackやProtobufに変更したら速いかといえば、別にそこまでそうではなかった。これはつまり、C#のレイヤーで大量の何かを舐めて何かを作るという行為そのものが遅い。ではScriptableObject化すればどうだろう、確かにデシリアライズのプロセスがUnityネイティブ（実体は不明）と化して、確かに速い。が、そこからDictionaryに変換してやるのをC#で書いたらやっぱりそこが遅い。</p>
<p>遅い、というとアレで、量次第ですけどね。今回、量がやたら多かったので結構かなり相当引っ張られてた。初期化のタイミングなどで大量のDictionaryを捌くような場合に、無視できない程度に結構引っかかる遅さを醸し出してる。結局、配列からであっても、C#のレイヤーで大量の何かを舐めて何かを作るという行為そのものが遅い。という悲しい現実をつきつけられるのであった。</p>
<p>というわけで、SerializableDictionaryはDictionaryの内部構造をシリアライズすることで、ネイティブプロセスのみで完結して爆速で復元します。</p>
<p>SerializableDictionaryではSerializableDictionary, SerializableLookup(MultiDictinary), SerializableTupleの3つを提供します。今のとこアセットストアに公開するつもりはそんなないので、使いたい場合はソースコードをZipでダウンロードするなりGitで落とすなりしてプロジェクトに投げ込んでください。</p>
<h2>SerializableDictionary</h2>
<p>例えばキーがint、値がstringの辞書を保存したい場合は、まず、継承したクラスを作ります。</p>
<pre><code class="language-csharp">[Serializable]
public class IntStringSerializableDictionary : SerializableDictionary&lt;int, string&gt;
{

}
</code></pre>
<p>わざわざ継承しなきゃいけない理由は、ジェネリックな型はシリアライズできないからです！しょうがないね。別にゆうてそんなに大量の型があるわけでもないでしょうし、素直にそれぐらいは作りましょう。あとは、普通に使えば普通にシリアライズ可能になってます。メデタシメデタシ。</p>
<p>インスペクタに表示するためのPropertyDrawerも用意してあります（こちらも定義しないとインスペクタに何も表示されなくて不安になる）。使う場合は、SerializableDictionaryPropertyDrawerを継承した型を一つ作って、そこに属性でひたすらぶら下げます。</p>
<pre><code class="language-csharp">#if UNITY_EDITOR

[UnityEditor.CustomPropertyDrawer(typeof(IntStringSerializableDictionary))]
[UnityEditor.CustomPropertyDrawer(typeof(IntDoubleSerializableDictionary))]
[UnityEditor.CustomPropertyDrawer(typeof(IntIntStringSerializableDictionary))]
public class ExtendedSerializableDictionaryPropertyDrawer : SerializableDictionaryPropertyDrawer
{

}

#endif
</code></pre>
<p>これを定義すれば、インスペクタ上では</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/13866974/da6f9fac-ec77-11e5-93a7-a8eb43c08680.png" alt="image" /></p>
<p>なんとKeyとValueの確認しか用意されてなくて、エディット不能！ただのDump！うーん、気が向いたらエディット可能にします。そのうち（多分やらない）。</p>
<h2>複数キーの辞書</h2>
<p>Int + Intの組み合わせでキーにしたいとか、辞書にはよくあるケースです。そして、そういったよくあるケースではKeyにTupleを使うことが多いです。が、UnityにはTupleはありません。<a href="https://github.com/neuecc/UniRx">UniRx</a>にTupleがあります、が、それはシリアライズ可能ではありません(Genericだからねー、structなので継承もできない)。と、いうわけで、辞書のキーにしたいよね専用にSerializableTupleを用意しておきました。使う場合はもちろんまずは継承してジェネリックを消すとこからはじめます。</p>
<pre><code class="language-csharp">[Serializable]
public class IntIntTuple : SerializableTuple&lt;int, int&gt;
{
    public IntIntTuple()
    {

    }

    public IntIntTuple(int item1, int item2)
        : base(item1, item2)
    {

    }
}

[Serializable]
public class IntIntStringSerializableDictionary : SerializableDictionary&lt;IntIntTuple, string&gt;
{

}
</code></pre>
<p>あとは普通にキーに使ってもらえれば、普通に使えます。ちょっと手間ですが、そこまで多いわけでもないでしょうし我慢できる範囲内。だといいかな。</p>
<h2>SerializableLookup</h2>
<p>ILookupは、Keyに対してValue側が複数になっている辞書です。Dictionary[Key, Value[]] みたいなイメージ。通常のILookupはLINQのToLookup経由でしか作成できない、Readonlyなシロモノです。これ、非常に便利な型でして、よく使います。ToLookupしらない人は覚えましょう。ただ、勿論シリアライズできないのでAddを加えたSerializableLookupを用意しました（Removeはありません！つまりBuilderのほうがイメージ近いかもしれません。Removeがない理由は実装しててバグッたからとりあえず消してるだけなのでそのうち入れるかもしれないかもしれない）</p>
<p>使い方はDictionaryと同様。</p>
<pre><code class="language-csharp">[Serializable]
public class IntIntSerializableLookup : SerializableLookup&lt;int, int&gt;
{
}

#if UNITY_EDITOR

[UnityEditor.CustomPropertyDrawer(typeof(IntIntSerializableLookup))]
public class ExtendedSerializableLookupPropertyDrawer : SerializableLookupPropertyDrawer
{

}

#endif
</code></pre>
<p>ちなみに中身は面倒くさいんでSerializableDictionaryの一部を改変して辻褄合わせてるだけなので、実効速度的な意味ではToLookupで生成したものに比べるとやや劣るかなー、といったところ。まぁハッシュキーの衝突具合とかにもよるので、いうほどそこまでではないと思います。実装の雑さは気にしてるのでそのうち直したい（絶対やらない）</p>
<h2>TrimExcess</h2>
<p>ListにせよDictionaryにせよ、任意個数をAdd可能なものは、内部である程度余分なバッファを持っています。しかし、ScriptableObjectなどにしてAssetBundleに載せたい場合は、その後の追加なども特になく個数は固定である可能性も少なくないはずです。と、いうわけで、TrimExcessメソッドを呼ぶことで余分なバッファを切り落とすことができます。もし個数が固定であることが見えているなら、事前にSerialize前に呼んであげておくことで、メモリ節約につながります。</p>
<h2>Unityでシリアライズ可能なもの</h2>
<p>内部構造の話なのですが、その前にUnityでシリアライズ可能なものの制限についておさらい。</p>
<ul>
<li>[Serializable]のついた非ジェネリックな具象型</li>
<li>UnityEngine.Objectを継承した型</li>
<li>public、または[SerializeField]のついたインスタンスフィールド</li>
<li>int, float, double, bool, stringなどのプリミティブなデータ型</li>
<li>配列、もしくはList[T]</li>
</ul>
<p>Dictionaryに非対応なのは勿論ですが、Nullable[T]に非対応が割と痛かったりするかな！また、トップレベル以外でnullをサポートしていなかったりして、ちょっと複雑な型を作った場合、nullを入れたと思ったら全部0が入った謎データに置き換わっていた、とかが生じます。それらの制限の回避策としては、SerializableDictionaryと同じようにSerializableNullableのようなそれっぽい似非な型を自前で作ってあげればなんとかなります。nullのほうも同様にNullableClass（なんじゃそりゃ）を作ってあげることにより、nullかそうでないかの区別を可能にできます。面倒くさくはあるんですが、どうしても必要な場合はそうして回避できなくもないよ、ということで。</p>
<p>SerializableDictionaryは、Dictionaryの内部構造を、Unityでシリアライズ可能な範囲（ようするにひたすら単純な配列まみれにする）に修正することで実現しています。オリジナルのDictionary自体は<a href="https://github.com/dotnet/corefx">dotonet/corefx</a>のものです。</p>
<h2>ハッシュコードを永続化することの安全性</h2>
<p>ハッシュコードを永続化することは、推奨されないことが明言されています。というのも、そのオブジェクトに対するハッシュコードが一意であるかが、どのスコープまで保たれるかというのは、全くもって不明瞭だからです。参照型などはアプリケーション起動毎に異なってなにの役にも立たなくなる、では数字は？文字列は？保証はないんですねー。</p>
<p>実用的な意味では、問題ないと判断しても構わないと思っています。しかし、まず、monoと.NET Frameworkのような環境が違うもので生成したもの同士の互換性はないと考えたほうがいいでしょう（実際ない）。また、.NET Framework内だけでも、バージョンが異なれば、違うハッシュアルゴリズムが使われることにより異なるハッシュコードが使われる可能性は全然あります。今後も、Unityのバージョンアップ＋（もしあるのなら）monoのバージョンアップが発生した際などは、互換性が崩れる可能性があります。最悪そうなった場合は、任意のComparerを挟み込めるようになっているので、そこで互換性を保ったハッシュコードを返してやることにより、一応大丈夫とはいえます。一応。</p>
<p>とはいえまあ、実用的な意味では大丈夫でしょう。タブンネ。まぁしかし、この辺グレーゾーンなきらいもあるから、Unity公式でサポートってのは難しいんじゃないかなあ、というのはしょうがないかなー。</p>
<h2>まとめ</h2>
<p>Unityって結局どこで動いているものなのよ、ってのを改めて突きつけられた感じがしました。C++のエンジンがあくまでも主だな、と。また、シリアライズを通して考えると、一見不思議なMonoBehaviourやpublic fieldなども納得がいくように見えてきて、ようするにネイティブとの境界線を接続している場所なんですね。COMとdynamicでやり取りするように、ネイティブレイヤーとフィールドでやり取りする。そう思えば、何もかも腑に落ちてきた気がします（悟り！）。</p>
<p>C#のレイヤーでいかに仕事をさせないかがキモで、そのためにC#を書く。ってのも、まぁ悪くない話だし、Unityアプリケーションとしての整合感やパフォーマンスが最も求めるべきことなのだ。というのは認識しておきたいな、なんて改めて思わさせられました。</p>
</div>
<h1><a href="https://neue.cc/2016/01/06_525.html">Unityでのボクシングの殺し方、或いはラムダ式における見えないnewの見極め方</a></h1>
<ul class="date"><li>2016-01-06</li></ul>
<div class="entry_body"><p>Happy boxing! UniRxの<a href="http://neue.cc/2015/12/21_523.html">前回リリース(UniRx 5.0.0)</a>でパフォーマンス向上を果たしたと書きましたが、まだやり残したことがありました。それが<a href="https://msdn.microsoft.com/ja-jp/library/yz2be5wk.aspx">ボックス化</a>(boxing)の殺害です。ボックス化は単純に言うと、せっかくの値型が箱に入っちゃってGCゴミが発生してGCがーーー、というもの。避けれるなら避けるべし。あ、ちなみに今回の内容は特に別にUnityに限らないふつーのC#の話です。</p>
<p>それと、というわけかで<a href="https://github.com/neuecc/UniRx">UniRx</a> 5.1.0リリースしました、アセットストアから落とせます。基本的な内容は以下に解説するボックス化を徹底的に殺害したことによるパフォーマンス向上です。</p>
<h2>ボックス化とジェネリクス</h2>
<p>GCって、別に見えてるnewだけで発生するわけでもありません。見えてるものを警戒するのは大事ですが、見えないものを見てないのは片手落ち感が否めない。そんな見えないものの代表例がボックス化です。実際どういう時に発生するのかというと</p>
<pre><code class="language-csharp">var x = (object)10;
</code></pre>
<p>みんな大好きint(ValueType)がobject(ReferenceType)に！これがボックス化の害です。なるほど、避けたほうが良さそうだ。とはいえこんなのやらないって？ですよね。ではこれは？</p>
<pre><code class="language-csharp">void Hoge(object o)
{
}

Hoge(10);
</code></pre>
<p>まぁまぁやらないかもしれませんが、まぁまぁやるといえなくもないです。というかやる時はあります。ではこれは？</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2)
{
    return t1.Equals(t2);
}
</code></pre>
<p>一見何も悪くないのですが、実は悪いです。どこが？</p>
<pre><code class="language-csharp">public virtual bool Equals(Object obj);
</code></pre>
<p>ここが。ようするにEqualsはobjectになった後に比較されてしまうのです。というわけでボックス化が発生します。ジェネリクスは基本的にボックス化を避けれるのですが、一部のObjectに生えてるメソッド、というかようするにEqualsですが、を触る場合、気をつけないとうっかりしがちです。他に t1.GetType() と書いてもボックス化が発生します。その場合、 typeof(T) と書くことで避けられます。</p>
<h2>EqualityComparer&lt;T&gt;を使う</h2>
<p>ボックス化を避けた比較を行うインターフェイスに<a href="https://msdn.microsoft.com/ja-jp/library/ms131187(v=vs.110).aspx">IEquatable&lt;T&gt;</a>があります。</p>
<pre><code class="language-csharp">public interface IEquatable&lt;T&gt;
{
    bool Equals(T other);
}
</code></pre>
<p>これを使い、つまり</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2) where T : IEquatable&lt;T&gt;
{
    return t1.Equals(t2);
}
</code></pre>
<p>にすればボックス化は避けれる問題なし。ではあるんですが、これでは不便すぎます（さすがにintとかはIEquatable&lt;T&gt;を実装してはいますが、普通の参照型はほとんど実装していないでしょう）。同じなのかどうかとりあえずチェックしたい、Equalsを普通に呼びたいケースは沢山あります。そこでEqualsを外部から渡せる<a href="https://msdn.microsoft.com/ja-jp/library/ms132151(v=vs.110).aspx">IEqualityComparer&lt;T&gt;</a>インターフェイスと、デフォルト実装を取得するEqualityComparer&lt;T&gt;.Defaultが使えます。</p>
<pre><code class="language-csharp">bool IsSame&lt;T&gt;(T t1, T t2)
{
    return EqualityComparer&lt;T&gt;.Default.Equals(t1, t2);
}
</code></pre>
<p>EqualityComparer&lt;T&gt;.Defaultは、TがIEquatable&lt;T&gt;を実装していればTがIEquatable&lt;T&gt;のEquals(T other)を、実装してなければEquals(object other)を呼んで比較します。これによりめでたく値型のボックス化が避けれました！UniRxでもDistinct、DistinctUntilChanged、ObserveEveryValueChanged、そしてReactivePropertyのSetValueでボックス化が発生していたのですが、UniRx 5.1.0からは発生しなくなっています。なんで今まで発生していたのかというと、EqualityComparer&lt;T&gt;がiOS/AOTで怪しくてあえて避けてたんですが、5.0.0からAOTサポートはきってIL2CPPのみにしたので無事性能向上を果たせました。</p>
<h2>UnityとIEquatable&lt;T&gt;</h2>
<p>Unityにおいては、それだけでメデタシではなく、もう少し話に続きがあります。Unityにおける代表的な値型であるVector2やRectなどは、全て、IEquatable&lt;T&gt;を実装して、いません。へー。==はオーバーライドされているので、素のままで扱って比較している限りは問題ないのですが、ジェネリックの要素として、また、DictionaryのKeyとして使った場合などでもボックス化が発生しています。</p>
<p>これが地味に困る話で、UniRxにおいてもObserveEveryValueChangedなどでVector2などが流れてくるたびにボックス化が発生したらちょっとよろしくない。</p>
<p>そこで、その対策として今回のUniRx 5.1.0では UnityEqualityComparer.Vector2/Vector3/Vector4/Color/Rect/Bounds/Quaternion というものを用意しました。これら代表的なUnityの値型に関しては、専用のEquals/GetHashCodeを実装してあります。また、 UnityEqualityComparer.GetDefault[T] により、それらが型から取り出せます。普通にUniRxを使っている範囲では(Distinct、DistinctUntilChanged、ObserveEveryValueChangedなど) IEqualityComparer の取得は UnityEqualityComparer.GetDefault[T] を通すようにしているため、極力ボックス化が発生しないようになっています。</p>
<h2>ラムダ式と見えないnew</h2>
<p>ボックス化、見えないGCゴミの話を書いたので、ついでにもう一つ見えないゴミを発生させるラムダ式について。ラムダ式は実際のところコンパイラ生成の塊みたいなもの、かつ、中身によってかなり生成物が変わってきます。ざっと6通りのパターンを用意してみました。</p>
<pre><code class="language-csharp">static int DoubleStatic(int x)
{
    return x * 2;
}

int DoubleInstance(int x)
{
    return x * 2;
}

void Run()
{
    var two = int.Parse(&quot;2&quot;);

    Enumerable.Range(1, 1).Select(DoubleStatic);           // 1
    Enumerable.Range(1, 2).Select(DoubleInstance);         // 2
    Enumerable.Range(1, 3).Select(x =&gt; x * 2);             // 3
    Enumerable.Range(1, 4).Select(x =&gt; x * two);           // 4
    Enumerable.Range(1, 5).Select(x =&gt; DoubleStatic(x));   // 5
    Enumerable.Range(1, 6).Select(x =&gt; DoubleInstance(x)); // 6
}
</code></pre>
<p>どんな感じになるか想像できました？では、答え合わせ。ちょっと簡略化しているので正確にはもう少しこんがらがった機会生成になっていますが、概ねこんな感じになってます。</p>
<pre><code class="language-csharp">static Func&lt;int, int&gt; cacheA;
static Func&lt;int, int&gt; cacheB;

internal static int LambdaA(int x)
{
	return x * 2;
}

class Closure
{
    internal int two;
    
    internal int LambdaB(int x)
    {
        return x * two;
    }
}

internal static int LambdaC(int x)
{
	return DoubleStatic(x);
}

internal static int LambdaD(int x)
{
	return DoubleInstance(x);
}

void Run()
{
    var two = int.Parse(&quot;2&quot;);

    // 1 - Select(DoubleStatic)
    Enumerable.Range(1, 1).Select(new Func&lt;int, int&gt;(DoubleStatic));
    
    // 2 - Select(DoubleInstance)
    Enumerable.Range(1, 2).Select(new Func&lt;int, int&gt;(DoubleInstance));
    
    // 3 - Select(x =&gt; x * 2)
    if(cacheA != null)
    {
        cacheA = new Func&lt;int, int&gt;(LambdaA);
    }
    Enumerable.Range(1, 3).Select(cacheA);
    
    // 4 - Select(x =&gt; x * two)
    var closure = new Closure();
    closure.two = two;
    Enumerable.Range(1, 4).Select(new Func&lt;int, int&gt;(closure.LambdaB));
    
    // 5 - Select(x =&gt; DoubleStatic(x))
    if(cacheB != null)
    {
        cacheB = new Func&lt;int, int&gt;(LambdaC);
    }
    Enumerable.Range(1, 5).Select(cacheB);
    
    // 6 - Select(x =&gt; DoubleInstance(x))
    Enumerable.Range(1, 6).Select(new Func&lt;int, int&gt;(LambdaD));
}	
</code></pre>
<p>それぞれ似ているような違うような、ですよね？一つ一つ見ていきましょう。</p>
<p>パターン1、パターン2はメソッドを直接突っ込む場合。この場合、実際のところはデリゲートを生成して包んでます。そしてこのデリゲートはGCゴミになります。なります。全く見えないんですが地味にそうなってます。と、いうわけで、それを回避するには静的メソッドなら静的フィールドに静的コンストラクタででも事前に作ってキャッシュしておく、インスタンスメソッドの場合は、もし使うシーンがループの内側などの場合は外側で作っておくことで、生成は最小限に抑えられるでしょう。</p>
<p>パターン3は、恐らく最もよく使うラムダ式の形式で、使う値が全てラムダ式の中だけで完結している場合。この場合、自動的に静的にキャッシュを生成してそれを未来永劫使いまわしてくれるので、非常に効率的です。一番良く使う形式が効率的というのは嬉しい、遠慮無くどんどん使おう。</p>
<p>パターン4も、まぁよく使う形式、でしょう。ローカル変数をラムダ式内で使っている（キャプチャ）した場合。この場合、普通にクラスがnewされて、そこにラムダ式内部で使われる値を詰め込み、その自動生成のクラスのインスタンスメソッドを呼ぶ形に変換されます。というわけで、パターン4は見た目は人畜無害ですが、中身はそれなりのゴミ発生器です！いや、まぁたかがクラス一個。であり、されどクラス一個。画面上に大量に配置されるGameObjectのUpdateなどで無自覚に使っていたりすると危なっかしいので、それなりに気を留めておくと精神安定上良いでしょう。</p>
<p>パターン5、パターン6は内部でメソッドを使っている場合。ちなみにここではメソッドにしましたが、フィールドやプロパティでも同じ生成結果になります。抱え込む対象がstaticかinstanceかで変わってきて、staticの場合ならキャッシュされるので少しだけ有利です。</p>
<p>なお、この挙動は現時点でのVisual Studio 2015のC#コンパイラによって吐かれるコードであり(Unityの今のmonoもほぼ一緒、のはず、です、確か多分）、将来的にはそれぞれもう少し効率的になるかもしれません（メソッドを直接突っ込む場合のキャッシュとかは手を加える余地がある気がする）。とはいえ原理を考えたら、外部変数をキャプチャするラムダ式はどうやってもこうなるしかなさそうだったりなので、大筋で変わることはないと思います。</p>
<h2>まとめ</h2>
<p>正直なところ今回書いたのは細かい話です！別に気にしすぎてもしょうがないし、というかこんなの細部まで気にして避けながら書くのは不可能です。ギチギチに避けてラムダ式禁止だのLINQ禁止だの言い出すなら、早すぎる最適化の一種で、かなり愚かしい話です。が、ゲームの中にはひじょーにタイトな部分は存在するはずで、そこで無自覚に使ってしまうのも大きなダメージです。私だってタイトになることが想定されるUpdateループの中でLINQを貫くならやめろバカであり、普通にペタペタとforで書けとは思いますよ。</p>
<p>あんまりゼロイチで考えないで、柔軟に対処したいところですねえ。どこに使うべきで、使うべきでないか。まぁその見極めがむつかしいから全面禁止とかって話になるのは実際のところ非常によくわかる！のですが、それこそプロファイラで問題発見されてからでもいいじゃん、ぐらいの牧歌的な考えではいます。いやだって、そんなたかがLINQやラムダ式ぐらいであらゆるところがボトルネックになるわけないぢゃん？そんなのより大事なとこ沢山あるでしょう。それに比べたらLINQを普通に使えることのほうが、UniRxを普通に使えることのほうが100億倍素晴らしい。もちろん、地味な積み重ねでダメージが出てくるところであり、そして一個一個は地味だったりするから見つけづらくて辛いとかって話もありつつ。</p>
<p>そんなわけでUniRxは、かなり厳し目に考慮しながら作っているので、比較的概ね性能面でも安心して使えるはずです！まだもう少しやれることが残ってはいるんですが、ちょっと踏み込んで書いてみると謎のuNET weaver errorに見舞われて回避不能で死んでいるので、当面はこの辺が限界です（ほんとuNET絡みのエラーはなんとかして欲しい、理不尽極まりない）。とはいえ、何かネタがあれば継続してより良くしていきますので、よろしくおねがいします。</p>
<p>そういえば第一回Unityアセットコンテストでは、<a href="http://blogs.unity3d.com/jp/2015/12/24/unityassetcontestjp1st/">セミファイナリスト頂きました</a>。ほぼほぼスクリプトのみの地味 of 地味なアセットであることを考えると全然上等で、嬉しい話です。</p>
</div>
<h1><a href="https://neue.cc/2015/12/31_524.html">2015年を振り返る</a></h1>
<ul class="date"><li>2015-12-31</li></ul>
<div class="entry_body"><p>振り返るシリーズ第四弾。去年の目標は</p>
<blockquote>
<p>テーマは「クライアントサイドとサーバーサイドをC#で統一することのメリットの実証」「さらにリアルタイムネットワークもC#で統一」「のためのヒットアプリケーションの創出」です。指向はあんま変わってないんですが、より具体的に。来年は動く年かな、といったところ</p>
</blockquote>
<p>ようするに会社(<a href="http://grani.jp/">グラニ</a>/CTO)でゲーム出して実証する。であり、結果としては……。はい。なので、本当に来年こそはね。というところです。</p>
<h2>C#</h2>
<p>今年はVS2015のリリースということもあり、かなりRoslynに傾倒しました。その集大成としてのまとめは<a href="http://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a>にスライドで出してますが、その後にもAnalyzerだけではなく、<a href="http://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a>や<a href="http://neue.cc/2015/12/21_523.html">Workspace APIを使ったプロジェクトコードからのT4生成での応用例</a>といった形で、ただたんに触ってみた、ではなくて、実用的にどう使えるのか、の応用例をきっちり掲示できたんじゃないかと思います。これらの話は実際に使っているもので、便利、かつ世界が広がったのは確かなので、Roslynはこれからどんどん応用的に使われるといいかな。</p>
<p>また、いつになくライブラリ書いてました。会社で必要だから作ってったという面も大きいんですけれど、こうして並べると、実際結構やりましたね、えらいえらい。</p>
<p>まずAPIサーバーとして<a href="https://github.com/neuecc/LightNode">LightNode</a>という自家製フレームワークを採用しているので、<a href="http://neue.cc/2015/02/16_505.html">Glimpse対応</a>と<a href="http://neue.cc/2015/04/19_511.html">Swagger対応</a>を入れてます。この対応は大正解で、もはやGlimpseとSwaggerなしでAPI開発していくのは無理ゲーとすら思える。超絶便利。Glimpseは主要開発者がMicrosoft入りしてより専任して開発することになったのと、Swaggerはもはやウェッブ標準といってもいい立ち位置を確立したということで、どちらもメジャーなテクノロジとなったことも含めて、技術選定にも成功したと言えるでせう。ASP.NET 5がまだまだ時間かかるので様子見したのも含めて、現状での最適解ではあるんじゃないかな、と。</p>
<p>Redisライブラリの<a href="https://github.com/neuecc/CloudStructures">CloudStructures</a>もGlimpse対応とStackExchange.Redis対応によって、相当リッチなものになりました。特にGlimpseのは相当気合入れたので充実してて実用度超絶高い。とはいえ本体部分は原則的には薄いラッパーなので、粛々とやってきます、というところですね。</p>
<p><a href="https://github.com/neuecc/LINQ-to-BigQuery">LINQ to BigQuery</a>はLINQPad Driverを作りました！これで実用度が飛躍的に上がりました。世間的にもデータ分析はBigQueryで決まりだよね！という流れが出来上がった年なわけですが、ここも乗り遅れずというか、むしろ引っ張る側に回れたのではないかと自負するところです。あとLINQPadにも相当詳しくなった。</p>
<p>今年最後の新顔は<a href="https://github.com/neuecc/EtwStream">EtwStream</a>で、↑でLINQPadに詳しくなった結果、応用例が頭に浮かんで一気に実用に載せられました。ETW(Event Tracing for Windows)のビューアーとしてまともに使える世界唯一の解といっても過言ではない（むしろ今までのフベンサがヤバすぎた……）。年末にはRoslyn C# Scriptingによる実行できるコンフィグというコンセプトを打ち出したOut-of-Process Serviceも追加していて、来年はこれの稼働実績を作っていきたいところです。</p>
<p>変わり種だけど誰にとっても実用度100億なのは<a href="https://github.com/neuecc/Open-on-GitHub">Open on GitHub</a>というVS拡張で、もはやこれなしでぎっはぶでコミュニケーションを取るのは無理なのでは疑惑もあるほどに神拡張。地味に12/29にVer 1.4.0のアップデート出してます。</p>
<p>そして<a href="https://github.com/neuecc/UniRx">UniRx</a>。今年はお陰様で大躍進の年で、<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;ref=searchresults&amp;s=stars&amp;type=Repositories">GitHubスター順</a>でも、GitHubで公開されてるUnity用ライブラリでは世界4位と、中々に中々の感じで、いやほんと良かった。</p>
<p>年の始めではReacitvePropertyやPresenterBaseの導入によるModel-View-(Reactive)Presenterというコンセプトの確立が地味に大きめ（ちなみに私は設計とかってこのレベルの話こそ最も大事だと思ってて、コードを小奇麗にするようなレベルの話は設計、ですかねえ？とは思ってる）。真ん中でObservableTriggers、そして年末駆け込みの<a href="http://neue.cc/2015/12/21_523.html">UniRx 5.0</a>で完全書き直しによるパフォーマンスとデバッガビリティの向上。もはやUniRxなしで書けと言われると困りすぎるぐらいに必要不可欠な存在となれました。</p>
<p>UniRxが成功したポイントは、Reactive Extensions自体が素晴らしいコンセプトで実績もある、というのも勿論そうなんですが、UniRx自体の、Unityへフィットさせるための繋ぎ方の工夫の面も大きいとは自負してます。あまり頭でっかちにならずに柔軟に作り込めたのが良かった。ReacitvePropertyなんかも、実装はシンプルですが、（.NET版を作った時の）コンセプト立証と実装には普通に時間かけてたし、そもそもコロンブスの卵的なところもありましたし、更にそのUnity化でも、削ぎ落とし方には相当神経使ってます（ゴテゴテ足すだけが設計ではない）。</p>
<p>また、お陰様でUnityのスクリプティングと、そしてRxには詳しすぎるほどに詳しくなれました、というかRxに関しては実際隅から隅まで理解した……。</p>
<p>現在未公開だけど予定があるものとしては<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>というUnity/Photon Server用の非同期RPCフレームワークがあります。これは来年の初頭に公開できればな、ですかねー。</p>
<h2>お仕事</h2>
<p>書いたライブラリは基本的に会社でフルに使ってるものなので、成果っちゃあ成果です。が、集中力散漫な年でした。成果として些かライブラリ過多になったのは、それが時間の捻出が比較的しやすい（土日とかにちょっと徹夜して気合いれればグッと形にできたりするんで）というのが大きいですね。細切れな時間で、いまいちうまくプロダクトそのものにコミットできなかったのは減点度大きめで、非常に良くない。ライブラリ側の成果と相殺してプラマイゼロと言いたくはあるんですが、私的な理想像とは離れたところにあるので、まぁ、60点ぐらい……（ちょっと甘め）</p>
<p>いろいろと白髪が増える、ハゲる。といったぐらいな感じです、うみぅ。来年は100点目指します。</p>
<h2>ゲームとか音楽とか</h2>
<p>今年はライブにまぁまぁ行ったんですが、年末の<a href="http://www.creativeman.co.jp/artist/2015/12kingcrimson/">King Crimsonの来日講演</a>が震えすぎたのでそれが全て。生きててよかったというか生きてるうちに生で聴けることがあるなんて……！内容もばっちしで、いやはやホンモノは永遠にホンモノであり続ける、というかホンモノであり続けようとする姿勢に感服するばかりです。この編成での本気のライブ版が早く出てほすぃ。</p>
<p>面白かったといえば<a href="http://www.beatink.com/Labels/Warp-Records/Squarepusher/BRC-461/">Squarepusherの来日講演</a>も見に行ったのですが、実に面白かった。サイトでは360度動画が公開されてますが、そうした全方位動画やプロジェクションマッピング、VRの未来すら感じられて、思い出すと行けて本当に良かったなぁ。</p>
<p>ゲームは<a href="http://downwellgame.com/">Downwell</a>がオモシロイッス。</p>
<p>漫画は、iPhone 6s Plusを買ってから、スマフォで本や漫画が十分に読めるようになってしまって革命的に体験が変わった。いやあ、大画面スマフォ（ファブレット）は良いですね！一度体験すると、もう小さいのには戻れない。というわけで基本Kindleで買ってiPhoneで読むというインスタントな生活になりました。今年読んだ中だと<a href="http://www.amazon.co.jp/dp/B00U0OMIQA/">ヴァーチャル・レッド</a>が良かったかなぁ、終始、陰鬱な空気が流れていて息苦しいんだけどどこか心地良くもある。気に入りすぎてKindleで読んだ後に実書籍のほうも買ったんですが装丁がよく出来てて、そちらも満足度高し。</p>
<h2>来年</h2>
<p>シンプルに、全力で仕事してゲーム出す。ですね。それ以外なし。もちろん、それはC#を全方面で活かした実証結果として成り得るものです。絶対。これは絶対。</p>
<p>私個人としてはヌルヌルとC#でのスクリプティングにだけ篭もりすぎた感あるので、UniRxも一段落したことだし（ちなみに、もう少し性能向上のためのアップデートが控えていてというか現在審査中なので年明け早々にそれはリリースされるでしょう）、シェーダーをそれなりにすらすら書ける程度にはグラフィック処理もできるようにってのは年頭の宿題にしておきます。</p>
</div>
<h1><a href="https://neue.cc/2015/12/21_523.html">UniRx 5.0 - 完全書き直しによるパフォーマンス向上とヒューマンリーダブルなスタックトレース生成</a></h1>
<ul class="date"><li>2015-12-21</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx(Reactive Extensions for Unity)</a>のVer 5.0が昨日、AssetStoreにリリースされました。前回が4.8.2で6月なので、半年ぶりで、今回はメジャーアップデートとなります。現在の最新であるUnity 5.3（の新機能）に対応というのもあります、が、今回の目玉は書き直しです。半年間なにやっていたかというと、書き直そう！いよいよやっと重い腰を上げてスタックトレースに優しいコードにしよう！と思い立って始めてみたもののメンドウくささが極まって挫折して放置。してたんですが、先月ぐらいに、いい加減に手を付けたくて、ちょっと<a href="http://grani.jp/">うちの会社</a>の仕事時間を貰ってゴリゴリ進めてやっと終わりました。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub - UniRx</a></li>
<li><a href="http://u3d.as/7tT">UnityAssetStore - UniRx</a></li>
</ul>
<p>とりあえず分かりやすい成果としては、スタックトレースです。</p>
<pre><code class="language-csharp">var rp = new ReactiveProperty&lt;int&gt;();

rp.Where(x =&gt; x % 2 == 0)
  .Select(x =&gt; x * x)
  .Take(10)
  .Subscribe(x =&gt; Debug.Log(x));

rp.Value = 100;
</code></pre>
<p>という人畜無害なコードがあるとして、以前のスタックトレースはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917884/404287a0-a75d-11e5-9aee-ebe8d5bb28e3.png" alt="image" /></p>
<p>言ってることはわからんでもないコンパイラ生成の何かと、多量の中間物で埋まっていて、実に読み取りにくい。この程度のメソッドチェーンならまだマシで、もっと長大で、複雑なオペレータが絡んでる場合は困難極まってました。私も何度文句を言われて平謝りしたか分からないぐらいです。しかし、今回のバージョンからはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917889/765ebcf0-a75d-11e5-8117-f2b85a4113af.png" alt="image" /></p>
<p>自動生成コードなし、中間物ナシ。圧倒的な読みやすさ！また、これはそのまま、書いたとおりに動いているということの証左でもあります。実行パイプラインの無駄がスタックトレースに出ているままに皆無になったので、パフォーマンスにも寄与しています（書き換えた今では、もはや前のが厚すぎた説はありますけれど、それはまぁ言わんといてください……）</p>
<p>実装はかなりメンドウで、ラムダ式を使うと問答無用でコンパイラ生成のクラスが吐かれてしまうので、ひたすら名前付きのクラスを作っていくお仕事をしました（一個のオペレーターにつき2~3のクラスを要求する、オーバーロードがあればその分だけ……）。また、Unityのコンソールの出力に合わせた細かい調整を施すことによって（＋通常のスタックトレースへの吐かれ方に対しても調整して）作りました。すっかりスタックトレースのことを考えたプログラミングができる脳みそが出来上がったんですが、基本的に面倒くさ度100なので、ふつーのゲーム側のコードでは考えたくないしやりたくもないしやらなくていいと思ふ。</p>
<h2>性能改善</h2>
<p>じゃあ前のは遅かったのかよ、と言われると、うーん、そんなでもないですよ？、とは言いたいのですけれど、まぁカタログスペック的には実際3~10倍ぐらい速くなってます。これはねぇ、例えばMySQL 5.7が5.6の3倍速い！なるほど、じゃあ5.6はゲロ遅なのか？そうじゃあないっしょー、みたいな話なのですが、実際速くなったのは誰にとっても私にとっても嬉しい話です。</p>
<p>しかし、パフォーマンス低いとか気になるとか、漠然とした話で、何も言ってないに等しいんです。もちろん、3~10倍速くなったというのも何も言っちゃあいないです。プログラムの抱えている範囲に対して広すぎる、漠然としすぎていて何ら指標になっちゃいません。というのは気をつけてください。Rxのパフォーマンスを測るにあたって、フェーズ的に3つあって、</p>
<ul>
<li>Observableを構築するフェーズ(さすがにこれはほとんど無視していい)</li>
<li>Subscribe = Observerを構築するフェーズ</li>
<li>OnNext</li>
</ul>
<p>それぞれは独立して考える必要があります。また、ReactivePropertyはSubscribeと同時にOnNextも一回入るのでSubscribe + OnNextである、などなどがあるので、どこをどう測りたいかを明確にし、どう測るかを考えないとザルな結果になります。</p>
<p>基本的に、Rxのチェーンの寿命は長いのでOnNextの性能を最重要視して見るべきです。ここの区別は非常に大事です、長ければチェーン構築コストは相対的に無視できる範囲に収まるのでマイクロな結果で想像するのは違うってものです。が、初回に大量にSubscribeが発生するといった、ローディング的な意味合いでは、Subscribeのフェーズも鑑みる必要があります。</p>
<p>んで、これもザックリとしすぎでアレなんですが、OnNextは3~5倍ぐらい、Subscribeに関しては10~20倍速くなりました。OnNextは全体的なパイプラインの最適化のオペレーターの実装調整が効いてるんですが、Subscribeは抜本的に最適化/単純化したので、以前と全然違う結果になってます。これは、社内で大量のSubscribeがシーンロード初回に発生するという事案がありまして、Subscribeを改善しない限りロード長過ぎで終わぽ、だったのでなんとかしました、はい、すびばせん今まで手付かずで……（ちなみに本家Rx.NETとやり方変えてるので本家Rx.NETよりも速い）</p>
<p>あとのところはオペレーター次第です。WhereとかSelectとか、単純な奴は実装変わってないんで大差ないんですが、一部のメソッドの実装が素朴でしょっぱかったので、そういうのはきっちり直してるので以前のと全然性能変わってきてます。特にObserveOnが顕著かな。また、Observable.IntervalやTimerなどの一部の時間系メソッドも構造がガラッと変わってるので(MainThreadScheduler/ThreadPoolSchedulerが使われる場合には最適化パスを通るようにしてる)、かなり良好な結果が得られるのではないかと。</p>
<p>全体的にGCゴミも減ってます。まだもう少し減らせるポイントが残ってるので、次のマイナーアップデートではその辺の処理をする予定デス。</p>
<h2>リリースノート</h2>
<p>今回の。</p>
<pre><code class="language-txt">破壊的変更:
iOS/AOTサポートは切りました。IL2CPPしかサポートしません。
Unit/Tuple/CancellationToken/TimeInterval/Timestampedをclassからstructに変えました。
MainThreadDispatcher.Postのメソッドシグネチャが変わり、T stateを要求します。
ObservableMonoBehaviour/TypedMonoBehaviourがObsoleteになりました。
AotSafe Extensions(WrapValueToClass)を消しました。
InputField.OnValueChangeAsObservableをOnValueChangedAsObservableにリネームしています(Unity 5.3の場合。Unity 5.3でInputField側で同様の変更が入っているため)
Subscribe in SubscribeでのException Durabilityを保証します。

追加メソッド/クラス:
Observable.ForEachAsync
Observable.Take(duration)
Observable.Aggregate
Observable.Zip(T3~T7)
Observable.CombineLatest(T3~T7)
Observable.Start(function, timeSpan)
Observable.ToYieldInstruction in Unity 5.3
Observable.DoOnError
Observable.DoOnCompleted
Observable.DoOnTerminate
Observable.DoOnSubscribe
Observable.DoOnCancel
Observable.CreateSafe
Progress
StableCompositeDisposable
MultilineReactivePropertyAttribute

その他色々修正:
色々色々(詳しくはGitHubのとこの正式なリリースノート見てくだしあ)
</code></pre>
<p>破壊的変更といっても、直撃することはないんじゃないかなあ、と思ってます。ただ社内ではUnit/Tupleのstructへの変更で引っかかったりはしました(想定外にもnullが代入されている場合があった！)。それは適切にdefault使うのと、Tupleに関してはTuple?にするなりする程度で対応はできます。struct化はAOTサポートを切ることで躊躇いなくできるようになって、ヨイことだなー、と。コードも全体的にAOTサポートのための余計なコードを順次切り落としています（パフォーマンスロスに繋がっていたので）。その辺はIL2CPPバンザイ、ですかねえ。</p>
<h2>vs IL2CPP - Runtime UnitTest Runnner</h2>
<p>IL2CPP万歳と言ったそばから言うのもアレですが、IL2CPP苦しい……。コンパイル死ぬほど遅いし、というのはおいておいても、まだ地雷は埋まっていて、たまに踏んで死ぬんですよね。その場合IL2CPPのバグなんで報告して直してもらうってことになるんですが、それはそれとして、なんで死ぬのかがAOTの場合は想像ついたし対処も比較的容易だったんですが、IL2CPPは踏むまで地雷かどうかを察知することが不能な上に、踏んだら踏んだで、何を踏んだからこうなったかがイマイチ分からなくて最小ケース作ってバグレポも辛いケースもちらほら。</p>
<p>とはいえ、それなりに安定してきてるのは確かだと思います。偉い。そこは賞賛されるべき。</p>
<p>のはいいんですが、実行するまで分からないじゃ（特にライブラリ側としては）困るので、iOS実機でユニットテストを動かしたいと思いました。Unity 5.3から<a href="http://docs.unity3d.com/Manual/testing-editortestsrunner.html">Editor Test Runner</a>なども標準で入ってきましたが、端的に言えば、欲しいのはそれじゃない。実機で動かしたいの！エディターでの実行はどうでもいいの！</p>
<p>エディター上での実行も大事なんですが、元々UniRxは.NET用ライブラリとしても動くように設計されていて、ユニットテストも.NET用ライブラリとしてMSTestで書かれている（！）という特殊な環境なので、エディターでのテストサポートは完全に不要なのです。いや、だってVSのテストランナー使ったほうがやりやすいじゃん？</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919089/a1042f8e-a78b-11e5-9b65-fbca28a5da13.png" alt="image" /></p>
<p>そうやってユニットテスト自体は書かれてるし、さすがに実機用に別のを書きなおすのは不可能なので、このユニットテストを実機で動かせるように持ってければそれでいいんだよねー。</p>
<p>ここで出てくるのが<a href="https://github.com/dotnet/roslyn">Roslyn</a>。Roslynを使ってユニットテストプロジェクト内のユニットテストを、ソースコードのファイル単位ではなく、解析可能な構文木単位で取得し、<a href="https://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Text Template</a>で整形して吐き出せちゃえばいいんだ、という合わせ技で運搬することに成功しました。VS2015だから出来るハック、VS2015最高……。さすがにコード持ってくだけではMSTestの実体がなくて動かないんですが、そこは適当にモック(Shim)を用意して回避しました。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919143/db2b7fae-a78c-11e5-8dea-6e7e99598bd2.png" alt="image" /></p>
<p>エクストリーム雑なUI。エラーが出た場合は赤くなってExceptionを表示します。これで、ちゃんとiOS/IL2CPPで全部パスしてるのを確認済みです。</p>
<p>ちなみにこのRoslyn + T4でコード生成するテクニック、今回のように別プロジェクトをターゲットにして運搬するというのもいいんですが、自プロジェクトを対象にすることもできます。T4で生成するためのコードのタネって、今まではT4側に書くしかなくて面倒だったんですが、もうその制限はありません。ありとあらゆるソースコードがコード生成のためのタネとして使えます。メタプログラミングの扉をまた一つ開いてしまった。</p>
<p>このテクニックは私の発明じゃなくて<a href="http://www.misuzilla.org/Blog/2015/12/04/UsingRoslynInT4Template">RoslynをT4テンプレート内で使う - ぷろじぇくと、みすじら。</a>から拝借してますので、気になる人はそちらの記事をどうぞ。ｌ</p>
<h2>Unhandled Exception Durability</h2>
<p>UniRx 5.0の変更のうち、ちょっとだけ重要なのがUnhandled Exception Durabilityというコンセプト。です。これは、Rxでイベントハンドリングするのはいいんだけどエラーでるとイベント購読が吹っ飛ぶの困るんだよねー、に対するUniRxからの回答ということで。内容ですが、Subscribe in Subscribe時の例外を外側に伝搬「しない」ことを保証しています（逆に言えば実は4.8では保証されてなくて解除されたりしてました。ちなみにRx.NETでも保証されてなくて解除されたりされなかったりします、ここはUniRx独自で挙動を明言する形に倒しています)。伝搬しない、というのは握りつぶすという意味ではなくて、ObservableのDispose処理を行わない、という意味です（例外自体はグローバルに飛ぶのでUnityのConsoleにExceptionが表示されるし、ログイベントでちゃんと捉えられます）</p>
<pre><code class="language-csharp">button.OnClickAsObservable().Subscribe(_ =&gt;
{
    // もし内側でエラーが発生しても、外側のOnClickがデタッチされることはない
    ObservableWWW.Get(&quot;htttp://error/&quot;).Subscribe(x =&gt;
    {
        Debug.Log(x);
    });
});
</code></pre>
<p>エラーハンドリングは難しい問題で、<a href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling">RxJavaのErrorHandlingの章</a>を読んでも別にそんなワカラナイよね、とかって感じではある。UniRxでは Retry/OnErrorRetry でハンドルできなくはなく、まぁそれがスタンダードなRx Wayではあるんですが<a href="http://qiita.com/bouzuya/items/5e068659d63d9961a260">RxJS の Operators (6) - Observable のエラーハンドリング</a>のまとめコメント「これで本当にエラーハンドリングに十分なのか不安です。」とあるように、実に不安です。</p>
<p>で、入力用のハンドラーが吹っ飛ぶのは致命傷なので、どうしても救いたいその辺のとこに関してはSubscribe in Subscribeで処理するのがいいんじゃないかなー、というのを提唱します。入力イベントを合成したいって局面も多いと思うので、それはそれで合成してもらったうえで（そして、その合成パイプラインに関してはエラーが出ないよう厳重に作る！）、それを入力ストリームだと考えて、そこから先はSubscribe in Subscribe。あまり格好の良いものではないのも事実ですが、現実的っちゃあ現実的かなー、と。ちなみにこの挙動を保証するのはUniRxだけだと思うので他のRx系に持ってっても動きません（多分）</p>
<p>なお、Subscribe in Subscribeでの例外で解除されないのは最上流がHot Observableのものだけです。HotとColdに関しては<a href="http://qiita.com/toRisouP/items/f6088963037bfda658d3">RxのHotとColdについて</a>などを参照するといいと思いますが、とりあえず具体的にHotなのはUniRxデフォルトでは FromEvent/Subject/ReactiveProperty/ObservableTriggers/UnityUI.AsObservable です。ようはイベント的なやつです。Coldなのは Return/Interval/Timer/FromCoroutine などで、これらは例外で解除されます（そうじゃないとTimerとか無限に動き続けられても危なくて困るでしょ？FromCoroutineだって途中でエラーが出てる状態なのに回られても困るでしょ？）</p>
<h2>CustomYieldInstuction</h2>
<p>書き直しはいいんだけど、何か新機能ないと寂しいよなー、ということで、Unity 5.3用に一つ入れました。Unityブログでも<a href="http://blogs.unity3d.com/jp/2015/12/01/custom-coroutines/">カスタムコルーチン</a>として紹介されていますが、Unity 5.3からCustomYieldInstructionが搭載されました。というわけでUniRxもUnity 5.3以上ならToYieldInsturctionメソッドが使えるようになっています。</p>
<pre><code class="language-csharp">IEnumerator TestNewCustomYieldInstruction()
{
    // Rx Observableをyield returnで待ちます.
    yield return Observable.Timer(TimeSpan.FromSeconds(1)).ToYieldInstruction();

    // スケジューラを変える(Time.scaleを無視する)とかも当然可能
    yield return Observable.Timer(TimeSpan.FromSeconds(1), Scheduler.MainThreadIgnoreTimeScale).ToYieldInstruction();

    // 戻り値を得る場合はObservableYieldInstructionを変数に取れば、Result/Errorで受け取れます
    var o = ObservableWWW.Get(&quot;http://unity3d.com/&quot;).ToYieldInstruction(throwOnError: false);
    yield return o;

    if (o.HasError) { Debug.Log(o.Error.ToString()); }
    if (o.HasResult) { Debug.Log(o.Result); }

    // 当然こういう長めのものだって自由に書けます 
    yield return this.transform.ObserveEveryValueChanged(x =&gt; x.position)
        .FirstOrDefault(p =&gt; p.y &gt;= 100)
        .ToYieldInstruction();
}
</code></pre>
<p>今までもToAwaitableEnumerator/StartAsCoroutineというメソッドで同様なことを出来るようにしていたのですが、ToYieldInsturctionのほうが効率的だし、使いやすいです。ToYieldInsturctionによるObservable-&gt;Coroutine変換のオーバーヘッドはないといっても過言ではない！Unity 5.3最高！</p>
<p>ちなみに、このToYieldInsturctionはCustomYieldInstructionクラスを実装してません。Unity 5.3のカスタムコルーチン対応というのは、yield returnでIEnumeratorを受け取ると毎フレームMoveNextを呼び出して待機する、というのが正しい話です。CustomYieldInstructionはあくまでIEnumerator実装のためのちょっとしたヘルパーなので、別にそれにこだわる必要はありません、ということで普通に独自の軽量なIEnumerator実装を刺しています。</p>
<p>ちなみに実行されるタイミングは<a href="http://docs.unity3d.com/530/Documentation/ScriptReference/CustomYieldInstruction.html">CustomYieldInstructionの説明</a>によると after MonoBehaviour.Update and before MonoBehaviour.LateUpdate だそうなので、実行タイミング調整のネタに使えるかもしれません。</p>
<h2>まとめ</h2>
<p>実際のトコver 2.0なんですが、諸事情で4始まりなのでver 5.0です！Unityのメジャーバージョンと偶然揃ったしいっか、という気がしますね！今回のコードはかなり自信あって、パフォーマンスがー、な局面であってもお薦めできます。どうせ、ライトウェイトを冠した超機能限定版の同じようなものを実装するなら、性能面であっても素直にUniRxを使ったほうがいいでしょう。と、言えます。言えます。</p>
<p>今月頭に書いた<a href="http://neue.cc/2015/12/03_521.html">Unity 5.3のMulti Scene EditingをUniRxによるシーンナビゲーションで統合する</a>などのように、UniRxを前提に置くことで、やれることが大幅に広がります。根底から入れれば全体のプログラミングの世界観が（良くも悪くも）大きく変わります。が、まぁそれはエキセントリックすぎるということであれば、触りは単純なところからでも全然アリかな、とは。思います。特に非同期/マルチスレッド関連は、変なライブラリ入れるよりもずっと良いでしょう。</p>
<p>ところで半年前、今年6月に<a href="http://neue.cc/2015/06/20_514.html">第一回UniRx勉強会を開催しました</a>が、第二回の需要ってありますか？もしありましたら、その前に発表者が必要！なので、是非話したい！人は、私のTwitterかメールかに連絡ください。開催するにも発表者いなければ開催もなにもないですからね……！</p>
<p>ついでにもはや触れちゃいけない扱いの気がしなくもない<a href="http://asecon.unity3d.jp/">Unity アセットコンテスト</a>というのに応募していたのですが結果発表……。</p>
</div>
<h1><a href="https://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a></h1>
<ul class="date"><li>2015-12-13</li></ul>
<div class="entry_body"><p>Advent Calendar大遅刻組です。というわけで<a href="http://qiita.com/advent-calendar/2015/csharp">C# Advent Calendar 2015</a>の10日目です！なんで遅刻したかというと、記事のネタのためのライブラリを作るのに思いの外時間がかかってしまったから…… コンセプトも固まってたしプロト実装も済んでたんですが、最終的な形に落としこむのが想定よりちょっと割と大変だった……。すびばせんすびばせん。</p>
<p>どうやらC# Advent Calendarは2011年から書いてるので5回目ですね、へぇー。過去を振り返ると<a href="http://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a>、モダンつってもC# 4.0時代ですが、今ぱっと見直すと別にここで言ってることは今も変わらないですね、これに5.0, 6.0の話を足せばいいだけの話で。2012年は<a href="http://neue.cc/2012/12/03_389.html">MemcachedTranscoder - C#のMemcached用シリアライザライブラリ</a>ということで、このライブラリは別に私自身も使ってないので割とどうでもいー、んですが、まぁシリアライザにまつわる諸々についての知見が少しは入ってる模様。2013年の<a href="http://neue.cc/2013/12/04_435.html">非同期時代のLINQ</a>はいい話だなー、これがC# 5.0のModern Styleの追記差分みたいなもので、実際、今現在においては超絶大事な部分。2014年は<a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a>で、C# 6.0ではないですが、その世代ではAnalyzerは中心になってくるので、これがC# 6.0の差分といってもいいでしょう。多分きっと。</p>
<h2>Roslyn C# Scripting</h2>
<p>Roslyn、Compiler as a Serviceとか言ってましたが、やっぱスクリプティングが華形だと思うのです。が、しかし。が、しかし。今の今までRoslynに関する話題で、Scripting APIに関するお話はあまり上ってませんでした。理由は単純で、今の今まで未完成品だったから。先月末に出たVisual Studio 2015 Update 1でC# Interactiveが、そして同時にNuGetでも<a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting">Microsoft.CodeAnalysis.CSharp.Scripting</a>で、現在は1.1.1が配布されることにより（ところでこれのパッケージ名が中々定まらなくて実際これであってるのか不安だけどLast updatedが2015/12/3なのでこれでいいでしょう、まだDL数が405ですけど！）やっと全てのピースが揃った感じです。</p>
<p>Scriptingについてのドキュメントは、RoslynのWikiにある2つのページを見ておけば十分でしょう。<a href="https://github.com/dotnet/roslyn/wiki/Interactive-Window">Interactive-Window</a>には、csxの仕様っぽいもの、特殊なDirectiveの説明があります(#rとか#loadとか)。<a href="https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples">Scripting-API-Samples</a>にはプログラムから触った時のAPIとしてどんなものを持ってるか、どういう風に使えるかが書いてあります。かなりシンプルなので、そんな難しくなくすぐ使えます。</p>
<p>ちなみにC# Interactiveはまだまだ全然使えないって感じなので、期待するほどのものでもないですね。csxもエディタサポートが実質、シンタックスハイライトぐらいなので厳すぃ。黙って<a href="https://www.linqpad.net/">LINQPad</a>使いましょう、課金しましょう。</p>
<h2>Roslyn時代のコンフィグ</h2>
<p>最近というか数年前からずっと構造化ログにご執心で、<a href="http://neue.cc/2015/11/03_520.html">EtwStream - ETW/EventSourceのRx化 + ビューアーとしてのLINQPad統合</a>というのを作ってたんですが、今回はそれに、ファイル等への出力プラグイン(Sink)と外部サービス(EtwStream.Service)を作りました。アプリケーションから出力されるログは、ETWというWindows内部に流れてる高速なロギングストリーム機構を通して、別プロセスのEtwStream.Serviceで受け取ります。ログは特に最近ではファイル出力など比較的安定性が保証されているものだけでなく、ネットワークを通じて配信するケースも少なくありません。ログの扱いが別プロセスに別れることにより、アプリケーションに与える影響が少なくなるほか、アプリケーションの状態(アプリ自体の終了/デプロイでの入れ替わり等)に気を配る必要もなくなります。</p>
<p>というのが外部サービスであることの意義なのですが、問題はコンフィグです。コンフィグ。元々EtwStreamはObservableEventListenerという、IObservble&lt;LogEvent&gt;の形でログをストリームで受け取り、それをRxで自由にフィルタしたりグルーピングしたりマージしたりなんでも出来ますよね、という究極の自由度がウリでした。しかしコンフィグです、Rxのその柔軟性をコンフィグで実現するのは不可能です。物凄く機能を削った単純なSubscribeで我慢するか、あるいは超絶複雑なXMLでそれっぽいものを構築するか(log4netやNLogのXMLコンフィグが死ぬほど難解で複雑なのは、ログのルーティング自体が複雑で、それをコンフィグで表現することが困難だということなのです）になります。</p>
<p>せっかく、ログを現代的なReactive Extensionで表現することができたのに、外部サービスにした途端に破棄しなければならないのか。それでいいわけがなく、そこでC# Scriptingの出番になります。EtwStream.Serviceはコンフィグをconfiguration.csxとして、以下のように書きます。</p>
<pre><code class="language-csharp">// configuration.csx

// 5秒 or 1000件でバッファリング(ふつーのRxのBufferを利用)
// 出力フォーマットは普通にFunc&lt;TraceEvent, string&gt;で整形できる！
ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
    .Buffer(TimeSpan.FromSeconds(5), 1000, EtwStreamService.TerminateToken)
    .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
    .AddTo(EtwStreamService.Container);
</code></pre>
<p>基本的に完全にC#そのものなので、全てのRxのメソッドが使えて自由に合成・ルーティングが可能です。これはIn-Processで書いてる際（普通のロガーとしてC#コードで埋め込む場合）もOut-Of-Process Serviceでコンフィグとして書く場合も（ほぼ）同じコードで表現できるということです。もちろんC#で書けるということは、 System.Configuration.ConfigurationManager.AppSettings から設定を引っ張ってきたり、ネットワーク通信して何か引っ張ってきたりとかも自由自在やりたいほーだいです。</p>
<p>例えばこれをNLogで表現すると</p>
<pre><code class="language-xml">&lt;targets&gt;
    &lt;default-wrapper xsi:type=&quot;BufferingWrapper&quot; bufferSize=&quot;1000&quot; flushTimeout=&quot;5000&quot; /&gt;
    &lt;target name=&quot;file&quot; xsi:type=&quot;File&quot; fileName=&quot;log.txt&quot; keepFileOpen=&quot;true&quot;
		layout=&quot;[${date:format=yyyy/MM/dd hh\:mm\:ss}][${level}]${message}&quot; /&gt;
&lt;/targets&gt;
&lt;rules&gt;
    &lt;logger name=&quot;*&quot; minlevel=&quot;Debug&quot; writeTo=&quot;file&quot; /&gt;
&lt;/rules&gt;
</code></pre>
<p>になります。NLogの独自フォーマットルールに従って書く必要があるし、メッセージ書式も独自テンプレートになります。とはいえ、これはまだ単体なので遥かにマシで、色々複合的なことをやろうとするとすぐに膨れ上がって意味不明なことになるのは、みんな経験のあることなのではないでしょうか？</p>
<p>バイナリが<a href="https://github.com/neuecc/EtwStream/releases/tag/EtwStream.Service">EtwStream/releases/EtwStream.Service</a>に転がってるので、是非ちょっとだけ遊んでみてくださいな。</p>
<h2>仕組み</h2>
<p>csxをEvaluateしてるだけです。基本的にcsxの実行は即座に終わります、ObservableEventListenerをSubscribeしているだけですから。しかし、csxが終了してもSubscribeは生き続けています！（言われてみると当たり前のようで、最初はそうなの？と違和感はありました）。それにより、流れてくるログは（別スレッド上の)ObservableEventListenerを流れて、csx上のRxを通りcsx上でのSubscribeにより処理され続けます。というわけで、EtwStream.Serviceのcsxは、ただのXMLコンフィグがcsxに変わっただけ、ではなく、このcsxはコンフィグのようでコンフィグじゃなく、実行コードそのものなのです！</p>
<p>終了処理に関しては、ホスト側から渡しているTerminateTokenと、AddToを通してSubscriptionを登録していることにより制御されています。csxの評価としての実行が終わっていても、裏で生き続けている限り同じ参照を持っているので、ホスト側から干渉することが可能です。なので、ServiceのStopイベント時にはTerminateTokenにCancel命令をホストが出すことにより、Rxの残ってるBufferが送り出され、AddToで受け取っているSubscriptionを待つことにより、溜まったログの処理が完了するまで待機するといった、安全な終了処理を可能にしています。この辺はRxをフル活用してパイプライン組んだ成果ということで。</p>
<h2>再びエディタとしてのLINQPad</h2>
<p>さて、csxで書けるところのイイトコロはC#なのでコンパイルエラーも検出できるしシンタックスハイライトもあるし、などなど、なのですが、エディタサポートは……。Visual Studio 2015のUpdate 1によって確かにシンタックスハイライトはついた、が、それだけ……。IntelliSenseもDLL読み込ませたり色々しなければなので実質使えないみたいなもので厳しい……。</p>
<p>そこで出てくるのがLINQPad。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11766813/037c7376-a1db-11e5-9f74-8b4aeec20c5b.png" alt="image" /></p>
<p>EtwStream.LINQPadには、EtwStream.Serviceのcsxで渡されてくるEtwStreamServiceクラスのShim成分が入っているので、csxと互換性があって、LINQPadで実際にコンパイルできる/動かして確認した結果をcsxに持っていくことが可能です。（というようなことが出来るようにAPIを調整したんです……）。C# Interactiveが使い物にならならいなら使い物になるまで我慢する、のではなくて、一時凌ぎでもなんでも、他の現実的な解法を探すのが正すぃ。クソだクソだと文句だけ言ってても何も動きませんしね。必要なのは今この場でどうするか、それだけ。</p>
<h2>Topshelf</h2>
<p>Windowsサービスの実装には<a href="https://github.com/Topshelf/Topshelf">Topshelf</a>というライブラリを用いています。これは、最高に良いです。もはやこれなしでWindowsサービスを実装するのは考えられません！Visual Studioのテンプレートからふつーにサービスを作ると、なんかゴチャゴチャしたのが吐かれてよくわからない上に実行も面倒だし（いちいちinstallしたくないでしょ？）デバッグも困難だし、実にヤバい最低な開発環境。Topshelfで作るとコンソールアプリケーションと同じ感覚で作れます。また、成果物のexeは、そのまんまふつーにコンソールアプリケーションとしても動くので、EtwStream.Serviceの場合、ビューアーとしてLINQPadを要求していましたが、EtwStream.Service.exeを実行すれば普通にビューアーになります(csxで書き出し先をConsole(LogToConsole)にすれば色分けもしてくれる）。サービスとしてのインストールは「install」をつけて実行するだけ。素晴らしい。</p>
<p>日本語では<a href="https://84zume.wordpress.com/2014/03/23/topshelf/">Windowsサービスを楽に開発～TopShelf～</a>や<a href="http://tech.guitarrapc.com/entry/2015/05/13/015406">TopShelf によるWindowsサービスの配置をDSCで自動化してみよう</a>に説明ありますが、本当に簡単なので、サービスを作る機会がある人は是非使ってみてください。超お薦め。</p>
<h2>ファイル出力時のロガーのパフォーマンス</h2>
<p>今回ロガーを全部自作する都合上、さすがに単純なファイル書き出しと、ローテーションするファイル書き出しは用意しとかないとなぁ、ということで作ったんですが(FileSink, RollingFileSink)、作ってる上でなんとなく気づいたことなど。</p>
<p>そもそもファイルに吐くっていうこと自体がレガスィーで好きじゃないんですが、それはそれとしてもやはり重要なのは間違いありませんし、普通に使います。で、特にInProcessでのロギングの場合、これに気を配らないと普通にパフォーマンス上のボトルネックになってしまったりするわけですねー。さて、で、パフォーマンスは設定が全てです。とりあえず、バッファリングと非同期の二つのオプションを探しましょう。まず、ファイルに吐く場合のパフォーマンスはバッファするかしないかで全く変わるし、逆にバッファさえすればよほどタコな実装じゃない限りはそんな差はなくふつーに性能出ます（多分）。もう一点はasyncですね、これは別に大抵は非同期I/Oじゃなくて別スレッドで書くってだけのパターンなんですが、これが有効だとロガーの動作がアプリケーション自体に一切影響しなくなりますので。まぁバッファを有効にしてれば、例えば1000件に一回書く設定だったら1/1000回以外は書き込み処理に時間喰われることはなくなるので、ほぼ無視できてあってもなくても大差なくなるんですが、（起こるかもしれない）ちょっとしたスパイクは抑制できるかもしれません。また、あえてバッファはオフにしてasyncだけオン（+即時Flush)にすれば、ログが中々Flushされなくてリアルタイムで確認したいのにイライラ、というのがなくなって良いかもしれません。この辺は好みとか要件しだいで。</p>
<p>とりあえず言えるのはデフォの設定がどうなってるかはともかく、ノーバッファでノーエーシンクだと当然のように遅いです。更に設定によってはファイルストリームを都度閉じるか開きっぱがオプションになってるものもありますが、これは当然、開きっぱじゃないとゲロ遅いです。そういう項目がオプションにある場合は注意しましょう。デフォが都度閉じるだったりしてね……(NLogがそうです。NLogのデフォルトは安全寄りに倒し過ぎでパフォーマンスがヤヴァいことになってるので、NLog使う場合はそれなりに弄ったほうがいいでしょう。かといって他のロガーもそう変わりはなくて、大抵はそれなりに弄らないと遅いです）</p>
<p>かわりに、バッファや非同期ってのはログの消失の危険性があります。書いた瞬間には保存されてないってことですからね、アプリケーション終了への耐性が低くなります。気の利いたロガーは、可能な限り、終了を検知して(AppDomainが消える時のイベントとかをハンドリングして)、残ってるバッファを出力しに行ったり非同期の終了を待機しに行ってくれたりはしますが、パーフェクトではありません。例えば<a href="https://msdn.microsoft.com/en-us/library/system.appdomain.processexit.aspx">AppDomain.ProcessExit</a>のタイムアウトは既定で2秒です。2秒以内にフラッシュが完了する保証はないわけで、そこで完了できなければログロストです。</p>
<p>それを避けるには、「パフォーマンス低下を承知してバッファや非同期オプションを使わない」というのも手ですが、EtwStreamは更に2つの選択肢を提供してます。一つは「Out-Of-Process Serviceでのログ収集」。ETWへのログ出力はほぼノーコストで即時に吐けるのでアプリケーションへの影響は一切無い上に、それを外部サービスで取り出せば、出力側の終了の影響を全く受けません。ただし当然、受け取る側の外部サービスが死んだらロストするという危険性はありますがね！そこに関しては知らんがなというかshoganaiというか精一杯堅牢性を高めますとしか言い様がないですにぇ。</p>
<p>もう一つは、プログラム的に終了が完全に待機できるSubscriptionシステム。もともとEtwStreamは設定をC#で、Rxで書く必要があるので、購読状態に関して100%コントロールできます。というわけでその辺に仕掛けを入れといて</p>
<pre><code class="language-csharp">static void Main()
{
    // ApplicationStartの部分でこの2つを用意する
    var cts = new CancellationTokenSource();
    var container = new SubscriptionContainer();
    
    // でログの設定する
    ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
        .Buffer(TimeSpan.FromSeconds(5), 1000, cts.Token)
        .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
        .AddTo(container);
        
    // --- 実際にアプリが動いてる部分 --- //
        
    // アプリが終了した時のイベントのところでハンドリングする(Form_ClosedでもApplication_Endでもなんでもいいですが)
    cts.Cancel(); // CancellationTokenのCancelによりBufferの残りが吐き出される
    container.Dispose(); // Subscriptionの完了を待機する
}
</code></pre>
<p>といった風にすれば、100%コントロールされて停止時のログ処理を完了させられます。csxでもEtwStreamService.TerminateTokenとか渡していたのと同じことをやればいいということで。</p>
<p>100%コントロールできる代わりに、逆にEtwStreamは自分でコントロールしないかぎりは、気の利いた終了の検知とか組み込んでないので、待たなければふつーにバッファは消えます。これに関しては、10年前はゴテゴテとブラックボックスの中で気の利いたことをしてくれるのが正義だったかもしれませんが、2015年の現代では仕組みはシンプルに、薄くしたうえで、自分でコントロールさせるのが正義だと思ってます。そういう流儀。どっちが正しいってこともないですが、まぁ、今風なんじゃないかな？</p>
<p>ついでに言えば、EtwStreamのFileSinkやRollingFileSinkのパフォーマンスはバッファしてる前提同士で比較しても、他のよりも高い性能を誇ります。理由は幾つかあって、そもそも性能を意識して書いてるから。というのと、.NET 4.6以外をサポートする気がないのでasync/awaitやTPL全開でコードを書いてるから。オプション自体も同期処理は一切なくて、書き出しは非同期I/Oのみに限定などの割り切り。そして、通常はログフォーマット整形などに独自テンプレート的なのを挟まなきゃいけないところを、csxのお陰でFuncで処理できるため、そもそもコードパスに一切のオーバーヘッドがない。C# Scriptingによるコンフィグはパフォーマンスにも寄与するわけです。</p>
<p>しかしまぁ、Javaでは<a href="https://github.com/Netflix/blitz4j/wiki/Blitz4j-at-a-glance">Blitz4j</a>や<a href="http://logging.apache.org/log4j/2.x/manual/async.html">log4j2のAsynchronous Logger</a>などのスピード競争があるのに、.NETの牧歌的なこと、といった感じは否めませんねぇ。そんなだから私のとりあえずの雑実装でもfastestになってしまうわけで……。</p>
<h2>出力先</h2>
<p>EtwStreamが提唱するのは構造化ログ(Structured/Semantic Log)ですし、テキストログが終着点ではありません！テキストログは無視して、構造化されたペイロードを、そのまま<a href="https://azure.microsoft.com/ja-jp/services/event-hubs/">Azure EventHubs</a>や<a href="https://aws.amazon.com/jp/kinesis/">Amazon Kinesis</a>、<a href="https://cloud.google.com/bigquery/">Google BigQueryのStreaming Insert</a>に流して、ただたんに溜めるのではなくて、即座に分析可能な状態にするのが理想形です。特にお薦めなのは、というか弊社で使ってるのはGoogle BigQueryです。事例として<a href="http://googlecloudplatform-japan.blogspot.jp/2015/12/google-cloud-platform-using-csharp.html">株式会社グラニの Google Cloud Platform 導入事例: 「using CSharp;」という軸と BigQuery の活用で、先進性を求め続ける。</a>を掲載してもらいました:)</p>
<p>今のとこEtwStream用のBigQuerySinkはないんですが（！）そのうち公開するかされるかするんじゃないでしょーか多分きっと。（本当はそれも作って持ってきたかったんですがもう完全に時間切れでして、すでに大遅刻だし……）。そういえばあとFromTraceEventでRegisteredTraceEventが取れるようになりました。これはつい数日前のTraceEventライブラリのアップデートでそうなったから、というだけなんですが、今まで取れてなかったんですよねー。これで大丈夫。というのと、SLABのOut-of-Process Serviceじゃダメな理由に.NET 4.6からEventSourceに追加されたself-describing events（超重要！）に対応してないとか色々あるんですが、そういった話はまたの機会にでも。</p>
<h2>まとめ</h2>
<p>ロガーの未来はこうあるべきだ、という構想自体は1年以上前からあったんですが、Roslyn C# Scripting APIが正式リリースされてやっと作れた！あと、基本的にはMicrosoft Patterns &amp; Practicesの<a href="https://github.com/mspnp/semantic-logging">Semantic Logging Application Block(SLAB)</a>の影響が濃くはあるんですが、更新されなすぎだし、v3はElastic Search + LogStash + Kibana on Azureとか言ってて、マジで終わってるなという感じでもはや見限るしかない……。P&amp;Pは相変わらず本当にやっぱダメですねーという残念さ加減。なにがPatterns &amp; Practicesだよっていう。</p>
<p>csxでコンフィグするライブラリとして<a href="https://github.com/config-r/config-r">ConfigR</a>というのがあるんですが、XMLをcsxで置き換えるだけじゃ、あんま意味がないかな。必要なのは、コンフィグができることじゃなくて、それそのものが実行されて自走することだというのに気づいたので、使うことはなかったし、多分他のアプリケーションでもConfigRを使うことはないと思います。XMLはいうて設定ファイルとしては悪くないんですよねー、XSLTなんかもやり過ぎなければ良い機構ですし。逆にJSONを設定ファイルとして使うのは最低最悪なチョイス(なのでDNXへのやる気が0.1ミリも起きない)</p>
<p>何れにせよ、徐々にではあるでしょうが、csxの面白い活用例というのはどんどん出てくるのではないかと思います、と言いたいんですがfsxが別に対して面白い活用はされてないことを考えるとそんなに出てこないかもしれませんね、とも思いますが、いえいや面白い活用例はやっぱ出てくるかもしれません。batをcsxにしましたとかってだけだと別に面白くもないし意味もそんなにないですからねー、まぁあってもいいけど。もっと本質的に変わるような事例が増えてくれれば何よりです。</p>
</div>
<a href="https://neue.cc/5">Prev |</a>
<a href="https://neue.cc/7">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2023<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
