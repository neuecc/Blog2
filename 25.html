<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2009-10-05" data-pagefind-meta="published:2009-10-05"><a href="https://neue.cc/2009/10/05_207.html">ラムダ式の引数の名前</a></h1>
<ul class="date"><li>2009-10-05</li></ul>
<div class="entry_body"><p>Linqもそうですが、Linq意外でもFuncやActionのお陰様でラムダ式を渡しまくりな昨今。そうなるとちょろっとした引数の名前付けが面倒くさかったりします。ので、大抵は一文字で済ませるわけです。一文字ってどうなのよ、よくないんじゃないの？というと、ラムダ式のような極端にスコープが短いものは、しっかりした名前がついているもののほうが逆に見づらかったりするので、一文字でいいと思います。面倒くさいからって全て_だの__だので済ませると見づらいので一文字はなるべく死守します。但し引数を利用しない場合は_を使います。ネストしたり、式じゃなくて文になる場合はしっかりした名前を付けます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">a // AnonymousType
i // int
s // string
c // char
d // datetime
g // IGrouping
t // Type
e(ex) // exception
e(elem) // XElement
e(ev) // event
e(ie) // IEnumerable(あんま使わないですが)
ar // array(IEnumerableの時もこれ使ったりする(適当))
ar // IAsyncResult(うわ、被っとる)
fs // fileSystemとかラクダの頭文字を繋げる
x // 適当なのがない場合とか、x =&gt; xとか
xs // arrayやらIEnumerableやらどっちでもいー、とヤケクソな時
_ // 引数を式中で利用しない場合
</code></pre>
<p>大抵は型の頭文字一つです。AnonymousTypeは、前はtを使ってたんですが、IntelliSenseで出てくるのが'aだし、世間的にもaが主流だしTypeと紛らわしいので、最近はaで書くようにしています。Aggregateなんかは(a,b)=&gt;って昔は書いていたのですが、aが匿名型なので紛らわしいから、(x,y)=&gt;と書くようにしています。徹底はしてません。適当です。</p>
<p>それにしてもeの被りっぷりは酷い。こうなると、不人気頭文字を使いたい。というわけで、ライブラリからTypeの頭文字を取得してみる。アセンブリの取得部分は<a href="http://d.hatena.ne.jp/siokoshou/20090817#p1" title="2009-08-17 - 当面C#と.NETな記録">2009-08-17 - 当面C#と.NETな記録</a>のコードをお借りしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// asmNamesは http://d.hatena.ne.jp/siokoshou/20090817#p1 から
// Groupingをバラしているのは、デバッガで中身を見る時にかったるかったから
var list = asmNames
    .SelectMany(s =&gt; Assembly.LoadWithPartialName(s).GetExportedTypes())
    .Select(t =&gt; t.Name)
    .GroupBy(s =&gt; s.First())
    .OrderBy(g =&gt; g.Key)
    .Select(g =&gt; new { Key = g.Key, Types = g.ToArray() })
    .ToList();
list.ForEach(a =&gt; Console.WriteLine(&quot;{0} : {1}&quot;, a.Key, a.Types.Length));

A : 319
B : 252
C : 773
D : 715
E : 275
F : 263
G : 172
H : 264
I : 887
J : 14
K : 58
L : 249
M : 424
N : 140
O : 189
P : 526
Q : 31
R : 312
S : 1039
T : 644
U : 169
V : 118
W : 272
X : 372
Z : 7
_ : 32
</code></pre>
<p>IはInterfaceだから数が多いのはしょうがない。Zは当然としてJ, K, Qは不人気ワードなので狙いどころですね！そしてSは人気あり過ぎ、と。別に考察でも何でもないです、すみません。CamelCaseを短縮結合して、一文字の場合のみを取り上げたら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// SplitCamelWordはasmNamesと同じくsiokoshouさんのコードから
.Select(t =&gt; SplitCamelWord(t.Name).Aggregate(&quot;&quot;, (x, y) =&gt; x + y.First(), s =&gt; s.ToLower()))
.Where(s =&gt; s.Length == 1)
</code></pre>
<p>ちゃんと(?)、eが一番人気でした。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-30" data-pagefind-meta="published:2009-09-30"><a href="https://neue.cc/2009/09/30_206.html">C# Linqでクイックソート</a></h1>
<ul class="date"><li>2009-09-30</li></ul>
<div class="entry_body"><pre data-pagefind-ignore="all"><code class="language-haskell">qsort []     = []
qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
                 where
                   elts_lt_x   = [y | y &lt;- xs, y &lt; x]
                   elts_greq_x = [y | y &lt;- xs, y &gt;= x]
</code></pre>
<p>これはHaskellのコードで、良く見かける定番のQuickSort。うん、短い。というわけでLinqでそれをやる。というネタは既出のン番煎じなのですが、気にせずやる。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// LinqでHaskell風のクイックソート
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    return source
        .GroupBy(x =&gt; x.CompareTo(pivot))
        .OrderBy(g =&gt; g.Key) // OrderBy使うのはどうかなー、というところはある
        .SelectMany(g =&gt; (g.Key == 0) ? g : QuickSort(g));
}
</code></pre>
<p>GroupBy-&gt;SelectManyと流れるように書けて美しいー。これならHaskellにも引けを取らないですね！但し問題なのは、OrderByを使用しているところ。CompareToの結果である-1, 0, 1を並べ替えるために使っているのだけど、OrderByの中身はシュワルツ変換の挟まったクイックソートそのものなので邪道な感は否めない。OrderBy使うなら、そもそもsource.OrderBy(x =&gt; x)でもいいぢゃん、って話になってしまう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 非GroupBy版。LookupはGroupByの即時評価版と考えていい。
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    var lookup = source.ToLookup(x =&gt; x.CompareTo(pivot));
    return QuickSort(lookup[-1]).Concat(lookup[0]).Concat(QuickSort(lookup[1]));
}
</code></pre>
<p>GroupByをToLookupに書き変えました。ToLookupはGroupByの即時評価版といった感じで、インデクサによるアクセスが可能。インデクサ使わないでそのままforeachで列挙する、なんて時はGroupByを使った方が良いです。今回はインデクサで順番を明示的に指定するため、ToLookupでパーティション切って、Concatで繋いでやれば出来あがり。やってることが非常に分かりやすくて良い。ソースの見た目も中々綺麗じゃないでしょうか。Haskellのものとも非常に近いです(ようするに++がConcatなので) ToLookupではなくWhereを使えば、見た目は更にHaskellに近づきますが、列挙が二回になるので、ここはToLookupで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 普通に？書いた場合。
public static void QuickSort&lt;T&gt;(IList&lt;T&gt; source, int lowerBound, int upperBound)
    where T : IComparable&lt;T&gt;
{
    var pivot = source[lowerBound + ((upperBound - lowerBound) &gt;&gt; 1)];
    var left = lowerBound - 1;
    var right = upperBound + 1;
    while (true)
    {
        while (source[++left].CompareTo(pivot) &lt; 0) ;
        while (source[--right].CompareTo(pivot) &gt; 0) ;
        if (left &gt;= right) break;
        var temp = source[left];
        source[left] = source[right];
        source[right] = temp;
    }
    if (lowerBound &lt; left - 1) QuickSort(source, lowerBound, left - 1);
    if (right + 1 &lt; upperBound) QuickSort(source, right + 1, upperBound);
}
</code></pre>
<p>今度は非Linqに一般的？な書き方で。あまりヘタな書き方するとアレだなあ、と思ったので<a href="http://blog.livedoor.jp/dankogai/archives/51182235.html">404 Blog Not Found:javascript - Array#sortはオレquicksortより遅い by Chrome</a>のコードをC#に移植しました。<a href="http://dic.nicovideo.jp/a/%E3%81%82%E3%81%9F%E3%81%97%E3%81%93%E3%81%AE%E3%83%91%E3%82%A4%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%82%88%E3%81%AD">あたしこの書き方嫌いなのよね</a>、という感じにゴチャゴチャした印象は否めないというか、まあ、嫌いなのよね。一本の配列で頑張るところが、ゆとりな私としてはしんどい。ビットシフトも嫌よね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    var enumerator = source.GetEnumerator();
    if (!enumerator.MoveNext()) yield break;

    var pivot = enumerator.Current;
    var less = new List&lt;T&gt;();
    var equal = new List&lt;T&gt;();
    var greater = new List&lt;T&gt;();
    do
    {
        switch (enumerator.Current.CompareTo(pivot))
        {
            case -1: less.Add(enumerator.Current); break;
            case 0: equal.Add(enumerator.Current); break;
            case 1: greater.Add(enumerator.Current); break;
        }
    } while (enumerator.MoveNext());

    foreach (var item in QuickSort(less)) yield return item;
    foreach (var item in equal) yield return item;
    foreach (var item in QuickSort(greater)) yield return item;
}
</code></pre>
<p>最後に、非Linqで、ToLookup版を再現してみたものを。do-whileがToLookupでforeachの連発がConcat。ようするに富豪的にListを作りまくるってわけなんですね！書きやすいし分かりやすいので、一本配列版よりも遥かに好き度高い。現代人はListを贅沢に大量に好きなだけ使うのです。まあ、Linq版がない状態でこの書き方が浮かぶ or 実行に移せるかどうかといったら、かなり無理ですけど。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-28" data-pagefind-meta="published:2009-09-28"><a href="https://neue.cc/2009/09/28_205.html">.NET Reactive Framework メソッド探訪第五回:Scan</a></h1>
<ul class="date"><li>2009-09-28</li></ul>
<div class="entry_body"><p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var random = new Random();
Func&lt;byte&gt; nextByte = () =&gt; (byte)random.Next(0, byte.MaxValue + 1);

// CenterEllipseは真ん中の円のこと。
// 1000秒以内に3回クリックするとランダムで色が変わる
// GetMultiClickScan関数が今回の主題で、解説は後で。
CenterEllipse.GetMultiClickScan(3, 1000).Subscribe(() =&gt;
    CenterEllipse.Fill = new SolidColorBrush(Color.FromArgb(255, nextByte(), nextByte(), nextByte())));
</code></pre>
<p>円を1秒以内にトリプルクリックすると色が変わります。右側のログ表示はミリセカンド単位でトリプルクリック時の経過時間を表しています。つまり、これが1000以内ならば色が変わり、1000より上ならば色は変わりません。このサンプルのテーマは、トリプルクリックの検出です。トリプルだけではなく、クアドラプルでもクインタプルでも、1秒以内じゃなくて5秒でも10秒でも応用できる形で書くとしたら、どう書く？ グローバル変数に、クリックイベントを格納する配列でも置くかしらん。それがきっと簡単で分かりやすくて、でも……。</p>
<p>今回はRx Frameworkの関数から、Scanを取り上げます。この例題は私が考えたわけではなく、<a href="http://blogs.msdn.com/jeffva/archive/2009/08/14/my-solutions-to-the-reactive-framework-tripple-click-puzzle.aspx">Ramblings of a Lazy Coder : My solutions to the Reactive Framework Tripple-click puzzle</a>という問題からです。URLリンク先は解答編、というわけで、この解答を解説します。</p>
<p>考え方としては、クリックイベントに「クリックされた時間」という情報を付加。更に、クリック回数分の「前のデータ」を参照して指定時間内で連続クリックかどうかを確認する。時間情報の付加は匿名型を作るだけなので簡単ですが、「前のデータ」を参照するのが厄介。Linqは前にしか進まないし、送られてくるデータは過去のものなど知らない。このことはReactive Frameworkだけの話ではなく、以前にも<a href="http://neue.cc/2009/03/06_138.html">LINQで左外部自己結合</a>や<a href="http://neue.cc/2009/03/16_141.html">Scan?</a>という記事で書きましたが、そこで出てくる解決策がScan。そうそう、ScanはAchiralにあるので(ということでlinq.jsにもあります)、動作は分かってます。ようするにAggregateの計算過程吐きだし版です。とりあえず<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>でE.Range(1,10).Scan(&quot;x,y=&gt;x+y&quot;)と打ってみてください(宣伝宣伝)</p>
<p>Scanならば「一個前」の情報が手に入る。しかし「複数個前」の情報はどうすれば？ 答えは配列使えばいいぢゃない。だそうです。過程のデータをとりあえず配列に入れて、次に送り出してやれば、そりゃ簡単に取り出せますね。何だか邪道な気がしますが、気にしない気にしない。URL先の解答例では生の配列を使って、インデックスをゴニャゴニャとしていて非常に正しいとは思いますが、あまり生の配列のインデックスは扱いたくないので、Queueを使ってみました。別にQueueのClear()のコストなんてたかが知れてるっしょ(中ではArray.Clearを呼んでいて、Array.Clearは……以下略)という割り切りで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IObservable&lt;MouseButtonEventArgs&gt; GetMultiClickScan
    (this UIElement element, int count, int multiClickSpeedInMilliSeconds)
{
    return Observable.FromEvent&lt;MouseButtonEventArgs&gt;(element, &quot;MouseLeftButtonDown&quot;)
        .Select(e =&gt; e.EventArgs)
        .Scan(new
        {
            Times = new Queue&lt;DateTime&gt;(count),
            Hit = false,
            Event = (MouseButtonEventArgs)null // ダミーなのでnullをキャストするのが楽
        }, (a, e) =&gt;
        {
            var isHit = false;
            var now = DateTime.Now;
            a.Times.Enqueue(now);
            if (a.Times.Count == count)
            {
                var first = a.Times.Dequeue();
                Debug.WriteLine((now - first).TotalMilliseconds); // Debug
                if ((now - first).TotalMilliseconds &lt;= multiClickSpeedInMilliSeconds)
                {
                    isHit = true;
                    a.Times.Clear();
                }
            }

            return new
            {
                Times = a.Times,
                Hit = isHit,
                Event = e
            };
        })
        .Where(a =&gt; a.Hit)
        .Select(a =&gt; a.Event);
}
</code></pre>
<p>ScanはAggregateと全く同じで、accumlatorのみの実行の他に、第一引数でseedを渡すこともできます。Scanのseedで、変数と判定を行うためのフラグを保持するクラスを作り、accumlatorで判定と変数の持ち越しを行い、Whereで判定をフィルタリング。このコンボは非常に強力で、幾らでも応用が効きそう。LinqでのAggregateはほとんど使われませんが、RxにおけるScanはよく見かけることになるのではないかと思います。</p>
<p>で、理屈は分かったけれど、何だかゴチャゴチャとしてない？ という感想は否めない。ただ、グローバル領域に変数を置く必要なくフラグを閉じ込められていること、そして、応用の効きそうな柔らかさが見えたり見えなかったりしませんか？ 応用的なものも、追々考えていきたいです。</p>
<h2>次元の狭間へ</h2>
<p>Scanが出たので、Aggregateもついでにおさらい。これはLinq to ObjectsのAggregateと変わりません。ちなみにRx Frameworkでの内部実装はScan().Last()だったりするので、Scanとほんとーに丸っきり変わりません。じゃあ、無限リピートのFromEventにたいしてAggregateって、実行するとどうなるの？というのは気になるところですが、答えは次元の狭間に入ってしまって、その行からコードが一切進まなくなります。AggregateだけじゃなくCountやLast、ToEnumerableなど全てを列挙してから答えを返す系のメソッドは全て同じ結果になります。コンソールアプリの簡単なコードで試してみると、こうなる。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class MyClass
{
    public event EventHandler&lt;EventArgs&gt; Ev;

    public void Fire()
    {
        Ev(this, new EventArgs());
    }
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var count = Observable.FromEvent&lt;EventArgs&gt;(mc, &quot;Ev&quot;)
        .Count(); // ここで次元の狭間にダイブする

    mc.Fire(); // ここに到達することは未来永劫無い
}
</code></pre>
<p>恐ろしや。ただ、前段階でTakeやTakeWhileを挟めば、無限リストは有限リストとなるので、面白い感じに制限が出来ます。この辺も応用例として、そのうち紹介していければと思います。</p>
<h2>カウンター</h2>
<p>もう一度Scanを見ます。トリプルクリックの例題は捻りすぎな感が否めないので、もっとストレートに、Scanの「前の値を保持し続けることが出来る」という点を見せる例題を一つ。<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3" title="クロージャ - Wikipedia">クロージャの例</a>なんかでも定番のカウンターで。</p>
<p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="200px" height="50px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan_Counter.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.FromEvent&lt;RoutedEventArgs&gt;(CounterButton, &quot;Click&quot;)
    .Scan(0, (x, y) =&gt; ++x)
    .Subscribe(i =&gt; CounterButton.Content = i + &quot;Clicked&quot;);
</code></pre>
<p>とても簡潔で、変数が全て閉じ込められていて、綺麗……。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-25" data-pagefind-meta="published:2009-09-25"><a href="https://neue.cc/2009/09/25_204.html">Linqは美人</a></h1>
<ul class="date"><li>2009-09-25</li></ul>
<div class="entry_body"><pre data-pagefind-ignore="all"><code class="language-csharp">public class Stamp
{
    public int Year { get; set; }
    public string Name { get; set; }
    public Stamp(int year, string name) { this.Year = year; this.Name = name; }
    public override string ToString() { return this.Year + &quot;:&quot; + this.Name; }
}

public class StampCollection : IEnumerable&lt;Stamp&gt;
{
    private Dictionary&lt;string, Stamp&gt; stamps = new Dictionary&lt;string, Stamp&gt;();

    public void Add(Stamp s) { stamps.Add(s.Name, s); }
    public void Add(int year, string name) { stamps.Add(name, new Stamp(year, name)); }

    // yield returnを通さなくてもそのままreturn可能
    public IEnumerator&lt;Stamp&gt; GetEnumerator()
    {
        return stamps.Values.OrderBy(s =&gt; s.Year).GetEnumerator();
    }

    // GetEnumeratorと名乗りながらGetEnumeratorじゃないのが少しアレですね
    public IEnumerable&lt;Stamp&gt; GetEnumerator2()
    {
        return stamps.Values.OrderByDescending(s =&gt; s.Year);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}

// 利用時例
static void Main(string[] args)
{
    // コレクション初期化子は、複数引数時は更に{}で囲む
    var stamps = new StampCollection()
    {
        {1998, &quot;hoge1&quot;},
        {1999, &quot;hoge2&quot;},
        {2000, &quot;hoge3&quot;}
    };
    
    // GenericsにしておくとCast&lt;T&gt;を使わずLinqでコンボ出来る
    stamps.GetEnumerator2().Select(s =&gt; s.Name).ToList().ForEach(Console.WriteLine);
}
</code></pre>
<p><a href="http://d.hatena.ne.jp/cast_everything/20090924/1253786494" title="memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋">memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋</a>のものを少し書き換えました。コレクション初期化子と、yield returnせずにそのまま投げ返すように変えただけですが。Linqは美人。ですです。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-18" data-pagefind-meta="published:2009-09-18"><a href="https://neue.cc/2009/09/18_203.html">JavaScriptでString.Format的な超簡易テンプレート置換</a></h1>
<ul class="date"><li>2009-09-18</li></ul>
<div class="entry_body"><pre data-pagefind-ignore="all"><code class="language-javascript">// String.Format的な超簡易テンプレート置換関数
var Format = function(template, replacement)
{
    if (typeof replacement != &quot;object&quot;) // 可変長引数時はreplacementを詰め替え
    {
        replacement = Array.prototype.slice.call(arguments, 1);
    }
    return template.replace(/\{(.+?)\}/g, function(m, c)
    {
        return (replacement[c] != null) ? replacement[c] : m
    });
}

// 例。可変長引数渡しでも配列渡しでもオブジェクト渡しでも可。
var case1 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, &quot;あいでぃ&quot;, &quot;要素&quot;);
var case2 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, [&quot;あいでぃ&quot;, &quot;要素&quot;]);
var case3 = Format(&quot;&lt;div id={ID}&gt;{ELEM}&lt;/div&gt;&quot;, { ID: &quot;あいでぃ&quot;, ELEM: &quot;要素&quot; })
</code></pre>
<p>.NET FrameworkのString.Formatは文字を連結するのに、非常にお手軽で良いです。というわけでJavaScriptでもそれをやる。ついでにテンプレート置換風にオブジェクト渡しにも対応させる。単純な置換時は数字で、長ったらしい置換時はオブジェクトで。両方に対応させなければ、詰め替えが必要ないので正規表現でカカッと一行なんですねえ。詰め替えも別にslice.callで一発だし。<a href="http://neue.cc/2009/04/28_154.html" title="neue cc - JavaScriptでString.Format">以前にlinq.jsを絡めてgdgdとやってた</a>のですが、<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">二度もね！</a>、あんなにgdgdやらずとも、もんのすごーく単純明快に書ける。無理やり使おうとして、無駄に複雑になるのはイクない。</p>
<p>と、恥ずかしくなったので今回載せました。あと、JavaScriptは文字連結面倒くせー、って時にササッとコピペで取り出して使いたい時のために(笑) ちゃんとDateTime等も含めたフォーマット変換に対応させるとか、テンプレートだったらちゃんとテンプレートエンジンな感じでforやifも動くように、とかの話は知りません。</p>
<p>そういえば、置換部分の関数ですけど、最初は格好つけて「return replacement[c] || m」って書いたんですが、これだとマッチがハッシュ内に見つからなかった場合(undefinedになってる)だけでなく、 空文字列の場合もfalse扱いになってしまってダメなんですね。C#の??のように使いたいのですが、例えば数字だと「var i = 0 || 3」だったら3になるしで使いづらい。というわけで、結局==nullばかり使うことになる。===undefinedって書けって話でもありますが、まあ、==nullのほうが色々考えなくて済むから楽で。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-16" data-pagefind-meta="published:2009-09-16"><a href="https://neue.cc/2009/09/16_202.html">ログ吐き骨組み</a></h1>
<ul class="date"><li>2009-09-16</li></ul>
<div class="entry_body"><p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/LogBrowseBase.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>デモ大事。<a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">Subscribe</a>の時にConsole.WriteLine並べて、実行結果想像つきますよね、というのがいまひとつすぎたので、出力が見える骨組みを作りました。今後のReactive Frameworkの紹介時にソースコード上のDebug.WriteLineは、こーいうことなんですねー、と思ってください。毎回これ乗っけてると長ったらしいので、暗黙の、ということで。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;UserControl x:Class=&quot;SilverlightApplication4.MainPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; 
    mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;640&quot; d:DesignHeight=&quot;480&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition /&gt;
            &lt;ColumnDefinition Width=&quot;200&quot; /&gt;
        &lt;/Grid.ColumnDefinitions&gt;

        &lt;StackPanel Grid.Column=&quot;0&quot;&gt;
            &lt;Button Name=&quot;ExecuteButton&quot; Content=&quot;Execute&quot; /&gt;
            &lt;Button Name=&quot;ErrorButton&quot; Content=&quot;Error&quot; /&gt;
            &lt;Button Name=&quot;ObservableButton&quot; Content=&quot;Observable&quot; /&gt;
            &lt;Button Name=&quot;EnumerableButton&quot; Content=&quot;Enumerable&quot; /&gt;
        &lt;/StackPanel&gt;
        &lt;ScrollViewer Grid.Column=&quot;1&quot;&gt;
            &lt;TextBlock Name=&quot;LogBrowseTextBlock&quot;&gt;&lt;/TextBlock&gt;
        &lt;/ScrollViewer&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Reflection;

namespace SilverlightApplication4
{
    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();
            Debug.Set(LogBrowseTextBlock, Dispatcher);

            ExecuteButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10).Subscribe(
                    i =&gt; Debug.WriteLine(i),
                    e =&gt; Debug.WriteLine(e),
                    () =&gt; Debug.WriteLine(&quot;completed&quot;)
                )
            );

            ErrorButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10)
                    .Do(i =&gt; { if (i == 5) throw new Exception(); })
                    .Subscribe(
                        i =&gt; Debug.WriteLine(i),
                        e =&gt; Debug.WriteLine(&quot;onError&quot;),
                        () =&gt; Debug.WriteLine(&quot;onCompleted&quot;)
                    )
            );

            ObservableButton.GetClick().Subscribe(() =&gt;
                GetMethodNames(typeof(Observable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );

            EnumerableButton.GetClick().Subscribe(() =&gt;
                  GetMethodNames(typeof(Enumerable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );
        }

        IEnumerable&lt;string&gt; GetMethodNames(Type type)
        {
            return type.GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Select(mi =&gt; mi.Name)
                .OrderBy(s =&gt; s)
                .Distinct();
        }
    }

    public static class Debug
    {
        private static TextBlock textBlock;
        private static Dispatcher dispatcher;

        public static void Set(TextBlock textBlock, Dispatcher dispatcher)
        {
            Debug.textBlock = textBlock;
            Debug.dispatcher = dispatcher;
        }

        public static void WriteLine(object message)
        {
            if (textBlock != null)
            {
                dispatcher.BeginInvoke(() =&gt;
                    textBlock.Text = message.ToString() + Environment.NewLine + textBlock.Text);
            }
        }
    }

    public static class ControlExtensions
    {
        public static IObservable&lt;Event&lt;RoutedEventArgs&gt;&gt; GetClick(this ButtonBase button)
        {
            return Observable.FromEvent&lt;RoutedEventArgs&gt;(button, &quot;Click&quot;);
        }
    }
}
</code></pre>
<p>幾ら簡易的なものだから、という言い訳がましさを考えても、かなり微妙なコードな気がする。原型はWPFでTraceListenerにTextBlockに書きだすものを追加して、Trace.WriteLineで処理していたもの。SilverlightにはTraceがなかったので、そのまま静的クラス・メソッドに置き換えて、Silverlightにも本来あるDebugを塗り替えちゃうという……。ようするにそのままコピペしても動くよね！的な感じでやりたいな、というところなわけです。ダメ？</p>
<p>ついでにSubscribeの中でObservableって、汚い、ように見えるかも。でも実際これはなんてことなくて、ようはJavaScriptっぽいんですよね、ほんと。DOMContentLoadedにイベント登録のaddEventListener並べるのと一緒で。じゃあ実際こうしてグチャグチャ並べるかというとそうではないようで、実際は拡張メソッドへ記述する、という形で分散していくようですが、まだまだ分からず。Microsoft側の実例やドキュメントが整ってくれないと何とも言えない感じ。</p>
<h2>作業環境</h2>
<p class="noindent">
	<a href="http://neue.cc/wp-content/uploads/image/vsorig.jpg"><img src="http://neue.cc/wp-content/uploads/image/vsmin.jpg"></a>
</p>
<p>画像クリックで原寸サイズ。最近思うところあってVisual Studioの配置をごにょごにょと弄っています。今は、こんな感じに落ち着きました。左にエラー一覧・検索など。右にソリューションエクスプローラー・クラスビュー・スタートページなど。そして左右にそれぞれコードウィンドウを分割。原則的にメインウィンドウは左。コード定義ウィンドウを右ウィンドウに開いて常時表示。もしくはXAML編集と並列したり。といったところです。コード定義ウィンドウはデカい画面で常時表示で初めて効果を発揮しますね、素晴らしく便利。</p>
<p>30インチ 2560x1600の無駄遣いが火を吹く！というわけですが、やっぱ広いって便利、エディタウィンドウ2面同時表示って便利、です。30インチでなくても、横2560は19インチ1280x1024のデュアルで行けます。ただ、実際はこれに加えてデバッグ時のプログラム本体なりブラウザなりを置いておく場所が欲しいので、その場合はデュアルじゃ足りないですね……。グラフィックボードが一枚でトリプルをサポートしてくれれば、というか、するべき、ですよね。ATIの<a href="http://pc.watch.impress.co.jp/docs/news/20090911_315056.html" title="【PC Watch】 AMDが次世代GPUに搭載するマルチディスプレイ機能「Eyefinity」を披露">Eyefinity</a>にはとても期待してます。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-14" data-pagefind-meta="published:2009-09-14"><a href="https://neue.cc/2009/09/14_201.html">.NET Reactive Framework メソッド探訪第四回:メソッド一覧</a></h1>
<ul class="date"><li>2009-09-14</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">前回</a>が少し、明らかに説明不足でした……。Subscribeが原則としてIObserverを受ける(直接ラムダ式でonNextを記述するのはただの省略記法)ということは、IObserverを別に作っておける。もっと進めると、Subscribeで実行されるコード本体は自由に入れ替え可能。ということになります。ここが、イベント直記入に対するReactive Frameworkの強みの一つ。それ○○パターンだって？そうですね？その○○パターンがデフォルトで何も考えず使えるのならば、素晴らしいと思います。</p>
<p>では、ここからようやくメソッド探訪。の前に、全メソッド一覧を見てみます。IObservable&lt;T&gt;拡張メソッド一覧。そう、最初感動したのは、ドット打ってIntelliSenseに並んだこのメソッド名を見て、なのよね。いかにも素晴らしいことが出来そうな予感だったという。</p>
<pre data-pagefind-ignore="all"><code class="language-text">Aggregate
Amb
AsObservable
Catch
CombineLatest
Concat
Cons
Contains
Count
Create
Defer
Delay
Dispatch
Do
Empty
Finally
First
FirstOrDefault
Flatten
ForkJoin
FromEvent
Generate
GetEnumerator
HoldUntilChanged
Interval
Last
LastOrDefault
Latest
Let
LetRec
LongCount
Merge
MostRecent
Never
Next
Post
Range
Reify
Repeat
Retry
Return
Sample
Scan
Select
SelectMany
Send
Single
SingleOrDefault
Skip
SkipWhile
Spawn
Start
Subscribe
Synchronize
Take
TakeWhile
Throttle
Throw
Timeout
ToAsync
ToBehavior
ToEnumerable
ToObservable
ToSubject
Until
WaitUntil
Where
Zip
</code></pre>
<p>かなり多い。68個ある。名前から想像つくのもあれば全くつかないものも。順番はどうしようかな、LinqではGenerating, Projection and Filtering, Join, Set, Ordering, Grouping, Aggregate, Paging, Convertで分けられたので、何らかの指針でもって分けた方が良いのは間違いないのですが、実際に中を突っつかないと何が何なのか全く分からない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Func&lt;Type, IEnumerable&lt;string&gt;&gt; GetMethodNames = 
    type =&gt; type
        .GetMethods(BindingFlags.Static|BindingFlags.Public)
        .Select(mi =&gt; mi.Name)
        .OrderBy(s =&gt; s)
        .Distinct();

var enumerable = GetMethodNames(typeof(Enumerable));
var observable = GetMethodNames(typeof(Observable));

observable.Except(enumerable).ToList().ForEach(Console.WriteLine);
</code></pre>
<p>メソッド名一覧はobservableのみを吐いたもので、上のコードはEnumerableとの差分も取ってみたものです。Enumerableと重複しないものは47個でした。そんなに被ってる、というわけではないですね……。ちなみに、Enumerableは50個。覚えきれているので、もっと少ないと思ってたんですが、意外と多かった。Linq to Objectsもきちんと理解して使えるようになるのに半年ぐらいかかってしまっているので、今回も長期戦かなー。ちんたらやってる間にドキュメントが出てくるのを期待したい。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-13" data-pagefind-meta="published:2009-09-13"><a href="https://neue.cc/2009/09/13_200.html">.NET Reactive Framework メソッド探訪第三回:Subscribe</a></h1>
<ul class="date"><li>2009-09-13</li></ul>
<div class="entry_body"><p>メソッド探訪とか言いながら、ちっとも探訪してません。今回までが基礎知識で、Linq to Objectsで言ったらイテレータがどうこう、という段階。次回以降はメソッドを見ていきたいと思います。では、最後の予習ということで、Subscribe。SubscribeはIObservable&lt;T&gt;連鎖の終点となるもので(但し、別にSubscribeだけが終点というわけではない、FirstとかCountとか、終点になるものは他にもあります)ForEachのようなもの。戻り値はIDisposableで、イベント発生の監視を止めたい時はDisposeを呼ぶ。と、第一回の時に書きましたので、今回は別の方向から見ていきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void Main(string[] args)
{
    Observable.Range(1, 10).Subscribe(Observer.Create(
        (int i) =&gt; Console.WriteLine(i), // OnNext
        e =&gt; { throw e; }, // OnError
        () =&gt; Console.WriteLine(&quot;Completed&quot;) // OnCompleted
    ));

    Console.ReadLine();
}
</code></pre>
<p>今回はコンソールアプリで。結果は想像つくとおり、1から10、最後にCompletedを表示。Observable.RangeはEnumerable.Rangeと同じです。というか中身的にはEnumerable.Range.ToObservableで変換されているだけです。RepeatとEmptyも用意されているので、ちょっとしたメソッド確認用に便利に使えると思います。それにしてもコード、ゴチャゴチャしてますねえ、わけわかんない書き方してわざと難解にやってるんじゃないだろうかって感じですが、その通りです、ので、普通の書き方も下の方でちゃんと書きます。で、SubscribeはIObservable&lt;T&gt;のメソッドとして定義されています。IEnumerable&lt;T&gt;がGetEnumeratorを持つように、IObservableはSubscribeを持つ。そして、原則Subscribeの引数はIObserver&lt;T&gt;です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IObservable&lt;T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}

public interface IObserver&lt;T&gt;
{
    void OnCompleted();
    void OnError(Exception exception);
    void OnNext(T value);
}
</code></pre>
<p>インターフェイスなので直接生成することは出来ない。よってファクトリメソッドObserver.Createを用いて生成します。生成されるのは前回見たAnonymousEnumeratorと同じくinternalのジェネリッククラス「AnonymousObserver&lt;T&gt;」で、インターフェイスの各メソッドにデリゲートを直接放り込むだけの単純明快なものです。勿論、IObservable&lt;T&gt;を継承して自前の専用のものを用意しても構いませんが、クロージャを活かせば、自前で定義する意味など少しもありません。コンパイラの自動生成クラス任せでOK。</p>
<p>これの動作はメソッド名通りで、OnNextは値が来るたびに実行されるメソッド。OnCompletedは全て完了した時(FromEvent経由のものなど、実質無限リピート状態の場合は、Disposeが呼ばれた時)に実行されるメソッド。OnErrorは例外が発生した時に実行されるメソッド。発生した例外は原則catchされるので、再スローしたい時は、そのまんまですがthrow eの明示が必要です。</p>
<p>……それにしても面倒くさい。Observer.Createは。onNextだけが書ければいいんだよ！ってシーンにわざわざ空の式を書けとでも？（ちなみに空は()=&gt;{}です) 大体がして、推論出来ないから(int i)だとか、型を書かなければならないのもかったるい。というわけで、拡張メソッドが用意されています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError, Action onCompleted);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError, Action onCompleted);
</code></pre>
<p>いっぱいありますけど、ようするに無視した部分は空のメソッドが代わりに埋められる、というだけの話。これを使えば、最初の例は、onNextだけにすると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.Range(1, 10).Subscribe(i =&gt; Console.WriteLine(i));
</code></pre>
<p>と、簡潔明快に記述出来るわけです。メデタシメデタシ。</p>
<h2>過去記事</h2>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">.NET Reactive Framework メソッド探訪第一回:FromEvent</a><br />
<a href="http://neue.cc/2009/09/07_198.html" title="neue cc - .NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></p>
</div>
<h1 data-pagefind-sort="date:2009-09-09" data-pagefind-meta="published:2009-09-09"><a href="https://neue.cc/2009/09/09_199.html">無限リピートの幸福</a></h1>
<ul class="date"><li>2009-09-09</li></ul>
<div class="entry_body"><p>Reactive Frameworkが、結構に無限リピートな感じなので、関連してC# Linqで<a href="http://ja.doukaku.org/197/lang/csharp/">どう書くにあった13日金曜日問題</a>を今更書いてみた。n番煎じ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 今日から2013年12月31日までの、13日の金曜日とその総数を表示してください。
// 「今日」を無限リピートという方針で書いてみたりして(総数は省略)
// 利点はTodayを変数として外側に定義する必要が無くLinq内に閉じ込められる
// Toを求めるのに足したり引いたりする必要がなく自然に書ける、の二つかしらん
// 「まで」という問いに対してTakeWhileで解答するのは自然で良いと思う

Enumerable.Repeat(DateTime.Now, int.MaxValue)
    .Select((d, i) =&gt; d.AddDays(i))
    .TakeWhile(d =&gt; d.Year &lt; 2014)
    .Where(d =&gt; (d.DayOfWeek == DayOfWeek.Friday) &amp;&amp; (d.Day == 13))
    .ToList()
    .ForEach(d =&gt; Console.WriteLine(d.ToShortDateString()));
</code></pre>
<p>TakeWhileが好きです。問題文に対して、自然に解答出来るような気がするので。「今日から(Repeat)」「2013年12月31日までの(TakeWhile)」「13日の金曜日(Where)」。実に自然に記述できる。いやまあ、Repeatが直感的かというと結構微妙なところではありますが。Rangeでfrom,toのほうが自然だろ常識的に考えて、というのも確かなんですけど、Rangeだとtoを作るのに計算式が必要ってのが、ちょっと違うかな、と。</p>
<p><a href="http://en.wikipedia.org/wiki/Pizza_(programming_language)">Pizza (programming language)</a>のexampleにもあるような、Streamを始めとして何かを無限リピートしてTakeWhileで終了条件を設定、というのはパターンとして結構幅広く使える、と思う。ある種のデザインパターン。イディオムイディオム。参考リンクは<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">C# 3.0 と while(true) と Iterator - NyaRuRuの日記</a>この辺り。</p>
<p>例えばVS2010から搭載されるEnumerable.Zipや、あとCycleを定義してみる。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// この二つを混ぜ合わす(VS2010で搭載されるZip関数)
var seq1 = Enumerable.Range(1, 10);
var seq2 = Enumerable.Range(10, 10);
Enumerable.Repeat(new { e1 = seq1.GetEnumerator(), e2 = seq2.GetEnumerator() }, int.MaxValue)
    .TakeWhile(t =&gt; t.e1.MoveNext() &amp;&amp; t.e2.MoveNext())
    .Select(t =&gt; t.e1.Current + t.e2.Current); // ここがZipのSelectorの部分
// foo,bar,hoge,foo,bar,hogeを無限に繰り返す
var elements = new[] { &quot;foo&quot;, &quot;bar&quot;, &quot;hoge&quot; };
var cycle = Enumerable.Repeat(elements, int.MaxValue).SelectMany(ar =&gt; ar);
</code></pre>
<p>Linqのお陰でかつてない勢いでint.MaxValueを使っているこの頃。Repeatも万能ですねえ。いやまあ、もう素直にAchiral使えよって話なんですが、標準メソッドのみで粘るのも面白くて。そういえばでついでなので<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>でもやってみた。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// JavaScriptはAddDaysがないので副作用全開でTodayを
// setHours(24)で翌日にしてしまう、という方針でやってみた

E.Repeat(new Date())
 .Do(&quot;$.setHours(24)&quot;)
 .TakeWhile(&quot;$.getFullYear() &lt; 2014&quot;)
 .Where(&quot;$.getDay() == 5 &amp;&amp; $.getDate() == 13&quot;)
 .ForEach(&quot;alert($)&quot;);
</code></pre>
<p>DoはReactive Frameworkにもありました。副作用を加えた上で素通しするメソッド。副作用は嫌なものです。汚いです。何が嫌かというと、動作を考えるのに見る範囲を広げなきゃいかんところかなあ。そしてLinqの何がいいかというと、見る範囲が物凄く限定される(ラムダ式一文だけを見ればいい)と思っている。だからLinq内でクロージャ(というか外部の変数をキャプチャして使う)もあんま好ましくないし、C#クエリ構文のletも好きじゃない。なるべくなら使いたくない。長文耐性なのは分かるけれど、カッコやインデントがなくてスマートだけれど、その分だけスコープが不明瞭になるという側面が否めない。まあ、letが必要なシチュエーションをSelectManyでやると、大抵はもっと奇怪になるのですけど。</p>
<p>んでまあ、この場合だとAddDaysのかわりにnew Date(year,month,day)で新しいのを作れば副作用なくSelectが使えるわけですが、ありきたりで面白くないと思ったので別な方向に走ってみた。というか、無限リピートは、無限リピートする何かに対して副作用全開で操作を加え続ける、という形の方が面白いというか実用的というか普通だとは思う。冒頭の例みたいなやつだと、別にRangeでよくね？って感じですし。Haskellじゃないんだから、潔癖症にならずに、副作用といかに楽しくお付き合いするかが大事なのですかね。</p>
<p>あ、ちなみに$は引数が一つの場合の省略記法です。こういった機能は<a href="http://ja.wikipedia.org/wiki/Scala">Scala</a>にもある。引数が一つのみの場合が大半なので、記述がグッと縮まるし、何よりも引数名を付ける必要がないのが嬉しい。C#でも使えるようになると嬉しいなあ、とずっと思ってるんですが中々どうして無理なんですかねえ、残念。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-07" data-pagefind-meta="published:2009-09-07"><a href="https://neue.cc/2009/09/07_198.html">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></h1>
<ul class="date"><li>2009-09-07</li></ul>
<div class="entry_body"><p>予定は常に変更されるもの、というわけで、今回はAnonymousEnumerableとAnonymousEnumeratorを見たいと思います。表に出てこない、internalのクラスな上に、内部でも全然使われていないので、見る必要はあんまりない。のですが、これと対になるAnonymousObservableとAnonymousObserverを見るにあたって、先に慣れ親しんだIEnumerable/Enumeratorで考えたほうが分かりやすかったので、これを先に考えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class AnonymousEnumerable&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator;
    public AnonymousEnumerable(Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator)
    {
        // 以下略
}

class AnonymousEnumerator&lt;T&gt; : IEnumerator&lt;T&gt;
{
    private Func&lt;T&gt; current;
    private Action dispose;
    private Func&lt;bool&gt; moveNext;

    public AnonymousEnumerator(Func&lt;bool&gt; moveNext, Func&lt;T&gt; current, Action dispose)
    {
        this.moveNext = moveNext;
        this.current = current;
        this.dispose = dispose;
    }

    public T Current
    {
        get { return this.current(); }
    }

    public bool MoveNext()
    {
        return this.moveNext();
    }
    
    // 以下略
}
</code></pre>
<p>Reflectorで見ちゃってるので、一部だけ(ライセンス！)。ただ、どれも一行なので見るまでもなく何をやってるのか想像付くと思います。 お馴染みのインターフェイスを実装しているだけですが、その実装を全てコンストラクタで受ける関数に任せています。ようするにこれはどういうことなのかというと、実例としてEnumerable.RepeatとSelectをAnonymousEnumerableで実装してみるとこうなります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class Enumerable
{
    public static IEnumerable&lt;T&gt; Repeat&lt;T&gt;(T element, int count)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var index = 0;
            var current = default(T);
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; // MoveNext
                {
                    if (index == 0) current = element;
                    return (index++ &lt; count);
                },
                () =&gt; current, // Current
                () =&gt; { } // Dispose
            );
        });
    }
    
    // 実際のSelectは&lt;TSource,TResult&gt;ですが、都合により略
    public static IEnumerable&lt;T&gt; Select&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, T&gt; selector)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var enumerator = source.GetEnumerator();
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; enumerator.MoveNext(),
                () =&gt; selector(enumerator.Current),
                () =&gt; enumerator.Dispose()
            );
        });
    }
}
</code></pre>
<p>勿論、普通はyieldを使えばいいわけですが、もしyieldがなければ、こういう形で実装するのが簡潔でベスト、に見える。クロージャでコンパイラにクラス生成を任せているわけですねー。外部イテレータですが、外部のクラスに分割せず中に書けるため、すっきり分かりやすい。この発想はあったけどC#でやるという発想はなかったわ、というわけで結構感動しました。</p>
<p>そうそう、この仕組みは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>と丸っきり同じなのです。感動ってのは、私の基本方針は間違ってなかったんだ！の裏付けでの喜びなので不純です。そのJavaScriptでの実装はこんな感じ。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">Linq.Object = function(getEnumerator)
{
    this.GetEnumerator = getEnumerator;
}

Linq.Enumerator = function(moveNext)
{
    this.Current = null;
    this.MoveNext = moveNext;
}

Repeat: function(element, count)
{
    return new Linq.Object(function()
    {
        var index = 0;
        return new Linq.Enumerator(function()
        {
            if (this.Current == null) this.Current = element;
            return (index++ &lt; count);
        });
    });
}

Select: function(selector)
{
    var source = this;
    selector = Linq.Utils.CreateFunctor(selector);

    return new Linq.Object(function()
    {
        var enumerator = source.GetEnumerator();
        var index = 0;

        return new Linq.Enumerator(function()
        {
            if (enumerator.MoveNext())
            {
                this.Current = selector(enumerator.Current, index++);
                return true;
            }
            else
            {
                return false;
            }
        });
    });
}
</code></pre>
<p>スコープが若干違うかなって感じですが、大体同じです。(Linq.ObjectはLinq.Enumerableに名前変えよう……)。JavaScriptだからこそ、yieldがなくてもスッキリ定義出来る！と思っていただけに、そっかあ、そういう手を使えば良かったのかと少しショックだったりして。ほんとC#は柔軟な言語で、むしろもうJavaScriptよりもLightWeightだよ！</p>
<p>さて、次回はAnonymousObservableとAnonymousObserverを見てみることにします。勿論、予定は未定です。ていうかSubscribeはどうした、というと、Subscribeの中身はAnonymousObserverなので全然横道にそれてません、大丈夫です、まだ一直線です。</p>
</div>
<h1 data-pagefind-sort="date:2009-09-04" data-pagefind-meta="published:2009-09-04"><a href="https://neue.cc/2009/09/04_197.html">.NET Reactive Framework メソッド探訪第一回:FromEvent</a></h1>
<ul class="date"><li>2009-09-04</li></ul>
<div class="entry_body"><p>まず、リアクティブフレームワークとは何ぞや、ということなのですが今のところ<a href="http://www.infoq.com/jp/news/2009/07/Reactive-Framework-LINQ-Events">InfoQ: .NETリアクティブフレームワーク（Rx）がLINQ to Eventsを可能にする</a>の記事ぐらいしか情報はありません。.NET 4.0に含まれる(かもしれない)ということ、現在のところSilverlight Toolkitの単体テストのところにこっそりと配置されていること。それだけです。紹介も、記事中にもリンクされていますが<a href="http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html">unfold: Introducing Rx (Linq to Events)</a>の一連の記事ぐらいしかありません。これの前文が中々に素敵です。</p>
<blockquote>
<p>Buried deep in the bin folder of the Silverlight Toolkit Unit Tests is a hidden gem: The Rx Framework (System.Reactive.dll).  If you glanced quickly you’d miss it altogether but it’s one of the most exciting additions to the .NET framework since Linq.</p>
</blockquote>
<p>今のところ微妙にパッとしない(Parallelは簡単に使えるがゆえにインパクトが足らない)4.0の隠し玉はコレですね、間違いない。軽く触ってみたのですが、中々に感動的。Linq to Objects好きならば間違いなく琴線に触れます。C#3.0がコレクションの操作をforeachからLinqに変えてしまったように、.NET4.0はイベントもLinqに変わる。まさにLinq to Everywhere! Functional Reactive Programming!</p>
<h2>How to use</h2>
<p><a href="http://www.codeplex.com/Silverlight">Silverlight Toolkit</a>をダウンロードしてSource/Binaries/System.Reactive.dllを頂けば完了。ただし、これはそのままだとSilverlightのプロジェクトでしか動作しないので、その他ので利用したい場合は<a href="http://evain.net/blog/articles/2009/07/30/rebasing-system-reactive-to-the-net-clr">ここの記事</a>に示されているように、githubに公開されているコードを実行(Cecilのdllが必要、記事文中にリンクされています)して変換する必要があります。今回はとりあえず、Silverlightで試してみたいと思います。こちらはこちらで、<a href="http://www.microsoft.com/downloads/details.aspx?displaylang=ja&amp;FamilyID=9442b0f2-7465-417a-88f3-5e7b5409e9dd">Silverlight 3 Tools</a>のダウンロードが必要ですけれど。</p>
<h2>実例</h2>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication4.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>マウスの動きに円が追随する、という単純なものをSilverlightで作ってみました。移動は完全に追随するのではなく、座標が15で割り切れる位置の場合のみ移動としました。スナップすることをイメージしたつもりなのですが、動きがガクガクです。これは、マウス移動に完全に追随して全ての座標でイベントが発生するわけではない = 15で割り切れる座標を通過してもイベントが発生しない場合がある = 動きがガクガク。というわけで、スナップしたい場合はWhereで間引くのではなく、Selectで近傍座標に寄せるべきです、が、いやまあ、例なので……。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// XAMLではなく全部コード上に書いたのは両方を張るのが面倒だから……
// 内容はCanvasとEllipseを配置するというもので、本筋とは関係ありません
InitializeComponent();
var canvas = new Canvas { Background = new SolidColorBrush(new Color {A=255, R = 100, G = 100, B = 100 }) };
var ellipse = new Ellipse { Height = 30, Width = 30, Fill = new SolidColorBrush(Colors.Orange) };
canvas.Children.Add(ellipse);
this.Content = canvas;

// FromEventはイベント発火がトリガとなってLinq発動
// 後段に送られるのはEvent&lt;T&gt;というもので、
// SenderとEventArgsという読み取り専用プロパティを持つクラス
var canvasMove = Observable.FromEvent&lt;MouseEventArgs&gt;(canvas, &quot;MouseMove&quot;)
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Where(p =&gt; (p.X % 15 == 0) || (p.Y % 15 == 0))
    .Subscribe(p =&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    });

// Subscribeの戻り値の型はIDisposable
// Disposeを呼ぶと登録したイベントをデタッチすることが出来る
// デタッチしないなら取得する必要は特にはない
// canvasMove.Dispose();
</code></pre>
<p>MouseMoveでイベントが発火する度にLinqを通る。なるほど、イベントがリストに、見える。イベントを無限リスト生成として捉えることで、イベントに対してLinq操作が可能になった。ObserverパターンとIteratorパターンは同じだったんだよ！なんだってー！みたいなノリがある。もう少し丁寧に見ると、Observable.FromEventでイベントをPush型の無限リストに変換。戻り値はIObservable&lt;T&gt;。イベント発火時に後段に流れてくるのはEvent&lt;T&gt;。これは通常のイベント登録時に使うsenderとeventArgsをラップしただけの単純なもの。あとはIObservableに用意されているメソッド(Select, Where, TakeWhileなどお馴染みのものから、Delay, WaitUntilなどイベント用の目新しいメソッドなど多数)を繋げて、最後にSubscribe。このSubscribeは、つまり通常のイベント登録時のメソッド本文の役割を果たす。Linqで言ったらForEachのようなもの。Subscribeのオーバーロードも幾つかあるのですが、それはまた後日。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// つまるところ、以下のコードと同じだったりはする
// ただ、IObservable&lt;T&gt;は通常のイベント登録では無理な複雑な操作が簡単、
// そして何よりも、このような単純なコードでもそんなに複雑になっていない！
canvas.MouseMove += (sender, e) =&gt;
{
    var pos = e.GetPosition(canvas); // Select
    if (!(pos.X % 15 == 0 || pos.Y % 15 == 0)) return; // Where
    ellipse.SetValue(Canvas.LeftProperty, pos.X - ellipse.Width / 2);
    ellipse.SetValue(Canvas.TopProperty, pos.Y - ellipse.Height / 2);
};
</code></pre>
<p>通常のイベント登録と対比してみると分かりやすいかしらん。FromEventではMouseEventArgsという型を明示する必要があるのがカッタルイ。推論は偉大。が、しかし、IObservableが複雑な操作が可能なのに対し、イベントに追加では直球なものしか書けない。また、複雑な操作が可能なわりには、FromEventは驚くほどシンプルに書ける。シンプルな操作でも(記述するのに)重たくない、というのは特筆すべきことじゃあないでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// stringを避けたこういう登録方法もあるけれど、面倒なうえに警告出る
Observable.FromEvent((EventHandler&lt;MouseEventArgs&gt; h) =&gt; new MouseEventHandler(h),
        h =&gt; canvas.MouseMove += h, // addHandler
        h =&gt; canvas.MouseMove -= h) // removeHandler
    .Subscribe(e =&gt; Debug.WriteLine(e.EventArgs.GetPosition(canvas)));
</code></pre>
<p>ところで、イベント名をstringで書くのはどうよ、ていうかJavaScriptのaddEventHandlerみたいで嫌だよね？ね？リファクタリング効かないわ、IntelliSenseも動かないわでロクなことがない。というわけで、FromEventのオーバーロードを見ると、ちゃんと普通に登録する方法も用意されてはいる。一応、用意、されては、いる。が、しかし、あんまりだー。あんまりすぎるー。流れてくるEventhandler&lt;MouseEventArgs&gt;をMouseMoveが受け取ってくれないので、第一引数でMouseEventHandlerに変換する(ところで警告が消せないのですが、警告無しで処理する方法ってあるのかしらん)。あとは、addとremoveの登録。長ったらすぎてこれはダメぽ。確かに、こんなんなら、stringでいいです……。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication3.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 普段あまり書かないMouseEventArgsとかいう型定義は書きにくいし
// メソッド名もstringで書くのはミスが出がち、ということで
// 拡張メソッドでイベント取り出し用のメソッドを予め作っておくと良い
public static IObservable&lt;Event&lt;MouseEventArgs&gt;&gt; GetMouseMove(this UIElement elem)
{
    return Observable.FromEvent&lt;MouseEventArgs&gt;(elem, &quot;MouseMove&quot;);
}

// マウスの軌跡を1秒後に描画します
canvas.GetMouseMove()
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Delay(1000)
    .Subscribe(p =&gt;Dispatcher.BeginInvoke(()=&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    }));
</code></pre>
<p>汚い部分は隔離！ということで、拡張メソッドに退避してやると、美しく書ける。いやまあ、この辺は全部<a href="http://themechanicalbride.blogspot.com/2009/07/developing-with-rx-part-1-extension.html">unfold: The Joy of Rx: Extension Events</a>に書いてあることなのですけど。んで、デモ的にもう少し面白げがあったほうがいいかな、と思ったのでDelayを足してみました。1秒後にマウス移動の軌跡を描画します。グルグルーっとマウス動かして止めてみてください。スムーズ、とは言い難いですね、しょんぼり。記述も、Delayを足すだけ。と言いたかったんですがBeginInvokeかあ、これどーにかなる方法ないかなあ。</p>
<h2>次回</h2>
<p>全10回ぐらいで、全部のメソッドを紹介するつもりです。私が理解できればの話ですが。ちょこちょこと実例的なものも交えていきたいと思います。私が使いこなせればの話ですが。というわけで、次回はSubscribeのオーバーロードの紹介にしたいと思います。Reactive Frameworkならではの魅力、に関してはもう少し先になってしまいそう。少し飛ばして、非同期連結の話なんかを先に持ってきた方が良いかなあ。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-30" data-pagefind-meta="published:2009-08-30"><a href="https://neue.cc/2009/08/30_196.html">3桁到達</a></h1>
<ul class="date"><li>2009-08-30</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xitoauthusers.jpg">
</p>
<p>開発者用のOAuth管理ページで認証ユーザー数が見れるのですが(「誰が」までは分からないので安心してください)、いつのまにやらユーザー数が100を超えていました。三桁！奇跡的ですね。はてな同期云々とかフォトライフ云々は壊滅的な状態なので。世の中そんなものです。ついでにこのサイトのアクセス数も壊滅的だったりはします。成り行きでプログラミング系サイトに転換してから半年、以上は経つ感じですが、伸びもせず縮みもせず、ずっと低調をキープ。サイトの内容がガラッと変わったのにアクセス平均が変わらないってのも面白いですけど。検索サイトからのアクセスがほとんどなので、検索キーワードが入れ替わって、でも流入人口は変わらずという。あー、まあ、少し増えた、かな。つまりかわりに常連的な人口が減った、と。おお、虚しい！悲しい！RSSリーダー登録数も伸びないしね。しょぼーん。</p>
<p>ゲーム系サイトへは、XNAで返り咲きしたいとこっそり思ってます。XNAは使用言語がC#だからね。C#好きーなのです、私。積みタスクを全部消化したらXNAやりたいんですが中々どうして……。 そういえばインディーズゲーム(XBIG)を完全スルー状態なのはぶっちけ（略）</p>
<p>fromにクライアント名が出るようになってからは、googleのサイト検索で利用具合が見つかるので、毎日<a href="http://www.google.co.jp/search?q=site%3Atwitter.com%20xboxinfotwit&amp;hl=ja&amp;lr=lang_ja&amp;safe=off&amp;rlz=1B5GGGL_jaJP296JP296&amp;sa=G&amp;num=100&amp;output=search&amp;tbs=qdr:d&amp;tbo=1" title="site:twitter.com xboxinfotwit - Google 検索">24時間以内の結果</a>を眺めていたりします。見ていて思うというか教訓は、デフォルト設定大事ってことでしょうかね。カスタマイズせずそのまま、カスタマイズする場合も、デフォルトを残しつつ細部を変える、という感じなので、デフォルトの投稿文はちゃんとしたものを用意しなきゃダメなんですね。当たり前といえば当たり前なのですけど、この辺はてなついったー同期ツールは大失敗していて、どうせカスタマイズするだろうと踏んで、書式のサンプルとばかりにゴテゴテのものをデフォルトにしてしまったので……。反省。</p>
<p>あと、デフォルトでは「プレイ中タイトルの状況が変わった時の投稿」はオフにしているのですが、意外とこれをオンにする人が多かったのも驚き。これオンにすると物凄い勢いで投稿されるんですよ。更新間隔を5分にすると、例えばGoW2のHordeすると、WAVE44,45,46...と、全部のWAVE投稿するんじゃないか、最新50個の投稿が全部XboxInfoTwit経由になってますが大丈夫？みたいなことになる。こういう滅茶苦茶なことが出来るのはローカルで動くツールならでは、なのですが(ウェブサービス系じゃあ、ちいと無理ですね、秋のTwitter対応が仮に実績やプレイ状況の投稿に対応するとしても、ここまでの連投は無理かと)フォロワーの目からどうなのか、というと、まあ、分からにゃい。いや、本人の満足が一番だと思いますよ。一日のプレイ後に投稿を眺めると、状況の変化がよく見えて結構楽しかったりはします。お薦めはしませんけどお薦め。別アカでやるなら何も問題なくお薦め。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-27" data-pagefind-meta="published:2009-08-27"><a href="https://neue.cc/2009/08/27_195.html">JavaScriptで要素追加するやり方</a></h1>
<ul class="date"><li>2009-08-27</li></ul>
<div class="entry_body"><p>ド素人がjQueryとprototype.jsではどう書くのかな、と思っただけです。メジャーな両者ですが実はまともに使ったことがないのです。困ったことに。しょうがないので見よう見まねで書く。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">&lt;!-- このselectにoptionを一個追加する --&gt;
    
&lt;select id=&quot;selectID&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;hugahuga&lt;/option&gt;
&lt;/select&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

    // 素のJavaScriptその1(古臭いというか微妙な……)
    var option = new Option(&quot;要素&quot;, &quot;属性&quot;);
    var select = document.getElementById(&quot;selectID&quot;);
    select.options[select.options.length] = option;

    // 素のJavaScriptその2(これはダルい)
    var option = document.createElement(&quot;option&quot;);
    option.setAttribute(&quot;value&quot;, &quot;属性&quot;);
    option.appendChild(document.createTextNode(&quot;要素&quot;));
    document.getElementById(&quot;selectID&quot;).appendChild(option);

    // みんな大好きjQuery
    $(&quot;&lt;option&gt;&quot;).attr({ value: &quot;属性&quot; }).text(&quot;要素&quot;).appendTo(&quot;#selectID&quot;);

    // 何だかんだで好きなprototype.js
    var option = new Element(&quot;option&quot;, { value: &quot;属性&quot; }).update(&quot;要素&quot;);
    $(&quot;selectID&quot;).insert(option);

    // linq.js + linq.xml.jsの関数型構築
    var option = X.Elem(&quot;option&quot;, X.Attr(&quot;value&quot;, &quot;属性&quot;), &quot;要素&quot;);
    X.ID(&quot;selectID&quot;).Add(option);
    
&lt;/script&gt;
</code></pre>
<p>素のJavaScriptその1はねーよ、というわけで、その2をいかにスマートにやるかという話。だと思う。jQueryのappendToが合理的というか便利なのは分かるけど、キモく感じてしまう。んで、どれが好きかっていたら、当然自分で作ってる<a href="http://neue.cc/2009/04/04_145.html" title="neue cc - linq.js - JavaScript用LINQライブラリ">linq.js</a>のが一番好きですよ(笑)</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/selectbox.jpg">
</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// linq.js + linq.xml.js
var options = E.RangeTo(1, 12).Select(function(i)
{
    return X.Elem(&quot;option&quot;, X.Attr(&quot;value&quot;, i), i + &quot;月&quot;);
});
X.ID(&quot;selectID&quot;).Add(options);

// prototype.js
var options = $R(1, 12, false).map(function(i)
{
    return new Element(&quot;option&quot;, { value: i }).update(i + &quot;月&quot;);
});
var elem = $(&quot;selectID&quot;);
options.each(function(e) { elem.insert(e) });
</code></pre>
<p>X.Elem()もAdd()もLinqオブジェクト/可変長配列を受け取れるので、まとめてドバーっと追加が結構楽かな、と思います。eachとかじゃなく、そのまんま追加出来るってのが大事。上の例だと、prototype.jsではmapでoptionsを作らずそのまんまeachでinsertしちゃえばいいぢゃん、というのはそのとーりなんですが(2回もループ回ることになるしね、あ、linq.jsのは遅延評価しているのでループはAddで呼び出される時の1回しか回りません)、配列(的なもの)が既にある状態ってのは、結構ありますよね？</p>
<p>と、何故か突然アピールしてますがlinq.xml.jsは作りかけで放置しているので足りない関数がいっぱいあるんですけどね！</p>
</div>
<h1 data-pagefind-sort="date:2009-08-25" data-pagefind-meta="published:2009-08-25"><a href="https://neue.cc/2009/08/25_194.html">enumの日本語別名とか三項演算子ネストとか</a></h1>
<ul class="date"><li>2009-08-25</li></ul>
<div class="entry_body"><p>enumのToStringで日本語名になって欲しいというケースはとてもあるある。<a href="http://igeta.cocolog-nifty.com/blog/2007/11/enum_string.html">enum に文字列の属性を: いげ太のブログ</a>と<a href="http://d.hatena.ne.jp/siokoshou/20080124">2008-01-24 - 当面C#と.NETな記録</a>の記事を見て、今まで拡張メソッドで処理することが多かったのですが、やっぱり見た目は属性のほうがスッキリするなあ、と思った。記述が本体と離れないのが良いですよね。処理速度とか、そんなに頻繁に繰り返し繰り返し呼ぶものでもないしリフレクション上等！それ気にしたらSerializeとか出来ない！とか思ったので、基本は属性で処理することにしてみた。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">enum Fruit
{
    [AliasName(&quot;ブドウ&quot;)]
    Grape,
    [AliasName(&quot;リンゴ&quot;)]
    Apple,
    [AliasName(&quot;オレンジ&quot;)]
    Orange
}

static void Main(string[] args)
{
    var fruit = Fruit.Orange;
    Console.WriteLine(fruit.ToAliasName());
}
</code></pre>
<p>こんな感じに定義してこんな感じに使う、と。定義もスッキリ、呼び出し時もToString的に拡張メソッドでスッキリ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
public sealed class AliasNameAttribute : Attribute
{
    public string AliasName { get; private set; }

    public AliasNameAttribute(string aliasName)
    {
        AliasName = aliasName;
    }
}

public static class Ext
{
    // どうしてもメソッドチェインを崩したくない人用
    public static T ThrowIf&lt;T&gt;(this T value, Func&lt;T, bool&gt; predicate, Exception exception)
    {
        if (predicate(value)) throw exception;
        else return value;
    }

    public static string ToAliasName(this Enum value)
    {
        return value.GetType()
            .GetField(value.ToString())
            .GetCustomAttributes(typeof(AliasNameAttribute), false)
            .Cast&lt;AliasNameAttribute&gt;()
            .FirstOrDefault()
            .ThrowIf(a =&gt; a == null, new ArgumentException(&quot;属性が設定されていません。&quot;))
            .AliasName;
    }
}
</code></pre>
<p>ドットが縦にならんでると何だか楽しい。というわけで、チェーンを崩さずに例外を放り投げるための拡張メソッドThrowIfを用意してみた。nullが邪魔！邪魔！nullが出現するせいで一個変数を置いてnullチェックかまさなきゃいけない！というシーンは多いので、predicateじゃなくてnull限定決め打ちでも良いぐらいかもかも。とにかくnull撲滅。まあ、この場合はFirstOrDefaultじゃなくてFirstにすれば、Firstが例外を吐いてくれるのですけど、一応ちゃんとメッセージ用意したいとか、ありますよね？ね？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 三項演算子のチェーンを崩さないためにダミーの型を返して例外を投げる
static T Throw&lt;T&gt;(Exception exception)
{
    throw exception;
}

static string Test(Fruit fruit)
{
    return (fruit == Fruit.Apple) ? &quot;あぷる&quot;
         : (fruit == Fruit.Grape) ? &quot;ぐれえぷ&quot;
         : (fruit == Fruit.Orange) ? &quot;おれんじ&quot;
         : Throw&lt;string&gt;(new ArgumentException(&quot;引数ダメぽ！&quot;));
}
</code></pre>
<p>三項演算子を延々とネストしてコロンを前置にするのが好き、と<a href="http://neue.cc/2009/08/21_190.html" title="neue cc - ネストした三項演算子の書き方">以前に書いた</a>のですが、そうすると、最後にdefault的なものを書く必要があって困る。&quot;&quot;とか0とかでお茶を濁さずに、例外を吐きたいのですが、ネスト三項演算子では例外を吐けない。困った困った。というわけでThrowという補助メソッドを用意してみた。ただ例外を吐くだけメソッド。おー。これでもう大量にネストしても大丈夫！万歳！三項演算子でネストしよう！ついでにネスト時のコロンは前置にしよう！の会。</p>
<h2>使用しないでください？</h2>
<p>ところで、EnumのToStringはIntelliSenseに使用しないでください、が出てきてビビる。んが、よくよく眺めてみると……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public override string ToString();
[Obsolete(&quot;The provider argument is not used. Please use ToString().&quot;)]
public string ToString(IFormatProvider provider);
public string ToString(string format);
[Obsolete(&quot;The provider argument is not used. Please use ToString(String).&quot;)]
public string ToString(string format, IFormatProvider provider);
</code></pre>
<p>ObsoleteなのはIFormatProviderが絡んでるものだけで、普通のToStringは使用していいんでないのん？<a href="http://blogs.wankuma.com/jeanne/archive/2006/04/04/22239.aspx" title="文字列の列挙体">文字列の列挙体</a>←ここのコメント欄が白熱していたのを見て、どうなのかなー、と思っているのですが、どうなんでしょうか。いやほんと。</p>
</div>
<h1 data-pagefind-sort="date:2009-08-24" data-pagefind-meta="published:2009-08-24"><a href="https://neue.cc/2009/08/24_193.html">WSH用にCOMのIntelliSenseを自動生成する</a></h1>
<ul class="date"><li>2009-08-24</li></ul>
<div class="entry_body"><p>本題、の前にJavaScript用のIntelliSenseの作成方法について。以前、<a href="http://neue.cc/2009/06/06_164.html" title="neue cc - 最もタメになる「初心者用言語」はVisualStudio(言語?)">linq.jsにIntelliSense用ファイルを追加した時</a>に利用法を書きましたが、今回はvsdocの作成方法を、ざっと書きます。まずVS2008 SP1とパッチを適用する。hoge.jsに対しhoge-vsdoc.jsを用意するとhoge.jsのかわりにhoge-vsdoc.jsがIntelliSense用に読み込まれる。IntelliSenseでVSが見ているのはメソッド名と引数だけなので、コードの中身はなくてもいい。例えば本来は存在するがprivateメソッドのつもりのものは、vsdoc.js側に書かなければIntelliSenseには表示されない。C#と同様に関数にはXMLドキュメントコメントを記述することが出来る。記述箇所はC#とは異なり開始の波括弧の直下。ドキュメントコメントのタグで現在機能しているものはsummary, params, returnsのみ。特に重要なのはreturns typeで、これにprototypeが存在する関数(ようするにクラスですなー)を指定することで戻り値の型をVSに認識させ、IntelliSenseを働かせることが出来る。ちなみに、ただのオブジェクトだと認識してくれない。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">function Hoge(aaa, bbb)
{
    /// &lt;summary&gt;hogehogehogehoge&lt;/summary&gt;
    /// &lt;param name=&quot;aaa&quot; type=&quot;String&quot;&gt;a!a!a!a!a!&lt;/param&gt;
    /// &lt;param name=&quot;bbb&quot; type=&quot;Optional:Boolean&quot;&gt;b?b?b?b?b?&lt;/param&gt;
    /// &lt;returns type=&quot;Number&quot;&gt;&lt;/returns&gt;
}
</code></pre>
<p>基本はこんな感じ。引数の省略や、型が目で見て分かるので大分書きやすくなります。 で、<a href="http://neue.cc/2009/08/02_182.html" title="neue cc - linq.js :: Next">いつぞやかに作成中</a>とか言っていた通りにlinq.jsをWSH対応させようとしているわけですが、IntelliSense書きの量が思ったよりも膨大なわけです。実は最初は普通に手書きしてました。一応勉強も兼ねて書写みたいなノリで。ですが、あまりにも手間かかりすぎるので自動生成することにしました。こんなの人力でやるもんじゃないですよ。微調整はどちらにせよ必要なのですか、大枠だけでも書きだされていると物凄く楽になる。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void Main(string[] args)
{
    // add reference and replace dll path
    var assembly = Assembly.LoadFrom(@&quot;Interop.IWshRuntimeLibrary.dll&quot;);
    var types = assembly.GetTypes();

    var enums = types
        .Where(t =&gt; t.IsEnum)
        .OrderBy(t =&gt; t.Name)
        .Select(t =&gt; string.Format(&quot;{0}: \r\n{{\r\n{1}\r\n}}&quot;,
            t.Name,
            Enum.GetNames(t).Select(s =&gt; string.Format(&quot;\t{0}: {1}&quot;, s, (int)Enum.Parse(t, s))).Join(&quot;,\r\n&quot;)));

    var classes = types
        .Where(t =&gt; t.IsClass)
        .Select(type =&gt;
        {
            var bindingFlag = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;

            var properties = type.GetProperties(bindingFlag)
                .OrderBy(pi =&gt; pi.Name)
                // .Select(pi =&gt; string.Format(&quot;{0}: {1}&quot;, pi.Name, pi.PropertyType.Name
                .Select(pi =&gt; string.Format(&quot;{0}: null&quot;, pi.Name));

            var methods = type.GetMethods(bindingFlag)
                .Where(mi =&gt; !mi.IsSpecialName &amp;&amp; mi.Name != &quot;GetEnumerator&quot;)
                .Select(mi =&gt; new { mi.Name, Parameters = mi.GetParameters(), ReturnType = mi.ReturnType.Name })
                .OrderBy(t =&gt; t.Name)
                .Select(t =&gt; string.Format(&quot;{0}: function({1})\r\n{{\r\n{2}\t/// &lt;returns type=\&quot;{3}\&quot;&gt;&lt;/returns&gt;\r\n}}&quot;,
                    t.Name,
                    t.Parameters.Select(pi =&gt; pi.Name).Join(&quot;, &quot;),
                    t.Parameters.Select(pi =&gt; string.Format(&quot;\t/// &lt;param name=\&quot;{0}\&quot; type=\&quot;{1}{2}\&quot;&gt;&lt;/param&gt;\r\n&quot;,
                            pi.Name,
                            (pi.IsOptional) ? &quot;Optional:&quot; : &quot;&quot;,
                            pi.ParameterType.Name.Replace(&quot;Void&quot;, &quot;void&quot;).Replace(&quot;Int32&quot;, &quot;Number&quot;)))
                        .Join(&quot;&quot;),
                    t.ReturnType.Replace(&quot;Void&quot;, &quot;void&quot;).Replace(&quot;Int32&quot;, &quot;Number&quot;)));

            var result = properties.Concat(methods).Join(&quot;,\r\n&quot;);
            return string.Format(&quot;{0} = function() {{ }}\r\n{0}.prototype =\r\n{{\r\n{1}\r\n}}&quot;,
                Regex.Replace(type.Name, &quot;Class$&quot;, &quot;&quot;),
                result.Split(new string[] { &quot;\r\n&quot; }, StringSplitOptions.None).Select(s =&gt; &quot;\t&quot; + s).Join(&quot;\r\n&quot;));
        });

    var name = assembly.GetName().Name.Split('.').Last();
    File.WriteAllText(name + &quot;_enum.js&quot;, string.Format(&quot;{0}Enum =\r\n{{\r\n{1}\r\n}}&quot;, name,
        enums.Join(&quot;,\r\n&quot;).Split(new string[] { &quot;\r\n&quot; }, StringSplitOptions.None).Select(s =&gt; &quot;\t&quot; + s).Join(&quot;\r\n&quot;)), Encoding.UTF8);
    File.WriteAllText(name + &quot;_class.js&quot;, classes.Join(&quot;\r\n\r\n&quot;), Encoding.UTF8);
}

static string Join&lt;T&gt;(this IEnumerable&lt;T&gt; source, string separator)
{
    var index = 0;
    return source.Aggregate(new StringBuilder(),
            (sb, o) =&gt; (index++ == 0) ? sb.Append(o) : sb.AppendFormat(&quot;{0}{1}&quot;, separator, o))
        .ToString();
}
</code></pre>
<p>参照設定で対象のCOMを読み込んで、一旦ビルド。生成されてるInterop.hoge.dllを読み込んで解析、という流れをとってみました。もっとマシなやり方があれば教えてください。コードは、んーと、string.Formatがクドくて見難いですね！ 最初はVSのフォーマッタに後で手動でかければいいや、と思ってたのを、出力状態でちゃんとフォーマットされてるようにと継ぎ接ぎしてたら酷いことに。一回文字列にしたものを改行でバラして再生成とか笑えない。こういうの、HTML/XMLが対象なら何も考えなくてもLinq to Xmlで綺麗に書けるのになあ……。 それ以外はまぁ、こんなものかしらんって感じでしょうか？ リフレクションが絡むとLinq大活躍。Selectがネストしまくるのでクエリ構文の出番はない。リフレクションは掘り進める都合上、ネストが深くなるのでLinqがなかったら、と思うとゾッとします。最近はforの二重ループですらウエエ、とか思ってしまうので。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">IWshRuntimeLibraryEnum =
{
    IOMode:
    {
        ForReading: 1,
        ForWriting: 2,
        ForAppending: 8
    }
}

Folder = function() { }
Folder.prototype =
{
    Name: null,
    ParentFolder: null,
    Drive: null,
    CreateTextFile: function(FileName, Overwrite, Unicode)
    {
        /// &lt;param name=&quot;FileName&quot; type=&quot;String&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Overwrite&quot; type=&quot;Optional:Boolean&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Unicode&quot; type=&quot;Optional:Boolean&quot;&gt;&lt;/param&gt;
        /// &lt;returns type=&quot;TextStream&quot;&gt;&lt;/returns&gt;
    }
}
</code></pre>
<p>一部抜粋ですが、こんなようなデータが出力されます。プロパティが全部nullなのは、ここに未指定のものが記述されているとIntelliSenseがエラー起こしてしまうから。例えばDrive: new Drive()で戻り値の型指定が可能といえば可能なのですが、出現位置の上下が問題になってくるので結構面倒くさい。ようはFolderよりも上にDriveがあれば関数が存在するので大丈夫だけど、下にあれば存在しないのでエラー。当たり前といえば当たり前なのですが、ダミーでのIntelliSense作りとしては面倒な問題でして。 この辺は素直に諦めて全部nullで型連鎖を止めてしまうのがお気楽といえばお気楽。あと、Dateはnew Date()にしてもDate.prototypeにしても型指定出来なかったりする問題もある。これは今のところ対処不能。</p>
<p>そんなわけで、linq.js + WSHはわりと順調に作成中なので期待しないでも待っててください。IntelliSenseというだけじゃなく、JScriptではバイト配列が扱いにくいので、扱いやすく出来るような補助メソッドを用意したりとか色々やってたらいつになっても終わらないー。<a href="http://gyazo.com/5707f82cea9dc9af36ee5f825c5d56b7.png" title="5707f82cea9dc9af36ee5f825c5d56b7.png (PNG 画像, 632x672 px)">例としてWSHでMD5を作る</a>、とか。.NET Frameworkを通しているのでSHA1でも何でもいけます。これでWSHでwsse認証通してAtomAPIで投稿、とか出来ますね。まあ、もうC#でいいぢゃん、って気がかなりしなくもないですけど、うーん。C#4.0からdynamicが追加されるからCOM連携も楽になるしねえ。ただサイドバーガジェットに使うとか、JavaScriptの用途はまだまだあるもん！(これもSilverlightでやれば？って話がなくもないので、うーん)</p>
</div>
<a href="https://neue.cc/24">Prev |</a>
<a href="https://neue.cc/26">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
