<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2009/09/14_201.html">.NET Reactive Framework メソッド探訪第四回:メソッド一覧</a></h1>
<ul class="date"><li>2009-09-14</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">前回</a>が少し、明らかに説明不足でした……。Subscribeが原則としてIObserverを受ける(直接ラムダ式でonNextを記述するのはただの省略記法)ということは、IObserverを別に作っておける。もっと進めると、Subscribeで実行されるコード本体は自由に入れ替え可能。ということになります。ここが、イベント直記入に対するReactive Frameworkの強みの一つ。それ○○パターンだって？そうですね？その○○パターンがデフォルトで何も考えず使えるのならば、素晴らしいと思います。</p>
<p>では、ここからようやくメソッド探訪。の前に、全メソッド一覧を見てみます。IObservable&lt;T&gt;拡張メソッド一覧。そう、最初感動したのは、ドット打ってIntelliSenseに並んだこのメソッド名を見て、なのよね。いかにも素晴らしいことが出来そうな予感だったという。</p>
<pre><code class="language-text">Aggregate
Amb
AsObservable
Catch
CombineLatest
Concat
Cons
Contains
Count
Create
Defer
Delay
Dispatch
Do
Empty
Finally
First
FirstOrDefault
Flatten
ForkJoin
FromEvent
Generate
GetEnumerator
HoldUntilChanged
Interval
Last
LastOrDefault
Latest
Let
LetRec
LongCount
Merge
MostRecent
Never
Next
Post
Range
Reify
Repeat
Retry
Return
Sample
Scan
Select
SelectMany
Send
Single
SingleOrDefault
Skip
SkipWhile
Spawn
Start
Subscribe
Synchronize
Take
TakeWhile
Throttle
Throw
Timeout
ToAsync
ToBehavior
ToEnumerable
ToObservable
ToSubject
Until
WaitUntil
Where
Zip
</code></pre>
<p>かなり多い。68個ある。名前から想像つくのもあれば全くつかないものも。順番はどうしようかな、LinqではGenerating, Projection and Filtering, Join, Set, Ordering, Grouping, Aggregate, Paging, Convertで分けられたので、何らかの指針でもって分けた方が良いのは間違いないのですが、実際に中を突っつかないと何が何なのか全く分からない。</p>
<pre><code class="language-csharp">Func&lt;Type, IEnumerable&lt;string&gt;&gt; GetMethodNames = 
    type =&gt; type
        .GetMethods(BindingFlags.Static|BindingFlags.Public)
        .Select(mi =&gt; mi.Name)
        .OrderBy(s =&gt; s)
        .Distinct();

var enumerable = GetMethodNames(typeof(Enumerable));
var observable = GetMethodNames(typeof(Observable));

observable.Except(enumerable).ToList().ForEach(Console.WriteLine);
</code></pre>
<p>メソッド名一覧はobservableのみを吐いたもので、上のコードはEnumerableとの差分も取ってみたものです。Enumerableと重複しないものは47個でした。そんなに被ってる、というわけではないですね……。ちなみに、Enumerableは50個。覚えきれているので、もっと少ないと思ってたんですが、意外と多かった。Linq to Objectsもきちんと理解して使えるようになるのに半年ぐらいかかってしまっているので、今回も長期戦かなー。ちんたらやってる間にドキュメントが出てくるのを期待したい。</p>
</div>
<h1><a href="https://neue.cc/2009/09/13_200.html">.NET Reactive Framework メソッド探訪第三回:Subscribe</a></h1>
<ul class="date"><li>2009-09-13</li></ul>
<div class="entry_body"><p>メソッド探訪とか言いながら、ちっとも探訪してません。今回までが基礎知識で、Linq to Objectsで言ったらイテレータがどうこう、という段階。次回以降はメソッドを見ていきたいと思います。では、最後の予習ということで、Subscribe。SubscribeはIObservable&lt;T&gt;連鎖の終点となるもので(但し、別にSubscribeだけが終点というわけではない、FirstとかCountとか、終点になるものは他にもあります)ForEachのようなもの。戻り値はIDisposableで、イベント発生の監視を止めたい時はDisposeを呼ぶ。と、第一回の時に書きましたので、今回は別の方向から見ていきます。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    Observable.Range(1, 10).Subscribe(Observer.Create(
        (int i) =&gt; Console.WriteLine(i), // OnNext
        e =&gt; { throw e; }, // OnError
        () =&gt; Console.WriteLine(&quot;Completed&quot;) // OnCompleted
    ));

    Console.ReadLine();
}
</code></pre>
<p>今回はコンソールアプリで。結果は想像つくとおり、1から10、最後にCompletedを表示。Observable.RangeはEnumerable.Rangeと同じです。というか中身的にはEnumerable.Range.ToObservableで変換されているだけです。RepeatとEmptyも用意されているので、ちょっとしたメソッド確認用に便利に使えると思います。それにしてもコード、ゴチャゴチャしてますねえ、わけわかんない書き方してわざと難解にやってるんじゃないだろうかって感じですが、その通りです、ので、普通の書き方も下の方でちゃんと書きます。で、SubscribeはIObservable&lt;T&gt;のメソッドとして定義されています。IEnumerable&lt;T&gt;がGetEnumeratorを持つように、IObservableはSubscribeを持つ。そして、原則Subscribeの引数はIObserver&lt;T&gt;です。</p>
<pre><code class="language-csharp">public interface IObservable&lt;T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}

public interface IObserver&lt;T&gt;
{
    void OnCompleted();
    void OnError(Exception exception);
    void OnNext(T value);
}
</code></pre>
<p>インターフェイスなので直接生成することは出来ない。よってファクトリメソッドObserver.Createを用いて生成します。生成されるのは前回見たAnonymousEnumeratorと同じくinternalのジェネリッククラス「AnonymousObserver&lt;T&gt;」で、インターフェイスの各メソッドにデリゲートを直接放り込むだけの単純明快なものです。勿論、IObservable&lt;T&gt;を継承して自前の専用のものを用意しても構いませんが、クロージャを活かせば、自前で定義する意味など少しもありません。コンパイラの自動生成クラス任せでOK。</p>
<p>これの動作はメソッド名通りで、OnNextは値が来るたびに実行されるメソッド。OnCompletedは全て完了した時(FromEvent経由のものなど、実質無限リピート状態の場合は、Disposeが呼ばれた時)に実行されるメソッド。OnErrorは例外が発生した時に実行されるメソッド。発生した例外は原則catchされるので、再スローしたい時は、そのまんまですがthrow eの明示が必要です。</p>
<p>……それにしても面倒くさい。Observer.Createは。onNextだけが書ければいいんだよ！ってシーンにわざわざ空の式を書けとでも？（ちなみに空は()=&gt;{}です) 大体がして、推論出来ないから(int i)だとか、型を書かなければならないのもかったるい。というわけで、拡張メソッドが用意されています。</p>
<pre><code class="language-csharp">public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError, Action onCompleted);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError, Action onCompleted);
</code></pre>
<p>いっぱいありますけど、ようするに無視した部分は空のメソッドが代わりに埋められる、というだけの話。これを使えば、最初の例は、onNextだけにすると</p>
<pre><code class="language-csharp">Observable.Range(1, 10).Subscribe(i =&gt; Console.WriteLine(i));
</code></pre>
<p>と、簡潔明快に記述出来るわけです。メデタシメデタシ。</p>
<h2>過去記事</h2>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">.NET Reactive Framework メソッド探訪第一回:FromEvent</a><br />
<a href="http://neue.cc/2009/09/07_198.html" title="neue cc - .NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></p>
</div>
<h1><a href="https://neue.cc/2009/09/09_199.html">無限リピートの幸福</a></h1>
<ul class="date"><li>2009-09-09</li></ul>
<div class="entry_body"><p>Reactive Frameworkが、結構に無限リピートな感じなので、関連してC# Linqで<a href="http://ja.doukaku.org/197/lang/csharp/">どう書くにあった13日金曜日問題</a>を今更書いてみた。n番煎じ。</p>
<pre><code class="language-csharp">// 今日から2013年12月31日までの、13日の金曜日とその総数を表示してください。
// 「今日」を無限リピートという方針で書いてみたりして(総数は省略)
// 利点はTodayを変数として外側に定義する必要が無くLinq内に閉じ込められる
// Toを求めるのに足したり引いたりする必要がなく自然に書ける、の二つかしらん
// 「まで」という問いに対してTakeWhileで解答するのは自然で良いと思う

Enumerable.Repeat(DateTime.Now, int.MaxValue)
    .Select((d, i) =&gt; d.AddDays(i))
    .TakeWhile(d =&gt; d.Year &lt; 2014)
    .Where(d =&gt; (d.DayOfWeek == DayOfWeek.Friday) &amp;&amp; (d.Day == 13))
    .ToList()
    .ForEach(d =&gt; Console.WriteLine(d.ToShortDateString()));
</code></pre>
<p>TakeWhileが好きです。問題文に対して、自然に解答出来るような気がするので。「今日から(Repeat)」「2013年12月31日までの(TakeWhile)」「13日の金曜日(Where)」。実に自然に記述できる。いやまあ、Repeatが直感的かというと結構微妙なところではありますが。Rangeでfrom,toのほうが自然だろ常識的に考えて、というのも確かなんですけど、Rangeだとtoを作るのに計算式が必要ってのが、ちょっと違うかな、と。</p>
<p><a href="http://en.wikipedia.org/wiki/Pizza_(programming_language)">Pizza (programming language)</a>のexampleにもあるような、Streamを始めとして何かを無限リピートしてTakeWhileで終了条件を設定、というのはパターンとして結構幅広く使える、と思う。ある種のデザインパターン。イディオムイディオム。参考リンクは<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">C# 3.0 と while(true) と Iterator - NyaRuRuの日記</a>この辺り。</p>
<p>例えばVS2010から搭載されるEnumerable.Zipや、あとCycleを定義してみる。</p>
<pre><code class="language-csharp">// この二つを混ぜ合わす(VS2010で搭載されるZip関数)
var seq1 = Enumerable.Range(1, 10);
var seq2 = Enumerable.Range(10, 10);
Enumerable.Repeat(new { e1 = seq1.GetEnumerator(), e2 = seq2.GetEnumerator() }, int.MaxValue)
    .TakeWhile(t =&gt; t.e1.MoveNext() &amp;&amp; t.e2.MoveNext())
    .Select(t =&gt; t.e1.Current + t.e2.Current); // ここがZipのSelectorの部分
// foo,bar,hoge,foo,bar,hogeを無限に繰り返す
var elements = new[] { &quot;foo&quot;, &quot;bar&quot;, &quot;hoge&quot; };
var cycle = Enumerable.Repeat(elements, int.MaxValue).SelectMany(ar =&gt; ar);
</code></pre>
<p>Linqのお陰でかつてない勢いでint.MaxValueを使っているこの頃。Repeatも万能ですねえ。いやまあ、もう素直にAchiral使えよって話なんですが、標準メソッドのみで粘るのも面白くて。そういえばでついでなので<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>でもやってみた。</p>
<pre><code class="language-javascript">// JavaScriptはAddDaysがないので副作用全開でTodayを
// setHours(24)で翌日にしてしまう、という方針でやってみた

E.Repeat(new Date())
 .Do(&quot;$.setHours(24)&quot;)
 .TakeWhile(&quot;$.getFullYear() &lt; 2014&quot;)
 .Where(&quot;$.getDay() == 5 &amp;&amp; $.getDate() == 13&quot;)
 .ForEach(&quot;alert($)&quot;);
</code></pre>
<p>DoはReactive Frameworkにもありました。副作用を加えた上で素通しするメソッド。副作用は嫌なものです。汚いです。何が嫌かというと、動作を考えるのに見る範囲を広げなきゃいかんところかなあ。そしてLinqの何がいいかというと、見る範囲が物凄く限定される(ラムダ式一文だけを見ればいい)と思っている。だからLinq内でクロージャ(というか外部の変数をキャプチャして使う)もあんま好ましくないし、C#クエリ構文のletも好きじゃない。なるべくなら使いたくない。長文耐性なのは分かるけれど、カッコやインデントがなくてスマートだけれど、その分だけスコープが不明瞭になるという側面が否めない。まあ、letが必要なシチュエーションをSelectManyでやると、大抵はもっと奇怪になるのですけど。</p>
<p>んでまあ、この場合だとAddDaysのかわりにnew Date(year,month,day)で新しいのを作れば副作用なくSelectが使えるわけですが、ありきたりで面白くないと思ったので別な方向に走ってみた。というか、無限リピートは、無限リピートする何かに対して副作用全開で操作を加え続ける、という形の方が面白いというか実用的というか普通だとは思う。冒頭の例みたいなやつだと、別にRangeでよくね？って感じですし。Haskellじゃないんだから、潔癖症にならずに、副作用といかに楽しくお付き合いするかが大事なのですかね。</p>
<p>あ、ちなみに$は引数が一つの場合の省略記法です。こういった機能は<a href="http://ja.wikipedia.org/wiki/Scala">Scala</a>にもある。引数が一つのみの場合が大半なので、記述がグッと縮まるし、何よりも引数名を付ける必要がないのが嬉しい。C#でも使えるようになると嬉しいなあ、とずっと思ってるんですが中々どうして無理なんですかねえ、残念。</p>
</div>
<h1><a href="https://neue.cc/2009/09/07_198.html">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></h1>
<ul class="date"><li>2009-09-07</li></ul>
<div class="entry_body"><p>予定は常に変更されるもの、というわけで、今回はAnonymousEnumerableとAnonymousEnumeratorを見たいと思います。表に出てこない、internalのクラスな上に、内部でも全然使われていないので、見る必要はあんまりない。のですが、これと対になるAnonymousObservableとAnonymousObserverを見るにあたって、先に慣れ親しんだIEnumerable/Enumeratorで考えたほうが分かりやすかったので、これを先に考えます。</p>
<pre><code class="language-csharp">class AnonymousEnumerable&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator;
    public AnonymousEnumerable(Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator)
    {
        // 以下略
}

class AnonymousEnumerator&lt;T&gt; : IEnumerator&lt;T&gt;
{
    private Func&lt;T&gt; current;
    private Action dispose;
    private Func&lt;bool&gt; moveNext;

    public AnonymousEnumerator(Func&lt;bool&gt; moveNext, Func&lt;T&gt; current, Action dispose)
    {
        this.moveNext = moveNext;
        this.current = current;
        this.dispose = dispose;
    }

    public T Current
    {
        get { return this.current(); }
    }

    public bool MoveNext()
    {
        return this.moveNext();
    }
    
    // 以下略
}
</code></pre>
<p>Reflectorで見ちゃってるので、一部だけ(ライセンス！)。ただ、どれも一行なので見るまでもなく何をやってるのか想像付くと思います。 お馴染みのインターフェイスを実装しているだけですが、その実装を全てコンストラクタで受ける関数に任せています。ようするにこれはどういうことなのかというと、実例としてEnumerable.RepeatとSelectをAnonymousEnumerableで実装してみるとこうなります。</p>
<pre><code class="language-csharp">public static class Enumerable
{
    public static IEnumerable&lt;T&gt; Repeat&lt;T&gt;(T element, int count)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var index = 0;
            var current = default(T);
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; // MoveNext
                {
                    if (index == 0) current = element;
                    return (index++ &lt; count);
                },
                () =&gt; current, // Current
                () =&gt; { } // Dispose
            );
        });
    }
    
    // 実際のSelectは&lt;TSource,TResult&gt;ですが、都合により略
    public static IEnumerable&lt;T&gt; Select&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, T&gt; selector)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var enumerator = source.GetEnumerator();
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; enumerator.MoveNext(),
                () =&gt; selector(enumerator.Current),
                () =&gt; enumerator.Dispose()
            );
        });
    }
}
</code></pre>
<p>勿論、普通はyieldを使えばいいわけですが、もしyieldがなければ、こういう形で実装するのが簡潔でベスト、に見える。クロージャでコンパイラにクラス生成を任せているわけですねー。外部イテレータですが、外部のクラスに分割せず中に書けるため、すっきり分かりやすい。この発想はあったけどC#でやるという発想はなかったわ、というわけで結構感動しました。</p>
<p>そうそう、この仕組みは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>と丸っきり同じなのです。感動ってのは、私の基本方針は間違ってなかったんだ！の裏付けでの喜びなので不純です。そのJavaScriptでの実装はこんな感じ。</p>
<pre><code class="language-javascript">Linq.Object = function(getEnumerator)
{
    this.GetEnumerator = getEnumerator;
}

Linq.Enumerator = function(moveNext)
{
    this.Current = null;
    this.MoveNext = moveNext;
}

Repeat: function(element, count)
{
    return new Linq.Object(function()
    {
        var index = 0;
        return new Linq.Enumerator(function()
        {
            if (this.Current == null) this.Current = element;
            return (index++ &lt; count);
        });
    });
}

Select: function(selector)
{
    var source = this;
    selector = Linq.Utils.CreateFunctor(selector);

    return new Linq.Object(function()
    {
        var enumerator = source.GetEnumerator();
        var index = 0;

        return new Linq.Enumerator(function()
        {
            if (enumerator.MoveNext())
            {
                this.Current = selector(enumerator.Current, index++);
                return true;
            }
            else
            {
                return false;
            }
        });
    });
}
</code></pre>
<p>スコープが若干違うかなって感じですが、大体同じです。(Linq.ObjectはLinq.Enumerableに名前変えよう……)。JavaScriptだからこそ、yieldがなくてもスッキリ定義出来る！と思っていただけに、そっかあ、そういう手を使えば良かったのかと少しショックだったりして。ほんとC#は柔軟な言語で、むしろもうJavaScriptよりもLightWeightだよ！</p>
<p>さて、次回はAnonymousObservableとAnonymousObserverを見てみることにします。勿論、予定は未定です。ていうかSubscribeはどうした、というと、Subscribeの中身はAnonymousObserverなので全然横道にそれてません、大丈夫です、まだ一直線です。</p>
</div>
<h1><a href="https://neue.cc/2009/09/04_197.html">.NET Reactive Framework メソッド探訪第一回:FromEvent</a></h1>
<ul class="date"><li>2009-09-04</li></ul>
<div class="entry_body"><p>まず、リアクティブフレームワークとは何ぞや、ということなのですが今のところ<a href="http://www.infoq.com/jp/news/2009/07/Reactive-Framework-LINQ-Events">InfoQ: .NETリアクティブフレームワーク（Rx）がLINQ to Eventsを可能にする</a>の記事ぐらいしか情報はありません。.NET 4.0に含まれる(かもしれない)ということ、現在のところSilverlight Toolkitの単体テストのところにこっそりと配置されていること。それだけです。紹介も、記事中にもリンクされていますが<a href="http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html">unfold: Introducing Rx (Linq to Events)</a>の一連の記事ぐらいしかありません。これの前文が中々に素敵です。</p>
<blockquote>
<p>Buried deep in the bin folder of the Silverlight Toolkit Unit Tests is a hidden gem: The Rx Framework (System.Reactive.dll).  If you glanced quickly you’d miss it altogether but it’s one of the most exciting additions to the .NET framework since Linq.</p>
</blockquote>
<p>今のところ微妙にパッとしない(Parallelは簡単に使えるがゆえにインパクトが足らない)4.0の隠し玉はコレですね、間違いない。軽く触ってみたのですが、中々に感動的。Linq to Objects好きならば間違いなく琴線に触れます。C#3.0がコレクションの操作をforeachからLinqに変えてしまったように、.NET4.0はイベントもLinqに変わる。まさにLinq to Everywhere! Functional Reactive Programming!</p>
<h2>How to use</h2>
<p><a href="http://www.codeplex.com/Silverlight">Silverlight Toolkit</a>をダウンロードしてSource/Binaries/System.Reactive.dllを頂けば完了。ただし、これはそのままだとSilverlightのプロジェクトでしか動作しないので、その他ので利用したい場合は<a href="http://evain.net/blog/articles/2009/07/30/rebasing-system-reactive-to-the-net-clr">ここの記事</a>に示されているように、githubに公開されているコードを実行(Cecilのdllが必要、記事文中にリンクされています)して変換する必要があります。今回はとりあえず、Silverlightで試してみたいと思います。こちらはこちらで、<a href="http://www.microsoft.com/downloads/details.aspx?displaylang=ja&amp;FamilyID=9442b0f2-7465-417a-88f3-5e7b5409e9dd">Silverlight 3 Tools</a>のダウンロードが必要ですけれど。</p>
<h2>実例</h2>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication4.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>マウスの動きに円が追随する、という単純なものをSilverlightで作ってみました。移動は完全に追随するのではなく、座標が15で割り切れる位置の場合のみ移動としました。スナップすることをイメージしたつもりなのですが、動きがガクガクです。これは、マウス移動に完全に追随して全ての座標でイベントが発生するわけではない = 15で割り切れる座標を通過してもイベントが発生しない場合がある = 動きがガクガク。というわけで、スナップしたい場合はWhereで間引くのではなく、Selectで近傍座標に寄せるべきです、が、いやまあ、例なので……。</p>
<pre><code class="language-csharp">// XAMLではなく全部コード上に書いたのは両方を張るのが面倒だから……
// 内容はCanvasとEllipseを配置するというもので、本筋とは関係ありません
InitializeComponent();
var canvas = new Canvas { Background = new SolidColorBrush(new Color {A=255, R = 100, G = 100, B = 100 }) };
var ellipse = new Ellipse { Height = 30, Width = 30, Fill = new SolidColorBrush(Colors.Orange) };
canvas.Children.Add(ellipse);
this.Content = canvas;

// FromEventはイベント発火がトリガとなってLinq発動
// 後段に送られるのはEvent&lt;T&gt;というもので、
// SenderとEventArgsという読み取り専用プロパティを持つクラス
var canvasMove = Observable.FromEvent&lt;MouseEventArgs&gt;(canvas, &quot;MouseMove&quot;)
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Where(p =&gt; (p.X % 15 == 0) || (p.Y % 15 == 0))
    .Subscribe(p =&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    });

// Subscribeの戻り値の型はIDisposable
// Disposeを呼ぶと登録したイベントをデタッチすることが出来る
// デタッチしないなら取得する必要は特にはない
// canvasMove.Dispose();
</code></pre>
<p>MouseMoveでイベントが発火する度にLinqを通る。なるほど、イベントがリストに、見える。イベントを無限リスト生成として捉えることで、イベントに対してLinq操作が可能になった。ObserverパターンとIteratorパターンは同じだったんだよ！なんだってー！みたいなノリがある。もう少し丁寧に見ると、Observable.FromEventでイベントをPush型の無限リストに変換。戻り値はIObservable&lt;T&gt;。イベント発火時に後段に流れてくるのはEvent&lt;T&gt;。これは通常のイベント登録時に使うsenderとeventArgsをラップしただけの単純なもの。あとはIObservableに用意されているメソッド(Select, Where, TakeWhileなどお馴染みのものから、Delay, WaitUntilなどイベント用の目新しいメソッドなど多数)を繋げて、最後にSubscribe。このSubscribeは、つまり通常のイベント登録時のメソッド本文の役割を果たす。Linqで言ったらForEachのようなもの。Subscribeのオーバーロードも幾つかあるのですが、それはまた後日。</p>
<pre><code class="language-csharp">// つまるところ、以下のコードと同じだったりはする
// ただ、IObservable&lt;T&gt;は通常のイベント登録では無理な複雑な操作が簡単、
// そして何よりも、このような単純なコードでもそんなに複雑になっていない！
canvas.MouseMove += (sender, e) =&gt;
{
    var pos = e.GetPosition(canvas); // Select
    if (!(pos.X % 15 == 0 || pos.Y % 15 == 0)) return; // Where
    ellipse.SetValue(Canvas.LeftProperty, pos.X - ellipse.Width / 2);
    ellipse.SetValue(Canvas.TopProperty, pos.Y - ellipse.Height / 2);
};
</code></pre>
<p>通常のイベント登録と対比してみると分かりやすいかしらん。FromEventではMouseEventArgsという型を明示する必要があるのがカッタルイ。推論は偉大。が、しかし、IObservableが複雑な操作が可能なのに対し、イベントに追加では直球なものしか書けない。また、複雑な操作が可能なわりには、FromEventは驚くほどシンプルに書ける。シンプルな操作でも(記述するのに)重たくない、というのは特筆すべきことじゃあないでしょうか。</p>
<pre><code class="language-csharp">// stringを避けたこういう登録方法もあるけれど、面倒なうえに警告出る
Observable.FromEvent((EventHandler&lt;MouseEventArgs&gt; h) =&gt; new MouseEventHandler(h),
        h =&gt; canvas.MouseMove += h, // addHandler
        h =&gt; canvas.MouseMove -= h) // removeHandler
    .Subscribe(e =&gt; Debug.WriteLine(e.EventArgs.GetPosition(canvas)));
</code></pre>
<p>ところで、イベント名をstringで書くのはどうよ、ていうかJavaScriptのaddEventHandlerみたいで嫌だよね？ね？リファクタリング効かないわ、IntelliSenseも動かないわでロクなことがない。というわけで、FromEventのオーバーロードを見ると、ちゃんと普通に登録する方法も用意されてはいる。一応、用意、されては、いる。が、しかし、あんまりだー。あんまりすぎるー。流れてくるEventhandler&lt;MouseEventArgs&gt;をMouseMoveが受け取ってくれないので、第一引数でMouseEventHandlerに変換する(ところで警告が消せないのですが、警告無しで処理する方法ってあるのかしらん)。あとは、addとremoveの登録。長ったらすぎてこれはダメぽ。確かに、こんなんなら、stringでいいです……。</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/SilverlightApplication3.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre><code class="language-csharp">// 普段あまり書かないMouseEventArgsとかいう型定義は書きにくいし
// メソッド名もstringで書くのはミスが出がち、ということで
// 拡張メソッドでイベント取り出し用のメソッドを予め作っておくと良い
public static IObservable&lt;Event&lt;MouseEventArgs&gt;&gt; GetMouseMove(this UIElement elem)
{
    return Observable.FromEvent&lt;MouseEventArgs&gt;(elem, &quot;MouseMove&quot;);
}

// マウスの軌跡を1秒後に描画します
canvas.GetMouseMove()
    .Select(e =&gt; e.EventArgs.GetPosition(canvas))
    .Delay(1000)
    .Subscribe(p =&gt;Dispatcher.BeginInvoke(()=&gt;
    {
        ellipse.SetValue(Canvas.LeftProperty, p.X - ellipse.Width / 2);
        ellipse.SetValue(Canvas.TopProperty, p.Y - ellipse.Height / 2);
    }));
</code></pre>
<p>汚い部分は隔離！ということで、拡張メソッドに退避してやると、美しく書ける。いやまあ、この辺は全部<a href="http://themechanicalbride.blogspot.com/2009/07/developing-with-rx-part-1-extension.html">unfold: The Joy of Rx: Extension Events</a>に書いてあることなのですけど。んで、デモ的にもう少し面白げがあったほうがいいかな、と思ったのでDelayを足してみました。1秒後にマウス移動の軌跡を描画します。グルグルーっとマウス動かして止めてみてください。スムーズ、とは言い難いですね、しょんぼり。記述も、Delayを足すだけ。と言いたかったんですがBeginInvokeかあ、これどーにかなる方法ないかなあ。</p>
<h2>次回</h2>
<p>全10回ぐらいで、全部のメソッドを紹介するつもりです。私が理解できればの話ですが。ちょこちょこと実例的なものも交えていきたいと思います。私が使いこなせればの話ですが。というわけで、次回はSubscribeのオーバーロードの紹介にしたいと思います。Reactive Frameworkならではの魅力、に関してはもう少し先になってしまいそう。少し飛ばして、非同期連結の話なんかを先に持ってきた方が良いかなあ。</p>
</div>
<h1><a href="https://neue.cc/2009/08/30_196.html">3桁到達</a></h1>
<ul class="date"><li>2009-08-30</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/xitoauthusers.jpg">
</p>
<p>開発者用のOAuth管理ページで認証ユーザー数が見れるのですが(「誰が」までは分からないので安心してください)、いつのまにやらユーザー数が100を超えていました。三桁！奇跡的ですね。はてな同期云々とかフォトライフ云々は壊滅的な状態なので。世の中そんなものです。ついでにこのサイトのアクセス数も壊滅的だったりはします。成り行きでプログラミング系サイトに転換してから半年、以上は経つ感じですが、伸びもせず縮みもせず、ずっと低調をキープ。サイトの内容がガラッと変わったのにアクセス平均が変わらないってのも面白いですけど。検索サイトからのアクセスがほとんどなので、検索キーワードが入れ替わって、でも流入人口は変わらずという。あー、まあ、少し増えた、かな。つまりかわりに常連的な人口が減った、と。おお、虚しい！悲しい！RSSリーダー登録数も伸びないしね。しょぼーん。</p>
<p>ゲーム系サイトへは、XNAで返り咲きしたいとこっそり思ってます。XNAは使用言語がC#だからね。C#好きーなのです、私。積みタスクを全部消化したらXNAやりたいんですが中々どうして……。 そういえばインディーズゲーム(XBIG)を完全スルー状態なのはぶっちけ（略）</p>
<p>fromにクライアント名が出るようになってからは、googleのサイト検索で利用具合が見つかるので、毎日<a href="http://www.google.co.jp/search?q=site%3Atwitter.com%20xboxinfotwit&amp;hl=ja&amp;lr=lang_ja&amp;safe=off&amp;rlz=1B5GGGL_jaJP296JP296&amp;sa=G&amp;num=100&amp;output=search&amp;tbs=qdr:d&amp;tbo=1" title="site:twitter.com xboxinfotwit - Google 検索">24時間以内の結果</a>を眺めていたりします。見ていて思うというか教訓は、デフォルト設定大事ってことでしょうかね。カスタマイズせずそのまま、カスタマイズする場合も、デフォルトを残しつつ細部を変える、という感じなので、デフォルトの投稿文はちゃんとしたものを用意しなきゃダメなんですね。当たり前といえば当たり前なのですけど、この辺はてなついったー同期ツールは大失敗していて、どうせカスタマイズするだろうと踏んで、書式のサンプルとばかりにゴテゴテのものをデフォルトにしてしまったので……。反省。</p>
<p>あと、デフォルトでは「プレイ中タイトルの状況が変わった時の投稿」はオフにしているのですが、意外とこれをオンにする人が多かったのも驚き。これオンにすると物凄い勢いで投稿されるんですよ。更新間隔を5分にすると、例えばGoW2のHordeすると、WAVE44,45,46...と、全部のWAVE投稿するんじゃないか、最新50個の投稿が全部XboxInfoTwit経由になってますが大丈夫？みたいなことになる。こういう滅茶苦茶なことが出来るのはローカルで動くツールならでは、なのですが(ウェブサービス系じゃあ、ちいと無理ですね、秋のTwitter対応が仮に実績やプレイ状況の投稿に対応するとしても、ここまでの連投は無理かと)フォロワーの目からどうなのか、というと、まあ、分からにゃい。いや、本人の満足が一番だと思いますよ。一日のプレイ後に投稿を眺めると、状況の変化がよく見えて結構楽しかったりはします。お薦めはしませんけどお薦め。別アカでやるなら何も問題なくお薦め。</p>
</div>
<h1><a href="https://neue.cc/2009/08/27_195.html">JavaScriptで要素追加するやり方</a></h1>
<ul class="date"><li>2009-08-27</li></ul>
<div class="entry_body"><p>ド素人がjQueryとprototype.jsではどう書くのかな、と思っただけです。メジャーな両者ですが実はまともに使ったことがないのです。困ったことに。しょうがないので見よう見まねで書く。</p>
<pre><code class="language-javascript">&lt;!-- このselectにoptionを一個追加する --&gt;
    
&lt;select id=&quot;selectID&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;hugahuga&lt;/option&gt;
&lt;/select&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

    // 素のJavaScriptその1(古臭いというか微妙な……)
    var option = new Option(&quot;要素&quot;, &quot;属性&quot;);
    var select = document.getElementById(&quot;selectID&quot;);
    select.options[select.options.length] = option;

    // 素のJavaScriptその2(これはダルい)
    var option = document.createElement(&quot;option&quot;);
    option.setAttribute(&quot;value&quot;, &quot;属性&quot;);
    option.appendChild(document.createTextNode(&quot;要素&quot;));
    document.getElementById(&quot;selectID&quot;).appendChild(option);

    // みんな大好きjQuery
    $(&quot;&lt;option&gt;&quot;).attr({ value: &quot;属性&quot; }).text(&quot;要素&quot;).appendTo(&quot;#selectID&quot;);

    // 何だかんだで好きなprototype.js
    var option = new Element(&quot;option&quot;, { value: &quot;属性&quot; }).update(&quot;要素&quot;);
    $(&quot;selectID&quot;).insert(option);

    // linq.js + linq.xml.jsの関数型構築
    var option = X.Elem(&quot;option&quot;, X.Attr(&quot;value&quot;, &quot;属性&quot;), &quot;要素&quot;);
    X.ID(&quot;selectID&quot;).Add(option);
    
&lt;/script&gt;
</code></pre>
<p>素のJavaScriptその1はねーよ、というわけで、その2をいかにスマートにやるかという話。だと思う。jQueryのappendToが合理的というか便利なのは分かるけど、キモく感じてしまう。んで、どれが好きかっていたら、当然自分で作ってる<a href="http://neue.cc/2009/04/04_145.html" title="neue cc - linq.js - JavaScript用LINQライブラリ">linq.js</a>のが一番好きですよ(笑)</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/selectbox.jpg">
</p>
<pre><code class="language-javascript">// linq.js + linq.xml.js
var options = E.RangeTo(1, 12).Select(function(i)
{
    return X.Elem(&quot;option&quot;, X.Attr(&quot;value&quot;, i), i + &quot;月&quot;);
});
X.ID(&quot;selectID&quot;).Add(options);

// prototype.js
var options = $R(1, 12, false).map(function(i)
{
    return new Element(&quot;option&quot;, { value: i }).update(i + &quot;月&quot;);
});
var elem = $(&quot;selectID&quot;);
options.each(function(e) { elem.insert(e) });
</code></pre>
<p>X.Elem()もAdd()もLinqオブジェクト/可変長配列を受け取れるので、まとめてドバーっと追加が結構楽かな、と思います。eachとかじゃなく、そのまんま追加出来るってのが大事。上の例だと、prototype.jsではmapでoptionsを作らずそのまんまeachでinsertしちゃえばいいぢゃん、というのはそのとーりなんですが(2回もループ回ることになるしね、あ、linq.jsのは遅延評価しているのでループはAddで呼び出される時の1回しか回りません)、配列(的なもの)が既にある状態ってのは、結構ありますよね？</p>
<p>と、何故か突然アピールしてますがlinq.xml.jsは作りかけで放置しているので足りない関数がいっぱいあるんですけどね！</p>
</div>
<h1><a href="https://neue.cc/2009/08/25_194.html">enumの日本語別名とか三項演算子ネストとか</a></h1>
<ul class="date"><li>2009-08-25</li></ul>
<div class="entry_body"><p>enumのToStringで日本語名になって欲しいというケースはとてもあるある。<a href="http://igeta.cocolog-nifty.com/blog/2007/11/enum_string.html">enum に文字列の属性を: いげ太のブログ</a>と<a href="http://d.hatena.ne.jp/siokoshou/20080124">2008-01-24 - 当面C#と.NETな記録</a>の記事を見て、今まで拡張メソッドで処理することが多かったのですが、やっぱり見た目は属性のほうがスッキリするなあ、と思った。記述が本体と離れないのが良いですよね。処理速度とか、そんなに頻繁に繰り返し繰り返し呼ぶものでもないしリフレクション上等！それ気にしたらSerializeとか出来ない！とか思ったので、基本は属性で処理することにしてみた。</p>
<pre><code class="language-csharp">enum Fruit
{
    [AliasName(&quot;ブドウ&quot;)]
    Grape,
    [AliasName(&quot;リンゴ&quot;)]
    Apple,
    [AliasName(&quot;オレンジ&quot;)]
    Orange
}

static void Main(string[] args)
{
    var fruit = Fruit.Orange;
    Console.WriteLine(fruit.ToAliasName());
}
</code></pre>
<p>こんな感じに定義してこんな感じに使う、と。定義もスッキリ、呼び出し時もToString的に拡張メソッドでスッキリ。</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
public sealed class AliasNameAttribute : Attribute
{
    public string AliasName { get; private set; }

    public AliasNameAttribute(string aliasName)
    {
        AliasName = aliasName;
    }
}

public static class Ext
{
    // どうしてもメソッドチェインを崩したくない人用
    public static T ThrowIf&lt;T&gt;(this T value, Func&lt;T, bool&gt; predicate, Exception exception)
    {
        if (predicate(value)) throw exception;
        else return value;
    }

    public static string ToAliasName(this Enum value)
    {
        return value.GetType()
            .GetField(value.ToString())
            .GetCustomAttributes(typeof(AliasNameAttribute), false)
            .Cast&lt;AliasNameAttribute&gt;()
            .FirstOrDefault()
            .ThrowIf(a =&gt; a == null, new ArgumentException(&quot;属性が設定されていません。&quot;))
            .AliasName;
    }
}
</code></pre>
<p>ドットが縦にならんでると何だか楽しい。というわけで、チェーンを崩さずに例外を放り投げるための拡張メソッドThrowIfを用意してみた。nullが邪魔！邪魔！nullが出現するせいで一個変数を置いてnullチェックかまさなきゃいけない！というシーンは多いので、predicateじゃなくてnull限定決め打ちでも良いぐらいかもかも。とにかくnull撲滅。まあ、この場合はFirstOrDefaultじゃなくてFirstにすれば、Firstが例外を吐いてくれるのですけど、一応ちゃんとメッセージ用意したいとか、ありますよね？ね？</p>
<pre><code class="language-csharp">// 三項演算子のチェーンを崩さないためにダミーの型を返して例外を投げる
static T Throw&lt;T&gt;(Exception exception)
{
    throw exception;
}

static string Test(Fruit fruit)
{
    return (fruit == Fruit.Apple) ? &quot;あぷる&quot;
         : (fruit == Fruit.Grape) ? &quot;ぐれえぷ&quot;
         : (fruit == Fruit.Orange) ? &quot;おれんじ&quot;
         : Throw&lt;string&gt;(new ArgumentException(&quot;引数ダメぽ！&quot;));
}
</code></pre>
<p>三項演算子を延々とネストしてコロンを前置にするのが好き、と<a href="http://neue.cc/2009/08/21_190.html" title="neue cc - ネストした三項演算子の書き方">以前に書いた</a>のですが、そうすると、最後にdefault的なものを書く必要があって困る。&quot;&quot;とか0とかでお茶を濁さずに、例外を吐きたいのですが、ネスト三項演算子では例外を吐けない。困った困った。というわけでThrowという補助メソッドを用意してみた。ただ例外を吐くだけメソッド。おー。これでもう大量にネストしても大丈夫！万歳！三項演算子でネストしよう！ついでにネスト時のコロンは前置にしよう！の会。</p>
<h2>使用しないでください？</h2>
<p>ところで、EnumのToStringはIntelliSenseに使用しないでください、が出てきてビビる。んが、よくよく眺めてみると……</p>
<pre><code class="language-csharp">public override string ToString();
[Obsolete(&quot;The provider argument is not used. Please use ToString().&quot;)]
public string ToString(IFormatProvider provider);
public string ToString(string format);
[Obsolete(&quot;The provider argument is not used. Please use ToString(String).&quot;)]
public string ToString(string format, IFormatProvider provider);
</code></pre>
<p>ObsoleteなのはIFormatProviderが絡んでるものだけで、普通のToStringは使用していいんでないのん？<a href="http://blogs.wankuma.com/jeanne/archive/2006/04/04/22239.aspx" title="文字列の列挙体">文字列の列挙体</a>←ここのコメント欄が白熱していたのを見て、どうなのかなー、と思っているのですが、どうなんでしょうか。いやほんと。</p>
</div>
<h1><a href="https://neue.cc/2009/08/24_193.html">WSH用にCOMのIntelliSenseを自動生成する</a></h1>
<ul class="date"><li>2009-08-24</li></ul>
<div class="entry_body"><p>本題、の前にJavaScript用のIntelliSenseの作成方法について。以前、<a href="http://neue.cc/2009/06/06_164.html" title="neue cc - 最もタメになる「初心者用言語」はVisualStudio(言語?)">linq.jsにIntelliSense用ファイルを追加した時</a>に利用法を書きましたが、今回はvsdocの作成方法を、ざっと書きます。まずVS2008 SP1とパッチを適用する。hoge.jsに対しhoge-vsdoc.jsを用意するとhoge.jsのかわりにhoge-vsdoc.jsがIntelliSense用に読み込まれる。IntelliSenseでVSが見ているのはメソッド名と引数だけなので、コードの中身はなくてもいい。例えば本来は存在するがprivateメソッドのつもりのものは、vsdoc.js側に書かなければIntelliSenseには表示されない。C#と同様に関数にはXMLドキュメントコメントを記述することが出来る。記述箇所はC#とは異なり開始の波括弧の直下。ドキュメントコメントのタグで現在機能しているものはsummary, params, returnsのみ。特に重要なのはreturns typeで、これにprototypeが存在する関数(ようするにクラスですなー)を指定することで戻り値の型をVSに認識させ、IntelliSenseを働かせることが出来る。ちなみに、ただのオブジェクトだと認識してくれない。</p>
<pre><code class="language-javascript">function Hoge(aaa, bbb)
{
    /// &lt;summary&gt;hogehogehogehoge&lt;/summary&gt;
    /// &lt;param name=&quot;aaa&quot; type=&quot;String&quot;&gt;a!a!a!a!a!&lt;/param&gt;
    /// &lt;param name=&quot;bbb&quot; type=&quot;Optional:Boolean&quot;&gt;b?b?b?b?b?&lt;/param&gt;
    /// &lt;returns type=&quot;Number&quot;&gt;&lt;/returns&gt;
}
</code></pre>
<p>基本はこんな感じ。引数の省略や、型が目で見て分かるので大分書きやすくなります。 で、<a href="http://neue.cc/2009/08/02_182.html" title="neue cc - linq.js :: Next">いつぞやかに作成中</a>とか言っていた通りにlinq.jsをWSH対応させようとしているわけですが、IntelliSense書きの量が思ったよりも膨大なわけです。実は最初は普通に手書きしてました。一応勉強も兼ねて書写みたいなノリで。ですが、あまりにも手間かかりすぎるので自動生成することにしました。こんなの人力でやるもんじゃないですよ。微調整はどちらにせよ必要なのですか、大枠だけでも書きだされていると物凄く楽になる。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    // add reference and replace dll path
    var assembly = Assembly.LoadFrom(@&quot;Interop.IWshRuntimeLibrary.dll&quot;);
    var types = assembly.GetTypes();

    var enums = types
        .Where(t =&gt; t.IsEnum)
        .OrderBy(t =&gt; t.Name)
        .Select(t =&gt; string.Format(&quot;{0}: \r\n{{\r\n{1}\r\n}}&quot;,
            t.Name,
            Enum.GetNames(t).Select(s =&gt; string.Format(&quot;\t{0}: {1}&quot;, s, (int)Enum.Parse(t, s))).Join(&quot;,\r\n&quot;)));

    var classes = types
        .Where(t =&gt; t.IsClass)
        .Select(type =&gt;
        {
            var bindingFlag = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;

            var properties = type.GetProperties(bindingFlag)
                .OrderBy(pi =&gt; pi.Name)
                // .Select(pi =&gt; string.Format(&quot;{0}: {1}&quot;, pi.Name, pi.PropertyType.Name
                .Select(pi =&gt; string.Format(&quot;{0}: null&quot;, pi.Name));

            var methods = type.GetMethods(bindingFlag)
                .Where(mi =&gt; !mi.IsSpecialName &amp;&amp; mi.Name != &quot;GetEnumerator&quot;)
                .Select(mi =&gt; new { mi.Name, Parameters = mi.GetParameters(), ReturnType = mi.ReturnType.Name })
                .OrderBy(t =&gt; t.Name)
                .Select(t =&gt; string.Format(&quot;{0}: function({1})\r\n{{\r\n{2}\t/// &lt;returns type=\&quot;{3}\&quot;&gt;&lt;/returns&gt;\r\n}}&quot;,
                    t.Name,
                    t.Parameters.Select(pi =&gt; pi.Name).Join(&quot;, &quot;),
                    t.Parameters.Select(pi =&gt; string.Format(&quot;\t/// &lt;param name=\&quot;{0}\&quot; type=\&quot;{1}{2}\&quot;&gt;&lt;/param&gt;\r\n&quot;,
                            pi.Name,
                            (pi.IsOptional) ? &quot;Optional:&quot; : &quot;&quot;,
                            pi.ParameterType.Name.Replace(&quot;Void&quot;, &quot;void&quot;).Replace(&quot;Int32&quot;, &quot;Number&quot;)))
                        .Join(&quot;&quot;),
                    t.ReturnType.Replace(&quot;Void&quot;, &quot;void&quot;).Replace(&quot;Int32&quot;, &quot;Number&quot;)));

            var result = properties.Concat(methods).Join(&quot;,\r\n&quot;);
            return string.Format(&quot;{0} = function() {{ }}\r\n{0}.prototype =\r\n{{\r\n{1}\r\n}}&quot;,
                Regex.Replace(type.Name, &quot;Class$&quot;, &quot;&quot;),
                result.Split(new string[] { &quot;\r\n&quot; }, StringSplitOptions.None).Select(s =&gt; &quot;\t&quot; + s).Join(&quot;\r\n&quot;));
        });

    var name = assembly.GetName().Name.Split('.').Last();
    File.WriteAllText(name + &quot;_enum.js&quot;, string.Format(&quot;{0}Enum =\r\n{{\r\n{1}\r\n}}&quot;, name,
        enums.Join(&quot;,\r\n&quot;).Split(new string[] { &quot;\r\n&quot; }, StringSplitOptions.None).Select(s =&gt; &quot;\t&quot; + s).Join(&quot;\r\n&quot;)), Encoding.UTF8);
    File.WriteAllText(name + &quot;_class.js&quot;, classes.Join(&quot;\r\n\r\n&quot;), Encoding.UTF8);
}

static string Join&lt;T&gt;(this IEnumerable&lt;T&gt; source, string separator)
{
    var index = 0;
    return source.Aggregate(new StringBuilder(),
            (sb, o) =&gt; (index++ == 0) ? sb.Append(o) : sb.AppendFormat(&quot;{0}{1}&quot;, separator, o))
        .ToString();
}
</code></pre>
<p>参照設定で対象のCOMを読み込んで、一旦ビルド。生成されてるInterop.hoge.dllを読み込んで解析、という流れをとってみました。もっとマシなやり方があれば教えてください。コードは、んーと、string.Formatがクドくて見難いですね！ 最初はVSのフォーマッタに後で手動でかければいいや、と思ってたのを、出力状態でちゃんとフォーマットされてるようにと継ぎ接ぎしてたら酷いことに。一回文字列にしたものを改行でバラして再生成とか笑えない。こういうの、HTML/XMLが対象なら何も考えなくてもLinq to Xmlで綺麗に書けるのになあ……。 それ以外はまぁ、こんなものかしらんって感じでしょうか？ リフレクションが絡むとLinq大活躍。Selectがネストしまくるのでクエリ構文の出番はない。リフレクションは掘り進める都合上、ネストが深くなるのでLinqがなかったら、と思うとゾッとします。最近はforの二重ループですらウエエ、とか思ってしまうので。</p>
<pre><code class="language-javascript">IWshRuntimeLibraryEnum =
{
    IOMode:
    {
        ForReading: 1,
        ForWriting: 2,
        ForAppending: 8
    }
}

Folder = function() { }
Folder.prototype =
{
    Name: null,
    ParentFolder: null,
    Drive: null,
    CreateTextFile: function(FileName, Overwrite, Unicode)
    {
        /// &lt;param name=&quot;FileName&quot; type=&quot;String&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Overwrite&quot; type=&quot;Optional:Boolean&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Unicode&quot; type=&quot;Optional:Boolean&quot;&gt;&lt;/param&gt;
        /// &lt;returns type=&quot;TextStream&quot;&gt;&lt;/returns&gt;
    }
}
</code></pre>
<p>一部抜粋ですが、こんなようなデータが出力されます。プロパティが全部nullなのは、ここに未指定のものが記述されているとIntelliSenseがエラー起こしてしまうから。例えばDrive: new Drive()で戻り値の型指定が可能といえば可能なのですが、出現位置の上下が問題になってくるので結構面倒くさい。ようはFolderよりも上にDriveがあれば関数が存在するので大丈夫だけど、下にあれば存在しないのでエラー。当たり前といえば当たり前なのですが、ダミーでのIntelliSense作りとしては面倒な問題でして。 この辺は素直に諦めて全部nullで型連鎖を止めてしまうのがお気楽といえばお気楽。あと、Dateはnew Date()にしてもDate.prototypeにしても型指定出来なかったりする問題もある。これは今のところ対処不能。</p>
<p>そんなわけで、linq.js + WSHはわりと順調に作成中なので期待しないでも待っててください。IntelliSenseというだけじゃなく、JScriptではバイト配列が扱いにくいので、扱いやすく出来るような補助メソッドを用意したりとか色々やってたらいつになっても終わらないー。<a href="http://gyazo.com/5707f82cea9dc9af36ee5f825c5d56b7.png" title="5707f82cea9dc9af36ee5f825c5d56b7.png (PNG 画像, 632x672 px)">例としてWSHでMD5を作る</a>、とか。.NET Frameworkを通しているのでSHA1でも何でもいけます。これでWSHでwsse認証通してAtomAPIで投稿、とか出来ますね。まあ、もうC#でいいぢゃん、って気がかなりしなくもないですけど、うーん。C#4.0からdynamicが追加されるからCOM連携も楽になるしねえ。ただサイドバーガジェットに使うとか、JavaScriptの用途はまだまだあるもん！(これもSilverlightでやれば？って話がなくもないので、うーん)</p>
</div>
<h1><a href="https://neue.cc/2009/08/23_192.html">簡易文字列置換</a></h1>
<ul class="date"><li>2009-08-23</li></ul>
<div class="entry_body"><pre><code class="language-csharp">static void Main(string[] args)
{
    // {}で括った部分を(ラムダ式/匿名型)を使って置換する
    var input = &quot;食べ物は{tabemono}で飲み物は{nomimono}&quot;;
    var r1 = input.Replace(new { tabemono = &quot;たこ焼き&quot;, nomimono = &quot;コーラ&quot; });
    var r2 = input.Replace(tabemono =&gt; &quot;たこ焼き&quot;, nomimono =&gt; &quot;コーラ&quot;);
}
</code></pre>
<p>前も書いたというか<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">JavaScriptでやりました</a>が、それのC#移植。簡易テンプレート的な文字列置換。ラムダ式版と匿名型版の二つでやってみました。ラムダ式だと、見た目が少し短くて何となく格好良いのですが、変数名の入力時にIntelliSenseが動いてしまうので結構鬱陶しかったり。匿名型のほうはObjectを受け取る関数なので、危なっかしいのが嫌ですね……。</p>
<pre><code class="language-csharp">static class Extensions
{
    // 正規表現の|でキーを連結して辞書から置換
    private static string Replace(string input, Dictionary&lt;string, string&gt; dict)
    {
        var pattern = string.Format(&quot;{{({0})}}&quot;, dict.Select(kvp =&gt; Regex.Escape(kvp.Key)).ToJoinedString(&quot;|&quot;));
        return Regex.Replace(input, pattern, m =&gt; dict[m.Groups[1].Value]);
    }

    /// &lt;param name=&quot;anonymousType&quot;&gt;{pattern = &quot;replacement&quot;}&lt;/param&gt;
    public static string Replace(this string input, Object anonymousType)
    {
        var dict = anonymousType.GetType()
            .GetProperties()
            .ToDictionary(pi =&gt; pi.Name, pi =&gt; pi.GetValue(anonymousType, null).ToString());
        return Replace(input, dict);
    }

    /// &lt;param name=&quot;exprs&quot;&gt;pattern =&gt; &quot;replacement&quot;&lt;/param&gt;
    public static string Replace(this string input, params Expression&lt;Func&lt;Object, string&gt;&gt;[] exprs)
    {
        var dict = exprs.ToDictionary(e =&gt; e.Parameters[0].Name, e =&gt; e.Compile().Invoke(null));
        return Replace(input, dict);
    }

    // 文字列連結補助メソッド(これないとシンドイので)
    public static string ToJoinedString&lt;T&gt;(this IEnumerable&lt;T&gt; source, string separator)
    {
        var index = 0;
        return source.Aggregate(new StringBuilder(),
                (sb, o) =&gt; (index++ == 0) ? sb.Append(o) : sb.AppendFormat(&quot;{0}{1}&quot;, separator, o))
            .ToString();
    }
}
</code></pre>
<p>速度は、匿名型版のほうが圧倒的に速いです。100000回の繰り返しが匿名型だと2秒なのに対してラムダ式版は30秒かかった。Compile().Invokeがアレなんですかねえ。ちなみに、string.Formatでふつーにやった場合は0.03秒でした。まー、でも、メール雛型の置換に、とかちょっとしたことにそこそこ便利に使えるかなー、とは思いつつもっと効率考えてちゃんと組んだ方がいい気もする。</p>
<p>ラムダ式から取り出すのは<a href="http://d.hatena.ne.jp/NyaRuRu/20071211/p3">C# 3.0 における疑似 Map 生成リテラル - NyaRuRuの日記</a>から、匿名型はprototype.jsとかPHPのstrtrとか色々。あと<a href="http://d.hatena.ne.jp/NyaRuRu/20080706/p1">ややニッチな Anonymous Types の使い方をまとめてみる (C# 3.0) - NyaRuRuの日記</a>です。</p>
</div>
<h1><a href="https://neue.cc/2009/08/22_191.html">ver 0.0.0.3</a></h1>
<ul class="date"><li>2009-08-22</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>拡張子が大文字だとアップロード出来なかったので直しました。XboxInfoTwitの時も同じのやってたのにまたかよって感じです。拡張子判定部分は、ちゃんとIgnoreCaseにしたしあれえ？と思ってたんですがContentType作るところで漏れがあって、ウッカリ。てへ。</p>
<p>まあ、そんなこんなでちゃんと一眼レフも買いました。わざわざこのためだけに！<a href="http://f.hatena.ne.jp/neuecc/" title="neuecc's fotolife">neuecc's fotolife</a> 。それで、しかし撮るものが悲しいほど無いんですよね、やっぱり。とはいえ、自分で撮って自分で上げてかないと、何をどうすれば良くなるのか分からないので、室内写真で栄える何かを探し中です。現在は多肉植物でも育てようかな、と思ってるんですがどうでしょうかねえ。</p>
<p>ちなみに現在までのDL数は余裕で一桁。べ、別に悲しくないもん！ そういえばこの半自動ってぶっちゃけ機能的にいらなくね？むしろフォルダ監視で自動化したほうがよくね？とも思ってきたので、まあ、そのうち。そのうち。</p>
</div>
<h1><a href="https://neue.cc/2009/08/21_190.html">ネストした三項演算子の書き方</a></h1>
<ul class="date"><li>2009-08-21</li></ul>
<div class="entry_body"><p><a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1027163420" title="javaプログラムの組み方がわかりませんorz 無理な課題を学校で出されました(´･_･... - Yahoo!知恵袋">javaプログラムの組み方がわかりませんorz 無理な課題を学校で出されました(´･_･... - Yahoo!知恵袋</a></p>
<p>「小学生向けの四則演算の計算練習のプログラムを考える」……？ 回答のJavaコードが長くてよくわからにゃい。ぽりもふぃずむって何？</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/condoperator.jpg">
</p>
 
これでおｋ。最近、三項演算子の:は後置が普通だけど、前置にすると[F#のパターンマッチ](http://msdn.microsoft.com/en-us/library/dd233242(VS.100).aspx)みたいで格好良くね？とか思うので、開き直って前置にしたいです。これはコーディング規約に載せるべきですね(笑) あと三項演算子の、うにゃ、条件演算子の条件は必ずカッコで括る派。
</div>
<h1><a href="https://neue.cc/2009/08/18_189.html">LINQ to XMLのNamespaceと書き出し時のEncodingについて</a></h1>
<ul class="date"><li>2009-08-18</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>ver 0.0.0.2に更新。アップロードするフォルダが指定出来るようになりました。アップロードツール名(FotolifeUploader)が利用されるようになりました。フォルダ指定は再設定が必要なので、前のバージョンを使っている方はsettings.xmlを削除して、再度設定し直してください。あとは間抜けだったUploadToFotolifeメソッドを手直ししたり。</p>
<p>私自身が、そもそもフォトライフのヘビーユーザーではないので、細かいところに気が利いてないかもですね……。そういうのは、よくない。というわけで、当分はFotolifeをちゃんと利用しようキャンペーンを張ることにします。なので、デジタル一眼を買う。と言いたいのだけど、何か微妙なのよねん。いや、そもそも引き籠って家から出ないので撮影するものがないので。かといって熱帯魚や食虫植物とかフィギュアとか、撮影に適した趣味があるわけでもなく。困った困った。まあ、考えます。食虫植物を育てる方向で(？) 部屋が殺風景なので何かは入れたいのだけど、手間はかけたくない。ううむ、難しい。</p>
<h2>LINQ to XML</h2>
<p>アップロードにはAtomAPIを利用しているので、XMLです。つまりLINQ to XMLの出番です。出力結果がこんな感じなので、そこから逆に考えると……</p>
<pre><code class="language-xml">&lt;entry xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns=&quot;http://purl.org/atom/n
s#&quot;&gt;
  &lt;title&gt;タイトル&lt;/title&gt;
  &lt;content mode=&quot;base64&quot; type=&quot;image/jpeg&quot;&gt;画像BASE64&lt;/content&gt;
  &lt;generator&gt;FotolifeUploader&lt;/generator&gt;
  &lt;dc:subject&gt;フォルダ名&lt;/dc:subject&gt;
&lt;/entry&gt;
</code></pre>
<p>XElementは、Namespaceの利用が少しややこしいんですよね。最初引っかかりました。「XNamespace.Xmlns + &quot;接頭辞&quot;」で登録できます。</p>
<pre><code class="language-csharp">XNamespace ns = &quot;http://purl.org/atom/ns#&quot;;
XNamespace dc = &quot;http://purl.org/dc/elements/1.1/&quot;;
var xml =
    new XDocument(new XDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, null),
    new XElement(ns + &quot;entry&quot;, new XAttribute(XNamespace.Xmlns + &quot;dc&quot;, dc),
        new XElement(ns + &quot;title&quot;, &quot;タイトル&quot;),
        new XElement(ns + &quot;content&quot;, new XAttribute(&quot;mode&quot;, &quot;base64&quot;), new XAttribute(&quot;type&quot;, &quot;image/jpeg&quot;), &quot;画像BASE64&quot;),
        new XElement(ns + &quot;generator&quot;, &quot;FotolifeUploader&quot;),
        new XElement(dc + &quot;subject&quot;, &quot;フォルダ名&quot;)
    ));
Console.WriteLine(xml); // 出力確認、DeclarationはToStringでは出力されない
</code></pre>
<p>少し独特ですが、ほとんど1:1で対応させられるので慣れるとサクサク書けます。非常に快適。個人的にはXMLリテラル的なものよりも好き。Linqがあってほんと良かった……。で、Declarationを出力したい場合の話に続く。<a href="http://d.hatena.ne.jp/Nobuhisa/20080914/1221326352">(hatena (diary ’Nobuhisa))</a>にもあるように、ToStringでは出力されないのでSaveを使う、と……</p>
<pre><code class="language-csharp">var sb = new StringBuilder();
var sw = new StringWriter(sb);
xml.Save(sw);
Console.WriteLine(sb); // UTF-16になる
</code></pre>
<p>これでencodingがUTF-16になるのは、Saveメソッド呼ぶとDeclarationは作りなおしているから。.Save(&quot;string fileName&quot;)ではXDeclarationのエンコーディングを見て、それで保存するけれど、それ以外の場合はXDeclaration無視で再構築される。XDocumentというかXmlWriterのほうの話でしょうか。実際にファイル出力してみると分かる。</p>
<pre><code class="language-csharp">var fs = new FileStream(@&quot;C:\text.xml&quot;, FileMode.Create);
var sw = new StreamWriter(fs, Encoding.GetEncoding(&quot;x-mac-turkish&quot;));
xml.Save(sw);
</code></pre>
<p>出力先のエンコードに合わせてくれる、のを便利と見るか、むしろ気が利かない、Writer部分もC#3.0に合わせて作りなおせ、なのかは不明。まあ、嘘エンコード宣言は許しませんよってことですかね。じゃあどうするか、って言ったら</p>
<pre><code class="language-csharp">// これで別に何も問題ないと思います、文字列として吐くんだからToStringでいいと思ふ
var xmlString = string.Format(&quot;{0}{1}{2}&quot;,
    xml.Declaration, Environment.NewLine, xml);
Console.WriteLine(xmlString);

// ToStringがどうしても嫌ならMemoryStream経由で、とか？
string result;
var encoding = Encoding.UTF8;
using (var ms = new MemoryStream())
using (var sw = new StreamWriter(ms, encoding))
{
    xml.Save(sw);
    result = encoding.GetString(ms.ToArray());
}
Console.WriteLine(result); // 望み通りのUTF-8で出力されてます
</code></pre>
<p>結論は、普通にToStringでいいんじゃないかな、と。ToStringメソッドだけではXmlWriterSettingsで言うところのOmitXmlDeclarationを設定出来ないから、デフォルトでは付加しないようにしてる。削除は無理だけど、追加なら簡単だから。XmlDeclarationを付加したい時は別途、自分でくっつければいい。というだけのお話かなー？ ToStringで一発で終わらせられないからStringBuilder使って組み立てるってのは、何でそうなるの？と、とても思った。ついでにもう一つ。</p>
<pre><code class="language-csharp">// こんなXElementがあるとして
var xElement = XElement.Parse(&quot;&lt;hoge&gt;3&lt;/hoge&gt;&quot;);
// intとして値を取り出す時は
var num1 = int.Parse(xElement.Value); // これダメ。
var num2 = (int)xElement; // こう書こう。
</code></pre>
<p>です。LINQ to XMLは既存のものを上手く使ってシンプルに書けるように作られてる。気がする。このキャストもそうだし、ToStringもそう。Parseは頻繁に行うから汚くなるよね→キャストでよくね？ 文字列化はよくやるけどSaveもXmlWriterSettingsも面倒くさいよね→ToStringでよくね？ といった感じ。関数型構築もそうだけど、今までのもの(XmlDocument)を踏まえて、よく練り直されているなー、と思います。</p>
</div>
<h1><a href="https://neue.cc/2009/08/17_187.html">半自動はてなフォトライフアップローダー ver 0.0.0.1</a></h1>
<ul class="date"><li>2009-08-17</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/fotolifeuploader">neue cc - 半自動はてなフォトライフアップローダー</a></li>
</ul>
<p>はてなフォトライフに画像をワンクリックでアップロードするプログラムです。ワンクリックの手間があるので、半自動。主な機能は、実行すると設定したフォルダの最新の更新画像一枚をアップロード。利用例としてデジカメ接続時やメモリーカード内の画像フォルダを指定することを想定しています。写真撮る→PCに繋げる→プログラムを実行する→アップロード完了。みたいな流れです。Twitterに載せるための写真とか最新一枚で十分でしょう？ Blogに載せる場合でも、一枚で済む場合って結構多いよね。そんな感じに、サクサクッと写真と付き合えたらいいな、と。</p>
<h2>設定</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader2.jpg">
</p>
<p>まさかのCUI設定画面(笑) 初回起動時にこの画面になります。設定し直したい時は、生成されるsettings.xmlを削除してください。レトロでアナログで半自動を貫く感じがいいかなー、と思ったんですが、どうでしょう。</p>
<h2>最新画像一枚のアップロード</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader.jpg">
</p>
<p>設定終了後にexeファイルを実行すると、設定時に指定したフォルダの中の、拡張子が「jpg/jpeg/gif/png/bmp」で更新日時が最も新しいもの一枚をアップロードします。設定によってはアップロード後にブラウザでフォトライフのURLが開きます。なので、そこからそのままTwitterにURLをポストするなりBlog書くなりがシームレスに行えるわけです。キリッ。ちなみにリサイズ等はこちら側では一切しません、そのまま丸投げ。リサイズ処理もはてな任せ。</p>
<h2>任意画像複数枚のアップロード</h2>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fotolifeuploader3.jpg">
</p>
<p>フォルダ/画像をまとめてexeファイル(本体じゃなくてショートカットでもOKです)にドラッグアンドドロップすると、そのファイルをアップロードします。フォルダはサブディレクトリを含めて全てのファイルをアップロードします。拡張子が「jpg/jpeg/gif/png/bmp」以外のものはちゃんと無視しますので、多少適当でも大丈夫。また、いわゆる「送る」にショートカットを登録することで、このドラッグアンドドロップと同様の結果になります。Vistaの場合はエクスプローラー上で「%AppData%\Microsoft\Windows\SendTo」と入力するとSendToのフォルダに飛べますので、ここにショートカットを登録してみてください。</p>
<p>今回コンソールアプリにしたのは、実行にかかる手間を最小にしたかった、というのがあります。普通のアップロードアプリだと、「アプリを起動→画像フォルダを開く→ドラッグアンドドロップで画像を乗っける→アップロードボタンを押す→アプリを閉じる→Fotolifeにアップロードされた画像を確認しにいく」 これじゃあ工程多すぎであまりにも面倒くさい。というわけで、最新画像一枚ならば、アプリ起動だけで完了。複数毎でも画像フォルダ→ドラッグアンドドロップだけで完了という、考え得る限りの最短を目指しています。</p>
<h2>ソースコード</h2>
<p>ソースコードも同梱してあります。csファイル一つだけの、200行ちょいのちっぽいコンソールアプリです。好きに改変とか突っ込みとかディスとかしてください。しいていえば、Linqだらけです。個人的には</p>
<pre><code class="language-csharp">.SelectMany(s =&gt; (Directory.Exists(s))
  ? Directory.GetFiles(s, &quot;*&quot;, SearchOption.AllDirectories)
  : Enumerable.Repeat(s, 1))
.Select(s =&gt; new FileInfo(s))
.Where(fi =&gt; fi.Exists &amp;&amp; FotolifeExtensionPattern.IsMatch(fi.Extension))
</code></pre>
<p>この部分が気に入ってます。ドラッグアンドドロップで来る文字列配列からファイル抜き出しの部分。SelectManyでディレクトリをファイル名配列に、ディレクトリじゃない場合はEnumerable.Repeatで繰り返し回数が1回のファイル名配列にする。あとはまあ普通に、SelectしてWhereしてToArray。Linqがあって良かったーと本当に思う。逆にAtomPub APIでアップロードする部分はLinqでやる意味がなかったというか、当初予定と変わってあれ追加これ追加で肥大化してしまった結果でして……。</p>
<p>LLの人はこの手のちょっとしたスクリプトをほいほい公開しているわけだから、C#もコンソールアプリぐらいほいほい公開出来ないといかんのぅ、と思いつつもページ用意して云々かんぬんは面倒くさくて、そうホイホイってわけにもいかない感じ。もちっと軽くやれる環境作らないとね……。まあ、でも、このちょっとした重苦しさも悪くはないんだ。だってほら、Rubyでスクリプトがホイッって転がってても、普通の人は動かせもしないわけですよ。だから、少し面倒くさいなー、と思いつつ設定画面つけてexeの形式にして、それだけで幸せになれないかな、どうだろう。</p>
<p>私はプログラム書き始めたのがほんとつい最近で、利用するだけ人間の歴が何年も何年もあるので、その辺は極力優しくやりたいなあ、と思ってます。</p>
</div>
<h1><a href="https://neue.cc/2009/08/13_185.html">可変のLookup</a></h1>
<ul class="date"><li>2009-08-13</li></ul>
<div class="entry_body"><p><a href="http://d.hatena.ne.jp/griefworker/20090611/multi_dictionary" title="一対多の Dictionary が欲しい - present">一対多の Dictionary が欲しい - present</a></p>
<p>今だと、やっぱLookupがあるので、ILookupの実装という形で作った方が統一感取れていいのかな……？ 通常のLookupはToLookupでしか作成できず不変なので、追加したり削除したり出来るILookupの実装を作りました。MultiDictionaryとかMultiMapとか言われているもの、ですが名前をimmutableの反対なのでMutableLookupとしてみました。かなり、微妙。名前ってむつかしい。んで、中身はDictionary&lt;TKey, List&lt;TValue&gt;&gt;のゆるふわラッピング。コンストラクタでIEqualityComparerを突っ込めるので、大文字小文字無視とかも出来ます。</p>
<pre><code class="language-csharp">// こんな風に使います
var mutableLookup = new MutableLookup&lt;string, string&gt;();
mutableLookup.Add(&quot;食べ物&quot;, &quot;たこやき&quot;);
mutableLookup.AddRange(&quot;食べ物&quot;, new[] { &quot;いかやき&quot;, &quot;さかなやき&quot; });
mutableLookup.Add(&quot;飲み物&quot;, &quot;ぽかり&quot;);

IEnumerable&lt;string&gt; tabemono = mutableLookup[&quot;食べ物&quot;]; // インデクサでアクセス
foreach (var item in mutableLookup) // 列挙するとIGroupingが出てくる
{
    var key = item.Key; // キー(食べ物,飲み物)
    var array = item.ToArray(); // 配列
}
</code></pre>
<pre><code class="language-csharp">public class MutableLookup&lt;TKey, TValue&gt; : ILookup&lt;TKey, TValue&gt;
{
    private readonly Dictionary&lt;TKey, List&lt;TValue&gt;&gt; dictionary;

    // Constructor

    public MutableLookup()
    {
        dictionary = new Dictionary&lt;TKey, List&lt;TValue&gt;&gt;();
    }

    public MutableLookup(IEqualityComparer&lt;TKey&gt; keyComparer)
    {
        dictionary = new Dictionary&lt;TKey, List&lt;TValue&gt;&gt;(keyComparer);
    }

    // Property

    public IEnumerable&lt;TKey&gt; Keys
    {
        get { return dictionary.Select(kvp =&gt; kvp.Key); }
    }

    public IEnumerable&lt;TValue&gt; Values
    {
        get { return dictionary.SelectMany(kvp =&gt; kvp.Value); }
    }

    // Methods

    public ILookup&lt;TKey, TValue&gt; AsReadOnly()
    {
        return dictionary.SelectMany(kvp =&gt; kvp.Value, (kvp, Value) =&gt; new { kvp.Key, Value })
            .ToLookup(t =&gt; t.Key, t =&gt; t.Value);
    }

    public void Add(TKey key, TValue value)
    {
        if (dictionary.ContainsKey(key)) dictionary[key].Add(value);
        else dictionary.Add(key, new List&lt;TValue&gt; { value });
    }

    public void AddRange(TKey key, IEnumerable&lt;TValue&gt; values)
    {
        if (dictionary.ContainsKey(key)) dictionary[key].AddRange(values);
        else dictionary.Add(key, new List&lt;TValue&gt;(values));
    }

    public void RemoveKey(TKey key)
    {
        dictionary.Remove(key);
    }

    public void RemoveValue(TKey key, TValue value)
    {
        if (!dictionary.ContainsKey(key)) return;

        var list = dictionary[key];
        list.Remove(value);
        if (!list.Any()) dictionary.Remove(key);

    }

    public void RemoveWhere(TKey key, Func&lt;TValue, bool&gt; predicate)
    {
        if (!dictionary.ContainsKey(key)) return;

        var list = dictionary[key];
        list.RemoveAll(new Predicate&lt;TValue&gt;(predicate));
        if (!list.Any()) dictionary.Remove(key);
    }

    public void Clear()
    {
        dictionary.Clear();
    }

    public bool Contains(TKey key, TValue value)
    {
        if (dictionary.ContainsKey(key))
        {
            return dictionary[key].Contains(value);
        }
        return false;
    }

    #region ILookup&lt;TKey,TValue&gt;

    public bool Contains(TKey key)
    {
        return dictionary.ContainsKey(key);
    }

    public int Count
    {
        get { return dictionary.Count; }
    }

    public IEnumerable&lt;TValue&gt; this[TKey key]
    {
        get
        {
            return (dictionary.ContainsKey(key))
                ? dictionary[key].AsEnumerable()
                : Enumerable.Empty&lt;TValue&gt;();
        }
    }

    #endregion

    #region IEnumerable&lt;IGrouping&lt;TKey,TValue&gt;&gt;

    public IEnumerator&lt;IGrouping&lt;TKey, TValue&gt;&gt; GetEnumerator()
    {
        return dictionary
            .Select(kvp =&gt; new Grouping(kvp.Key, kvp.Value))
            .Cast&lt;IGrouping&lt;TKey, TValue&gt;&gt;()
            .GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }

    #endregion

    // Nested Types

    private class Grouping : IGrouping&lt;TKey, TValue&gt;
    {
        private TKey key;
        private List&lt;TValue&gt; list;

        public Grouping(TKey key, List&lt;TValue&gt; list)
        {
            this.key = key;
            this.list = list;
        }

        #region IGrouping&lt;TKey,TValue&gt;

        public TKey Key
        {
            get { return key; }
        }

        #endregion

        #region IEnumerable&lt;TValue&gt;

        public IEnumerator&lt;TValue&gt; GetEnumerator()
        {
            return list.GetEnumerator();
        }

        #endregion

        #region IEnumerable

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        #endregion
    }
}
</code></pre>
<p>利用はご自由にどうぞ。パブリックドメイン、でいいのかな？ あー、AsReadOnlyは新しいのに作り替えちゃってるのでAsじゃないですねえ。まあ、放置。あと、new Predicate()が果てしなくダサい。これ何とかならないのかな。delegateはFuncとAction以外は消滅しちゃえばいいのに。ジェネリクス以前のコレクションクラスと同じで、3.0以前の負の遺産だと何となく思ってる。</p>
</div>
<a href="https://neue.cc/24">Prev |</a>
<a href="https://neue.cc/26">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
