<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2014-07</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2014/07/22_475.html">Amazon Kinesis + Reactive Extensionsによる簡易CEP</a></h1>
<ul class="date"><li>2014-07-22</li></ul>
<div class="entry_body"><p>AWSの<a href="http://aws.amazon.com/jp/kinesis/">Amazon Kinesis</a>！大規模なストリーミングデータをリアルタイムで処理する完全マネージド型サービス。うーん、いかにもわくわくしそうなキーワードが並んでいます。そしてついに先日、東京リージョンでも利用可能になったということでAWS Summitの最中もｗｋｔｋして、どうやって利用したもんかと考えてました。だって、リアルタイムにイベントデータが流れてくる→オブザーバブルシーケンス→<a href="https://rx.codeplex.com/">Reactive Extensions(Rx)</a>、という連想になるのは自然なことですよね？</p>
<h2>Kinesisとは</h2>
<p>Rx、の前にKinesisとは。<a href="http://aws.typepad.com/aws_japan/2013/11/amazon-kinesis-real-time-processing-of-streamed-data.html">【AWS発表】 Amazon Kinesis – ストリームデータのリアルタイム処理</a>を見れば事足りますが、表現するなら土管、ですかね。イベントデータの。以下ぽんち絵</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/image/amazonkinesis.jpg' />
</p>
<p>Streamの中はShardという単位で分かれていて、データを放り込む時はPartitionKeyを元に、どのShardに突っ込まれるか決まる。読み書き性能自体は完全にShardの数で決まっていて、1シャード毎にWriteは1MB/sec - 1000Req/sec, Readは2MB/sec - 5Req/secとなってます。事前に負荷状況を予測していくのと、随時、Split(Shardの分割)とMerge(Shardの統合)してスケーリングしていく、って感じですかねえ。API自体は単純で、あんま数もないので簡単に理解できるかと。</p>
<p>APIが単純なのはやれることが少ないから。土管。情報を左から右に流すだけのパイプ。その代わり入力は限りなく無限にスケールしていく(Shardを増やしまくれば)。では出力は？というと、Kinesis Applicationとよばれる、といっても実体は、別にAPIをほぼほぼポーリングで叩いてデータ取り出して何か処理するものをそう呼んでるだけ。で、取り出すのはAPI叩いて保存されたデータを読むだけ。</p>
<p>そう、ポーリング。Kinesis自体は一時保管所であって、本当のリアルタイムでPubSub配信するわけじゃあない（用途としては問題ないレベルで低遅延にはなるけれど）。保存時間は24時間で、その間はStream中のどこから（最初からでも最新からでも任意の位置から）でも取り出すことができる。一時保管所がわりにS3を使ったりすると、ゴミは貯まるしどこまで取ったかとか煩わしくなるけれど、Kinesisの場合はStreamの形状になっているのでとてもやりやすい。ただしKinesisは制限として1レコード辺り50KBまで。更にHTTPで投げる際にBase64になってブヨっと膨らむ。</p>
<h2>ObservableKinesisClient</h2>
<p>C#でKinesisを使うには、<a href="http://aws.amazon.com/jp/sdkfornet/">AWS SDK for .NET</a>を使えばAmazonKinesisClient入ってます。ソースコードも公開されてるしNuGetでも入れられるし、APIはとりあえずAsyncに対応してるし、APIデザインもちょっと奇妙なところもあるけれど、一応全て統一されたモデルでデザインされてるので、割と結構良いと思ってます。</p>
<p>Kinesis、データの登録はPutRecordでバイナリ投げるだけなので単純なのですが、取り出しの方はいささか面倒で、DescribeStreamによるStream内のShard情報の取得、GetShardIteratorによるShardIterator(どの位置から取得開始するか、の情報)の取得、それを元にGetRecord、そして延々とポーリングのためのループ。と、繰り返す必要があります。</p>
<p>というわけかで、まずは利用例の方を。</p>
<pre><code class="language-csharp">// とりあえずAWSのキーと、ストリーム名で生成する感じ
var client = new ObservableKinesisClient(&quot;awsAccessId&quot;, &quot;awsSecretAccessKey&quot;, RegionEndpoint.APNortheast1, streamName: &quot;KinesisTest&quot;);

// データの登録。オブジェクトを投げ込むとJSONシリアライズしたのを叩き込む。
await client.PutRecordAsync(new { Date = DateTime.Now, Value = &quot;ほげほげほげほげ&quot; });

// ObserveRecordDynamicでJSONのストリームとして購読できる
client.ObserveRecordDynamic()
    .Where(x =&gt; x.Value != &quot;ほげ&quot;) // xはdynamicなのでどんなSchemaのJSONも自由に辿れる
    .Select(x =&gt; x.Date + &quot;:&quot; + x.Value)
    .Subscribe(Console.WriteLine);
</code></pre>
<p>はい。ObserveRecordDynamicで、リアルタイムに流れてくるデータを簡単に購読できます。IObservableなので、Rxによって自由にクエリを書くことが可能。また、何のデータが流れてくるか分からないストリームのために、JSONはdynamicの形でデシリアライズされています。(IntelliSenseの補助は効きませんが)スキーマレスに、あらゆるデータをRxで処理できます。もちろん、型付けされたものが欲しければObserverRecord&lt;T&gt;を、今は実装してないですが、まあ簡単につくれます:)</p>
<p>以下ObservableKinesisClient本体。</p>
<pre><code class="language-csharp">// JSON.NET, AWSSDK, Rx-Mainの参照が必要
public class ObservableKinesisClient
{
    readonly UTF8Encoding encoding = new UTF8Encoding(false);
    readonly JsonSerializer serializer = new JsonSerializer() { Formatting = Newtonsoft.Json.Formatting.None }; // ThreadSafeだよ
    readonly string streamName;
    readonly AmazonKinesisClient kinesis; // ThreadSafeなのかは知らない（ぉぃ

    // コンストラクタはもっとまぢめにやりましょう
    public ObservableKinesisClient(string awsAccessId, string awsSecretAccessKey, RegionEndpoint endPoint, string streamName)
    {
        this.kinesis = new AmazonKinesisClient(awsAccessId, awsSecretAccessKey, endPoint);
        this.streamName = streamName;
    }

    // ようするにObjectを1レコードずつJSONで突っ込むもの
    public async Task&lt;PutRecordResponse&gt; PutRecordAsync(object value)
    {
        using (var ms = new MemoryStream())
        using (var sw = new StreamWriter(ms, encoding))
        using (var jw = new JsonTextWriter(sw) { Formatting = Formatting.None })
        {
            serializer.Serialize(jw, value);
            jw.Flush();
            ms.Position = 0;

            var request = new PutRecordRequest
            {
                StreamName = streamName,
                Data = ms,
                PartitionKey = Guid.NewGuid().ToString() // PartitionKeyは適当にランダム
            };

            // つまり1レコード1HTTP POSTということになる。
            // 大量に投げる際は素朴すぎてアレゲ感があるので、実際にやるときはまとめてから放り込んで
            // 取り出す側も↑の構造を前提にして取り出すよーな感じにしたほうがいーかもデスネー
            return await kinesis.PutRecordAsync(request).ConfigureAwait(false);
        }
    }

    // Dynamicが嫌な場合はSerialize&lt;T&gt;でおｋ。とりあえずこの例ではdynamicでやります。
    // Client内部で分配しちゃったほうがきっと自然にやさしい(Publish().RefCount())
    public IObservable&lt;dynamic&gt; ObserveRecordDynamic()
    {
        return Observable.Create&lt;dynamic&gt;(async (observer, cancellationToken) =&gt;
        {
            var isRunningNextPipeline = false;
            try
            {
                // まずShard一覧を取得する
                // TODO:これを使いまわしちゃうとShardsの増減には対応してないよ！
                // 毎回DescribeStream読むのもアレだしたまに問い合わせとかがいいの？
                var describeStreamResponse = await kinesis.DescribeStreamAsync(new DescribeStreamRequest { StreamName = streamName }).ConfigureAwait(false);
                var shards = describeStreamResponse.StreamDescription.Shards;

                var nextIterators = new List&lt;string&gt;();
                foreach (var shard in shards)
                {
                    if (cancellationToken.IsCancellationRequested) return; // CancellationTokenの監視だいぢだいぢ

                    // ShardIteratorTypeは実際は取り出した位置を記録しておいてAFTER_SEQUENCE_NUMBERでやるか、LATESTでやるかがいーんじゃないでしょーか？
                    var shardIterator = await kinesis.GetShardIteratorAsync(new GetShardIteratorRequest
                    {
                        StreamName = streamName,
                        ShardId = shard.ShardId,
                        ShardIteratorType = ShardIteratorType.TRIM_HORIZON, // TRIM_HORIZON = 最初から, LATEST = 最新, AT_SEQUENCE_NUMBER = そこから, AFTER_SEQUENCE_NUMBER = 次から
                    }).ConfigureAwait(false);

                    var record = await kinesis.GetRecordsAsync(new GetRecordsRequest { ShardIterator = shardIterator.ShardIterator }).ConfigureAwait(false);

                    // Shardの順番で回してるので、このPushの順番は必ずしも「時系列ではない」ことにチューイ！
                    foreach (var item in record.Records)
                    {
                        PushRecord(item, observer, ref isRunningNextPipeline); // ObserverでPush!Push!Push!
                    }

                    nextIterators.Add(record.NextShardIterator);
                }

                // NextShardIteratorがある状態で無限ぐるぐる
                do
                {
                    if (cancellationToken.IsCancellationRequested) return; // ところどころCancellationTokenの監視 Part2

                    for (int i = 0; i &lt; nextIterators.Count; i++)
                    {
                        if (cancellationToken.IsCancellationRequested) return; // ところどころCancellationTokenの監視 Part3

                        var shardIterator = nextIterators[i];

                        var record = await kinesis.GetRecordsAsync(new GetRecordsRequest { ShardIterator = shardIterator }).ConfigureAwait(false);

                        // こちらでも、やはりShardの順番で回してるので、状況によって必ずしも時系列にはならないことにチューイ！
                        foreach (var item in record.Records)
                        {
                            PushRecord(item, observer, ref isRunningNextPipeline); // ObserverでPush!Push!Push!
                        }

                        nextIterators[i] = record.NextShardIterator;
                    }

                    await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false); // 実質ポーリングなのでなんとなくDelayをちょっと入れてみる

                    nextIterators = nextIterators.Where(x =&gt; x != null).ToList(); // 明らかに非効率なこの実装はテキトーなんで真面目にやるなら真面目に書いてください:)
                } while (nextIterators.Any());
            }
            catch (Exception ex)
            {
                if (isRunningNextPipeline)
                {
                    throw;
                }
                else
                {
                    observer.OnError(ex);
                }

                return;
            }

            observer.OnCompleted();
        });
    }

    void PushRecord(Record record, IObserver&lt;dynamic&gt; observer, ref bool isRunningNextPipeline)
    {
        using (var sr = new StreamReader(record.Data, encoding)) // item.DataにMemoryStreamの形で1レコードが受け取れる
        using (var jr = new JsonTextReader(sr))
        {
            var obj = serializer.Deserialize(jr);
            isRunningNextPipeline = true;
            observer.OnNext(obj); // 1レコードをPush
            isRunningNextPipeline = false;
        }
    }
}
</code></pre>
<p>PutRecordAsyncはまんま、JSONにシリアライズしたデータを投げ込んでるだけです。ObserverRecordDynamicのほうはちょっと複雑っぽいですが、やってることは順に、DescribeStreamAsyncでShard一覧を取得→それぞれのShardでGetShardIteratorAsyncで始点の取得・GetRecordsAsyncで最初のデータを取得しobserverに配信→取得できたNextShardIteratorを元にデータ取得と配信の無限ループ。です。</p>
<p>コメントで色々書いてありますが、Shard単位で処理していくのでレコードのSequenceNumberの順にPushされているわけではないことと、ShardがSplitやMergeで変動することへの対応は必要よね、とか考えることは色々ありますね。あと、Readの制限が5Req/secとかなり少ないので、複数処理する必要があるなら、できればリクエストは分配してやりたいところ。RxならPublishで分配、ついでにRefCountでSubscriberが0になったら購読解除というのが自然に書けるので、その辺も入れてやるといいかなー、なんて思います。とはいえ、基本的にはデータ取ってOnNextで垂れ流すという、それだけに収まってはいます（ほんとだよ！）。</p>
<p>従来はこの手のコードはyield returnで処理するはずですが、それがOnNextに変わっているという事実が面白い！勿論、同期API + yield returnにすることも可能ですが、AWS SDKの同期APIは非同期のものを.Resultで取ってるだけで非同期のほうがネイティブになるので、同期API使うのはお薦めしません。<a href="http://neue.cc/2013/12/04_435.html">非同期時代のLINQ</a>、非同期時代のイテレータ。中々面白くありません？<a href="https://github.com/neuecc/UniRx#how-to-use-for-ienumeratoras-coroutine">UniRx - Reactive Extensions for UnityのFromCoroutine</a>でも、IObserverをyielderとして渡して、非同期のイテレータを作れる（コンバートできる）ようにしています。こういうのも一つのデザイン。</p>
<h2>like CEP(with LINQPad)</h2>
<p><a href="http://en.wikipedia.org/wiki/Complex_event_processing">CEP(Complex Event Processing)</a>は最近良く聞くようになりましたねー、Microsoftにも<a href="http://technet.microsoft.com/en-us/library/ee362541.aspx">StreamInsight</a>というかなり立派なプロダクトがあるのですが、あんまり話を聞かないし将来性もビミョーそうなので見なかったことにしましょう。ちなみにStreamInsightは2.1からRxと統合されたりして、この手のイベントストリームとRxとが相性良いこと自体は証明済みです。</p>
<p>そんなわけでMicrosoft周辺では全然聞きませんが、日本だと<a href="http://www.atmarkit.co.jp/ait/articles/1404/30/news024.html">LINEでのEsper CEPの活用例</a>とか<a href="http://norikra.github.io/">Norikra:Schema-less Stream Processing with SQL</a>で盛んに聞いて、まーたMicrosoft周辺によくある、一歩先を行ったと思ったら周回遅れ現象か！とか思ったり思わなかったり。</p>
<p>というわけで、<a href="http://www.slideshare.net/tagomoris/fluentpluginnorikra-fluentdcasual">Norikraの紹介スライド</a>のクエリ5つをRxで書いてみましょう。また、動作確認は<a href="http://www.linqpad.net/">LINQPad</a>のDumpでリアルタイムに表示が可能です(asynchronousにクエリが走ってる最中はResultsのところにリアルタイムにグリッドが追加されていく！）</p>
<p class="noindent">
<img src='http://neue.cc/wp-content/uploads/image/kinesislinqpad.jpg' />
</p>
<pre><code class="language-csharp">// Queries:(1)
client.ObserveRecordDynamic()
    .Select(x =&gt; new{ x.Name, x.Age })
    .Dump();

// Queries:(2)
client.ObserveRecordDynamic()
    .Where(x =&gt; x.Current == &quot;Shibuya&quot;)
    .Select(x =&gt; new{ x.Name, x.Age })
    .Dump();

// Queries:(3)
client.ObserveRecordDynamic()
    .Buffer(TimeSpan.FromMinutes(5))
    .Select(xs =&gt; xs.GroupBy(x =&gt; x.Age).Select(x =&gt; new { Age = x.Key, Count = x.Count() }))
    .Dump();

// Queries:(4)
client.ObserveRecordDynamic()
    .Buffer(TimeSpan.FromMinutes(5))
    .Select(xs =&gt; xs.Max(x =&gt; x.Age))
    .Dump();

// Queries:(5)
client.ObserveRecordDynamic()
    .Where(x =&gt; x.Current == &quot;Kyoto&quot; &amp;&amp; x.Attend[0] &amp;&amp; x.Attend[1])
    .Buffer(TimeSpan.FromMinutes(5))
    .Select(xs =&gt; xs.GroupBy(x =&gt; x.User.Age).Select(x =&gt; new { Age = x.Key, Count = x.Count() }))
    .Dump();
</code></pre>
<p>5分間だったらBufferもしくはWindowが使えます（量が少なそうならBufferのほうが、後続クエリにLINQ to Objectsが使えて分かりやすい、量が多いならWindowで、同様にRxで集計クエリが書ける）。他に何ができるかは<a href="https://github.com/Netflix/RxJava/wiki">RxJavaのWikiのOperator一覧</a>でもどうぞ。めちゃくちゃ何でもできます。</p>
<h2>SQL vs Rx</h2>
<p>SQLである必要は、あるようで、ない。テキストベースのDSLを作るならSQLが共通知識として期待できるので、SQLに寄せる必要性はかなり高い。けれど、Rxならば、LINQとしての共通知識と、C#そのものであるというコンパイルセーフな点と何でもできること、メソッドチェーン(+IntelliSense)による書きやすさ。SQLライクなものを使いたい理由は全くない。</p>
<p>（とはいえ勿論いちだいのRxがぶんさんごりごりのに勝てるとは思ってないんで、そこはまぁかじゅあるなはなしです）</p>
<h2>TODO</h2>
<p>というわけで見てきたわけですが、まあ所詮まだ単純なコードによるコンセプトレベルの話ですね！本格的にこれからやるとしたら</p>
<ul>
<li>ObservableKinesisClientをもっとしっかりしたものに</li>
<li>Kinesis ApplicationをホストするためのServiceとプラグイン機構</li>
<li>ログ転送側としてSLABのKinesis用Sink</li>
</ul>
<p>ですかねえ。まぁ、これらはJavaですでに用意されている<a href="https://github.com/awslabs/amazon-kinesis-client">amazon-kinesis-client</a>や<a href="https://github.com/awslabs/amazon-kinesis-connectors">amazon-kinesis-connectors</a>を.NET環境で代替するために必要だ、といったところですね。素直にJava書けば？っていうのは一理あるけれど、どーなんですかね、C#でやりたいんですよ（笑）</p>
<p><a href="https://slab.codeplex.com/">Semantic Logging Application Block(SLAB)</a>というのは構造化ロガー（正確にはロガーは含まれないけれど）と収集サービスがセットになったライブラリです。面白いのはOut-Of-Processでの動作が選べて、その場合はWindowsネイティブの<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363668.aspx">Event Tracing for Windows (ETW)</a>経由でログが運ばれるので、非常に高速に動作する、というところ。Sinkというのは出力用プラグインみたいなものです。なので、アプリケーション→<a href="http://msdn.microsoft.com/ja-jp/library/system.diagnostics.tracing.eventsource.aspx">EventSource</a>ロガー→SLAB Service(+ KinesisSink)→Kinesis という構造を作ることで、データをリアルタイムに投下するところまでは行ける。あとはRedShiftに送って解析(amazon-kinesis-connectorsには既にありますね)するなり、他のKinesis Application作るなりよしなに出来るかなぁ、できればいいかなぁ、と。<a href="http://lambda-architecture.net/">ラムダアーキテクチャ</a>、というホドデハ・モチロンナイ。</p>
<h2>AWS + Windows(C#)</h2>
<p>先週の木・金に開催された<a href="http://www.awssummittokyo.com/">AWS Summit Tokyo 2014</a>にて、AWS + Windows(C#)で構築する.NET最先端技術によるハイパフォーマンスウェブアプリケーション開発実践と題して、セッションを行いました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/37121424" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/neuecc/aws-windowscnet" title="AWS + Windows(C#)で構築する.NET最先端技術によるハイパフォーマンスウェブアプリケーション開発実践" target="_blank">AWS + Windows(C#)で構築する.NET最先端技術によるハイパフォーマンスウェブアプリケーション開発実践</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>まとめで書きましたが、C#+AWSは現実解、だと思ってます。そしてAWSだからといって特別なこともなく、そしてC#だからといって特別なこともない。Kinesisもちゃんと使えるわけだし、結構面白いことがまだまだ出来るんじゃないかな、って思ってます。なんでAzure使わないんですか？というのには、よく聞かれるのでお茶を濁して答えないとして（！）、AzureにもKinesisのような<a href="http://azure.microsoft.com/ja-jp/services/event-hubs/">Azure Event Hubs</a>というものが先週プレビューリリースされました。C#からの活用という点では、こちらにも注目していきたいところです。<a href="http://msdn.microsoft.com/en-us/library/dn789972.aspx">Event Hubs Developer Guide</a>なんか見ると普通に色々参考になるし、機能的にはHTTP以外にAMQP使えたり、ちょっと強そうではある。</p>
</div>
<h1><a href="https://neue.cc/2014/07/01_474.html">Unity + iOSのAOTでの例外の発生パターンと対処法</a></h1>
<ul class="date"><li>2014-07-01</li></ul>
<div class="entry_body"><p><a href="http://japan.unity3d.com/">Unity</a>、はUnity3Dのほうの話ですが、それで開発していてiOS実機にデプロイして確認すると、以下の様なエラーに悩まされると思います！</p>
<pre><code class="language-text">System.ExecutionEngineException: Attempting to JIT compile method
</code></pre>
<p>ひぎぃ！怖い！これはiOSはネイティブコードしか許可していないので、Monoの<a href="http://ja.wikipedia.org/wiki/%E4%BA%8B%E5%89%8D%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9">AOT(Ahead-Of-Time)コンパイラ</a>経由でネイティブコード変換されるんですが、それの関係で色々な制限があるからなのですね。さて、制限があるのはshoganaiんですが、引っかかるのは痛いです、めっちゃ痛いです、辛いです。</p>
<p>というわけで、どういうコードを書けば発生するのか、というのを並べてみました。どうすれば発生するのか分かれば、自然に避けられますからね。そのうえで、幾つかのものはちょっとしたハックで防げるので、それも述べます。あとは、一々実機で確認なんてやってられないので、効率のよい確認方法などなども紹介します。</p>
<p>Unity 4.5で少し改善されたとか言ってましたが別にあんま改善されてる気配なくて以下のコードは4.5.1で確認取って全部片っ端から死にますんで安心してください、悲しい。</p>
<h2>Interlocked.CompareExchange</h2>
<p>正確にはInterlocked.CompareExchange&lt;T&gt;が死にます。以下のコードは即死。</p>
<pre><code class="language-csharp">// ExecutionEngineException: Attempting to JIT compile method '(wrapper native-to-managed)' while running with --aot-only
var a = &quot;hoge&quot;;
Interlocked.CompareExchange&lt;string&gt;(ref a, &quot;hugahuga&quot;, &quot;hoge&quot;);
</code></pre>
<p>ExecutionEngineExceptionの中でもnative-to-managedと出ているものは対処方法が明確で、そもそも<a href="http://docs-jp.unity3d.com/Documentation/Manual/TroubleShooting.html">Unityのトラブルシューティング</a>のiOSのところにも書いてあります。デリゲートに[MonoPInvokeCallback]が必要だ、と。つまりそういうことで、mscorlib.dll内のメソッドなので手が出せないので、100%死ぬ運命にあります、南無。対処方法は使わないこと。(実際にはそれだけじゃなさそうですが、中のことで分からないのでとりあえずそういうことにしておこふ)</p>
<p>ただし、実はCompareExchangeにはintやdoubleなどを受け取るオーバーロードがあって、そちらは大丈夫です。問題なのは&lt;T&gt;のオーバーロードだけなのです。しかもCompareExchangeにはobjectを受け取るオーバーロードもあるので、そちらを使うことによりT的なものも一応回避することが可能。どうしても使いたい場合は安心してどうぞ。</p>
<pre><code class="language-csharp">// これは大丈夫！
object a = &quot;hoge&quot;;
var v = Interlocked.CompareExchange(ref a, &quot;hugahuga&quot;, &quot;hoge&quot;);
</code></pre>
<p>ちなみにInterlocked.CompareExchange&lt;T&gt;は意外なところでも使われていて、というか、VS2010以降のコンパイラでeventをコンパイルすると、eventの実装がInterlocked.CompareExchange&lt;T&gt;を用いたものになっています。なのでプラグインとしてdllを作ってUnityに読み込ませると、これに引っかかって死にます。回避方法はなし。event使うのやめましょう、Actionで我慢しましょう。なお、Unity内だけで使う分には古いコードが吐かれるので問題ないです。(あと<a href="http://ufcpp.net/study/csharp/">ufcppさん</a>からコメント貰いましたが、<a href="http://msdn.microsoft.com/ja-jp/library/cc713648.aspx">add/delete</a>といったカスタムイベントアクセサを定義すれば回避できるもよふ)</p>
<h2>動的コード生成</h2>
<p>Reflection.Emitとか、この辺は当たり前だ！ですね。</p>
<pre><code class="language-csharp">Expression&lt;Func&lt;string&gt;&gt; expr = () =&gt; &quot;hoge&quot;;

// System.ExecutionEngineException: Attempting to JIT compile method '(wrapper dynamic-method) System.Runtime.CompilerServices.ExecutionScope:lambda_method (System.Runtime.CompilerServices.ExecutionScope)' while running with --aot-only.
expr.Compile();
</code></pre>
<p>Expressionも構築まではOKだけどCompileはNG。悩ましいのは一般的にC#で高速化を測る場合（特にシリアライザ）って動的コード生成＋キャッシュをよく使います。<a href="http://neue.cc/2014/01/27_446.html">neue cc - C#での動的なメソッド選択における定形高速化パターン</a>とか<a href="http://neue.cc/2011/04/20_317.html">neue cc - Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化</a>をミテネ。が、動的コード生成が使えないと低速なリフレクションのみかぁ、うーん、萎える。といったかんぢ。こういうのが積み重なってC#が遅いとか言われると心外だなぁ、UnityのC#は正直、うーん、ねぇ……。</p>
<h2>PropertyのReflection</h2>
<p>そんなわけでリフレクション。これがひじょーに悩ましくて、どこまでが死んでどこまで大丈夫なのかがひじょーーーーーに分かりづらい！さて、実は意外と行けますが、そして意外と死にます。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
public class MyClass
{
    public int MyInt { get; set; }
    public string MyStr { get; set; }
}

// ----

var mc = new MyClass() { MyStr = &quot;hoge&quot;, MyInt = 100 };
var propInfo = typeof(MyClass).GetProperty(&quot;MyStr&quot;);

// SetValueは大丈夫
propInfo.SetValue(mc, &quot;hugahuga&quot;, null);

// GetValueは死ぬ
// System.ExecutionEngineException: Attempting to JIT compile method '(wrapper delegate-invoke) System.Reflection.MonoProperty/Getter`2&lt;&gt;:invoke_string__this___MyClass ()' while running with --aot-only.
var v = propInfo.GetValue(mc, null);
</code></pre>
<p>(GetValueは死ぬ、って書きましたがUnity 4.5.1 + iOS7.1で試したら死ななかった、↑が死んだのはmono2.6.7でした)。なんだこの非対称ってところですが、実際そうだからshoganai。そしてGetValueは実は簡単に回避できます。GetGetMethodでメソッドを取得して、それをInvokeすればいい。</p>
<pre><code class="language-csharp">var mc = new MyClass() { MyStr = &quot;hoge&quot;, MyInt = 100 };
var propInfo = typeof(MyClass).GetProperty(&quot;MyStr&quot;);

// こうすればGetもできる
var v = propInfo.GetGetMethod().Invoke(mc, null);
Debug.Log(v);
</code></pre>
<p>というわけで、これでシリアライザも作ることができます。例えばこんな感じの簡易シリアライザ。</p>
<pre><code class="language-csharp">public static void Run()
{
    var format = Serialize(new MyClass { MyInt = 100, MyStr = &quot;hoge&quot; });

    var v = Deserialize&lt;MyClass&gt;(format);
    Debug.Log(v.MyStr + &quot;:&quot; + v.MyInt);
}

public static string Serialize&lt;T&gt;(T obj)
{
    // JSON、ではない
    var sb = new StringBuilder();
    foreach (var item in typeof(T).GetProperties())
    {
        sb.Append(item.Name + &quot;:&quot; + item.GetGetMethod().Invoke(obj, null));
        sb.Append(&quot;,&quot;);
    }
    return sb.ToString();
}

public static T Deserialize&lt;T&gt;(string format)
{
    var obj = Activator.CreateInstance&lt;T&gt;();
    var type = typeof(T);

    foreach (var item in format.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries).Select(x =&gt; x.Split(':')))
    {
        var key = item[0];
        var value = item[1];

        var propInfo = type.GetProperty(key);
        if (propInfo == null) continue;

        // 型の変換は超絶手抜き:)
        if (propInfo.PropertyType == typeof(int))
        {
            propInfo.SetValue(obj, int.Parse(value), null);
        }
        else
        {
            propInfo.SetValue(obj, value, null);
        }
    }

    return obj;
}
</code></pre>
<p>これはインチキなテキスト形式にシリアライズしてますが、例えばJSONにシリアライズ・デシリアライズとかできるようにすれば、ひじょーに有益でしょう。ベタリフレクションとかC#er的には萎えるんですが、まぁその辺はshoganaiということで諦めるぐらいはできる。諦めます。</p>
<h2>InterfaceとGenericsとStruct</h2>
<p>この3つが組み合わさることによって端的に言えば、死ぬ。</p>
<pre><code class="language-csharp">// こんなインターフェイスとメソッドがあるとして
public interface IMyInterface
{
    void MyMethod&lt;T&gt;(T x);
}

public class MyImpl : IMyInterface
{
    public void MyMethod&lt;T&gt;(T x)
    {
    }
}

IMyInterface intf = new MyImpl();
intf.MyMethod(&quot;hogehoge&quot;); // 死なない

// System.ExecutionEngineException: Attempting to JIT compile method 'MyImpl:MyMethod&lt;int&gt; (int)' while running with --aot-only.
intf.MyMethod(100); // 死ぬ
</code></pre>
<p>ジェネリクスのメソッドをインターフェイスで受けて、構造体を渡すと死にます。死にます。クラスなら死なないんですけどねー。さて、しかしこの現象は回避する術があります。</p>
<pre><code class="language-csharp">// どこでもいいし呼び出さなくてもいいから、使う構造体の型を呼ぶコードをどっかに書いておく
static void _CompilerHint()
{
    new MyImpl().MyMethod(default(int));
}

void Awake()
{
    IMyInterface intf = new MyImpl();
    intf.MyMethod(100); // ↑により死なない
}
</code></pre>
<p>実体で実際に使う型を用いて呼び出してるコードを書いておくと死なずに済みます。実際に呼び出す必要はなくて、とにかく書いてあればいいです。イメージとしてはコンパイラにヒントを与えるような感じ。なのでまぁ、1. インターフェイスで受けないようにする 2.受けなきゃならないシチュエーションがあるなら（まぁそりゃあるよね）どっかに定義沢山書きだしておく。ことにより神回避。オマジナイのようでいて実際効果あるからshoganai。</p>
<p>あと、ジェネリクスはメソッドじゃなくてインターフェイスのほうがTなら死にません。IMyInterface&lt;T&gt;みたいなほう。</p>
<h2>LambdaとGenericsとStruct</h2>
<p>Genericsのラムダ作って構造体渡すと死にます、例によって渡すのがクラスなら死にません。</p>
<pre><code class="language-csharp">// こんなメソッドがあるとして
static void Death&lt;T&gt;()
{
    var act = new Action&lt;T&gt;(_ =&gt; { Debug.Log(&quot;hoge&quot;); }); // ここではまだ死なない

    // System.ExecutionEngineException: Attempting to JIT compile method '&lt;Death&gt;b__0&lt;int&gt; (int)' while running with --aot-only.
    act(default(T)); // 呼び出すと死ぬ
}

// こんなコード呼び出しすると死ぬ
Death&lt;int&gt;();
</code></pre>
<p>こんな入り組んだコード書かないって？いや、案外このパターンに当てはまっちゃったりしたりするんですよ。特にライブラリ書いたりする人だとラムダ式の使いどころによっては、こういうパターンになりがちで頭抱えます。解決策はラムダ式使うのやめよう！じゃあなくて、簡単な解決策があります。</p>
<pre><code class="language-csharp">static void Death&lt;T&gt;()
{
    var _dummy = 0;
    var act = new Action&lt;T&gt;(_ =&gt; 
    {
        Debug.Log(&quot;hoge&quot;);

        _dummy.GetHashCode(); // なんでもいいから外側の変数をキャプチャする
    });

    act(default(T)); // 死なない
}
</code></pre>
<p>ラムダ式は外側の変数をキャプチャするかしないかによって、生成されるコードが変わってきます。そこがミソで、勿論キャプチャしないほうが本来は効率がいいんですが、AOTで死んでしまっては元も子もない。キャプチャすることによってAOTで死なないコードが生成されます、というわけで、入り組んだシチュエーションでラムダ式使いたい場合は意図的に外側の変数をキャプチャすることで回避できます。これは思いついた時は思わず叫んじゃいましたね！マジで！（そんだけこの問題に悩まされてたんですよ……）</p>
<h2>参照型で死ぬ</h2>
<p>型引数がクラスなら死ぬことはない、と思っていた時もありました。残念ながら、死ぬ時があるんですねぇー。いや、正確にはclass＋structで死ぬ、なんですが、struct+structだと死なないのが癪。これは後述しますがLINQのSumがクラスで死ぬ理由が分からなくて再現コード作ってたらこうなったって感じです。よくわからないけど、こうなった。</p>
<pre><code class="language-csharp">public static void Run()
{
    // 参照型でメソッドを呼ぶ
    // System.ExecutionEngineException: Attempting to JIT compile method 'Method2&lt;int, object&gt; ()' while running with --aot-only.
    Method1&lt;object&gt;();
}

// 1型引数でメソッドを呼ぶ際に片方が値型
public static void Method1&lt;T1&gt;()
{
    Method2&lt;int, T1&gt;();
}

// 2型引数で戻り値がある(戻り値の型はなんでもいいけどvoidはダメ)
static string Method2&lt;T1, T2&gt;()
{
    return &quot;&quot;;
}
</code></pre>
<p>ちなみにMethod1&lt;int&gt;みたいに、struct渡すんなら動くんですよね、逆にこれは。クラスだと死ぬ。どうしてこうなるのか、ちょっとこれはよくわからないですね、ともかくクラスでも油断すると死ぬということはよくわかりました、あべし。</p>
<h2>LINQで死ぬ</h2>
<p><a href="http://tanku.hatenablog.jp/entry/20130604/1370318678">UnityのiOSビルドで使うとエラーになるLINQ拡張メソッドのメモ</a>といった記事もありますが、実際死にます。これは濡れ衣みたいなものなんですけどねぇ、別にLINQが悪いわけじゃないし、それでLINQ使わない！LINQ禁止！とか絶対言って欲しくないです。LINQのないC#なんてC#じゃないです。C#の魅力の8割はLINQなのですから。と、それは置いておいて、実際幾つかのLINQのメソッドは死にます。</p>
<p>例えばAverage(selector)。</p>
<pre><code class="language-csharp">// System.ExecutionEngineException: Attempting to JIT compile method 'System.Linq.Enumerable:&lt;Average`1&gt;m__20&lt;int&gt; (long,int)' while running with --aot-only.
Enumerable.Range(1, 3).Average(x =&gt; x);
</code></pre>
<p>なんで死ぬのかというと、ソース見れば簡単に分かります。<a href="https://github.com/Unity-Technologies/mono/blob/unity-staging/mcs/class/System.Core/System.Linq/Enumerable.cs#L264">Unity-Technologies/monoからEnumerable.cs</a>の該当行を見ると</p>
<pre><code class="language-csharp">return source.Select (selector).Average&lt;int, long, double&gt; ((a, b) =&gt; a + b, (a, b) =&gt; (double) a / (double) b);
</code></pre>
<p>お分かりかな？そう、「LambdaとGenericsとStruct」のところで見たように、Genericsのメソッドの中で値型のラムダが放出されてます。そう、結構あるんですよ、Genericsのメソッドの中にラムダを埋めてしまうのって。さて、で、これは死にます。具体的に死んだ箇所は、エラー履歴の一番上のat...のとこ見れば</p>
<pre><code class="language-csharp">// at System.Linq.Enumerable.Average[Int32,Int64,Double] (IEnumerable`1 source, System.Func`3 func, System.Func`3 result) [0x00000] in &lt;filename unknown&gt;:0 
</code></pre>
<p>privateメソッドのAverage(↑でいうAverage[int, long, double]のとこ)で死んでるのが分かります。基本的に呼び出すタイミングで死ぬのでfunc(total, element)ってとこが死亡地点だと推測付きます。</p>
<p>これの対処方法は？ないよ！System.Core.dllの中のコードだから手が出せません。もはや使わないしか選択できません！もしくは、自前実装してAverageSafeとかって拡張メソッドを用意するとか、ですかねえ。それも悪くはないと思います、shoganaiし。</p>
<p>で、実はこの問題は当然mono本体は気付いていて、mono 2.8では改善されています。<a href="https://github.com/mono/mono/commit/071f495d6a4ce4951e2b2c9069586bd5bcde5fbb">該当コミット</a>を見れば、ラムダ使って共通化されてるコードがコピペに置き換えられてます:) これがAOTセーフだ！みたいな。はい、ライブラリには苦労してもらいましょう、使う側が快適ならそれで、それがいいのです。</p>
<p>残念ながら現在のUnity(4.5.1)のmonoは2.6で、しかも2.8へのUpgradeは蹴られてます。3.0（そう、monoの最新はもう遠いところにある、Unity置いてかれすぎ）へのアップデートは、もしやる気があるとしても大仕事になるだろうから、当面は来そうにないですねえ。でもmono 2.8で改善されたのって4年前なんですよね、4年前から変わらずLINQ（の一部）が使えないUnity……、残念です。とりあえずダメ元でEnumerable.csだけでもバージョンあげてくれ！ってFeedbackを出したので、よければVoteしてください。<a href="http://feedback.unity3d.com/suggestions/upgrade-enumerable-dot-cs-for-avoid-aot-problem-of-linq-average-etc-dot-dot-dot">Upgrade Enumerable.cs for avoid AOT Problem of LINQ(Average etc...)</a></p>
<p>XamarinのほうはAOTに関しても先を行っているようで、詳しくはXamarinの中の人である榎本さんの<a href="http://www.buildinsider.net/mobile/insidexamarin/06">インサイドXamarin（6）</a>の真ん中辺りに書いてあります。最新のXamarinと昔のXamarinと、そしてUnityとではAOTの制限がそれぞれ微妙に違っててなんとも。しかしXamarin、じゅる、いいなぁ……。</p>
<p>UnityのLINQでは他にも明らかに使えないメソッドがあって、例えばThenBy。</p>
<pre><code class="language-csharp">// System.ExecutionEngineException: Attempting to JIT compile method 'System.Linq.OrderedEnumerable`1&lt;int&gt;:CreateOrderedEnumerable&lt;int&gt; (System.Func`2&lt;int, int&gt;,System.Collections.Generic.IComparer`1&lt;int&gt;,bool)' while running with --aot-only.
Enumerable.Range(1, 3)
    .OrderBy(x =&gt; x)
    .ThenBy(x =&gt; x)
    .ToArray();
</code></pre>
<p>死にます。これも最新のmonoでは解決しています、<a href="https://github.com/mono/mono/blob/master/mcs/class/System.Core/System.Linq/Enumerable.cs#L2839">該当ソース</a></p>
<pre><code class="language-csharp">#if FULL_AOT_RUNTIME
			var oe = source as OrderedEnumerable &lt;TSource&gt;;
			if (oe != null)
				return oe.CreateOrderedEnumerable (keySelector, comparer, false);
#endif
</code></pre>
<p>これは「InterfaceとGenericsとStruct」のとこに書いた制限を回避してます。IOrderedEnumerableというインターフェイスのままCreateOrderedEnumerableを呼ぶと死ぬので、OrderedEnumerableにキャストして具象型に戻すことによってうまく動くようにしています。ThenByは便利なので使いたいものですねえ（まぁ富豪な処理なのでゲーム向けかと言われるとビミョーですが）</p>
<p>最後に、Sumは参照型でも死にます。逆に値型だと生き残れます。</p>
<pre><code class="language-csharp">// System.ExecutionEngineException: Attempting to JIT compile method 'System.Linq.Enumerable:Sum&lt;object, int&gt; (System.Collections.Generic.IEnumerable`1&lt;object&gt;,System.Func`3&lt;int, object, int&gt;)' while running with --aot-only.
Enumerable.Empty&lt;object&gt;().Sum(x =&gt; (int)x);
</code></pre>
<p>これは「参照型で死ぬ」パターン、ソースコードの該当箇所を見ると……</p>
<pre><code class="language-csharp">public static int Sum&lt;TSource&gt; (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int&gt; selector)
{
	Check.SourceAndSelector (source, selector);

	return Sum&lt;TSource, int&gt; (source, (a, b) =&gt; checked (a + selector (b)));
}

static TR Sum&lt;TA, TR&gt; (this IEnumerable&lt;TA&gt; source, Func&lt;TR, TA, TR&gt; selector)
{
	TR total = default (TR);
	long counter = 0;
	foreach (var element in source) {
		total = selector (total, element);
		++counter;
	}

	return total;
}
</code></pre>
<p>これねえ、なんで参照型で死ぬのか本当にさっぱり分からなかったけど、とりあえずSum&lt;TSource, int&gt;で二回層掘ってるのが死因っぽいです、片方はint固定で、二階層目は戻り値TRっていう。Max, Minが参照型のみ死ぬもの同じようなコードだった。これで死ぬとかもはや理不尽さしか感じなくて怖い怖い。ちなみにmonoの最新版のコードではメソッドは一回層で重複上等のハイパーコピペになってます（勿論それによりExceptionは発生しなくなる）、それでいいです、はい、ほんと。</p>
<p>そんなわけでLINQは一部の地雷メソッドに注意しながら使う！まぁ、それはそれでいいんですが（地雷が怖いから使わないってのはNG）、やっぱ地雷が埋まってるのは怖い。というわけで、Unityのmonoのランタイムが新しくなってくれるのが一番なのですが現実はそれを待ってはいられないので、mono本体のEnumerable周辺コードを頂いて、名前空間だけ、例えばSystem.LinqExとかにして、基本そちらをusingするようにするっていう風にして回避するのがいいんじゃないかしら、というか私はそうしてます。この辺は名前空間の切り分けだけでなんとかなる拡張メソッドの良さですね。</p>
<h2>Enumで死ぬ</h2>
<p>簡単にはEnumの配列をToArrayすると観測できる！</p>
<pre><code class="language-csharp">// こんなEnumがあるとして
public enum MyEnum
{
    Apple
}

// ToArrayで問答無用で死ぬ
// System.ExecutionEngineException: Attempting to JIT compile method '(wrapper managed-to-managed) MyEnum[]:System.Collections.Generic.ICollection`1.CopyTo (UniRx.MyEnum[],int)' while running with --aot-only.
new[] { MyEnum.Apple }.ToArray();
</code></pre>
<p>(wrapper managed-to-managed)ってのが目新しくていいですね！これの対処方法は、元が配列とかListだと印象的にヤヴァいので空のイテレータに変えてやります、それもご丁寧にジェネリクスじゃないIEnumeratorを経由することで、なんとなく回避できます。</p>
<pre><code class="language-csharp">public static class AotSafeExtensions
{
    // こんなメソッドを用意しておくと
    public static IEnumerable&lt;T&gt; AsSafeEnumerable&lt;T&gt;(this IEnumerable&lt;T&gt; source)
    {
        var e = ((IEnumerable)source).GetEnumerator();
        using (e as IDisposable)
        {
            while (e.MoveNext())
            {
                yield return (T)e.Current;
            }
        }
    }
}

// 死なない！
new[] { MyEnum.Apple }.AsSafeEnumerable().ToArray();
</code></pre>
<p>ヤヴァそうな香りがしたらAsSafeEnumerableを呼ぶ、という対処療法で勝つる。かなぁ……？</p>
<h2>実機を使わないでAOTのテストする方法</h2>
<p>ここまでで例外の発生パターンと対処法は終わり。じゃあ実際、こういった問題をどう検出するか、ひたすら実機テスト？というのも辛い。で、AOT自体はmono本体にもあって、そして現在のUnityはmono 2.6相当です。というわけでmono 2.6でAOTを動かせばいいんじゃろ？<a href="http://www.mono-project.com/AOT">mono --full-aot hoge.exe</a>と書くだけで、iOS実機とほぼほぼ同等のAOT例外が検出できます(この記事の範囲だとInterlocked.CompareExchange以外は同じ)。MonoBehaviourとかは無理ですがロジック系だったらNUnitでユニットテスト書いて、回すことで自動テスト可能になります。</p>
<p>実際、私はこの記事を書くにあたって、Windows + Visual Studio 2013でC#を書いて.exe(ConsoleApplication)作って、それを会社の同僚の作ってくれたexeを渡すとfull-aotで実行して結果表示してくれるウェブサービスに突っ込んで延々と動作確認してました。超捗る。むしろ同僚が神だった。実機とかやってられない。そもそもUnity書くのもVisual Studioじゃなきゃ嫌だ(<a href="http://neue.cc/2014/04/10_450.html">UnityVS - Unity開発におけるVisual Studio利用のすすめ</a>)。</p>
<h2>UniRx</h2>
<p>なんで延々と調べたかというと、今、私は<a href="https://github.com/neuecc/UniRx">UniRx - Reactive Extensions for Unity</a>というライブラリを作っていて、というか実際アセットストアにも既に公開されているんですが（無料です！）、例によってiOSで動かなくて！で、重い腰を上げて調べたのでした。パターンさえ分かってしまえば、まあ十分対応できる範囲ですねー、というわけでバシバシと動かなくなる箇所を殺してる最中です。</p>
<p>UniRx自体はブログ記事をそのうち書く書く詐欺で(一応、<a href="http://www.slideshare.net/neuecc/unityrx-reactive-extensions-for-unity">ちょっとだけ発表した時の資料はある</a>)、ええと、AOTの対処が終わったら書く！というのと、<a href="http://unityassetjp.doorkeeper.jp/events/12698">【第1回】UnityアセットまみれのLT大会</a>でLTするつもりなので、そちらでもよろしくお願いします。というか是非いらしてください、お話しませう。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
