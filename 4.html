<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2020-12-15" data-pagefind-meta="published:2020-12-15"><a href="https://neue.cc/2020/12/15_597.html">UnitGenerator - C# 9.0 SourceGeneratorによるValueObjectパターンの自動実装とSourceGenerator実装Tips</a></h1>
<ul class="date"><li>2020-12-15</li></ul>
<div class="entry_body"><p>ValueObjectは好きですか？私は大嫌いです。いじょ。</p>
<p>ざっくり言えばプリミティブ型に専用の型を付ける教義です。例えばUserIdをintとして扱っているとTeamIdと取り違えるかもしれないし、Hpに突っ込んでしまうかもしれない。StrengthとIntelligenceとAgilityとSpeedは別物なのだから全部intじゃなくて区別して欲しい、そうじゃないと間違った演算しちゃうぞ、と。まぁそういう自体を避けるために、それぞれラップした個別型を作るのです。int strengthじゃなくてStrength strengthだぞ、と。</p>
<p>これは一見正しく実際正しいのですが、問題もあります。一つに面倒くさい。ラップしたctorを作るのだけでも定形でウザ、と思いますが、更に等値とか実装するのは面倒くさい。また、そのままだと計算できなくなるので、算術演算のために生の値を<code>.Value</code>で取り出す、が頻出すると安全度も下がるし見た目もめっちゃ汚くなる、当然ながらものすごく書きづらい。そしてシリアライゼーションの問題。Serialize(userId)としたときに「{ &quot;Value&quot; = 100 }」なんて形にシリアライズされたら最低で、全く許容できない。また、データベースで扱うときにもORMはそのままだとプリミティブしか扱えないので、マッピングできなくて不便なことになります。</p>
<p>といった問題があるため、基本的には大嫌いなのでそういうのやらない、プリミティブで何が悪いんだボケ。ぐらいの勢いでした。実際、社内でそうしたい、という話があった場合にはトップダウン権限で却下してたぐらいです（横暴！）。のですが、上記の問題が解決するのならば、全然許せます。むしろ良い。むしろすべき。かもしれません。</p>
<p>そこで C# 9.0 から新搭載されたSourceGeneratorの出番です。SourceGeneratorを活用したUnitGeneratorというライブラリを新しく作りました。今回はその内容の解説と、SourceGeneratorを実装する上でのTipsを紹介します。また、この記事は <a href="https://qiita.com/advent-calendar/2020/csharplang2">C# その2 Advent Calendar 2020</a> 15日用です。19日にも<a href="https://qiita.com/advent-calendar/2020/csharplang">C# Advent Calendar 2020</a>でSourceGeneratorネタを書く予定なので、まずはPart 1ということで合わせてお楽しみください。</p>
<p>ちなみにC# Advent Calendar 2020の初日の記事 <a href="https://qiita.com/RyotaMurohoshi/items/83775cf4ed1ce4f6378d">C# 9.0で加わったC# Source Generatorと、それで作ったValueObjectGeneratorの紹介</a> と内容的には非常に似通ってるんですが、そこはshoganai。また<a href="https://qiita.com/pierusan2010/items/d66b835240af30955da6">C#9.0 SourceGeneratorでReadonly構造体を生成するGeneratorを作ってみました。</a>とも被ってますね、しょーがしょーがない。</p>
<h2>SourceGeneratorの特性</h2>
<p>GitHubとNuGetに<code>UnitGenerator</code>として公開しました（この記事でも後で触れますが、ReadMe末尾にはUnityでの使い方も載せてあります）。</p>
<ul>
<li><a href="https://github.com/Cysharp/UnitGenerator">Cysharp/UnitGenerator</a></li>
</ul>
<p>使い方は、<code>public readonly partial struct</code>に対して、<code>[UnitOf(typeof(T))]</code>を書くだけです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using UnitGenerator;

[UnitOf(typeof(int))]
public readonly partial struct UserId { }
</code></pre>
<p>これを書くと、SourceGeneratorが裏側で以下のpartial classをコンパイル時（ビルド前）に生成します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[System.ComponentModel.TypeConverter(typeof(UserIdTypeConverter))]
public readonly partial struct UserId : IEquatable&lt;UserId&gt; 
{
    readonly int value;
    
    public UserId(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(UserId value) =&gt; value.value;
    public static explicit operator UserId(int value) =&gt; new UserId(value);
    public bool Equals(UserId other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;UserId(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in UserId x, in UserId y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in UserId x, in UserId y) =&gt; !x.value.Equals(y.value);

    private class UserIdTypeConverter : System.ComponentModel.TypeConverter
    {
        // snip...
    }
}
</code></pre>
<p>SourceGeneratorのいいところは、生成コードがC#コンパイラのメモリ内で完結していることです。つまり、ファイルが出てきません。ファイルが出てこないのは非常にいいことで、自動生成ファイルが減った時の管理をしなくてすみます。ディレクトリごと毎回Cleanするのもイマイチですし、かといって古いファイルが残り続けるのはマズいので、そこの管理をどうするか問題は毎度面倒くさいことです。</p>
<p>欠点はメモリ内で完結していることです。ソースが見えないとデバッガビリティも下がりますし、コンパイルしないと追加されたコードが使えないというのもコード書いてる最中の手触り的に面倒。というのが一般的な話なのですが、そこを言語組み込みの機能として用意したことでカバーしているのがSourceGeneratorの良いところです。まず、デバッガビリティに関してはIDE(Visual Studioなど)でコードジャンプできるようになっているし、デバッガのステップ実行もフルサポート。また、IDEのインクリメンタルコンパイルとフルに連動しているため、属性を書いた瞬間から、裏ではそこの部分だけコンパイルが走ってコードが生成されて、生成コードが利用可能になっています。これは今までのビルド時プリプロセッサー/ポストプロセッサーではできなかった体験で、中々小気味良いものです。</p>
<p>唯一の欠点は既存コードをEditできないので、partialであることが必須になることと、編集を要求する内容は作れないことでしょうか。まぁ、それは従来あったAnalyzer(CodeFixProvider)でやればいいということで、それなりに棲み分けもできてますし、ソースコードの追加しかできないという仕様のお陰で、作成に関してはかなりシンプルになったこともいいことです。</p>
<h2>UnitGenerateOptions</h2>
<p>値の等値性だけを実装するのはままあるのですが、それだけだと不便なんですよね。例えばHpは + 100 とかそのまま演算したいじゃん、と。その辺のサポートがないとすぐに.Valueで生の値を取り出すことになって
よくないし、MinやMaxなんかもそのまんま使いたい、例えばHpを現在値の2倍で回復する、みたいなのは <code>target.Hp = Hp.Min(target.Hp * 2, target.MaxHp)</code> と書けたるとかなり自然でいいよね、と。</p>
<p>その辺の生成をサポートするのが UnitGenerateOptions で、これを組み合わせることによって、算術演算子など好きなメソッドが追加されます。UserIdのようなものは算術演算子が生成されては困るので抑制したいし、Hpはフルで生成したい、みたいな使い分けができます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Hp { }

// -- generates

[System.ComponentModel.TypeConverter(typeof(HpTypeConverter))]
public readonly partial struct Hp : IEquatable&lt;Hp&gt; , IComparable&lt;Hp&gt;
{
    readonly int value;

    public Hp(int value)
    {
        this.value = value;
    }

    public readonly int AsPrimitive() =&gt; value;
    public static explicit operator int(Hp value) =&gt; value.value;
    public static explicit operator Hp(int value) =&gt; new Hp(value);
    public bool Equals(Hp other) =&gt; value.Equals(other.value);
    public override bool Equals(object? obj) =&gt; // snip...
    public override int GetHashCode() =&gt; value.GetHashCode();
    public override string ToString() =&gt; &quot;Hp(&quot; + value + &quot;)&quot;;
    public static bool operator ==(in Hp x, in Hp y) =&gt; x.value.Equals(y.value);
    public static bool operator !=(in Hp x, in Hp y) =&gt; !x.value.Equals(y.value);
    private class HpTypeConverter : System.ComponentModel.TypeConverter { /* snip... */ }

    // UnitGenerateOptions.ArithmeticOperator
    public static Hp operator +(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value + y.value)));
    public static Hp operator -(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value - y.value)));
    public static Hp operator *(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value * y.value)));
    public static Hp operator /(in Hp x, in Hp y) =&gt; new Hp(checked((int)(x.value / y.value)));

    // UnitGenerateOptions.ValueArithmeticOperator
    public static Hp operator ++(in Hp x) =&gt; new Hp(checked((int)(x.value + 1)));
    public static Hp operator --(in Hp x) =&gt; new Hp(checked((int)(x.value - 1)));
    public static Hp operator +(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value + y)));
    public static Hp operator -(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value - y)));
    public static Hp operator *(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value * y)));
    public static Hp operator /(in Hp x, in int y) =&gt; new Hp(checked((int)(x.value / y)));

    // UnitGenerateOptions.Comparable
    public int CompareTo(Hp other) =&gt; value.CompareTo(other);
    public static bool operator &gt;(in Hp x, in Hp y) =&gt; x.value &gt; y.value;
    public static bool operator &lt;(in Hp x, in Hp y) =&gt; x.value &lt; y.value;
    public static bool operator &gt;=(in Hp x, in Hp y) =&gt; x.value &gt;= y.value;
    public static bool operator &lt;=(in Hp x, in Hp y) =&gt; x.value &lt;= y.value;

    // UnitGenerateOptions.MinMaxMethod
    public static Hp Min(Hp x, Hp y) =&gt; new Hp(Math.Min(x.value, y.value));
    public static Hp Max(Hp x, Hp y) =&gt; new Hp(Math.Max(x.value, y.value));
}
</code></pre>
<p>この辺のメソッドがしっかり生成されることによって、プリミティブ型をそのまま使うのと遜色のない使用感が担保できるわけです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">if (character.Hp &lt;= 0) // Hp.GetType == typeof(Hp)
{
    // is dead.
}
</code></pre>
<p>みたいに書けるようになってとても嬉しい。</p>
<p>また、演算子のオーバーロードはしっかり考慮して作るのが地味に大変な代物なので、そこをちゃんとやってくれるのも助かりです。例えばboolの場合はtrue演算子を自動実装します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static bool operator true(Foo x) =&gt; x.value;
public static bool operator false(Foo x) =&gt; !x.value;
public static bool operator !(Foo x) =&gt; !x.value;
</code></pre>
<p>こんなの自分で実装する機会なんてほとんどないと思いますが、これによってifに直接突っ込めるようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">if (foo) // foo.GetType() == typeof(Foo)
{
}
</code></pre>
<p>UnitGenerateOptionsは現在のところ以下のオプションを提供しています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[Flags]
internal enum UnitGenerateOptions
{
    None = 0,
    ImplicitOperator = 1,
    ParseMethod = 2,
    MinMaxMethod = 4,
    ArithmeticOperator = 8,
    ValueArithmeticOperator = 16,
    Comparable = 32,
    Validate = 64,
    JsonConverter = 128,
    MessagePackFormatter = 256,
    DapperTypeHandler = 512,
    EntityFrameworkValueConverter = 1024,
}
</code></pre>
<p>例えば以下のように指定できます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]
public readonly partial struct Strength { }

[UnitOf(typeof(DateTime), UnitGenerateOptions.ParseMethod | UnitGenerateOptions.Comparable)]
public readonly partial struct EndDate { }

[UnitOf(typeof(string), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct Message { }

[UnitOf(typeof(byte[]))]
public readonly partial struct Image { }

[UnitOf(typeof((string street, string city)), UnitGenerateOptions.Validate)]
public readonly partial struct StreetAddress
{
    private partial void Validate()
    {
        if (!DataMaster.Contains(value.street)) throw new Exception(&quot;Invalid Street: &quot; + value.street);
        if (!DataMaster.Contains(value.city)) throw new Exception(&quot;Invalid City: &quot; + value.city);
    }   
}
</code></pre>
<p>Validateだけ少し特殊で、自動生成側のコードが<code>partial void Validate()</code>メソッドを生成して、自動生成されるコンストラクタでそれを呼ぶようになっています。Validateの実体をユーザー側が書けばOKということですね。プリミティブ型と違って、値が検証済みであることが保証されている、というのも一般的なプラクティスとしては重要な話です。（ただしstructのため、default(T)は防げないので、そういう意味では完全なValidationではありません）</p>
<h2>シリアライザの自動実装</h2>
<p>繰り返しますが 「{ &quot;Value&quot; = 100 }」みたいにシリアライズされるのは最低です。「100」とシリアライズされなければならない。と、いうわけで、そういう場合は専用のシリアライザを実装すれば回避できます。現状はSystem.Text.JsonのJsonConverterとMessagePack用のMessagePackFormatterを自動実装するオプションが用意されています。こういうのをちまちま用意するのは、私がシリアライザについて人一倍拘りがあるからで、普通はあんまないでしょうね。でもシリアライザはシステムにおいて本当に大事なことだから！</p>
<p>例えば <code>UnitGenerateOptions.MessagePackFormatter</code> は以下のようなコードを自動実装します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter)]
public readonly partial struct UserId { }

// -- generates

[MessagePackFormatter(typeof(UserIdMessagePackFormatter))]
public readonly partial struct UserId 
{
    class UserIdMessagePackFormatter : IMessagePackFormatter&lt;UserId&gt;
    {
        public void Serialize(ref MessagePackWriter writer, UserId value, MessagePackSerializerOptions options)
        {
            options.Resolver.GetFormatterWithVerify&lt;int&gt;().Serialize(ref writer, value.value, options);
        }

        public UserId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new UserId(options.Resolver.GetFormatterWithVerify&lt;int&gt;().Deserialize(ref reader, options));
        }
    }
}
</code></pre>
<p>private classでFormatterが実装されるのがポイントで、Attributeからそのフォーマッターを取り出すことで、外部のResolverへの登録をせずに専用の対応をしています。Serialize/DeserializeはResolver経由じゃなくて直接Writer/Readerのプリミティブ型を呼ぶことで高速化できますが、まぁそれは次の機会に。このコードを発展化させた、MessagePack for C#におけるSourceGenerator対応については12/19の記事で詳しく触れる予定です。</p>
<p>データベースに関しても UnitGenerateOptions.DapperTypeHandler, UnitGenerateOptions.EntityFrameworkValueConverter でDapperとEF Coreの対応コードを生成します。ただしこちらは自動利用のシステムがないので、手動で取り出して登録する必要があります。</p>
<h2>.Value is dead</h2>
<p>UnitGeneratorはpublicプロパティを一つも生成しません。つまり、.Valueはありません。私は.Valueによる値の取り出しが悪いプラクティスだと思っていて、カジュアルに使おうという気持ちを起こさないようにしています。演算子の生成なども用意してあるし、あとは専用のメソッドを自前で書いたりしていくなどで解決できるといいよね、と。</p>
<p>とはいえさすがに取り出せないのは不便というか実用的ではないので、<code>.AsPrimitive()</code> で取れます。プロパティではなくメソッドというだけで、心理的に少し抵抗感出るんじゃないでしょうか？制約なんてそのぐらいでいいでしょう。あんまりキツくやるのも好きではないので。</p>
<h2>Unityで使う</h2>
<p>Source Generatorは C# 9.0 の機能です。というわけで、2020年現在のUnityはどのバージョンもそれをサポートしていません。じゃあ使えないじゃんって話なのですが、幸いファイルとして生成する機能も用意されているので、外部コマンドを実行したら自動生成する、ぐらいの雰囲気でならUnityでも使うことができます。</p>
<p>まずはコンフィグとなるcsprojを用意します。例えばUnitSourceGen.csprojとして、以下のような内容のものを作ります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;

        &lt;!-- add this two lines and configure output path --&gt;
        &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
        &lt;CompilerGeneratedFilesOutputPath&gt;$(ProjectDir)..\Generated&lt;/CompilerGeneratedFilesOutputPath&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;!-- reference UnitGenerator --&gt;
        &lt;PackageReference Include=&quot;UnitGenerator&quot; Version=&quot;1.0.0&quot; /&gt;

        &lt;!-- add target sources path from Unity --&gt;
        &lt;Compile Include=&quot;..\MyUnity\Assets\Scripts\Models\**\*.cs&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとは <a href="https://dotnet.microsoft.com/download">.NET SDK</a>を入れて、コマンドを叩きましょう。</p>
<pre data-pagefind-ignore="all"><code>dotnet build UnitSourceGen.csproj
</code></pre>
<p>これで UnitGenerator\UnitGenerator.SourceGenerator*.Generated.cs がOutputPathに指定したところに生成されています。UnitGeneratorは、UnitOfAttributeやUnitGenerateOptionsも自動生成コードの中に含まれる仕様（ランタイムレス）なので、一回空の状態で実行すれば、それらのコードが生成されて利用可能になります。</p>
<h2>SourceGenerator実装の方法</h2>
<p>netstandard2.0のライブラリプロジェクトとして（いまのところnet5.0だとうまくいかない、これはVisual Studioが .NET Frameworkで動いているせいだから、らしい）Microsoft.CodeAnalysis.CSharpを参照します。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;3.8.0&quot; PrivateAssets=&quot;all&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>また、合わせてテスト用のプロジェクトを用意して、ライブラリプロジェクトを参照するようにしておくといいでしょう。プロジェクト参照を、OutputItemType=&quot;Analyzer&quot;にしておきます。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;LangVersion&gt;preview&lt;/LangVersion&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;ProjectReference Include=&quot;..\..\src\UnitGenerator\UnitGenerator.csproj&quot;
                          OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>あとはISourceGeneratorを実装するだけ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">[Generator]
public class SourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            // System.Diagnostics.Debugger.Launch();
        }
#endif 

        context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
    }

    // 実装しなくてもいいけど、この段階で対象になるファイルを引っ掛けておくとワンパスで処理できる
    class SyntaxReceiver : ISyntaxReceiver
    {
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
        }
    }
}
</code></pre>
<p>System.Diagnostics.Debugger.Launch() を入れておくと、デバッガでアタッチできて実装が捗ります。ただしVisual Studioがインクリメンタルコンパイル的にかなりの頻度でキックしてくるので、不要なときはコメントアウトしておくのが吉。また、SourceGeneratorの実装コードの変更にたいしてVisual Studioのキャッシュがうまく追随してくれなくて、実装中は挙動が腐ることがよくあるので、困ったときの再起動でやり過ごしましょう。</p>
<p>RegisterForSyntaxNotificationsは使っても使わなくてもどちらでもいいのですが(ExecuteのところでSyntaxTreeの全てが手に入るので探索し放題)、ここで大雑把でも引っ掛けておいたほうが、その後の処理が軽量になるので、使ったほうが基本的にはヨシ。</p>
<p>SourceGeneratorでユーザーが使う属性は、参照DLL内に含めておいてそれを使う場合と、参照DLLは完全に空にして、ソースジェネレーター自身が生成するパターンがあります。後者のパターンを使うと、ソースジェネレーターのためだけに参照DLLが増えることを避けれるので、今回のUnitGeneratorのような、生成コードが全ての処理を行うタイプのものは、そちらのパターンを使ったほうが良いでしょう。</p>
<p>やりかたは単純に最初に必要な属性を突っ込んでしまうという、ただそれだけなのですが一点注意なのは、この生成は絶対死守しましょう。Execute内で例外が発生したりすると、ここでAddSourceした属性の追加はキャンセルされます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Execute(GeneratorExecutionContext context)
{
    context.AddSource(&quot;UnitOfAttribute.cs&quot;, &quot;internal class UnitOfAttribute...);

    try
    {
        // manipulate syntax...
    }
    catch (Exception ex)
    {
        System.Diagnostics.Trace.WriteLine(ex.ToString());
    }
}
</code></pre>
<p>特にIDEのインクリメンタルコンパイルが稼働している状態だと、入力途中の「不完全なコード」が頻繁に飛んできます。こうした不完全なコードによる不正な構文木を正しくハンドリングするのはかなり難しく、例外を飛ばしてしまうのは正直避けられません。しかし、何があっても最初に生成する属性のAddSourceだけは維持しないと、「入力途中の不完全コード→例外発生で属性が吹っ飛ぶ→属性が吹っ飛ぶので入力補完が効かないどころか書いてるものが全てエラーになる」という負のループが発生します。なので、これに関してはtry-catchで握り潰しOKです。</p>
<p>コード生成のためのテンプレートですが、サンプルだとみんなstring interpolationでさっくり処理してますが、やめときましょう。複雑なコードを生成しようとすると破綻するので、よほど単純な生成じゃないならちゃんとテンプレートエンジン使いましょう。</p>
<p>じゃあ何を使えばいいのか、というとT4 Templateです。以前に<a href="http://neue.cc/2019/12/06_585.html">.NET Core時代のT4によるC#のテキストテンプレート術</a>という記事を書いたので、それを読んでくださいな。これの「実行時テキスト生成(TextTemplatingFilePreprocessor)」を使います。具体的なUnitGeneratorのテンプレートは<a href="https://github.com/Cysharp/UnitGenerator/blob/939e6d54d68dbb102d2986de5fe442b8780d4216/src/UnitGenerator/CodeTemplate.tt">UnitGenerator/CodeTemplate.tt</a>にあるので参考にどうぞ。ただたんにOptionによってifがちょろちょろある程度ですが、それでもこれをstring interpolationとStringBuilderで処理するのは無理があります。</p>
<p>ユニットテストに関しては <code>CSharpGeneratorDriver</code> というものが用意されているので、それで小さいCompilationを作って渡せばOK。ってどういうこっちゃという感じですが、<a href="https://gist.github.com/chsienki/2955ed9336d7eb22bcb246840bfeb05c">chsienki/GeneratorTests.cs</a>のコードをまんま使えばOKですね。中身は単純です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var comp = CreateCompilation(/* ソースジェネレーターの対象コード */);
var newComp = RunGenerators(comp, out var generatorDiags, new SimpleGenerator());

// あとはnewCompから生成コードを引っ張ってきて、それが意図通りの正しさかどうか見たり
Assert.Empty(newComp.GetDiagnostics()); // エラーなくちゃんと生成できてるかどうか
</code></pre>
<p>ただし、参照DLLを増やすと面倒くさい挙動したり、そもそも生成されたコードの挙動が正しいかどうかを見たい(UnitGeneratorでいうと算術演算子が正しいかとか、シリアライザの実装が正しいかとか）ほうが多いんじゃないかなーと思うので、普通にユニットテストプロジェクトにSourceGenerator参照して、それが生成されたコードを動かして普通にAssert書く、みたいなのでいいかな。私は実際そんなわけで、CSharpGeneratorDriver経由のテストはやめました。（というかそもそも普通のユニットテストもたいして書いてない説はある）</p>
<p>最後にNuGetへのパブリッシュについて。SourceGeneratorはAnalyerとして登録したいので、ひと手間いります。具体的には以下のように処理します。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;PropertyGroup&gt;
    &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;
    &lt;SuppressDependenciesWhenPacking&gt;true&lt;/SuppressDependenciesWhenPacking&gt;
&lt;/PropertyGroup&gt;

&lt;ItemGroup&gt;
    &lt;None Include=&quot;$(OutputPath)\$(AssemblyName).dll&quot; Pack=&quot;true&quot; PackagePath=&quot;analyzers/dotnet/cs&quot; Visible=&quot;false&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>IncludeBuildOutputで、自身のDLLを参照用として含めないようにします、これは前述の「参照DLLは完全に空にして、ソースジェネレーター自身が必要な属性を生成するパターン」を使う場合には自身の参照は不要だからですね。SuppressDependenciesWhenPackingは、これ設定しとかないとpack時に空なんだけど、という警告が出てくるので黙らせます。空なのは知っとるがな。</p>
<p>Analyzerとしてpackするにはanalyzers/dotnet/cs以下に配置すればいいだけ、ということで、そういう設定をしておきます。</p>
<p>一手間と言ってもこれだけです。昔はAnalyzerはPowerShell動かして小細工しなきゃいけないとか色々あって超絶面倒くさかったんですが、.NET 5時代の今は、だいぶ簡単になりました。</p>
<h2>まとめ</h2>
<p>ずっとF#の<a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure">Units of Measure</a>のようなものが欲しいと思っていたのですよね。プリミティブなのだけど型がついてる。コンパイル時には型が消えてプリミティブそのものになるのでオーバーヘッドがない。そのままでも色々な演算ができる。</p>
<p>UnitGeneratorはお洒落なsuffixで生成とかはできないし組み込みの単位の変換関係（グラムとキログラムとかインチとフィーととか）があるわけじゃないので、同じものかといったら全然別物ではありますが、しかしValue Objectパターンの実装としては必要十分で、雰囲気も近づけられたのではないかと思います。</p>
<p>C#において、1要素のstructはメモリレイアウト的にはプリミティブ型と同一なので、完全に消せるわけではないですが、オーバーヘッドも減らしていける余地があります(演算のたびにnewで包み直していたりするのも、Unsafe.Asを活用していけばなくせるので、だいぶ近づけはするかな、と）。</p>
<p>実際ちゃんと型がついているのは良い状態で最終的に捗るのは間違いないので、このUnitGeneratorのアプローチが役に立てば何よりですね、是非試してみてください。あと、SourceGeneratorも是非作っていきましょう！</p>
</div>
<h1 data-pagefind-sort="date:2020-11-16" data-pagefind-meta="published:2020-11-16"><a href="https://neue.cc/2020/11/16_596.html">MagicOnion v4 - .NET 5 と ASP .NET Core gRPC対応への進化</a></h1>
<ul class="date"><li>2020-11-16</li></ul>
<div class="entry_body"><p>Cysharpから<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion v4</a>を先週リリースしました。今回のリリースの実装はほぼ全て<a href="https://github.com/mayuki">@mayuki</a>さんにやってもらったので、詳細はそちらに丸投げドンとして(ReadMeもかなり書き換えてあるので、詳しいところはそちらも読んでください)、改めて .NET 5とgRPC、そしてMagicOnionの位置付けとロードマップなどを説明したいかな、と思います。</p>
<p>MagicOnion v4ではサーバーサイド側は完全に ASP.NET Core KestrelベースのPure C#実装になりました。今まではGoogleの提供していたgRPC C Coreを利用していたのですが、今回よりMicrosoft実装に切り替えています。これによりASP.NET Core MVCなどと基盤が共通化されたので、gRPCを提供しつつHTTP/1 REST APIの口やHTML出力を行うような同居がとてもやりやすくなりました。</p>
<p>そして何より、パフォーマンスが向上しています。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/99238325-ed574380-283c-11eb-91cb-5c6982dc6be8.png" width=640>
</p>
<p>.NET 5における性能向上に関しては<a href="https://devblogs.microsoft.com/aspnet/grpc-performance-improvements-in-net-5/">gRPC performance improvements in .NET 5</a>にて紹介されていますが、まず、gRPCと一口で言っても性能は言語によって千差万別です。HTTP/2だから速いとか、gRPCだから速いとか、そういうことはありません。大事なのは実装です。</p>
<p>gRPCの場合は、各言語での独自実装組(Java, Go, Rust)と、Cで作られているCoreのバインディング組(Ruby, Python, Node.js, etc...)に分かれます。バインディングだから低速だということはないのですが（そもそも高速なC++実装はC Coreの上に作られている）、どうしてもマーシャリング部分の実装の甘さや、各言語の部分に乗っかった箇所の実装の弱さに引っ張られて、性能が落ちやすい傾向にあります。</p>
<p>実際のところ、どれだけパフォーマンスに本気になって実装しているか、というところが性能に現れるので、わざわざ各言語で独自実装しているものは本気度が高く、バインディングで済ませているのは本気度が低い（動けば御の字）といったような見方でも良いでしょう。</p>
<p>C#も今まではC Coreのバインディングでしたが、.NET Core 3.1からPure C#実装が提供され、そして今回の.NET 5よりHTTP/2の性能向上に注力したことで、C++, Rust, Goと並ぶTier1の位置までパフォーマンス向上を果たしました。</p>
<p>もともとHTTP/1においても執念深く延々と性能改善施策を続けていて、ついに<a href="https://www.techempower.com/benchmarks/#section=data-r19&amp;hw=ph&amp;test=plaintext">TechEmpower Web Framework Benchmarks</a>では1位(Plaintextのみですが)を奪取しています。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/99238486-2099d280-283d-11eb-87b6-322730902eee.png" width=640>
</p>
<p>それ以外にも .NET 5では<a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/">Performance Improvements in .NET 5</a>として細かい対応を延々としてきたのがついに実ったという感じですね。<a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0/">Announcing .NET 5.0</a>で表明されていますが、.NET 5 は Unified Platformsを標榜してランタイムコンポーネント・コンパイラ・言語を統一するという話があります。そうした大きなバージョンアップに相応しい一歩なのではないでしょうか。</p>
<p>ちなみに、.NET 5、実質的に機能しだすのは.NET 6からで、5に関しては基礎固めと.NET Core 3のリブランディング的な感じなので、実際のインパクトは今の所あんまありません。</p>
<h2>gRPCとトランスポート中立、或いはQUIC</h2>
<p>色々な構成要素の塊がgRPCなのですが、それぞれの要素はプラガブルで分解可能だったりします。シリアライザはProtocol Buffersでなくてもいいし(C++実装は<a href="https://google.github.io/flatbuffers/">FlatBuffers</a>に置き換えられるものも用意されていたりするし、MagicOnionはMessagePackを使っています)、トランスポート層もHTTP/2的な決まりごとにさえ従えるのなら、ある程度は自由に変更できます、実際TCPではなくUNIX domain socketへの置き換えはプロセス間通信としてgRPCを使う場合にはままあります。</p>
<p>C Coreにべったりの場合は、換装の自由度が低かったりしたのですが、Pure C#に置き換わり、その辺の仕組みが全て ASP.NET Core の上に乗っかったことにより、比較的自由に弄れるようになっています。</p>
<p>既にASP.NET CoreにはQuic実装が<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Transport.Experimental.Quic/">Microsoft.AspNetCore.Server.Kestrel.Transport.Experimental.Quic</a>として(Experimentalですが)提供されています。<a href="https://github.com/microsoft/msquic">MsQuic</a>を基盤として利用するため、Quicの実装準拠度としても比較的信用が置けるでしょう。MsQuicはWindows Serverで使うため、当然ながら相当固い実装である必要があるからです。なお、MsQuic自体はクロスプラットフォームのためLinuxで動きます。</p>
<p>サーバーはそうして自由に対応できるとして、現状クライアント側がイマイチなのですが、そこは追々という感じでしょうか。</p>
<p>特にゲームでのリアルタイム通信での利用時に、TCPであることがボトルネックとなることは避けたいので、RUDPや、中国のネットワークゲームでよく使われる<a href="https://github.com/skywind3000/kcp/blob/master/README.en.md">KCP</a>による通信の口は用意しておきたいと思っています。QUICが大安定して全てそれで解決、みたいな時代が来ればいいんですけれどね。そう遠くはなさそうな感じがあるので、期待しています。</p>
<h2>gRPCとMagicOnion、StreamingHubとBidirectional Streaming</h2>
<p>gRPCの色々な構成要素の中でも最重要なのがprotoによる言語中立のスキーマとコードジェネレートにあるでしょう。MagicOnionは、そのprotoを投げ捨ててC# to C#に限定されるため、デメリットを超えるだけのメリットが必要です。</p>
<p>一つはprotoが言語中立であることによる表現力の乏しさを、C#そのものスキーマとすることで解決しています。protoの場合は少しのプリミティブとEnum、コレクションとマップのみですが（また、nullもない)、MagicOnionの場合は、C#そのものスキーマとして見立て、メッセージ形式にMessagePack for C#を利用することで、（ほぼ）全てのC#型が転送可能になっています。</p>
<p>例えば.NET 5ではWCFの置き換えにgRPCが推奨されていますが <a href="https://docs.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/migrate-request-reply">Migrate a WCF request-reply service to a gRPC unary RPC</a> 、protoへの書き換えが必要なことと、表現力のギャップに苦しむことがあります。MagicOnionならDataContractで表現された型は全てMessagePack for C#でシリアライズ可能ですし、OperationContractのメソッドの複数引数のような表現も可能なため、移行におけるギャップはほとんどありません。</p>
<p>また、gRPCは双方向のリアルタイム通信用にBidirectional streaming RPCが利用できますが、これは双方が投げっぱなしのAPIしか存在しないため、戻り値の取得や処理の完了の待機などが実装できません。更にエンドポイントとなる型も一つしか使えないため、大量のoneofで呼び出しの切り分け処理をするしかありません。</p>
<p>MagicOnion StreamingHubはBidirectional streaming RPCの上に、双方向にC#としての型やメソッドのルーティング処理をつけ、client -&gt; server -&gt; client の呼び出しでは戻り値の取得やエラー送信、完了待機のシステムを入れました。この基盤処理の実装によって、初めてgRPCで実用的なリアルタイム通信が可能になっています。なお、APIは <a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction">ASP.NET Core SignalR</a>に寄せたため、そちらの経験があれば比較的スムーズに移行できるはずです。</p>
<h2>UnityとgRPC</h2>
<p>MagicOnion v4ではサーバーサイド側は完全に ASP.NET Core KestrelベースのPure C#実装になりました。クライアント側も.NET Coreの場合はHttpClientベースのPure C#実装になりました。Unityは……？というと、引き続きC Coreベースの提供になります。Unity側の改善はMagicOnionにおいてはv5でなんとかする予定ですので少々お待ち下さい。</p>
<p>Unity側の実装がC Coreで提供されている状態は、初期セットアップが相当面倒くさくなっています。というのもGoogleがAndroid, iOS向けのビルドを雑にとりあえずといった感じで提供しているだけなので、そのまんまだと動かないという……。MagicOnionのReadMeの<a href="https://github.com/Cysharp/MagicOnion/#support-for-unity-client">Support for Unity Client</a>セクションで、その辺は手厚めに解説してはいます。例えばそのまんまだとiOS用のgRPC libが100MBを超えていてGitHubで扱えないという問題が発生するのですが、ReadMeに説明してあるストリッピングの手順に従ってもらえればlibのサイズを縮めることができます。</p>
<p>ほか、C Coreの持つネイティブコネクションのライフサイクルと、Unity上での頻繁なPlay/StopによるC#側のライフサイクルが自動では一致しないため、ネイティブコネクションがリークするとエディタごと巻き込んでフリーズする（この場合、コネクション管理を徹底してライフサイクルを一致させれば大丈夫）、といった面倒くさい問題が発生したりします。</p>
<p>また、Taskベースで作られているためアロケーションが多めという問題もあったり。</p>
<p>これらネイティブライブラリであることの問題は、Pure C#実装を提供することで解決すると考えています。Task部分に関しては<a href="https://github.com/Cysharp/UniTask/">UniTask</a>を活用するように書き換えれば、アロケーションも減らせるでしょう。実際、Unity用のメジャーなOSSネットワークフレームワークであるMirror、の作者陣が内部分裂してForkされた<a href="https://github.com/MirrorNG/MirrorNG">MirrorNG</a>はUniTaskベースで構築されています。</p>
<p>Pure C#実装の場合は、UnityのC#ランタイムであるmonoがあまり性能が良いとは言えないため、問題になる可能性があるのですが、サーバーとして使わなければ大丈夫なのではないかと踏んでいます。フルUnity実装でサーバーを提供する場合は気になるところなのでネイティブ実装を混ぜるなどの方向性もあるとは思いますが、現状のMagicOnionの構成はUnityはクライアントにしかならないので。</p>
<h2>gRPCであること</h2>
<p>gRPCを推しているのは、HTTP/2に乗っかっていることでインフラ側のミドルウェアが豊富なことがあります。Nginx, Envoyなど、今ではほとんどのソフトウェアがHTTP/2対応していますし、AWS ALBに至っては<a href="https://aws.amazon.com/jp/blogs/news/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/">gRPC専用のサポート</a>を追加してきました。これらを活用することで、独自の通信形式などに比べると、サーバー構築の柔軟性が飛躍的に向上しています。独自っぽい雰囲気の漂っているMagicOnionも、変更しているのはメッセージの中身だけなので、gRPCのミドルウェアのエコシステムにはフルに乗っかれています（というか、ちゃんと乗れるように作っているのです）</p>
<p>また、自社で何もかもをすべて作らない、というのもあります。ASP.NET Coreに乗っかることで、Microsoftによる通信ライブラリの性能改善にタダ乗りしています。</p>
<p>gRPCそのもののメリットとしては、API通信とリアルタイム通信の二系統を一つのフレームワークに一本化できること、これは私が4年前にgRPCを採用した（当時は1.0が出たばかりでUnityの利用事例はゼロだし、一般の事例はマイクロサービスのサーバー間通信用としてが多くクライアント-サーバー通信を置き換えようとする例もあまりなかった）理由でもあります。</p>
<h2>ロードマップ</h2>
<p>v5におけるUnityクライアントの作成、ユーティリティとして負荷テストツールの提供、などがとりあえず並んでいます。特に負荷テストツールはあと少しなので、近日中にお届けできるかと。</p>
<p>MagicOnion自体のプロダクト採用の実績は増えてきていて、直近では<a href="https://d4dj.bushimo.jp/">D4DJ Groovy Mix</a>がAPI(Unary)もリアルタイムマルチ(StreamingHub)も活用しています。また、<a href="https://virtualcast.jp/">バーチャルキャスト</a> 2.0では、ルームというVR SNSの実装に活用されているそうです。</p>
<p>ゲームーサーバーとしてC#が活用できるのか？といったことは、クラスメソッドさん向けにお話したゲームサーバー用の発表でも話しましたので、レポ記事 - <a href="https://dev.classmethod.jp/articles/game-server-development-seminar-by-cysharp/">Cysharpの河合様をゲスト講師にお招きしてゲームサーバーに関する社内勉強会を開催しました！</a>と、発表資料もどうぞ。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/Gfd2wf6fsBsj3y" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/building-the-game-server-both-api-and-realtime-via-c" title="Building the Game Server both API and Realtime via c#" target="_blank">Building the Game Server both API and Realtime via c#</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>世の中、適材適所なのは間違いありません。だからこそ、「C#がその適材である」と言えるだけの環境を提供していく、というのがCysharpのミッションでもあります。Microsoftも.NET Coreにおいて、当初はWindowsべったりなC#が今更Linuxとか言ったって、みたいな白い目で見られていました。しかし、最初のバージョンから4年が経ち、文句を言わせないだけのパフォーマンスでもって証明してきました。</p>
<p>.NET 5はスタート地点だと考えています。C#も大変面白い環境になってきたと思うので、是非みんなと追求していけたら嬉しいですね。</p>
</div>
<h1 data-pagefind-sort="date:2020-10-01" data-pagefind-meta="published:2020-10-01"><a href="https://neue.cc/2020/10/01_595.html">ConsoleAppFramework v3 - より強化されたC#のためのコマンドラインツール用フレームワーク</a></h1>
<ul class="date"><li>2020-10-01</li></ul>
<div class="entry_body"><p>.NET 5も控えていることだし、というのは関係ないのですが、CLIアプリケーションや大量のバッチをC#で簡単に作れるフレームワークであるところのConsoleAppFrameworkを思い立って更新しました。</p>
<ul>
<li>github - <a href="https://github.com/Cysharp/ConsoleAppFramework/">Cysharp/ConsoleAppFramework</a></li>
</ul>
<p>基本的な構成である、Generic Hostの上に乗っかるCLIフレームワークというコンセプトには変更ありません。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/72047323-a08e0c80-32fd-11ea-850a-7f926adf3d22.png" width=640 />
</p>
<p>メソッド定義がそのままコマンドライン引数になって、ヘルプなども自動生成してくれます。Host(ASP.NET Coreなどでも使う)の設定によってロガーやDIの設定、オプションの読み込みとバインディングも可能なので、細かいコンフィグレーションもそれで行えますし、基盤が一緒なためASP.NET Coreなどとの共通化なども可能になります。</p>
<p>一番単純な例を出すとこんな感じになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Program : ConsoleAppBase
{
    static async Task Main(string[] args)
    {
        await Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&lt;Program&gt;(args);
    }

    public void Hello([Option(&quot;m&quot;, &quot;Message to display.&quot;)]string message)
    {
        Console.WriteLine(&quot;Hello &quot; + message);
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">&gt; SampleApp.exe help

Usage: SampleApp [options...]

Options:
  -m, -message &lt;String&gt;    Message to display. (Required)

Commands:
  help          Display help.
  version       Display version.

&gt; SampleApp.exe -m World
Hello World
</code></pre>
<p>今回の変更内容は</p>
<ul>
<li>厳密っぽいオプション引数指定</li>
<li>version, helpコマンドをデフォルトでヘルプ表示</li>
<li>class/methodによる自動コマンド定義を class method コマンド引数で実行可能に(以前はClass.Methodだった)</li>
<li>Interceptorを廃止してFilterによる拡張</li>
</ul>
<p>Interceptorの廃止だけが破壊的変更で、それ以外は互換性取れています。</p>
<h2>厳密っぽいオプション引数指定</h2>
<p>厳密っぽいというか、 <code>-i, --input</code> のようにショート版の名前を-、ロング版の名前を--で一致を見るスタイルを適用可能にしました。デフォルトは-の数を無視します、つまり-inputでも--inputでも-----inputでも同じ扱いにしています。これ区別するの面倒くさいなーと思っていて、例えばgoのコマンドは全て-o, -outputみたいな-だけで済ませていて、私もそれでいいじゃん、むしろそれがいいじゃん、と思ってはいるのですが（なのでデフォルトはそう）、区別したい人も世の中には大勢いるとは思うので、そーいうオプションを足しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Program : ConsoleAppBase
{
    static async Task Main(string[] args)
    {
        await Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&lt;Program&gt;(args, new ConsoleAppOptions
        {
            StrictOption = true, // default is false.
            ShowDefaultCommand = false, // default is true
        });
    }

    public void Hello([Option(&quot;m&quot;, &quot;Message to display.&quot;)]string message)
    {
        Console.WriteLine(message);
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">&gt; SampleApp.exe help

Usage: SampleApp [options...]

Options:
  -m, --message &lt;String&gt;    Message to display. (Required)
</code></pre>
<p>デフォルトが <code> -m, --message &lt;String&gt;</code>だったhelpが、 <code>-m, --message</code> になっています。-messageという指定をすると、名前が合わないというエラーが出るようになります。</p>
<p>また、version, helpコマンドがデフォルトでヘルプ表示されるように今回からなりました。これもオプションで ShowDefaultCommand = false にすれば表示されなくなります（表示されなくなるだけで、コマンドとして存在はしています）。</p>
<h2>class/methodによる自動コマンド定義</h2>
<p>プロジェクトに沿ったバッチを作成する場合に、数十、時に数百個のバッチを作る必要があります。そうなると一々コマンド定義をしてる場合じゃねえ、という感じなので、自動でルーティングしてくれる機能がConsoleAppFrameworkにはあります。 MVCフレームワークがclass/methodでURLルーティングするのと同様に、class methodというサブコマンド階層を自動で生成してくれます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">class Program
{
    static async Task Main(string[] args)
    {
        // &lt;T&gt;を指定しないとアセンブリ全体から実行コマンドとなるクラスを検索して登録する
        await Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync(args);
    }
}

public class Foo : ConsoleAppBase
{
    public void Echo(string msg)
    {
        Console.WriteLine(msg);
    }

    public void Sum([Option(0)]int x, [Option(1)]int y)
    {
        Console.WriteLine((x + y).ToString());
    }
}

public class Bar : ConsoleAppBase
{
    public void Hello2()
    {
        Console.WriteLine(&quot;H E L L O&quot;);
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">&gt; SampleApp.exe help
Usage: SampleApp &lt;Command&gt;

Commands:
  foo echo
  foo sum
  bar hello2
  help          Display help.
  version       Display version.

&gt; SampleApp.exe foo sum 10 30
40
</code></pre>
<p>前のバージョンでは &quot;Foo.Sum&quot; というコマンド名での呼び出しだったのですが、それはコマンドラインツールとして不自然だろう、ということで、小文字の &quot;class method&quot; で実行されるようになりました。互換性のために &quot;Foo.Sum&quot;といった指定でも実行可能です。</p>
<h2>Filterによる拡張</h2>
<p>ASP.NET Core や <a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a> のように、フィルターによって実行前後を拡張できるようになりました。実装はConsoleAppFilterを継承して、await nextを実行するという非同期スタイルです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MyFilter : ConsoleAppFilter
{
    // Filter is instantiated by DI so you can get parameter by constructor injection.

    public async override ValueTask Invoke(ConsoleAppContext context, Func&lt;ConsoleAppContext, ValueTask&gt; next)
    {
        try
        {
            /* on before */
            await next(context); // next
        }
        catch
        {
            /* on after */
            throw;
        }
        finally
        {
            /* on finally */
        }
    }
}

// ConsoleAppContext
public class ConsoleAppContext
{
    public string?[] Arguments { get; }
    public DateTime Timestamp { get; }
    public CancellationToken CancellationToken { get; }
    public ILogger&lt;ConsoleAppEngine&gt; Logger { get; }
    public MethodInfo MethodInfo { get; }
    public IServiceProvider ServiceProvider { get; }
    public IDictionary&lt;string, object&gt; Items { get; }
}
</code></pre>
<p>フィルターはグローバル(全てのメソッドで呼ばれる)、クラス、メソッド単位で付与することが可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// フィルターの呼び出し順序はOrderで設定可能
await Host.CreateDefaultBuilder()
    .RunConsoleAppFrameworkAsync(args, options: new ConsoleAppOptions
    {
        GlobalFilters = new ConsoleAppFilter[] { new MyFilter2 { Order = -1 }, new MyFilter() }
    });

[ConsoleAppFilter(typeof(MyFilter3))]
public class MyBatch : ConsoleAppBase
{
    [ConsoleAppFilter(typeof(MyFilter4), Order = -9999)]
    [ConsoleAppFilter(typeof(MyFilter5), Order = 9999)]
    public void Do()
    {
    }
}
</code></pre>
<h2>まとめ</h2>
<p>シンプルさと機能性のバランスがうまくとれてるんじゃないでしょうか。すごく細かい調整ができるわけではないので、そこはどうしても割り切りという感じになってしまうのですが、それでもほとんどのユースケースは満たせているんじゃないかと思います。</p>
<p>自動コマンド定義は大量にバッチを量産する場合に便利、でもあるのですが、それと同時にC#のプロジェクト一つで大量のバッチを管理できるようになる、というのも利点です。ファイル単位で管理するとわけわからん、ということになりがちですが、これなら綺麗に整理されますし、ロジックのメソッド化などで共通化もできます。また、フィルターを活用することによっても前処理や後処理などの共通化をより推し進められるでしょう。</p>
<p>大きなプロジェクトの一部としてのバッチアプリの場合、ASP.NET Coreなどのコンフィグに定義されているDBのパスなどが、同じジェネリックホストなのでそのまま読み込めるのも楽になれるポイントです。ロガーのパフォーマンスが必要な場合は、 <a href="https://github.com/Cysharp/ZLogger/">Cysharp/ZLogger</a>を使うと良いでしょう、ZLoggerも Microsoft.Extensions.Logging の上に構築されているので、ジェネリックホストが基盤になっているConsoleAppFrameworkではスムーズに使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">await Host.CreateDefaultBuilder()
    .ConfigureLogging(x =&gt;
    {
        x.ClearProviders();
        x.SetMinimumLevel(LogLevel.Trace);
        x.AddZLoggerConsole();
        x.AddZLoggerFile(&quot;fileName.log&quot;);
    })
    .RunConsoleAppFrameworkAsync(args);
</code></pre>
<p>と、いうわけでより強力になったConsoleAppFramework、是非使ってみてください。</p>
</div>
<h1 data-pagefind-sort="date:2020-08-20" data-pagefind-meta="published:2020-08-20"><a href="https://neue.cc/2020/08/20_594.html">async decoratorパターンによるUnityWebRequestの拡張とUniTaskによる応用的設計例</a></h1>
<ul class="date"><li>2020-08-20</li></ul>
<div class="entry_body"><p><a href="https://github.com/Cysharp/UniTask/">UniTask v2</a>も2.0.30まで到達し、いい加減そろそろ安定したと言える頃合いです（ほんと！）。GitHub Star数も1000を超えて、準スタンダードとして安心して使ってもらえるレベルまで到達したと思うので、基盤部分から入れ込んで設計するとこんなことができますよ、という一例を出してみます。</p>
<p>UnityWebRequestはかなりプリミティブな代物で、そのまま使うよりかはある程度はアプリケーションに沿ったラッパーを被せることがほとんどなのではないかと思います。しかし、ライブラリ単体でアプリケーションの要求を全て満たそうとするとヘヴィになりすぎたり、というかそもそもアプリケーション固有の要求には絶対に答えられない。というわけで、理想的なラッパーというのは、それ自身が極力軽量で、拡張性を持たせたプラガブルな仕組みが用意されているものということになります。プラガブルな拡張性がないと、例えば基盤ライブラリ側で用意されたラッパーをアプリケーションで使う場合にうまく要件をあわせられなくて、Forkして直接改造しちゃう、という不毛な自体になったりします。</p>
<p>と、いうものを実現するにあたって、非同期リクエストにつきもののコールバックは非常に相性が悪い。コールバックの連鎖は、コード上でその場でネストしていくだけだったら数階層ネストしてもまぁまぁなんとかなりますが、プラガブルで複雑な組み合わせを実現しようとするとハンドリング不可能になります。</p>
<p>そこでasync/await。async/awaitならコンパイラの力に頼ることでそういうものができます！</p>
<p>async decoratorパターンという名前で紹介しますが、一般にはMiddlewareとして知られているものを実装します。ASP.NET Core、node.js(Express)やReactのMiddleware、PythonのWSGI、MagicOnionではFilterとして実装している、サーバーサイドではよく使われるデザインです。これは非常に強力なデザインパターンで、クライアント処理においても有用だと私は考えています。もし知らなければ絶対に覚えるべき……！</p>
<p>MagicOnionのフィルターの図を持ってくるとこんな感じで</p>
<img src="https://user-images.githubusercontent.com/46207/50969421-cb465900-1521-11e9-8824-8a34cc52bbe4.png" width=600 />
<p>メソッドが外から内側に包まれて呼ばれていきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">await next(
    await next(
        await next()
    )
);
</code></pre>
<p>通常やりたいことってざっくり</p>
<ul>
<li>ロギング</li>
<li>モック</li>
<li>タイムアウト処理</li>
<li>リクエスト前のヘッダー処理</li>
<li>リクエスト後のヘッダー処理</li>
<li>ステータスコードに応じた例外時処理</li>
<li>エラー時の処理（ポップアップ/リトライ/画面遷移）</li>
</ul>
<p>といったことだと思われますが、この仕組みなら、これだけで全て実装できます……！</p>
<p>というわけで、実装例を見ていきましょう。</p>
<h2>デコレーター例</h2>
<p>まずは共通のインターフェイスとして以下のものを用意します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IAsyncDecorator
{
    UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next);
}
</code></pre>
<p>なるほどわからん。RequestContext、ResponseContextがそれぞれリクエスト/レスポンスに必要なデータが詰まっている単純な入れ物ということで特に気にしないこととして、大事なのはFunc nextです。</p>
<p>とりあえず、単純な例としてヘッダーの前後で処理するなにかを。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class SetupHeaderDecorator : IAsyncDecorator
{
    public async UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        context.RequestHeaders[&quot;x-app-timestamp&quot;] = context.Timestamp.ToString();
        context.RequestHeaders[&quot;x-user-id&quot;] = &quot;132141411&quot;; // どこかから持ってくる
        context.RequestHeaders[&quot;x-access-token&quot;] = &quot;fafafawfafewaea&quot;; // どこかから持ってくる2

        var respsonse = await next(context, cancellationToken); // 次のメソッドが呼ばれる

        var nextToken = respsonse.ResponseHeaders[&quot;token&quot;];
        UserProfile.Token = nextToken; // どこかにセットするということにする

        return respsonse;
    }
}
</code></pre>
<p>await next() によって連鎖しているデコレーターメソッドの内側に進んでいきます。つまり、その前に書けば前処理、後ろに書けば後処理になります。nextの定義がよくわからなくても、デコレーターを量産していくことは簡単です。そこが大事。そんなんでいいんです。</p>
<p>さて、async/awaitと統合されていることによって、try-catch-finallyも自然に書けます。例えばロギングを用意すると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class LoggingDecorator : IAsyncDecorator
{
    public async UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        var sw = Stopwatch.StartNew();
        try
        {
            UnityEngine.Debug.Log(&quot;Start Network Request:&quot; + context.Path);

            var response = await next(context, cancellationToken);

            UnityEngine.Debug.Log($&quot;Complete Network Request: {context.Path} , Elapsed: {sw.Elapsed}, Size: {response.GetRawData().Length}&quot;);

            return response;
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                UnityEngine.Debug.Log(&quot;Request Canceled:&quot; + context.Path);
            }
            else if (ex is TimeoutException)
            {
                UnityEngine.Debug.Log(&quot;Request Timeout:&quot; + context.Path);
            }
            else if (ex is UnityWebRequestException webex)
            {
                if (webex.IsHttpError)
                {
                    UnityEngine.Debug.Log($&quot;Request HttpError: {context.Path} Code:{webex.ResponseCode} Message:{webex.Message}&quot;);
                }
                else if (webex.IsNetworkError)
                {
                    UnityEngine.Debug.Log($&quot;Request NetworkError: {context.Path} Code:{webex.ResponseCode} Message:{webex.Message}&quot;);
                }
            }
            throw;
        }
        finally
        {
            /* log other */
        }
    }
}
</code></pre>
<p>また、処理を打ち切ることも簡単に実現できます。nextを呼ばないだけですから。例えばダミーのレスポンスを返す（テストに使ったり、サーバー側の実装が整わない間に進めたりするために）デコレーターが作れます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MockDecorator : IAsyncDecorator
{
    Dictionary&lt;string, object&gt; mock;

    // Pathと型を1:1にして事前定義したオブジェクトを返す辞書を渡す
    public MockDecorator(Dictionary&lt;string, object&gt; mock)
    {
        this.mock = mock;
    }

    public UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        // それと if (EditorProfile.EnableMocking) とか用意しておいて、モック使うかの有無をエディタ拡張辺りで切り替えれるようにしとくと楽
        if (mock.TryGetValue(context.Path, out var value))
        {
            // 一致したものがあればそれを返す（実際の通信は行わない）
            return new UniTask&lt;ResponseContext&gt;(new ResponseContext(value));
        }
        else
        {
            return next(context, cancellationToken);
        }
    }
}
</code></pre>
<p>リトライ的な処理も考えてみましょう。例えば特殊なレスポンスコードを受信したときは、Tokenを取ってから再度処理し直してくれ、みたいな要求があるとします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class AppendTokenDecorator : IAsyncDecorator
{
    public async UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        string token = &quot;token&quot;; // どっかから取ってくるということにする
        RETRY:
        try
        {
            context.RequestHeaders[&quot;x-accesss-token&quot;] = token;
            return await next(context, cancellationToken);
        }
        catch (UnityWebRequestException ex)
        {
            // 例えば700はTokenを再取得してください的な意味だったとする
            if (ex.ResponseCode == 700)
            {
                // 別口でTokenを取得します的な処理
                var newToken = await new NetworkClient(context.BasePath, context.Timeout).PostAsync&lt;string&gt;(&quot;/Auth/GetToken&quot;, &quot;access_token&quot;, cancellationToken);
                context.Reset(this); // RequestContextの状態が汚れてる（？）ので、nextを最初からやり直す場合はResetする
                token = newToken;
                goto RETRY;
            }

            throw;
        }
    }
}
</code></pre>
<p>シーケンシャルな処理を強制するために、キューを挟む場合はこのように書けます。私は並列リクエストできるなら極力並列にしたい派なので、あまりこういうのを挟むのは好きではないのですけれど、サーバー側の要求によっては必要な場合もあると思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class QueueRequestDecorator : IAsyncDecorator
{
    readonly Queue&lt;(UniTaskCompletionSource&lt;ResponseContext&gt;, RequestContext, CancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt;)&gt; q = new Queue&lt;(UniTaskCompletionSource&lt;ResponseContext&gt;, RequestContext, CancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt;)&gt;();
    bool running;

    public async UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        if (q.Count == 0)
        {
            return await next(context, cancellationToken);
        }
        else
        {
            var completionSource = new UniTaskCompletionSource&lt;ResponseContext&gt;();
            q.Enqueue((completionSource, context, cancellationToken, next));
            if (!running)
            {
                Run().Forget();
            }
            return await completionSource.Task;
        }
    }

    async UniTaskVoid Run()
    {
        running = true;
        try
        {
            while (q.Count != 0)
            {
                var (tcs, context, cancellationToken, next) = q.Dequeue();
                try
                {
                    var response = await next(context, cancellationToken);
                    tcs.TrySetResult(response);
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(ex);
                }
            }
        }
        finally
        {
            running = false;
        }
    }
}
</code></pre>
<p>簡単なものから結構複雑そうなものまで、そこそこ単純に書けることがわかったと思います！ただのawait nextという仕組みを用意するだけで！</p>
<p>用意したデコレーターはこんな風に使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// デコレーターの詰まったClientを生成（これは一度作ったらフィールドに保存可）
var client = new NetworkClient(&quot;http://localhost&quot;, TimeSpan.FromSeconds(10),
    new QueueRequestDecorator(),
    new LoggingDecorator(),
    new AppendTokenDecorator(),
    new SetupHeaderDecorator());

// 例えばこんな風に呼ぶということにする
var result = await client.PostAsync(&quot;/User/Register&quot;, new { Id = 100 });
</code></pre>
<h2>async decoratorを実装する</h2>
<p>ちょっと長くなりますが、そんな複雑なわけではありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 基本のインターフェイス
public interface IAsyncDecorator
{
    UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next);
}

// リクエスト用の入れ物
public class RequestContext
{
    int decoratorIndex;
    readonly IAsyncDecorator[] decorators;
    Dictionary&lt;string, string&gt; headers;

    public string BasePath { get; }
    public string Path { get; }
    public object Value { get; }
    public TimeSpan Timeout { get; }
    public DateTimeOffset Timestamp { get; private set; }

    public IDictionary&lt;string, string&gt; RequestHeaders
    {
        get
        {
            if (headers == null)
            {
                headers = new Dictionary&lt;string, string&gt;();
            }
            return headers;
        }
    }

    public RequestContext(string basePath, string path, object value, TimeSpan timeout, IAsyncDecorator[] filters)
    {
        this.decoratorIndex = -1;
        this.decorators = filters;
        this.BasePath = basePath;
        this.Path = path;
        this.Value = value;
        this.Timeout = timeout;
        this.Timestamp = DateTimeOffset.UtcNow;
    }

    internal Dictionary&lt;string, string&gt; GetRawHeaders() =&gt; headers;
    internal IAsyncDecorator GetNextDecorator() =&gt; decorators[++decoratorIndex];

    public void Reset(IAsyncDecorator currentFilter)
    {
        decoratorIndex = Array.IndexOf(decorators, currentFilter);
        if (headers != null)
        {
            headers.Clear();
        }
        Timestamp = DateTimeOffset.UtcNow;
    }
}

// レスポンス用の入れ物
public class ResponseContext
{
    readonly byte[] bytes;

    public long StatusCode { get; }
    public Dictionary&lt;string, string&gt; ResponseHeaders { get; }

    public ResponseContext(byte[] bytes, long statusCode, Dictionary&lt;string, string&gt; responseHeaders)
    {
        this.bytes = bytes;
        StatusCode = statusCode;
        ResponseHeaders = responseHeaders;
    }

    public byte[] GetRawData() =&gt; bytes;

    public T GetResponseAs&lt;T&gt;()
    {
        return JsonUtility.FromJson&lt;T&gt;(Encoding.UTF8.GetString(bytes));
    }
}

// 本体
public class NetworkClient : IAsyncDecorator
{
    readonly Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next;
    readonly IAsyncDecorator[] decorators;
    readonly TimeSpan timeout;
    readonly IProgress&lt;float&gt; progress;
    readonly string basePath;

    public NetworkClient(string basePath, TimeSpan timeout, params IAsyncDecorator[] decorators)
        : this(basePath, timeout, null, decorators)
    {
    }

    public NetworkClient(string basePath, TimeSpan timeout, IProgress&lt;float&gt; progress, params IAsyncDecorator[] decorators)
    {
        this.next = InvokeRecursive; // setup delegate

        this.basePath = basePath;
        this.timeout = timeout;
        this.progress = progress;
        this.decorators = new IAsyncDecorator[decorators.Length + 1];
        Array.Copy(decorators, this.decorators, decorators.Length);
        this.decorators[this.decorators.Length - 1] = this;
    }

    public async UniTask&lt;T&gt; PostAsync&lt;T&gt;(string path, T value, CancellationToken cancellationToken = default)
    {
        var request = new RequestContext(basePath, path, value, timeout, decorators);
        var response = await InvokeRecursive(request, cancellationToken);
        return response.GetResponseAs&lt;T&gt;();
    }

    UniTask&lt;ResponseContext&gt; InvokeRecursive(RequestContext context, CancellationToken cancellationToken)
    {
        return context.GetNextDecorator().SendAsync(context, cancellationToken, next); // マジカル再帰処理
    }

    async UniTask&lt;ResponseContext&gt; IAsyncDecorator.SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; _)
    {
        // Postしか興味ないからPostにしかしないよ！
        // パフォーマンスを最大限にしたい場合はuploadHandler, downloadHandlerをカスタマイズすること

        // JSONでbodyに送るというパラメータで送るという雑設定。
        var data = JsonUtility.ToJson(context.Value);
        var formData = new Dictionary&lt;string, string&gt; { { &quot;body&quot;, data } };

        using (var req = UnityWebRequest.Post(basePath + context.Path, formData))
        {
            var header = context.GetRawHeaders();
            if (header != null)
            {
                foreach (var item in header)
                {
                    req.SetRequestHeader(item.Key, item.Value);
                }
            }

            // Timeout処理はCancellationTokenSourceのCancelAfterSlim(UniTask拡張)を使ってサクッと処理
            var linkToken = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            linkToken.CancelAfterSlim(timeout);
            try
            {
                // 完了待ちや終了処理はUniTaskの拡張自体に丸投げ
                await req.SendWebRequest().ToUniTask(progress: progress, cancellationToken: linkToken.Token);
            }
            catch (OperationCanceledException)
            {
                // 元キャンセレーションソースがキャンセルしてなければTimeoutによるものと判定
                if (!cancellationToken.IsCancellationRequested)
                {
                    throw new TimeoutException();
                }
            }
            finally
            {
                // Timeoutに引っかからなかった場合にてるのでCancelAfterSlimの裏で回ってるループをこれで終わらせとく
                if (!linkToken.IsCancellationRequested)
                {
                    linkToken.Cancel();
                }
            }

            // UnityWebRequestを先にDisposeしちゃうので先に必要なものを取得しておく（性能的には無駄なのでパフォーマンスを最大限にしたい場合は更に一工夫を）
            return new ResponseContext(req.downloadHandler.data, req.responseCode, req.GetResponseHeaders());
        }
    }
}
</code></pre>
<p>コアの処理はInvokeRecursiveです。もう少し単純化すると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">UniTask&lt;ResponseContext&gt; InvokeRecursive(RequestContext context, CancellationToken cancellationToken)
{
    context.decoratorIndex++;
    return decorators[context.decoratorIndex].SendAsync(context, cancellationToken, InvokeRecursive);
}
</code></pre>
<p>というように、IAsyncDecorator[]を少しずつ進めています。nextに入っているのは、配列の次の要素ということで、実際パターンの実装としてはそれだけです。</p>
<p>また、NetworkClient自体がIAsyncDecoratorとなっていて、つまりnextを使わないものが最奥部の、最後の処理となるわけです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async UniTask&lt;ResponseContext&gt; IAsyncDecorator.SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; _)
{
    // nextは使わず、ここで実際の通信処理を始める
}
</code></pre>
<p>今回はasync decoratorの紹介なので本体の処理は雑なんですが（とりあえずJsonシリアライズ/デシリアライズしたものを受け渡しするだけ、的な）、まぁ概ね雰囲気はわかると思うのでそれでいいでしょう。通常Pathとリクエスト/レスポンス型は1:1のはずなので（そうなってなければサーバー実装者を〆て1:1にさせましょう)、その辺のメソッドを自動生成しておくとかはよくあります。また、戻り値を複数めいたこと（ポリモーフィズム的な）のしたいんだよなあ、という場合にはMessagePack for C#のUnionという機能が使えるので、活用するといい感じになります。</p>
<p>面白要素としてはTimeoutの処理を CancellationTokenSource.CancelAfterSlim で行っているところでしょうか。TimeoutはWhenAnyを使って外側から処理するパターンもありますが、対象がCancellationTokenを受け取れる場合は、こっちのほうがより効率的で良いです。</p>
<h2>タイトル画面に戻すなどダイアログとシーン遷移を組み合わせる</h2>
<p>ネットワークリクエストに失敗した時って、なんかポップアップ出して 「エラーが発生しました タイトルに戻ります 「OK」」 みたいな画面が出てきますよね？それをやりましょうやりましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public enum DialogResult
{
    Ok,
    Cancel
}

public static class MessageDialog
{
    public static async UniTask&lt;DialogResult&gt; ShowAsync(string message)
    {
        // (例えば)Prefabで作っておいたダイアログを生成する
        var view = await Resources.LoadAsync(&quot;Prefabs/Dialog&quot;);

        // Ok, Cancelボタンのどちらかが押されるのを待機
        return await (view as GameObject).GetComponent&lt;MessageDialogView&gt;().ClickResult;
    }
}

public class MessageDialogView : MonoBehaviour
{
    [SerializeField] Button okButton = default;
    [SerializeField] Button closeButton = default;

    UniTaskCompletionSource&lt;DialogResult&gt; taskCompletion;

    // これでどちらかが押されるまで無限に待つを表現
    public UniTask&lt;DialogResult&gt; ClickResult =&gt; taskCompletion.Task;

    private void Start()
    {
        taskCompletion = new UniTaskCompletionSource&lt;DialogResult&gt;();

        okButton.onClick.AddListener(() =&gt;
        {
            taskCompletion.TrySetResult(DialogResult.Ok);
        });

        closeButton.onClick.AddListener(() =&gt;
        {
            taskCompletion.TrySetResult(DialogResult.Cancel);
        });
    }

    // もしボタンが押されずに消滅した場合にネンノタメ。
    private void OnDestroy()
    {
        taskCompletion.TrySetResult(DialogResult.Cancel);
    }
}
</code></pre>
<p>UniTaskCompletionSourceを活用して、ボタンが押されるまで待機というのを表現できます。こういう使い方、めっちゃするので覚えましょう。UniTaskCompletionSourceめっちゃ大事。</p>
<p>では、これとasync decoratorを組み合わせていきます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ReturnToTitleDecorator : IAsyncDecorator
{
    public async UniTask&lt;ResponseContext&gt; SendAsync(RequestContext context, CancellationToken cancellationToken, Func&lt;RequestContext, CancellationToken, UniTask&lt;ResponseContext&gt;&gt; next)
    {
        try
        {
            return await next(context, cancellationToken);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                // キャンセルはきっと想定されている処理なのでそのまんまスルー（呼び出し側でOperationCanceledExceptionとして飛んでいく)
                throw;
            }

            if (ex is UnityWebRequestException uwe)
            {
                // ステータスコードを使って、タイトルに戻す例外です、とかリトライさせる例外です、とかハンドリングさせると便利
                // if (uwe.ResponseCode) { }...
            }

            // サーバー例外のMessageを直接出すなんて乱暴なことはデバッグ時だけですよ勿論。
            var result = await MessageDialog.ShowAsync(ex.Message);

            // OK か Cancelかで分岐するなら。今回はボタン一個、OKのみの想定なので無視
            // if (result == DialogResult.Ok) { }...

            // シーン呼び出しはawaitしないこと！awaitして正常終了しちゃうと、この通信の呼び出し元に処理が戻って続行してしまいます
            // のでForget。
            SceneManager.LoadSceneAsync(&quot;TitleScene&quot;).ToUniTask().Forget();


            // そしてOperationCanceledExceptionを投げて、この通信の呼び出し元の処理はキャンセル扱いにして終了させる
            throw new OperationCanceledException();
        }
    }
}
</code></pre>
<p>await使ってサクサク書いていけるので、道具が揃っていれば非同期処理とは思えないほど難なく書けます。</p>
<p>一つ注意なのは、呼び出し元に処理を戻すか戻さないか。普通にreturnすると処理が戻っていってしまいますが、Exceptionを再スローすればそれはそれでエラーとして出てしまってウザい。タイトル画面に戻すということは、その通信処理はキャンセルされたということなので、ここは処理がキャンセルされたとマークするのが正解です。asyncメソッドでキャンセル扱いするにはOperationCanceledExceptionを投げる必要があります。これは初見だと？？？という感じになると思いますが、そういうものなのでそういうものとして受け入れませう。</p>
<h2>まとめ</h2>
<p>UniTaskで道具を揃えたんだから、別に普通にばんばん書けるでしょ、便利に使ってね！ぐらいの気持ちでいたのであんまり応用例みたいなのの発信をしてこなかったんですが、よくよく考えると別にそんなことないよね……。ということにやっと気づいたので、色々盛りだくさんで紹介してみましたがどうでしょう。</p>
<p>最初はコールバックに毛が生えたもの程度でもいいとは思いますが、それだけじゃあ勿体ないわけです。せっかく言語機能として用意されているので、コールバックでは実現不可能なもう一段階上の設計が狙えるので、コールバックのことは忘れて使いこなしていって欲しいですね。</p>
<p>キャンセル処理に癖があるのは事実ですが（実際、最後に書いた明示的にOperationCanceledExceptionを投げよう、とかは一から発想していくのは難しいかもしれません）、「引数の最後に渡す」「明示的に投げてもいい」の二点だけなので、これは慣れるしかないし、それを理由にして利用範囲を限定的にするのはよくないかなー、と思ってます。</p>
<p>まぁ、ようするに普通に使ってね！便利ですよ実際！ということで。</p>
</div>
<h1 data-pagefind-sort="date:2020-07-09" data-pagefind-meta="published:2020-07-09"><a href="https://neue.cc/2020/07/09_593.html">ライブラリ作成のすゝめ - 40以上のOSS作成事例から見る個人OSSによる効能とキャリアの開発</a></h1>
<ul class="date"><li>2020-07-09</li></ul>
<div class="entry_body"><iframe src="//www.slideshare.net/slideshow/embed_code/key/4eUpWKiOa9rO8W" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/oss-236734450" title="ライブラリ作成のすゝめ - 事例から見る個人OSS開発の効能" target="_blank">ライブラリ作成のすゝめ - 事例から見る個人OSS開発の効能</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>去年に専門学校の学生さん向けに講演した資料で、それ以外には未発表のスライドです。デベロッパーのキャリアとしてのエモい話になっているのでデブサミ向けにいいかな、と思って公募したところ落ちた！（←微妙にショックだった）のでずっとお蔵入りで眠っていたのですが、このご時世ですし他で講演できるところもなさそうなので、ここで放出することにしました。</p>
<p>作ることが能力の向上に繋がり、キャリアにも繋がっていく。別にそれだけが唯一解ではないけれど、一つの道筋として力になれたらな、と思っています。</p>
<p>大量に作るというのは、いや、大量ではなくても、メンテナンスが回るわけじゃないから大変だったり、時に無責任に見えてしまう（そういうわけではないけれど大変なのです！ごめんなさい！）とか、Issueに埋もれてシンドイとか、そういう負の側面も色々あるのですけれど、それでもね、やっていくのはいいことだと思います。そしてやるからには、一つ一つには真剣に取り組むことが、大きなリターンを得るための秘訣かな、と。</p>
</div>
<h1 data-pagefind-sort="date:2020-07-02" data-pagefind-meta="published:2020-07-02"><a href="https://neue.cc/2020/07/02_592.html">Microsoft MVP for Developer Technologies(C#)を再々々々々々々々々受賞しました</a></h1>
<ul class="date"><li>2020-07-02</li></ul>
<div class="entry_body"><p>しました。多分10回目。Developer Technologiesというのが分かりづらくて嫌なのですが、C#です。一年ごとに再審査があって7月に一斉更新されるのですが、今年も継続です。</p>
<p>最近ちっともブログ書いてない気がしますが、<a href="https://tech.cygames.co.jp/">Cygames Engineer's Blog</a>に割とよく書いているので、なんだかんだでつまり結構書いています。<a href="https://cysharp.co.jp/">Cysharp</a>のほうでも、<a href="https://github.com/Cysharp">GitHub/Cysharp</a>での公開OSS数は15。総☆数も5000近くあるので、まだ設立2年に満たない会社ではありますが、結構存在感を示せていると思っています。もちろん全部C#。めっちゃC#に貢献してるやん。すごいえらい。</p>
<p>直近では<a href="https://tech.cygames.co.jp/archives/3417/">UniTask v2</a>が大きな成果で、同時にC#はまだまだ突き詰められるなというのを実感しました。2年前の自分だとここまで書けなかったので、極めたなんてことはなく、まだまだ日々成長しています。Zシリーズ(<a href="https://github.com/Cysharp/ZString">ZString</a>, <a href="https://github.com/Cysharp/ZLogger">ZLogger</a>)も面白いですね。<a href="https://github.com/Cysharp/ConsoleAppFramework">ConsoleAppFramework</a>もばんばん使ってます。</p>
<p>Unity と .NET Coreが主軸というのは変わらず、そして両者を繋ぐ活動ができるのは世界に私だけ（能力的に、ではなくてアクティブに使命持ってやっている人が、ということですよネンノタメ）だと思っていて、OSSによる、C#の価値を広げていく、活用の幅を広げていくというのは引き続きやっていきたいことなのですが、もう一つ、会社としてもアクションを起こしていきたいと考えています。日本で、世界で大きなインパクトを出すためにも、まだまだ足りないことがいっぱいですから。</p>
<p>というわけかで引き続きC#の最前線で戦っていきますので、今年もよろしくおねがいします。</p>
</div>
<h1 data-pagefind-sort="date:2020-04-22" data-pagefind-meta="published:2020-04-22"><a href="https://neue.cc/2020/04/22_591.html">GitHub ActionsでUnityでunitypackage生成とビルド＆実機(Linux)ユニットテストを実行する</a></h1>
<ul class="date"><li>2020-04-22</li></ul>
<div class="entry_body"><p>以前に<a href="http://neue.cc/2019/04/08_574.html">CircleCIでUnityをテスト/ビルドする、或いは.unitypackageを作るまで</a>、それと<a href="http://neue.cc/2019/05/06_576.html">CIや実機でUnityのユニットテストを実行してSlackに通知するなどする</a>という記事を書いたのですが、時代はGitHub Actionsということで、私も全体的にCircleCIからGitHub Actionsに移行を始めてまして、それに伴ってビルドスクリプトも最新化したので、紹介します。コンフィグ作成にあたっては<a href="https://qiita.com/pCYSl5EDgo/items/690dd56ffb0fcf64e70b">【Unity】GitHub Actions v2でUnity Test Runnerを走らせて、結果をSlackに報告する【入門】</a>と<a href="https://qiita.com/pCYSl5EDgo/items/7496f39eb1ab49a594bc">UnityをGitHub Actionsで動かす際にライセンス認証周りで注意するべき点</a>も参考にしました。</p>
<p>実際のコンフィグは <a href="https://github.com/Cysharp/ZLogger/tree/master/.github/workflows">ZLogger/.github/workflows</a> にありますが、Unityの部分だけ取り出して実行可能な形式にすると</p>
<pre data-pagefind-ignore="all"><code class="language-yaml">name: Build-Debug

on:
  push:
    branches:
      - &quot;**&quot;
    tags:
      - &quot;!*&quot; # not a tag push
  pull_request:
    types:
      - opened
      - synchronize

jobs:
  build-unity:
    strategy:
      matrix:
        unity: ['2019.3.9f1', '2020.1.0b5']
        include:
          - unity: 2019.3.9f1
            license: UNITY_2019_3
          - unity: 2020.1.0b5
            license: UNITY_2020_1
    runs-on: ubuntu-latest
    container:
      # with linux-il2cpp. image from https://hub.docker.com/r/gableroux/unity3d/tags
      image: gableroux/unity3d:${{ matrix.unity }}-linux-il2cpp
    steps:
      - run: apt update &amp;&amp; apt install git -y
      - uses: actions/checkout@v2
      # create unity activation file and store to artifacts.
      - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -logFile -createManualActivationFile || exit 0
      - uses: actions/upload-artifact@v1
        with:
          name: Unity_v${{ matrix.unity }}.alf
          path: ./Unity_v${{ matrix.unity }}.alf
      # activate Unity from manual license file(ulf)
      - run: echo -n &quot;$UNITY_LICENSE&quot; &gt;&gt; .Unity.ulf
        env:
          UNITY_LICENSE: ${{ secrets[matrix.license] }}
      - name: Activate Unity, always returns a success. But if a subsequent run fails, the activation may have failed(if succeeded, shows `Next license update check is after` and not shows other message(like GUID != GUID). If fails not). In that case, upload the artifact's .alf file to https://license.unity3d.com/manual to get the .ulf file and set it to secrets.
        run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .Unity.ulf || exit 0

      # Execute scripts: RuntimeUnitTestToolkit
      - name: Build UnitTest(Linux64, mono)
        run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend mono /BuildTarget StandaloneLinux64
        working-directory: src/ZLogger.Unity
      - name: Execute UnitTest
        run: ./src/ZLogger.Unity/bin/UnitTest/StandaloneLinux64_Mono2x/test

      # Execute scripts: Export Package
      - name: Export unitypackage
        run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
        working-directory: src/ZLogger.Unity

      # Store artifacts.      
      - uses: actions/upload-artifact@v1
        with:
          name: ZLogger.Unity.unitypackage
          path: ./src/ZLogger.Unity/ZLogger.Unity.unitypackage
</code></pre>
<p>となっています。微妙に長いね！（ショボいシンタックスハイライターの影響でインデントが腐ってて読みづらいので<a href="https://github.com/Cysharp/ZLogger/blob/c6c0436/.github/workflows/build-debug.yml">workflows/build-debug.yml</a>を見ていただいたほうがいいです）</p>
<p>さて、とりあえずUnityにおいての第一関門は認証を通すことなのですが、ここは -createManualActivationFile して -manualLicenFile に投げる、というやり方を採用します（他にも幾つかやり方はある）。Unityのインストール等に関しては、インストール済みのコンテナイメージを使って、コンテナでビルドします。使用できるイメージ一覧は <a href="https://hub.docker.com/r/gableroux/unity3d/tags">DockerHub - gableroux/unity3d/tags</a>から選べますが、ここではIL2CPPビルドが実行できると謳ってる、かつ最新の2019.3.9f1-linux-il2cppと2020.1.0b5-linux-il2cppを使うことにしました。マトリックスビルドかけるなら、もっと古いのあたりも入れたほうがいいといえばいいんですが、LinuxでIL2CPPビルド可能なのは2019.3からなのでshoganai。</p>
<p>matrix組むのは、特にアセット作っている人にとっては重要で、というのも新しいUnityサポートしたら古いUnityで使えないAPIを使っちゃってビルドエラーとか、たまによくやるんですよね、うっかり。if-def囲み忘れとか、逆に囲みすぎとか。というわけで、可能なら最低サポートバージョンから、マイナーバージョン毎ぐらいに組むのがいいと思います。そういう意味では、私は今のところ2018.3を最低サポートバージョンにしているので、2018.3, 2018.4もmatrixに組んだほうがいいのですがIL2CPPビルドのために以下略。</p>
<p>さて、認証ですが、この辺で処理しています。</p>
<pre data-pagefind-ignore="all"><code class="language-yaml"># create unity activation file and store to artifacts.
- run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -logFile -createManualActivationFile || exit 0
- uses: actions/upload-artifact@v1
    with:
      name: Unity_v${{ matrix.unity }}.alf
      path: ./Unity_v${{ matrix.unity }}.alf
# activate Unity from manual license file(ulf)
- run: echo -n &quot;$UNITY_LICENSE&quot; &gt;&gt; .Unity.ulf
    env:
      UNITY_LICENSE: ${{ secrets[matrix.license] }}
- name: Activate Unity, always returns a success. But if a subsequent run fails, the activation may have failed(if succeeded, shows `Next license update check is after` and not shows other message(like GUID != GUID). If fails not). In that case, upload the artifact's .alf file to https://license.unity3d.com/manual to get the .ulf file and set it to secrets.
  run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .Unity.ulf || exit 0
</code></pre>
<p>基本的に認証の流れは .alf を作る -&gt; .alf を <a href="https://license.unity3d.com/manual">https://license.unity3d.com/manual</a> にアップロードして .ulf ファイルをダウンロード。そのulfファイル（中身はXMLテキスト）をGitHub ActionsのSettings -&gt; Secretsに設定する、ということなのですが、.alfを手元で作るのは面倒なのでCIに作ってもらって、artifactsにあげてます。</p>
<p>初回実行時は.ulfがないので絶対に後続の実行は失敗します(Activate処理だけはエラーにならないので、その先で認証できなかったといってコケます）。ので、ActionsのArtifactsのところからalfをダウンロードして、.ulfを作ります。それをテキストエディタで開いてSecretsのところに適切な名前で保存すればOK。名前との関連付けは</p>
<pre data-pagefind-ignore="all"><code class="language-yaml">matrix:
unity: ['2019.3.9f1', '2020.1.0b5']
include:
    - unity: 2019.3.9f1
      license: UNITY_2019_3
    - unity: 2020.1.0b5
      license: UNITY_2020_1
</code></pre>
<p>で設定してますが、ここでは2019.3.9f1用はUNITY_2019_3, 2020.1.0b5用はUNITY_2020_1にしました。2019_3といいつつ、コンテナイメージ毎に新しい認証ファイルがいるので、2019.3.10f1に変えたらSecretは設定しなおしです。面倒くさい。shoganai。</p>
<p>ユニットテストの実行は<a href="https://github.com/Cysharp/RuntimeUnitTestToolkit/">Cysharp/RuntimeUnitTestToolkit</a>を使用します。これはUnity Test Runnerで書いたユニットテストからCUI/GUIでの実行シーンをビルド時に動的に生成するもので、まぁまぁ便利です。特にCUIでのテスト実行はCI用ですね、結果をそのまま出力で見れたり、エラーがあったらそのままエラーにしてくれたりするので非常に楽。それ以外に私はエディタからWindowsでのIL2CPPビルド実行を多用しています（よくIL2CPPで引っかかるライブラリを作っているので）</p>
<p>設定は <code>-executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend mono /BuildTarget StandaloneLinux64</code> といったものを書けばOK。そうすると <code>bin/UnitTest/StandaloneLinux64_Mono2x/test</code> に成果物ができてるので、すぐに実行すれば、CIでのテスト実行ということになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp"># Execute scripts: RuntimeUnitTestToolkit
- name: Build UnitTest(Linux64, mono)
    run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend mono /BuildTarget StandaloneLinux64
    working-directory: src/ZLogger.Unity
- name: Execute UnitTest
    run: ./src/ZLogger.Unity/bin/UnitTest/StandaloneLinux64_Mono2x/test
</code></pre>
<p>ここで <code>/ScriptBackend mono</code> を <code>/ScriptBackend IL2CPP</code> にするとIL2CPPビルドになるので、やったーCIでIL2CPPのテストができるぞー！と思ったんですが、現在のコンテナイメージだとなんか謎エラーでビルドに失敗するので、一旦は諦めました。誰か成功させてください。何かとIL2CPPで引っかかるライブラリを作ってるので、できればここでテストしたいんですけどねえ。</p>
<p>最後に.unitypackageの作成ですが、これはリポジトリに仕込んである生成メソッドをキックして、artifactsにアップロードします。</p>
<pre data-pagefind-ignore="all"><code class="language-yaml"># Execute scripts: Export Package
- name: Export unitypackage
    run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
    working-directory: src/ZLogger.Unity

# Store artifacts.      
- uses: actions/upload-artifact@v1
    with:
    name: ZLogger.Unity.unitypackage
    path: ./src/ZLogger.Unity/ZLogger.Unity.unitypackage
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

public static class PackageExporter
{
    [MenuItem(&quot;Tools/Export Unitypackage&quot;)]
    public static void Export()
    {
        var version = Environment.GetEnvironmentVariable(&quot;UNITY_PACKAGE_VERSION&quot;);

        // configure
        var root = &quot;Scripts/ZLogger&quot;;
        var fileName = string.IsNullOrEmpty(version) ? &quot;ZLogger.Unity.unitypackage&quot; : $&quot;ZLogger.Unity.{version}.unitypackage&quot;;
        var exportPath = &quot;./&quot; + fileName;

        var path = Path.Combine(Application.dataPath, root);
        var assets = Directory.EnumerateFiles(path, &quot;*&quot;, SearchOption.AllDirectories)
            .Where(x =&gt; Path.GetExtension(x) == &quot;.cs&quot; || Path.GetExtension(x) == &quot;.meta&quot; || Path.GetExtension(x) == &quot;.asmdef&quot;)
            .Where(x =&gt; Path.GetFileNameWithoutExtension(x) != &quot;_InternalVisibleTo&quot;)
            .Select(x =&gt; &quot;Assets&quot; + x.Replace(Application.dataPath, &quot;&quot;).Replace(@&quot;\&quot;, &quot;/&quot;))
            .ToArray();

        UnityEngine.Debug.Log(&quot;Export below files&quot; + Environment.NewLine + string.Join(Environment.NewLine, assets));

        var dir = new FileInfo(exportPath).Directory;
        if (!dir.Exists) dir.Create();
        AssetDatabase.ExportPackage(
            assets,
            exportPath,
            ExportPackageOptions.Default);

        UnityEngine.Debug.Log(&quot;Export complete: &quot; + Path.GetFullPath(exportPath));
    }
}
</code></pre>
<p>と、まぁこれでいい感じに？テストとパッケージ生成ができるようになりました！</p>
<p>なお、リリースビルドは別ワークフローのymlになっているので、マトリックスビルドとalfの処理とテストを省いてます（本当はマトリックスもテストもしたほうがよくて、全部通ったらartifact生成とかにしたほうがいいんですが、まぁ多少ザルでもいいでしょう）。</p>
<pre data-pagefind-ignore="all"><code class="language-yaml">  build-unity:
    strategy:
      matrix:
        unity: ['2019.3.9f1']
        include:
          - unity: 2019.3.9f1
            license: UNITY_2019_3
    runs-on: ubuntu-latest
    container:
      # with linux-il2cpp. image from https://hub.docker.com/r/gableroux/unity3d/tags
      image: gableroux/unity3d:${{ matrix.unity }}-linux-il2cpp
    steps:
    - run: apt update &amp;&amp; apt install git -y
    - uses: actions/checkout@v2
    - run: echo -n &quot;$UNITY_LICENSE&quot; &gt;&gt; .Unity.ulf
      env:
        UNITY_LICENSE: ${{ secrets[matrix.license] }}
    - run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -manualLicenseFile .Unity.ulf || exit 0

    # Execute scripts: Export Package
    - name: Export unitypackage
      run: /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
      working-directory: src/ZLogger.Unity

    # Store artifacts.
    - uses: actions/upload-artifact@v1
      with:
        name: ZLogger.Unity.unitypackage
        path: ./src/ZLogger.Unity/ZLogger.Unity.unitypackage
</code></pre>
<h2>まとめ</h2>
<p>GitHub Actions、最初は抵抗感あったんですが、というかCIの設定というのが、かなり嫌いな種類のエンジニアリングなので、一度覚えてコピペで済ませてるCircleCIから引っ越すのに腰が重かったんですが、まぁやってみればなんとかなる（社内でわちゃくちゃと手伝ってもらったお陰でもありますが）し、やってみれば、割といいんじゃないのかな、と思えるようになりました。CircleCIもいいんですが、最近のUI変更などがイケてない感じだったりで好感度下がっていたので、ぎっはぶActions、いいんじゃないでしょーか。</p>
<p>とりあえずDOOM Eternalが超絶面白いのでやっておくといいです。<a href="https://www.youtube.com/watch?v=cd47x85C7Hk">YouTube - Doom Eternal - Cultist Base Master Level</a>がDoom Eternalの圧倒的なスピード感と暴力を表現しててとてもいいので、ぜひ見て買ってくださいな。今年のGame of the Yearなので。久しぶりにゲーム超面白い……！と思った。ただたんに（クラシックなFPS的に）スピード速くするだけじゃこうならないんですよねえ（実際、前作のDOOM(2016)をEternal後にやると、あまり面白く感じない）、近年ではバトルロイヤルも発明でしたが、DOOM EternalもFPSを、ゲームを進化させるゲームデザインの発明ですね、とにかく良い。めっちゃ良い。</p>
</div>
<h1 data-pagefind-sort="date:2020-01-30" data-pagefind-meta="published:2020-01-30"><a href="https://neue.cc/2020/01/30_590.html">ProcessX - C#でProcessを C# 8.0非同期ストリームで簡単に扱うライブラリ</a></h1>
<ul class="date"><li>2020-01-30</li></ul>
<div class="entry_body"><p>C#使う人って全然外部プロセス呼び出して処理ってしないよね。というのは、Windowsがなんかそういうのを避ける雰囲気だから、というのもあるのですが、ともあれ実際、可能な限り避けるどころか絶対避ける、ぐらいの勢いがあります。ライブラリになってないと嫌だ、断固拒否、みたいな。しかし最近はLinuxでもばっちし動くのでそういう傾向もどうかなー、と思いつつ。</p>
<p>避けるというのはOSの違いというのもありそうですが、もう一つはそもそも外部プロセスの呼び出しが死ぬほど面倒くさい。ProcessとProcessStartInfoを使ってどうこうするのですが、異常に面倒くさい。理想的にはシェルで書くように一行でコマンドと引数繋げたstringを投げておしまい、と行きたいのですが、全然そうなってない。呼び出すだけでも面倒くさいうぇに、StdOutのリダイレクトとかをやると更に面倒くさい。非同期でStdOutを読み込むとかすると絶望的に面倒くさい、うえに罠だらけでヤバい。この辺の辛さは<a href="https://qiita.com/skitoy4321/items/10c47eea93e5c6145d48">非同期外部プロセス起動で標準出力を受け取る際の注意点</a>という記事でしっかり紹介されてますが、実際これを正しくハンドリングするのは難儀です。</p>
<p>そこで「シェルを書くように文字列一行投げるだけで結果を」「C# 8.0の非同期ストリームで、こちらも一行await foreachするだけで受け取れて」「ExitCodeやStdErrorなども適切にハンドリングする」ライブラリを作りました。</p>
<ul>
<li><a href="https://github.com/Cysharp/ProcessX">GitHub - Cysharp/ProcessX</a></li>
</ul>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Cysharp.Diagnostics; // using namespace

// async iterate.
await foreach (string item in ProcessX.StartAsync(&quot;dotnet --info&quot;))
{
    Console.WriteLine(item);
}
</code></pre>
<p>というように、 <code>await foreach(... in ProcessX.StartAsync(command))</code> だけで済みます。普通にProcessで書くと30行ぐらいかかってしまう処理がたった一行で！革命的便利さ！C# 8.0万歳！</p>
<p>実際これ、普通のProcessで書くと中々のコード量になります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var pi = new ProcessStartInfo
{
    // FileNameとArgumentsが別れる（地味にダルい）
    FileName = &quot;dotnet&quot;,
    Arguments = &quot;--info&quot;,
    // からの怒涛のboolフラグ
    UseShellExecute = false,
    CreateNoWindow = true,
    ErrorDialog = false,
    RedirectStandardError = true,
    RedirectStandardOutput = true,
};

using (var process = new Process()
{
    StartInfo = pi,
    // からのここにもboolフラグ
    EnableRaisingEvents = true
})
{
    process.OutputDataReceived += (sender, e) =&gt;
    {
        // nullが終端なのでnullは来ます！のハンドリングは必須
        if (e.Data != null)
        {
            Console.WriteLine(e.Data);
        }
    };

    process.Exited += (sender, e) =&gt;
    {
        // ExitCode使ってなにかやるなら
        // ちなみにExitedが呼ばれてもまだOutputDataReceivedが消化中の場合が多い
        // そのため、Exitと一緒にハンドリングするなら適切な待受コードがここに必要になる
    };

    process.Start();

    // 何故かStart後に明示的にこれを呼ぶ必要がある
    process.BeginOutputReadLine();

    // processがDisposeした後にProcess関連のものを触ると死
    // そして↑のようにイベント購読しているので気をつけると触ってしまうので気をつけよう
    // ↓でもWaitForExitしちゃったら結局は同期じゃん、ということで真の非同期にするには更にここから工夫が必要
    process.WaitForExit();
}
</code></pre>
<p>↑のものでも少し簡略化しているぐらいなので、それぞれより正確にハンドリングしようとすると相当、厳しい、です……。</p>
<p>さて、await foreachの良いところは例外処理にtry-catchがそのまま使えること、というわけで、ExitCodeが0以外（或いはStdErrorを受信した場合)には、ProcessErrorExceptionが飛んでくるという仕様になっています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">try
{
    await foreach (var item in ProcessX.StartAsync(&quot;dotnet --foo --bar&quot;)) { }
}
catch (ProcessErrorException ex)
{
    // int .ExitCode
    // string[] .ErrorOutput
    Console.WriteLine(ex.ToString());
}
</code></pre>
<p>WaitForExit的に、同期待ちして結果を全部取りたいという場合は、ToTaskが使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// receive buffered result(similar as WaitForExit).
string[] result = await ProcessX.StartAsync(&quot;dotnet --info&quot;).ToTask();
</code></pre>
<p>キャンセルに関しては非同期ストリームのWithCancellationがそのまま使えます。キャンセル時にプロセスが残っている場合はキャンセルと共にKillして確実に殺します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">await foreach (var item in ProcessX.StartAsync(&quot;dotnet --info&quot;).WithCancellation(cancellationToken))
{
    Console.WriteLine(item);
}
</code></pre>
<p>タイムアウトは、CancellationTokenSource自体が時間と共に発火というオプションがあるので、それを使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1)))
{
    await foreach (var item in ProcessX.StartAsync(&quot;dotnet --info&quot;).WithCancellation(cts.Token))
    {
        Console.WriteLine(item);
    }
}
</code></pre>
<p>また、ProcessX.StartAsyncのオーバーロードとして、作業ディレクトリや環境変数、エンコードを設定できるものも用意しているので、ほとんどのことは問題なく実装できるはずです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">StartAsync(string command, string? workingDirectory = null, IDictionary&lt;string, string&gt;? environmentVariable = null, Encoding? encoding = null)
StartAsync(string fileName, string? arguments, string? workingDirectory = null, IDictionary&lt;string, string&gt;? environmentVariable = null, Encoding? encoding = null)
StartAsync(ProcessStartInfo processStartInfo)

Task&lt;string[]&gt; ToTask(CancellationToken cancellationToken = default)
</code></pre>
<h2>System.Threading.Channels</h2>
<p>今回、ProcessのイベントとAsyncEnumeratorとのデータの橋渡しにはSystem.Threading.Channelsを使っています。詳しくは<a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">An Introduction to System.Threading.Channels</a>、或いは日本語だと<a href="https://qiita.com/skitoy4321/items/c19ca3dc7624a7049fd5">System.Threading.Channelsを使う</a>を読むと良いでしょう。</p>
<p>プロデューサー・コンシューマーパターンのためのライブラリなのですが、めっちゃ便利です。シンプルなインターフェイス（ちょっと弄ってれば使い方を理解できる）かつasync/awaitビリティがめっちゃ高い設計になっていて、今まで書きづらかったものがサクッと書けるようになりました。</p>
<p>これはめちゃくちゃ良いライブラリなのでみんな使いましょう。同作者による System.Threading.Tasks.DataFlow（TPL Dataflow) は全く好きじゃなくて全然使うことはなかったのですが、Channelsは良い。めっちゃ使う。</p>
<h2>まとめ</h2>
<p>Process自体は、C# 1.0世代(10年前！)に設計されたライブラリなのでしょうがないという側面もありつつも、やはり現代は現代なので、ちゃんと現代流に設計したものを再度提供してあげる価値はあるでしょう。設計技法も言語自体も、遥かに進化しているので、ちゃんとしたアップデートは必要です。</p>
<p>こうした隙間産業だけど、C#に今までなくて面倒で、でもそれが一気に解消して超絶便利に、というのは<a href="https://github.com/Cysharp/ConsoleAppFramework/">ConsoleAppFramework</a>に通じるものがあります。C#の面倒と思えるところを片っ端から潰して超絶便利言語にしていく、ことを目指して引き続きどしどし開発していきます。というわけで是非使ってみてください。</p>
</div>
<h1 data-pagefind-sort="date:2020-01-28" data-pagefind-meta="published:2020-01-28"><a href="https://neue.cc/2020/01/28_589.html">Unityによるリアルタイム通信とMagicOnionによるC#大統一理論の実現 - フォローアップ</a></h1>
<ul class="date"><li>2020-01-28</li></ul>
<div class="entry_body"><p>先週の土曜日に<a href="https://kyoto-gamedevel.doorkeeper.jp/events/100492">Unity道場 京都スペシャル4</a>というイベントで登壇してきました。関西にはめったに行かないので、良い機会を頂いて感謝です。参加者応募も231名、場所もかなり大きなホールでいい感じでした。また、主催された<a href="http://cloud-creative-studios.com/">クラウドクリエイティブスタジオ</a>さんはサーバー開発もC#でしてる企業さんでもありますね……！すばらすばら。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/3ZjDetvdWRnmMQ" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/UnityTechnologiesJapan002/unity4unitymagiconionc" title="【Unity道場京都スペシャル4】Unityによるリアルタイム通信とMagicOnionによるC#大統一理論の実現" target="_blank">【Unity道場京都スペシャル4】Unityによるリアルタイム通信とMagicOnionによるC#大統一理論の実現</a> </strong> from <strong><a href="https://www.slideshare.net/UnityTechnologiesJapan002" target="_blank">UnityTechnologiesJapan002</a></strong> </div>
<p>動画も<a href="https://learning.unity3d.jp/4267/">Unity Learning Material(YouTube)</a>に公開されています。</p>
<p>Unity……？まぁ、Unity、です、ええ。どちらかというと、MagicOnionが何を目指しているのか、みたいなところを説明できたんじゃないかなー、と思ってます。色々、思っているところを入れました。</p>
<p>このスライドを踏まえて、更に今後考えていること、というか「ハードコアを緩和する」というのが当分のテーマなのですが、なにやるか、というと……RPC以外の便利コンポーネントを作る、という意味ではありません。</p>
<p>あまり便利コンポーネントには関心がなくて、というのもどうせ無駄ばっかでパフォーマンスでないから使わん、とかになるんで、それだといらないなー、と。何のかんので私は割と理想主義者なので、良いものを作るための道具を提供したい、という思いがあります。性能の追求とかもその一環ですよね。というわけで、そこに反するものはちょっとねー、と。そこはアプリケーション実装側の責務だと思うので、自分で作り込んで欲しい……！</p>
<p>導入のヘヴィさやインフラ側は緩和していきたいです。特に、現在ネックになっているのがネイティブgRPCなので、それを引っ剥がしたいと思ってます。これを引っ剥がすと、つまり私の方で提供するPure C#なHTTP/2, gRPC実装に置き換えることでクライアント側は完全にプラットフォームフリー！サイズも低減！依存も消滅！そして完全なチューニングが可能になる！サーバー側はMicrosoft実装の ASP.NET Coreによるgrpc-dotnetベースに置き換えます。そうすると、実は通信層が自由に置き換えられるようになるので、TCPだけじゃなくてQUIC（これは実際、MicrosoftがExperimentalな実装をやってる最中なのでそれをすぐ投下できる）や、RUDPとかを入れ込むこともできます。</p>
<p>インフラ周りは、特にKuberenetes + Dedicated Server的に使うと、プラクティスがなさすぎて死にます。これは<a href="https://agones.dev/site/">Agones</a>というGoogleの開発しているKuberenetes用のミドルウェアで解決すると思ってるんですが、現状だとまだ厳しいんですねー。というわけで<a href="https://github.com/googleforgames/agones/issues/1197">AgonesにIssue</a>立てたりもしてるんですが、さてはて。というわけでまだもう少し大変です。</p>
<p>それとアーキテクチャ的に、まずはRPCになってるのですが、これをサーバーループによる駆動に変換するためのブリッジ層を作り込みたいかなあ、と。現状でも自作すればできる状態なんですが、このぐらいは標準で用意してあげたほうがすわりがよさそうだ、と。</p>
<p>理想的な状態までの絵図は描けていますし、かなりいいところまでは来てると思ってます。ので、あともう一歩強化できれば、というところなのでやっていきます、はい。</p>
</div>
<h1 data-pagefind-sort="date:2020-01-09" data-pagefind-meta="published:2020-01-09"><a href="https://neue.cc/2020/01/09_588.html">ConsoleAppFramework - .NET Coreコンソールアプリ作成のためのマイクロフレームワーク（旧MicroBatchFramework)</a></h1>
<ul class="date"><li>2020-01-09</li></ul>
<div class="entry_body"><p>以前に<a href="https://tech.cygames.co.jp/archives/3241/">MicroBatchFramework - クラウドネイティブ時代のC#バッチフレームワーク</a>という名前でリリースしていたライブラリですが、リブランディング、ということかでConsoleAppFrameworkに変更しました。それに伴い名前変更による多数の破壊的変更と、全体の挙動の調整を行っています。</p>
<ul>
<li><a href="https://github.com/Cysharp/ConsoleAppFramework">github/ConsoleAppFramework</a></li>
</ul>
<p>当初の想定ではバッチ、特に機能紹介にあるMulti Batchをメイン機能と捉えて作っていたのですが、最終的には汎用的なコンソールアプリケーション用のフレームワークとして出来上がっていたので、より適正な名前にすることで、多くの人に正しく捉えてもらって、届けられるのではないかと思い、今回の変更に至りました。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/72047323-a08e0c80-32fd-11ea-850a-7f926adf3d22.png" width=640 />
</p>
<p>といったように、 Microsoft.Extensions の仕組みに乗ってLogging, Configuration, DIなどをカバーしつつ、CLI用にパラメーターバインディング、メソッドルーティング、ライフサイクル管理を乗っけているのがConsoleAppFrameworkの意義となります。一度使ってもらえば、もう素のConsoleAppを作ることはなくなります、というぐらいには便利なのではないかと……！</p>
<p>同様のコンセプトとしては、PHPでは<a href="https://laravel-zero.com/">Laravel Zero</a>という、Micro-framework for console applicationsがあります。Laravelのロギングやコンフィグレーションを共有しつつも、コマンドラインアプリケーションで使いやすいような処理が施されています。Microsoftによる実装では<a href="https://github.com/dotnet/command-line-api">dotnet/command-line-api</a>の System.CommandLine.Hosting + System.CommandLine.DragonFruit が近い機能を持っていますが、ConsoleAppFrameworkのほうがよりプロダクティビティが高いです。というかMSのはダメです。こういうの作るのにMicrosoftはセンスないんですよねー。</p>
<p>あらためてConsoleAppFrameworkの単純な例ですが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using ConsoleAppFramework;
using Microsoft.Extensions.Hosting;
using System;
using System.Threading.Tasks;

// Entrypoint, create from the .NET Core Console App.
class Program : ConsoleAppBase // inherit ConsoleAppBase
{
    static async Task Main(string[] args)
    {
        // target T as ConsoleAppBase.
        await Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync&lt;Program&gt;(args);
    }

    // allows void/Task return type, parameter is automatically binded from string[] args.
    public void Run(string name, int repeat = 3)
    {
        for (int i = 0; i &lt; repeat; i++)
        {
            Console.WriteLine($&quot;Hello My ConsoleApp from {name}&quot;);
        }
    }
}

&gt; SampleApp.exe -name &quot;foo&quot; -repeat 5.
</code></pre>
<p>といったように、Mainに毛が生えた程度の記述だけで、気の利いたコマンドラインアプリケーションが作れます。今回からヘルプのフォーマットに気合いを入れているので、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Run(
    [Option(&quot;n&quot;, &quot;name of send user.&quot;)]string name, 
    [Option(&quot;r&quot;, &quot;repeat count.&quot;)]int repeat = 3)
{
    // ...
}
</code></pre>
<p>といったようにいい感じのショートカットと説明を属性で追加してあげると、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&gt; SampleApp.exe help
Usage: SampleApp [options...]

Options:
  -n, -name &lt;String&gt;     name of send user. (Required)
  -r, -repeat &lt;Int32&gt;    repeat count. (Default: 3)
</code></pre>
<p>いい感じのhelpが表示されるようになりました。ちなみにこれは dotnet コマンドのフォーマットに近いものです。</p>
<p>.NET Core 3.0からは<a href="https://docs.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-core-3-0">ランタイム不要での単一ファイルのバイナリ作成</a>がやっとできるようになったので、配布もよりやりやすくなりました。また、パッケージマネージャー経由での <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools">.NET Core Global Tools</a>という仕組み(.NET Core 2.1から)や、プロジェクト単位で設定してバージョン固定などがやりやすい<a href="https://andrewlock.net/new-in-net-core-3-local-tools/">.NET Core Local Tools</a>(.NET Core 3.0から)といった仕組みも整備されているので、かなりいけてます。</p>
<p>また、ConsoleAppFrameworkの持つ複数のバッチ(コマンド/メソッド)を単一アプリケーションで管理する実行可能にする機能は、プロジェクト固有のバッチ（大量にあるはず！）やインフラ管理スクリプトなどを一本化して、CIなどではgit pull後に <code>dotnet run command</code> で済ませられたりするなどは、実際私自身も有用に使っています。</p>
<h2>リブランディングについて</h2>
<p>MicroBatchFramework、正直なところもう少しウケてもいいと思ってたんですが、あんま伸びなかったんですよねー。コンセプトは良いはずだし実際機能的にもいいのになんでー？と思ったんですが、ようは&quot;Cloud Native Batch Framework&quot; というのが全然ピンときてないんですよねー。Cloud Nativeとか言っておけば喰い付くだろうとかいう安易なネーミングがダメ。あとBatchってのがやっぱダメだよね。バッチ。バッチって。</p>
<p>というわけで、ずっと気になってたんで、結果、今回の名前変えたのは本質をより表していていいんじゃないかなー、と思いますがどうでしょう？ReadMeも全体的に見直して、ウケる雰囲気になったと思うので、これでもう一発逆転狙いたいです（？）</p>
<p>それと、こういう名前変えるみたいなのも決断の一種なわけですが、名前を変えること自体は誰でもできるし、変えた名前も安易で誰でも決めれるわけですし、実際に変えてみるとピタッとピースがはまったように見える。けれど、じゃあいざ変えましょう、と踏み出すのはとてもむずかしい。というわけで、あ、シャッチョさん仕事したな、みたいな気になりました。まる。</p>
</div>
<h1 data-pagefind-sort="date:2019-12-30" data-pagefind-meta="published:2019-12-30"><a href="https://neue.cc/2019/12/30_587.html">2019年を振り返る</a></h1>
<ul class="date"><li>2019-12-30</li></ul>
<div class="entry_body"><p>今年はどういう年だったかというと、うーん、まともに会社として動き出した年、ですかね。去年<a href="https://cysharp.co.jp/">Cysharp</a>という会社を作りましたが、その時点では一人だったので会社感も全く何もなかったのですが、今年から何人か入ってきたので、やっと会社として体をなしてきました。</p>
<p>ブログの本数があからさまに減ってますが、<a href="https://tech.cygames.co.jp/">Cygames Engineers' Blog</a>に書いている分もあるのでそこはしょーがない。今年は講演も結構した気がします。CEDECやUniteなど大きなイベントでも話してきましたし、特にUniteの<a href="http://neue.cc/2019/09/30_584.html">Understanding C# Struct All Things</a>は好評だったようで、アンケート結果でも実質一位(正しくは4位、1~3位はUnity Technologies Japanの人だったので、それを除いたらという謎基準により）だったので、嬉しみがあります。</p>
<p>ライブラリは、なんか一年中ずっと<a href="http://neue.cc/2019/12/17_586.html">MessagePack for C# v2</a>に関わってた気がするのですが、なんとか駆け込みでリリースできてよかった。それに合わせて<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>や<a href="https://github.com/Cysharp/MasterMemory/">MasterMemory</a>といった内部でMessagePackを使っているライブラリのアップデートも間に合い、今年を気持ちよく終えることができそうです。</p>
<p>Cysharpとしてはパブリックなリポジトリ(<a href="https://github.com/Cysharp">github/Cysharp</a>)が10個。設立から一年ちょいの会社のポートフォリオとしては、かなり立派なんじゃないでしょうか！会社の社是「C#の可能性を切り開いていく」のとおりに、C#にないものを絶妙な感じに埋めまくっています。</p>
<p>私はC#にとてもこだわっているわけですが、実際のところ、言語の選択がアプリケーションの開発の成功に必須かといったら、別にそうではないとも思っているのです、実のところ。ほとんどのことは、別に何の言語だろうと達成できるだろう、とも。（実際、私はCTOとして在籍していた前の会社、グラニの立ち上げタイトルである「神獄のヴァルハラゲート」をPHPでの開発に同意して、暫くPHP書いていたりもしましたしね←ただし成功したらすぐにC#リプレイスプロジェクトを始動して、半年後に完全移行しましたが）。</p>
<p>それでも、人は何かを選択しなきゃあいけないわけで、そのときにC#を選んでほしいし、選ぶ理由を作っていくことを大事にしています。前提としての他の言語にあってC#にはないものをなくしていき、差別化としてC#にしかないものを用意（超ハイパフォーマンスなライブラリであったり、C#大統一理論なんかがそうです）する。そうすれば自然と選択肢に上がってくるし、その結果、選ばれることが増えていく。実績だって数多くできていく。そういった環境を作っていくために、気を吐いているわけです。</p>
<p>それって会社の経営者としてどうなの！？というと、そうした活動が回り回って自分たちにうまくいくようにうまくしている（いく）ので、まぁまぁうまくいってるんじゃないでしょうか。</p>
<p>私はいっぱいOSSを公開しているのですが、そもそもに私はライブラリを作ることをアートだと捉えているんですよね。比喩でなく文字通りの。強く伝えたいメッセージ、表現したい衝動があり、それは時に、哲学的であり、政治的であり、ポジショントークでもある。私にとってはOSSの形で公開することこそが最も強く表現できる手段で、ライブラリは思想の塊であり、言葉だけよりもずっと流暢に語ってくれると考えています。</p>
<p>なので、つまんない量産型アーキテクチャの話とか聞くと、もっと個性が立っていてもいいのに！いったい何がしたいの？（いや、普通に動くアーキテクチャが一番大事ですが）、とか思ったりはよくします。あと、外資系企業とかシアトルやシリコンバレー勤務とかの話もつまんないですね、彼らが誇っているのって結局は場所が違うだけで自分自身はフツーのことをしてるだけじゃない？魂がないよね！それで他人を腐してるのだから実にダサい。（いやまぁそれは言い過ぎで、どんな仕事にも情熱はこもっているものです！だいじょうぶだいじょうぶ！）</p>
<p>とはいえアートじゃ生きていけない！実際OSSでは喰っていけない！中世ならパトロンが必要なところですが、現代においても<a href="https://ja.wikipedia.org/wiki/%E9%A3%9F%E5%AE%A2">食客</a>のような立ち回りが必要です。つまり……。いやまぁ、食客かどうかはともかくとしてともかくとして、私は役に立つべき局面（たまにある、しょっちゅうはない）では驚くべきほど役に立ちます！し、実際、食客じゃないのでちゃんと仕事してますし（してます！）、今仕込んでいるものはきっと来年にはお見せできる（したい）と思うのですが、非常にインパクトのある成果になっていることと思います。Win-Winじゃないですかー。そうありたいね。</p>
<p>というわけで、生きていく間で大事にしたいのは、これからもそうした表現したい衝動を持ち続けられること、です。そのためにも、どこから降ってくるか分からない衝動のために、色々な刺激を受け、脳みそで咀嚼して考えていきたいなあ、と。</p>
<h2>C#</h2>
<p>今年も色々作ったのですが、<a href="https://tech.cygames.co.jp/archives/3241/">MicroBatchFramework</a>が地味に大きかったかなあ。めっちゃくちゃ使ってます。作って良かった。もっと評判になればいいのに、ぐぬぬ……。</p>
<p>技術的には<a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C# v2</a>がめちゃくちゃ大きくて、また一つC#が新しいレベルに到達してしまった……。みたいな感慨があります。v2のお陰で、MagicOnionはどうあるべきなのか、といった道筋がスッと通っていったのが実際感動的です。というわけで、来年はフレームワーク全体を通しての新世代のアーキテクチャの掲示、というのを行えるんじゃないかと思っています。</p>
<p><a href="https://tech.cygames.co.jp/archives/3269/">MasterMemory</a>も良かったのではないかと、SQLiteの4700倍！なのも当たり前で、これがあると取るべきアーキテクチャの幅が広がるはずです。サーバーサイドでもクライアントサイドでも、活用しがいのあるライブラリになっています。</p>
<p>反省点はUnity側の深堀りがほとんど出来なかったことですね。毎年言い続けているECSやる、とか、去年も言っていたECS+物理エンジンでちゃりんちゃりん、みたいなのも今年も何も実装せずに終わった、とか、いやはやー。来年こそECSイヤーにするぞい！</p>
<p>諸事情で、プログラミングに集中して割ける時間というのがどんどん減っていってはいるのですが(GitHubの草も壊滅的で)、それでも要所要所での爆発力みたいなので成果は出せているし、今年も純粋な能力的成長は果たせたと思っています。今のところの脳みその調子的にはかなり良いので、来年もいい成果を出していけそうです。</p>
<h2>漫画/音楽/ゲーム/その他…</h2>
<p>GDC 2019に行ってきたのですが、そのアウォードで表彰されてたゲームが、さすがの普通にとても良かった。特に<a href="http://celestegame.jp/">Celeste</a>は本当によく出来ていて暫く遊び続けていました。それと<a href="https://jp.ign.com/florence/22094/review/florence">Florence</a>、これは(リリースは2018年ですが私が今年プレイした中で)Bestで、感情を動かすためのUI/UXの究極系みたいな感じで、がっつりショック受けました。とにかくヤバい。制作秘話がまさにGDCで発表されていました。<a href="https://www.4gamer.net/games/453/G045353/20190320123/">［GDC 2019］鮮やかな人間ドラマを描く新感覚ゲーム「Florence」は，どのように作られたのか。22か月間の苦闘をデザイナーが振り返る</a>。</p>
<p>音楽は念願の相対性理論の野外ライブに行ってきた！Liveアルバム<a href="http://mirairecords.com/stsr/2337">調べる相対性理論</a>を日比谷野音で全曲実演したのですが、信じられないほど良かった！メンバーチェンジ後の相対性理論はビミョンに思ってたのですが、前のメンバーじゃこのライブには絶対ならなかっただろうし、この到達点のための……！みたいに思ってもう全てが受け入れられた。そんなわけで今年はずっとこのアルバム聴いてましたね。Live映像も出してほしい……。</p>
<p>あとは、<a href="https://www.mori.art.museum/jp/exhibitions/shiotachiharu/">魂がふるえる展</a>でふるえて来ました。いやあ、よかったね。実際この展示は最終的に<a href="https://globe.asahi.com/article/12891790">今年の美術展の入場者数でもトップクラス</a>だったそうで、映え、もそうですけれど実物から漂う死生観には圧倒されました。</p>
<p>ベストガジェットは<a href="https://www.apple.com/jp/airpods-pro/">AirPods Pro</a>ということで。Sonyの<a href="https://www.sony.jp/headphone/products/WF-1000XM3/">WF-1000XM3</a>も買っちゃってはいたんですが、どうにも使いづらくてAirPodsをずっと使い続けてたんですが、AirPods Proが出た瞬間に、完全に全て乗り換えました。恐ろしい完成度のデバイスだし、様々な面で既存の延長線上「ではない」革命的な要素が散りばめられていて、モノを作るならこういうのを作りたいよね（喩えで、別にハードウェアを作りたいとかそういうことを言ってるわけではない）、と思わせる一品でした。</p>
<h2>来年は</h2>
<p>MagicOnion v4と、そのためのパーツ作りが年始に入っています。これは間違いなくC#にとってのキーパーツになるので、ちゃんと仕上げたいですねえ。仕事のほうでも今仕込んでいるものが公開されていく年だと思うので、きっちりやっていけば相乗効果でC#元年（とは）ですよ！にできるんじゃないかと思ってます。そしてUnity度合いが結構下がっちゃってるので、そこも補填していければパーフェクトな姿に……！</p>
<p>といったのを目指してどしどしやっていきます。来年は爆発の年、ということで。</p>
</div>
<h1 data-pagefind-sort="date:2019-12-17" data-pagefind-meta="published:2019-12-17"><a href="https://neue.cc/2019/12/17_586.html">MessagePack for C# v2によるC#における最新のI/Oパイプライン最適化</a></h1>
<ul class="date"><li>2019-12-17</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>のVersion 2を本日リリースしました。出る出る詐欺で、一年がかりでリリースまで漕ぎ着けました！とにかくめっちゃ時間かかった、死ぬほど私のリソースが取られていた、ので本当にリリースまで持ってこれてよかった……。めでたし。</p>
<p>今回はとてもOSSっぽく開発していて、メインの開発はMicrosoftのVisual StudioチームのPrincipal Software Engineerである<a href="https://github.com/AArnott">Andrew Arnott</a>さんが書いています。私はそれに対してひたすら、APIデザインが好きじゃないだの、パフォーマンスが私の基準に満たしてないだの、文句つけまくる仕事をしていました。しかしコードのクオリティはさすがに非常に高くて、私だけだったらここには至れなかっただろうことを考えると、いい感じの共同開発ができたんじゃないかなあと思います。その結果として、一年前に掲示されたv2よりも、百億倍良くなってます。この一年間で磨きに磨き抜いたわけです。</p>
<p>最初のリリースから2年半が経ち、MessagePack for C#は今では ASP.NET のリポジトリに含まれていたり、Visual Studio内部で使われていたりと、もはや準標準バイナリシリアライザの地位を得ていたりします。さすがにここまで成長するとは想像してなかった。.NETに貢献し過ぎで偉い。Version 1はシリアライザのパフォーマンスの基準を大きく塗り替えて、新しい世代の水準を作り出したという偉業があったわけですが、今回のv2も大きな成果を出せると思っています。v2はI/Oパイプライン全体の最適化を見据えて、パイプラインの心臓部として正しく機能するためにはどうあるべきか、というのを指し示しました。今後のC#のアプリケーションのアーキテクチャは、ここで指し示した道に進んでいくことでしょう。</p>
<p>v1 -&gt; v2においては破壊的変更多数なので、移行ガイドを<a href="https://github.com/neuecc/MessagePack-CSharp/blob/master/doc/migration.md">migration.md</a>にまとめてあるので、適当に読んでおくと良いでしょう、詳しい解説は特にしません。ライブラリ類は一斉にバージョン上げないと詰みます。Cysharpで作っている<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>と<a href="https://github.com/Cysharp/MasterMemory">MasterMemory</a>は作業中なので、来週にはドバッと上げておきます多分予定。</p>
<h2>パイプラインによるゼロコピー</h2>
<p>MessagePack for C#の内部構造について、見るべきメソッドシグネチャは以下の2つです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static void Serialize&lt;T&gt;(IBufferWriter&lt;byte&gt; writer, T value, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
public static T Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; byteSequence, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
</code></pre>
<p>シリアライズにおいては <code>IBufferWriter&lt;byte&gt;</code>, デシリアライズにおいては <code>ReadOnlySequence&lt;byte&gt;</code> を入出力口に使うというのがポイントです。
どちらも<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.buffers">System.Buffers</a>に定義されている <code>.NET Standard 2.1</code> 世代のインターフェイスです。反面、v1ではともに <code>byte[]</code> ベースでした。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/70992927-30310880-210e-11ea-8b52-e2f673cb66b2.png" width=640 />
</p>
<p>I/Oのパイプラインってなんぞや、というと、ようするに入出力への<code>byte[]</code>をどう扱うかということであり、C#的には入り口も出口も最終的にはネイティブがやり取りするので、その手前のもの(SocketAsyncEventArgs, ConslePal+Stream, FileStream, etc...)、を呼び出して処理するフレームワーク、が呼び出すシリアライザ。といった流れになっています。シリアライザは常に中心(Object -&gt; byte[]変換)にいます。上の画像は一般的なやり取りの場合（あるいはv1の場合)で、RedisValue(StackExchange.Redis)がbyte[]を、ByteArrayContent(HttpClient)がbyte[]を、といったように、割と素のbyte[]を求められる局面は多い。その場合、シリアライザはnew byte[]した結果を返すことになり、それはフレームワークの処理を得て、入出力の源流へ再度コピーされ（されないこともある）ます。</p>
<p>ここにおける無駄は、byte[]のアロケーションと、コピーです。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/70992939-3a530700-210e-11ea-8224-4146c4928d8f.png" width=640 />
</p>
<p>と、いうわけで、byte[]のアロケーションを避けるパターンとして、シリアライザは作業領域として外部のバッファープール( <code>System.Buffers</code> で定義された<code>ArrayPool&lt;byte&gt;</code>は .NET Core 3.0ではクラスライブラリ内でも多用されています)を使用し、フレームワークから提供されるStreamに書き込むことで、必要なコストをコピーだけにする手法があります。v1でも一部実装していました。なお、Streamに対して直接Writeすることで自前バッファを使わないという手も理論上可能ですが、Writeによるオーバーヘッドが多いため性能が悪化します。また、どちらにせよStream内部でバッファを持っている場合もあります。さらに、非同期にも対応できませんし、では全てをWriteAsyncで処理すれば、更にオーバーヘッドが多くて全く性能がでません。つまり、性能の良いアプリケーションを作るには、バッファをどう扱うが大事です。v1の設計思想として、シリアライズの一単位をバッファとして取り扱えば良い、だから全てをbyte[]ベースで処理し、Streamへは一気に書き込めば良い。という指針がありました。そして、それは実際正しく機能して、当時存在したあらゆるシリアライザを引き離す性能を叩き出しました。</p>
<p class="noindent">
<img src="https://user-images.githubusercontent.com/46207/70992948-417a1500-210e-11ea-9119-b3f20a9ae662.png" width=640 />
</p>
<p><code>IBufferWriter&lt;byte&gt;</code>を活用すると、作業に必要なバッファを元ソースに対して直接要求することができます。それによりバッファ管理を完全に元ソースに任せることができるため、シリアライザ内部の作業バッファからのコピーコストが消滅します。例えばソケット通信で使われる<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.net.sockets.socketasynceventargs">SocketAsyncEventArgs</a>は通常使いまわされますが、それの持つ(byte[] Buffer)に直接書き込む、といったようなことが可能です。</p>
<p>Streamに対しては<code>System.IO.Pipleines</code>の提供する<a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.pipelines.pipewriter">PipeWriter</a>が<code>IBufferWriter&lt;byte&gt;</code>を実装し、最適なバッファ管理を代替してくれます。</p>
<p>ASP.NET Core 3.0からは従来の(Stream HttpResponse.Body)だけでなく、<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/middleware/request-response">(PipeWriter HttpResponse.BodyWriter)</a>も提供されるようになりました。<a href="https://www.nuget.org/packages/MessagePack.AspNetCoreMvcFormatter/">MessagePack.AspNetCoreMvcFormatter</a>は、.NETCoreApp 3.0の場合にはBodyWriterに対してシリアライズする実装を用意しています。</p>
<p>現在の.NETのフレームワークは、Streamを要求するものか、あるいはbyte[]を要求するものがほとんどです。しかし、フレームワークレベルでのIBufferWriter対応が進んでいけば、よりMessagePack for C# v2の真価が発揮されていくことでしょう。もちろん、byte[]を返すAPI(<code>byte[] Serialize&lt;T&gt;(T value)</code>)でも、最適なバッファ管理によってアロケーションやコピーコストを抑えるようになっています。</p>
<h2>理論とパフォーマンス</h2>
<p>多くある誤解として、<code>async/await</code>にしたら速くなるわけでもないし、<code>Span&lt;byte&gt;</code>にしたから速くなるわけでもありません。そして、<code>IBufferWriter&lt;byte&gt;</code>や<code>ReadOnlySequence&lt;byte&gt;</code>にしても速くなるわけではありません。理屈上コピーが減ったとしても、遅くなりえます。素朴に実装すればコピーしたほうが10倍速い、といった状況はありえます。</p>
<p>例えば <code>[10, 100, 100]</code> をシリアライズしたいと思ったとして、intが最大5バイト必要だとして、都度writter.GetSpanで取得した場合と、byte[]でどばっと取得した場合を比較すると……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IBufferWriter&lt;byte&gt;
foreach(var v in values)
{
    var buffer = writer.GetSpan(5);
    var length = WriteInt(buffer, v); // WriteInt returns write length
    writer.Advance(length); 
}

// byte[]
var buffer = ArrayPool&lt;byte&gt;.Shared.Rent(64K).AsSpan();
var offset = 0;
foreach(var v in values)
{
    var length = WriteInt(buffer.Slice(index), v);
    offset += length;
}
// Return buffer...
</code></pre>
<p>というようなコードを書いた場合、どう見てもbyte[]ベースで素朴にやったほうが速そうです、というか速いです。<code>ReadOnlySequence&lt;byte&gt;</code>もそうで、内部は複雑な型のため、そのまま使ってSliceなどを多用すると、かなり遅くなります。よって、<code>IBufferWriter&lt;byte&gt;</code>によって得られたバッファを適切に管理する中間層、<code>ReadOnlySequence&lt;byte&gt;</code>によって得られたSegmentのバッファを適切に管理する中間層、の作り込みが必要になってきます。</p>
<p>v2の開発にあたっては、byte[]ベースで極限まで性能を高めたv1があるので、どれだけv1と比較して遅くなっていないか、を基準に随時ベンチマークを取ることによって、中間層の存在による性能低下を検知し、極力性能低下を抑えることに成功しました。</p>
<p>逆に言えば、純粋なシリアライザとしての性能はv1のほうが高速(な場合も多い/バッファ管理が賢くなったのでシリアライズ対象が大きい場合はv2が有利な場合もある)なのですが、パイプラインに組み込めることと、様々な工夫により、トータルでみるとv2のほうが実アプリケーションとしては有利になっています。</p>
<h2>配列上のLZ4圧縮</h2>
<p>v1 -&gt; v2による性能向上の一つに、v1では64K以上のシリアライズではプールを使わず新規アロケーションをしていましたが、v2ではArrayPoolから取得する32Kのチャンクの連結リストを内部バッファとして使用しています(外部からIBufferWriterを渡さず、v2内部のバッファプールを使用する場合)。</p>
<p><img src="https://user-images.githubusercontent.com/46207/70992978-4ccd4080-210e-11ea-9ba6-1455a15c1ed8.png" alt="image" /></p>
<p>byte[]を作る場合は、最後に連結して一塊に。Streamに書き込む場合は32K毎にWriteAsyncします。これによりバッファが溢れた場合に、<code>List&lt;T&gt;</code>のように二倍のサイズのバッファを新規に確保して書き込み、などせずに済んでいます。また、常に使用するバッファの大きさが85K以下で済むため、悪名高いLarge Object Heap(LOH)を消費する(ここに溜まるとGCの性能が極度に低下する)ことも避けられています。</p>
<p>そしてv2から新規搭載された新しい圧縮モードである <code>MessagePackCompression.Lz4BlockArray</code> では、この内部形式を利用して32K単位でLZ4圧縮をかけることにより、圧縮するために、一度、全部が一塊になった大きな配列を確保することを避けています。</p>
<p><img src="https://user-images.githubusercontent.com/46207/70992989-52c32180-210e-11ea-9a92-7e14fe7cd258.png" alt="image" /></p>
<p>実装上の工夫としては、MessagePackの拡張領域であるExtを使用することによって圧縮種別を判定可能にしていることと、Extは長さが必要なため、LZ4で圧縮されてサイズが縮むことを考えると事前に長さを計算することができない！ことを避けるために、Arrayを使用した上で、Arrayの最初の要素をExtにして判定用＋LZ4のデシリアライズに必要な圧縮前の長さをここの部分に格納しています。これ、シリアライズもそうですが、デシリアライズ時もブロック単位で伸張できるので、大きなデータでも巨大配列を確保しないで済むという利点があります。</p>
<p>v1までの圧縮モードは<code>MessagePackCompression.Lz4Block</code>として残していますが、v2では<code>MessagePackCompression.Lz4BlockArray</code>を使用することをお薦めしています。既に圧縮済みのバイナリデータに関しては、Lz4BlockArrayでもLz4Blockをデシリアライズすることが可能です（逆も同様）。</p>
<p>ちなみにこの32Kというサイズを選んだのには、ちゃんと意味があります！まず、ArrayPoolの仕様で16K, 32K, 64K, 128Kの大きさで確保されます。20Kを要求した場合は32Kが、65Kを要求した場合は128Kが得られるという図式です。</p>
<p>そしてLZ4圧縮した場合、全く圧縮できなかった場合、ワーストケースでは要求サイズよりもほんの少し「大きく」なります。さて、そこでチャンクのサイズが64Kギリギリまで使用していて、LZ4圧縮をかけようとした場合は、圧縮後のサイズは圧縮完了まで不明のため、事前にワーストケースを想定し64.1K(仮)を要求し、結果として128Kが得られます。つまり、LOH行きです。厳密にはArrayPoolを使用しているため使い回されるので大丈夫ですが、プールサイズには上限を設けているので(全体で共有で32K * 100)、使い切った場合はアロケートされるので、そういうケースでもLOH行きを避けるためのサイズになっています。</p>
<h2>真のコードジェネレーター</h2>
<p>悪名高いド不安定なコードジェネレーターは大きく改善され、真の安定性と、ディレクトリ単位での指定と、ファイル単位での出力と、CIで使いやすい .NET Core (Local/Global) Toolsでのインストールと、XamarinやUWPで便利なMSBuild Taskの提供と、Unityでは初心者フレンドリーなEditor拡張を追加しました。</p>
<p><img src="https://user-images.githubusercontent.com/46207/69414381-f14da400-0d55-11ea-9f8d-9af448d347dc.png" alt="" /></p>
<p>とにかくMac/Linuxでも安定して動作する！というのが大きい！やっと大手を振って人にお薦めできるようになりました。</p>
<h2>まとめ</h2>
<p>と、解説しましたが、実装の8割以上は前述のAArnottさんが行ったものなので、まずは本当にありがとうございます。そもそもv2のキッカケはプロトタイプ実装を掲示されて、Forkしていくパターンか一緒に実装するかのどちらかと言われて、（何ヶ月も返事を放置した末に）、一緒にやっていきましょうとしたのが元でした。その後も、一ヶ月質問を放置するとかメールスルーとか、そもそも開発の遅れは私のコミュニケーションによるものでは……、というようなところを粘り強く乗り越えてもらったお陰です。</p>
<p>いや、そうはいっても私もかなりしっかりやってますよ！？特にAPIのデザインは紆余曲折あってもめにもめた末に一周回って私が最初に掲示したデザインになってるし、性能面では延々と私が地道にベンチマーク取って掲示することで腰を上げてもらったり（その時点で大体どこをどう変えればいいのかは分かってるので、指摘しながら）、Unity周りはそもそも興味ないみたいなので油断するとすぐ壊れるところを直していったりと、はい。</p>
<p>これでパイプラインにおける心臓部分を手に入れることが出来たのですが、改めてまだそもそもパイプラインに血が流れてません。ASP.NET Coreだけでなく他のフレームワークやライブラリ郡(特にRedisと、ADO.NETはいい加減に10年前のレガシーモデルから卒業して新しい抽象層を提供して欲しい)も対応していかなければならないし、私の場合は<a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>が、トランスポート層に採用しているGoogleのgRPCがイマイチなせいでめちゃくちゃイマイチです。</p>
<p>というわけで、次回はMagicOnionのパイプライン化を最適化するために、通信層から手を入れる予定です。また、シリアライザはMessagePackだけではなく、JSONも重要なので、改めて<a href="https://github.com/neuecc/Utf8Json/">Utf8Json</a>の改修も行いたいと思っています。.NET Core 3で華々しくデビューしたMicrosoft公式実装のSystem.Text.JsonによるJsonSerializerの性能が極めて悪いので……。残念ながらMicrosoftは柔軟かつ性能の出るシリアライザの作り方を全く分かっていないのでしょう。</p>
<p>また、このパイプラインはサーバーの入口→出口だけで閉じるものではなく、ネットワークを超えてクライアント側(Unity)にまで届くものだと考えています。サーバー/クライアントを大きなパイプラインに見立てて、見えるところ通るところ全てを最適化することが「C#大統一理論」であり、真に強力なのだ。ということを実証していくのが当座の目標で、やっと最初の一歩が踏めました。C#凄いな、と心の底から世界中の人が思ってもらうためにも（そしてあわよくば採用してもらう！）、まだ足りてないものは山のようにあるので、どんどん潰していきましょう。</p>
</div>
<h1 data-pagefind-sort="date:2019-12-06" data-pagefind-meta="published:2019-12-06"><a href="https://neue.cc/2019/12/06_585.html">.NET Core時代のT4によるC#のテキストテンプレート術</a></h1>
<ul class="date"><li>2019-12-06</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2019/c-sharp">C# Advent Calendar 2019</a>用の記事となります。<a href="https://qiita.com/advent-calendar/2019/c-sharp-2">C# Advent Calendar 2019はその2</a>もあって、そちらも埋まってるので大変めでたい。</p>
<p>さて、今回のテーマはT4で、この場合にやりたいのはソースコードジェネレートです。つまるところC#でC#を作る、ということをやりたい！そのためのツールがテンプレートエンジンです。.NETにおいてメジャーなテンプレートエンジンといえばRazorなわけですが、アレはASP.NET MVCのHTML用のViewのためのテンプレートエンジンなため、文法が全くソースコード生成に向いていません、完全にHTML特化なのです。また、利用のためのパイプラインもソースコード生成に全く向いていない（無理やりなんとか使おうとするRazorEngineといったプロジェクトもありますが……)ので、やめておいたほうが無難です。</p>
<p>では何を使えばいいのか、の答えがT4(Text Template Transfomration Toolkit)です。過去には<a href="http://neue.cc/2013/06/30_411.html">Micro-ORMとテーブルのクラス定義自動生成について</a>という記事で、データベースのテーブル定義からマッピング用のC#コードを生成する方法を紹介しました。テーブル定義は、実際にDB通信してもいいし、あるいは何らかの定義ファイルを解析して生成、とかでもいいですね。また、最近の私の作っているライブラリには(UnityのIL2CPP対策で)コードジェネレーターがついていますが(<a href="https://github.com/Cysharp/MagicOnion">MagicOnion</a>, <a href="https://github.com/Cysharp/MasterMemory/">MasterMemory</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack-CSharp</a>など)、それらの生成テンプレートは全てT4で作っています。</p>
<p>元々はVisual Studioべったりでしたし、実際べったりなのですが、Mac環境ではVisual Studio for Macで、あるいは（一手間入りますが）VS Codeで使用したり、最近だとRiderが2019.3 EAP 5からばっちしサポートされたようなので、MacやRider派の人も安心です。RiderのT4サポートは曰く</p>
<pre data-pagefind-ignore="all"><code class="language-txt">You asked us to support T4, and we’ve answered! T4 support is here, based on our own generator and available as a pre-installed plugin.
The plugin is open-sourced (https://github.com/JetBrains/ForTea) and your contributions are very welcome.
Feature-rich C# support in code blocks includes highlighting, navigation, code completion, typing assistance, refactorings, context actions, inspections, formatting, and more.
T4-specific features include inspections, typing assistance, folding, brace matching, etc.
Extensive support is offered for includes to make the resolve in C# code as correct as possible.
You can execute T4 templates.
You can also debug T4 templates.
All these features work across Windows, macOS, and Linux.
</code></pre>
<p>だそうで、なかなかイケてるじゃないですか。Visual Studioも、Riderもそうですが、テンプレートエンジンでデバッガ動かしてステップ実行できたりするのが地味に便利です。VS Codeだと設定に一手間が必要なので(Qiitaにて<a href="https://qiita.com/nogic1008/items/2c4049d43a11e83df15b">.NET Core+VS CodeでもT4 テンプレートエンジンでコード生成したい！</a>といった紹介もありますが)、VS2019, VS for Mac, Riderを使ったほうが楽そうです。</p>
<p>T4には2種類の生成パターン、<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates?view=vs-2019">デザイン時コード生成(TextTemplatingFileGenerator)</a>と、<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/run-time-text-generation-with-t4-text-templates?view=vs-2019">実行時テキスト生成(TextTemplatingFilePreprocessor)</a>の2種類がありますが、両方紹介します。</p>
<p>また、詳細なドキュメントが<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2019">コード生成と T4 テキスト テンプレート</a>にあり、実際かなり複雑な機能も搭載してはいますが、テキストテンプレートで複雑なことはやるべきではない（テキストテンプレートなんてあまり使わないような機能で使い倒した複雑なことやられても解読に困るだけ）ので、シンプルに使いましょう。シンプルに使う分には、全く難しくないです。</p>
<h2>デザイン時コード生成</h2>
<p>デザイン時コード生成とは、テンプレート単体でテキストを出力するタイプです。出力されたコードが、そのまま自身のプロジェクトのコンパイル対象になるイメージ。使い道としては、手書きだと面倒くさい単純な繰り返しのあるソースコードを一気に量産するパターンがあります。例えばジェネレクスのT1~T16までの似たようなコードを作るのに、一個雛形をテンプレートとして用意して for(1..16) で生成すれば一発、というわけです。他に、プリミティブの型(intとかdoubleとか)に対してのコード生成などもよくやりますね。またマークダウンで書かれた表（別の人がドキュメントとして書いているもの）から、enumを生成する、なんてこともやったりしますね。違うようで違わないようで実際微妙に違う退屈なユニットテストコードの生成、なんかにも使えます。</p>
<p>例としてMessagePackのカスタムシリアライザとして、以下のようなものを作りたいとします（単純な繰り返しの例としてちょうどよかったというだけなので、MessagePackの細かいAPIの部分は見なくてもいいです）。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Buffers;

namespace MessagePack.Formatters
{
    public sealed class ForceInt16BlockFormatter : IMessagePackFormatter&lt;Int16&gt;
    {
        public static readonly ForceInt16BlockFormatter Instance = new ForceInt16BlockFormatter();

        private ForceInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16 value, MessagePackSerializerOptions options)
        {
            writer.WriteInt16(value);
        }

        public Int16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt16();
        }
    }

    // 以下、Int16の部分がInt32だったりDoubleだったりするのを用意したい。
}
</code></pre>
<p>Int16になっている部分を、Int32やDoubleなど全てのプリミティブにあてはめて作りたい、と。手書きでも気合でなんとかなりますが、そもそも面倒くさいうえに、修正の時は更に面倒くさい。なので、これはT4を使うのが最適な案件といえます。</p>
<p>例はVisual Studio 2019(for Windows)で説明していきますが、T4の中身自体は他のツールを使っても一緒なのと、最後にRiderでの使用方法を解説するので、安心してください。</p>
<p>まずは新しい項目の追加で、「テキスト テンプレート」を選びます。</p>
<p class="noindent">
    <img src="https://user-images.githubusercontent.com/46207/70261367-9f852f00-17d5-11ea-87a2-bb7e00ff2ebe.png" width=640 />
</p>
<p>すると、以下のような空のテンプレートが生成されたんじゃないかと思われます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template debug=&quot;false&quot; hostspecific=&quot;false&quot; language=&quot;C#&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.txt&quot; #&gt;
</code></pre>
<p>csprojには以下のような追加のされ方をしています。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;ItemGroup&gt;
    &lt;None Update=&quot;ForceSizePrimitiveFormatter.tt&quot;&gt;
        &lt;Generator&gt;TextTemplatingFileGenerator&lt;/Generator&gt;
        &lt;LastGenOutput&gt;ForceSizePrimitiveFormatter.txt&lt;/LastGenOutput&gt;
    &lt;/None&gt;
    &lt;None Update=&quot;ForceSizePrimitiveFormatter.txt&quot;&gt;
        &lt;DesignTime&gt;True&lt;/DesignTime&gt;
        &lt;AutoGen&gt;True&lt;/AutoGen&gt;
        &lt;DependentUpon&gt;ForceSizePrimitiveFormatter.tt&lt;/DependentUpon&gt;
    &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>2個のItemが追加されているのは、T4本体と、生成物の2つ分です。<code>&lt;Generator&gt;TextTemplatingFileGenerator&lt;/Generator&gt;</code>というのがT4をこれで処理しますよ、という話で、DependentUponはソリューションエクスプローラーでの見た目上、ネストする親を指定、ということになっています。Visual Studioの不正終了なので、たまに***1.csなどといった末尾にインクリメントされたファイルしか生成されなくなってムカつく！という状況にたまによく陥るのですが、その場合はLastGenOutputあたりを手書きで修正してけば直ります。</p>
<p>さて、まず思うのはシンタックスハイライトが効いていない！ということなので、しょうがないのでVS拡張を入れます。私がよく使うのは<a href="https://t4-editor.tangible-engineering.com/T4-Editor-Visual-T4-Editing.html">tangible T4 Editor 2.5.0 plus
UML modeling tools</a>というやつで、インストール時にmodeling Toolsとかいういらないやつはチェック外してT4 Editorだけ入れておきましょう。なお、Visual Studioは閉じておかないとインストールできません。他のT4用拡張も幾つかあるのですが、コードフォーマッタがキモいとかキモいとか色々な問題があるので、私はこれがお気に入りです（そもそもコードフォーマットがついてない！変な整形されるぐらいなら、ないほうが百億倍マシです）。</p>
<p>さて、<code>&lt;#@ ... #&gt;</code>が基本的な設定部分で、必要な何かがあればここに足していくことになります。assembly nameは参照アセンブリ、基本的なアセンブリも最小限しか参照されていないので、必要に応じて足しておきましょう。ちなみにRiderだと何も参照されていない空テンプレートが生成されるので、デフォだとLINQすら使えなくてハァァァ？となるので要注意。System.Coreぐらい入れておけよ……。</p>
<p>import namespaceはまんま、名前空間のusingです。output extensionは、フツーは.csを吐きたいと思うので.csにしておきましょう。場合によってはcsvとかjsonを吐きたい場合もあるかもしれないですが。</p>
<p>次に、&lt;# ... #&gt; を使って、テンプレートに使う変数群を用意します。この中ではC#コードが書けて、別に先頭じゃなくてもいいんですが、あまりテンプレート中にC#コードが散らかっても読みづらいので、用意できるものはここで全部用意しておきましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#
    var types = new[]
    {
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(byte), 
        typeof(sbyte),
    };

    Func&lt;Type, string&gt; GetSuffix = t =&gt;
    {
        return t.Name == nameof(Byte) ? &quot;UInt8&quot; : (t.Name == nameof(SByte)) ? &quot;Int8&quot; : t.Name;
    };
#&gt;
</code></pre>
<p>今回は生成したいプリミティブ型を並べた配列を用意しておきます。また、ここではローカル関数を定義して、くり返し使う処理をまとめることもできるんですが(テンプレート中に式を書くと見にくくなるので、引数を受け取ってstringを返す関数を用意しておくと見やすくなります)、tangible T4 Editorがショボくてローカル関数に対してシンタックスエラー扱いしてくるので（動作はする）、Funcを使うことでお茶を濁します。</p>
<p>ここから先は本体ですが、短いので↑で見せた部分も含めてフルコードが以下になります。Visual Studioの場合は保存時、Riderの場合は右クリックから手動で実行した場合に、ちゃんとファイルが生成されていることが確認できるはずです！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template debug=&quot;false&quot; hostspecific=&quot;false&quot; language=&quot;C#&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
&lt;#
    var types = new[]
    {
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(byte), 
        typeof(sbyte),
    };

    Func&lt;Type, string&gt; GetSuffix = t =&gt;
    {
        return t.Name == nameof(Byte) ? &quot;UInt8&quot; : (t.Name == nameof(SByte)) ? &quot;Int8&quot; : t.Name;
    };
#&gt;
// &lt;auto-generated&gt;
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// &lt;/auto-generated&gt;

using System;

namespace MessagePack.Formatters
{
&lt;# foreach(var t in types) { #&gt;
    public sealed class Force&lt;#= t.Name #&gt;BlockFormatter : IMessagePackFormatter&lt;&lt;#= t.Name #&gt;&gt;
    {
        public static readonly Force&lt;#= t.Name #&gt;BlockFormatter Instance = new Force&lt;#= t.Name #&gt;BlockFormatter();

        private Force&lt;#= t.Name #&gt;BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, &lt;#= t.Name #&gt; value, MessagePackSerializerOptions options)
        {
            writer.Write&lt;#= GetSuffix(t) #&gt;(value);
        }

        public &lt;#= t.Name #&gt; Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.Read&lt;#= t.Name #&gt;();
        }
    }

&lt;# } #&gt;
}
</code></pre>
<p>記法の基本的なルールは&lt;# ... #&gt;で括っている部分以外は平文で出力されます。そして、&lt;#= ... #&gt;が式で、そこが文字列として展開されます。</p>
<p>なお、テンプレートを書くにあたって、長年の経験から得たおすすめのお作法があります。</p>
<ul>
<li>計算式はなるべくテンプレート中で書くのを避ける、ために事前に関数として定義しておく</li>
<li><code>&lt;auto-generated&gt;</code>を冒頭に書く、これはlintによる解析対象から外れる効果があるのと、このファイルがどこから来ているのかを伝えるために有用</li>
<li>foreachやifなどはなるべく一文で書く、複数行に渡っているとテンプレート中のノイズになって見難くなる。また、あまり</li>
<li><code>&lt;#</code>の開始行はインデントつけずに先頭で、というのもインデントつけてると平文のテンプレート生成対象になるため生成コードのインデントがズレやすい</li>
</ul>
<p>この辺を守ると、割と綺麗に書けると思います。テンプレートはどうしてもコード埋め込みがあって汚くなりやすいので、なるべく綺麗にしておくのは大事です。それでもどうしても避けられないifだらけで、読みにくくなったりはしてしまいますが、そこはしょうがない。</p>
<h2>実行時テキスト生成</h2>
<p>実行時テキスト生成は、いわゆるふつーに想像するテンプレートエンジンの動作をするもので、プログラム実行時に、変数を渡したらテンプレートにあてはめてstringを返してくれるクラスを生成します。データベースのテーブル定義からマッピング用のC#コードを生成するツール、であったり、私がよくやってるのはRoslyn(C# Compiler)でC#コードを解析して、それをもとにして更にC#コードを生成するツールであったり、というかむしろC#コードを解析してKotlinコードを生成したりなど、やれることはいっぱいあります。リフレクションでアセンブリを舐めて、条件に一致した型、メソッドから何かを作る、みたいなのも全然よくありますね。</p>
<p>これの作り方は、追加→新しい項目から「ランタイム テキスト テンプレート」を選ぶと、悲しいことに別に普通の「テキスト テンプレート」とほぼ同じものが生成されてます（VS2019/.NET Coreプロジェクトの場合）。なぜかというと、csprojを開くとGeneratorがTextTemplatingFileGenerator、つまり普通のテキストテンプレートと同じ指定になっているからです。これは、多分バグですね、でもなんか昔から全然直されてないのでそういうもんだと思って諦めましょう。</p>
<p>しょーがないので手書きで直します。GeneratorのTextTemplatingFileGeneratorをTextTemplatingFilePreprocessorに変えてください。そうすると以下のようなファイルが生成されています(Visual Studioの場合は保存時、Riderの場合は右クリックから手動で実行した場合)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">    #line 1 &quot;C:\Users\neuecc\Source\Repos\ConsoleApp14\ConsoleApp14\MyCodeGenerator.tt&quot;
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.VisualStudio.TextTemplating&quot;, &quot;16.0.0.0&quot;)]
    public partial class MyCodeGenerator : MyCodeGeneratorBase
    {
        /// &lt;summary&gt;
        /// Create the template output
        /// &lt;/summary&gt;
        public virtual string TransformText()
        {
            return this.GenerationEnvironment.ToString();
        }
    }
</code></pre>
<p>ファイル名で作られたパーシャルクラスと、TransformTextメソッドがあるのが分かると思います。これで何となく使い方は想像つくと思いますが、<code>new MyCodeGenerator().TransformText()</code>でテンプレート結果が実行時に得られる、という寸法です。</p>
<p>さて、しかしきっとコンパイルエラーが出ているはずです！これはNuGetで「System.CodeDom」を参照に追加することで解決されます。別にCodeDomなんて使ってなくて、CompilerErrorとCompilerErrorCollectionというExceptionを処理する生成コードが吐かれてるから、というだけなので、自分でその辺のクラスを定義しちゃってもいいんですが、まぁ面倒くさいんでCodeDom参照するのが楽ちんです。この辺ねー、昔の名残って感じでめっちゃイケてないんですがしょーがない。</p>
<p>それと行番号がフルパスで書かれててめっちゃ嫌、というかフルパスが書かれたのをバージョン管理に突っ込めねーよ、って感じなので、これも消しましょう。linePragmas=&quot;false&quot;をテンプレート冒頭に書いておけば消えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; linePragmas=&quot;false&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
</code></pre>
<p>この対応はほとんど必須ですね、ていうかデフォでfalseにしといてくれよ……。</p>
<p>さて、テンプレートにパラメーターを渡す方法ですが、これは生成されたクラス名と同じpartial classを定義すればOK。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">namespace ConsoleApp14
{
    // 名前空間/クラス名(ファイル名)を合わせる(親クラスの継承部分は書かなくてOK)
    public partial class MyCodeGenerator
    {
        public GenerationContext Context { get; }

        // とりあえずコンストラクタで受け取る
        public MyCodeGenerator(GenerationContext context)
        {
            this.Context = context;
        }
    }

    // 生成に使うパラメーターはクラス一個にまとめておいたほうが取り回しは良い
    public class GenerationContext
    {
        public string NamespaceName { get; set; }
        public string TypeSuffix { get; set; }
        public int RepeatCount { get; set; }
    }
}
</code></pre>
<p>これでテンプレート中でContextが変数として使えりょうになります。テンプレートの例として、面白みゼロのサンプルコードを出すと……(Roslynとか使うともっと意味のあるコード例になるのですが、本題と違うところがかさばってしまうので、すみません……)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">&lt;#@ template language=&quot;C#&quot; linePragmas=&quot;false&quot; #&gt;
&lt;#@ assembly name=&quot;System.Core&quot; #&gt;
&lt;#@ import namespace=&quot;System.Linq&quot; #&gt;
&lt;#@ import namespace=&quot;System.Text&quot; #&gt;
&lt;#@ import namespace=&quot;System.Collections.Generic&quot; #&gt;
&lt;#@ output extension=&quot;.cs&quot; #&gt;
// &lt;auto-generated&gt;
// THIS (.cs) FILE IS GENERATED BY ConsoleApp14.exe. DO NOT CHANGE IT.
// &lt;/auto-generated&gt;
namespace &lt;#= Context.NamespaceName #&gt;
{
&lt;# foreach(var i in Enumerable.Range(0, Context.RepeatCount)) { #&gt;
    public class Foo&lt;#= Context.TypeSuffix #&gt;&lt;#= i #&gt;
    {
    }

&lt;# } #&gt;
}
</code></pre>
<p>RepeatCountの回数で中身空のクラスを作るというしょっぱい例でした。これの注意事項は、普通のテキストテンプレートと特に変わりはないのですが、auto-generatedのところに、生成ツール名を入れておいたほうがいいです。外部ツールでコード生成するという形になるため、ファイルだけ見てもなにで生成されたかわからないんですね。あとから、何かで作られたであろう何で作られたかわからない自動生成ファイルを解析する羽目になると、ツールの特定から始めなくちゃいけなくてイライラするので、この辺をヘッダにちゃんと書いといてあげましょう。ただたんに「これは自動生成されたコードです」と書いてあるだけよりも親切で良い。</p>
<p>記述におけるコツは、やはりテンプレート中に式を書いて文字列を生成するよりかは、この場合だとContext側にメソッドを作って、引数をもらってstringを返すようにすると見通しが良いものが作りやすいでしょう。ちなみに<code>this.Context</code>のContextのIntelliSenseは効きません、そっちの解析までしてくれないので。テンプレートファイルにおける入力補完は甘え、おまけみたいなもんなので、基本的には頼らず書きましょう。もちろん、そのせいでばんばんTypoしてエラーもらいます。これが動的型付け言語の世界だ！をC#をやりながら体感できるので、いやあ、やっぱ静的型付け言語はいいですねえ、という気持ちに浸れます。</p>
<p>さて、こうして出来たクラスは、ただのパラメーターを受け取ってstringを返すだけのクラスなので、何に使っても良いのですが、9割はシンプルなコマンドラインツールになるのではないでしょうか。</p>
<p>C#でコマンドラインツールといったら！私の作ってる<a href="https://github.com/Cysharp/MicroBatchFramework">MicroBatchFramework</a>が当然ながらオススメなので、それを使ってツールに仕立ててみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using MicroBatchFramework;
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp14
{
    class Program : BatchBase
    {
        static async Task Main(string[] args)
        {
            await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync&lt;Program&gt;(args);
        }

        public void Run(
            [Option(&quot;o&quot;, &quot;output file path&quot;)]string outputPath,
            [Option(&quot;n&quot;, &quot;namespace name&quot;)]string namespaceName,
            [Option(&quot;t&quot;, &quot;type name suffix&quot;)]string typeSuffix = &quot;Foo&quot;,
            [Option(&quot;c&quot;, &quot;type generate count&quot;)]int repeatCount = 10
            )
        {
            // パラメータを作って
            var context = new GenerationContext
            {
                NamespaceName = namespaceName,
                TypeSuffix = typeSuffix,
                RepeatCount = repeatCount
            };

            // テキストを生成して
            var text = new MyCodeGenerator(context).TransformText();

            // UTF8(BOMなし)で出力
            File.WriteAllText(outputPath, text, new UTF8Encoding(false));

            Console.WriteLine(&quot;Success generate:&quot; + outputPath);
        }
    }
}
</code></pre>
<p>これで <code>ConsoleApp14.exe -o &quot;foo.cs&quot; -n &quot;HogeHoge&quot; -t &quot;Bar&quot; -c 99</code> というしょっぱいコマンドでfoo.csが吐かれるツールが完成しました！</p>
<h2>RiderにおけるT4</h2>
<p>RiderでのT4は、Visual Studioが使っている生成ツールとは違う、T4の記法として互換性のあるJet Brains独自のツールを実行している気配があります（そのため、場合によっては互換性がないところもあるかもしれません、というか実際linePragms=falseで行番号が消えなかった……)</p>
<p>実行自体は簡単で、ttに対して右クリックしてRunを選べばデザイン時コード生成、Preprocessを選べば実行時テキスト生成の出力結果が得られます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/70267774-74eda300-17e2-11ea-9121-a760d2db38ba.png" alt="image" /></p>
<p>現時点ではEAP、つまりプレビュー版ですが、まぁ他にもいっぱい良い機能が追加されてるっぽいので、Riderユーザーは積極的にEAPを使っていけばいいんじゃないかしら。</p>
<h2>T4にできないこと</h2>
<p>T4は、基本的に.ttで書かれたファイルを事前に(VSだと保存時、Riderだと任意に、あるいは設定次第でビルド時に)外部ツールが叩いて、テキスト(.csだったり色々)を生成します。いいところはC#プロジェクトと一体化して埋め込まれるので、パフォーマンスもいいし、そもそもT4生成時に型が合わなければエラーが出てくれる（動的の塊であるテンプレートファイルにとって、書き間違えは日常茶飯事なので、これは結構嬉しい）。実行効率も良いです、ファイル読んでパースして必要があればキャッシュして云々というのがないので。</p>
<p>が、しかし、プログラムが実行時に動的にテンプレートを読み込んでなにかする、みたいなことはできません。ツールのビルド時にテンプレートが出来上がってないといけないので、プラグイン的に足すのは無理です。それは成約になる場合もある、でしょうし、私的には型もわからないようなのを動的に合わせてテンプレート作るとか苦痛なので（←最近なんかそういうのやる機会が多くて、その度にシンドイ思いをしてる）、パラメータ渡しだけでなんとかして済むようにして諦めて作り込んだほうが百億倍マシ、ぐらいには思っていますが、まぁそういうのがしたいというシチュエーション自体は否定できません。その場合は、他のテンプレートエンジンライブラリを選んで組み込めば良いでしょう、T4がやや特殊なだけで、他のテンプレートエンジンライブラリは、むしろそういう挙動だけをサポートしているので。</p>
<h2>まとめ</h2>
<p>T4は十分使い物になります。微妙にメンテされてるのかされてないのか不安なところもありますが、そもそもMicrosoftもバリバリ使っているので(GitHubに公開されているcorefxのコードとかはT4で生成されているものもかなりあります、最近追加されたようなコードでも)、全く問題ないでしょう。実際、記法も必要十分揃っているし、特に極端に見にくいということもないと思います、ていうかテンプレートエンジンとしてフツーなシンタックスですしね。</p>
<p>仮に複雑なことやりたければ、例えばテンプレートをパーツ化して使い回すために分割して、都度インポートとか、というのもできます(<a href="https://docs.microsoft.com/ja-jp/visualstudio/modeling/t4-include-directive?view=vs-2019">T4 インクルード ディレクティブ</a>では.t4という拡張子が紹介されていますが(拡張子はなんでもいい)、一般的には.ttincludeという拡張子が使われています)。他いろいろな機能がありますが、あらためて、テキストテンプレートごときで複雑なことやられると、追いかける気が失せるので、なるべく単純に保ちましょう。やるとしてもせいぜいincludeまで。それ以上はやらない。</p>
<p>というわけで、どうでしょう。MicroBatchFrameworkとも合わせて、C#のこの辺の環境は割といいほうだと思ってます。コード生成覚えるとやれることも広がるので、ぜひぜひ、コード生成生活を楽しんでください！</p>
<p>また、Unityでも普通に便利に使えると思います。Editor拡張でソースコード生成するものを用意するパターンは多いと思いますが（なにかリソースを読み込んで生成したり、あるいはそのままAssembly.GetExecutingAssembly().GetTypes()して型から生成したり)、その時のテンプレートとして、普通にstringの連結で作ってるケースも少なくなさそうですが、「デザイン時コード生成」も「実行時テキスト生成」も、どっちも全然いけます。「T4にできないこと」セクションに書いたとおり、よくも悪くも外部ツールで実行環境への依存がないので。</p>
</div>
<h1 data-pagefind-sort="date:2019-09-30" data-pagefind-meta="published:2019-09-30"><a href="https://neue.cc/2019/09/30_584.html">Unite Tokyo 2019でC# Structの進化の話をしてきました</a></h1>
<ul class="date"><li>2019-09-30</li></ul>
<div class="entry_body"><p><a href="https://events.unity3d.jp/unitetokyo/">Unite Tokyo 2019</a>にて、「Understanding C# Struct All Things」と題して登壇してきました！動画は後日<a href="https://learning.unity3d.jp/3305/">Unity Learning Materials</a>に公開される予定です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/h7l40rS3W9o3dI" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2019understanding-c-struct-all-things" title="【Unite Tokyo 2019】Understanding C# Struct All Things" target="_blank">【Unite Tokyo 2019】Understanding C# Struct All Things</a> </strong> from <strong><a href="https://www.slideshare.net/UnityTechnologiesJapan002" target="_blank">UnityTechnologiesJapan002</a></strong> </div>
<p>C#成分強めなので、Unityに馴染みのない人でも読んで楽しめる内容になっていると思います。とはいえ勿論、Uniteでのセッションであるということに納得してもらえるようUnity成分もきちんと取り入れています。というわけで、どちらの属性の人にも楽しんでいただければ！</p>
<p>structに関する機能強化、実際めっちゃ多いんですが、それをカタログ的に延々と紹介してもつまらないので、そうしたカタログ紹介っぽさが出ないように気を配ってます。あと、あんましそういうのでは脳みそに入ってこないというのもあるので。</p>
<p>応用例的なところのものは、ないとつまらないよねーということで色々持ってきたのですが、もう少し説明厚くしても良かったかなー感はありました。セッション内でも雰囲気で流した感じありますしね。とはいえ尺とか尺とか。まぁ雰囲気を分かってもらえれば（structは色々遊べるよ、という）いい、と割り切った面もあるにはあります。詳しくは資料を熟読してください！</p>
<p>Span/NativeArrayの説明も厚くしたくはあったんですが、structそのものの本題からは若干外れるので見送り。あと尺とか尺とか。</p>
<p>今年のUnite、もの凄くいいイベントでした。神運営とはこのことか……。そしてDOTSが熱い。めっちゃやるやる詐欺なので、いい加減本当にそろそろDOTSに手を出して楽しみたいですます！</p>
<p>あと、MessagePack-CSharp v2はいい加減そろそろ出るはず予定です、ちなみにSystem.Memoryとかにめっちゃ依存しているので、MessagePack-CSharpを入れるとSpanとかSystem.Runtime.CompilerServices.Unsafeとかが解禁されます（依存ライブラリとして同梱する予定なので）。いいのかわるいのか。まあ、いいでしょふ。未来未来。</p>
</div>
<h1 data-pagefind-sort="date:2019-09-09" data-pagefind-meta="published:2019-09-09"><a href="https://neue.cc/2019/09/09_583.html">CEDEC 2019にてMagicOnion、或いは他言語とC#の協調について話しました</a></h1>
<ul class="date"><li>2019-09-09</li></ul>
<div class="entry_body"><p>セッション名は<a href="https://cedec.cesa.or.jp/2019/session/detail/s5c9dede391631">Unity C# × gRPC × サーバーサイドKotlinによる次世代のサーバー/クライアント通信 〜ハイパフォーマンスな通信基盤の開発とMagicOnionによるリアルタイム通信の実現〜</a>(長い！）ということで二部構成になっていて、私は後半部分を担当しました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/3bVZiQOrtqFUqt" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/unity-cnet-coremagiconion-c-kotlin" title="Unity C#と.NET Core(MagicOnion) C# そしてKotlinによるハーモニー" target="_blank">Unity C#と.NET Core(MagicOnion) C# そしてKotlinによるハーモニー</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p><a href="https://cysharp.co.jp">Cysharp</a>は他社さんのお仕事も（ボリューム次第で、今はちょっとしたコンサルティングぐらいしか空きがないんですが）受けたりも可能です、ということで<a href="https://www.applibot.co.jp">アプリボット</a>さんのお手伝いをちょいちょいしています。リアルなMagicOnionの採用の話として、どんな風にやってるんですかねーというところの一環をエモ成分強めで語ってみました。リリースどころかタイトルもまだ未発表なので技術的な部分が弱めなので、次はリアルな実例として色々詰めたいところですね！</p>
<p>前半部、というかがっちゃんこされている資料は<a href="https://speakerdeck.com/n_takehata/kuraiantotong-xin-haipahuomansunatong-xin-ji-pan-falsekai-fa-tomagiconionniyoruriarutaimutong-xin-falseshi-xian">こちら</a>で公開されています。前半でgRPCいいぞ！という話をしているのに、こちらは冒頭でprotoは嫌だお！という展開で繋げるアレゲさでしたが、まあジョークの一環です。多分。はい。protoのいいところは中間形式であり言語agnosticなところで、protoのよくないところは中間形式であること、ですね。これが何を言っているかを理解できれば100点満点です！是非の議論は、このことを理解してから進めましょう。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">MagicOnion</a>は、ちょうど今日Ver 2.4.0をリリースしまして、やる気満々です。次の展開もいろいろ考えているので、というか積みタスクがんがんがんが。まぁ、順次やってきます。</p>
<p>さて、9月はもう一つ、「Understanding C# Struct All Things」と第して<a href="https://events.unity3d.jp/unitetokyo/">Unite Tokyo 2019</a>でセッションします。
Day 2のRoom A、13:30からでライブ配信もあるので、そちらも見ていただければ！</p>
</div>
<a href="https://neue.cc/3">Prev |</a>
<a href="https://neue.cc/5">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
