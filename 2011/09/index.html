<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <meta charset="utf-8" />
    <title>neue cc - 2011-09</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-twilight.min.css" rel="stylesheet" />
    <meta property="og:url" content="" />
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <div id="header"></div>
        <div id="content"><h1><a href="https://neue.cc/2011/09/23_345.html">SL/WP7のSilverlight Unit Test Frameworkについて少し深く</a></h1>
<ul class="date"><li>2011-09-23</li></ul>
<div class="entry_body"><p>の、前に少し。<a href="http://dynamicjson.codeplex.com/" title="DynamicJson">DynamicJson</a>と<a href="http://linqcomparer.codeplex.com/" title="AnonymousComparer - lambda compare selector for Linq">AnonymousComparer</a>をNuGetに登録しました。どちらも.csファイル一個のお手軽クラスですが、NuGetからインストール可能になったことで、より気楽に使えるのではかと思います。機能説明は省略。</p>
<p>そして、昨日の今日ですが<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>を<a href="http://archive.msdn.microsoft.com/silverlightut" title="Silverlight Unit Test Framework - Home">Silverlight Unit Test Framework</a>に対応させました。リリースのバージョンは1.6.0.1ということで。NuGetでは<a href="http://nuget.org/List/Packages/ChainingAssertion-SL">ChainingAssertion-SL</a>と<a href="http://nuget.org/List/Packages/ChainingAssertion-WP7">ChainingAssertion-WP7</a>になります。</p>
<h2>Silverlight Unit Test Framework</h2>
<p>Silverlightで使う場合は(WP7じゃなくてね、という意味です)、一応<a href="http://silverlight.codeplex.com/" title="Silverlight Toolkit">Silverlight Toolkit</a>に同梱という話ではあるのですが、テンプレートなどの用意が面倒くさいので、NuGet経由で入れるのが最も楽のようです。<a href="http://nuget.org/List/Packages/Silverlight.UnitTest" title="NuGet gallery">Install-Package Silverlight.UnitTest</a>で。</p>
<p>まず、Silverlightアプリケーションを新規作成。Webサイトでのホストはなしでいいです。それとブラウザで実行させる必要もないので、プロジェクトのプロパティからOut of Browserに変更してしまいましょう。次に、NuGetからInstall-Package Silverlight.UnitTest。これでライブラリの参照と、ApplicationExtensions.cs(イニシャライズ用拡張メソッド)、UnitTest.cs（テスト用テンプレ）が追加されているはずです。次にApp.xaml.csのStartupを以下のように書き換えます。</p>
<pre><code class="language-csharp">private void Application_Startup(object sender, StartupEventArgs e)
{
    // this.StartTestRunnerDelayed();
    this.StartTestRunnerImmediate();
}
</code></pre>
<p>StartTestRunnerDelayedはテストランナー起動時に実行オプション（指定属性のもののみ実行するなど）を選択可能にするもの、Immediateはすぐに全テストを実行する、というものです。どちらかを選択すればOK。それで、とりあえず実行(Ctrl+F5)してみれば、テストランナーが立ち上がって、デフォテンプレに含まれるUnitTest.csのものが実行されているんじゃないかしらん。あとは、それを適宜書き換えていけばよし。なお、テンプレのテストクラスはSilverlightTestを継承していますが、これは必ずしも継承する必要はありません。後述しますが、Asynchronousのテストを行いたいときは必須ですが、そうでないならば、普通にMSTestでの場合と同じように、[TestClass]と[TestMethod]属性がついているものがテスト対象になっています。</p>
<p>なお、MainPage.xaml/.xaml.csは不要なので削除してしまってOK。StartTestRunnerによって、参照DLLのほうに含まれるxamlが呼ばれているためです。</p>
<h2>WP7の場合。</h2>
<p>一応NuGetにも用意されてるっぽい(silverlight.unittest.wp7)んですが、動きませんでした。ので、今のところ手動で色々用意する必要があります。詳しくは<a href="http://d.hatena.ne.jp/okazuki/20110911/1315736690" title="Windows Phone 7用の単体テストツール？ その２「使ってみた」 - かずきのBlog@Hatena">Windows Phone 7用の単体テストツール？ その２「使ってみた」 - かずきのBlog@Hatena</a>に全部書いてあるのでそちらを参照のことということで。参照するためのDLLを拾ってくる→App.xaml.cs、ではなくてMainPage.xaml.csを書き換える、という、Silverlight版とやることは一緒なのですけどね。こういう状況なのはMangoのSDKがベータだったからとかなんとかのせいだとは思うので、近いうちに解決するのではかと、楽観視したいところです。</p>
<h2>Chaining Assertionを使ってみる</h2>
<p><a href="http://neue.cc/2011/09/20_344.html" title="neue cc - Chaining Assertion ver 1.6.0.0">Chaining Assertion ver 1.6.0.0</a>の解説で紹介した失敗結果が丁寧に表示されるよー、をチェックしてみませう。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public int Age { get; set; }
    public string FamilyName { get; set; }
    public string GivenName { get; set; }
}
 
[TestClass]
public class ToaruTest
{
    [TestMethod]
    public void PersonTest()
    {
        // こんなPersonがあるとすると
        var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
        // こんな風にメソッドチェーンで書ける(10歳以下でYamadaTarouであることをチェックしてます)    
        // 実際の値は50歳でYamamotoTasukeなので、このアサーションは失敗するでしょう
        person.Is(p =&gt; p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
    }
}
</code></pre>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/persontestwp7.jpg">
</p>
<p>はい、ちゃんと表示されます。Chaining Assertionを使うと、メソッドチェーンスタイルで、実際の値.Is(期待値の条件)というように、 簡潔な記述でテストを書くことが出来るのがうりです。また、失敗時には、この場合personの値を詳細に出力してくれるので、何故失敗したのかが大変分かりやすい。もし、普通に書くと以下のようになりますが、</p>
<pre><code class="language-csharp">// もし普通に書く場合
var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
Assert.IsTrue(person.Age &lt;= 10);
Assert.AreEqual(&quot;Yamada&quot;, person.FamilyName);
Assert.AreEqual(&quot;Tarou&quot;, person.GivenName);
</code></pre>
<p>まず、Assert.IsTrueでは失敗時にperson.Ageの値を出してくれないので、確認が面倒です。また、この場合、Personが正しいかをチェックしたいわけなので、FamilyNameやGivenNameも同時に判定して欲しいところですが、Ageを判定した時点で失敗のため、そこでテストは終了してしまうため、FamilyNameやGivienNameの実際の値を知ることは出来ません。</p>
<p>などなどの利点があるので、<a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>はお薦めです！この記事はSilverlight Unit Test Frameworkの紹介の体をとっていますが、実態はChaining Assertionの宣伝記事ですからね(ｷﾘｯ</p>
<h2>非同期テストをしてみる</h2>
<p>Silverlightといったら非同期は避けて通れない。というわけで、Silverlight Unit Test Frameworkには非同期をテストできる機構が備わっています。[Asynchronous]というように、Asynchronous属性をつければそれだけでOK。と、思っていた時もありました。実際に試してみると全然違って、独特なシステムのうえにのっかっていて、かなり面倒くさかった……。</p>
<p>準備。まず、非同期テストをしたいクラスはSilverlightTestクラスを継承します。そしてAsynchronous属性をつけます。すると、そのテストメソッドはTestCompleteが呼ばれるか例外を検知するまでは、終了しなくなります。というわけで、こんな感じ。</p>
<pre><code class="language-csharp">[TestClass]
public class ToaruTest : SilverlightTest
{
    [TestMethod]
    [Asynchronous]
    public void AsyncTest()
    {
        var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
        req.BeginGetResponse(ar =&gt;
        {
            try
            {
                req.EndGetResponse(ar)
                    .ResponseUri.ToString()
                    .Is(&quot;http://www.google.co.jp/&quot;);
            }
            catch (Exception ex)
            {
                EnqueueCallback(() =&gt; { throw ex; }); // 例外はテスト用スレッドに投げる必要がある
                return;
            }

            // ↓は定型句なので、EnqueueTestComplete(); という単純化されたのが用意されている
            EnqueueCallback(() =&gt; TestComplete()); // 何事もなければ終了でマーク
        }, null);
    }
}
</code></pre>
<p>このUnitTestの非同期は、独自のスレッドモデル（のようなもの）で動いていて、Dispatcherのようなキューにたいしてアクションを放り投げてあげる必要があります。別スレッドからUIスレッドは触れないように、「成功(TestComplete)」か「失敗(例外発生)」を伝えるには、EnqueueCallbackを経由しなければなりません。この辺はDispatcher.BeginInvokeするようなもの、と考えるといいかもしれません。</p>
<p>上のは少し原理に忠実にやりすぎた。まるごとEnqueueCallbackしてしまえばスレッドを意識する必要性は少しだけ減ります。</p>
<pre><code class="language-csharp">[TestMethod, Asynchronous]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/404&quot;); //404なので例外出してくれる
    req.BeginGetResponse(ar =&gt;
    {
        EnqueueCallback(() =&gt; req.EndGetResponse(ar)
            .ResponseUri.ToString()
            .Is(&quot;http://www.google.co.jp/&quot;));

        EnqueueTestComplete();
    }, null);
}
</code></pre>
<p>といっても、これは非常に単純なケースなだけであって、複雑なケースを書くとどんどん泣きたくなっていくでしょう……。一応、Enqueueには他にEnqueueConditionalという、条件式がtrueになるまで待機し続けるというものが用意されているので、若干制御はできなくもないんですが、あんまりできるとは言い難い仕組みがあります。詳しくは述べませんというか、別に使いやすいシステムじゃないのでどうでもいいです。</p>
<h2>Rxを使ってみる</h2>
<p>結果・もしくは例外を別のスレッドシステムに投げる。どこかで聞いたことあるような。ここでティンと来るのは<a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>のObserveOnDispatcherです。Dispatcher.BeginInvokeのかわりにEnqueueCallback。丸っきりそっくり。なので、ObserveOnTestQueueのようなメソッドが作れれば、非常に使い勝手がいいんじゃないか。と思い浮かぶわけです。</p>
<p>と、浮かんだ人は実に素敵な発想力を持っていますね。浮かんだのは私じゃなくて海外の人です。はい。<a href="http://blog.richardszalay.com/2011/08/08/writing-asynchronous-unit-tests-with-rx-and-the-silverlight-unit-testing-framework/" title="Writing asynchronous unit tests with Rx and the Silverlight Unit Testing Framework | Richard Szalay">Writing asynchronous unit tests with Rx and the Silverlight Unit Testing Framework | Richard Szalay</a>に、実装が書かれています。</p>
<p>そのRxによるScheduler実装を使うと(WP7版なのでSystem.ObservableとMicrosoft.Phone.Reactiveも参照してください)</p>
<pre><code class="language-csharp">[TestMethod, Asynchronous]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
    Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse,req.EndGetResponse)()
        .ObserveOnTest(this)
        .Subscribe(r =&gt; 
            r.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;),
            () =&gt; TestComplete());
}
</code></pre>
<p>EnqueueCallbackの管理がなくなり、非常に簡単に記述できました。Rxのスケジューラのシステムの柔軟さの賜物ですね。これはRxの素晴らしい応用例だと本当に感動しました。Richard Szalayさんに乾杯。それと、私がこの記事を知ったのは<a href="http://www.infoq.com/jp/news/2011/09/Rx-Silverlight-Tests" title="InfoQ: Rx と Silverlight で非同期テストを記述する">InfoQ: Rx と Silverlight で非同期テストを記述する</a>からなので、紹介したInfoQと、そして翻訳した勇 大地さんにも大変感謝します。</p>
<h2>Silverlightの場合</h2>
<p>Richard SzalayさんのコードはWP7のMicrosoft.Phone.Reactiveのためのものなので、Silverlight用Rxの場合はそのままでは動きません。はい。残念ながら、WP7版RxとDataCenter版Rxとでは、互換性がかなり崩壊しているので、そのまま動くことなんてないんです。悲しいですねえ……。これに関しては<a href="http://techblog.hilife-jp.info/2011/09/rx-silverlight-web.html" title="銀の光と藍い空: 「Rx と Silverlight で非同期テストを記述する」をWeb版にも使えるようにしたい!">銀の光と藍い空: 「Rx と Silverlight で非同期テストを記述する」をWeb版にも使えるようにしたい!</a>に書かれていますが、Silverlight用に移植してあげればよいようです。</p>
<p>既に、上記記事で田中さんが移植されているのですが、二番煎じに書いてみました（と、※欄で書いたものを流用です、毎回、流用させてもらっていてすみません……）</p>
<pre><code class="language-csharp">public static class TestHarnessSchedulerObservableExtensions
{
    public static IObservable&lt;T&gt; ObserveOnTestHarness&lt;T&gt;(this IObservable&lt;T&gt; source, WorkItemTest workItemTest)
    {
        return source.ObserveOn(new TestHarnessScheduler(workItemTest));
    }

    public static IDisposable RunAsyncTest&lt;T&gt;(this IObservable&lt;T&gt; source, WorkItemTest workItemTest, Action&lt;T&gt; assertion)
    {
        return source.ObserveOnTestHarness(workItemTest).Subscribe(assertion, () =&gt; workItemTest.TestComplete());
    }
}

public class TestHarnessScheduler : IScheduler, IDisposable
{
    readonly WorkItemTest workItemTest;
    readonly CompositeDisposable subscriptions;

    public TestHarnessScheduler(WorkItemTest workItemTest)
    {
        var completionSubscription =
            Observable.FromEventPattern&lt;TestMethodCompletedEventArgs&gt;(
                h =&gt; workItemTest.UnitTestHarness.TestMethodCompleted += h,
                h =&gt; workItemTest.UnitTestHarness.TestMethodCompleted -= h)
            .Take(1)
            .Subscribe(_ =&gt; Dispose());

        this.subscriptions = new CompositeDisposable(completionSubscription);
        this.workItemTest = workItemTest;
    }

    public void Dispose()
    {
        subscriptions.Dispose();
    }

    public DateTimeOffset Now
    {
        get { return DateTimeOffset.Now; }
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        return Schedule(state, dueTime - Now, action);
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        if (subscriptions.IsDisposed) return Disposable.Empty;

        workItemTest.EnqueueDelay(dueTime);
        return Schedule(state, action);
    }

    public IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        if (subscriptions.IsDisposed) return Disposable.Empty;

        var cancelToken = new BooleanDisposable();

        workItemTest.EnqueueCallback(() =&gt;
        {
            if (!cancelToken.IsDisposed) action(this, state);
        });

        subscriptions.Add(cancelToken);
        return Disposable.Create(() =&gt; subscriptions.Remove(cancelToken));
    }
}
</code></pre>
<p>Richard Szalayさんのコードが非常に素晴らしく、あらゆるケースへのキャンセルに対して完全に考慮されているという感じなので、そのまま持ってきました。実際のところ、テスト用なので「例外発生/TestCompleteが呼ばれる」で実行自体が終了してしまうわけなので、こうもギチギチに考えなくてもいいのではかなー、とか緩いことを思ってしまいますが、まあ、よく出来ているならよく出来ているままに使わさせてもらいます。</p>
<p>メソッド名は、ObserveOnTestHarnessに変更しました。ObserveOnTestだけだと何かイマイチかなー、と思いまして。それと、時間のスケジューリングは、NotSupportedではなくて、EnqueueDelayというのものがあるので、それを使うことにしてみました。それと、ObserveOn -&gt; Subscribe -&gt; onCompletedにTestCompleteが定形文句なので、それらをひとまとめにしたRunAsyncTestを追加。こんな風に書けます。</p>
<pre><code class="language-csharp">var req = WebRequest.Create(&quot;http://www.google.co.jp/444&quot;);
Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
    .RunAsyncTest(this, res =&gt; 
        res.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;));
</code></pre>
<p>定形文句が減る、つまりうっかりミスで書き忘れて死亡というのがなくなる、というのはいいことです。</p>
<h2>通常のMSTestの場合</h2>
<p>ところで、もしSilverlight/WP7固有の機能は使っていなくて、WPFでも利用出来るようなコードならば、コードをリンク共有の形でWPF側に持っていってしまって、そこでテスト実行してしまうと非常に楽です。まず第一に、MSTestやNUnitなどの通常のテストフレームワークが使えるため、Visual Studio統合やCIが簡単に行えます。第二に、非同期のテストが(Rxを使った場合)更に簡単になります。</p>
<pre><code class="language-csharp">[TestMethod]
public void AsyncTest()
{
    var req = WebRequest.Create(&quot;http://www.google.co.jp/&quot;);
    var result = Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)()
        .First(); // First()で同期的に待機して値が取れる。複数の場合はToEnumerable().ToArray()で。

    result.ResponseUri.ToString().Is(&quot;http://www.google.co.jp/&quot;);
}
</code></pre>
<p>FirstやToEnumerable.ToArrayにより、同期的に待機することが出来るので、簡単にテストすることができます。通常のコードは同期的待機はすべきではないのですが、こうしたユニットテストの場合は便利に使えます。</p>
<p>じゃあSilverlightのユニットテストでも待機できるのはないか？というと、それはできません。理由は<a href="http://neue.cc/2010/10/14_280.html">Windows Phone 7で同期APIを実現するたった つの冴えないやり方</a>で書いたのですが、WebRequestなどのネットワーク問い合わせは、一度Dispatcherに積まれて、現在のメソッドを抜けた後に実行開始されるので、テスト実行スレッドで同期的に待って値を取り出すことは不可能なのです。</p>
<p>こういった細部の違いもあるので、コード共有してMSTestでチェックするのは楽でいいのですが、やはりSilverlight/WP7の実際の環境で動かされるユニットテストのほうも必要不可欠かなー、と。どこまでやるか、にもよりますが。</p>
<h2>まとめ</h2>
<p><a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>は便利なので是非試してみてね！</p>
<p>なお、Rxを使うとTestScheduler(時間を好きなように進められる)やITestableObserver(通知の時間と値を記録できる)といった、イベント/非同期のテストを強力に支援する仕組みが備わっているので、それらと併用することで、より簡単に、もしくは今までは不可能だったことを記述できるようになります。それはまた後日そのうち。</p>
<p>SL/WP7のテストは、本当はIDE統合されてるといいんですけどねー。まあ、エミュレータ動かさなければならないので、しょうがないかな、というところもありますけれど。その辺も次期VisualStudioでは改善されるのかされないのか、怪しいところです。現在DeveloperPreviewで出ているVS11は、特に何も手をつけられてる感じがしないので、そのままな可能性はなきにしもあらず。どうなるかしらん。async/awaitが入ることだし、色々変わってくるとは思うんですけれど。</p>
</div>
<h1><a href="https://neue.cc/2011/09/20_344.html">Chaining Assertion ver 1.6.0.0</a></h1>
<ul class="date"><li>2011-09-20</li></ul>
<div class="entry_body"><p><a href="http://chainingassertion.codeplex.com/" title="Chaining Assertion">Chaining Assertion</a>というメソッドチェーンスタイルでユニットテストを書くことの出来るテスト用補助ライブラリをver.1.6に更新しました。内容はAssertEx.ThrowsContractExceptionの追加と、ラムダ式を使った判定の失敗時メッセージが親切になりました。</p>
<h2>ThrowsContractException</h2>
<p>まず、契約失敗でスローされる例外を厳密に検出することができるということについて。以前に<a href="http://www.slideshare.net/neuecc/code-contracts-8069150" title="基礎からのCode Contracts">基礎からのCode Contracts</a>というスライドに書きましたが、Contract.Requires(など)で発生する、契約の条件に合っていない時にスローされる例外は、ContractExceptionというリライト時にアセンブリに埋め込まれる型のため、型を判別してのcatchは不可能です。</p>
<p>そのため、従来は大雑把にExceptionがスローされるか否か、でしか判定できませんでした。そこでThrowsContractExceptionを使うと、厳密に、契約失敗の例外のみを判定することができます。</p>
<pre><code class="language-csharp">// こんなContractなクラスがあるとして
public class QB
{
    public void Homu(string s)
    {
        Contract.Requires(s != null);
    }
}

// こういう風に契約違反の例外を捉えることができる
[TestMethod]
public void QBTest()
{
    AssertEx.ThrowsContractException(() =&gt;
        new QB().Homu(null));
}
</code></pre>
<p>Code Contractsを使ったコードを書いている場合は、便利に使えるのではないでしょうかー。</p>
<h2>ラムダ式によるアサーション</h2>
<p>で、Chaining Assertionって、こんな感じに書けます。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
public class Person
{
    public int Age { get; set; }
    public string FamilyName { get; set; }
    public string GivenName { get; set; }
}

// こうして判定することが出来ます
[TestMethod]
public void PersonTest()
{
    // GetPersonメソッドでPersonインスタンスを取得するとして、
    // こんな風にメソッドチェーンで書ける(10歳以下でYamadaTarouであることをチェックしてます)
    new HogeService().GetPerson().Is(p =&gt;
        p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
}
</code></pre>
<p>今回追加したのは、失敗した時のメッセージをより分かりやすくしました。</p>
<pre><code class="language-csharp">[TestMethod]
public void PersonTest()
{
    // こんなPersonがあるとすると
    var person = new Person { Age = 50, FamilyName = &quot;Yamamoto&quot;, GivenName = &quot;Tasuke&quot; };
    // このアサーションは失敗します
    person.Is(p =&gt; p.Age &lt;= 10 &amp;&amp; p.FamilyName == &quot;Yamada&quot; &amp;&amp; p.GivenName == &quot;Tarou&quot;);
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/chainigassertion_error_lambda.jpg">
</p>
<p>分かりやすいですよね！値は全部のダンプじゃなくて、ラムダ式の中で使われているプロパティ/フィールドのみを出すことにしているので、メッセージ欄が極度に爆発することもないです。今はまだ一階層の値しか出力してないのですが、いずれはもう少し複雑に解析して表示できるようにしたいところ。理想は<a href="http://d.hatena.ne.jp/kyon_mm/20110315/1300193710" title="Groovyのassertがすごく見やすい件について - うさぎ組">GroovyのPowerAssert</a>のようなグラフィカルな表示ですね。Expressionにより、データはあるので、解析をがんばれば作ること自体は可能だ、というのがC#のポテンシャルです。活かすか殺すかは、努力次第。まだ、活かしきれてはいません。</p>
<h2>まとめ</h2>
<p>MSでSilverlight周りのチームにいるJafar Husain氏（Silverlight Toolkitに入ってるという話で最初にRxを世界に紹介した人ですね！）は、<a href="http://themechanicalbride.blogspot.com/2009/06/better-unit-tests-with-testassert-for.html" title="unfold: Better Unit Tests with Test.Assert() for NUnit/VSTT/SUTF">unfold: Better Unit Tests with Test.Assert() for NUnit/VSTT/SUTF</a>という記事で.NETはずっとパワフルなのに、いつまでJUnitスタイルの古いAPIを引きずってるんだ？と問題提起し、Expressionを解析して適切なAssertに差し替えるという、Queryable的な実装を示しました。Chaining Assertionでは、もっと野蛮に、拡張メソッドとラムダ式により、C#らしいスタイルで軽快に記述することを可能にしました。</p>
<p>最近少し刺され気味なので若干弁解しておきますが、別にスタイルは自由ですよ。でも他人に使わせるものは、より良いものであるべきだし、そうして他人が使ったりリファレンスとして参照されるものが、あんまりな出来だったら、そりゃ一言あって然りでしょう。本当に多くの人が参照するものだったら、なおのことです。いやまあ、度を超えた発言は刺されてもしょうがないですが。</p>
<p>NuGetからも入れられるのと、MSTestの他にNUnit, MbUnit, xUnit.NETにも対応しているので、試してもらえると嬉しいです。</p>
</div>
<h1><a href="https://neue.cc/2011/09/17_343.html">Rxにおける並行非同期実行とリソース処理の問題</a></h1>
<ul class="date"><li>2011-09-17</li></ul>
<div class="entry_body"><p>非同期(Asynchronous)だの並列(Parallel)だの並行(Concurerrent)だの、よくわからない単語が並びます。ParallelがやりたければPLINQ使うべし、と思うわけですがそれはさておき、Rxを使うと、意図しても意図しなくても、並行な状態にはなります。そして、その意図していないという状態は危うい線を踏んでいるので、きちんと認識しておく必要があります。また、危ういと同時に、Rxはその並行をうまくコントロールするメソッドが揃っているので、覚えておくと世界が一気に広がります。</p>
<p>例えば、こういう非同期メソッドがあるとして。</p>
<pre><code class="language-csharp">IObservable&lt;T&gt; AsyncModoki&lt;T&gt;(T value, int second)
{
    // second秒後にvalueを返す非同期処理をシミュレート
    return Observable.Return(value)
        .Delay(TimeSpan.FromSeconds(second));
}

static void Main(string[] args)
{
    // 1,2,3,4という入力をすぐに送り込む
    new[] { 1, 2, 3, 4 }
        .ToObservable()
        .SelectMany(x =&gt; AsyncModoki(x, 3))
        .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

    Console.ReadLine();
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="50px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>1~4は、全て同時にリクエストが開始されます。だから、3秒後に同時に結果が表示されます。</p>
<p>同時に実行が開始されているということは、非同期の結果が完了する時間にズレがある場合、結果が前後することがあります。実際、上のものも何度か実行すると毎回結果が変わると思います(Delayは（デフォルトだと）値をThreadPoolに投げて遅延させます。ThreadPoolに入った時点で、順序の保証が消滅する)。というわけで、基本的にSelectManyを使った場合1:1で渡していくわけではなければ、順序は壊れると考えてください。さて、それだと困る場合もあるのではと思いますので、結果の順序を制御する方法が幾つかあります。</p>
<h2>Switch</h2>
<p>Switchは実に有意義なメソッドで、分かると、SelectMany以上に多用することが多くなるのではと思います。</p>
<pre><code class="language-csharp">clickEventObservable // クリック毎に
    .Select(x =&gt; AsyncModoki(x, 1)) // 何らかの非同期処理をするとする
    .Switch() // IObservable&lt;IObservable&lt;T&gt;&gt;の状態なので、Switch
    .Subscribe(Console.WriteLine);
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="50px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=1" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>クリックすると1秒遅延（非同期処理でもしていると考えてください）して、値が表示されます。しかし、1秒以内に次の値がクリックされた場合はキャンセルされ、表示しません。</p>
<p>つまり、最新の値だけを返すことを保証します。それ以前のものはキャンセル(Disposeが呼ばれる)されます。どういう時に使うかというと、例えばインクリメンタルサーチ。L, LI, LIN, LINQと入力が変わる度に非同期リクエストを発生させますが、欲しい結果は最後の一件のみで、次のキー入力があった場合は以前のものはキャンセルして欲しい。キャンセルはともかく、非同期実行だと結果が前後してしまうことだってあります。LINQと入力したのにLIの結果一覧が表示されてしまったら困る。そんな場合に、まさに、うってつけです。そして存外、こういったシチュエーションは多いのではないかと思われます。例えば私の以前作った<a href="http://utakotoha.codeplex.com/">Utakotoha</a>というWP7用歌詞表示アプリケーションも、曲のスキップに応じて最新のものだけを表示するために、Switchを利用しました。（コードが激しく酷いのと機能貧弱っぷりなので、そろそろ書き直したい）</p>
<h2>Merge/Concat</h2>
<p>Switch以外にも色々あります。</p>
<pre><code class="language-csharp">new[] { 1, 2, 3, 4 }
    .ToObservable()
    .SelectMany(x =&gt; AsyncModoki(x, 1)) // 全て並行実行(最初の例です)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1)) // IO&lt;IO&lt;T&gt;&gt;
    .Merge() // こちらも全て並行実行、SelectMany(xs =&gt; xs)と同じ
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1))
    .Merge(2) // 2件ずつ並行実行する(並行実行数の指定が可能)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));


new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki(x, 1))
    .Concat() // 1件ずつ実行する(Merge(1)と同じ)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="200px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/rxasynchronous.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=2" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>ネストはSelectManyで一気に崩してしまうケースが一般的でしょうけれど、IObservable&lt;IObservable&lt;T&gt;&gt;といったネストした状態にすると、選択肢がSwitchもそうですが、更に、MergeとConcatを選択することができます。ちなみに、このintで並行実行数が指定可能なMergeはWP7同梱版のRxには存在しません。残念。(もう一つ余談ですが、SelectManyはRx内部ではSelect(selector).Merge()という実装になっていたりします)</p>
<h2>実行タイミングの問題</h2>
<p>上のSilverlight、Merge2とMerge2Exの二つを用意しましたが、Merge2Exのほうは4つ同時に表示されるのが確認出来るはずです。コードはほぼ同一なのですが、AsyncModokiを似たようで別なものに差し替えました。</p>
<pre><code class="language-csharp">// Merge(2):Ex
new[] { 1, 2, 3, 4 }
    .ToObservable()
    .Select(x =&gt; AsyncModoki2(x, 1)) // これが差分
    .Merge(2)
    .Subscribe(x =&gt; Console.Write(x + &quot;-&gt;&quot;));

// スレッドプール上で非同期実行(結果は指定秒数後に返る)のシミュレート
// second秒後にネットワーク問い合わせが返る、的なものをイメージしてみてください
static IObservable&lt;T&gt; AsyncModoki2&lt;T&gt;(T value, int second)
{
    var subject = new AsyncSubject&lt;T&gt;();

    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        Thread.Sleep(TimeSpan.FromSeconds(second)); // 指定秒数待機
        subject.OnNext(value);
        subject.OnCompleted(); // 完了（2つでワンセット）
    });

    return subject; // これ自体はすぐに返す(FromAsyncPatternの中身はこんな感じ)
}
</code></pre>
<p>このAsyncModoki2は、このメソッドを通ると即座にThreadPoolに送り込んで「実行」しています。Subscribeされるかどうかとは関係なく、Subscribeの「前に」。対してAsyncModokiはSubscribeされないと実行が開始されません。同じようで違う、この二つの状態をRxでは「Hot」と「Cold」と呼んで区別しています。HotはSubscribeとは関係なく動いているもの、イベントなんかはそうですね。ColdはSubscribeされて初めて動き出すもの、Observable.ReturnであったりRangeであったりと、Rxからの生成子の場合は、こちらのパターンが多いです。</p>
<p>実はFromAsyncPatternはHotなので、Subscribeとは関係なく即座に(といっても戻り値はFuncなのでInvokeしたら、ですが)非同期実行が開始されたりします。これは、あまり都合が良くなく（例えば上の例で見たように、MergeはSubscribeのタイミングによって実行数をコントロールしている）、Coldに変換したほうが扱いやすいです。そのためのメソッドがDefer。</p>
<pre><code class="language-csharp">static IObservable&lt;WebResponse&gt; AsyncModoki3&lt;T&gt;(WebRequest req)
{
    return Observable.Defer(()=&gt;
        Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse,req.EndGetResponse)());
}
</code></pre>
<p>こちらのほうが、大抵の利用シーンにはマッチするかと思われます。</p>
<h2>キャンセル時のリソース処理の問題</h2>
<p>Switchは実に有意義なのですが、それの行っていることは、次の値を検知すると前の値をキャンセルする、ということです。普段はあまりキャンセルはしないと思うのですが、Switch内部では大量のキャンセルが発生しています。さて、どのような問題が発生するか、というと、例えば……。</p>
<pre><code class="language-csharp">using System;
using System.Net;
using System.Reactive.Linq;

class Program
{
    static void Main(string[] args)
    {
        // ネットワークの最大接続数。通常、デフォルトは2になっているはず。
        ServicePointManager.DefaultConnectionLimit = 2;

        // テキストボックスのTextChangedイベントをイメージした、インクリメンタルサーチで来る文字列群
        new[] { &quot;w&quot;, &quot;wi&quot;, &quot;wik&quot;, &quot;wiki&quot;, &quot;wikip&quot;, &quot;wikipe&quot;, &quot;wikiped&quot;, &quot;wikipedi&quot;, &quot;wikipedia&quot; }
            .ToObservable()
            .Select((word, id) =&gt;
            {
                // wikipediaのAPIにリクエスト飛ばす
                var url = &quot;http://en.wikipedia.org/w/api.php?action=opensearch&amp;search=&quot; + word + &quot;&amp;format=xml&quot;;
                var req = (HttpWebRequest)WebRequest.Create(url);
                req.UserAgent = &quot;test&quot;;

                return Observable.FromAsyncPattern&lt;WebResponse&gt;((ac, state) =&gt;
                    {
                        Console.WriteLine(&quot;ASYNC START:&quot; + id);
                        return req.BeginGetResponse(ac, state);
                    }, ar =&gt;
                    {
                        Console.WriteLine(&quot;ASYNC END:&quot; + id);
                        return req.EndGetResponse(ar);
                    })()
                    .Select(res =&gt;
                    {
                        using (res) // ここのセクションが呼ばれることはない
                        {
                            Console.WriteLine(&quot;CALLED NEXT:&quot; + id);
                            return &quot;response string:&quot; + id;
                        }
                    });
            })
            .Switch()
            .ForEach(Console.WriteLine); // 終了を待機する形でのSubscribe
    }
}

// ConsoleApplication用のコードですが、是非実行してみてください。結果は以下のようになります。

ASYNC START:0
ASYNC START:1
ASYNC START:2
ASYNC START:3
ASYNC START:4
ASYNC START:5
ASYNC START:6
ASYNC START:7
ASYNC START:8
ASYNC END:0
ASYNC END:1
// そしてフリーズ...
</code></pre>
<p>これは、フリーズします。何故かというと、まず8件の非同期処理が一斉に開始されます(ASYNC STARTの表示)。一斉に開始はされますが、ネットワークの最大接続数は2なので、それ以外のものは内部的には待機されています。そして、Switchによる切り替えは最新のものだけを通すようにするため、7件はキャンセルされます。その後、最初の二件分のネットワークリクエストが終了し(ASYNC ENDの表示)、キャンセルされているためメソッドチェーンの続きであるSelectは呼ばれません。そして、フリーズ。</p>
<p>何故フリーズしてしまうかというと、EndGetResponseで取得した最初の二件のWebResponseが解放されていないためです。キャンセルが呼ばれなければ、Selectを通り、そこでusingにより利用+解放されるのですが、そのセクションを通らなければ何の意味がありません。使われることなく虚空に放り出されたWebResponseが、永遠にネットワーク接続を握ったままになってしまっています。</p>
<p>当然、大問題。</p>
<p>Switchを諦めてSelectMany(全件キャンセルせずに並行実行、どうせネットワーク自体の最大接続数で制限かかっているし)というのも手ではあります。大体の場合は結果は問題ないでしょう。けれど、Switchの利点は何でしたっけ、と。結果が前後しないことです。LINQを検索しようとしていたのに、検索結果が前後したせいでLINQ→LINの順番に結果が得られた結果、表示されるのがLINの結果では困ってしまいます。Switchなら、後に実行したものが必ず最後に来ると保証されるので、そのようなことにはなりません。反面、SelectManyは並行実行のため、前後する可能性が出てきます。Switchはこの例で挙げたような、インクリメンタルサーチのようなものと相性がとても良いんですね。</p>
<h2>ではどうするか？</h2>
<p>WebResponseのDispose(Close)を呼べれば解決するので、FromAsyncPatternのEnd部分に少し細工を加えてやる、ということが考えられます。</p>
<pre><code class="language-csharp">// こんなFromAsyncPatternを用意して
public static IObservable&lt;TResult&gt; SafeFromAsyncPattern&lt;TResult&gt;(Func&lt;AsyncCallback, object, IAsyncResult&gt; begin, Func&lt;IAsyncResult, TResult&gt; end)
    where TResult : IDisposable
{
    // WP7版ではCreateWithDisposableで(この辺の細かな差異が割とウザい)
    return Observable.Create&lt;TResult&gt;(observer =&gt;
    {
        var disposable = new BooleanDisposable();

        Observable.FromAsyncPattern&lt;TResult&gt;(begin, ar =&gt;
        {
            var result = end(ar);
            if (disposable.IsDisposed) result.Dispose(); // キャンセルされてたらDispose
            return result;
        })().Subscribe(observer);

        return disposable; // Disposeが呼ばれるとIsDisposedがtrueになる
    });
}

// こんな風に使うとか
public static IObservable&lt;WebResponse&gt; GetResponseAsObservable(this WebRequest req)
{
    return ObservableEx.SafeFromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse);
}
</code></pre>
<p>これにより、キャンセルされたかどうかをEnd部分で判定することが出来ます。よってEnd時にキャンセルされていたらリソースをDisposeしてしまう(ここでreturnしたオブジェクトは、チェーンは切れているので別に使われることなく虚空を彷徨うだけ)。これにより、FromAsyncPatternがリソースを返し、かつ、いつキャンセルされても問題なくなります。</p>
<p>他にも色々なアプローチが考えられます。CompositeDisposable/MutableDisposable/SingleAssignDisposableなどを使い、Disposeが呼ばれたら同時に管理下のリソースをDisposeしてしまう、といった手法。これは、リソースのDisposeされる瞬間が逆にコントロールしにくくなって、例えばWebResponseですと、その後のStreamを呼んでる最中にWebResponseがDisposeされてしまうなどの自体も起こりうるので、少し厄介に思えました。。リソースを後続に渡すまでは責任を持つ。それ以降はノータッチなので好きにやらせる、利用も解放も後続側が責任を。その方が自然だし、素直な動きになるので、いいかな。</p>
<p>他には、キャンセルを伝搬しないようなメソッドを作り、Disposeが呼ばれてもリソースを受け取れるようにし、後続でリソースをDisposeする、などの手段も考えられます。そうすればSafeFromAsyncPatternなどといった、独自のFromAsyncPatternを作る必要はなく、全てに適用できて汎用性は高いのですが、チェーンでの保証が途切れてしまうのが若干微妙かな、と……。この辺は悩ましいところです。</p>
<p>そもそもWebRequestなら、DisposeでAbortしてしまったほうが、キャンセルらしくていいかもしれない。</p>
<pre><code class="language-csharp">public static IObservable&lt;WebResponse&gt; GetResponseAsObservable(this WebRequest request)
{
    return Observable.Create&lt;WebResponse&gt;(observer =&gt;
    {
        Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse,
            ar =&gt;
            {
                try
                {
                    return request.EndGetResponse(ar); // Abort後の場合は例外発生
                }
                catch (WebException ex)
                {
                    if (ex.Status == WebExceptionStatus.RequestCanceled) return null;
                    throw; // キャンセル時以外は再スロー
                }
            })()
            .Subscribe(observer);
        return () =&gt; request.Abort(); // Dispose時にこのActionが呼ばれる
    });
}
</code></pre>
<p>Disposeが呼ばれるとwebRequest.Abortが呼ばれます。その後にEndGetResponseを呼ぶとRequestCanceledなWebExceptionが発生するので、キャンセルされていたならnullを(どちらにせよ、Dispose済みなので、ここでreturnしたものは次のメソッドチェーンで使われることはない)、そうでない例外ならば再スローを、という方針です。悪くなさそうですが、どうでしょうか。私的にはこれを採用するのがベストかなー、と考え中です。</p>
<h2>まとめ</h2>
<p>SwitchやMergeなどで、従来扱いにくかった並行処理時の非同期のコントロールが簡単になりました。単純に一本の非同期をSelectManyで摩り替えるだけもアリですけれど、せっかくの多機能なのだから、並行にリクエストなどを飛ばして、より速いアプリケーション作りを目指してもいいかもしれません。同期リクエストをTask.Factory.StartNewで包んで振り回すよりかは、ずっと楽です。また、現在行われているMSのイベントBUILDで発表されたWinRTなどは、完全に非同期主体です。C#5.0でasync/awaitが入り、非同期がより扱いやすくなることで、それに併せてModelの有り様も、同期から非同期へと変わっていき、それにあわせてVMなどの書き方も変わってくるのではかと思われます。</p>
<p>ただ、リソースの問題にだけは気をつけて！上で挙げた問題は、本質的にはFromAsyncPatternに限らず、リソース処理が引き離されている場合の全てで該当します。リソースを扱うのは難しい。とはいえ、全面的に問題になるのは、このFromAsyncPatternぐらいな気はします。Observable.Usingなども用意されているので、不用意にリソースをチェーン間で渡したりしなければ原則的には起こらない。けれど、そのFromAsyncPatternこそがリソースを扱うシチュエーションで最も使われるものなんですよね、とほほほ。</p>
<p>キャンセル(Dispose)を不用意に呼ばなければ問題は起こらないといえば起こらないんですが(そのため、不適切に書いてしまっていても、多くのケースで問題が表面化することはないでしょう)、Switchのようなアプローチが取れなくなるのがどうにも。現状だと、とりあえず気をつけましょう、としか言いようがないので、気をつけましょう。もし何かうまい具合に動かないなあ、と思ったら、この辺を疑ってみると良いかもしれません。</p>
<p>その辺難しいなあ、という場合は、近いうちに私の出すRx拡張ライブラリを使いましょう。特に考えなくても済むよう、色々配慮してあります。いつ出るの？というと、はい、最近ゴリゴリと書いてますんで(ブログがちょっと放置気味だった程度には)、必ず近いうちに出します。</p>
</div>
<h1><a href="https://neue.cc/2011/09/10_342.html">Re:FromEvent vs FromEventPattern</a></h1>
<ul class="date"><li>2011-09-10</li></ul>
<div class="entry_body"><p>現在のRxで最大の分かりにくいポイントになっているFromEventとFromEventPattern。以前に<a href="http://neue.cc/2011/07/06_332.html" title="neue cc - Rxでのイベント変換まとめ - FromEvent vs FromEventPattern">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a>として軽くまとめましたが、改めて、詳細に考えてみたいと思います。なお、ここでいうFromEventPatternはWP7版のRxではFromEventを指しています（ここも分かりにくいポイントです）。そして、ここでいうFromEventはWP7版のRxには未搭載です、あらあらかしこ。</p>
<p>ネタ元ですが、<a href="http://techblog.hilife-jp.info/2011/09/silverlight-5-3-doubleclicktrigger-rx.html?spref=tw" title="銀の光と藍い空: Silverlight 5 の新機能その3 番外編 DoubleClickTrigger をRxっぽくしてみた">銀の光と藍い空: Silverlight 5 の新機能その3 番外編 DoubleClickTrigger をRxっぽくしてみた</a>を拝見して、FromEventに関して実行時に例外が出るとのことなので、その部分の説明を書こうかと。最初コメント欄に書いたのですが、少しコメントにトチってしまったので、自分のブログに書かせていただきます、どうもすみません……。</p>
<p>FromEventとFromEventPatternの最大の違いは、FromEventがAction&lt;EventArgs&gt;を対象にしていて、FromEventPatternはAction&lt;object, EventArgs&gt;を対象にしているということです。Action&lt;object, EventArgs&gt;は、つまりEventHandler。ではAction&lt;EventArgs&gt;って何なんだよ、というと、通常は存在しません。というのもeventはデリゲートなら何でもアリということに仕様上はなっていますが、慣例としてobject sender, EventArgs eを引数に持つデリゲートを選択しているはずですから。</p>
<p>さて、デリゲート間には同じ引数の型・同じ戻り値の型を持っていても、型自体に互換性がないので（例えばEventHandlerとEventHandler&lt;T&gt;）、FromEventもFromEventPatternも、引数を3つ持つオーバーロードの第一引数は
conversionという、デリゲートの型を変換するラムダ式を受け入れるようになっています。よって</p>
<pre><code class="language-csharp">Observable.FromEventPattern&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
    h =&gt; h.Invoke,
    h =&gt; AssociatedObject.MouseLeftButtonDown += h,
    h =&gt; AssociatedObject.MouseLeftButtonDown -= h);
</code></pre>
<p>これが、リフレクションなしで変換出来る形式になります。conversionが不要なオーバーロードもあるのですが(+=と-=を書くだけ)、それはリフレクションを使ってデリゲートの変換をしていて今一つ効率が悪いので、わざわざ+=, -=を書いているのだから、もう一手間かけて、 h =&gt; h.Invoke を書いておいたほうがお得です。（もし対象がEventHandler&lt;T&gt;の場合は事情が違ってconversionが不要なので+=と-=だけで済みます、この辺の事情の違いが面倒臭く混乱を招きがちなんですよね…… Rxチームには「便利そうだから」機能を追加する、とかやる前に、もう少し深く考えてくださいと苦情を言いたい）</p>
<p>h =&gt; h.Invoke だけで何故変換出来ているのかを詳しく説明します。これは正しく書くのならば</p>
<pre><code class="language-csharp">(EventHandler&lt;MouseButtonEventArgs&gt; h) =&gt; new MouseButtonEventHandler(h)
</code></pre>
<p>が正解です。(左側の型に関しては省略可能ですが、説明用には型を書いていたほうが分かりやすいので明記しておきます、また、この最初からEventHandler&lt;T&gt;であることが、対象がEventHandler&lt;T&gt;である場合はconversionが不要な理由になっています）。ただし、関数を直接渡すとコンパイラがデリゲートの型を変換してくれるため、h =&gt; h.Invokeを渡した場合は</p>
<pre><code class="language-csharp">h =&gt; new MouseButtonEventHandler(h.Invoke)
</code></pre>
<p>という風に内部的には自動で整形してくれます。そのため、new MouseButtonEventHandlerを書く手間が省けるということになっています。h と h.Invoke はやってることは完全一緒なのですけど、この辺はコンパイラの仕組みの都合に合わせるという感じで。むしろ仕組みの隙間をついたやり方といいましょうか。</p>
<p>では、FromEventなのですが、まず正しく変換出来る形を見ると</p>
<pre><code class="language-csharp">Observable.FromEvent&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
    h =&gt; (sender, e) =&gt; h(e),
    h =&gt; AssociatedObject.MouseLeftButtonDown += h,
    h =&gt; AssociatedObject.MouseLeftButtonDown -= h);
</code></pre>
<p>です。もし第一引数を省いた場合はAction&lt;EventArgs&gt;を探してリフレクションをかけるようになっていて、そして、通常はそんなイベントを使うことはないので、十中八九例外が出るのではかと思われます（だからこういう混乱を招くだけのオーバーロードを入れるなとRxチームには苦情を言いたい）。</p>
<p>型まで明記すれば</p>
<pre><code class="language-csharp">Action&lt;MouseButtonEventArgs&gt; h =&gt; (object sender, MouseEventArgs e) =&gt; h(e)
</code></pre>
<p>となっているわけで、senderを捨ててMouseEventArgsだけを引数に渡す独自のconversionを渡しています。これですが、FromEventPatternであっても</p>
<pre><code class="language-csharp">h =&gt; (sender, e) =&gt; h(sender, e)
</code></pre>
<p>とも書けるので(つまるところ h.Invoke って何かといえば (sender, e) =&gt; h(sender,e) なのです)、それのsender抜きバージョンを渡しているということになります。</p>
<p>わかりづらい？例えば</p>
<pre><code class="language-csharp">.Subscribe(Console.WriteLine)
.Subscribe(x =&gt; Console.WriteLine(x))
</code></pre>
<p>この二つはやってること一緒なんですよ、ということですね。ラムダ式が入れ子になるとワケガワカラナイ度が加速されるので、私は関数型言語erにはなれないな、と思ったり思わなかったり。</p>
<h2>まとめ</h2>
<p>ただたんに使うにあたっては、こんなことは知ってる必要はなくh =&gt; h.Invoke と h =&gt; (sender, e) =&gt; h(e) を定型句だと思って暗記してもらうだけで十分です。はい。本来は、こういう部分はちゃんと隠蔽されてたほうがいいんですけれど、まあ、C#の限界としてはそうはいかないというとこですね(F#だとイベントがもう少し扱いやすいんですが)。</p>
<p>また、FromEventにせよFromEventPatternにせよFromAsyncPatternにせよ、実際に使うコードに直接書いてくにはノイズが多すぎるので、<a href="http://neue.cc/2011/07/06_332.html" title="neue cc - Rxでのイベント変換まとめ - FromEvent vs FromEventPattern">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a>で書いたように、拡張メソッドに隔離するのを私はお薦めしています。そうこうして裏側で地道に努力することでF#とC#の壁を縮める！とかなんとかかんとか。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
