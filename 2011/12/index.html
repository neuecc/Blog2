<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2011-12</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2011/12/30_361.html">2011年を振り返る</a></h1>
<ul class="date"><li>2011-12-30</li></ul>
<div class="entry_body"><p>一年、ありがとうございました。何とか生き延びれました。ブログも冬眠せず続けられましたし、よきかなよきかな。</p>
<p>今年は色々ありました。やはり一番大きかったのは<a href="http://neue.cc/2011/04/02_313.html">Microsoft MVP for Visual C#</a>の受賞ですね。と、いっても、今まで通りブログを書いてライブラリを書いて、というわけで、別に今までと何が変わったわけでもありません。ただ、肩書きとして威力があったりなかったり、というのはあります。あと、出す情報に関してはある程度は責任というか、適当すぎることは書けないかな、という意識は持ちました。</p>
<p>良くも悪くもといえば、やはりラベルが貼られると、ラベルに沿って動いてしまうというのが人の性かもしれません。少しC#贔屓が強くなりすぎたかもねー、とか。ちょっと反省。それと、他の言語を全然学べなかったなあ、というのもよくなかった。今年はちょっと色々なことに追われすぎたというかRx-WP7-Async-Roslynと、C#だけでいっぱいいっぱいだったのです……。結局Roslynはあまり追えてないし。</p>
<p>@ITでの連載 <a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a> がスタートしたり、C#ユーザー会で<a href="http://www.slideshare.net/neuecc/code-contracts-8069150">基礎からのCode Contracts</a>、すまべんで<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>、Silverlight Squareで<a href="http://www.slideshare.net/neuecc/reactiveproperty-slintokyo4">ReactiveProperty - slintokyo4</a>といった、幾つかの勉強会で発表させて頂いたりなど、結構動き出した年でもありました。</p>
<h2>ゲーム</h2>
<p>死ぬほどプレイ、しなかった……。積みゲーどころか買ったけど封すら開けなかったり。こんな私は想像できなかったなあ。しかも別に時間がないわけじゃなくてさあ、だらだらとネット見てTwitter見てるだけなんですよ。ただ無駄に時間を捨てているだけで。楽しみだったはずのSkyrimにすら手を出していない。ふぅー、来年はちゃんとメリハリつけて付き合いたいものです。ねえ、だらだらネット見てるだけって、だらだらTV見てるだけと何も違わないぢゃあないか。</p>
<h2>C#</h2>
<p>ライブラリも色々作りました。その時の関心ごとに応じて、徹底的に調べて、不満をライブラリ作って解消する、というのが基本的なスタイルでした。ユニットテストの書き方が気に入らないから<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>を作り、DBへの生クエリ周りが気に入らないから<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>を作り、INotifyPropertyChangedが気に入らないから<a href="http://reactiveproperty.codeplex.com/">ReactiveProperty</a>を作った。関心ごとが見つかったら、深くダイブして、新しいやり方を見つけ出す。なんていうとご立派ですが、本当に新しいこと、なんてないのですよね。既存の断片は幾らでも見つかる。だから、それらもまた徹底的に調査して、そして、自分の気にいるように融和させていく。</p>
<p>ずっと<a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>をlowerCamelCaseに変更する！と思ってたのですが未だにできてはいなくて。よくないですね。ちょうど今日、新しい<a href="http://nuget.org/packages/RxJS-All">Reactive Extensions for JavaScript</a>が出ました。詳しくは年明け早々に紹介したいと思いますが、これはちゃんとlowerCamelCaseになってます。いつまでも遅れていちゃマズい。</p>
<h2>来年</h2>
<p>ここで言うことか？という話ではありますが、12月で会社を退職し(て)ました。1月からは新しい会社で働くことになります。次の会社でもC#をメインにやっていきます（ということで雇われるわけでもありますので）。しっかり成果を出していきたいし、事例やコードなんかも、出せるならガシガシ出したいと思っています。その辺のことは追々。</p>
<p>来年は、MVP絡みで米MS本社でのMVP Global Summitもあり、新しい会社で働く（初めての転職です）ことにもなるしで、私としてもかなり転機な年になるのではという予感がしています。不安もありますが、同時に楽しみでもあります。<a href="http://neue.cc/2010/12/31_294.html">2010年を振り返る</a>で、来年には更なる成長のために動き出したい、などと言っていましたが、一応はしっかりとスタートを踏み出せたようです。</p>
<p>そんな感じですが、来年もよろしくお願いします。</p>
</div>
<h1><a href="https://neue.cc/2011/12/21_360.html">RxとパフォーマンスとユニットテストとMoles再び</a></h1>
<ul class="date"><li>2011-12-21</li></ul>
<div class="entry_body"><p><a href="http://atnd.org/events/21988">C# Advent Calendar 2011</a>、順調に進んでいますね。どのエントリも力作で大変素晴らしいです。私はこないだ<a href="http://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a>というものを書きました。はてブ数は現段階で45、うーん、あまり振るわない……。私の力不足はともかくとしても、他の言語だったらもっと伸びてるだろうに、と思うと、日本のC#の現状はそんなものかなあ、はぁ、という感じではあります。はてブが全てではない（むしろ斜陽？）とはいえ、Twitterでの言及数などを見ても、やっぱまだまだまだまだまだまだ厳しいかなあ、といったところ。Unityなどもあって、見ている限りだと人口自体は着実に増えている感じではありますけれど、もっともっと、関心持ってくれる人が増えるといいな。私も微力ながら尽力したいところです。</p>
<p>ところで、<a href="http://d.hatena.ne.jp/ZOETROPE/">id:ZOETROPE</a>さんのAdvent Calendarの記事、<a href="http://d.hatena.ne.jp/ZOETROPE/20111220#1324392149">Reactive Extensionsでセンサプログラミング</a>が大変素晴らしい！センサー、というと私だとWindows Phone 7から引っ張ってくるぐらいしか浮かばないのですが（最近だとKinectもHotですか、私は全然触れてませんが……）おお、USB接続のレンジセンサ！完全に門外漢な私としては、そういうのもあるのか！といったぐらいなわけですが、こうしてコード見させていただくと、実践的に使うRxといった感じでとてもいいです。</p>
<p>記事中で扱われているトピックも幅広いわけですが、まず、パフォーマンスに関しては少し補足を。@okazukiさんの<a href="http://d.hatena.ne.jp/okazuki/20111214/1323828027">見せてもらおうじゃないかReactive Extensionsの性能とやらを！ その２</a>のコメント欄でもちょっと言及したのですが、この測り方の場合、Observable.Rangeに引っ張られているので、ベンチマークの値はちょっと不正確かな、と思います。</p>
<pre><code class="language-csharp">// 1000回イベントが発火(発火の度に長さ3000のbyte配列が得られる)を模写
static IObservable&lt;byte[]&gt; DummyEventsRaised()
{
    return Observable.Repeat(new byte[3000], 1000, Scheduler.Immediate);
}

// 配列をバラす処理にObservable.Rangeを用いた場合
static IObservable&lt;byte&gt; TestObservableRange()
{
    return Observable.Create&lt;byte&gt;(observer =&gt;
    {
        return DummyEventsRaised()
            .Subscribe(xs =&gt;
            {
                Observable.Range(0, xs.Length, Scheduler.Immediate).ForEach(x =&gt; observer.OnNext(xs[x]));
            });
    });
}

// 配列をバラす処理にEnumerable.Rangeを用いた場合(ForEachはIxのもの)
static IObservable&lt;byte&gt; TestEnumerableRange()
{
    return Observable.Create&lt;byte&gt;(observer =&gt;
    {
        return DummyEventsRaised()
            .Subscribe(xs =&gt;
            {
                Enumerable.Range(0, xs.Length).ForEach(x =&gt; observer.OnNext(xs[x]));
            });
    });
}

// SelectManyでバラす場合
static IObservable&lt;byte&gt; TestSelectMany()
{
    return DummyEventsRaised().SelectMany(xs =&gt; xs);
}

static void Main(string[] args)
{
    // ベンチマーク補助関数
    Action&lt;Action, string&gt; bench = (action, label) =&gt;
    {
        var sw = Stopwatch.StartNew();
        action();
        Console.WriteLine(&quot;{0,-12}{1}&quot;, label, sw.Elapsed);
    };

    // 配列をばらすケースは再度連結する(ToList)
    bench(() =&gt; TestObservableRange().ToList().Subscribe(), &quot;Ob.Range&quot;);
    bench(() =&gt; TestEnumerableRange().ToList().Subscribe(), &quot;En.Range&quot;);
    bench(() =&gt; TestSelectMany().ToList().Subscribe(), &quot;SelectMany&quot;);
    // 配列をばらして連結せず直接処理する場合
    bench(() =&gt; TestSelectMany().Subscribe(), &quot;DirectRx&quot;);
    // byte[]をばらさず直接処理する場合
    bench(() =&gt; DummyEventsRaised().Subscribe(xs =&gt; { foreach (var x in xs);}), &quot;DirectLoop&quot;);

    // 実行結果
    // Ob.Range    00:00:02.2619670
    // En.Range    00:00:00.2600460
    // SelectMany  00:00:00.2701137
    // DirectRx    00:00:00.0852836
    // DirectLoop  00:00:00.0152816
}
</code></pre>
<p>得られる配列をダイレクトに処理するとして、Observable.Rangeで配列のループを回すと論外なほど遅い。のですが、しかし、この場合ですとEnumerable.Rangeで十分なわけで、そうすれば速度は全然変わってきます（もっと言えば、ここではEnumerable.Rangeではなくforeachを使えば更に若干速くなります）。更に、これは配列を平坦化している処理とみなすことができるので、observerを直に触らず、SelectManyを使うこともできますね。そうすれば速度はほとんど変わらず、コードはよりすっきり仕上がります。</p>
<p>と、いうわけで、遅さの原因はObservable.Rangeです。Rangeが遅いということはRepeatやGenerateなども同様に遅いです。遅い理由は、値の一つ一つをISchedulerを通して流しているから。スケジューラ経由であることは大きな柔軟性をもたらしていますが、直にforeachするよりもずっとずっと遅くなる。なので、Enumerableで処理出来る局面ならば、Enumerableを使わなければなりません。これは、使うほうがいい、とかではなくて、圧倒的な速度差となるので、絶対に、Enumerableのほうを使いましょう。</p>
<p>また、一旦配列をバラして、再度連結というのは、無駄極まりなく、大きな速度差にも現れてきます。もし再度連結しないでそのまま利用(ベンチ結果：DirectRx)すれば直接ループを回す(ベンチ結果：DirectLoop)よりも5倍程度の遅さで済んでいます。このぐらいなら許容範囲と言えないでしょうか？とはいえ、それでも、遅さには違いないわけで、避けれるのならば避けたほうがよいでしょう。</p>
<p>ZOETROPEさんの記事にあるように、ここはばらさないほうが良い、というのが結論かなあ、と思います。正しくは上流ではばらさない。一旦バラしたものは復元不可能です。LINQで、パイプラインで処理を接続することが可能という性質を活かすのならば、なるべく後続で自由の効く形で流してあげたほうがいい。アプリケーション側でバラす必要があるなら、それこそSelectMany一発でばらせるのだから。</p>
<p>例えばWebRequestで配列状態のXMLを取ってくるとします。要素は20個あるとしましょう。最初の文字列状態だけを送られてもあまり意味はないので、XElement.Parseして、実際のクラスへのマッピングまではやります。例えばここではPersonにマッピングするとして、長さ1のIObservable&lt;Person[]&gt;です。しかし、それをSelectManyして長さ20のIObservable&lt;Person&gt;にはしないほうがいい。ここでバラしてしまうと長さという情報は消滅してしまうし、一回のリクエスト単位ではなくなるのも不都合が生じやすい。もしアプリケーション的にフラットになっていたほうが都合が良いのなら、それはまたそれで別のメソッドとして切り分けましょう。</p>
<h2>成功と失敗の一本化</h2>
<p>ZOETROPEさんの記事の素晴らしいのは、通常のルート(DataReceived)と失敗のルート(ErrorReceived)を混ぜあわせているところ！これもまたイベントの合成の一つの形なわけなんですねー。こういう事例はWebClientのDownloadStringAsyncのような、EAP(Eventbased Asynchronous Programming)をTaskCompletionSourceでラップしてTaskに変換する <a href="http://msdn.microsoft.com/ja-jp/library/ee622454.aspx">方法: タスクに EAP パターンをラップする</a>←なんかゴチャゴチャしていますが、TrySetCanceled, TrySetException, TrySetResultで結果を包んでいます、というのと似た話だと見なせます。</p>
<p>WebClientではEventArgsがCancelledやErrorといったステータスを持っているのでずっと単純ですが、SerialPortではエラーは別のイベントでやってくるのですね。というわけで、私もラップしてみました。</p>
<pre><code class="language-csharp">public static class SerialPortExtensions
{
    // 面倒くさいけれど単純なFromEventでのイベントのRx化
    public static IObservable&lt;SerialDataReceivedEventArgs&gt; DataReceivedAsObservable(this SerialPort serialPort)
    {
        return Observable.FromEvent&lt;SerialDataReceivedEventHandler, SerialDataReceivedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; serialPort.DataReceived += h, h =&gt; serialPort.DataReceived -= h);
    }

    public static IObservable&lt;SerialErrorReceivedEventArgs&gt; ErrorReceivedAsObservable(this SerialPort serialPort)
    {
        return Observable.FromEvent&lt;SerialErrorReceivedEventHandler, SerialErrorReceivedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; serialPort.ErrorReceived += h, h =&gt; serialPort.ErrorReceived -= h);
    }

    // DataReceived(プラスbyte[]化)とErrorReceivedを合成する
    public static IObservable&lt;byte[]&gt; ObserveReceiveBytes(this SerialPort serialPort)
    {
        var received = serialPort.DataReceivedAsObservable()
            .TakeWhile(e =&gt; e.EventType != SerialData.Eof) // これでOnCompletedを出す
            .Select(e =&gt;
            {
                var buf = new byte[serialPort.BytesToRead];
                serialPort.Read(buf, 0, buf.Length);
                return buf;
            });

        var error = serialPort.ErrorReceivedAsObservable()
            .Take(1) // 届いたらすぐに例外だすので長さ1として扱う（どうせthrowするなら関係ないけど一応）
            .Do(x =&gt; { throw new Exception(x.EventType.ToString()); });

        return received.TakeUntil(error); // receivedが完了した時に同時にerrorをデタッチする必要があるのでMergeではダメ
    }
}
</code></pre>
<p>成功例と失敗例を合成して一本のストリーム化。また、DataReceivedはそのままじゃデータすっからかんなので、Selectでbyte[]に変換してあげています。これで、ObserveReceiveBytes拡張メソッドを呼び出すだけで、かなり扱いやすい形になっている、と言えるでしょう。パフォーマンスも、これなら全く問題ありません。</p>
<h2>MolesとRx</h2>
<p>と、ドヤ顔しながら書いていたのですが、とーぜんセンサーの実物なんて持ってませんので動作確認しようにもできないし。ま、まあ、そういう時はモックとか用意して、ってSerialDataReceivedEventArgsはパブリックなコンストラクタないし、ああもうどうすればー。と、そこで出てくるのが<a href="http://research.microsoft.com/en-us/projects/moles/">Moles - Isolation framework</a>。以前に<a href="http://neue.cc/2011/03/10_309.html">Rx + MolesによるC#での次世代非同期モックテスト考察</a>という記事で紹介したのですが、めちゃくちゃ強力なモックライブラリです。パブリックなコンストラクタがないとか関係なくダミーのインスタンスを生成可能だし、センサーのイベントだから作り出せないし、なんてこともなく自由にダミーのイベントを発行しまくれます。</p>
<pre><code class="language-csharp">[TestClass]
public class SerialPortExtensionsTest : ReactiveTest
{
    [TestMethod, HostType(&quot;Moles&quot;)]
    public void ObserveReceiveBytesOnCompleted()
    {
        // EventArgsを捏造！
        var chars = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Chars };
        var eof = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Eof };
        // SerialPort::BytesToRead/SerialPort::Readで何もしない
        MSerialPort.AllInstances.BytesToReadGet = (self) =&gt; 0;
        MSerialPort.AllInstances.ReadByteArrayInt32Int32 = (self, buffer, offset, count) =&gt; 0;

        var scheduler = new TestScheduler();

        // 時間10, 20, 30, 40でSerialData.Charsのイベントを、時間50でEofのイベントを発行
        MSerialPortExtensions.DataReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
                OnNext(10, chars),
                OnNext(20, chars),
                OnNext(30, chars),
                OnNext(40, chars),
                OnNext(50, eof))
            .Select(x =&gt; (SerialDataReceivedEventArgs)x);

        // 走らせる(戻り値のbyte[]はどうでもいいので無視するためUnitに変換)
        var result = scheduler.Start(() =&gt; new SerialPort().ObserveReceiveBytes().Select(_ =&gt; Unit.Default), 0, 0, 100);

        result.Messages.Is(
            OnNext(10, Unit.Default),
            OnNext(20, Unit.Default),
            OnNext(30, Unit.Default),
            OnNext(40, Unit.Default),
            OnCompleted&lt;Unit&gt;(50));
    }

    [TestMethod, HostType(&quot;Moles&quot;)]
    public void ObserveReceiveBytesOnError()
    {
        // EventArgsを捏造！
        var chars = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Chars };
        var eof = new MSerialDataReceivedEventArgs() { EventTypeGet = () =&gt; SerialData.Eof };
        // SerialPort::BytesToRead/SerialPort::Readで何もしない
        MSerialPort.AllInstances.BytesToReadGet = (self) =&gt; 0;
        MSerialPort.AllInstances.ReadByteArrayInt32Int32 = (self, buffer, offset, count) =&gt; 0;

        var scheduler = new TestScheduler();

        // 時間10, 20, 30, 40でSerialData.Charsのイベントを、時間50でEofのイベントを発行
        MSerialPortExtensions.DataReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
                OnNext(10, chars),
                OnNext(20, chars),
                OnNext(30, chars),
                OnNext(40, chars),
                OnNext(50, eof))
            .Select(x =&gt; (SerialDataReceivedEventArgs)x);

        /* ↑までOnCompletedのものと共通 */

        // 時間35でErrorのイベントを発行
        MSerialPortExtensions.ErrorReceivedAsObservableSerialPort = _ =&gt; scheduler.CreateHotObservable(
            OnNext&lt;SerialErrorReceivedEventArgs&gt;(35, new MSerialErrorReceivedEventArgs()));

        // 走らせる(戻り値のbyte[]はどうでもいいので無視するためUnitに変換)
        var result = scheduler.Start(() =&gt; new SerialPort().ObserveReceiveBytes().Select(_ =&gt; Unit.Default), 0, 0, 100);

        // Exceptionの等値比較ができないので、バラしてAssertする
        result.Messages.Count.Is(4);

        result.Messages[0].Is(OnNext(10, Unit.Default));
        result.Messages[1].Is(OnNext(20, Unit.Default));
        result.Messages[2].Is(OnNext(30, Unit.Default));

        result.Messages[3].Value.Kind.Is(NotificationKind.OnError);
        result.Messages[3].Time.Is(35);
    }
}
</code></pre>
<p>アサーションに使っているIsメソッドは、いつも通り<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>です。</p>
<p>Molesがいくら強力だとは言っても、イベントをそのまま乗っ取るのはデリゲートの差し替えなどで、割と面倒だったりします。しかし、FromEventでラップしただけのIObservable&lt;T&gt;を用意しておくと…… それを差し替えるだけで済むので超簡単になります。イベント発行については、TestScheduler(Rx-Testingを参照しておく)で、仮想時間で発行する値を作ってしまうと楽です。こういう、任意の時間で任意の値、というダミーの用意もFromEventでラップしただけのIObservable&lt;T&gt;があると、非常に簡単になります。</p>
<p>あとは、scheduler.Startで走らせると(3つの引数はそれぞれcreated, subscribed, disposedの仮想時間、何も指定しないと…… 実は0始まり「ではない」ことに注意。100,200,1000がデフォなので、0はすっ飛ばされています)、その戻り値で結果を受け取って、Messagesに記録されているので、それにたいしてアサートメソッドをしかける。</p>
<p>実に簡単ですね！Molesの力とRxの力が組み合わさると、イベントのテストが恐ろしく簡単になります。素敵じゃないでしょうか？</p>
<h2>まとめ</h2>
<p>テストなしで書いてたコードは、Molesでテスト走らせたら間違ってました。TakeWhileの条件が==だったのと、Mergeで結合していたり……。はっはっは、ちゃんとユニットテストは書かないとダメですね！そして、Molesのお陰でちゃんと動作するコードが書けたので恥を欠かなくてすみました、やったね。</p>
</div>
<h1><a href="https://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a></h1>
<ul class="date"><li>2011-12-16</li></ul>
<div class="entry_body"><p><a href="http://atnd.org/events/21988">C# Advent Calendar 2011</a>、ということで、C# 4.0時代のプログラミングスタイルについて説明してみます。モダン、というけれど、某書のように変態的なことじゃなくて、むしろ基本的な話のほうです。こういったものはナマモノなので、5.0になればまた変わる、6.0になればまた変わる。変わります。古い話を間に受けすぎないこと(歴史を知るのは大事だけど、そのまま信じるのは別の話)、常に知識をリフレッシュするようにすること。そういうのが大事よね。でも、だからってモダンに書けなきゃダメ！なんてことはありません。ただ、知ること、少しずつ変えていくこと、そういうのは大事よね、って。</p>
<p>ところでしかし、私の主観がかなり入っているので、その辺は差っ引いてください。</p>
<ol>
<li>varを使う</li>
</ol>
<hr />
<p>C# 3.0から搭載された型推論での宣言。出た当初には散々議論があって、今もたまに否の意見が出てきたりもしますが、varは使いましょう。積極的に。何にでも。国内的にも世界的にもMicrosoft的にも、var積極利用の方向で傾いているように見えます。また、最近流行りの関数型言語(Haskell, Scala, F#)は、少なくともC#のvarで可能な範囲は全て推論を使いますね←C#のvarはそれらに比べれば遥かに貧弱ですからね。そういったこともあるので、使わない理由もないでしょう。</p>
<pre><code class="language-csharp">var person = new Person();
var dict = new Dictionary&lt;string, Tuple&lt;int, Person&gt;&gt;();
var query = Enumerable.Range(1, 10).Select(x =&gt; x * 10);
</code></pre>
<p>varの利点は、何といっても書いていて楽なことです。はい、圧倒的に楽です。そして、型宣言の長さが一致するので「実は見やすい」というのもポイント高し。たった3文字の短さと相まって、ソースコードが綺麗になります。また、必ず変数の初期化を伴う、というのも良いことです。</p>
<p>欠点は「メソッドの戻り値などは宣言を見ても型が分からない」「インターフェイスで宣言できない」の二つが代表的でしょうか。前者は、Visual Studioを使えばマウスオーバーで型が表示されるので、コーディング上では支障はない。メールやBlogやWikiなど、Visual Studioのサポートのない完全にコードのみの状態だとサッパリなのは確かに難点ではありますが、逆にその程度の部分的な範囲なら、括り出されている目的が明確なわけなので、適切な変数名がついているのなら、正確な型名とまではいかずとも何に使うもののか大体分かるのではないでしょうか？なので、大きな問題だとは私は思いません。もし変数名がテキトーで型名ぐらいしかヒントが得られないんだよ！ということならば、varよりも前にまともな変数名をつけるようにしたほうがいいです。</p>
<p>インターフェイスで宣言できないことは、私は何の問題もないと思っています。具象型やメソッドの返す型でそのまま受けることに何の不都合が？むしろインターフェイスで宣言すると、アップキャスト可能という怪しい状態を作り出しているだけです。</p>
<p>ちなみにintやstring、配列などの基本的なものぐらいは型を書くという流儀もなくはないようですが、それは意味無いのでやめたほうがいいでしょう。</p>
<pre><code class="language-csharp">var num = 100;
var text = &quot;hogehoge&quot;;
var array = new[] { 1, 2, 3, 4, 5 };
</code></pre>
<p>だって、こういうのこそ、見れば一発で分かるほど自明なので。</p>
<ol start="2">
<li>オプション引数を使う(使いすぎない)</li>
</ol>
<hr />
<p>害悪もあるわけですが、割と積極的に使ってもいいような気がします。実際Roslyn CTPなどでは結構派手に使われていますし、オーバーロード地獄よりはIntelliSense的にも分かりやすいかな、って。思います。enumなど使うと、明確に何が使われるか見えるんですね、これはとても嬉しくて。やっぱC#としてはIntelliSenseで分かりやすい、というのはとても大事かと。</p>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/csadvent_1.jpg">
</p>
<p>さて、分かりやすく使いすぎに注意な点としては、引数なしコンストラクタが消滅してしまう可能性があげられます。引数なしコンストラクタがないと、色々なところで弊害が起こります。</p>
<pre><code class="language-csharp">// こんなオプション引数なコンストラクタしかないクラスがあるとして
public class ToaruClass
{
    public ToaruClass(int defaultValue = -1)
    {

    }
}

class Program
{
    static T New&lt;T&gt;() where T : new()
    {
        return new T();
    }

    static void Main(string[] args)
    {
        // 使うときは引数なしでnewできるけど
        var _ = new ToaruClass();

        // 実態は違うので、ジェネリックのnew制約が不可能になる
        New&lt;ToaruClass&gt;(); // コンパイル通らない

        // 引数なしコンストラクタを要求するシリアライザの利用も不可能に
        new XmlSerializer(typeof(ToaruClass)).Serialize();
    }
}
</code></pre>
<p>シリアライズできなかったりジェネリックのnew制約がきかなくなってしまったり。ご利用は計画的に。シリアライズに関しては、DataContractSerializerならばコンストラクタを無視するので使えはしますが……。その辺の話は<a href="http://neue.cc/2011/12/10_357.html">neue cc - .NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a>で。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/roslyn">Roslyn CTP</a>のAPIはオプション引数が激しく使われているのですが、中でもこれは面白いと思いました。<a href="http://www.mindscapehq.com/blog/index.php/2011/10/20/in-bed-with-roslyn/">Mindscape Blog » Blog Archive » In bed with Roslyn</a>から引用します。</p>
<pre><code class="language-csharp">PropertyDeclarationSyntax newProperty = Syntax.PropertyDeclaration(
    modifiers: Syntax.TokenList(Syntax.Token(SyntaxKind.PublicKeyword)),
    type: node.Type,
    identifier: node.Identifier,
    accessorList: Syntax.AccessorList(
        accessors: Syntax.List(
            Syntax.AccessorDeclaration(
                kind: SyntaxKind.GetAccessorDeclaration,
                bodyOpt: Syntax.Block(
                    statements: Syntax.List(
                        getter
                    )
                )
            ),
            Syntax.AccessorDeclaration(
                kind: SyntaxKind.SetAccessorDeclaration,
                bodyOpt: Syntax.Block(
                    statements: Syntax.List(
                        setter
                    )
                )
            )
        )
    )
);
</code></pre>
<p>そう、名前付き引数でツリー作ってるんですね。<a href="http://msdn.microsoft.com/ja-jp/library/bb387019.aspx">LINQ to XMLの関数型構築</a>も面白いやり方だと思いましたが、この名前付き引数を使った構築も、かなり素敵です。流行るかも！</p>
<ol start="3">
<li>ジェネリックを使う</li>
</ol>
<hr />
<p>もしお持ちの本がArrayListやHashTableを使っているコードが例示されていたら、窓から投げ捨てましょう。Silverlightでは廃止されていますし、WinRT(Windows 8)でも、勿論そんな産廃はありません。もはやどこにもそんなものを使う理由はありません。どうしても何でも入れられるListが欲しければ、List&lt;object&gt;を使えばいいぢゃない。</p>
<ol start="4">
<li>ジェネリックデリゲート(Func, Action)を使う</li>
</ol>
<hr />
<p>これも賛否両論ではあるのですが、私は断然ジェネリックデリゲート派です。ちなみにその反対は野良デリゲート量産派でしょうか（悪意のある言い方！）。ジェネリックデリゲートを使うと良い点は、デリゲートの型違い（同じ引数・戻り値のデリゲートでも型が違うとキャストが必要）に悩まされなくてすむ、定義しなくていいので楽、そして、なにより分かりやすい。例えば、「MatchEvaluator」というだけじゃ、何なのかさっぱり分かりません。正規表現のReplaceで使われるデリゲートなのですけどね。Func&lt;Match, string&gt;のほうが、ずっと分かりやすい。</p>
<p>では良くない点は、というと、引数に変数名で意味をつけられない。例えばLINQのSelectメソッドのFunc&lt;TSource, int, TResult&gt;。このintはインデックスですが、そのことはドキュメントコメントからしか分かりません。その点、野良デリゲートを作れば</p>
<pre><code class="language-csharp">public delegate TR ConverterWithIndex&lt;T, TR&gt;(T value, int index);
</code></pre>
<p>という形で、明示できます。なんて素晴らしい？そう？実のところそんなでもなくて、これ、IntelliSenseからじゃあ分からないんですよね。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/csadvent_2.jpg">
</p>
<p>F12なりなんなりで型定義まで飛ばないと見えないのです、デリゲートの変数名は。その点Func&lt;Match, string&gt;なら引数の型、戻り値の型がIntelliSenseで見えるわけでして。C#的にはIntelliSenseで見えないと価値は9割減です。というわけで、天秤にかければ、圧倒的にFuncの大勝利。引数ずらずらでイミフになるならドキュメントコメントに書くことで補う、でもいいぢゃない。</p>
<p>ちなみにoutやrefのジェネリックデリゲートは存在しないので、その場合のみ自作デリゲートを立てる必要があります。それ以外、つまるところ99%ぐらいはFunc, Action, EventHandler&lt;T&gt;でいいと思います。LINQだってPredicateじゃなくてFunc&lt;T, bool&gt;だしね。</p>
<ol start="5">
<li>ラムダ式を使う</li>
</ol>
<hr />
<p>ラムダ式(C# 3.0)を使わなければ何を使うのって話ですが、ラムダ式の登場により割を食った匿名メソッド(C# 2.0)は産廃です。唯一の利点は、匿名メソッドは引数を使わない場合は省略して書けます。</p>
<pre><code class="language-csharp">// 引数省略して書けるぞ！
button.Click += delegate { MessageBox.Show(&quot;hoge&quot;); };
// ラムダ式の場合は省略できないんだ(棒)
button.Click += (_, __) =&gt; MessageBox.Show(&quot;hoge&quot;);
</code></pre>
<p>こんなことは実にどうでもいいので、匿名メソッドを使うのはやめましょう。もしラムダ式が先にあれば、匿名メソッドはなかったと思います。ジェネリックが最初からあれば非ジェネリックコレクションクラスがなかっただろう、ということな程度には。あとジェネリックが先にあれば野良デリゲートもなかった気がする。なので、多少どうでもいい利点があったとしても、素直に使わないのが一番。</p>
<p>ところでラムダ式の引数の名前ですが、どうしていますか？私は、昔は型名から取っていました、例えばintだったらi、stringだったらs。でも最近は全てxにしています。理由は、面倒くさいし適切な名前が出てこない場合もあるし修正漏れが起こったりする（ハンガリアンみたいなもんですしねえ）などなどで、メリットを感じなかったので。</p>
<p>ちなみに、ラムダ式で長い名前を使うのは反対です。「名前はしっかりつけなきゃダメ！」が原則論のはずなのにxってなんだよそれって感じですが、逆に、小さい範囲のものは小さいほうがいいのです。名前をつけないことで、他の名前のついているものを強調します。なんでもかんでも名前をつけていると五月蝿くて、木を森に隠す、のようになってしまいます。LINQやRxでラムダ式だらけになると、なおそうです。勿論、ラムダ式だからって全てxにするわけではありません。中でネストしてネスト内でも使われたり、式ではなく文になってスコープが長くなっている場合などは、ちゃんと名前をつけます。また、（分かりやすさのため）強く意味を持たせたい場合も名前をつけます。型名以上の意味を持たせられないのなら、あえて名前をつける必要性を感じないのでxです。</p>
<p>そういうわけで、多少崩すこともありますが、原則的に私の命名規則は「ただの変数 = x, 配列などコレクション = xs, 引数を使わない = アンダースコア」としています。xのかわりにアンダースコアを使う流儀もあるようですが、私は嫌いですね……。Scalaのアンダースコアとは意味が違う感じもあるし、同じ.NETファミリーならばF#が引数を使わないという意味でアンダースコアを使っているので、それに合わせたほうがいいと思っています。xだと座標のxと被る、という場合は座標のxにつける変数名をpointXだかpxだかに変えます。</p>
<p>Exceptionはexにしたり、イベントの場合は(sender, e)にしたりはしますけれど、このへんは慣習ですし、わざわざ崩すほうが変かな。あとLINQでのGroupingはgを使ったりしますね。</p>
<ol start="6">
<li>LINQを使う（主にメソッド構文を使う、クエリ構文もたまには使う）</li>
</ol>
<hr />
<p>LINQはデータベースのためだけじゃなく、むしろ通常のコレクションへの適用(LINQ to Objects)のほうが多い。そんなにコレクション操作することなんてない、わけがない、はず。</p>
<pre><code class="language-csharp">// 配列の中のYから始まるものの名前(スペースできった最後のもの)を取り出す
new[] { &quot;Yamada Tarou&quot;, &quot;Yamamoto Jirou&quot;, &quot;Suzuki Saburou&quot; }
    .Where(x =&gt; x.StartsWith(&quot;Y&quot;))
    .Select(x =&gt; x.Split(' ').Last());
</code></pre>
<p>上の例のような、Where（フィルタリング）+ Select（射影）は特に良く使うパターンです。Pythonなどでもリスト内包表記としてパッケージされるぐらいには。やはり、この手の処理を持っていないと、重苦しい。しかし、C# 3.0はLINQを手にしたので、お陰で軽快に飛び回れるようになりました。しかもただのフィルタ＋射影だけではなく、ありとあらゆる汎用コレクション処理を、チェーンで組み合わせることで、無限のパターンを手にしました。</p>
<p>LINQにはメソッド構文とクエリ構文があり、どちらも同じですがメソッド構文のほうが機能豊富だし、分かりやすいです。なのでメソッド構文でメソッドチェーンﾊｧﾊｧしましょう。<a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a>で同様の記法でJavaScriptでも使えますし！</p>
<p>じゃあクエリ構文に利点はないのかというと当然そんなことはなく、多重from(SelectManyに変換される)が多く出現する場合はクエリ構文のほうがいいですね。また、Joinなどもクエリ構文のほうが書きやすいし、GroupJoinと合わせた左外部結合を記述したりなど複雑化する場合はクエリ構文じゃないと手に負えません（書けなくはないんですけどねえ）</p>
<p>それと、LINQ to SQLなどExpression Treeをそれぞれの独自プロパイダが解釈するタイプのものは、メソッド構文の豊富な記述可能性が逆に、プロパイダの解釈不能外に飛び出しがちなので、適度に制約の効いたクエリ構文だけで書いたほうがスムーズにいく可能性があります。</p>
<p>また、XMLはC#ではXmlReader/Writer, XmlDocument(DOM), XDocument(LINQ to XML)がありますが、そのうちDOMのXmlDocumentは産廃です。DOMって使いづらいのよね、それにSilverlightにはないし。メモリ内にツリーを持つタイプではXDocument(XElement)でLINQでﾊｧﾊｧするのが主流です。ちなみにXmlReader/Writerはストリーミング型なので別枠、ただ、生で使うことはあまりないと思います。特にWriterは、<a href="http://msdn.microsoft.com/ja-jp/library/system.xml.linq.xstreamingelement.aspx">XStreamingElement</a>を使えば省メモリなストリーミングで、Writeできる、しかもずっと簡単に。なので、使うことはないかと思います。</p>
<ol start="7">
<li>Taskを使う(生スレッドを使わない)</li>
</ol>
<hr />
<p>マルチスレッドプログラミングしなきゃ！Threadを使おう？デリゲートのBeginInvokeがある？それともThreadPool？BackgroundWorkerもあるぞ！古い記事はこれらの使用方法が解説されてきました。そうです、今まではそれらしかなかったので。けれど、全部ゴミ箱に投げ捨てましょう。.NET 4.0からは基本的原則的にTaskを使うべきです。豊富な待ち合わせ処理・継続・例外処理・キャンセルなどをサポートしつつ、同じスレッドを使いまわそうとするなど実行効率も配慮されています。もはや生スレッドを使う理由はないし、デリゲートのBeginInvokeなどともさよなら。BackgroundWorkerは、もう少しは出番あるかも(UIへの通知周りが今のTaskだけだと少し面倒、RxやC# 5.0のAsyncなら簡単にこなせるのですが)。</p>
<p>CPUを使う処理を並列に実行をしたいのなら、PLINQやParallel.ForEachなどが手軽かつ超強力です。</p>
<p>また、C# 5.0からはTaskの言語サポートが入り、awaitキーワードによりコード上では待機したように見せかけ同期的のように書けつつ中身は非同期で動く、といったことが可能になります。</p>
<pre><code class="language-csharp">async Task&lt;string&gt; GetBingHtml()
{
    var wc = new WebClient();
    var html = await wc.DownloadStringTaskAsync(new Uri(&quot;http://bing.com/&quot;));
    return html;
}
</code></pre>
<p>awaitするだけで同期的のように非同期が書けるなんて魔法のよう！</p>
<p>また、非同期といっても二つあります。CPUを沢山使って重たい処理と、I/O待ち（ネットワークやファイルアクセス）が重たい処理。これらへの対処は、別です。I/O待ちにスレッドを立てて対処することも可能ではありますが、あまり褒められた話ではありません。と、C#たんが<a href="http://csharptan.wordpress.com/2011/12/10/%e9%9d%9e%e5%90%8c%e6%9c%9fio%e5%be%85%e3%81%a1/">非同期I/O待ち</a>で言ってました。非同期I/Oは優れているのは分かったとしても、記述が面倒なのがネックだったのですね。しかし、C# 5.0からならばawaitが入るのでかなりサクッと書ける。非同期だって、node.jsにばかりは負けてられない！</p>
<p>なお、現在SilverlightやWindows Phone 7にはTaskがない(Silverlight 5にはTask入りました)ですが、将来的には間違いなく入るので、期待して待ちましょう。そして、分かりやすく書けるC# 5.0もwktkして待ちましょう。待ちきればければ<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360">Async CTP</a>として公開されているので、試すことが可能です。</p>
<ol start="8">
<li>Rxを使う</li>
</ol>
<hr />
<p>C# 5.0はCTPだし、現実問題として非同期に困ってるんだよ！という場合は、変化球としてReactive Extensionsが使えます。詳しくは<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a>で連載しているので読んでね！第二回がいつまでたっても始まらないのは何故なのでしょう、はい、私が原稿を送っていないからです、ごめんなさい……。これ書いてないで原稿書けやｺﾞﾙｧという感じですはい。いえ、もうすぐもう少しなので、ちょっと待ってください。</p>
<p>RxはTaskとは全く別の次元からやってきつつ、機能的にはある程度代替可能です。C# 5.0が来た時に共存できるのか、というと、非同期面ではTaskに譲るでしょう。けれど、非同期の生成をTaskで行なって、コントロールをawaitも使いつつRxでメインに使うとかも可能です。基本的に、コントロール周りはawaitサポートを除けばRxのほうが強力で柔軟です(代償として効率を若干犠牲にしているけれど)。ただまあ、基本的には非同期処理はTaskに絞られていくだろうと考えています。少し寂しいけど、全体としてより美しく書けるなら全然いいです、むしろ大歓迎なので早くC#5.0来ないかなあ。</p>
<p>ちなみに、Rxは別に非同期のためだけじゃなくて、イベントと、そしてあらゆるソースを合成するという点も見逃せないわけなので、決してAsync来たからRxさようなら、ではないです。その辺のことも連載であうあう。</p>
<ol start="9">
<li>Expressionを使う(そしてEmitしない)</li>
</ol>
<hr />
<p>Expressionの簡単な基本ですが、Expressionとして宣言します。Funcとほとんど同じで、違うのは型宣言だけです。</p>
<pre><code class="language-csharp">// 同じラムダ式だけれど
Expression&lt;Func&lt;int, int&gt;&gt; expr = x =&gt; x * x;
Func&lt;int, int&gt; func = x =&gt; x * x;

// Expressionで宣言すると実態は以下のものになる(コンパイラが自動生成する)
var paramX = Expression.Parameter(typeof(int), &quot;x&quot;);
var expr = Expression.Lambda&lt;Func&lt;int, int&gt;&gt;(
    Expression.Multiply(paramX, paramX),
    new[] { paramX });
</code></pre>
<p>Expressionで宣言するとコンパイラがコンパイル時に式木生成コードに変換してくれるのですね。自分で宣言しなくても、メソッドの引数の型がExpressionならば同じです。例えばQueryable.SelectのselectorはExpression型の引数なので、Queryableで連鎖を書いているということは同様に↑のようなコードが吐かれています。</p>
<p>Expressionの仕事は色々ありますが、概ね二つ。式がデータとして取り出せること。簡単な所ではINotifyPropertyChangedの実装なので話題沸騰したりしなかったりした、文字列ではなくプロパティを渡して、そこから引数名を取り出すことができること。</p>
<pre><code class="language-csharp">public class MyClass
{
    public string MyProperty { get; set; }
}

// これ
public static string GetPropertyName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; propertyExpression)
{
    return (propertyExpression.Body as MemberExpression).Member.Name;
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var propName = GetPropertyName(() =&gt; mc.MyProperty);
}
</code></pre>
<p>こんな形で推し進めたのが、LINQ to SQLなど、式木の塊を解釈してSQLに変換するといった、QueryProviderですね。</p>
<p>そしてもう一つはILビルダー。式木はCompileすることでFuncに変換することが可能です。</p>
<pre><code class="language-csharp">// (object target, object value) =&gt; ((T)target).memberName = (U)value
static Action&lt;object, object&gt; CreateSetDelegate(Type type, string memberName)
{
    var target = Expression.Parameter(typeof(object), &quot;target&quot;);
    var value = Expression.Parameter(typeof(object), &quot;value&quot;);
 
    var left =
        Expression.PropertyOrField(
            Expression.Convert(target, type), memberName);
 
    var right = Expression.Convert(value, left.Type);
 
    var lambda = Expression.Lambda&lt;Action&lt;object, object&gt;&gt;(
        Expression.Assign(left, right),
        target, value);
 
    return lambda.Compile();
}
 
// Test
static void Main(string[] args)
{
    var target = new MyClass { MyProperty = 200 };
    var accessor = CreateSetDelegate(typeof(MyClass), &quot;MyProperty&quot;);
 
    accessor(target, 1000); // set
    Console.WriteLine(target.MyProperty); // 1000
}
</code></pre>
<p>少なくとも、自前でILを書くよりは圧倒的に簡単に、動的コード生成を可能にしました。動的コード生成はCompileは重いものの、一度生成したデリゲートをキャッシュすることで二度目以降は超高速になります。単純なリフレクションよりはずっと速く。といったようなことを<a href="http://neue.cc/2011/04/20_317.html">neue cc - Expression Treeのこね方・入門編 - 動的にデリゲートを生成してリフレクションを高速化</a>で書いたので読んでね！</p>
<ol start="10">
<li>dynamicを使わない（部分的に使う）</li>
</ol>
<hr />
<p>一時期、LLブームで動的言語が持て囃されましたが、今は（静的型付けの）関数型言語ブームで、静的型付けへ寄り戻しが来ています。なので、C#もdynamicあって動的だよねひゃっほーい、なんてことはなく、むしろvarで型推論です(ｷﾘｯ のほうが正しくて。そんなわけで、dynamicはあまり使いません。ですが、使うとより素敵な場所も幾つかあります。それは、本質的に動的なところに対して。動的なのってどこ？というと、アプリケーションの管理範囲外。</p>
<p>例えばJSONはスキーマレス。DBも、自動生成しなければアプリケーションの外側で見えない。.NETはDLRがあるのでIronPythonなどスクリプト言語との連携などもそう。<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を例にだすと、スキーマレスなJSONに対して、そのまま、JSONをJavaScriptで扱うのと同じように使えます。</p>
<pre><code class="language-csharp">var json = DynamicJson.Parse(@&quot;{&quot;&quot;foo&quot;&quot;:&quot;&quot;json&quot;&quot;, &quot;&quot;bar&quot;&quot;:100, &quot;&quot;nest&quot;&quot;:{ &quot;&quot;foobar&quot;&quot;:true } }&quot;);

var r1 = json.foo; // &quot;json&quot; - dynamic(string)
var r2 = json.bar; // 100 - dynamic(double)
var r3 = json.nest.foobar; // true - dynamic(bool)
</code></pre>
<p>また、動的な存在であるDBへのIDataRecordも、<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>を例に出すと</p>
<pre><code class="language-csharp">var products = DbExecutor.ExecuteReaderDynamic(new SqlConnection(connStr), @&quot;
        select ProductName, QuantityPerUnit from Products
        where SupplierID = @SupplierID and UnitPrice &gt; @UnitPrice
        &quot;, new { SupplierID = 1, UnitPrice = 10 })
    .Select(d =&gt; new Product
    {
        ProductName = d.ProductName,
        QuantityPerUnit = d.QuantityPerUnit
    })
    .ToArray();
</code></pre>
<p>ドットで自然に参照可能なことと、また、dynamicが自動でキャストしてくれるので明示的なキャストが不要なため、取り回しの面倒な手動DBアクセスが随分と簡単になります。（が、DBのアクセス結果を決まったクラスにマッピングするのなら、9で紹介している動的コード生成でアクセサを作ったほうが更に楽々になるのでそこまで出番はないかも。DbExecutorは両方を搭載しているので、必要に応じて選ぶことが可能です）</p>
<ol start="11">
<li>自動プロパティを使う</li>
</ol>
<hr />
<p>自動プロパティ vs パブリックフィールド。同じです。はい、同じです。じゃあパブリックフィールドでいいぢゃん？という話が度々ありますが、いえ、そんなことはありません。プロパティにするとカプセル化が云々、変更した場合に云々、などは割とどうでもいいのですが、重要な違いはちゃんとあります。</p>
<p>WPFとかASP.NETとかのバインディングがプロパティ大前提だったりしてパブリックフィールドだと動かないことがある。</p>
<p>なので、黙って自動プロパティにしておきましょう。それに関連してですが、リフレクションでの扱い易さがプロパティとフィールドでは全然違って、プロパティだと断然楽だったりします。そういう面でサードパーティのライブラリでも、プロパティだけをサポート、なものも割とあるのではかと思います。具体例はあげられませんが私は自分で作るちょろっとリフレクションもにょもにょ系の小粒なライブラリは面倒なのでプロパティだけサポート、にすることが結構あります。</p>
<p>あと自動プロパティの定義はコードスニペットを使って一行でやりましょう。prop-&gt;Tab-&gt;Tabです。</p>
<pre><code class="language-csharp">public int MyProperty { get; set; }
</code></pre>
<p>get, setで改行して5行使ったりするのはコードの可読性が落ちるので、好きじゃありません。コードスニペットで一行のものが生成されるわけなので、それに従うという意味でも、一行で書くのがベストと思います。</p>
<h2>まとめ</h2>
<p>C#は言語がちゃんと進化を続けてきた。進化って無用な複雑化！ではなくて、基本的には今までよくなかった、やりづらいことを改善するために進化するんですよね。だから、素直にその良さを甘受したい。そしてまた、進化するということは、歴史の都合上で廃棄物が出てきてしまうというのもまた隣合わせ。C#は巧妙に、多量の廃棄物が出現するのを避けてきていると思います。ヘジたんの手腕が光ります。しかし、やはりどうしても幾つかの廃棄物に関しては致し方ないところです。それに関しては、ノウハウとして、自分で避けるしかなくて。</p>
<p>この手の話だったら、.NETのクラスライブラリ設計が良いです。もしお持ちでなければ、今すぐ買いましょう！いますぐ！超おすすめです。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4891006765" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>また、この手の本だったらEffective C# 4.0もかしら。第一版は（翻訳が出たのが既にC# 4.0の頃で1.0の内容）古くてう～ん、といった感だったのですが、第二版(C# 4.0対応)はかなり良かったです。More Effective C#のほうはLINQ前夜といった感じの内容で若干微妙なのですが、LINQ的な考えが必要な理由を抑える、という点では悪くないかもしれません。また、決定版的な内容を求めるならば、読み通す必要はなく気になるところつまみ読みで良いので、プログラミング.NET Frameworkがお薦めです。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4798122513" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4822294161" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>これらに加えて、自分のやりたいことの対象フレームワークの本(ASP.NET/ASP.NET MVC/Win Forms/WPF/WCF/Silverlight/Windows Phone 7/Unity)を一冊用意すれば、導入としては準備万端で素敵ではないかしらん。まあ、今時フレームワークとかの先端の部分だと、フレームワークの進化の速度が速すぎて本だと情報の鮮度が落ちる(特に日本だと)ので、基本は本でサッと抑えて、深い部分はネットの記事を見たほうが良いのではかと思います。ソースコードが公開されていたりフレームワークの制作陣や第一人者が情報出していたりしますしね。本こそが情報の基本にして全て、という時代でもないのだなぁ、と。学習の仕方というのも、時代で変わっていくものだと思います。</p>
</div>
<h1><a href="https://neue.cc/2011/12/13_358.html">Voidインスタンスの作り方、或いはシリアライザとコンストラクタについて</a></h1>
<ul class="date"><li>2011-12-13</li></ul>
<div class="entry_body"><p>voidといったら、特別扱いされる構造体です。default(void)なんてない。インスタンスは絶対作れない。作れない。本当に？</p>
<pre><code class="language-csharp">var v = System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof(void));

Console.WriteLine(v); // System.Void
</code></pre>
<p>作れました。というわけで、GetUninitializedObjectはその名前のとおり、コンストラクタをスルーしてオブジェクトを生成します。そのため、voidですら生成できてしまうわけです、恐ろしい。こないだ<a href="http://neue.cc/2011/12/10_357.html">.NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a>という記事でシリアライザ特集をして少し触れましたが、DataContractSerializerで激しく使われています。よって、シリアライズ対象のクラスがコンストラクタ内で激しく色々なところで作用しているようならば、それが呼び出されることはないので注意が必要です。</p>
<p>ただし、DataContractSerializerを使ったからって、必ずしも呼ばれるわけではないです。DataContract属性がついていなければ普通にコンストラクタを呼ぶ。DataContract属性がついていれば、引数のないコンストラクタがあったとしても、コンストラクタを無視する。という挙動になっているようです。ちょっと紛らわしいので、以下のコードは（参照設定があれば）そのままペーストして動くので、是非試してみてください。</p>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Text;
using System.Xml.Serialization;

public class EmptyClass
{
    public EmptyClass()
    {
        Console.WriteLine(&quot;BANG!&quot;);
    }
}

[DataContract]
public class ContractEmptyClass
{
    public ContractEmptyClass()
    {
        Console.WriteLine(&quot;BANG!BANG!&quot;);
    }
}

[DataContract]
public class NoEmptyConstructorClass
{
    public NoEmptyConstructorClass(int dummy)
    {
        Console.WriteLine(&quot;BANG!BANG!BANG!&quot;);
    }
}

class Program
{
    static void Main(string[] args)
    {
        // 普通にnewするとBANG!
        Console.WriteLine(&quot;New:&quot;);
        var e1 = new EmptyClass();

        // Activator.CreateInstanceでnewするのもBANG!
        Console.WriteLine(&quot;Activator.CreateInstance:&quot;);
        var e2 = Activator.CreateInstance&lt;EmptyClass&gt;();

        // ExpressionTreeでCompileしてもBANG!
        Console.WriteLine(&quot;Expression.New&quot;);
        var e3 = Expression.Lambda&lt;Func&lt;EmptyClass&gt;&gt;(Expression.New(typeof(EmptyClass))).Compile().Invoke();

        // 何も起こらない（コンストラクタを無視するのでね）
        Console.WriteLine(&quot;GetUninitializedObject:&quot;);
        var e4 = System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof(EmptyClass));

        // XmlSerializerでのデシリアライズはBANG!
        Console.WriteLine(&quot;XmlSerializer:&quot;);
        var e5 = new XmlSerializer(typeof(EmptyClass)).Deserialize(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;EmptyClass /&gt;&quot;)));

        // DataContractSerializerでもBANGって起こるよ！
        Console.WriteLine(&quot;DataContractSerializer:&quot;);
        var e6 = new DataContractSerializer(typeof(EmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;EmptyClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // DataContractJsonSerializerでも起こるんだ！
        Console.WriteLine(&quot;DataContractJsonSerializer:&quot;);
        var e7 = new DataContractJsonSerializer(typeof(EmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));

        // DataContract属性をつけたクラスだと何も起こらない
        Console.WriteLine(&quot;DataContract + DataContractSerializer:&quot;);
        var e8 = new DataContractSerializer(typeof(ContractEmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;ContractEmptyClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // DataContract属性をつけたクラスだとJsonSerializerのほうも当然何も起こらない
        Console.WriteLine(&quot;DataContract + DataContractJsonSerializer:&quot;);
        var e9 = new DataContractJsonSerializer(typeof(ContractEmptyClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));

        // 空コンストラクタのないもの+DataContractSerializerだと何も起こらない
        Console.WriteLine(&quot;NoEmptyConstructor + DataContractSerializer:&quot;);
        var e10 = new DataContractSerializer(typeof(NoEmptyConstructorClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;&lt;NoEmptyConstructorClass xmlns=\&quot;http://schemas.datacontract.org/2004/07/\&quot; /&gt;&quot;)));

        // 空コンストラクタのないもの+DataContractJsonSerializerでも何も起こらない
        Console.WriteLine(&quot;NoEmptyConstructor + DataContractJsonSerializer:&quot;);
        var e11 = new DataContractJsonSerializer(typeof(NoEmptyConstructorClass)).ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(&quot;{}&quot;)));
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/constuctorvoid.jpg">
</p>
<p>.NET 4でもSilverlightでも共通です。この挙動は妥当だと思います。DataContract属性を付けた時点で、そのクラスはシリアライズに関して特別な意識を持つ必要がある。コンストラクタ内でシリアライズで復元できない副作用のある処理をすべきではない。逆に、何も付いていない場合は特に意識しなくても大丈夫。</p>
</div>
<h1><a href="https://neue.cc/2011/12/10_357.html">.NETの標準シリアライザ(XML/JSON)の使い分けまとめ</a></h1>
<ul class="date"><li>2011-12-10</li></ul>
<div class="entry_body"><p>今年もAdvent Calendarの季節がやってきましたね。去年は私はC#とJavaScriptで書きましたが、今年はC#とSilverlightでやります。というわけで、この記事は<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>用のエントリです。前日は<a href="https://twitter.com/#!/Posaune">@posaune</a>さんの<a href="http://d.hatena.ne.jp/posaunehm/20111209/1323443047">SilverlightのListBoxでつくるいんちきHorizontalTextBlock </a>でした。</p>
<p>今回の記事中のサンプルはSilverlight 4で書いています。が、Silverlight用という体裁を持つためにDebug.WriteLineで書いているというだけで、Silverlightらしさは皆無です！えー。.NET 4でもWindows Phone 7でも関係なく通じる話ですねん。</p>
<h2>シリアライザを使う場面</h2>
<p>概ね3つではないでしょうか。外部で公開されているデータ(APIをネット経由で叩くとか)をクラスに変換する。これは 自分の管理外→プログラム での片方向です。内部で持っているデータ(クラスのインスタンス)を保存用・復元用に相互変換する。これは プログラム←→自分の管理内 での双方向です。最後に、内部で持っているデータを公開用に変換する。これは プログラム→外部 での片方向。</p>
<p>目的に応じてベストな選択は変わってきます。こっから延々と長ったらしいので、まず先に結論のほうを。</p>
<ul>
<li>外部APIを叩く→XML/XmlSerializer, JSON/DataContractJsonSerializer</li>
<li>オブジェクトの保存・復元用→DataContractSerializer</li>
<li>外部公開→さあ？</li>
</ul>
<p>外部公開のは、Silverlightの話じゃないので今回はスルーだ！<a href="http://msdn.microsoft.com/ja-jp/library/system.xml.linq.xstreamingelement.aspx">XStreamingElement</a>で組み上げてもいいし、何でもいいよ！WCFのテンプレにでも従えばいいんぢゃないでしょーか。</p>
<h2>XmlSerializer</h2>
<p>古くからあるので、シリアライザといったらこれ！という印象な方も多いのではないでしょうか。その名の通り、素直にXMLの相互変換をしてくれます。</p>
<pre><code class="language-csharp">// こんなクラスがあるとして
// (以降、断り書きなくPersonが出てきたらこいつを使ってると思ってください)
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
<pre><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new XmlSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.Deserialize(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre><code class="language-xml">// 出力結果のXML
﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
  &lt;Age&gt;99&lt;/Age&gt;
&lt;/Person&gt;
</code></pre>
<p>素直な使い勝手、素直な出力。いいですね。さて、しかし特に外部APIを叩いて手に入るXMLは名前PascalCaseじゃねーよ、とか属性の場合どうすんだよ、という場合も多いでしょう。細かい制御にはXmlAttributeを使います。</p>
<pre><code class="language-csharp">[XmlRoot(&quot;people&quot;)]
public class People
{
    [XmlElement(&quot;count&quot;)]
    public int Count { get; set; }
    [XmlArray(&quot;persons&quot;)]
    [XmlArrayItem(&quot;person&quot;)]
    public Person[] Persons { get; set; }
}

[XmlRoot(&quot;person&quot;)]
public class Person
{
    [XmlElement(&quot;name&quot;)]
    public string Name { get; set; }
    [XmlAttribute(&quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre><code class="language-csharp">// データ準備
var data = new People
{
    Count = 2,
    Persons = new[]
{
    new Person { Name = &quot;山本山&quot;, Age = 99 },
    new Person { Name = &quot;トマト&quot;, Age = 19 }
}
};
var xml = @&quot;
    &lt;people&gt;
        &lt;count&gt;2&lt;/count&gt;
        &lt;persons&gt;
            &lt;person age=&quot;&quot;14&quot;&quot;&gt;
                &lt;name&gt;ほむ&lt;/name&gt;
            &lt;/person&gt;
            &lt;person age=&quot;&quot;999&quot;&quot;&gt;
                &lt;name&gt;いか&lt;/name&gt;
            &lt;/person&gt;
        &lt;/persons&gt;
    &lt;/people&gt;&quot;;

var serializer = new XmlSerializer(typeof(People));

// シリアライズ
using (var ms = new MemoryStream())
{
    serializer.Serialize(ms, data);
    Debug.WriteLine(Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length));
}

// デシリアライズ
using (var sr = new StringReader(xml))
{
    var value = (People)serializer.Deserialize(sr);
    foreach (var item in value.Persons)
    {
        Debug.WriteLine(item.Name + &quot;:&quot; + item.Age);
    }
}

// 出力結果のXMLは↑に書いたXMLと同じようなものなので割愛
</code></pre>
<p>ちょっと属性制御が面倒ですが、それなりに分かりやすく書けます。他によく使うのは無視して欲しいプロパティを指定するXmlIgnoreかしら。さて、そんな便利なXmlSerializerですが、XML化するクラスに制限があります。有名所ではDictionaryがシリアライズできねえええええ！とか。小細工して回避することは一応可能ですが、そんな無理するぐらいなら使うのやめたほうがいいでしょう、シリアライザは別にXmlSerializerだけじゃないのだから。</p>
<p>というわけで、XmlSerializerの利用シーンのお薦めは、ネットワークから外部APIを叩いて手に入るXMLをクラスにマッピングするところです。柔軟な属性制御により、マッピングできないケースは(多分)ないでしょう。いや、分かりませんが。まあ、ほとんどのケースでは大丈夫でしょう！しかし、LINQ to XMLの登場により、手書きで変換するのも十分お手軽なってしまったので、こうして分かりにくい属性制御するぐらいならXElement使うよ、というケースのほうが多いかもしれません。結局、XML構造をそのまま映すことしかできないので、より細かく変換できたほうが良い場合もずっとあって。</p>
<p>実際、私はもう長いことXmlSerializer使ってない感じ。LINQ to XMLは偉大。</p>
<h2>DataContractSerializer</h2>
<p>割と新顔ですが、もう十分古株と言ってよいでしょう(どっちだよ)。XmlSerializerと同じくオブジェクトをXMLに変換するのですが、その機能はずっと強力です。Dictionaryだってなんだってシリアライズできますよ、というわけで、現在では.NETの標準シリアライザはこいつです。</p>
<pre><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<pre><code class="language-xml">&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;&lt;Age&gt;99&lt;/Age&gt;&lt;Name&gt;山本山&lt;/Name&gt;&lt;/Person&gt;
</code></pre>
<p>とまあ、使い勝手はXmlSerializerと似たようなものです。おお、出力されるXMLは整形されていません。整形して出力したい場合は</p>
<pre><code class="language-csharp">// 出力を整形したい場合はXmlWriter/XmlWriterSettingsを挟む
using (var ms = new MemoryStream())
using (var xw = XmlWriter.Create(ms, new XmlWriterSettings { Indent = true }))
{
    serializer.WriteObject(xw, data);

    xw.Flush();
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml);
}
</code></pre>
<pre><code class="language-xml">﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&gt;
  &lt;Age&gt;99&lt;/Age&gt;
  &lt;Name&gt;山本山&lt;/Name&gt;
&lt;/Person&gt;
</code></pre>
<p>さて、結果をXmlSerializerと見比べてみるとどうでしょう。名前空間が違います。SilverlightApplication34ってありますね。これは、私がこのXMLを出力するのに使ったSilverlightプロジェクトの名前空間です。ワシのConsoleApplicationは221まであるぞ（整理しろ）。さて、ではこのXMLをデシリアライズするのに、別のアプリケーション・別のクラスで使ってみるとどうでしょう？</p>
<pre><code class="language-csharp">namespace TestSilverlightApp
{
    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }

    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();

            var xml = @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
            &lt;Person xmlns:i=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot; xmlns=&quot;&quot;http://schemas.datacontract.org/2004/07/SilverlightApplication34&quot;&quot;&gt;
                &lt;Age&gt;99&lt;/Age&gt;
                &lt;Name&gt;山本山&lt;/Name&gt;
            &lt;/Person&gt;&quot;;

            var serializer = new DataContractSerializer(typeof(Person));
            using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
            {
                // System.Runtime.Serialization.SerializationExceptionが起こってデシリアライズできない
                // 名前空間 'http://schemas.datacontract.org/2004/07/TestSilverlightApp' の要素 'Person' が必要です。
                // 名前が 'Person' で名前空間が 'http://schemas.datacontract.org/2004/07/SilverlightApplication34' の 'Element' が検出されました。
                var value = (Person)serializer.ReadObject(ms);
            }
        }
    }
}
</code></pre>
<p>デシリアライズ出来ません。対象オブジェクトが名前空間によって厳密に区別されるからです。じゃあどうするのよ！というと、属性で名前空間を空、という指示を与えます。</p>
<pre><code class="language-csharp">// DataContract属性をクラスにつけた場合は
// そのクラス内のDataMember属性をつけていないプロパティは無視される
[DataContract(Namespace = &quot;&quot;, Name = &quot;person&quot;)]
public class Person
{
    [DataMember(Name = &quot;name&quot;)]
    public string Name { get; set; }
    [DataMember(Name = &quot;age&quot;)]
    public int Age { get; set; }
}
</code></pre>
<pre><code class="language-csharp">// こんなプレーンなXMLも読み込める
var xml = @&quot;
    &lt;person&gt;
        &lt;age&gt;99&lt;/age&gt;
        &lt;name&gt;山本山&lt;/name&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age);
}
</code></pre>
<p>属性面倒くせー、ですけれど、まあしょうがない。そうすれば外部からのXMLも読み込めるし、と思っていた時もありました。以下のようなケースではどうなるでしょうか？Personクラスは↑のものを使うとして。</p>
<pre><code class="language-csharp">// こんなさっきと少しだけ違うXMLがあるとして
var xml = @&quot;
    &lt;person&gt;
        &lt;name&gt;山本山&lt;/name&gt;
        &lt;age&gt;99&lt;/age&gt;
    &lt;/person&gt;&quot;;

var serializer = new DataContractSerializer(typeof(Person));
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
{
    var value = (Person)serializer.ReadObject(ms);
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 結果は？？？
}
</code></pre>
<p>これは出力結果は「山本山:0」になります。Ageが0、つまり復元されませんでした。なぜかというと、XMLを見てください。nameが先で、ageが、後。DataContractSerializerは規程された順序に強く従います。DataMember属性のOrderプロパティで順序を与えるか、与えない場合はアルファベット順(つまりAgeが先でNameが後)となります。この辺は<a href="http://msdn.microsoft.com/ja-jp/library/ms729813.aspx">データ メンバーの順序</a>に書かれています。</p>
<p>と、いうような事情から、DataContractSerializerを外部XMLからの受け取りに使うのはお薦めしません。XmlSerializerなら順序無視なので大丈夫です。いや、普通は順序が変わったりなどしないだろう！と思わなくもなくもないけれど、意外とデタラメなのじゃないか、基本的にはお外からのデータが何もかも信用できるわけなどないのだ、とうがってしまい(TwitterのAPIとか胡散臭さいのを日常的に触っていると！)、厳しいかなって、思ってしまうのです。</p>
<p>しかし、オブジェクトの保存・復元用にはDataContractSerializerは無類の強さを発揮します。例えば設定用のクラスを丸ごとシリアライズ・デシリアライズとかね。iniにして、じゃなくてフツーはXMLにすると思いますが、それです、それ。Dictionaryだってシリアライズできるし、引数なしコントラクタがないクラスだってシリアライズできちゃうんですよ？</p>
<pre><code class="language-csharp">// とある引数なしコンストラクタがないクラス
[DataContract]
public class ToaruClass
{
    [DataMember]
    public string Name { get; set; }

    public ToaruClass(string name)
    {
        Name = name;
    }
}
</code></pre>
<pre><code class="language-csharp">var toaru = new ToaruClass(&quot;たこやき&quot;);

var serializer = new DataContractSerializer(typeof(ToaruClass));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, toaru); // シリアライズできるし

    ms.Position = 0;
    var value = (ToaruClass)serializer.ReadObject(ms); // デシリアライズできる

    Debug.WriteLine(value.Name); // たこやき
}
</code></pre>
<p>ただし、対象クラスにDataContract属性をつけてあげる必要はあります。つけてないとシリアライズもデシリアライズもできません。</p>
<p>ちなみに何でコンストラクタがないのにインスタンス化出来るんだよ！というと、<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.formatterservices.getuninitializedobject.aspx">System.Runtime.Serialization.FormatterServices.GetUninitializedObject</a>を使ってインスタンス化しているからです（Silverlightの場合はアクセス不可能）。こいつはコンストラクタをスルーしてオブジェクトを生成する反則スレスレな存在です、というか反則です。チートであるがゆえに、対象クラスにはDataContract属性をつける必要があります。コンストラクタ無視してもいいよ、ということを保証してあげないとおっかない、というわけです。(GetUninitializedObjectメソッド自体は別に属性は不要で何でもインスタンス化できます、typeof(void)ですらインスタンス化できます、無茶苦茶である)</p>
<p>なお、このGetUninitializedObjectが使われるのはDataContract属性がついているクラスのみです。DataContract属性がついていなければ、普通のコンストラクタが呼ばれるし、逆にDataContract属性がついていると、例え引数をうけないコンストラクタがあったとしても、GetUninitializedObject経由となりコンストラクタは無視されます。DataContract属性を付ける時はコンストラクタ内でシリアライズで復元できない副作用のある処理をすべきではない。ということに注意してください。</p>
<p>また、.NET 4版ではprivateプロパティの値も復元できるのですが、Silverlightの場合は無理のようです。ということでフル.NETなら不変オブジェクトでもサクサク大勝利、と思ってたのですが、Silverlightでの不変オブジェクトのシリアライズ・デシリアライズは不可能のようです。保存したいなら、保存専用の代理のオブジェクトを立ててやるしかない感じでしょうかね。</p>
<p>そんなわけで微妙な点も若干残りはしますが、オブジェクトを保存するのにはDataContractSerializerがお薦めです。</p>
<h2>DataContractとSerializable</h2>
<p>シリアライズ可能なクラス、の意味でDataContract属性をつけているわけですが、じゃあSerializable属性は？というと、えーと、SerializableはSilverlightでは入っていなかったりするとおり、過去の遺物ですね。なかったということで気にしないようにしましょう。</p>
<h2>DataContractJsonSerializer</h2>
<p>今時の言語はJSONが簡単に扱えなきゃダメです。XMLだけ扱えればいい、なんて時代は過ぎ去りました。しかしC#は悲しいことに標準では……。いや、いや、Silverlightには<a href="http://msdn.microsoft.com/ja-jp/library/system.json.aspx">System.Json</a>がありますね。しかし.NET 4にはありません(.NET 4.5とWinRTには入ります)。いや、しかし.NET 4には<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>があります(それ出していいならJSON.NETがあるよ、で終わりなんですけどね)。が、Windows Phone 7には何もありません。ああ……。</p>
<p>とはいえ、シリアライザならば用意されています。DataContractJsonSerializerです。</p>
<pre><code class="language-csharp">// データ準備
var data = new Person { Name = &quot;山本山&quot;, Age = 99 };

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms = new MemoryStream())
{
    serializer.WriteObject(ms, data); // シリアライズ

    // 結果確認出力
    var xml = Encoding.UTF8.GetString(ms.ToArray(), 0, (int)ms.Length);
    Debug.WriteLine(xml); // {&quot;Age&quot;:99,&quot;Name&quot;:&quot;山本山&quot;}

    ms.Position = 0; // 巻き戻して……
    var value = (Person)serializer.ReadObject(ms); // デシリアライズ
    Debug.WriteLine(value.Name + &quot;:&quot; + value.Age); // 山本山:99
}
</code></pre>
<p>使い勝手はDataContractSerializerと完全に一緒です。ただし、違う点が幾つか。名前空間が（そもそもJSONで表現不可能なので）なくなったのと、順序も関係なく復元可能です。</p>
<pre><code class="language-csharp">var json1 = @&quot;{&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;,&quot;&quot;Age&quot;&quot;:99}&quot;;
var json2 = @&quot;{&quot;&quot;Age&quot;&quot;:99,&quot;&quot;Name&quot;&quot;:&quot;&quot;山本山&quot;&quot;}&quot;;

var serializer = new DataContractJsonSerializer(typeof(Person));
using (var ms1 = new MemoryStream(Encoding.UTF8.GetBytes(json1)))
using (var ms2 = new MemoryStream(Encoding.UTF8.GetBytes(json2)))
{
    var value1 = (Person)serializer.ReadObject(ms1);
    var value2 = (Person)serializer.ReadObject(ms2);

    Debug.WriteLine(value1.Name + &quot;:&quot; + value2.Age);
    Debug.WriteLine(value2.Name + &quot;:&quot; + value2.Age);
}
</code></pre>
<p>というわけで、随分とDataContractSerializerよりも使い勝手が良い模様。いい話だなー。さて、難点は出力されるJSONの整形が不可能です。DataContractSerializerではXmlWriterSettingsで行えましたが、DataContractJsonSerializerではそれに相当するものがありません。というわけでヒューマンリーダブルな形で出力、とはならず、一行にドバーっとまとめて吐かれるのでかなり苦しい。</p>
<p>もう一つ、これは本当に大したことない差なのでどうでもいいのですが、DataContractSerializerのほうが速いです。理由は単純でDataContractSerializerに一枚被せる形でDataContractJsonSerializerが実装されているから。その辺の絡みで.NET 4には<a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.serialization.json.jsonreaderwriterfactory.aspx">JsonReaderWriterFactory</a>などがあって、これを直に触ってJSON→XML変換をするとLINQ to XMLを通したJSONの直接操作が標準ライブラリのみで可能なのですが、Silverlight/Windows Phone 7では残念なことに触ることができません。</p>
<p>外部APIを叩いて変換する際に、シリアライズはお手軽で便利であると同時に、完全に同一の形のオブジェクトを用意しなければならなくて、かったるい側面もあります。LINQ to XML慣れしていると特に。そういった形でJSONを扱いたい場合、WP7では<a href="http://json.codeplex.com/">Json.NET</a>を使う、しかありません。使えばいいんぢゃないかな、どうせNuGetでサクッと入れられるのだし。</p>
<p>とはいえまあ、そう言うほど使いづらいわけでもないので、標準のみでJSONを扱いたいという場合は、DataContractJsonSerializerが第一にして唯一の選択肢になります。</p>
<h2>JavaScriptSerializer</h2>
<p>.NET Framework 4.0 Client Profileでは使えないのですが、FullならばSystem.Web.Extensionを参照することでJavaScriptSerializerが使えます。もはや完全にSilverlightと関係ないのでアレですが、少し見てみましょう。</p>
<pre><code class="language-csharp">var serializer = new JavaScriptSerializer();

var target = new { Name = &quot;ほむほむ&quot;, Age = 14 };
var json = serializer.Serialize(target); // stringを返す
</code></pre>
<p>Serializeで文字列としてのJSONを返す、というのがポイントです。それと、シリアライザ作成時にtypeを指定しません。また、匿名型もJSON化することが可能です（これはDataContractSerializerでは絶対無理）。ただし、コンストラクタのないクラスのデシリアライズは不可能です。</p>
<p>中々使い勝手がいいですね！で、これは、リフレクションベースの非常に素朴な実装です。だから匿名型でもOKなんですねー。ちょっとした用途には非常に楽なのですが、Client Profileでは使えないこともありますし(ASP.NETで使うために用意されてる)、あまり積極的に使うべきものではないと思います。ちなみに、一時期ではObsoleteになっていてDataContractJsonSerializer使え、と出ていたのですが、またObsoleteが外され普通に使えるようになりました。やはり標準シリアライザとしてはDataContractJsonSerializerだけだと重すぎる、ということでしょうか。</p>
<h2>バイナリとか</h2>
<p>別にシリアライズってXMLやJSONだけじゃあないのですね。サードパーティ製に目を向ければ、色々なものがあります。特に私がお薦めなのは<a href="http://code.google.com/p/protobuf-net/">protobuf-net</a>。これはGoogleが公開しているProtocol Buffersという仕様を.NETで実装したものなのですが、とにかく速い。めちゃくちゃ速い。稀代のILマスターが書いているだけある恐ろしい出来栄えです。SilverlightやWP7版もあるので、Protocol Buffersの本来の用途というだけなく、幅広く使えるのではかとも思います。</p>
<p>もう一つは国内だと最近目にすることの多い<a href="http://msgpack.org/">MessagePack</a>。以前に<a href="http://neue.cc/2010/05/29_261.html">.NET(C#)におけるシリアライザのパフォーマンス比較</a>を書いたときは振るわないスコアでしたが、最近別のC#実装が公開されまして、それは作者によるベンチ<a href="https://oikw.org/memo/2011/04/23/0">MessagePack for .NET (C#) を書いた</a>によると、protobuf-netよりも速いそうです。</p>
<h2>Next</h2>
<p>というわけでSilverlight枠でいいのか怪しかったですが、シリアライザの話でした。次は<a href="https://twitter.com/#!/ugaya40">@ugaya40</a>さんのWeakEventの話です。引き続きチェックを。あ、あと、Silverlight Advent Calendarはまだ埋まってない（！）ので、是非是非参加して、埋めてやってください。申し込みは<a href="http://atnd.org/events/22001">Silverlight Advent Calendar 2011</a>から。皆さんのエントリ、待ってます。どうやらちょうど今日Silverlight 5がリリースされたようなので、SL5の新機能ネタとかいいんじゃないでしょうか。</p>
</div>
<h1><a href="https://neue.cc/2011/12/09_356.html">自家製拡張メソッド制作のすすめ だいx回 BufferWithPadding</a></h1>
<ul class="date"><li>2011-12-09</li></ul>
<div class="entry_body"><p><a href="http://nuget.org/packages/Ix_Experimental-Main">Ix(Interactive Extensions)</a>は使っていますか？Rxから逆移植されてきている(IxのNuGet上のアイコンはRxのアイコンの逆向きなのですね)、LINQ to Objectsを更に拡張するメソッド群です。みんな大好きForEachなど、色々入っています。その中でも、私はBufferというものをよく使っています。Ixが参照できない場合は何度も何度も自作するぐらいに使いどころいっぱいあって、便利です。こんなの。</p>
<pre><code class="language-csharp">// 指定個数分をまとめたIList&lt;T&gt;を返します
// 第二引数を使うとずらす個数を指定することもできます
// これの結果は
// 0123
// 4567
// 89
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>標準でこういうのできないのー？というと、できないんですよねえ、残念なことに。</p>
<p>さて、ところで、この場合、指定個数に足りなかった場合はその分縮められたものが帰ってきます。上の例だと返ってくるListの長さは4, 4, 2でした。でも、埋めて欲しい場合ってあります。足りない分は0で埋めて長さは4, 4, 4であって欲しい、と。そこはLINQなので、創意工夫で頑張りましょう。例えば</p>
<pre><code class="language-csharp">// EnumerableEx.Repeatは指定の値の無限リピート
// それと結合して、Takeで詰めることで足りない場合だけ右を埋めることが出来る
// 0123
// 4567
// 8900
foreach (var xs in Enumerable.Range(0, 10).Buffer(4))
{
    xs.Concat(EnumerableEx.Repeat(0)).Take(4).ForEach(Console.Write);
    Console.WriteLine();
}
</code></pre>
<p>EnumerableEx.RepeatはIxにある無限リピート。Ixを参照しない場合は Enumerable.Repeat(value, int.MaxValue) で代用することも一応可能です。</p>
<p>さて、しかしこれも面倒なので、自家製拡張メソッドを作りましょう。拡張メソッドはばんばん作るべきなのです。</p>
<pre><code class="language-csharp">// 指定した値で埋めるように。これの結果は
// 0123
// 4567
// 89-1-1
foreach (var xs in Enumerable.Range(0, 10).BufferWithPadding(4, -1))
{
    xs.ForEach(Console.Write);
    Console.WriteLine();
}

public static class EnumerableExtensions
{
    public static IEnumerable&lt;T[]&gt; BufferWithPadding&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue = default(T))
    {
        if (source == null) throw new ArgumentNullException(&quot;source&quot;);
        if (count &lt;= 0) throw new ArgumentOutOfRangeException(&quot;count&quot;);

        return BufferWithPaddingCore(source, count, paddingValue);
    }

    static IEnumerable&lt;T[]&gt; BufferWithPaddingCore&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count, T paddingValue)
    {
        var buffer = new T[count];
        var index = 0;
        foreach (var item in source)
        {
            buffer[index++] = item;
            if (index == count)
            {
                yield return buffer;
                index = 0;
                buffer = new T[count];
            }
        }

        if (index != 0)
        {
            for (; index &lt; count; index++)
            {
                buffer[index] = paddingValue;
            }
            yield return buffer;
        }
    }
}
</code></pre>
<p>すっきりしますね！Emptyの時は何も列挙しないようにしていますが、Emptyの時は埋めたのを一つ欲しい、と思う場合は最後のifの囲みを外せばOK。あと、最後のif...for...yieldの部分を var dest = new T[index]; Array.Copy(buffer, dest, index); yield return dest; に変えればパディングしないBufferになります。Ix参照したくないけどBuffer欲しいなあ、と思ったときにコピペってどうぞ。</p>
<p>本体のコードと引数チェックを分けているのは、yield returnは本体が丸ごと遅延評価されるため、引数チェックのタイミング的によろしくないからです。少し面倒ですが、分割するのが良い書き方。詳しくは<a href="http://neue.cc/2011/08/15_338.html">neue cc - 詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)</a>で書いていますので見てください。</p>
</div>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2023<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
