<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
<meta property="og:url" content="https://neue.cc/2011/04/09_314.html" />
<meta property="og:type" content="article" />
<meta property="og:title" content="neue cc - Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション" />
<meta property="og:description" content="&lt;p class=&quot;noindent&quot;&gt;
	&lt;img src=&quot;http://neue.cc/wp-content/uploads/image/utakoto..." />

 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2011/04/09_314.html">Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション</a></h1>
<ul class="date"><li>2011-04-09</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_view.png">
</p>
<p>マーケットプレイスに通り、公開されました。フリーです(下で述べますがソースも公開しています)。再生中の音楽のアーティスト・タイトルを元に自動で検索して、歌詞を表示する、というものです。海外製の同種アプリとの違いは、対象が日本の曲ということになります。下記バナー、もしくはマーケットプレイス検索&quot;utakotoha&quot;でどうぞ。アプリケーション名は例によってヒネりなしで「歌詞」からそのままとりました。うたのことば。<a href="http://d.hatena.ne.jp/kaorun/20110211/1297427524">Utakata TextPad</a>と名前が似ていますが偶然の一致です(ほんと)</p>
<p class="noindent">
    <a href="http://social.zune.net/redirect?type=phoneApp&id=76526dfa-6260-e011-81d2-78e7d1fa76f8"><img src="http://neue.cc/wp-content/uploads/image/wp7_English_480x80_blue.png"></a>
</p>
<p>スクリーンショットでは格好つけてズームインして隠蔽していますが、スクリーンショット用詐欺なだけで、実際はこんな感じです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_ora.jpg">
</p>
<p>ようは、単純にWebBrowserに<a href="http://music.goo.ne.jp/lyric/">goo歌詞</a>を出しているだけです。ダブルタップでエリアに沿って幅一杯の拡大してくれるので、誤魔化し的にはまぁまぁ。WebBrowserを経由する理由は、APIが提供されているわけでもないので、権利関係考えるとこうでないとマズいかな、といったところで。goo歌詞を選んだ理由も直リンが許可されていたからです。</p>
<p>あと、WP7はテーマに黒背景のDarkと白背景のLightがあるわけですが、goo 音楽の背景は強制白で、どうもミスマッチなわけですね。アプリ自体を完全に白背景にしてしまうのもいいかな、とは思ったんですが、ブラウザのCSSを書き換えて黒背景にするという手を（ネタとして）取ってみました。オプションでOFFに出来るというか、デフォルトはOFFです。ズームすれば違和感はないんですが、画面いっぱいに広がってるものでは、微妙度極まりない。</p>
<p>ほか、Twitterに再生中楽曲を投稿する機能があります。</p>
<h2>ソースコード</h2>
<p>CodePlex上で公開しています。単機能アプリですので、コード規模は小さめです。あまりしっかりとはしてませんが、ユニットテストなども書いてあります。</p>
<ul>
<li><a href="http://utakotoha.codeplex.com/" title="Utakotoha">Utakotoha - CodePlex</a></li>
</ul>
<p>WP7の<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>実践例サンプル、のつもりで書いたので、Rxを全面的に使っています。むしろRx縛りと言ってもいいぐらいにRxのみでやるのを無駄に貫いています。意味がなくてただ複雑化しただけの箇所多数。UIと絡めて使うのがイマイチ分からず振り回されてますねー。とはいえ、バッチリはまった部分も勿論あり。というわけで、Windows Phone 7においてReactive Extensionsがどのような場所で使えるのか、というのをコードとともに解説していきます。</p>
<p>コードはWindows Phone 7向けですが、通常のSilverlightでもWPFでも適用できる話なので、WP7関係ないからー、と言わず、Rxに興味ありましたら、眺めてみてください。</p>
<h2>Linq to Event</h2>
<p>Rxの特徴の一つはイベントのLinq変換です。Linq化して何が嬉しいかというと、柔軟なフィルタリングが可能になることです。WP7では、センサーからのデータ処理やタッチパネルなど、様々な箇所で威力を発揮すると思われます。UtakotohaではMediaPlayerの再生情報の変化に対してRx化とフィルタリングを施しました。</p>
<pre><code class="language-csharp">// Model/MediaPlayerStatus.cs
public class MediaPlayerStatus
{
    public MediaState MediaState { get; set; }
    public ActiveSong ActiveSong { get; set; }

    public static MediaPlayerStatus FromCurrent()
    {
        return new MediaPlayerStatus
        {
            MediaState = MediaPlayer.State,
            ActiveSong = MediaPlayer.Queue.ActiveSong
        };
    }

    public static IObservable&lt;MediaPlayerStatus&gt; ActiveSongChanged()
    {
        return Observable.FromEvent&lt;EventArgs&gt;(
                h =&gt; MediaPlayer.ActiveSongChanged += h, h =&gt; MediaPlayer.ActiveSongChanged -= h)
            .Select(_ =&gt; MediaPlayerStatus.FromCurrent());
    }

    public static IObservable&lt;MediaPlayerStatus&gt; MediaStateChanged()
    {
        return Observable.FromEvent&lt;EventArgs&gt;(
                h =&gt; MediaPlayer.MediaStateChanged += h, h =&gt; MediaPlayer.MediaStateChanged -= h)
            .Select(_ =&gt; MediaPlayerStatus.FromCurrent());
    }

    // (省略)すぐ下に...
}
</code></pre>
<p>Rx化は、ただFromEventをかますだけです。また、その際に、IEventではなく、本当に使う情報にだけ絞ったもの(この場合はMediaStateとActiveSong)をSelectで変換しておくと色々とコードが書きやすくなるのでお薦めです。</p>
<p>さて、「柔軟なフィルタリング」とは何か。ただデータを間引くだけなら、イベントの先頭でif(cond) return;を書けばいいだけです。RxではLinq化により、(自分自身を含めた)イベント同士の合成と、時間軸を絡めた処理が可能になります。これにより、従来一手間だった処理がたった一行で、連続した一塊のシーケンスとして処理することが可能になりました。</p>
<p>Utakotohaでも、生のイベントをそのまま扱わず、ある程度間引いて加工したものを渡しています。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;raise when ActiveSongChanged and MediaState is Playing&lt;/summary&gt;
public static IObservable&lt;Song&gt; PlayingSongChanged(int waitSeconds = 2, IScheduler scheduler = null)
{
    return ActiveSongChanged()
        .Throttle(TimeSpan.FromSeconds(waitSeconds), scheduler ?? Scheduler.ThreadPool) // wait for seeking
        .Where(s =&gt; s.MediaState == MediaState.Playing)
        .Select(s =&gt; new Song(s.ActiveSong.Artist.Name, s.ActiveSong.Name));
}
</code></pre>
<p>「再生中かつx秒間(デフォルトは2秒)新しいイベントが発生しなかった最新のものだけを流す」というものです。どういう意味かというと、連続で楽曲をスキップした時。Utakotohaでは再生曲の変更に合わせて、自動で歌詞検索をしますが、連続スキップにたいしても全て裏で検索に走っていたらネットワークの無駄です。なので、2秒間だけ間隔を置いて連続スキップされていない、と判断した曲のみを歌詞検索するようにしています。</p>
<p>こういう処理は、地味だけど必ず入れなければならない、けれど面倒くさい。でも、Rxを使えばなんてことはなく、Throttleで一撃です。Timer動かしたりDateTimeを比較したりなんて、もうしなくていいんだよって。</p>
<pre><code class="language-csharp">/// &lt;summary&gt;raise when MediaState Pause/Stopped -&gt; Playing&lt;/summary&gt;
public static IObservable&lt;Song&gt; PlayingSongActive()
{
    return MediaStateChanged()
        .Zip(MediaStateChanged().Skip(1), (prev, curr) =&gt; new { prev, curr })
        .Where(a =&gt; (a.prev.MediaState == MediaState.Paused || a.prev.MediaState == MediaState.Stopped)
            &amp;&amp; a.curr.MediaState == MediaState.Playing)
        .Select(s =&gt; new Song(s.curr.ActiveSong.Artist.Name, s.curr.ActiveSong.Name));
}
</code></pre>
<p>こちらは、状態が停止-&gt;再生になったことを検知するというもの。停止-&gt;再生でも自動検索を走らせたいので。</p>
<p>この source.Zip(source.Skip(1), /* merge */) は、一見奇妙に見えるかもしれませんが、ある種のイディオムです。一つ先(Skip(1))の値と合流するということは、Skip(1)時の値を基準にすると、現在値と一つ前の値で合流させることができる、ということになります。それにより、一つ前の状態を参照して停止-&gt;再生を検知しています。</p>
<p>過去の値を参照するには、他に、Scan(Aggregateの列挙版、そう考えると現在値と一つ前の値が使えることのイメージつくでしょうか？)やBufferWithCount(Listでバッファを持つ、第二引数でずらす範囲を指定可能)など、幾つかやり方がありますが、このZip(Skip(1))が最も扱いやすいところ。ただし、通常のものとSkipしたものとで、二つ分Subscribeされるということは留意したほうがいいかもしれません。そのことが問題になるケースもあるので、キャッシュを使う(Pulish(xs=&gt;xs.Zip(xs.Skip(1)))など回避策を頭に入れておくと良いケースもあります。</p>
<h2>Linq to Asynchronous</h2>
<p>Rxのもう一つの大きな特徴は非同期のLinq変換です。そうすることにより、コールバックの連鎖で扱いにくかった非同期が、一本の流れに統一されます。</p>
<p>Utakotohaでは、歌詞の検索部分が代表的です。歌詞検索の背景ですが、goo歌詞のものを表示しているのだからgoo歌詞の検索を呼んでやるかなあ、と思ったのですが、それは色々マズいので、<a href="http://www.bing.com/developers/appids.aspx">Bing Api</a>のサイト内検索を経由して、表示しました。Bing Apiについては若干苦労話もあるので、いつかまた。</p>
<pre><code class="language-csharp">// Model/Bing/BingRequest.cs
public IObservable&lt;SearchWebResult&gt; Search(params SearchWord[] keywords)
{
    var req = WebRequest.Create(BuildUrl(keywords));

    return Observable.Defer(() =&gt; req.GetResponseAsObservable())
        .Select(res =&gt;
        {
            var serializer = new DataContractJsonSerializer(typeof(SearchWebStructure));
            using (var stream = res.GetResponseStream())
            {
                return (SearchWebStructure)serializer.ReadObject(stream);
            }
        })
        .SelectMany(x =&gt; (x.SearchResponse.Web.Results != null)
            ? x.SearchResponse.Web.Results
            : Enumerable.Empty&lt;SearchWebResult&gt;());
}
</code></pre>
<p>割とあっさり。Bing APIならびにJSONに関しては、以前<a href="http://neue.cc/2011/03/31_312.html">Windows Phone 7でJSONを扱う方法について(+ Bing APIの使い方)</a>として書きました。ほとんどそのままです。SearchResponse.Web.Resultsは、配列なので、SelectManyで分解してやります(nullの場合は空シーケンスを流す)。すると、後続に繋げるのが非常にやりやすくなります。実際に</p>
<pre><code class="language-csharp">// Model/Song.cs
public IObservable&lt;SearchWebResult&gt; SearchLyric()
{
    return new BingRequest()
        .Search(MakeWord(Artist), MakeWord(Title), LyricSite, Location, Language)
        .Where(sr =&gt; sr.Url.EndsWith(&quot;index.html&quot;))
        .Do(Clean);
}
</code></pre>
<p>といったように、Searchから更に続いて、若干のフィルタリングが入っています。これを使う場面では、勿論、更にチェーンが続きます。といったように、Rxは一つの流れを構築するわけですが、それらを徹底的に分解・分割して適切な場所への配置・組み合わせが可能になっています。もし、通常の非同期処理のようなコールバックの連鎖だったら、組み合わせは大変でしょう(だから、その場だけで処理したくなって、ネストが嵩んでしまう)</p>
<h2>Orchestrate and Coordinate</h2>
<p>Rx全体の特徴として、また、他の非同期を扱うライブラリと最も異なる、しかし重要な点として、中に流れるデータを区別しません。非同期もイベントもタイマーもオブジェクトシーケンスも、全て同列に扱います。それはどういうことかというと、データの種別を超えて合成処理が可能になるということです。つまり、Rxは、あらゆるデータソースを統合する基盤といえます。上のAsynchronousの例でも、非同期のWebResponseが、SelectMany以降はオブジェクトシーケンスに摩り替わっていました。</p>
<p>Utakotohaでは、歌詞の表示部分で色々なデータを混ぜあわせる処理を行っています。</p>
<pre><code class="language-csharp">// View/MainPage.xaml.cs
LyricBrowser.NavigatedAsObservable()
     .Where(ev =&gt; ev.EventArgs.Uri.AbsoluteUri.Contains(GooLyricUri))
     .SelectMany(ev =&gt;
     {
         // polling when can get attribute
         return Observable.Timer(TimeSpan.Zero, TimeSpan.FromSeconds(3))
             .ObserveOnDispatcher()
             .Select(_ =&gt; (ev.Sender as WebBrowser).SaveToString())
             .Select(s =&gt; Regex.Match(s, @&quot;s.setAttribute\('src', '(.+?)'&quot;))
             .Where(m =&gt; m.Success)
             .Take(1);
     })
     .Select(m =&gt; WebRequest.Create(GooUri + m.Groups[1].Value).DownloadStringAsync())
     .Switch()
     .Select(s =&gt; Regex.Replace(s.Trim(), @&quot;^draw\(|\);$&quot;, &quot;&quot;))
     .Where(s =&gt; !string.IsNullOrEmpty(s))
     .ObserveOnDispatcher()
     .Subscribe(jsonArray =&gt;
     {
         // insert json array to html
         LyricBrowser.InvokeScript(&quot;eval&quot;, @&quot;
            var array = &quot; + jsonArray + @&quot;;
            var sb = [];
            for(var i = 0; i &lt; array.length; i++) sb.push(array[i]);
            document.getElementById('lyric_area').innerHTML = sb.join('&lt;br /&gt;')&quot;);

         // (省略)
     }, e =&gt; MessageBox.Show(&quot;Browser Error&quot;))
     .Tap(disposables.Add);
</code></pre>
<p>歌詞の表示といっても、WebBrowserに表示しているこということは、歌詞のURLを渡すだけです。それだけで済むはずでした。が、……妙に複雑怪奇です。歌詞のURLが渡されて表示が完了してからが起点として(Navigated)、処理を開始しています。</p>
<p>何故こうなったか。WP7が現在積んでるIEは7。ついでにFlashはまだ未対応で見れません。それとこれとがどう関係あるかというと、歌詞表示に関係あります。日本の歌詞サイトは大抵はコピペ禁止のために右クリック禁止、だけでなく、Flashで表示していたりします。それじゃあ手が出せない。では今回利用しているgoo歌詞は、というと、少し変わっていてHTML5 Canvasに描画しています。勿論Canvasは古いブラウザじゃ動かないので、互換用JavaScriptも挟んでいるよう。<a href="http://uupaa-js-spinoff.googlecode.com/svn/trunk/uuCanvas.js/README.htm">uuCanvas.js </a>を使っているようですが、環境貧弱なWP7版のIE7じゃあ、土台動きませんでした。</p>
<p>このまんまじゃあ歌詞が表示出来なくて困ったわけですが、幸いgoo歌詞はJSONPで歌詞データを別途取得してCanvasにデータを流しているようなので、HTMLからJSONPの発行先を割り出して、歌詞データを頂いてしまえば問題ない(この時点で規約的にはグレーな気が)。生の歌詞データが手に入ってしまっ……。こいつをキャッシュするようにしてオフラインでも見れるといった機能を提供してあげられれば幸せになれるのですが、そういうのは利用規約に違反、してますね、明らかに。</p>
<p>じゃあどうするか。手元には歌詞の表示されていないブラウザ上のHTMLと、歌詞データがある。よし、じゃあブラウザにこちらからはめ込んでやればいいんじゃなイカ？</p>
<p>WP7ではWebBrowserのDOMは触れません。DOMを外から触ってappendChildしてサクッと終了、というわけにはいかず。ただ、外部から干渉出来る口が一つだけ用意されています。それがInvokeScript。外から実行関数を指定して、戻り値を受け取れます(DOMは無理なので、Stringで貰うのが無難)。ならば、evalして外から実行関数自体を注入してやれば、何だって出来る。どうにも馬鹿らしい気もしますが、このぐらいしか手がないのでShoganai(なお、予めWebBrowserのプロパティでスクリプト実行を許可しておかないと例外が出ます)。</p>
<h2>Timer and Polling</h2>
<p>イベント(Navigated)→タイマー(SaveToString)→非同期(DownloadStringAsync)という直列の合成でした。直列の合成を行うメソッドはSelectMany(もしくはSelect+Switch、両者には若干の違いがあるのですが、それに関しては後日説明します)で、Rxの中でも頻繁に使うことになるメソッドです。</p>
<p>ところで、タイマーが唐突なのですが、何故タイマーを仕込んでいるのか。どうもNavigated直後にSaveToString(WebBrowser内のHTMLを文字列化)だと、タイミング次第で上手く抽出できないことが多かったので(JSで色々処理されてる影響かな？)、必要なJSONPの書かれた属性が取れるまでSaveToStringをリトライするようにしました。つまり、ポーリング(定期問い合わせ)です。</p>
<p>ポーリングは普通だと面倒くさいはずなんですが、Rxだと恐ろしく簡単に書ける上に、こうして通常の処理の流れと合成することが可能になっているのが何よりも強力です。.NET Frameworkには幾つものTimerクラスがあって、何を使えばいいのかと戸惑ってしまうところがありますが、答えは出ました。Observable.Timerがベスト。大変扱いやすい。</p>
<p>これで、本来Canvasのあった領域にテキストデータとして歌詞を表示させられました。全く違和感のない、完璧なハメコミ合成。無駄なコダワリです。地味すぎて一手間かけてることなんてさっぱり分からない。だがそれがいい。……いや、ちょっと悲しい。それにしてもでしかし、Canvas, Flash対応になればこんなやり方は不要になるわけで、今年後半のアップデートでのIE9搭載が待ち遠しい。</p>
<h2>Unit Testing</h2>
<p>Silverlight向けのユニットテスト環境って、全然ない。ブラウザ上のSilverlightで動かす、というタイプは幾つかありますが、Visual Studioと統合された形のでないと、そんなのアタシが許さない。</p>
<p>TDDするわけでも、熱心にテスト書くわけでも、特段カバレッジを気にするわけでもない私ですが、テストが書けることは重要視しています。何故かというと、メソッドの動作確認が最も素早く行えるから。テスト(が出来ること)に何を期待しているかというと、確認したいんです、メソッドの動作を。手軽に、コンソールアプリを書く感覚で、素早く。処理をコンソールアプリにコピペって、もしくは並走してコンソールアプリを立てながら開発していたりなどを以前よくしたのですが、それを単体テストのメソッド部分に書けば、動作確認のついでに、テストまで手に入るので、それは素敵よね？と。</p>
<p>(単体)テストが第一の目的ではない、(動作確認)テストが目的なのだ。だから、テストフレームワークはVisual Studioと完全な統合を果たしていなければならない。ショートカットでIDE内のウィンドウで即座に実行。スピードが大事。また、シームレスなデバッグ実行への移行も。故にMSTestを選択するのである(ｷﾘｯ</p>
<p>などなどはその辺にしておいて、それはともかくで、素直にフル.NET Frameworkで動くMSTestを使います。一応Silverlightのアセンブリは<a href="http://blogs.msdn.com/b/clrteam/archive/2009/12/01/sharing-silverlight-assemblies-with-net-apps.aspx">フル.NETからも参照可能</a>のようなので、普通にテストプロジェクトを立ててDebug.dll を参照してやる(プロジェクト参照は警告出るので)という手も使えなくはなさそうなのですが、完全な互換を持つコアライブラリは全体のごく一部で、それ以外を使っていると普通に実行時例外でコケるなど、正直使えないと私は判断しました。よって、アセンブリ参照でやるのは諦め。プロジェクト参照で警告が出る理由も分かりました、あまり実用的な機能ではない……。</p>
<p>代わりにWP7プロジェクトとテストプロジェクトの間に、.NET4ライブラリプロジェクトを立てて、「追加-&gt;既存の項目-&gt;リンクとして追加」で、フルフレームワークとWP7間で.csファイルを共有してやります(Viewは勿論共有出来ないので、基本はModelのみ)。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/utakotoha_testref.jpg">
</p>
<p>勿論、コードレベルで互換が取れていないと動きません。そんなわけで、少なくともModelに関してはWPF/SL/WP7で共通で使いまわせるように意識して作りたいところです。移植性というだけじゃなく、MSTestの恩恵を受けれるので。ただまあ、無理な部分は無理で諦めちゃってもいいとは思います(SLのほうにだけあるクラスとかもありますから)。非同期のテストなどは、幸いRxを使っていれば非常に簡単なので、バシバシ書いちゃいましょう。</p>
<pre><code class="language-csharp">// Utakotoha.Test/SongTest.cs
[TestMethod]
[Timeout(3000)]
public void SearchLyric()
{
    var song = new Song(&quot;吉幾三&quot;, &quot;俺ら東京さ行ぐだ&quot;);
    var array = song.SearchLyric().ToEnumerable().ToArray();

    array.Count().Is(1);
    array.First().Title.Is(&quot;俺ら東京さ行ぐだ 吉幾三&quot;);
    array.First().Url.Is(&quot;http://music.goo.ne.jp/lyric/LYRUTND1127/index.html&quot;);
}
</code></pre>
<p>ToEnumerableしてToArrayするだけです！非同期のテストなんて怖くない。</p>
<p><a href="http://blogs.msdn.com/b/bclteam/archive/2011/01/19/announcing-portable-library-tools-ctp-justin-van-patten.aspx">Portable Library Tools CTP</a>という、各環境で互換性の取れるライブラリが作成出来るもの、なども出てきているので、リンクで追加とかいう間抜け(そして面倒)なことじゃなく、プロジェクトごと分離して、Modelは互換で生成、というのが将来的には良いやり方になるかなあ、などと思っています。そういう事情から、私は移植性とは関係ない立場からも、Portable Library Toolsの発展に期待しています。</p>
<p>なお、アサーションは<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>使っています。ドッグフードドッグフード。というかもう、必需品なので、これないと書けない、書きたくない……。</p>
<h2>Mocking Event with Moles and Rx</h2>
<p>さて、このやり方の利点として、PexやMolesが使えます(Pexは一応SLをサポートしたものの、Molesは依然としてSL未サポート)。Moles(Microsoft Researchが提供するモックフレームワーク、フリー)の乗っ取り機構は強力なので、テスト可能範囲が大幅に広がります。詳しくは<a href="http://neue.cc/2011/03/10_309.html" title="neue cc - Rx + MolesによるC#での次世代非同期モックテスト考察">Rx + MolesによるC#での次世代非同期モックテスト考察</a>をどうぞ。</p>
<p>今回Linq to Eventで紹介したPlayingSongActiveは、以下のようにテストしています。MediaPlayer周りはXNAなので、Test側の参照DLLとしてXNA Game Studio v4.0のMicrosoft.Xna.Framework.dllを参照。そしてMolesで乗っ取り。</p>
<pre><code class="language-csharp">// Utakotoha.Test/MediaPlayerStatusTest.cs

private MediaPlayerStatus CreateStatus(MediaState state, string artist, string name)
{
    return new MediaPlayerStatus
    {
        MediaState = state,
        ActiveSong = new Microsoft.Xna.Framework.Media.Moles.MSong
        {
            NameGet = () =&gt; name,
            ArtistGet = () =&gt; new MArtist
            {
                NameGet = () =&gt; artist
            }
        }
    };
}

[TestMethod, HostType(&quot;Moles&quot;)]
public void PlayingSongActiveTest()
{
    // event invoker
    var invoker = new Subject&lt;MediaPlayerStatus&gt;();
    MMediaPlayerStatus.MediaStateChanged = () =&gt; invoker;

    // make target observable
    var target = MediaPlayerStatus.PlayingSongActive().Publish();
    target.Connect();

    // at first, stopped
    using (target.VerifyZero())
    {
        invoker.OnNext(CreateStatus(MediaState.Stopped, &quot;&quot;, &quot;&quot;));
    }

    // next, playing
    using (target.VerifyOnce(song =&gt; song.Is(s =&gt; s.Title == &quot;song&quot; &amp;&amp; s.Artist == &quot;artist&quot;)))
    {
        invoker.OnNext(CreateStatus(MediaState.Playing, &quot;artist&quot;, &quot;song&quot;));
    }

    // pause
    using (target.VerifyZero())
    {
        invoker.OnNext(CreateStatus(MediaState.Paused, &quot;&quot;, &quot;&quot;));
    }

    // play again
    using (target.VerifyOnce(song =&gt; song.Is(s =&gt; s.Title == &quot;song2&quot; &amp;&amp; s.Artist == &quot;artist2&quot;)))
    {
        invoker.OnNext(CreateStatus(MediaState.Playing, &quot;artist2&quot;, &quot;song2&quot;));
    }
}
</code></pre>
<p>元のコード自体がイベント発火部分はRxで包んであるので、そのイベント発火だけを差し替え。SubjectとはイベントのRxでの表現。OnNextでイベント発火の代用が可能になっています。これで、任意のイベント(今回はMediaPlayerなので、再生停止であったり再生開始であったり)を発行して、その結果の挙動を確認しています。</p>
<p>VerifyなんたらはIObservableへの自前拡張メソッドで、発火されたか/回数の検証です。「イベントは発生したけれどフィルタリングされて値が届かなかった」ことの、フィルタリングが正常に出来たかの確認って、そのままだと難しい。如何せんSubscribeまで届いてくれないということですから。そのため、その辺を面倒みてくれるものを用意しました。</p>
<pre><code class="language-csharp">// Utakotoha.Test/Tools/ObservableVerifyExtensions.cs

/// &lt;summary&gt;verify called count when disposed. first argument is called count.&lt;/summary&gt;
public static IObservable&lt;T&gt; Verify&lt;T&gt;(this IObservable&lt;T&gt; source, Expression&lt;Func&lt;int, bool&gt;&gt; verify)
{
    var count = 0;
    return source
        .Do(_ =&gt; count += 1)
        .Finally(() =&gt;
        {
            var msg = verify.Parameters.First().Name + &quot; = &quot; + count + &quot; =&gt; &quot; + verify.Body;
            Assert.IsTrue(verify.Compile().Invoke(count), &quot;Verifier &quot; + msg);
        });
}

/// &lt;summary&gt;verify called count when disposed. first argument is called count.&lt;/summary&gt;
public static IDisposable VerifyAll&lt;T&gt;(this IObservable&lt;T&gt; source, Expression&lt;Func&lt;int, bool&gt;&gt; verify, Action&lt;T&gt; onNext = null)
{
    return source.Verify(verify).Subscribe(onNext ?? (_ =&gt; { }));
}

/// &lt;summary&gt;verify not called when disposed.&lt;/summary&gt;
public static IDisposable VerifyZero&lt;T&gt;(this IObservable&lt;T&gt; source)
{
    return source.VerifyAll(i =&gt; i == 0);
}

/// &lt;summary&gt;verify called once when disposed.&lt;/summary&gt;
public static IDisposable VerifyOnce&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext = null)
{
    return source.VerifyAll(i =&gt; i == 1);
}
</code></pre>
<p>usingによるスコープを抜けるとFinallyで検証が入ります。RxでイベントをラップするとIDisposableになる、そのことの利点が生きてきます。</p>
<h2>今後の改善</h2>
<p>Pivotのヘッダーのデザインがどうも間抜け(マージンの取り方が変だし文字サイズも違和感あり)なのが気になってるので、変えたいです。HeaderTemplateの編集の仕方がよくわからずで放置なのですけれど、ゆったり紐解けば出来るでしょう。多分。</p>
<p>レジュームへの配慮が全くなくて、別画面にいくと真っ白になるのがビミョい。WebBrowserが絡むので完全な復元は無理だから、いっかー、とか思ったのが半分はあるのですが、いやまてその理屈はオカシイ。ので、ちょっと何とかさせないとですね。</p>
<p>xaml.csのコードが全体的にマズい。特にOAuth認証の部分はありえない強引さなのでとっとと変更。あと、もう少し適切な分割。MVVMはわからんちん。</p>
<p>Settingsが何か変。IsolatedStorageSettingsというか、その内部のDataContractSerializerの都合というか。これだ！というやり方ないかしら。今のやり方は、非常に間抜け。</p>
<p>ブラウザ画面黒背景はビミョーなので、設定でアプリ全体を白背景に変更するオプションを入れるのもいいかなー。それとアプリ起動時は楽曲を再生中でも自動検索しないのだけど、自動検索してくれたほうが嬉しいかなー。など、細かい点では色々考えること、追加することあります。</p>
<h2>まとめ</h2>
<p>上手く決まった部分しか解説してないので、実際のコードは残念ながらスパゲッティです:) というか、UI絡みのコードってほとんど書いたことないので、経験の無さが如実に現れていて苦すぃ。WP7で勝手がわからないというもの若干はありますが、それ以前の問題がかなり。サンプルアプリとしても、もう少し良くしたいので、コードは徐々に洗練させていきたいですます。</p>
<p>アプリとしては、まあまあいい出来というか、実用品として悪くないフィーリングだと思うのですが、どうでしょうか？画面周りは、このレイアウトで決まるまで何度も試して投げてを繰り返してこれに落ち着きました。実際に作りながら、試しながらでないとこういうの決められないよね。コードに関してもそうだけど。ともあれ、Pivotいいよねー。やはりWP7といったらPivot。</p>
<p>そんなわけで、RxはWP7開発のお供として欠かせない代物なので、是非使ってみてください。また、WP7で欠かせないということはSilverlightで欠かせないということであり、Silverlightで欠かせないということはWPFでも欠かせないということでも、あったりなかったりするので、Rxによるプログラミングパラダイムの変化を是非とも楽しんでみてください。Linq to Anything!</p>
<p>一記事に収めるため少々駆け足気味だったので、なにか不明な点、質問などありましたら気楽にコメントどうぞ。突っ込みも勿論歓迎です。</p>
</div></div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
