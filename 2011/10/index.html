<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2011-10</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2011-10-24" data-pagefind-meta="published:2011-10-24"><a href="https://neue.cc/2011/10/24_350.html">Chaining Assertion ver1.6.1.0</a></h1>
<ul class="date"><li>2011-10-24</li></ul>
<div class="entry_body"><ul>
<li><a href="http://chainingassertion.codeplex.com/">Chaining Assertion - Codeplex</a></li>
</ul>
<p>Chaining Assertionとは、メソッドチェーンな形で簡単にユニットテストを書けるようにする拡張メソッドです。何でそういうのが必要なのか、とかの理由などは<a href="http://neue.cc/2010/08/02_270.html">neue cc - テストを簡単にするほんの少しの拡張メソッド</a>で。</p>
<p>最近こっそり小さな更新が続いているのですが、今回の更新は、IsNullにmessageが指定できるようになりました。実のところ、他のIsは指定できたのですが、IsNullだけ指定不可能でした。理由はただたんに忘れてたから、です。とてもしょうもない……。と、@okazukiさんに<a href="http://d.hatena.ne.jp/okazuki/20111022/1319257560">ChainingAssertion使ってみた</a>で指摘頂きました。いやあ、ありがとうございます。</p>
<p>そんなこんなで見直していて、そういえば params object[] parameters なオーバーロードが欠けてるなあ、入れたほうがいいかしらん、と少し実装初めてからやめました。やりたければstring.Format使ってください、はい。ちなみに理由はオーバーロードが必要(messageのほうに{}が入っていてparametersは空、というケースを避けるため、paramsとはいえ別のオーバーロードを用意する必要がある)だからです。</p>
<p>オーバーロードは減らしたいんです。少ないほうが分かりやすいというのは自明な話だと思います。使いやすいAPIのためには、クラスの数を減らそう、メソッドの数を減らそう、オーバーロードの数を減らそう、引数の数を減らそう。少ないことは美です。それでですね、メソッド数を減らすためもあって、Isはかなりオーバーロード嵩んでいるのですよね。だから、瑣末な機能を追加するためだけにホイホイとオーバーロードは足せません。</p>
<h2>その他</h2>
<p>@shinsukeodaさんに<a href="http://d.hatena.ne.jp/odashinsuke/20111005/1317813807">ChainingAssertion for MSTest のパラメタライズドテストを NUnit 感覚で利用すると… </a>で紹介頂き本当にありがとうございます。本題の、パラメタライズドテストについてですが、これが非常に悩ましい。実装的にビミョーになってしまう、というのもそうなのですが、NUnitは本当のパラメタライズドテストで、テストケースがバラバラになるのですが、ChainingAssertionのものは擬似的なものに過ぎないので、テスト結果的には一つのテストケースなのですね。そして、一つのケースなのにInitializeやCleanupを呼んでいく、という挙動がアリなのかナシなのかが、自分のなかで答えがでないのです。なので、今はちょっと見送りです。もう少し考えて答えが出たら、その時に、かしらん。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-17" data-pagefind-meta="published:2011-10-17"><a href="https://neue.cc/2011/10/17_349.html">ReactiveProperty ver.0.2.0.0</a></h1>
<ul class="date"><li>2011-10-17</li></ul>
<div class="entry_body"><ul>
<li><a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Reactive Extensions</a></li>
</ul>
<p>ver.0.2！ご意見ご感想は随時募集中で、コメントなりTwitterで私に@を投げてくれるなり、ただたんにTwitterでReactivePropertyと含めてつぶやいてくれるなり(検索経由で拾えるので)、ブログで記事を書いてくださるついでにクエスチョンしてみたりなどなど、ちょっとした疑問でも要望でも、何でもどうぞ。特に、細かな使用感の向上というのはリクエストがあってこそですので！斜め上からやってきた結果として世界最先端(但し逆向き)を体感出来るのは今だけです！斜め上なのでReactivePropertyのうまい使い方は今のところ誰にも分かりません、私もわかりません(えー)。というわけで、みんなで模索できたらいいな、と思います。</p>
<p>国内はもとよりReactiveUIの作者からも言及頂いて結構褒めてもらったりなどなど、RxのForumで宣伝したかいがあったね！というわけで、私自身かなり真剣に取り組んでますので、付き合って頂ければ幸いです。 /* 現在ReactiveOAuthをほっぽりだしてるという信頼感のなさがアレなので、そちらも早めに何とかします…… */</p>
<p>今回は、0.1では中途半端な存在だったReactiveCollectionを徹底的に考察して再デザインしました。他に細かい追加が幾つか。まずは小さな追加から。</p>
<h2>追加したり変わったりしたもの</h2>
<p>ObserverPropertyが、最初のSubscribe時に値をPushするようになりました(引数でfalseを指定するとオフにも出来る、そうすると、普通にFromEventしたのと同じ)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ToaranaiViewModel
{
    ToaruModel model;
    public ReactiveProperty&lt;string&gt; Name { get; private set; }

    public ToaranaiViewModel()
    {
        // こんなINotifyPropertyChangedなModelがあるとして
        model = new ToaruModel { Name = &quot;Anders&quot; };

        // 初期値として現在値(この場合&quot;Anders&quot;)を持つ
        Name = model.ObserveProperty(x =&gt; x.Name).ToReactiveProperty();
    }
}

public class ToaruModel : INotifyPropertyChanged
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; PropertyChanged(this, new PropertyChangedEventArgs(&quot;Name&quot;)); }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}
</code></pre>
<p>これにより、既存のModelからToObservablePropertyしてViewModelにする際などに、デフォルトで値が同期されるので多くのシチュエーションで、より便利になったと思います。という提案を@okazukiさんにリクエスト貰ったので実装しました:) @okazukiさんは<a href="http://d.hatena.ne.jp/okazuki/20111017/1318827792">ReactivePropertyを使ってみた感想 イケテル！気持ちいい！ハードルは高い？ - かずきのBlog@Hatena</a>という記事も書いてくれました、わーい。</p>
<p>ObserverProeprtyはINotifyPropertyChangedへの拡張メソッドです。また、今回よりINotifyPropertyChangingにObservePropertyChanging拡張メソッドを追加しました。ObserverProeprtyと同様な感覚で使えます。</p>
<p>それとReactiveCommand(無印)のExecuteが引数なしでnullをぶん投げるようになりました。なお、これがあるのは無印のほうのみで&lt;T&gt;のほうにはありません。だって、ジェネリックするということはパラメータが欲しい前提ですものね。ジェネリックのほうはExecute(T parmeter)を受け入れるうようにオーバーロードを隠蔽。こういう細かいところの使いやすさの向上ってのは随時取り組みたいところです。</p>
<p>また、ReactiveCommand(無印・ジェネリック共に)をDisposeすると、SubscribeしてたものにOnCompletedを投げるように変更しました。なお、ReactiveCommandをDisposeすると、CanExecuteもfalseになります。永久的にfalseにする、という意味合いで使えるかと思いますが、使うシチュエーションは分かりません。</p>
<h2>ReactiveCollectionの再デザイン</h2>
<p>ReactiveCollectionに大きめの変更を入れました。今まで通知をIScheduler上で行なっていましたが、これを廃止しました。かわりにToReactiveCollectionなどIObservableからの変換時は、Addと通知、両方をIScheduler上にしました。また、IScheduler上で各種操作(Add, Clear, Remove)を行うメソッド AddOnScheduler などを追加しました。この変更のデザイン上のポリシーは以下になります。</p>
<p>ObservableCollectionとスレッドセーフ・ディスパッチャーセーフというのは非常に難しい。まず、ObservableColectionは変更と通知がワンセットだと考えられる。コレクションが変更され通知を出し、通知され側(主にUI)がコレクションを読みに来る。これは全部ひとまとまりでなければならない。通知され側がコレクションを読みに行く際に、ズレがあってはならない。よって、通知をUIスレッドで行うなら、変更もUIスレッドで行われる必要がある。</p>
<p>しかし、全ての操作を内部で片っ端からDispatcherにBeginInvokeするアプローチを取ると、それはそれで都合が悪い。例えば別スレッドでAddしたりRemoveしたりClearしても、そのコード上では変更はすぐには反映されない。ClearしてもCountは変わらない。AddしてもCountは変わらない。そんな気味の悪いコレクションクラスは使えません。WPFではDispatcher.Invokeがあるので、変更と通知を強制的にUIスレッド上で行う、ということが可能でしたが、SilverlightにはBeginInvokeしかないので、操作をUIスレッドで行うことを保証するコレクションクラスの作成は不可能。(<a href="http://caliburnmicro.codeplex.com/">Caliburn Micro</a>のBindableCollectionは全部UIスレッド上で行うようにしているみたいですね、まあBindableにのみ焦点を当てるなら現実的なので、それはそれでいいと思います)</p>
<p>だから、コレクションを触る時は利用側がDispatcher.BeginInvokeして、明示的にDispatcherの中へ入ろう。というのが、整合性が取れて一番良いのだと思います。今まで、ReactiveCollectionは通知だけIScheduler上で行うようになっていました。でも、これはあまり良いデザインではない、操作と通知は同一スレッド上で行うべきなのだから、これでは乖離する可能性がある。単純なAddだけのようなケースでは問題になることは少ないし、利便性としては、その方が簡単にバインドで出来て良いよね、ではあるのだけど、決して良いデザインではない。いずれ発覚する破綻への気づきを遅らせているという点で、むしろ限りなく悪い。</p>
<p>よって、内部で片っ端からDispatcherにBeginInvokeする代わりに、AddOnSchedulerなど、(ReactiveCollection生成時に指定した/デフォルトはUIDispatcher)スケジューラ上で操作を行うと利用側が明示するアプローチを取ってみました。Rxには使い勝手の良いISchedulerが存在する。だからこそアリなやり方かな、と思います。この辺はまだまだ考えどころだと思いますので、ご意見ありましたらお願いします。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;ListBox ItemsSource=&quot;{Binding TimeItems}&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ToaruViewModel
{
    public ReactiveCollection&lt;string&gt; TimeItems { get; private set; }

    public ToaruViewModel()
    {
        // 1秒毎に現在時刻表示が追加されるコレクション
        TimeItems = Observable.Interval(TimeSpan.FromSeconds(1))
            .Select(_ =&gt; DateTime.Now.ToString())
            .ToReactiveCollection();
            
        // 5秒間隔で上記コレクションをクリアする
        Observable.Interval(TimeSpan.FromSeconds(5))
            .Subscribe(_ =&gt; TimeItems.ClearOnScheduler());
    }
}
</code></pre>
<p>今回考えるにあたっては<a href="http://shinichiaoyagi.blogspot.com/2011/06/net-observablecollection.html">青柳 臣一 ブログ（技術系）: [.NET] スレッドセーフな ObservableCollection&lt;T&gt; が欲しい</a>をとっても参考にさせて頂きました。</p>
<p>ReactiveProperty, ReactiveCommandは確固たる意思のもとに作ったんですが、ReactiveCollectionは非常に中途半端でした。が、今回ようやく理念が立てれたのではかと思います。なお、ObservableCollection/ReactiveCollectionにはObserveAddChangedなど、変更通知をIObservableで受け取ることのできる拡張メソッドを足してあるので、そちらも便利に使うことが可能です(素のNotifyCollectionChangedEventArgsはIList(ジェネリックじゃない！)であったりして非常に触りにくいので、その辺をきっちり整理してあります)。</p>
<p>とか言ってますが、コードにしたらたかが十数行なのですよね。それを決めるのに、ここ一週間ずっと考えてました。つまり私の生産性は一日一行です(ｷﾘｯ</p>
<h2>まだ追加してないもの</h2>
<p>Validation周りをValidationSummaryやDescriptionViewerに対応させる。とか、OnErrorRetryが値を返せるようにする。などは次に載せるつもりです。これらを加えてから、と思ったんですがReactiveCollectionの変更が大きいので、先に出したくて見送りました。</p>
<h2>ReactiveProperty-Experimental</h2>
<p>今回からExperimental版のRxにも対応しました。NuGetでは<a href="http://nuget.org/List/Packages/ReactiveProperty-Experimental">ReactiveProperty-Experimental</a>です。しかし、
.NET 4.5やWinRTへの対応は、まだしていません。せっかくRx(Experimental)がWinRT対応したので、それに合わせたいと思ったのですが断念。理由としてはVS11がCode Contractsに対応していないから、です。Code Contractsのバイナリリライトかけないと動かないので、どうにもなりません……。それがなければ今すぐにでも対応させたいのですけれどねえ。こういう時に機敏に動けないのはとても悲しいので、次回からはCode Contractsの採用は見送りたいと思ってしまいます……。</p>
<p>ところで、それを意識してではありますが、.NET 4.0版のDLL名をReactiveProperty.NET40.dllに変えました。複数プラットフォームに対応する場合、全てのDLLを同じ名前にする(JSON.NETなどはそうですね)か、全てのDLLにプラットフォームの識別子をつける(MVVMLightなどはそうです)か。前者のほうがスマートではあるのですが、分かりやすさを考え、後者を選びました。Stable版とExperimental版の区別もありますし、DLL名から判定出来たほうがいいかな、と。</p>
<h2>今後</h2>
<p>okazukiさんの記事にもあるように「MVVMライブラリにも精通しつつReactive Extensionsのことも知っててReactivePropertyの概要を把握してないといけない上に必要に応じてMVVMライブラリとReactivePropertyを繋ぐような機能を作りこまないといけない」きゃー、難しそう！でも事実だ！</p>
<p>私としてはReactivePropertyを通してReactive Extensionsを学習してもらえればいいかなあ、と思っています。Rxはイベントが合成出来る！というけれど、合成しようにもイベントのソースがないと始まらない。ReactivePropertyを使うと、手軽に合成のためのソースが手に入るので、イベント周りのRxでのこね方の学習に最適なのではかと思います。……多分。</p>
<p>既存MVVMライブラリとの使い分けなどに関しては、この類の「選択肢が増えます系」の永遠の課題ですねえ。結局、どう使い分けるかの判断をユーザーに丸投げしているわけですもの。ガイドなどを掲示できればベストなのですが、そもそも私がMVVMに全然詳しくないのであった。そもそも私自身がどう使えばいいのか分かってないぐらいなので(えー)、触ってみて、ついでに足りなかったり、これがこうなってたらいい、とかいう思いがあったら、私がそういうのに全然気づいてない確率100%なので、是非言ってやってください。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-14" data-pagefind-meta="published:2011-10-14"><a href="https://neue.cc/2011/10/14_348.html">Reactive Extensions v1.1.11011.11リリースに見る.NET 4.5からの非同期処理</a></h1>
<ul class="date"><li>2011-10-14</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の<a href="http://www.microsoft.com/download/en/details.aspx?id=27724">v1.1.11011 (Experimental Release)</a>がリリースされました。リリース対象はExperimental(実験)版のみです。Stable(安定)版のほうは変更ありません。別件で少しコメントで質問したところ、近いうちにStable版の更新もあるかも、とのことでしたので、Stableはそちらを待ちましょう。<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/23062737-e154-41af-99f6-45d819992254">リリース内容の詳細な解説はフォーラムにあります</a>。</p>
<p>今回の大きな追加は<a href="http://msdn.microsoft.com/en-us/netframework/hh403373">.NET Framework 4.5 Developer Preview</a>と<a href="http://msdn.microsoft.com/en-us/windows/apps">WinRT</a>への対応です。というわけで、WinRT関連では、WinRT用のスケジューラであったりイベントであったりへの対応とまぁまぁ想像つく普通のもの。あと非同期処理を他言語と結びつけるIAsyncOperationへの書き出し、などなどもサポートされるようですね。</p>
<p>そして.NET 4.5周りでは、C#5.0のAsyncサポート・クラスライブラリがTask中心に書き換わることが念頭に置かれ、大規模に変更が入っています。今後のRxの方針がよく見えますので、Experimentalではありますが注意深く観察してみる必要がありそうです。というわけで、しっかり紹介します。なお、以下の話は.NET 4.5のRxの話なので、.NET 4.0以前の場合では直接は関係なく、Obsoleteにもなっていません。が、将来フレームワークのバージョン上げたらObsolete祭りでモニョるのは覚悟が必要かしらん。もう一つ注意としては、あくまでExperimentalなので、将来的にもこのままかどうかは保証されません。現時点での話です。</p>
<h2>FromAsyncPatternがObsolete</h2>
<p>はい、Obsoleteです。理由としては、.NET 4.5では多くのメソッドがBegin-Endパターンの代わりにTaskを返すXxxAsyncメソッドを持っています。そしてTaskとIObservableは相互に変換可能だから、Rxで扱いたいならXxxAsync().ToObservableすればいいでしょ、ということでした。Begin-EndパターンなのにXxxAsyncを持っていないメソッドにはどうするんだ！という場合は、TaskFactory.FromAsyncがあるので、それ使えばいい、とのこと。まあ、それはレアケースなので滅多にないかな。</p>
<p>毎回ToObservableなんて面倒くさい、という人のためにSelectManyに限っては、Taskを受け取るオーバーロードが用意されているので、ToObservableは不要です。内部では予想つく通り、ただ単にToObservableしているだけですね。その他の合成系メソッド(MergeやSwitch)などは残念ながらというか当然というか、ToObservableしてください。</p>
<h2>IObservableはAwaitable</h2>
<p>IObservable&lt;T&gt;も非同期を扱うものなので、awaitできます。正確に言えばGetAwaiterが定義された、といったところでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var req = WebRequest.Create(&quot;http://google.com/&quot;);
var response = await Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)();
</code></pre>
<p>基本的にRxの非同期はFromAsyncPatternを初めとして長さが1のものを扱っていますが、複数の値が流れる場合はどうなるかというと、挙動は「最後の値」です。正確に言えばAsyncSubjectが利用されているので、OnCompletedの直前のOnNextの値。ではEmpty(OnCompletedのみ)やNever(何もなし)ではどうなるのか、というと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 10(最後の値)
var a = await Observable.Range(1, 10);
            
// InvalidOperationException(シーケンスに値がない)
var b = await Observable.Empty&lt;int&gt;();
            
// ある意味フリーズ、ここで永遠に止まる
var c = await Observable.Never&lt;int&gt;();
</code></pre>
<p>となります。これだけ見るとNeverって使い道がイミフですが、何かとMergeする必要があるときに、マージ対象がないときはNeverを渡すなどなど、ライブラリに近い部分では結構使う場所あります。私の書いているReactivePropertyというライブラリでもそうして利用しています。</p>
<h2>FirstなどがObsolete、かわりにFirstAsyncなどとWaitが追加</h2>
<p>え？という感じですがObsoleteです。対象はFirst,Last,Single、それとForEachも。FirstOrDefaultなど、XxxDefault系も同様です。つまり同期的にブロックするタイプのものが全てObsolete行きになりました。代わりにFirstAsyncなどXxxAsyncが用意されています。それとawaitを組み合わせてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var source = Observable.Return(&quot;async?&quot;);

var value0 = await source; // LastAsyncと挙動は同じ
var value1 = await source.FirstAsync();
var value2 = await source.LastAsync();
</code></pre>
<p>長さ1と分かっている状況なら、何もなくそのままawaitでも良いのではかしらん。LastAsyncがそれに相当しますね。さて、しかしawaitのお陰で同期的「のように」書けるには違いないけれど、FirstやLastなどはブロックして「同期」な挙動を取っていたわけなので、単純にObsolete行きにされたら困ってしまいます。そこで、同期的に待機して最後の値を取り出すWaitメソッドが用意されました(これは.NET 4.0やSilverlightなどでも使える、新たに追加されたメソッドです)。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var source = Observable.Return(&quot;async?&quot;);

var value0 = source.Wait();
var value1 = source.FirstAsync().Wait();
var value2 = source.LastAsync().Wait();
</code></pre>
<p>ちなみにWaitの中身はLastです。Lastという名前から離して、同期的に待機して値を取り出す、と明示させたのですね。それはいいと思います。Waitはいい。Waitはいいんですが、FirstをObsoleteにしてFirstAsyncを追加するのは、正直気にいりません。私は反対です。</p>
<p>ターゲットフレームワーク間でコードが共有出来なくなる、IQbservableプロバイダに影響が出る、そもそも標準クエリ演算子から離れるのはどうよ。などなど。だいたい、AllやAny、Maxなどは長さ1のIObservable&lt;T&gt;を返すようになっていました。Firstなどだけです、同期的に待機して値を取り出す、という別の意味が与えられていたのは。だから、ここはFirstはObsoleteにせず、FirstAsyncの挙動、つまりIObservable&lt;T&gt;を返すように変更すればいいのです。同期待ちについては、Waitが搭載されたので心配無用です。これで、全ての挙動に統一が取れる。</p>
<p>唯一問題点を挙げれば、本当に本当に「破壊的変更」になるんですよね。それも、Stableとか銘打ったものへの影響も出る。メソッド名同じで戻り値が変わる。そういう変更を許せるものか。私は、許してしまってもいいと思うのですけれど。Firstを廃止してFirstAsyncを追加、などという歪な形を将来に残すよりかは、ずっといい。</p>
<p>なので、Forumにもそうコメント入れましたところ返答貰えました。「Stableリリースが存在する以上、XxxAsyncのままでいるしかない。これが不幸なことは同意しますけれど、暫くはこのままでいるしかない。」とのことでした。というわけで、Stableと銘打つのが早まったな…… としか言いようがなく。あの段階でここまで読めなかったのはしょうがないところ、と思いつつ、やはり手痛いミスかなあ。うーん、将来に渡っての完璧なAPIを作り上げるというのは実に難しい。</p>
<p>まあ、Firstを多用する(といっても単体テストや動作確認時ぐらいですけど)のは、値を一つ取り出したい、ということなので、await sourceかsource.Wait() で済む。FirstAsyncやLastAsyncを直接使うことは恐らく少なくて、ならば実際上の問題というのはそこまでないかもしれません。</p>
<h2>長さ1の非同期処理の戻り値はTaskを選ぶべきか、Rxを選ぶべきか</h2>
<p>メソッドを作るときの非同期処理の戻り値。これは、Taskを選ぶべきです。それは.NET標準と合わせるべきという理由からもそうですし、この.NET 4.5向けのRxの指針からしてそうなっています。長さ1のIObservableで非同期を表現する、というのは特殊だったと言わざるを得ないので、メソッドを作るとき、非同期処理の戻り値はTaskにしたほうが間違いなく良いでしょう。</p>
<p>ただ、アプリケーショに全体でRxによる合成を中心に置く場合は、ToObservableが面倒くさい、というだけじゃなく逆にオーバーヘッドになる可能性もあるので、IObservable中心にしたほうが良いでしょう。この辺は一概には言えずケースバイケースでしょうか。どちらにせよToObservable&lt;-&gt;ToTaskで相互変換が可能なわけなので、あまりガチガチに捉える必要もないですけれど。</p>
<p>あと、あくまで.NET 4.5の話でasync/awaitが入るからTaskのほうが良いと言ってるのであって、.NET 4.0以前ならまた違う話です。というかその場合だとRx一択です。</p>
<h2>ねぇ、Rxってもう要らない子？</h2>
<p>時代の徒花でしたね、短い命だった……。</p>
<p>って、ちょっと待ったー。それはYESでもあり、NOでもあります。YESなのは、単純な形での非同期処理ならば、遥かに楽になりますし、それに何よりもRxを通すよりもパフォーマンスは良いと思われるので、むしろasync/awaitを使うべきです。具体的には、SelectManyしてSubscribeするだけ、あとCatchで少し例外処理、みたいなコードなら、もう全面的にRxさようならでいいでしょう。</p>
<p>でも往々にしてそういう処理だけじゃないよね？以前にも紹介しましたがSwitch（新しい処理が入ったら以前の非同期処理はキャンセルして新しい処理のみを後続に流す）などを手書きせず演算子一つにパッケージ化できることや、全体的にTaskのメソッド群よりも合成や待ち合わせが容易に記述できる、などなど。そして、「複数の戻り値のある非同期処理、例えばStreamのBeginReadは細切れにbyte[]が得られますが、それを複数回分の非同期処理をまとめてシーケンスとして、IObservable&lt;byte[]&gt;としてまとめることは現状ではRxしかできません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 複数回のBeginReadをRx+Asyncで一つにまとめる例
static IObservable&lt;byte[]&gt; ReadMultipleAsync(Stream stream, int bufferSize)
{
    return Observable.Create&lt;byte[]&gt;(async observer =&gt;
    {
        try
        {
            while (true)
            {
                var buffer = new byte[bufferSize];
                var readCount = await stream.ReadAsync(buffer, 0, bufferSize);

                if (readCount == 0) break;
                if (readCount != bufferSize)
                {
                    var newBuffer = new byte[readCount];
                    Array.Copy(buffer, newBuffer, readCount);
                    buffer = newBuffer;
                }

                observer.OnNext(buffer); // yield returnのノリで書く
            }
            observer.OnCompleted(); // 完了合図と
        }
        catch (Exception ex)
        {
            observer.OnError(ex); // 例外は自前で明示的に
        }
    });
}
</code></pre>
<p>ExperimentalリリースではObservable.Createがasync/await対応しているので、擬似的なyield returnとして、非同期での列挙をそこそこ簡単に記述することができます。OnErrorとOnCompletedは自前で管理する必要がありますけれど。</p>
<p>なので、メソッド単体で分けた場合の戻り値は「長さ1」ならTask、複数ならIObservable。それらメソッドを使って非同期処理を組み上げる時は、単純ならawaitのみ、複雑ならRx。というのが使い分けの指針です。とはいえ、使い分けっていうのは幻想に近くて、実際はどっちか一つになりがちだとは思っています。そして、それならTask中心になるでしょうねえ、とも。非同期における大抵のシチュエーションでRxがサヨウナラ気味になるのはしかたのない話です。ぶっちゃけSelectManyしてSubscribeがほとんどだし、それ以外のことだって、同期的のように書けるのなら、いくらでもやりようはありますから。</p>
<p>まあ、未来を待たなくても今使える解としてなら十分ですし、それ自体がawait可能なので、今書いたコードは将来に渡っても無駄にはなりません。FromAsyncPatternがObsoleteというのは、まあ単純に.NET4.5本来のXxxAsyncに置き換えればいいというだけなので無駄になる、とは言わないでしょう。</p>
<p>けれど、それだけじゃあ、すごく後ろ向きで、寂しいよね。Rx自体の持つ力というのは、別に非同期に限らない。ただの幾つもある側面のうちの一つにすぎない。そこで出した私の答えが<a href="http://neue.cc/2011/10/07_346.html">ReactiveProperty : WPF/SL/WP7のためのRxとMVVMを繋ぐ拡張ライブラリ</a>です。ReactivePropertyはC#5.0によってプレゼンスが低下するReactive Extensionsに新たな価値をもたらしたいという危機感から作ったものだったりします(後付け、じゃなくてこれは本当の話です、次の一手を指すならRx自体に注目の集まっている今しかない、とも)</p>
<p>ReactivePropertyを通して見ると、非同期だけではない、Rxの持つポテンシャルがよく分かるのではないでしょうか？Rxの真の強みはイベント単独や非同期単独ではなくて、それらが、ただの配列も含めて、統一的に扱える、だから全て一本のストリームになって合成処理が自由自在。というOrchestrateな部分にある。ReactivePropertyはそれを全面的に押し出してます（半強制的に全てが一本に繋がるようになってる）</p>
<p>Rxは、この先も力強く存在し続けるので、学習する価値は間違いなくありますよ！</p>
<h2>まとめ</h2>
<p>相変わらずフリーダムな変更が続いているRxですが、あくまでExperimental版の話です。Stableでは、こんなバカバカと変わっていくことはないので、安心して使えばいいです。あと、Experimentalなのでまだまだ変動の余地はある、と思いますので、意見あればForumで直接言っておくとよさそう。私も、何やらかんやらと意見言っておきました(昔は書くのにビビッてたのに、今は平然と書いててアレです、慣れですね、ようするに)。</p>
<p>ところでRxは.NET 4.5に標準搭載されるのか否か、ですが、なんかまだまだ全然色々と変更や模索する気満々なようなので、この様子だと、仮にそういう話があったとしても間に合わなさそうという点で、標準搭載はなさそうですねー。ほぼ完成してるのに標準入りしない、とかだと悲しいんですが、そういう形で標準搭載見送り、ならばむしろ喜ばしい話なので、いいかなー、と思います。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>それにしてもRx本は出すタイミング難しいですねえ。今回の変更は非同期周りの話がガラッと変わってきちゃうわけなので。また延期かしらねえ。さすがにそれはないか。ところで私もLINQ + Rx本をオライリーから出したいです(←ただたんに表紙をデンキウナギ(Rxのロゴはピンクのデンキウナギ)にしてウナギ本と呼ばれたいという一点だけの話なので間に受けないでください)</p>
</div>
<h1 data-pagefind-sort="date:2011-10-11" data-pagefind-meta="published:2011-10-11"><a href="https://neue.cc/2011/10/11_347.html">ReactivePropertyのデモをしました</a></h1>
<ul class="date"><li>2011-10-11</li></ul>
<div class="entry_body"><p><a href="http://silverlightsquare.com/index.php/tokyo04.html">Silverlightを囲む会in東京#4</a>にて、<a href="http://neue.cc/2011/10/07_346.html">先日公開したReactiveProperty</a>についてお話しました。</p>
<div style="width:595px" id="__ss_9602585"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/reactiveproperty-slintokyo4" title="ReactiveProperty - slintokyo4" target="_blank">ReactiveProperty - slintokyo4</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/9602585" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>本題のセッションの後の、お楽しみセッションということで、LT的に5分程度とか思っていたつもりなのですが、大幅に時間オーバーして17分も喋っていました。これは酷い。色々と寛容に見て頂き感謝です。さおさんありがとうー。IIJさんも本当にありがとうございます。時間オーバーを許してくれたというのと(笑)、それと、ネットワークが良好だったお陰でTwitterインクリメンタルサーチのデモが出来たので。毎度ながら凄まじい画質のSmooth Streamingといい、神会場すぎます。</p>
<p>いつまで残るか分かりませんが、会場で行ったセッションの録画です。<a href="http://live.streamingmedia.jp/slintky04/">Silverlight を囲む会 in 東京 #4 @ IIJ 神保町三井ビル</a>。私のセッションは04:01:30 - 04:19:00です。ライブコーディングしているのは04:05:30-04:16:30ですね。</p>
<p>色々アレゲなのはいいとして、以前にスマベンで話をしたときにも反省事項だったのですがすっかり失念してた声の小ささはダメですねー。次は気をつけます。むしろ早口気味なのかと気にしてたんですが、録画を見るとそうでもないというか、このぐらいで調度良いぐらいですね。スライドはちゃっちゃと進めて欲しいし、本題のDemoは素早く進行して欲しいですから。ライブコーディングは好評だったようで何よりです。ちなみに、スムーズにプログラム書いていて凄い！と評価いただきましたが、やる内容が決まっているから書けたというだけで、例えばギターやピアノの演奏などと同じなわけで、普段は頭抱えながらゆったり書いてます。</p>
<p>ちなみに最後のTwitter検索のコードは若干アレだったので、修正したのをここに載せておきます。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, UpdateSourceTrigger=PropertyChanged}&quot; /&gt;
    &lt;ListBox ItemsSource=&quot;{Binding SearchResults.Value}&quot; /&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MainWindowViewModel
{
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveProperty&lt;string[]&gt; SearchResults { get; private set; }

    public MainWindowViewModel()
    {
        CurrentText = new ReactiveProperty&lt;string&gt;();

        SearchResults = CurrentText
            .Select(word =&gt; new WebClient()
                .DownloadStringObservableAsync(&quot;http://search.twitter.com/search.atom?q=&quot; + Uri.EscapeUriString(word)))
            .Switch()
            .Select(s =&gt;
            {
                var xml = XElement.Parse(s);
                var ns = xml.Name.Namespace;
                return xml.Descendants(ns + &quot;title&quot;).Select(x =&gt; x.Value).ToArray();
            })
            .OnErrorRetry((WebException e) =&gt; Debug.WriteLine(e))
            .ToReactiveProperty();
    }
}
</code></pre>
<p>SelectManyよりもSelect-&gt;Switchのほうがいいのと、OnErrorRetryの書く場所は、WebClientの真下だと永遠にリクエストをリピートしちゃうのでダメでしたね。</p>
</div>
<h1 data-pagefind-sort="date:2011-10-07" data-pagefind-meta="published:2011-10-07"><a href="https://neue.cc/2011/10/07_346.html">ReactiveProperty : WPF/SL/WP7のためのRxとMVVMを繋ぐ拡張ライブラリ</a></h1>
<ul class="date"><li>2011-10-07</li></ul>
<div class="entry_body"><p class="noindent">
	<img style="width:640px" src="http://neue.cc/wp-content/uploads/image/RxMVVMLoop.jpg">
</p>
<p>MVVM拡張、という言い方が適切かは不明ですが、ともあれ、RxでXAMLによるUIシステムとの親和性を高めるライブラリを作成し、リリースしました。</p>
<ul>
<li><a href="http://reactiveproperty.codeplex.com/">ReactiveProperty - MVVM Extensions for Reactive Extensions</a></li>
</ul>
<p>中身は大きく分けて二つで、一つはReactivePropertyというXAMLと双方向にバインド可能なIObservable&lt;T&gt;、ReactiveCommandというIObservable&lt;bool&gt;からCanExecuteの条件を宣言的に生成するコマンドなど、MVVM的なUI絡みのクラス群。もう一つはWebClientやWebRequestなど、非同期処理のための拡張メソッド群になります。</p>
<p>名前はUI中心に見えますが、UI絡みはいらないよ、という人は非同期周りだけを使ってくれても問題ありません。それと、機能紹介の前に一つ。決して既存のMVVMフレームワークを置き換えたり、同等の機能を提供するものではありません。ViewModelBaseやMessengerなどに相当するものはないので、その辺は適宜、既存のMVVMフレームワークを使えばいいと思います。というか、併用することを推奨します。だから「拡張ライブラリ」と名乗っています。</p>
<h2>UIへのバインディング</h2>
<p>ReactivePropertyとは何か。というと、双方向にバインド可能なIObservable&lt;T&gt;です。まず、ViewModel(Model)-&gt;Viewという片方向のバインドを見てみましょう。時計のようなものを作ります。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;TextBlock Text=&quot;{Binding DisplayText.Value}&quot;  HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class SimpleClockViewModel
{
    // 双方向にバインド可能なIObservable&lt;T&gt;
    public ReactiveProperty&lt;string&gt; DisplayText { get; private set; }

    public SimpleClockViewModel()
    {
        // 1秒毎に値を発行、Selectで現在時刻に変換してToReactivePropertyでバインド可能にする
        DisplayText = Observable.Interval(TimeSpan.FromSeconds(1))
            .Select(_ =&gt; DateTime.Now.ToString())
            .ToReactiveProperty();
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=0" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>XAML側ではDisplayText.Valueというように、.Valueまで指定してバインドします。実に簡単にIObservableがバインドできると分かるのではないでしょうか？</p>
<p>IObservableとは、時間軸に沿って値が変わるものです。Intervalはx秒置きに等間隔で変わるので、まさに「時間」といったものですが、それ以外のものも全て時間軸に乗っていると考えることが可能です。例えばイベント、クリックやマウスムーブ、ジェスチャーやセンサーイベントで考えると、タッチした、x秒後にまたタッチした、x秒後にまたタッチした…… 発行される時間が不定期なだけで、時間軸に沿って次の値が出力されるという図式は同じです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rxeventime.jpg">
</p>
<p>非同期処理もそうで、x秒後に一回だけ値が来る。Rangeや配列のToObservableは0.0001秒刻みに値が来る。Rxで、IObservableで表現することが出来る値というのは、時間軸に乗って変わる/発行する値ということになります。そして、見渡してみると、IObservableになる、時間によって変わるという表現がマッチするものは意外と多い。特にリッチクライアントでは。UI自身の値の変化(バインディング/イベントによる通知)もそうだし、ModelのINotifyPropertyChangedもそう。INotifyPropertyChangedとは、或るプロパティの値が変化したという通知を行うオブジェクト。そのプロパティだけに着目してみれば、時間軸上で連続的に変化する値とみなせる、つまりIObservableで表現できます。</p>
<h2>UIからのバインディング</h2>
<p>では、UIからのバインディングもしてみましょう。これは、空のReactivePropertyを作成してバインディングします。これにより、UIからの入力をIObservableとして他へと中継することができます。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;!-- このTriggerは入力と同時に発火させるために(SL4では)必要なもの --&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, Mode=TwoWay}&quot;&gt;
        &lt;i:Interaction.Behaviors&gt;
            &lt;prism:UpdateTextBindingOnPropertyChanged /&gt;
        &lt;/i:Interaction.Behaviors&gt;
    &lt;/TextBox&gt;
    &lt;TextBlock Text=&quot;{Binding DisplayText.Value}&quot; /&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class FromUIViewModel
{
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveProperty&lt;string&gt; DisplayText { get; private set; }

    public FromUIViewModel()
    {
        // UIからのテキスト入力の受け口
        CurrentText = new ReactiveProperty&lt;string&gt;();

        // そして、それを元にして加工してUIへ返してみたり
        DisplayText = CurrentText
            .Select(x =&gt; x.ToUpper()) // 全て大文字にして
            .Delay(TimeSpan.FromSeconds(3)) // 3秒後に値を流す
            .ToReactiveProperty();
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=1" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>Interaction.Behaviorは本題とは関係なくて、値の更新通知のタイミングを、値の変更と同時にするためのものです（デフォルトだとフォーカスが移ったときかな）。WPFでは、こういった小細工がなくてもいいのですが、SL4,WP7では必要なので已むを得ず。詳しくは <a href="http://code.msdn.microsoft.com/Silverlight-4TextBoxTextBin-3edebee5">Silverlight 4のTextBoxのTextプロパティの変更のタイミングでBindingのSourceを更新したい - MSDN Samples Gallery</a> に。というわけで、このUpdateTextBindingOnPropertyChangedはPrismからコピペってきたものです。</p>
<p>さて、入力の受け付けをベースにするものは、newで空の物を作ります。出力中心のものはToReactivePropertyなわけですね。あとは、文字が非連続的に、(同じスレッド上の)非同期でやってくるので、LINQで加工します。Selectで大文字にして、そして、Rxなので時間系のものも使えるので、Delayを使ってみたりしながら、UIに戻しました。なお、Delayの時点で値の実行スレッドはUIスレッドからスレッドプールに移りますが、ReactivePropertyを使う限りは、ReactiveProperty内部でスレッド間の値の通知を解決するため、Dispatcher.BeginInvokeも、ObserveOnDispatcherも不必要です。実行スレッドを意識するなんて原始的ですよね、ReactivePropertyなら、全く意識する必要がなくなります。非同期は自然のまま非同期で扱える。だって、そもそも全てが非同期なのだもの。</p>
<h2>ReactiveCommand</h2>
<p>ReactivePropertyのもう一つの大事な機構が、ReactiveCommandです。これは、IObservable&lt;bool&gt;という、実行可否の変化のストリームからICommandを生成します。一般的なMVVMフレームワークで使われるRelayCommand, DelegateCommandとは発想が異なるのですが、私はこのReactiveCommandのアプローチこそがベストだと考えます。まずは例を。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;StackPanel&gt;
    &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked1.Value, Mode=TwoWay}&quot;&gt;CheckBox1&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked2.Value, Mode=TwoWay}&quot;&gt;CheckBox2&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked3.Value, Mode=TwoWay}&quot;&gt;CheckBox3&lt;/CheckBox&gt;
        &lt;CheckBox IsChecked=&quot;{Binding IsChecked4.Value, Mode=TwoWay}&quot;&gt;CheckBox4&lt;/CheckBox&gt;
    &lt;/StackPanel&gt;
    &lt;TextBox Text=&quot;{Binding CurrentText.Value, Mode=TwoWay}&quot; /&gt;
    &lt;Button Command=&quot;{Binding ExecCommand}&quot;&gt;Execute?&lt;/Button&gt;
&lt;/StackPanel&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Extensions; // 拡張メソッドを使う場合はこれを忘れず。

public class CommmandDemoViewModel
{
    public ReactiveProperty&lt;bool&gt; IsChecked1 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked2 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked3 { get; private set; }
    public ReactiveProperty&lt;bool&gt; IsChecked4 { get; private set; }
    public ReactiveProperty&lt;string&gt; CurrentText { get; private set; }
    public ReactiveCommand ExecCommand { get; private set; }

    public CommmandDemoViewModel()
    {
            var mode = ReactivePropertyMode.RaiseLatestValueOnSubscribe | ReactivePropertyMode.DistinctUntilChanged;

            IsChecked1 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked2 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked3 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            IsChecked4 = new ReactiveProperty&lt;bool&gt;(mode: mode);
            CurrentText = new ReactiveProperty&lt;string&gt;(
                initialValue: &quot;テキストが空の時はボタン押せないよ&quot;,
                mode: mode);

            ExecCommand = IsChecked1.CombineLatest(IsChecked2, IsChecked3, IsChecked4, CurrentText,
                    (a, b, c, d, txt) =&gt; a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; txt != &quot;&quot;)
                .ToReactiveCommand();

            ExecCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;Execute!&quot;));
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="150px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=2" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>全てのチェックがONで、かつ、テキストボックスに文字が含まれていないとボタンを押せません（テキストボックスの値の判定はフォーカスが外れてからになります）。CombineLatestというのは、二つの値のうち、どちらか一つが更新されると、片方は新しい値、片方はキャッシュから値を返して、イベントを合成するものです。もし片方にキャッシュがない場合はイベントは起こしません。「二つの値」というように、標準では二つの合成しか出来ないのですが、ReactivePropertyではこれを拡張して7つの値まで同時に合成できるようにしました（それ以上合成したい場合は、匿名型にまとめて、再度CombineLatestを繋げればよいでしょう）。この拡張はCodeplex.Reactive.Extensionsをusingすることで使えるようになります。Extensions名前空間には、他にも有益な拡張メソッドが大量に定義されていますので、是非覗いてみてください。</p>
<p>さて、つまりCombineLatestの結果というのは、ボタンが押せるか否かの、条件のストリームです。どういうことかというと、連続的なCanExecuteです。なので、そのままICommandに変換してしまいましょう、というのがToReactiveCommandになります。CanExecuteに変更があることを、条件のほうからPushして伝えるので、従来使われてきたコマンドを集中管理するCommandManager.RequerySuggestedや、(イベントなので)本来外から叩けないCanExecuteChangedを外から叩けるようにする、などの手立ては不要です。</p>
<p>常にtrueのコマンドならば、new ReactiveCommand()で生成できます。</p>
<p>ところで、mode: ReactivePropertyMode.RaiseLatestValueOnSubscribe というのは、Subscribeされる時に(ToReactivePropertyやToReactiveCommandは内部でSubscribeしています)、同時に最新の値を返します(最新の値がない場合は初期値を返します。初期値は指定することもできますし、もし指定していない場合はdefault(T)になります)。どういうことかというと、判定のタイミングの問題があります。CombineLatestは全てに一度は値の通知が来ている(キャッシュが存在する)状態じゃないと、イベントを起こしてくれません。なので、CanExecuteを初回時から判定させるために、これの指定が必要です。なお、ReactivePropertyModeのデフォルトはDistinctUntilChangedのみで、RaiseLatestValueOnSubscribeは明示的に指定しなければなりません。一件便利そうに見えるRaiseLatestValueOnSubscribeですが、問題も抱えていまして、後でも詳しく説明しますがバリデーションの時。バリデーションの場合は初回実行はして欲しくない（画面を表示したら、いきなり真っ赤っかだと嫌でしょう？）ケースがほとんどのはずです。RaiseLatestValueOnSubscribeを指定すると、初回実行してしまうので、そういう場合にとても都合が悪いのです。これは、良し悪しなので、適宜判断して、最適な方をお選びください。</p>
<h2>宣言的であるということ</h2>
<p>ReactiveCommandは、条件を宣言的に記述しました。そして、外部から叩くことは禁じられているので、その宣言以外のことが絡む可能性はありません。また、状態を外部変数から取得する(RelayCommandなどはそうなりますね)わけではないので、CanExecuteの変化のスコープはToReactiveCommandをする一連のシーケンスを読むだけですみます。変数を返す場合は、変数を使う範囲、つまりオブジェクト全体から変更可能性が混ざるという、大きなスコープの観察を余儀なくされます。読む場合だけでなく、書く場合でも、集中的に変化の条件を記述することができるので、ずっと楽でしょう。</p>
<p>ReactivePropertyもまた、同じです。値の変化の条件を宣言的に記述しました（こちらはReactiveCommandと違い、(Two-wayでバインド可能にするという都合上外部から叩くことが可能なのでスコープは閉じていませんが）。大事なのは、スコープを小さくすること。大きなスコープは往々に管理しきれないものです。リッチクライアントはステートを持つ。その通りだ。プロパティが、オブジェクトが、絡みあう。それは実に複雑なのは間違いない。でも複雑だから難しくて当然、複雑だからテストできない、複雑さを複雑なまま放っておいたら、それはただの新世代のスパゲティにすぎない。</p>
<p>ステートを捨てようじゃあなくて、宣言的にやろう。それがReactivePropertyの解決策、提案です。</p>
<h2>INotifyPropertyChangedと一緒に。</h2>
<p>全てReactivePropertyで相互作用を記述する、というのは理想的ですが過激派です。それに、既存のModelや自動生成のModelなど、様々なところにINotifyPropertyChangedはあります。理想だけじゃ生きていけません。それに、私もプレーンなModelはPOCO(+INotifyPropertyChanged)のほうが嬉しい。でも、IObservableになっていないと、関係の合成が不可能で困るので、INotifyPropertyChanged -&gt; ReactivePropery変換を可能にしました。ここでは説明しませんが、その逆のReactiveProperty -&gt; INotifyPropertyChanged変換も可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Extensions; // ObservePropertyもこれをusingで。

public class ObserveViewModel
{
    public ReactiveProperty&lt;string&gt; ModelText { get; private set; }

    public ObserveViewModel()
    {
        ModelText = new ToaruModel()
            .ObserveProperty(x =&gt; x.Text) // タイプセーフにIObservable&lt;T&gt;に変換
            .ToReactiveProperty();
    }
}

// WCFからだったりEntity Frameworkだったり既存のModelだったり他のViewModelだったり
// ともかく、INotifyPropertyChangedは至る所に存在します
public class ToaruModel : INotifyPropertyChanged
{
    private string text;
    public string Text
    {
        get { return text; }
        set { text = value; PropertyChanged(this, new PropertyChangedEventArgs(&quot;Text&quot;)); }
    }

    public event PropertyChangedEventHandler PropertyChanged = (_, __) =&gt; { };
}
</code></pre>
<p>INotifyPropertyChangedの仕組みって、とあるプロパティが変更された、と名前でPushして、変更通知を受けた方はその名前を元にPullで取り出す。描画フレームワークが面倒を見ているなら、それでいいのですが、通常使うには、とてもまどろっこしい。だから、そうしたオブジェクトという大きな土台から名前ベースのPush &amp; Pull通知を、プロパティ単位の小さなPush通知に変換してやりました。指定はExpressionで行うのでタイプセーフですしね。</p>
<p>ReactivePropertyのほうがINotifyPropertyChangedよりも細かいハンドリングが効くのは当たり前の話で、単位が小さいから。逆に、だから、INotifyPropertyChangedという大きい単位で関係を作り込んでいくのは、非常に複雑でスパゲティの元だと言わざるを得ない。勿論、Reactive Extensionsという、プロパティ単位でのPushを自在に扱う仕組みが背後にあってこそのやり方ではあるのですが。</p>
<h2>MとVMの境界</h2>
<p>が、曖昧にみえるのはその通りかもしれません。けれど、処理がVMに偏りすぎるように見えるのなら、それは素直にMに移せばいい。細かいMを束ねるMを導入すればいい。名前は、サービスでもファサードでもプロキシーでもアプリケーションでもコントローラーでも、なんでもいい(わけではないけれど)。移せばいいなんて簡単にいいますが、それは簡単にできるからです。VM-M-VMが一気通貫してループを描いているなら、ローカル変数への依存もなくメソッドチェーンを切った貼ったするだけなので、どこに置くのも移すのは楽です。</p>
<p>そもそも、最初から明確に分けようとしたってどうせうまくいかないもの。インターフェイスだって、具象型から抽象を見出したほうが簡単だし、ずっとうまくいくでしょう？ネーミングだってリファクタリングで徐々に洗練させる。そもそもVMがヘヴィになりがちなのは、目で見える境界がないから、なせいでしょう。VはXAMLで線引きされるけれど、それ以外はコードで地続き。理想論だけで線を引こうとしたって空疎だし、そもそも、無理な話。境界を見出すには具体的に積み重なった後じゃないと無理でしょう(勿論、境界の敷き方を常日頃考える、研究することは有意義だと思います。そもそも考えていないと、いざ境界を見出そうとしても見えませんから)</p>
<h2>そもそもMVVMなのか</h2>
<p>UIに対するReactive Programmingなのは間違いないと思ってます。Reactive ProgrammingはUI向きだ。よく聞くその話は、実際その通りだと思うのですが、しかし同時にUI(というか、WPF/SL/WP7などXAML)とRxってどうもイマイチフィットしないなぁ、と悩んでいました。その理由は、最終的に描画を司るフレームワーク(XAML)とミスマッチなせいにあるのだと、気づきました。フレームワークの要求(INotifyPropertyChangedなオブジェクトであったりICommandであったり)と異なるものを、そのまま使おうとしたところで、良い結果は得られない。ゴリ押ししてもXAMLの旨みが生かせないし、Reactive Programmingを大前提に置いた描画フレームワークを構築すれば、もっと違う形になるでしょうが、そんなものは非現実的な話です。膨大な投資のされた、現在のXAML中心のシステムより良いもの……。やはり、絵空事にしか見えません。それに、XAMLは何だかんだ言って、良いものです。</p>
<p>それを認識したならば、必要なのは、境界を繋ぐシステムだと導ける。そのことを念頭においてReactivePropertyとReactiveCommandをデザインしました。MVVMライクなのは描画フレームワークに合わせた結果です、だから、MVVMでもあり、そうでもないようでもある。ただ、それによってパラダイムがミックスされてどちらの長所も活かせるし、世界最高峰のシステムであるXAMLアプリケーションに乗っかれるので今すぐ実用的という面もあるわけなので、これでいいと思うんです。いや、これがいいんです。マルチパラダイムは悪いことではない。あとは、ミックス故に生まれる新しい悩みをどう解消していくか、です。</p>
<p>マルチパラダイムといえば、ReactivePropertyは描画フレームワークからの言語への要求が変化（吸収）しているので、F#でも美味しくXAMLアプリケーションを書くことが可能になるでしょう。多分。</p>
<h2>非同期拡張メソッド群</h2>
<p>Rxは非同期の苦痛を癒す。とはいっても、実のところ素の状態だと罠が多くて、意外と使いづらかったりします。WebClientは、実行順序の問題があり、そのままではRxで扱いにくい。WebRequestはWebRequestでプリミティブすぎて機能が乏しいし、そのままではリソース処理に問題を抱えたりします。どちらも、ただFromEvent, FromAsyncするだけでは足りなくて、もう一手間かけたRx化が必要です。そのため、WebClient, WebRequestに対して拡張メソッドを用意し、簡単に実行出来るようにしました。</p>
<p>ReactivePropertyと合わせてのインクリメンタルサーチの例を。これは、ReactivePropertyのダウンロードファイルに含む非同期サンプルですので、是非ダウンロードして、サンプルを実際に実行してみてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using Codeplex.Reactive.Asynchronous; // 非同期系の拡張メソッド群を格納
using Codeplex.Reactive.Extensions; // OnErrorRetryはこちら

public class AsynchronousViewModel
{
    public ReactiveProperty&lt;string&gt; SearchTerm { get; private set; }
    public ReactiveProperty&lt;string&gt; SearchingStatus { get; private set; }
    public ReactiveProperty&lt;string&gt; ProgressStatus { get; private set; }
    public ReactiveProperty&lt;string[]&gt; SearchResults { get; private set; }

    public AsynchronousViewModel()
    {
        // IncrementしたりDecrementしたりすることでイベント(Empty ,Inc, Dec, Max)が発生する
        // それはネットワークの状態を管理するのに都合が良い(IObservable&lt;SignalChangedStatus&gt;)
        var connect = new SignalNotifier();
        // 指定したスケジューラ(デフォルトはUIDispatcherScheduler)上で任意にイベントを起こせる
        // 主にProgressと併用して進捗報告に利用する
        var progress = new ScheduledNotifier&lt;DownloadProgressChangedEventArgs&gt;();

        SearchTerm = new ReactiveProperty&lt;string&gt;();

        // 検索は当然非同期で行い、それをダイレクトにバインドしてしまう
        SearchResults = SearchTerm
            .Select(term =&gt;
            {
                connect.Increment(); // 非同期なのでリクエストは一つじゃなく並列になるので、これで管理
                return WikipediaModel.SearchTermAsync(term, progress)
                    .Finally(() =&gt; connect.Decrement()); // リクエストが終了したら、確実にカウントを下げる
            })
            .Switch() 
            .OnErrorRetry((WebException ex) =&gt; ProgressStatus.Value = &quot;error occured&quot;)
            .Select(w =&gt; w.Select(x =&gt; x.ToString()).ToArray())
            .ToReactiveProperty();

        // SignalChangedStatus : Increment(network open), Decrement(network close), Empty(all complete)
        SearchingStatus = connect
            .Select(x =&gt; (x != SignalChangedStatus.Empty) ? &quot;loading...&quot; : &quot;complete&quot;)
            .ToReactiveProperty();

        ProgressStatus = progress
            .Select(x =&gt; string.Format(&quot;{0}/{1} {2}%&quot;, x.BytesReceived, x.TotalBytesToReceive, x.ProgressPercentage))
            .ToReactiveProperty();
    }
}

// 非同期リクエストとデータ。単純ですが、Modelということで。
public class WikipediaModel
{
    const string ApiFormat = &quot;http://en.wikipedia.org/w/api.php?action=opensearch&amp;search={0}&amp;format=xml&quot;;

    public string Text { get; set; }
    public string Description { get; set; }

    public WikipediaModel(XElement item)
    {
        var ns = item.Name.Namespace;
        Text = (string)item.Element(ns + &quot;Text&quot;);
        Description = (string)item.Element(ns + &quot;Description&quot;);
    }

    // WebClientの他に、WebRequestやWebResponseへの非同期拡張メソッドも多数用意されています
    // また、ほとんど全ての非同期拡張メソッドにはプログレス通知を受け付けるオーバーロードがあります
    public static IObservable&lt;WikipediaModel[]&gt; SearchTermAsync(string term, IProgress&lt;DownloadProgressChangedEventArgs&gt; progress)
    {
        var clinet = new WebClient();
        return clinet.DownloadStringObservableAsync(new Uri(string.Format(ApiFormat, term)), progress)
            .Select(Parse);
    }

    static WikipediaModel[] Parse(string rawXmlText)
    {
        var xml = XElement.Parse(rawXmlText);
        var ns = xml.Name.Namespace;
        return xml.Descendants(ns + &quot;Item&quot;)
            .Select(x =&gt; new WikipediaModel(x))
            .ToArray();
    }

    public override string ToString()
    {
        return Text + &quot;:&quot; + Description;
    }
}
</code></pre>
<p>色々な機能を一度に説明しようとしているので、些か複雑かもしれません。まず、非同期リクエストは並列になります。例えばボタンを、通信中はDisabledにするのに、単純にbooleanで管理してもうまくいきません。どれか一つのアクセスが始まったらDisabledにしてどれか一つのアクセスが終わったらEnabledにする。それではダメです。どれか一つのアクセスが終わったところで、他のリクエストが通信中かもしれないケースに対応できませんから。</p>
<p>そこで、ReactivePropertyではSignalNotifierというものを用意しました。これは、IncrementかDecrementの操作によって、「ゼロになった」「インクリメントされた」「デクリメントされた」「Max（初期値で指定した場合）になった」というイベントを発行します。イベントといっても、自身がIObservable&lt;SignalStatus&gt;になっているので、直接Rxで扱えます。これのネットワークリクエストへの適用はシンプルで、通信開始されたらインクリメント。通信終了したらデクリメントする。そして、ゼロになったか否かを見れば、それが通信中か否かの判定になります。</p>
<p>非同期拡張メソッドはキャンセルに対しても強く考慮されています。WebClient(のSubscribeの戻り値)にDisposeするとCancelAsyncを、WebRequest(のSubscribeの戻り値)にDisposeするとAbortを呼ぶようになっています。このような挙動は、単純にFromEvent, FromAsyncしただけでは実現できないので、大きくて間を省けることでしょう。ネットワークリクエストを自身でキャンセルすることは少ないかもしれませんが、上の例であげたSwitchは内部でDisposeを呼びまくる仕組みになっていますので、しっかり対応している、というのは実行上、大きなアドバンテージとなります。</p>
<p>Switchは複数の非同期リクエストが確認された場合に、前のリクエストをキャンセル＋キャンセルが遅れた場合でも遮断して結果を後続に返さないことで、最新のリクエストの結果のみを返します。そのため、非同期リクエストが抱える結果が前後してしまう可能性、例えばインクリメンタルサーチではLINQと検索したのに、LINQの結果よりも後にLIの結果が返ってきたために、表示されるのがLIの結果になってしまう。などという自体が防げます。</p>
<p>また、OnErroRetryに注目してください。これはReactivePropertyが独自に定義している拡張メソッドで、例外発生時の処理をすると同時に、Retry（ここでいうとSearchTermの再購読なので、つまりチェーンの状態が維持される、ということになる）します。ToReactivePropertyを使い、ダイレクトに結び付けている場合は、例外が発生するとチェーンが終了して困るのですが、例外処理にこのOnErrorRetryを使うことで、そのような悩みは不要になります。なお、このOnErrorRetryは勿論ReactiveProperty専用というわけでもなく汎用的に使えます。例えば、もしネットワークからのダウンロードに失敗したら、一定間隔を置いて再度ダウンロードをする、但しリトライの挑戦は指定回数まで。というよくありそうな処理が、引数で回数とTimeSpanが指定できるので、簡単に記述できます。</p>
<p>進捗レポートも非同期処理では欠かせませんが、これは非同期拡張メソッドとScheduledNotifierを組み合わせることで、簡単に実現出来ます。これら非同期周りのサポートはReactivePropertyの重要な柱だと考えているので、UI周りの機能は必要ない、という人も、是非試してみて欲しいです。</p>
<h2>同期 vs 非同期</h2>
<p>SLやWP7はともかく、WPFでこのように強烈に非同期サポートする意味はあるのでしょうか。というと、あります(ただたんにコード共有しているから、というだけではなく)。まず、WinRTがそうなように、時間のかかる処理は時間のかかる処理なわけなので、強制的に非同期になっていたほうが、ViewModelなり束ねるModelなりで、そこら中に、明示的にスレッド管理(ただたんにTaskに投げるのも含む)をしないで済みます。本質的に非同期(CPU依存ではない形で時間がかかる)なものは非同期として扱ったほうが易しいのです。</p>
<p>もう一つは、Switchのような、キャンセルを多用した処理が書きやすいこと。それに、自然な形でプログレス処理もサポートできます。更には、ReactivePropertyを全面に使うのなら、全てがReactiveに通知しあう世界、つまり全てが非同期で回っているので、非同期のほうが圧倒的に相性が良いです。同期プログラミングさようなら。大丈夫です、何も問題ありません。</p>
<h2>C#5.0 Async vs Rx</h2>
<p>従来通りに書く。シンプルに同期のように。のならば、async/awaitのほうがずっと良い。そういう使い方をする場合は、Rxを非同期に使う必要性というのは、今後はなくなるでしょう。ではRxでの非同期に価値はなくなってしまうのか？というと、それに関しては明確にNOと答えます。</p>
<p>Rxの場合はLINQということで、宣言的なスタイル、演算子という形に汎用的な処理を閉じ込められる高いモジュール性。というのがあります。上で見たきたように、Switchのようなこと、OnErrorRetryのようなこと、これらを演算子という形で定義して、メソッド一発で適用出来るのはRxならではの利点です。もし自分でそれらの処理を書くとしたら…… あまり考えたくはないし、もしメソッドの形でまとめあげるとしても、Rxのように綺麗に適用させるのは不可能でしょう。どこか歪んだシグネチャを抱えることになります。</p>
<p>ReactivePropertyと親和性が高いのでViewModelへの伝達に使いやすいというのもポイントですね(TaskとIObservableは相互に変換可能なので、ToTaskしたりToObservableしたりするだけなので、別段問題でもないですけど)</p>
<p>使い分けというのは実際のところ幻想みたいなことなので、人によりどちらか主体のスタイルには落ち着くでしょう。私は、とりあえずRx主体で行きたいかなあと思ってますが、ライブラリ的な部分ではasync/awaitを使って書くでしょう(演算子の組み合わせでやろうとすると書くのも難しいし、パフォーマンスも出ないので)。現在のシーケンスに対する、yield returnで汎用的な演算子を作って、通常使うシーンではLINQ to Objectsで、定義した演算子を含めて使っていく。というのと同じスタイルが良さそうだと想像します。async/awaitの書きやすさ・パフォーマンスと、Rxのモジュール性の両立はその辺かなあ、って。</p>
<p>あと、連続的な非同期処理を一纏めにするというのが(今のところ)async/awaitだと出来ない(Task&lt;T&gt;の戻り値は一つだけだから)ので、その辺をやりたい場合にもRx(IObservable&lt;T&gt;は元より複数の戻り値を内包する)頼みになります。ここは将来的にどういう形になるのか、まだ不明瞭なところなので断言はしませんが。</p>
<h2>Validation</h2>
<p>ReactivePropertyでは、三種類のバリデーションに対応しています。DataAnnotationsによる属性ベース、IDataErrorInfoによるPull型のエラー確認、INotifyDataErrorInfoによるPush型/非同期のエラー確認。ただし、WPFではINotifyDataErrorInfoは使えなく(.NET4.5からは入るようですが)、WP7ではDataAnnotationsが使えません。これはクラスライブラリの問題なので私の方では如何ともしがたくで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// XAMLは省略。詳しくはSample/Validationを見てください

public class ValidationViewModel
{
    [Required]
    [Range(0, 100)]
    public ReactiveProperty&lt;string&gt; ValidationAttr { get; private set; }
    public ReactiveProperty&lt;string&gt; ValidationData { get; private set; }
    [StringLength(5)]
    public ReactiveProperty&lt;string&gt; ValidationBoth { get; private set; }
    public ReactiveProperty&lt;string&gt; ValidationNotify { get; private set; }
    public ReactiveProperty&lt;string&gt; ErrorInfo { get; private set; }
    public ReactiveCommand NextCommand { get; private set; }

    public ValidationViewModel()
    {
        // 属性ベースのバリデーションは、自身のプロパティをExpressionで指定することで適用できます
        // 通常属性ベースの場合、例外経由ですが、ReactivePropertyではIDataErrroInfo経由になります
        // そのため、XAML側ではValidatesOnDataErrors=Trueにしてください
        ValidationAttr = new ReactiveProperty&lt;string&gt;()
            .SetValidateAttribute(() =&gt; ValidationAttr);

        // IDataErrorInfoではエラー時のメッセージを渡します、nullの場合は成功の判定になります
        ValidationData = new ReactiveProperty&lt;string&gt;()
            .SetValidateError(s =&gt; s.All(Char.IsUpper) ? null : &quot;not all uppercase&quot;);

        // 三種類の指定は、重ねることが可能です（但し同じ種類のものを複数指定するのは不可能）
        ValidationBoth = new ReactiveProperty&lt;string&gt;()
            .SetValidateAttribute(() =&gt; ValidationBoth)
            .SetValidateError(s =&gt; s.All(Char.IsLower) ? null : &quot;not all lowercase&quot;);

        // INotifyDataErrorInfoの場合は、IObservable&lt;IEnumerable&gt;を返してください
        // 第一引数はself、つまりIObservable&lt;T&gt;になっていて、最終的にSelectでIEnumerableに変換します
        // IObservableということで、非同期での検証が可能になっているのがポイントです
        // これもIDataErrorInfoと同じく、nullの場合は成功という判定になります
        ValidationNotify = new ReactiveProperty&lt;string&gt;(&quot;foo!&quot;, ReactivePropertyMode.RaiseLatestValueOnSubscribe)
            .SetValidateNotifyError(self =&gt; self
                .Delay(TimeSpan.FromSeconds(3)) // DB問い合わせなど非同期なバリデーション（が可能）
                .Select(s =&gt; string.IsNullOrEmpty(s) ? null : new[] { &quot;not empty string&quot; }));

        // バリデーションの結果は、三種類全てまとめられてObserveErrorChangedから購読できます
        var errors = Observable.Merge(
            ValidationAttr.ObserveErrorChanged,
            ValidationData.ObserveErrorChanged,
            ValidationBoth.ObserveErrorChanged,
            ValidationNotify.ObserveErrorChanged);

        // もし、それらを分類したいときは、OfTypeを使うといいでしょう
        ErrorInfo = Observable.Merge(
                errors.Where(o =&gt; o == null).Select(_ =&gt; &quot;&quot;), // 成功はnull
                errors.OfType&lt;Exception&gt;().Select(e =&gt; e.Message), // 属性からはException
                errors.OfType&lt;string&gt;(), // IDataErrorInfoからはstring
                errors.OfType&lt;string[]&gt;().Select(xs =&gt; xs[0]))  // INotifyDataErrorInfoからは、IEnumerableの何か
            .ToReactiveProperty();

        // 検証が全部通ったら実行可能にするコマンド、などもこうやって書けますね！
        NextCommand = errors.Select(x =&gt; x == null).ToReactiveCommand(initialValue: false);
        NextCommand.Subscribe(_ =&gt; MessageBox.Show(&quot;Can go to next!&quot;));
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=3" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>一点だけ通常と異なるのは、属性ベースのものを例外ではなくてIDataErrorInfoとして扱います（この辺はRxのパイプラインを通す都合上、例外を出すという形での実現が不可能だったので）</p>
<h2>Event to Observable</h2>
<p>イベントをXAML側で指定して、ReactivePropetyにバインドすることが可能です。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;Grid&gt;
    &lt;i:Interaction.Triggers&gt;
        &lt;i:EventTrigger EventName=&quot;MouseMove&quot;&gt;
            &lt;r:EventToReactive ReactiveProperty=&quot;{Binding MouseMove}&quot; /&gt;
        &lt;/i:EventTrigger&gt;
    &lt;/i:Interaction.Triggers&gt;
    &lt;TextBlock Text=&quot;{Binding CurrentPoint.Value}&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class EventToReactiveViewModel
{
    public ReactiveProperty&lt;MouseEventArgs&gt; MouseMove { get; private set; }
    public ReactiveProperty&lt;string&gt; CurrentPoint { get; private set; }

    public EventToReactiveViewModel()
    {
        // UIからのイベントストリームを受信
        MouseMove = new ReactiveProperty&lt;MouseEventArgs&gt;();
        
        // とりあえず座標を表示する、というもの
        CurrentPoint = MouseMove
            .Select(m =&gt; m.GetPosition(null))
            .Select(p =&gt; string.Format(&quot;X:{0} Y:{1}&quot;, p.X, p.Y))
            .ToReactiveProperty(&quot;MouseDown and drag move&quot;);
    }
}
</code></pre>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="100px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactivePropertyFirstIntroduction.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <param name="initparams" value="Start=4" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>お手軽なので、結構便利だと思います。あの長大なFromEventPatternを書くよりかは(笑)</p>
<h2>シリアライズ</h2>
<p>特にWP7では頻繁な休止と復帰で、シリアライズ/デシリアライズによる状態の回復が重要です。そこで、値の回復を可能にするシリアライズ用のヘルパーを用意しました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんなビューモデルがあるとして
public class SerializationViewModel
{
    // なにもつけてないと普通にシリアライズ対象
    public ReactiveProperty&lt;bool&gt; IsChecked { get; private set; }
    [IgnoreDataMember] // Ignoreつけたら無視
    public ReactiveProperty&lt;int&gt; SelectedIndex { get; private set; }
    [DataMember(Order = 3)] // Orderつけたら、デシリアライズの順序を規程
    public ReactiveProperty&lt;int&gt; SliderPosition { get; private set; }
}

// 例えばWindows Phone 7のトゥームストーンなシチュエーションを考えてみると
private SerializationViewModel viewmodel = new SerializationViewModel();
private string viewmodelData = null;

protected override void OnNavigatingFrom(System.Windows.Navigation.NavigationEventArgs e)
{
    viewmodelData = SerializeHelper.PackReactivePropertyValue(viewmodel);
}

protected override void OnNavigatedTo(System.Windows.Navigation.NavigationEventArgs e)
{
    SerializeHelper.UnpackReactivePropertyValue(viewmodel, viewmodelData);
}
</code></pre>
<p>デシリアライズの順序はDataMember属性のOrderに従います。詳しくは<a href="http://msdn.microsoft.com/ja-jp/library/ms729813.aspx">データ メンバーの順序</a>を参照のこと。Pushしあう関係の都合上、デシリアライズの順序によって正確な復元ができないこともあるでしょうから、その場合は、Orderをつけると、ある程度制御できます。また、IgnoreDataMember属性をつけておくと、シリアライズ対象から除外することが可能です。</p>
<h2>スニペットとサンプル</h2>
<p>NuGetから入れてもらってもいいのですが、ダウンロードしてもらえるとコードスニペットとサンプルがついてきますので、最初はダウンロードのほうがいいかもです。コードスニペットはrpropでReactiveProperty&lt;T&gt; PropertyName{ get; private set; }という頻繁に書くことになる宣言が展開されます。他にはrcomm(ReactiveCommand)など。</p>
<p class="noindent">
    <img src="http://neue.cc/wp-content/uploads/image/ReactivePropertySample.jpg">
</p>
<p>サンプルはWPF/SL4/WP7全てで用意しました。サンプルを割としっかり用意した最大の理由は、ただ渡されても、もしかしなくてもどう書けばいいのかさっぱり分からないのでは、と思ったのがあります。決して複雑ではなく、むしろシンプルだし記述量は大幅に減るわけです、が、従来のやり方からするとあまりにも突飛なのは否めないので、いきなりスイスイ書くというのは無理ですよねぇ、と。</p>
<p>その他紹介していない、サンプルに載ってない機能は、まだいっぱい。こんなに記事がなくなっちゃってもまだ全然足りない。でも、いきなりてんこ盛りだと引いてしまうので、基本的にはReactivePropertyとReactiveCommandが主体で、慣れたら徐々に周囲を見てもらえばな、ぐらいに思っています。</p>
<h2>まとめ</h2>
<p>仕上がりはかなり良いと、興奮しています。この長い記事！興奮を伝えたいという気持ちでいっぱいだからです。今後も、利用シーンの模索と合わせて、どんどん進化させていくつもりです。初回リリースですし、というのもありますが、コアコンセプトの実現と、使い勝手としてのAPIの錬成に力を注いだので、それ以外の部分の研究が疎かになっているというのは否めませんので、そこのところの強化も行なっていきます。また、JavaScriptへの移植もノリ気なので、まず<a href="http://knockoutjs.com/">Knockout.js</a>を試して、その上に構築させたいなあ、とか考えています。</p>
<p>ところで、10/8土曜日、明日の<a href="http://silverlightsquare.com/index.php/tokyo04.html">Silverlightを囲む会in東京#4</a>の一番最後に、少し、デモ中心でお話をするつもりなので（最後のオマケなのでほんの少しだけですけどね)良ければ見に来てください。ギリギリではありますが、まだ申し込みも出来ると思います。また、もしよければ会場/懇親会でつかまえて聞いてくれたりすると泣いて喜びます。会場に来れなくてもIIJさんのSmooth Streamingで超高画質な配信が行われると思われますので、そちらでも是非是非。</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
