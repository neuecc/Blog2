<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc - 2018-12</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2018-12-30" data-pagefind-meta="published:2018-12-30"><a href="https://neue.cc/2018/12/30_573.html">2018年を振り返る</a></h1>
<ul class="date"><li>2018-12-30</li></ul>
<div class="entry_body"><p>毎年恒例ということで、今年も振り返ります。だいたい30日に書いてるのですが、理由は12月30日は私の誕生日なので色々ちょうどよいかな、と。いよいよ35歳なので、例のあれ、35年定年説になりました。そのへんどうでもいい外れ値をひた走ってるので一般論はあんま関係ないんですが、体力は落ちてる実感ありますね！肥ったし。文章はどんどんてきとーになってくし。</p>
<p>と、いうわけで、今年は客観的には激動の年です。会社辞めて会社作って会社作って。私生活でも色々あり、イベントが多くて中々どうして落ち着かなかった年です。そのため成果という点では不完全燃焼が否めないですね、どうしても集中しきれないし時間も上手く捻出できないし。GitHubの草生やしで考えれば、もう全然すっかすっか。その中でUniRx.AsyncやMagicOnion2など、今年もちゃんと大きめの成果を出せたのは、意地です。特にUniRx.Asyncの開発はしんどかった……(MagicOnion2のほうはCysharpとしての時間を使えたので良かったんですが、UniRx.Asyncの開発のための時間捻出はめっちゃ厳しかった）。まぁ、ダラダラ草生やすことをKPIにするよりは、一発ホームランをKPIにしたほうがエンジニアの脳トレ的にも随分かいいんじゃないでしょーか？</p>
<p>ここ数年は毎年、C#を書く技量が向上してていいわー、と言い続けてるんですが、今年も随分と向上しました！特に大きかったのはUniRx.Asyncの開発で、これのためにasync/awaitやTask周りの生態系を全部自前実装したので、曖昧な理解だった、ということに気づいてすらいなかったものも、全て完全に理解したので、私自身の能力の向上としてかなり大きいですね。車輪の再発明は良いものです。</p>
<p>きちんと最前線のC#を書けている自信がありますし、対外的な証明もできているので、能力的な意味では老害とはまだ遠そうでいいんじゃないでしょーか。色々な言語に手を出して成長、ってのも悪くはないでしょうが、一つの言語を集中的に深掘りするというのもまた成長の道かと思います。中途半端な深掘りだと言語固有の話になって応用がー、みたいなところがなくもないのですが、徹底的に深掘りすりゃあ、逆に言語固有じゃなくなって、応用が効いてくる領域に入るのです。もしなんとなく成長の限界を感じて他の言語やったほうがいいかな、とか思うのだとしたら、多分、全然深掘りが足りないじゃないかしら？と、思ったりね、します。実に上から目線ですが！</p>
<h2>お仕事</h2>
<p>先に仕事の話を考えると、<a href="http://neue.cc/2018/04/02_563.html">株式会社グラニを退任しま</a>した。私だけではなく皆バラバラになっているので（もちろんマイネットさんのほうで引き続きタイトル開発にあたっているメンバーもいます）、グラニという会社の始まりから終わりまで、ですね。結末として、悪くはない（退職時の未払いなどももちろんありませんし、エンジニアメンバーは他社に転職した人も、みな良いところに移れているので、グラニという会社が経験としてもキャリアとしても、良いものを提供できたのではないかなー、と思ってます、まぁ役員としてはこれが最後の仕事の成果という形になるのでそう思わせてください……！）ですが、もちろん、最良ではない、です。</p>
<p>CTOとしてどうだったかというと、会社として一点突破な凡百じゃない他にない個性を作れたし、悪くないところまで突き進めた、という点ではよくやれてはいますが（別に「素で」やってるわけじゃなくて割としっかり戦略組んでやっての結果なのでそれなりに大変なんですよ！）、最良のエンディングではないという結果をもって、ベストじゃあないでしょうね。実際反省点はめちゃくちゃ多いです。世の中、結果が全てで、一般論のハンマーを叩き返すには結果を出していかなきゃいけないので、今回の5年間の結果では一般論に反逆はできないんで、次はもっとうまくやる。という決意もあります。</p>
<p>退任後には<a href="http://new-world.co/">New World, Inc.</a>を設立しました。設立じゃない道も模索していたのですが、うまくまとまらなかったので、とりあえずやったことないしやってみっか、と。なんで株式会社なのかというと、とりあえず作ってみたかったから、以外の理由はない、です。次の会社のスタートまでの間(4ヶ月ぐらい)は、この会社名義、といってもほぼ個人事業主として仕事していました。一応会社としてのビジネスプランも考えてはいたのですが、時間的なものもあって結局ほとんど個人事業主的な働き方に終始しました。</p>
<p>こちらは死ぬほど反省点ありますね……。あまり表明するのもアレですが、多分、まぁ、請負で作業するの自分には向いてないんだとは思います……。それ以外にも単純にスキル不足があって、自分が組んできた環境ではなく自由度もそう高くない中でのパフォーマンスチューニング、みたいなことをするための手札があんまなかったですね。こういうスキルって、多分テクニカルサポート（それも高額なプレミア契約の）の人が持つスキルなんでしょうけれど、明らかに自分の手札にはなかったのを自覚しました。ここはもう能力不足だし、あったほうがいいのは間違いないんで、来年は伸ばしていこうかな、とは思ってます。</p>
<p>グラニでのトラブルシューティングは、徹夜で張り付いて空いてそうな時間にサーバー一時的に止まるの強行でダンプ取ったり、本番環境データベース相当のをコピーして好きに実験したり、既に豊富に用意しているモニタリング系システムにクエリ書いたり追加したり、そもそも根本からライブラリを自作のものを開発して取り替えたりと、権限に甘えきったことやってたんで、まぁ世の中そんなイージーモードなわけないぞ、と。そりゃそうだ。会社としてはイージーモードな世界を作るのが大事で、個人スキルとしてはハードモードな世界でやりきれる能力をつけるのが大事。両面から頑張っていきたい。</p>
<p>そして、<a href="http://neue.cc/2018/10/31_570.html">株式会社Cysharpを設立しました</a>。設立に関する話は←の記事と、<a href="https://gamebiz.jp/?p=225825">Social Game Infoでのインタビュー</a>を読んでいただければなのですが、まず、この座組のインパクトはめっちゃあったかな、と！社名もそうですが！大きなことがやれそうな予感があります。来年はそうした予感を実現していくという、チャレンジの年です。会社としてもそれなりな規模にはしていきたいと思っているので、そのへんもやっていければ。</p>
<p>引き続きゲーム関連で勝負をかけるわけですけれど、ゲーム関連から攻めるのがC#にとって一番、あるいは唯一芽があるから、というのも大きくて。私はインターネットで育ってきたので、ウェブに話題が少ない言語や環境って嫌なんですよね、だからエンタープライズで採用伸びてるとか世界的には数字は良いんだとか、そういうの興味なくて。目の前のインターネットの世界で話題になり誰もが使う言語、であって欲しい。C#が。誰もが使い、話題にし、エコシステムが形成され、若い人がどんどん使う。そこへ向かうには、ゲームやUnityと絡めていくことが唯一の道だと思っています（個人的にはXamarinでは無理でしょう、と思ってるので）。そしてそこに対して貢献したいのです。それはMicrosoftやUnityの「外の人」だからこそできることでもある。</p>
<h2>C#</h2>
<p><a href="http://neue.cc/2018/07/12_567.html">UniTask(UniRx.Async)のリリースによるコンセプト実証</a>と<a href="http://neue.cc/2018/12/25_571.html">大規模アップデートによる真の実用化</a>。これはNew Worldとして動き出してちょい過ぎぐらいから作成に着手しました。私の中でこれのリリースには大きな意味があって、New World, Incとしての名刺、つまるところ私自身の自信が欲しかったのです。特にUnity関連においてUniRxは前の世代の話なので、今の世代で絶対の自信を持って薦められるものが欲しかった。そういうものがあると自分にも自信ができるんで、交渉も強気に迫れますからね。</p>
<p>UniTaskはUnityに最適化したasync/await生態系の再発明です。これやりきれる人って世の中いないんで、成果として世の中に存在するのはめっちゃレアなんじゃないでしょーか。と思える程度にはいい感じだと思います。しかし例によってまだバグや機能改善がかなり残っているのに、いったん放置が始まっていて、これは本当に私の悪癖ですね……。来年の抱負は放置しない、です。ほんと。ほんと。</p>
<p>もう一個が<a href="http://neue.cc/2018/12/28_572.html">MagicOnion v2のリリース</a>で、これはグラニでのやり残したことの一つの消化、という意味合いもあります（技術的にはもう一つやり残したことありますけれど、「まともな」UIライブラリの作成とプラクティスの構築とか）。そして、Cysharpで掲げる「C#大統一理論」のキーパーツですね。応用事例をどんどん作っていきたいます。</p>
<p>また、MagicOnionはリポジトリを<a href="https://github.com/Cysharp/MagicOnion/">Cysharp/MagicOnion</a>に移しています。これはメンテしっかりやっていくぞ、の現れですね！他にUniRxやMessagePack for C#などもorgnaization(Cysharpじゃなくて中立的組織）に移したいなあ、とは思ってます。そうした継続的メンテナンス体制を作って、永く行き続けていくものになっていければいいなあ、と。まあカウボーイエンジニアから会社経営者になったわけで、そのへんも世の中によりよい形を、ということで。</p>
<p>パフォーマンスの追求は引き続きやっていきたいテーマで、一旦のまとめをCEDEC 2018で<a href="http://neue.cc/2018/08/25_568.html">最速のC#の書き方 - C#大統一理論へ向けて性能的課題を払拭する</a>と題して講演しました。こういうのってどのへんまでDeepでDopeに書けばいいのか難しくて、浅瀬ちゃぷちゃぷなんちゃうんちゃうんな思いと戦いつつ、実体験ベースってのもあり良いちゃあ良かったんじゃないでしょうか。</p>
<p>Unity ECSはもっと力入れてやりたかったんですが、ほとんど出来なかったですね。LTドリブン開発だー、と思ったけれどロクにできず<a href="http://neue.cc/2018/10/23_569.html">Memory Management of C# with Unity Native Collections</a>でお茶濁しした程度だったので……。物理エンジンと絡めて、やりたいネタが2年ぐらい前からあって、ECSの登場でまさに最適なプラットフォーム！これでちゃりんちゃりんする！と考えてたのに何も実装できず一年が終わるとは……。来年こそリベンジします。</p>
<h2>漫画/音楽/ゲーム/その他…</h2>
<p>今年感動したゲームは<a href="https://www.jp.playstation.com/games/detroit-become-human/">Detroit: Become Human</a>一択ですねえ、もう全く悩まず。映像も音楽もシナリオもシステムも、あらゆる点で監督(デヴィッド・ケイジ)の神経質そうな（ほんと！）目が行き届いていて、完璧。ただの雰囲気ゲーにならずゲームとしてもちゃんと面白く仕上がっているので、非の打ち所がない（リプレイが面倒くさくてエンディングコンプがダルい問題はありますが、一周＋αの体験だけで十分価値あるんで良いんじゃないでしょーか）。</p>
<p>漫画は<a href="https://www.amazon.co.jp/dp/B07H29J6F1/">うめざわしゅん - えれほん</a>がとても良くて、三話(+1)入った短編集で<a href="http://denshi-birz.com/erewhon/">二話目は無料で読めます</a>。とにかくまぁ漫画が上手い。まぁあと古いですが今年読んだんで<a href="https://www.amazon.co.jp/dp/B01D1Q520C/">内田 春菊 - 目を閉じて抱いて</a>も。全然古くないというかむしろ今の時代のほうが共感できるんちゃうんちゃうん、と(といっても1994-2000だとそこまで古くもないのかー、いや、古いかー)。</p>
<p>音楽は、今年まぁまぁケンドリック・ラマーの記事を目にしたから（来日で一悶着あったからかしらん）、というわけでもないですが最新作のDAMN、ではなくてその前の<a href="https://www.amazon.co.jp/dp/B00UDDM7K0">To Pimp A butterfly</a>をよく聞いてました。特に一曲目のWesley's Theory。もともとこれ作曲してるFlying Lotusが好きというのもありますが、Flying Lotusの手掛けた中でも傑作と思ふ。アルバム全編を貫くストーリーも重たく、比喩も強烈で、言葉の強さを心底叩き込んでくる。そりゃ心震えますよ！</p>
<p>映画は、これも古いですがNetflixで見た<a href="https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B4">ニコラス・ウィンディング・レフン - ドライヴ</a>が良かった。映像美とバイオレンス！まぁーもうとにかく最高に格好良い。こりゃすげえ、と思わず監督の大ファンになって初期作のプッシャー三部作、これはまぁまぁだったんですが、最新作の<a href="http://gaga.ne.jp/neondemon/">ネオン・デーモン</a>が……。設定も良い。映像も良い。プロットも悪くない。映画としてはつまらない。というしょっぱい代物に……。脚本と構成が悪いんかなー、もう少しうまくやりゃあ、めっちゃ良くなったはずなのに感で超もったいない……。設定と映像は本当に好みなだけに、あうあうって感じ。何れにせよ次回作あったら見るよ！と思ったら、来年(2019)にAmazon Prime Videoのシリーズとして<a href="https://www.youtube.com/watch?v=_ZHMbh_GTkY">Too Old to Die Young</a>というドラマを撮ってるそうで。日本に来るのかな、Netflixだったら絶対来るはずだけどAmazon Prime Videoだとどうなんでしょ。</p>
<p><a href="http://shibari.jp/red/index.html">Hajime Kinoko写真集「Perfect Red」</a>は、写真集はもちろん、個展とショーも見に行きましたが、圧倒的な空間で。ショーだと、人間の表現として、静と動の中間のような世界なんですよね。例えば、静が彫刻、動がバレエのようなものだったりだとすると、その間。ほとんど止まっているのだけれど、手の動き、顔の表情、そして縄が皮膚に言葉を与えていて。表現としては未成熟というかアングラ感が拭えないですが（決して悪いことではなくそれはそれでいいんですが）、もっと表に出れば出るほど洗練されていくのでは、というわけで来年も見たいですね。</p>
<h2>来年は</h2>
<p>とにもかくにもCysharpをしっかり始動させます。会社の理念がC#とOSSを中心に、というのもあるので、技術のコミュニティ貢献も引き続き、ですね。そしてメンテやIssueを放置しないという抱負は、ただの意気込みじゃなくて組織的な解決となるよう、具体的に動いていきます。</p>
<p>技術的には、今年は色々な言い訳がありますが、チャレンジがなかったなー、というのは否めないです。UniRx.AsyncもMagicOnion2も延長線上ですから。時間がない中で一定の成果を出すことが必須という状況下だったのでしゃーなし、という言い訳もありますが、来年こそは今までの延長線上にない別のことも手掛けたい、と毎年言ってますが、今年も思います。とりあえずとにかくUnity ECSは絶対やりますから……！</p>
<p>ともあれ、<a href="https://cysharp.co.jp/">Cysharp</a>の活動にご期待下さい。人も募集ちゅ（します、そろそろ）。です。そろそろお問い合わせフォームぐらいはつけたい。</p>
</div>
<h1 data-pagefind-sort="date:2018-12-28" data-pagefind-meta="published:2018-12-28"><a href="https://neue.cc/2018/12/28_572.html">MagicOnion v1 -> v2リブート, gRPCによる.NET Core/Unity用ネットワークエンジン</a></h1>
<ul class="date"><li>2018-12-28</li></ul>
<div class="entry_body"><p>先にCygames Engineers' Blogで<a href="http://tech.cygames.co.jp/archives/3181/">MagicOnion – C#による .NET Core/Unity 用のリアルタイム通信フレームワーク</a>としてリリースを出しましたが、改めまして、MagicOnionというフレームワークを正式公開しました。</p>
<p><a href="https://github.com/Cysharp/MagicOnion/">GitHub - Cysharp/MagicOnion</a></p>
<p>MagicOnionはAPI通信系とリアルタイム通信系を一つのフレームワークで賄う、というコンセプトを元に、前職のグラニで「黒騎士と白の魔王」の開発において必要に迫られて捻り出されたものでした。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/LrPbFMPfMXWJKj" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/grpchttp2-api-streaming" title="「黒騎士と白の魔王」gRPCによるHTTP/2 - API, Streamingの実践" target="_blank">「黒騎士と白の魔王」gRPCによるHTTP/2 - API, Streamingの実践</a> </strong> from <strong><a href="https://www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>で、今更気づいたのがMagicOnionって正式リリースしてなかったんですよね、このブログでも↑のような形でしか触れていなくて、公式ドキュメントも貧弱な謎フレームワークだったという。今回Ver2って言ってますが、その前はVer0.5でしたし。まぁここでは便宜的にv1と呼びます。</p>
<p>何故に正式リリースまで行かなかったかというと、リアルタイム通信部分が微妙だったから。↑のp.39-40で説明していますが、Unary + ServerStreamingという構成で組んだのが、かなり開発的に辛かったんですね。時間的問題もあり強行するしかなかったんですが、ちゃんと自分が納得いく代案を出せない限りは、大々的には出していけないなあ、と。</p>
<p>その後すったもんだがあったりなかったりで、プレーンなgRPCでリアルタイム通信を組む機会があって、↑の時に考えていたDuplexStreaming一本で、コマンドの違いをProtobufのoneofで吸収する、という案でやってみたのですが、すぐに気づきましたね、これ無理だと。UnaryはRPCなのですが、Duplex一本はRPCじゃないんで、ただたんにoneofをswitchしてメソッド呼び出す、だけじゃ全然機能足りてない、と。</p>
<p>ただまぁコネクション的にはDuplex一本案は間違ってなさそうだったので、その中で手触りの良いRPCを組むにはどうすればいいか……。と、そこでMagicOnionをリブートさせるのが一番手っ取り早いじゃん、というわけで着手したりしなかったりしたりしたのでした。その間に<a href="https://cysharp.co.jp/">Cysharpの設立</a>の話とかもあり、事業の中心に据えるものとしても丁度良かったという思惑もあります。</p>
<p>早速（？）Qiitaでも何件か紹介記事書いてもらいました。</p>
<ul>
<li><a href="https://qiita.com/mitchydeath/items/cecf01493d1efeb4ae55">Unity+MagicOnionで超絶手軽にリアルタイム通信を実装してみた</a></li>
<li><a href="https://qiita.com/yKimisaki/items/1d55b08f3e7bcae46585">MagicOnion v2を使ってUnity IL2CPPでgRPC通信をする</a></li>
<li><a href="https://qiita.com/shigezo/items/66220c611be4d014463a">Docker を利用して MagicOnion &amp; .Net Core の開発環境を整える</a></li>
</ul>
<h2>v1 -&gt; v2</h2>
<p>Unary系(API通信系)はほとんど変わっていません。それは、v1の時点で十分に高い完成度があって、あんま手を加える余地はなかったからですね。ただしフィルターだけ戻り値をTaskからValueTaskに変えています。これはフィルターの実行はメソッド実行前に同期的にフック(ヘッダから値取り出してみるとか)するだけ、みたいなものも多いので、TaskよりValueTaskのほうが効率的に実行できるからですね。</p>
<p>元々フィルターを重ねることによるオーバーヘッドを極小にするため、純粋にメソッド呼び出しが一個増えるだけになるように構成してあったのですが、更により効率的に動作するようになったと思います。</p>
<p>SwaggerのUIを更新するのと、HttpGatewayの処理を効率化するのが課題として残っているので、それは次のアップデートでやっていきます。</p>
<p>また、Unity向けにはコードジェネレート時にインターフェイス定義でTaskをIObservableに変換していたのですが、今のUnityは.NET 4.xも使えるということで、インターフェイスはそのまま使ってもらうようにしています。Taskのままで。</p>
<h2>StreamingHub</h2>
<p>の、導入に伴って、v1でリアルタイム通信系をやるための補助機構である StreamingContextRepository を廃止しました。StreamingContextRepositoryは、まぁ、正直微妙と思っていたのでなくせて良かったかな。決して機能してないわけではないのですけれど。</p>
<p>代わりのコネクションを束ねる仕組みはGroupという概念を持ってきました。これはASP.NETのWebsocketライブラリである<a href="https://github.com/aspnet/AspNetCore/tree/master/src/SignalR">ASP.NET Core SignalR</a>にあるものを、再解釈して実装しています。</p>
<p>MagicOnionのGroupの面白いところは、裏側の実装を変えられることで、デフォルトはImmutableArrayGroupという、MORPGのようなルームに入って少人数で頻繁にやり取りするようなグルーピングに最適化された実装になっています。もう一種類はConcurrentDictionaryGroupという、こちらはMMORPGやグローバルチャットのような、多人数が頻繁に出入りするようなグルーピングのための実装です。更に、RedisGroupというバックエンドにRedisのPubSubを置いて複数サーバー間でグループを共有するシステムも用意しています、これはチャットや、全体通知などに有効でしょう。</p>
<p>また、GroupにはInMemoryStorage[T]というプロパティが用意されていて、グループ内各メンバーに紐付いた値をセットできるようにしています。これは、通信のブロードキャスト用グループの他に、値の管理のためにConcurrentDictionary[ConnectionId, T]のようなものを用意してデータを保持したりが手間で面倒くさいんで、いっそグループ自体にその機能持ってたほうが便利で最高に楽じゃん、という話で、実際多分これめちゃくちゃ便利です。</p>
<h2>まとめ</h2>
<p>というわけで、リブートしました！最初チョロいと思ってたんですが、割とそんなことはなくて、この形にまとめあげるまではそれなりに大変でした……。の甲斐もあって、今回のMagicOnionはかなり自信を持って推進できます。以前はそもそもgRPC本体をフォークして魔改造したり、というのもあったのですが、今は公式ビルドを使えるようになったのでUnity向けにも良い具合になってきています。</p>
<p>MagicOnion2の内容は、(v1を)実際に使ってリリースした後の反省点が盛り込まれているので、そういう点で二周目の強みがあります。最初からこの形で出すのは絶対にできないであろうものなので、しっかりと経験が活かされています。実プロダクトで使って初めて見えるものっていっぱいありますからねー。とはいえv1はv1で大きな役割を果たしたと思いますし、まぁあと自分で言うのもアレですが「黒騎士と白の魔王」が証明したこと(gRPCがUnityでいけるんだぞ、という)ってメチャクチャ大きかったなあ、と。</p>
<p>CysharpとしてもMagicOnion、使っていきますし、ほんと是非是非使ってみてもらえると嬉しいです。コードジェネレーターもついにWin/Mac/Linux対応しましたので（まだ微妙にバグいのですが年内か、年明け早々にはなんとかします）、ガッツリと使っていけるのではないかとです。</p>
</div>
<h1 data-pagefind-sort="date:2018-12-25" data-pagefind-meta="published:2018-12-25"><a href="https://neue.cc/2018/12/25_571.html">UniTask(UniRx.Async)から見るasync/awaitの未来</a></h1>
<ul class="date"><li>2018-12-25</li></ul>
<div class="entry_body"><p><a href="https://qiita.com/advent-calendar/2018/c-sharp">C# Advent Calendar 2018</a>大遅刻会です。間に合った。間に合ってない。ごめんなさい……。今回ネタとして、改めてコード生成に関して、<a href="http://neue.cc/2017/12/04_560.html">去年は「動的」な手法を解説した - Introduction to the pragmatic IL via C#</a>ので、現代的な「静的」な手法について説明してみよう、と考えていたのですが、そういえばもう一つ大遅刻がありました。</p>
<p>7月に<a href="http://neue.cc/2018/07/12_567.html">UniTask - Unity + async/awaitの完全でハイパフォーマンスな統合</a>という記事を出して、リリースしたUniTaskですが、その後もちょこちょこと更新をしていて、内部実装含め当初よりもかなり機能強化されています。といった諸々を含めて、<a href="https://connpass.com/event/95696/">Unity 非同期完全に理解した勉強会</a>で話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/BtNztL3wrlBCWN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/deep-dive-asyncawait-in-unity-with-unitaskunirxasync" title="Deep Dive async/await in Unity with UniTask(UniRx.Async)" target="_blank">Deep Dive async/await in Unity with UniTask(UniRx.Async)</a> </strong> </div>
<p>9月！更新内容の告知もしてなければ、この発表のフォローアップもしてない！最近はこうした文章仕事がめっちゃ遅延するようになってしまいました、めっちゃよくない傾向です。来年はこの辺もなんとかしていきたい。</p>
<p>と、いうわけで、予定を変えてUniRx.Asyncについて、というか、それだとUnity Advent Calendarに書けよって話になるので、UniRx.Asyncは独自のTask生態系を作っている、これは.NET Core 2.1からのValueTaskの拡張であるIValueTaskSourceに繋がる話なので、その辺を絡めながら見ていってもらえると思います。</p>
<h2>Incremental Compilerが不要に</h2>
<p>告知が遅延しまくっている間にUnity 2018.3が本格リリースされて、標準でC# 7.xに対応したため、最初のリリース時の注釈のような別途Incremental Compiler(preview)を入れる必要がなくなりました。Incremental Compiler、悪くはないのですが、やっぱpreviewで怪しい動きもしていたため、標準まんまで行けるのは相当嬉しいです。というわけで今まで敬遠していた人も早速試しましょう。</p>
<h2>new Progress[T] is Evil</h2>
<p>これは普通の.NETにも言える話なのですが、C#のasync/awaitの世界観では進捗状況はIProgress[T]で通知していくということになっています(別にAction[T]でよくね？そっちのほうが速いし、説はある)。進捗はReport(T value)メソッドで通知していくことになりますが、こいつは<a href="https://referencesource.microsoft.com/#mscorlib/system/progress.cs,92">必ずSynchronizationContext.Post経由で値を送ります</a>。これがどういうことかというと、Unityだとfloatを使う、つまりIProgress[float]で表現する場合が多いはずですが、なんと、ボックス化します。(If T is a value type, it will get boxed here.)じゃねーよボケが。アホか。これはオプションで回避不能なので、new Progress[T]は地雷だと思って「絶対に」使わないようにしましょう。</p>
<p>代わりにUniRx.AsyncではProgress.Createを用意しました。これはSynchronizationContextを使いません。もしSyncContext経由で同期したいならマニュアルでやってくれ。Unityの場合、進捗が取れるシチュエーションはメインスレッド上のはずなので、ほとんどのケースでは不要なはずです。</p>
<p>こういった、あらゆる箇所での.NET標準の余計なお世話を観察し、Unityに適した形に置き直していくことをUniRx.Asyncではやってるので、async/await使うならUniRx.Asyncを使ったほうがいいのです。標準のも、今の時代で設計するならこうはなってないと思うんですけどね、まぁ時代が時代なのでshoganai。</p>
<h2>コルーチンの置き換えとして</h2>
<p>コルーチン、或いはRxでできた処理は、改めて全部精査して、全てasync/awaitで実装できるようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-txt">Add UniTask.WaitUntil
Add UniTask.WaitWhile
Add UniTask.WaitUntilValueChanged
Add UniTask.WaitUntilValueChangedWithIsDestroyed
Add UniTask.SwitchToThreadPool
Add UniTask.SwitchToTaskPool
Add UniTask.SwitchToMainThread
Add UniTask.SwitchToSynchronizationContext
Add UniTask.Yield
Add UniTask.Run
Add UniTask.Lazy
Add UniTask.Void
Add UniTask.ConfigureAwait
Add UniTask.DelayFrame
Add UniTask.Delay(..., bool ignoreTimeScale = false, ...) parameter
</code></pre>
<p>概ね名前からイメージ付くでしょう、イメージ通りの挙動をします。こんだけ用意しておきゃほとんど困らないはず（逆に言えば、標準のasync/awaitには何もありません）</p>
<p>ちなみにSwitchTo***は、最初のVisual Studio Async CTP(お試しエディション)に搭載されていたメソッドで、すぐに廃止されました。というのも、async/awaitが自動でスレッド(SynchronizationContext)をコントロールするというデザインになったからですね。あまりにも最初期すぎる話なのでこの辺の話が残っているものも少ないのですが、ちゃんと<a href="https://ufcpp.wordpress.com/2011/04/13/async-ctp-refresh/">岩永さんのブログには残っていた</a>ので大変素晴らしい。</p>
<p>UniRx.Asyncでは不要なオーバーヘッドを避けるため（そもそも特にUnityだとメインスレッド張り付きの場合のほうが多い）、自動でSynchronizationContextを切り替えることはせず、必要な場合に手動で変更してもらうというデザインを取っています。というか、今からasync/await作り直すなら絶対こうなったと思うんだけどなぁ、どうなんでしょうねぇ。ちょっとSynchronizationContextに夢見すぎだった時代＆Windows Phone 7（うわー）とかの要請が強すぎたせいっていう時代背景は感じます。</p>
<h2>Everything is awaitable</h2>
<p>考えられるありとあらゆるものをawait可能にしました。AsyncOperationだけじゃなくてWWWやJobHandle（そう、C# Job Systemもawaitできます！）、そしてReactivePropertyやReactiveCommand、uGUI Events(button.OnClickAsyncなど)からMonoBehaviour Eventsまで。</p>
<p>さて、AsyncOpeartionなど長さ1の非同期処理がawait可能なら、そらそーだ、って話なのですが、イベントがawait可能ってどういうこっちゃ、というところはあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ようするところこんな風に待てる
async UniTask TripleClick(CancellationToken token)
{
    await button.OnClickAsync(token);
    await button.OnClickAsync(token);
    await button.OnClickAsync(token);
    Debug.Log(&quot;Three times clicked&quot;);
}
</code></pre>
<p>コレに関してはスライドに書いておきましたが、「複雑なイベントの合成」をする際に、Rxよりも可読性良く書ける可能性があります。</p>
<p>Rxは「複雑なイベントハンドリング」を簡単にするものじゃなかったの！？という答えは、YesでもありNoでもありで、複雑なものは複雑で、難しいものは難しいままです。イベントハンドリングは手続き的に記述出来ない（イベントコールバックが飛び飛びになる)ため、コールバックを集約させて合成できるRxが、素のままでやるより効果的だったわけですが、async/awaitはイベントコールバックを手続き的に記述できるため、C#のネイティブのコントロールフロー(for, if, whileなど)や自然な変数の保持が可能になります。これは関数合成で無理やり実現するよりも、可読性良く実現できる可能性が高いです。</p>
<p>単純なものをasync/awaitで記述するのは、それはそれで効率やキャンセルに関する対応を考慮しなければならなくて、正しく処理するのは地味に難易度が高かったりするので、基本的にはRxで、困ったときの必殺技として手段を知っている、ぐらいの心持ちが良いでしょう</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async UniTask TripleClick(CancellationToken token)
{
    // 都度OnClick/token渡しするよりも最初にHandlerを取得するほうが高効率
    using (var handler = button.GetAsyncClickEventHandler(token))
    {
        await handler.OnClickAsync();
        await handler.OnClickAsync();
        await handler.OnClickAsync();
        Debug.Log(&quot;Three times clicked&quot;);
    }
}
</code></pre>
<p>↑こういう色々なことを考えるのが面倒くさい。</p>
<h2>Exception/Cancellationの扱いをより強固に</h2>
<p>UniTaskでは未処理の例外はUniTaskScheduler.UnobservedTaskExceptionによって設定されている未処理例外ハンドラによって処理されます（デフォルトはロギング）。これは、UniTaskVoid、或いはUniTask.Forgetを呼び出している場合は即時に、そうでない場合はUniTaskがGCされた時に未処理例外ハンドラを呼びます。</p>
<p>async/awaitが持つべきステータスは「正常な場合」「エラーの場合」「キャンセルの場合」の3つがあります。しかし、async/awaitならびにC#の伝搬システムは、正常系は戻り値、異常系は例外の二択しかないため、「キャンセルの場合」の表現としてawaitされた元にはOperationCanceledExceptionが投げられます。よって、例外の中で、OperationCanceledExceptionは「特別な例外」です。デフォルトではこの例外が検出されて未処理の場合は、未処理例外ハンドラを無視します。何もしません。キャンセルは定形の処理だと判断して、無視します。</p>
<p>また、例外を使うためパフォーマンス上の懸念もあります。そこで、UniTask.SuppressCancellationThrowを使うことで、対象のUniTaskが例外の発生源であれば（throw済みで上の階層に伝搬されたものではない)、例外の送出ではなく、Tupleでの戻り値としてキャンセルを受け取り、例外発生のコストを抑えることができます。これはイベントハンドリングなどの場合に有用です、が、正しく使うことは内部をかなりのレベルで理解していないといけないため、ぶっちゃけムズい。ただたんにSuppressCancellationThrowを使うだけでパフォーマンスOKというわけにはいかんのだ。というわけで、どうしてもパフォーマンス的に困ったときのための逃げ道、ぐらいに思っておいてください。</p>
<h2>UniTaskTracker</h2>
<p>とはいえなんのかんのでTaskがリークしてしまったり、想像以上に多く起動してしまっていたりもあるでしょう。UnityのEditor拡張でトラッキングウィンドウを用意したので、すべて追跡できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/50421527-abf1cf80-0883-11e9-928a-ffcd47b8c454.png" alt="image" /></p>
<p>こういうのRxにも欲しいわー。そうですね、なんか実装方法は考えてみようかとは思いますが一ミリも期待しないで待たないでください。</p>
<h2>IValueTaskSourceでWhenAllを進化させる</h2>
<p>.NET CoreのC#はTaskとValueTaskに分かれているわけですが、面倒くせーから全てValueTaskでいーじゃん、というわけにはいきません(なお、私の意見は全部ValueTaskでいいと思ってます、というのも使い分けなんて実アプリ開発でできるわけないから）。そうはいかない一番大きな理由はWhenAllで、このTaskで最も使われる演算子であろうWhenAllは、Taskしか受け取らないので、Taskへの変換が必要になってきます。せっかくValueTaskなのにモッタイナイ。じゃあValueTask用のWhenAllを作ればいいじゃん、というとそれも無理で、Task.WhenAllはTaskのinternalなメソッドに依存して最適化が施されているので、外部からはどうしても非効率的なWhenAllしか作れない仕様になっています（クソですね！）。</p>
<p>が、しかし、そもそもWhenAllってあんま効率的じゃなくないっすか？というのがある。と、いうのも、<a href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,6055">配列を受け取るAPI</a>でも、まず保守的にコピーしてるんですよね。可変長引数でWhenAll(new[]{ foo, bar, baz })みたいに渡してもコピーされてるとか馬鹿らしい！あと、WhenAllの利用シーンでもう一つ多いのが WhenAll(source.Select(x =&gt; x.FooAsync()))のような、元ソース起点に非同期メソッドを呼んで、それを全部待つ、みたいなシチュエーション。なんかねー、別に配列作んなくてもいいじゃん、みたいな気になるんですよね。</p>
<p>と、そこでIValueTaskSourceの出番で、Task(ValueTaskですが)の中身を完全に自分の実装に置き換えることができるようになった、のがIValueTaskSourceです。よって、真に効率的なValueTaskに最適化されたうえで↑のような事情を鑑みたWhenAll作れるじゃん、って。思ったわけですよ。</p>
<p>そこでMagicOnionでは(UniRx.Asyncじゃないのかよって、IValueTaskSourceはUnityの話じゃないですから！)<a href="https://github.com/Cysharp/MagicOnion/blob/master/src/MagicOnion/Utils/ReservedWhenAllPromise.cs">ReservedWhenAllPromise</a>というカスタムなWhenAllを用意してみました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var promise = new WhenAllPromise(source.Length);
foreach (var item in source)
{
    promise.Add(item.FooAsync());
}
await promise.AsValueTask();
</code></pre>
<p>のように書けます。つまり何かと言うと、WhenAllに必要なのは「個数」で、個数が最初から確定しているなら、それを渡せばいいし、WhenAll自体の駆動に配列は必要ないので、随時Addしてあげてもいいわけです。これで、一切配列を使わない効率的なWhenAllが実装できました。めでたし。</p>
<p>他にも型が異なるTaskをawaitするのにValueTupleで受け取りたい、というのをTask.WhenAllを介さずにその個数に最適化したWhenAllを用意するとか、やりたい放題にめっちゃ最適化できるわけです。</p>
<p>と、いうのも踏まえて、(サーバーサイドC#における)アプリケーションのTaskの定義はValueTaskで統一しちゃっていいと思うし、そのかわりに幾つかの最適化したValueTask用のWhenAllを用意しましょう。というのが良い未来なんじゃないかなー、って思ってます。(このValueTask用のWhenAllのバリエーションはCysharpとして作ったらOSSで公開するので、こちらは期待して待っててください！）</p>
<h2>まとめ</h2>
<p>UniRx.AsyncナシでUnityにasync/awaitを持ち込んで使いこなすのはかなりの無理ゲーなので、よほどUnity以外で使い込んできた経験がある、とかでなければ、素直に使って頂ければと思います。また、そうでなくてもUnity向けに完全に作り直しているUniTaskの存在価値というのは、スライドのほうで十分理解してもらえてるのではとも思っています。</p>
<p>別にCLRの実装は至高のものだ！ってこたぁ全然なくて、時代とかもあるんで、後の世に作り直されるこたぁ往々にめっちゃある。Microsoftのハイパーエンジニアが練りに練ったものだろうがなんだろうが、永遠に輝き続けるコードなんてあんまなく、時代が経ちゃあどれだけ丁寧に作られたものでも滅びるんです。人間もプログラムも老化には逆らえない（WPFなんて何年前のUIフレームワークなんでしょう!)。というわけで、あんまり脳みそ固くせず、自分の意志で時々に見直して考えてみるといいんじゃないでしょうか。(古の)Microsoftよりも(現代の観点では)私のほうが正しい、とか自信持って言っておきましょう。</p>
<p>さて、UniRx.Asyncは(UniRxも)まだまだ完成しきってるとは言えない、のにドキュメント放置、更新放置で例によって半年ぐらい来てしまったのですが、その間は<a href="http://neue.cc/2018/10/31_570.html">株式会社Cysharpを設立しました</a>であったり、<a href="http://tech.cygames.co.jp/archives/3181/">MagicOnionのリブート</a>であったり、結構わたわたしてしまったところがありなのですが、ようやく諸々落ち着いてきたので、また腰据えて改善に取り組んでいきたいと思います。まぁドキュメントが全然足りないんですけど(UniRx.Asyncの機能は、かなり膨大なのです……)。</p>
<p>C#的にも、自分でTaskの全域を見つめ直して作り直すという経験を通して得られたものも多かったので、今回の記事もそうですが、Unity関係なくasync/awaitを使っていく上で使える話は色々出せていければというところですね。ではまた次回の更新の時まで！次こそはすぐブログ書きますから！</p>
</div>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
