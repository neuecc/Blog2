<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc - 2015</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2015/12/31_524.html">2015年を振り返る</a></h1>
<ul class="date"><li>2015-12-31</li></ul>
<div class="entry_body"><p>振り返るシリーズ第四弾。去年の目標は</p>
<blockquote>
<p>テーマは「クライアントサイドとサーバーサイドをC#で統一することのメリットの実証」「さらにリアルタイムネットワークもC#で統一」「のためのヒットアプリケーションの創出」です。指向はあんま変わってないんですが、より具体的に。来年は動く年かな、といったところ</p>
</blockquote>
<p>ようするに会社(<a href="http://grani.jp/">グラニ</a>/CTO)でゲーム出して実証する。であり、結果としては……。はい。なので、本当に来年こそはね。というところです。</p>
<h2>C#</h2>
<p>今年はVS2015のリリースということもあり、かなりRoslynに傾倒しました。その集大成としてのまとめは<a href="http://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a>にスライドで出してますが、その後にもAnalyzerだけではなく、<a href="http://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a>や<a href="http://neue.cc/2015/12/21_523.html">Workspace APIを使ったプロジェクトコードからのT4生成での応用例</a>といった形で、ただたんに触ってみた、ではなくて、実用的にどう使えるのか、の応用例をきっちり掲示できたんじゃないかと思います。これらの話は実際に使っているもので、便利、かつ世界が広がったのは確かなので、Roslynはこれからどんどん応用的に使われるといいかな。</p>
<p>また、いつになくライブラリ書いてました。会社で必要だから作ってったという面も大きいんですけれど、こうして並べると、実際結構やりましたね、えらいえらい。</p>
<p>まずAPIサーバーとして<a href="https://github.com/neuecc/LightNode">LightNode</a>という自家製フレームワークを採用しているので、<a href="http://neue.cc/2015/02/16_505.html">Glimpse対応</a>と<a href="http://neue.cc/2015/04/19_511.html">Swagger対応</a>を入れてます。この対応は大正解で、もはやGlimpseとSwaggerなしでAPI開発していくのは無理ゲーとすら思える。超絶便利。Glimpseは主要開発者がMicrosoft入りしてより専任して開発することになったのと、Swaggerはもはやウェッブ標準といってもいい立ち位置を確立したということで、どちらもメジャーなテクノロジとなったことも含めて、技術選定にも成功したと言えるでせう。ASP.NET 5がまだまだ時間かかるので様子見したのも含めて、現状での最適解ではあるんじゃないかな、と。</p>
<p>Redisライブラリの<a href="https://github.com/neuecc/CloudStructures">CloudStructures</a>もGlimpse対応とStackExchange.Redis対応によって、相当リッチなものになりました。特にGlimpseのは相当気合入れたので充実してて実用度超絶高い。とはいえ本体部分は原則的には薄いラッパーなので、粛々とやってきます、というところですね。</p>
<p><a href="https://github.com/neuecc/LINQ-to-BigQuery">LINQ to BigQuery</a>はLINQPad Driverを作りました！これで実用度が飛躍的に上がりました。世間的にもデータ分析はBigQueryで決まりだよね！という流れが出来上がった年なわけですが、ここも乗り遅れずというか、むしろ引っ張る側に回れたのではないかと自負するところです。あとLINQPadにも相当詳しくなった。</p>
<p>今年最後の新顔は<a href="https://github.com/neuecc/EtwStream">EtwStream</a>で、↑でLINQPadに詳しくなった結果、応用例が頭に浮かんで一気に実用に載せられました。ETW(Event Tracing for Windows)のビューアーとしてまともに使える世界唯一の解といっても過言ではない（むしろ今までのフベンサがヤバすぎた……）。年末にはRoslyn C# Scriptingによる実行できるコンフィグというコンセプトを打ち出したOut-of-Process Serviceも追加していて、来年はこれの稼働実績を作っていきたいところです。</p>
<p>変わり種だけど誰にとっても実用度100億なのは<a href="https://github.com/neuecc/Open-on-GitHub">Open on GitHub</a>というVS拡張で、もはやこれなしでぎっはぶでコミュニケーションを取るのは無理なのでは疑惑もあるほどに神拡張。地味に12/29にVer 1.4.0のアップデート出してます。</p>
<p>そして<a href="https://github.com/neuecc/UniRx">UniRx</a>。今年はお陰様で大躍進の年で、<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;ref=searchresults&amp;s=stars&amp;type=Repositories">GitHubスター順</a>でも、GitHubで公開されてるUnity用ライブラリでは世界4位と、中々に中々の感じで、いやほんと良かった。</p>
<p>年の始めではReacitvePropertyやPresenterBaseの導入によるModel-View-(Reactive)Presenterというコンセプトの確立が地味に大きめ（ちなみに私は設計とかってこのレベルの話こそ最も大事だと思ってて、コードを小奇麗にするようなレベルの話は設計、ですかねえ？とは思ってる）。真ん中でObservableTriggers、そして年末駆け込みの<a href="http://neue.cc/2015/12/21_523.html">UniRx 5.0</a>で完全書き直しによるパフォーマンスとデバッガビリティの向上。もはやUniRxなしで書けと言われると困りすぎるぐらいに必要不可欠な存在となれました。</p>
<p>UniRxが成功したポイントは、Reactive Extensions自体が素晴らしいコンセプトで実績もある、というのも勿論そうなんですが、UniRx自体の、Unityへフィットさせるための繋ぎ方の工夫の面も大きいとは自負してます。あまり頭でっかちにならずに柔軟に作り込めたのが良かった。ReacitvePropertyなんかも、実装はシンプルですが、（.NET版を作った時の）コンセプト立証と実装には普通に時間かけてたし、そもそもコロンブスの卵的なところもありましたし、更にそのUnity化でも、削ぎ落とし方には相当神経使ってます（ゴテゴテ足すだけが設計ではない）。</p>
<p>また、お陰様でUnityのスクリプティングと、そしてRxには詳しすぎるほどに詳しくなれました、というかRxに関しては実際隅から隅まで理解した……。</p>
<p>現在未公開だけど予定があるものとしては<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>というUnity/Photon Server用の非同期RPCフレームワークがあります。これは来年の初頭に公開できればな、ですかねー。</p>
<h2>お仕事</h2>
<p>書いたライブラリは基本的に会社でフルに使ってるものなので、成果っちゃあ成果です。が、集中力散漫な年でした。成果として些かライブラリ過多になったのは、それが時間の捻出が比較的しやすい（土日とかにちょっと徹夜して気合いれればグッと形にできたりするんで）というのが大きいですね。細切れな時間で、いまいちうまくプロダクトそのものにコミットできなかったのは減点度大きめで、非常に良くない。ライブラリ側の成果と相殺してプラマイゼロと言いたくはあるんですが、私的な理想像とは離れたところにあるので、まぁ、60点ぐらい……（ちょっと甘め）</p>
<p>いろいろと白髪が増える、ハゲる。といったぐらいな感じです、うみぅ。来年は100点目指します。</p>
<h2>ゲームとか音楽とか</h2>
<p>今年はライブにまぁまぁ行ったんですが、年末の<a href="http://www.creativeman.co.jp/artist/2015/12kingcrimson/">King Crimsonの来日講演</a>が震えすぎたのでそれが全て。生きててよかったというか生きてるうちに生で聴けることがあるなんて……！内容もばっちしで、いやはやホンモノは永遠にホンモノであり続ける、というかホンモノであり続けようとする姿勢に感服するばかりです。この編成での本気のライブ版が早く出てほすぃ。</p>
<p>面白かったといえば<a href="http://www.beatink.com/Labels/Warp-Records/Squarepusher/BRC-461/">Squarepusherの来日講演</a>も見に行ったのですが、実に面白かった。サイトでは360度動画が公開されてますが、そうした全方位動画やプロジェクションマッピング、VRの未来すら感じられて、思い出すと行けて本当に良かったなぁ。</p>
<p>ゲームは<a href="http://downwellgame.com/">Downwell</a>がオモシロイッス。</p>
<p>漫画は、iPhone 6s Plusを買ってから、スマフォで本や漫画が十分に読めるようになってしまって革命的に体験が変わった。いやあ、大画面スマフォ（ファブレット）は良いですね！一度体験すると、もう小さいのには戻れない。というわけで基本Kindleで買ってiPhoneで読むというインスタントな生活になりました。今年読んだ中だと<a href="http://www.amazon.co.jp/dp/B00U0OMIQA/">ヴァーチャル・レッド</a>が良かったかなぁ、終始、陰鬱な空気が流れていて息苦しいんだけどどこか心地良くもある。気に入りすぎてKindleで読んだ後に実書籍のほうも買ったんですが装丁がよく出来てて、そちらも満足度高し。</p>
<h2>来年</h2>
<p>シンプルに、全力で仕事してゲーム出す。ですね。それ以外なし。もちろん、それはC#を全方面で活かした実証結果として成り得るものです。絶対。これは絶対。</p>
<p>私個人としてはヌルヌルとC#でのスクリプティングにだけ篭もりすぎた感あるので、UniRxも一段落したことだし（ちなみに、もう少し性能向上のためのアップデートが控えていてというか現在審査中なので年明け早々にそれはリリースされるでしょう）、シェーダーをそれなりにすらすら書ける程度にはグラフィック処理もできるようにってのは年頭の宿題にしておきます。</p>
</div>
<h1><a href="https://neue.cc/2015/12/21_523.html">UniRx 5.0 - 完全書き直しによるパフォーマンス向上とヒューマンリーダブルなスタックトレース生成</a></h1>
<ul class="date"><li>2015-12-21</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx(Reactive Extensions for Unity)</a>のVer 5.0が昨日、AssetStoreにリリースされました。前回が4.8.2で6月なので、半年ぶりで、今回はメジャーアップデートとなります。現在の最新であるUnity 5.3（の新機能）に対応というのもあります、が、今回の目玉は書き直しです。半年間なにやっていたかというと、書き直そう！いよいよやっと重い腰を上げてスタックトレースに優しいコードにしよう！と思い立って始めてみたもののメンドウくささが極まって挫折して放置。してたんですが、先月ぐらいに、いい加減に手を付けたくて、ちょっと<a href="http://grani.jp/">うちの会社</a>の仕事時間を貰ってゴリゴリ進めてやっと終わりました。</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub - UniRx</a></li>
<li><a href="http://u3d.as/7tT">UnityAssetStore - UniRx</a></li>
</ul>
<p>とりあえず分かりやすい成果としては、スタックトレースです。</p>
<pre><code class="language-csharp">var rp = new ReactiveProperty&lt;int&gt;();

rp.Where(x =&gt; x % 2 == 0)
  .Select(x =&gt; x * x)
  .Take(10)
  .Subscribe(x =&gt; Debug.Log(x));

rp.Value = 100;
</code></pre>
<p>という人畜無害なコードがあるとして、以前のスタックトレースはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917884/404287a0-a75d-11e5-9aee-ebe8d5bb28e3.png" alt="image" /></p>
<p>言ってることはわからんでもないコンパイラ生成の何かと、多量の中間物で埋まっていて、実に読み取りにくい。この程度のメソッドチェーンならまだマシで、もっと長大で、複雑なオペレータが絡んでる場合は困難極まってました。私も何度文句を言われて平謝りしたか分からないぐらいです。しかし、今回のバージョンからはこうです。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11917889/765ebcf0-a75d-11e5-8117-f2b85a4113af.png" alt="image" /></p>
<p>自動生成コードなし、中間物ナシ。圧倒的な読みやすさ！また、これはそのまま、書いたとおりに動いているということの証左でもあります。実行パイプラインの無駄がスタックトレースに出ているままに皆無になったので、パフォーマンスにも寄与しています（書き換えた今では、もはや前のが厚すぎた説はありますけれど、それはまぁ言わんといてください……）</p>
<p>実装はかなりメンドウで、ラムダ式を使うと問答無用でコンパイラ生成のクラスが吐かれてしまうので、ひたすら名前付きのクラスを作っていくお仕事をしました（一個のオペレーターにつき2~3のクラスを要求する、オーバーロードがあればその分だけ……）。また、Unityのコンソールの出力に合わせた細かい調整を施すことによって（＋通常のスタックトレースへの吐かれ方に対しても調整して）作りました。すっかりスタックトレースのことを考えたプログラミングができる脳みそが出来上がったんですが、基本的に面倒くさ度100なので、ふつーのゲーム側のコードでは考えたくないしやりたくもないしやらなくていいと思ふ。</p>
<h2>性能改善</h2>
<p>じゃあ前のは遅かったのかよ、と言われると、うーん、そんなでもないですよ？、とは言いたいのですけれど、まぁカタログスペック的には実際3~10倍ぐらい速くなってます。これはねぇ、例えばMySQL 5.7が5.6の3倍速い！なるほど、じゃあ5.6はゲロ遅なのか？そうじゃあないっしょー、みたいな話なのですが、実際速くなったのは誰にとっても私にとっても嬉しい話です。</p>
<p>しかし、パフォーマンス低いとか気になるとか、漠然とした話で、何も言ってないに等しいんです。もちろん、3~10倍速くなったというのも何も言っちゃあいないです。プログラムの抱えている範囲に対して広すぎる、漠然としすぎていて何ら指標になっちゃいません。というのは気をつけてください。Rxのパフォーマンスを測るにあたって、フェーズ的に3つあって、</p>
<ul>
<li>Observableを構築するフェーズ(さすがにこれはほとんど無視していい)</li>
<li>Subscribe = Observerを構築するフェーズ</li>
<li>OnNext</li>
</ul>
<p>それぞれは独立して考える必要があります。また、ReactivePropertyはSubscribeと同時にOnNextも一回入るのでSubscribe + OnNextである、などなどがあるので、どこをどう測りたいかを明確にし、どう測るかを考えないとザルな結果になります。</p>
<p>基本的に、Rxのチェーンの寿命は長いのでOnNextの性能を最重要視して見るべきです。ここの区別は非常に大事です、長ければチェーン構築コストは相対的に無視できる範囲に収まるのでマイクロな結果で想像するのは違うってものです。が、初回に大量にSubscribeが発生するといった、ローディング的な意味合いでは、Subscribeのフェーズも鑑みる必要があります。</p>
<p>んで、これもザックリとしすぎでアレなんですが、OnNextは3~5倍ぐらい、Subscribeに関しては10~20倍速くなりました。OnNextは全体的なパイプラインの最適化のオペレーターの実装調整が効いてるんですが、Subscribeは抜本的に最適化/単純化したので、以前と全然違う結果になってます。これは、社内で大量のSubscribeがシーンロード初回に発生するという事案がありまして、Subscribeを改善しない限りロード長過ぎで終わぽ、だったのでなんとかしました、はい、すびばせん今まで手付かずで……（ちなみに本家Rx.NETとやり方変えてるので本家Rx.NETよりも速い）</p>
<p>あとのところはオペレーター次第です。WhereとかSelectとか、単純な奴は実装変わってないんで大差ないんですが、一部のメソッドの実装が素朴でしょっぱかったので、そういうのはきっちり直してるので以前のと全然性能変わってきてます。特にObserveOnが顕著かな。また、Observable.IntervalやTimerなどの一部の時間系メソッドも構造がガラッと変わってるので(MainThreadScheduler/ThreadPoolSchedulerが使われる場合には最適化パスを通るようにしてる)、かなり良好な結果が得られるのではないかと。</p>
<p>全体的にGCゴミも減ってます。まだもう少し減らせるポイントが残ってるので、次のマイナーアップデートではその辺の処理をする予定デス。</p>
<h2>リリースノート</h2>
<p>今回の。</p>
<pre><code class="language-txt">破壊的変更:
iOS/AOTサポートは切りました。IL2CPPしかサポートしません。
Unit/Tuple/CancellationToken/TimeInterval/Timestampedをclassからstructに変えました。
MainThreadDispatcher.Postのメソッドシグネチャが変わり、T stateを要求します。
ObservableMonoBehaviour/TypedMonoBehaviourがObsoleteになりました。
AotSafe Extensions(WrapValueToClass)を消しました。
InputField.OnValueChangeAsObservableをOnValueChangedAsObservableにリネームしています(Unity 5.3の場合。Unity 5.3でInputField側で同様の変更が入っているため)
Subscribe in SubscribeでのException Durabilityを保証します。

追加メソッド/クラス:
Observable.ForEachAsync
Observable.Take(duration)
Observable.Aggregate
Observable.Zip(T3~T7)
Observable.CombineLatest(T3~T7)
Observable.Start(function, timeSpan)
Observable.ToYieldInstruction in Unity 5.3
Observable.DoOnError
Observable.DoOnCompleted
Observable.DoOnTerminate
Observable.DoOnSubscribe
Observable.DoOnCancel
Observable.CreateSafe
Progress
StableCompositeDisposable
MultilineReactivePropertyAttribute

その他色々修正:
色々色々(詳しくはGitHubのとこの正式なリリースノート見てくだしあ)
</code></pre>
<p>破壊的変更といっても、直撃することはないんじゃないかなあ、と思ってます。ただ社内ではUnit/Tupleのstructへの変更で引っかかったりはしました(想定外にもnullが代入されている場合があった！)。それは適切にdefault使うのと、Tupleに関してはTuple?にするなりする程度で対応はできます。struct化はAOTサポートを切ることで躊躇いなくできるようになって、ヨイことだなー、と。コードも全体的にAOTサポートのための余計なコードを順次切り落としています（パフォーマンスロスに繋がっていたので）。その辺はIL2CPPバンザイ、ですかねえ。</p>
<h2>vs IL2CPP - Runtime UnitTest Runnner</h2>
<p>IL2CPP万歳と言ったそばから言うのもアレですが、IL2CPP苦しい……。コンパイル死ぬほど遅いし、というのはおいておいても、まだ地雷は埋まっていて、たまに踏んで死ぬんですよね。その場合IL2CPPのバグなんで報告して直してもらうってことになるんですが、それはそれとして、なんで死ぬのかがAOTの場合は想像ついたし対処も比較的容易だったんですが、IL2CPPは踏むまで地雷かどうかを察知することが不能な上に、踏んだら踏んだで、何を踏んだからこうなったかがイマイチ分からなくて最小ケース作ってバグレポも辛いケースもちらほら。</p>
<p>とはいえ、それなりに安定してきてるのは確かだと思います。偉い。そこは賞賛されるべき。</p>
<p>のはいいんですが、実行するまで分からないじゃ（特にライブラリ側としては）困るので、iOS実機でユニットテストを動かしたいと思いました。Unity 5.3から<a href="http://docs.unity3d.com/Manual/testing-editortestsrunner.html">Editor Test Runner</a>なども標準で入ってきましたが、端的に言えば、欲しいのはそれじゃない。実機で動かしたいの！エディターでの実行はどうでもいいの！</p>
<p>エディター上での実行も大事なんですが、元々UniRxは.NET用ライブラリとしても動くように設計されていて、ユニットテストも.NET用ライブラリとしてMSTestで書かれている（！）という特殊な環境なので、エディターでのテストサポートは完全に不要なのです。いや、だってVSのテストランナー使ったほうがやりやすいじゃん？</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919089/a1042f8e-a78b-11e5-9b65-fbca28a5da13.png" alt="image" /></p>
<p>そうやってユニットテスト自体は書かれてるし、さすがに実機用に別のを書きなおすのは不可能なので、このユニットテストを実機で動かせるように持ってければそれでいいんだよねー。</p>
<p>ここで出てくるのが<a href="https://github.com/dotnet/roslyn">Roslyn</a>。Roslynを使ってユニットテストプロジェクト内のユニットテストを、ソースコードのファイル単位ではなく、解析可能な構文木単位で取得し、<a href="https://msdn.microsoft.com/ja-jp/library/bb126445.aspx">T4 Text Template</a>で整形して吐き出せちゃえばいいんだ、という合わせ技で運搬することに成功しました。VS2015だから出来るハック、VS2015最高……。さすがにコード持ってくだけではMSTestの実体がなくて動かないんですが、そこは適当にモック(Shim)を用意して回避しました。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11919143/db2b7fae-a78c-11e5-8dea-6e7e99598bd2.png" alt="image" /></p>
<p>エクストリーム雑なUI。エラーが出た場合は赤くなってExceptionを表示します。これで、ちゃんとiOS/IL2CPPで全部パスしてるのを確認済みです。</p>
<p>ちなみにこのRoslyn + T4でコード生成するテクニック、今回のように別プロジェクトをターゲットにして運搬するというのもいいんですが、自プロジェクトを対象にすることもできます。T4で生成するためのコードのタネって、今まではT4側に書くしかなくて面倒だったんですが、もうその制限はありません。ありとあらゆるソースコードがコード生成のためのタネとして使えます。メタプログラミングの扉をまた一つ開いてしまった。</p>
<p>このテクニックは私の発明じゃなくて<a href="http://www.misuzilla.org/Blog/2015/12/04/UsingRoslynInT4Template">RoslynをT4テンプレート内で使う - ぷろじぇくと、みすじら。</a>から拝借してますので、気になる人はそちらの記事をどうぞ。ｌ</p>
<h2>Unhandled Exception Durability</h2>
<p>UniRx 5.0の変更のうち、ちょっとだけ重要なのがUnhandled Exception Durabilityというコンセプト。です。これは、Rxでイベントハンドリングするのはいいんだけどエラーでるとイベント購読が吹っ飛ぶの困るんだよねー、に対するUniRxからの回答ということで。内容ですが、Subscribe in Subscribe時の例外を外側に伝搬「しない」ことを保証しています（逆に言えば実は4.8では保証されてなくて解除されたりしてました。ちなみにRx.NETでも保証されてなくて解除されたりされなかったりします、ここはUniRx独自で挙動を明言する形に倒しています)。伝搬しない、というのは握りつぶすという意味ではなくて、ObservableのDispose処理を行わない、という意味です（例外自体はグローバルに飛ぶのでUnityのConsoleにExceptionが表示されるし、ログイベントでちゃんと捉えられます）</p>
<pre><code class="language-csharp">button.OnClickAsObservable().Subscribe(_ =&gt;
{
    // もし内側でエラーが発生しても、外側のOnClickがデタッチされることはない
    ObservableWWW.Get(&quot;htttp://error/&quot;).Subscribe(x =&gt;
    {
        Debug.Log(x);
    });
});
</code></pre>
<p>エラーハンドリングは難しい問題で、<a href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling">RxJavaのErrorHandlingの章</a>を読んでも別にそんなワカラナイよね、とかって感じではある。UniRxでは Retry/OnErrorRetry でハンドルできなくはなく、まぁそれがスタンダードなRx Wayではあるんですが<a href="http://qiita.com/bouzuya/items/5e068659d63d9961a260">RxJS の Operators (6) - Observable のエラーハンドリング</a>のまとめコメント「これで本当にエラーハンドリングに十分なのか不安です。」とあるように、実に不安です。</p>
<p>で、入力用のハンドラーが吹っ飛ぶのは致命傷なので、どうしても救いたいその辺のとこに関してはSubscribe in Subscribeで処理するのがいいんじゃないかなー、というのを提唱します。入力イベントを合成したいって局面も多いと思うので、それはそれで合成してもらったうえで（そして、その合成パイプラインに関してはエラーが出ないよう厳重に作る！）、それを入力ストリームだと考えて、そこから先はSubscribe in Subscribe。あまり格好の良いものではないのも事実ですが、現実的っちゃあ現実的かなー、と。ちなみにこの挙動を保証するのはUniRxだけだと思うので他のRx系に持ってっても動きません（多分）</p>
<p>なお、Subscribe in Subscribeでの例外で解除されないのは最上流がHot Observableのものだけです。HotとColdに関しては<a href="http://qiita.com/toRisouP/items/f6088963037bfda658d3">RxのHotとColdについて</a>などを参照するといいと思いますが、とりあえず具体的にHotなのはUniRxデフォルトでは FromEvent/Subject/ReactiveProperty/ObservableTriggers/UnityUI.AsObservable です。ようはイベント的なやつです。Coldなのは Return/Interval/Timer/FromCoroutine などで、これらは例外で解除されます（そうじゃないとTimerとか無限に動き続けられても危なくて困るでしょ？FromCoroutineだって途中でエラーが出てる状態なのに回られても困るでしょ？）</p>
<h2>CustomYieldInstuction</h2>
<p>書き直しはいいんだけど、何か新機能ないと寂しいよなー、ということで、Unity 5.3用に一つ入れました。Unityブログでも<a href="http://blogs.unity3d.com/jp/2015/12/01/custom-coroutines/">カスタムコルーチン</a>として紹介されていますが、Unity 5.3からCustomYieldInstructionが搭載されました。というわけでUniRxもUnity 5.3以上ならToYieldInsturctionメソッドが使えるようになっています。</p>
<pre><code class="language-csharp">IEnumerator TestNewCustomYieldInstruction()
{
    // Rx Observableをyield returnで待ちます.
    yield return Observable.Timer(TimeSpan.FromSeconds(1)).ToYieldInstruction();

    // スケジューラを変える(Time.scaleを無視する)とかも当然可能
    yield return Observable.Timer(TimeSpan.FromSeconds(1), Scheduler.MainThreadIgnoreTimeScale).ToYieldInstruction();

    // 戻り値を得る場合はObservableYieldInstructionを変数に取れば、Result/Errorで受け取れます
    var o = ObservableWWW.Get(&quot;http://unity3d.com/&quot;).ToYieldInstruction(throwOnError: false);
    yield return o;

    if (o.HasError) { Debug.Log(o.Error.ToString()); }
    if (o.HasResult) { Debug.Log(o.Result); }

    // 当然こういう長めのものだって自由に書けます 
    yield return this.transform.ObserveEveryValueChanged(x =&gt; x.position)
        .FirstOrDefault(p =&gt; p.y &gt;= 100)
        .ToYieldInstruction();
}
</code></pre>
<p>今までもToAwaitableEnumerator/StartAsCoroutineというメソッドで同様なことを出来るようにしていたのですが、ToYieldInsturctionのほうが効率的だし、使いやすいです。ToYieldInsturctionによるObservable-&gt;Coroutine変換のオーバーヘッドはないといっても過言ではない！Unity 5.3最高！</p>
<p>ちなみに、このToYieldInsturctionはCustomYieldInstructionクラスを実装してません。Unity 5.3のカスタムコルーチン対応というのは、yield returnでIEnumeratorを受け取ると毎フレームMoveNextを呼び出して待機する、というのが正しい話です。CustomYieldInstructionはあくまでIEnumerator実装のためのちょっとしたヘルパーなので、別にそれにこだわる必要はありません、ということで普通に独自の軽量なIEnumerator実装を刺しています。</p>
<p>ちなみに実行されるタイミングは<a href="http://docs.unity3d.com/530/Documentation/ScriptReference/CustomYieldInstruction.html">CustomYieldInstructionの説明</a>によると after MonoBehaviour.Update and before MonoBehaviour.LateUpdate だそうなので、実行タイミング調整のネタに使えるかもしれません。</p>
<h2>まとめ</h2>
<p>実際のトコver 2.0なんですが、諸事情で4始まりなのでver 5.0です！Unityのメジャーバージョンと偶然揃ったしいっか、という気がしますね！今回のコードはかなり自信あって、パフォーマンスがー、な局面であってもお薦めできます。どうせ、ライトウェイトを冠した超機能限定版の同じようなものを実装するなら、性能面であっても素直にUniRxを使ったほうがいいでしょう。と、言えます。言えます。</p>
<p>今月頭に書いた<a href="http://neue.cc/2015/12/03_521.html">Unity 5.3のMulti Scene EditingをUniRxによるシーンナビゲーションで統合する</a>などのように、UniRxを前提に置くことで、やれることが大幅に広がります。根底から入れれば全体のプログラミングの世界観が（良くも悪くも）大きく変わります。が、まぁそれはエキセントリックすぎるということであれば、触りは単純なところからでも全然アリかな、とは。思います。特に非同期/マルチスレッド関連は、変なライブラリ入れるよりもずっと良いでしょう。</p>
<p>ところで半年前、今年6月に<a href="http://neue.cc/2015/06/20_514.html">第一回UniRx勉強会を開催しました</a>が、第二回の需要ってありますか？もしありましたら、その前に発表者が必要！なので、是非話したい！人は、私のTwitterかメールかに連絡ください。開催するにも発表者いなければ開催もなにもないですからね……！</p>
<p>ついでにもはや触れちゃいけない扱いの気がしなくもない<a href="http://asecon.unity3d.jp/">Unity アセットコンテスト</a>というのに応募していたのですが結果発表……。</p>
</div>
<h1><a href="https://neue.cc/2015/12/13_522.html">Roslyn C# Scriptingによる実行できるコンフィグの手法と実活用例</a></h1>
<ul class="date"><li>2015-12-13</li></ul>
<div class="entry_body"><p>Advent Calendar大遅刻組です。というわけで<a href="http://qiita.com/advent-calendar/2015/csharp">C# Advent Calendar 2015</a>の10日目です！なんで遅刻したかというと、記事のネタのためのライブラリを作るのに思いの外時間がかかってしまったから…… コンセプトも固まってたしプロト実装も済んでたんですが、最終的な形に落としこむのが想定よりちょっと割と大変だった……。すびばせんすびばせん。</p>
<p>どうやらC# Advent Calendarは2011年から書いてるので5回目ですね、へぇー。過去を振り返ると<a href="http://neue.cc/2011/12/16_359.html">Modern C# Programming Style Guide</a>、モダンつってもC# 4.0時代ですが、今ぱっと見直すと別にここで言ってることは今も変わらないですね、これに5.0, 6.0の話を足せばいいだけの話で。2012年は<a href="http://neue.cc/2012/12/03_389.html">MemcachedTranscoder - C#のMemcached用シリアライザライブラリ</a>ということで、このライブラリは別に私自身も使ってないので割とどうでもいー、んですが、まぁシリアライザにまつわる諸々についての知見が少しは入ってる模様。2013年の<a href="http://neue.cc/2013/12/04_435.html">非同期時代のLINQ</a>はいい話だなー、これがC# 5.0のModern Styleの追記差分みたいなもので、実際、今現在においては超絶大事な部分。2014年は<a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a>で、C# 6.0ではないですが、その世代ではAnalyzerは中心になってくるので、これがC# 6.0の差分といってもいいでしょう。多分きっと。</p>
<h2>Roslyn C# Scripting</h2>
<p>Roslyn、Compiler as a Serviceとか言ってましたが、やっぱスクリプティングが華形だと思うのです。が、しかし。が、しかし。今の今までRoslynに関する話題で、Scripting APIに関するお話はあまり上ってませんでした。理由は単純で、今の今まで未完成品だったから。先月末に出たVisual Studio 2015 Update 1でC# Interactiveが、そして同時にNuGetでも<a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.CSharp.Scripting">Microsoft.CodeAnalysis.CSharp.Scripting</a>で、現在は1.1.1が配布されることにより（ところでこれのパッケージ名が中々定まらなくて実際これであってるのか不安だけどLast updatedが2015/12/3なのでこれでいいでしょう、まだDL数が405ですけど！）やっと全てのピースが揃った感じです。</p>
<p>Scriptingについてのドキュメントは、RoslynのWikiにある2つのページを見ておけば十分でしょう。<a href="https://github.com/dotnet/roslyn/wiki/Interactive-Window">Interactive-Window</a>には、csxの仕様っぽいもの、特殊なDirectiveの説明があります(#rとか#loadとか)。<a href="https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples">Scripting-API-Samples</a>にはプログラムから触った時のAPIとしてどんなものを持ってるか、どういう風に使えるかが書いてあります。かなりシンプルなので、そんな難しくなくすぐ使えます。</p>
<p>ちなみにC# Interactiveはまだまだ全然使えないって感じなので、期待するほどのものでもないですね。csxもエディタサポートが実質、シンタックスハイライトぐらいなので厳すぃ。黙って<a href="https://www.linqpad.net/">LINQPad</a>使いましょう、課金しましょう。</p>
<h2>Roslyn時代のコンフィグ</h2>
<p>最近というか数年前からずっと構造化ログにご執心で、<a href="http://neue.cc/2015/11/03_520.html">EtwStream - ETW/EventSourceのRx化 + ビューアーとしてのLINQPad統合</a>というのを作ってたんですが、今回はそれに、ファイル等への出力プラグイン(Sink)と外部サービス(EtwStream.Service)を作りました。アプリケーションから出力されるログは、ETWというWindows内部に流れてる高速なロギングストリーム機構を通して、別プロセスのEtwStream.Serviceで受け取ります。ログは特に最近ではファイル出力など比較的安定性が保証されているものだけでなく、ネットワークを通じて配信するケースも少なくありません。ログの扱いが別プロセスに別れることにより、アプリケーションに与える影響が少なくなるほか、アプリケーションの状態(アプリ自体の終了/デプロイでの入れ替わり等)に気を配る必要もなくなります。</p>
<p>というのが外部サービスであることの意義なのですが、問題はコンフィグです。コンフィグ。元々EtwStreamはObservableEventListenerという、IObservble&lt;LogEvent&gt;の形でログをストリームで受け取り、それをRxで自由にフィルタしたりグルーピングしたりマージしたりなんでも出来ますよね、という究極の自由度がウリでした。しかしコンフィグです、Rxのその柔軟性をコンフィグで実現するのは不可能です。物凄く機能を削った単純なSubscribeで我慢するか、あるいは超絶複雑なXMLでそれっぽいものを構築するか(log4netやNLogのXMLコンフィグが死ぬほど難解で複雑なのは、ログのルーティング自体が複雑で、それをコンフィグで表現することが困難だということなのです）になります。</p>
<p>せっかく、ログを現代的なReactive Extensionで表現することができたのに、外部サービスにした途端に破棄しなければならないのか。それでいいわけがなく、そこでC# Scriptingの出番になります。EtwStream.Serviceはコンフィグをconfiguration.csxとして、以下のように書きます。</p>
<pre><code class="language-csharp">// configuration.csx

// 5秒 or 1000件でバッファリング(ふつーのRxのBufferを利用)
// 出力フォーマットは普通にFunc&lt;TraceEvent, string&gt;で整形できる！
ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
    .Buffer(TimeSpan.FromSeconds(5), 1000, EtwStreamService.TerminateToken)
    .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
    .AddTo(EtwStreamService.Container);
</code></pre>
<p>基本的に完全にC#そのものなので、全てのRxのメソッドが使えて自由に合成・ルーティングが可能です。これはIn-Processで書いてる際（普通のロガーとしてC#コードで埋め込む場合）もOut-Of-Process Serviceでコンフィグとして書く場合も（ほぼ）同じコードで表現できるということです。もちろんC#で書けるということは、 System.Configuration.ConfigurationManager.AppSettings から設定を引っ張ってきたり、ネットワーク通信して何か引っ張ってきたりとかも自由自在やりたいほーだいです。</p>
<p>例えばこれをNLogで表現すると</p>
<pre><code class="language-xml">&lt;targets&gt;
    &lt;default-wrapper xsi:type=&quot;BufferingWrapper&quot; bufferSize=&quot;1000&quot; flushTimeout=&quot;5000&quot; /&gt;
    &lt;target name=&quot;file&quot; xsi:type=&quot;File&quot; fileName=&quot;log.txt&quot; keepFileOpen=&quot;true&quot;
		layout=&quot;[${date:format=yyyy/MM/dd hh\:mm\:ss}][${level}]${message}&quot; /&gt;
&lt;/targets&gt;
&lt;rules&gt;
    &lt;logger name=&quot;*&quot; minlevel=&quot;Debug&quot; writeTo=&quot;file&quot; /&gt;
&lt;/rules&gt;
</code></pre>
<p>になります。NLogの独自フォーマットルールに従って書く必要があるし、メッセージ書式も独自テンプレートになります。とはいえ、これはまだ単体なので遥かにマシで、色々複合的なことをやろうとするとすぐに膨れ上がって意味不明なことになるのは、みんな経験のあることなのではないでしょうか？</p>
<p>バイナリが<a href="https://github.com/neuecc/EtwStream/releases/tag/EtwStream.Service">EtwStream/releases/EtwStream.Service</a>に転がってるので、是非ちょっとだけ遊んでみてくださいな。</p>
<h2>仕組み</h2>
<p>csxをEvaluateしてるだけです。基本的にcsxの実行は即座に終わります、ObservableEventListenerをSubscribeしているだけですから。しかし、csxが終了してもSubscribeは生き続けています！（言われてみると当たり前のようで、最初はそうなの？と違和感はありました）。それにより、流れてくるログは（別スレッド上の)ObservableEventListenerを流れて、csx上のRxを通りcsx上でのSubscribeにより処理され続けます。というわけで、EtwStream.Serviceのcsxは、ただのXMLコンフィグがcsxに変わっただけ、ではなく、このcsxはコンフィグのようでコンフィグじゃなく、実行コードそのものなのです！</p>
<p>終了処理に関しては、ホスト側から渡しているTerminateTokenと、AddToを通してSubscriptionを登録していることにより制御されています。csxの評価としての実行が終わっていても、裏で生き続けている限り同じ参照を持っているので、ホスト側から干渉することが可能です。なので、ServiceのStopイベント時にはTerminateTokenにCancel命令をホストが出すことにより、Rxの残ってるBufferが送り出され、AddToで受け取っているSubscriptionを待つことにより、溜まったログの処理が完了するまで待機するといった、安全な終了処理を可能にしています。この辺はRxをフル活用してパイプライン組んだ成果ということで。</p>
<h2>再びエディタとしてのLINQPad</h2>
<p>さて、csxで書けるところのイイトコロはC#なのでコンパイルエラーも検出できるしシンタックスハイライトもあるし、などなど、なのですが、エディタサポートは……。Visual Studio 2015のUpdate 1によって確かにシンタックスハイライトはついた、が、それだけ……。IntelliSenseもDLL読み込ませたり色々しなければなので実質使えないみたいなもので厳しい……。</p>
<p>そこで出てくるのがLINQPad。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11766813/037c7376-a1db-11e5-9f74-8b4aeec20c5b.png" alt="image" /></p>
<p>EtwStream.LINQPadには、EtwStream.Serviceのcsxで渡されてくるEtwStreamServiceクラスのShim成分が入っているので、csxと互換性があって、LINQPadで実際にコンパイルできる/動かして確認した結果をcsxに持っていくことが可能です。（というようなことが出来るようにAPIを調整したんです……）。C# Interactiveが使い物にならならいなら使い物になるまで我慢する、のではなくて、一時凌ぎでもなんでも、他の現実的な解法を探すのが正すぃ。クソだクソだと文句だけ言ってても何も動きませんしね。必要なのは今この場でどうするか、それだけ。</p>
<h2>Topshelf</h2>
<p>Windowsサービスの実装には<a href="https://github.com/Topshelf/Topshelf">Topshelf</a>というライブラリを用いています。これは、最高に良いです。もはやこれなしでWindowsサービスを実装するのは考えられません！Visual Studioのテンプレートからふつーにサービスを作ると、なんかゴチャゴチャしたのが吐かれてよくわからない上に実行も面倒だし（いちいちinstallしたくないでしょ？）デバッグも困難だし、実にヤバい最低な開発環境。Topshelfで作るとコンソールアプリケーションと同じ感覚で作れます。また、成果物のexeは、そのまんまふつーにコンソールアプリケーションとしても動くので、EtwStream.Serviceの場合、ビューアーとしてLINQPadを要求していましたが、EtwStream.Service.exeを実行すれば普通にビューアーになります(csxで書き出し先をConsole(LogToConsole)にすれば色分けもしてくれる）。サービスとしてのインストールは「install」をつけて実行するだけ。素晴らしい。</p>
<p>日本語では<a href="https://84zume.wordpress.com/2014/03/23/topshelf/">Windowsサービスを楽に開発～TopShelf～</a>や<a href="http://tech.guitarrapc.com/entry/2015/05/13/015406">TopShelf によるWindowsサービスの配置をDSCで自動化してみよう</a>に説明ありますが、本当に簡単なので、サービスを作る機会がある人は是非使ってみてください。超お薦め。</p>
<h2>ファイル出力時のロガーのパフォーマンス</h2>
<p>今回ロガーを全部自作する都合上、さすがに単純なファイル書き出しと、ローテーションするファイル書き出しは用意しとかないとなぁ、ということで作ったんですが(FileSink, RollingFileSink)、作ってる上でなんとなく気づいたことなど。</p>
<p>そもそもファイルに吐くっていうこと自体がレガスィーで好きじゃないんですが、それはそれとしてもやはり重要なのは間違いありませんし、普通に使います。で、特にInProcessでのロギングの場合、これに気を配らないと普通にパフォーマンス上のボトルネックになってしまったりするわけですねー。さて、で、パフォーマンスは設定が全てです。とりあえず、バッファリングと非同期の二つのオプションを探しましょう。まず、ファイルに吐く場合のパフォーマンスはバッファするかしないかで全く変わるし、逆にバッファさえすればよほどタコな実装じゃない限りはそんな差はなくふつーに性能出ます（多分）。もう一点はasyncですね、これは別に大抵は非同期I/Oじゃなくて別スレッドで書くってだけのパターンなんですが、これが有効だとロガーの動作がアプリケーション自体に一切影響しなくなりますので。まぁバッファを有効にしてれば、例えば1000件に一回書く設定だったら1/1000回以外は書き込み処理に時間喰われることはなくなるので、ほぼ無視できてあってもなくても大差なくなるんですが、（起こるかもしれない）ちょっとしたスパイクは抑制できるかもしれません。また、あえてバッファはオフにしてasyncだけオン（+即時Flush)にすれば、ログが中々Flushされなくてリアルタイムで確認したいのにイライラ、というのがなくなって良いかもしれません。この辺は好みとか要件しだいで。</p>
<p>とりあえず言えるのはデフォの設定がどうなってるかはともかく、ノーバッファでノーエーシンクだと当然のように遅いです。更に設定によってはファイルストリームを都度閉じるか開きっぱがオプションになってるものもありますが、これは当然、開きっぱじゃないとゲロ遅いです。そういう項目がオプションにある場合は注意しましょう。デフォが都度閉じるだったりしてね……(NLogがそうです。NLogのデフォルトは安全寄りに倒し過ぎでパフォーマンスがヤヴァいことになってるので、NLog使う場合はそれなりに弄ったほうがいいでしょう。かといって他のロガーもそう変わりはなくて、大抵はそれなりに弄らないと遅いです）</p>
<p>かわりに、バッファや非同期ってのはログの消失の危険性があります。書いた瞬間には保存されてないってことですからね、アプリケーション終了への耐性が低くなります。気の利いたロガーは、可能な限り、終了を検知して(AppDomainが消える時のイベントとかをハンドリングして)、残ってるバッファを出力しに行ったり非同期の終了を待機しに行ってくれたりはしますが、パーフェクトではありません。例えば<a href="https://msdn.microsoft.com/en-us/library/system.appdomain.processexit.aspx">AppDomain.ProcessExit</a>のタイムアウトは既定で2秒です。2秒以内にフラッシュが完了する保証はないわけで、そこで完了できなければログロストです。</p>
<p>それを避けるには、「パフォーマンス低下を承知してバッファや非同期オプションを使わない」というのも手ですが、EtwStreamは更に2つの選択肢を提供してます。一つは「Out-Of-Process Serviceでのログ収集」。ETWへのログ出力はほぼノーコストで即時に吐けるのでアプリケーションへの影響は一切無い上に、それを外部サービスで取り出せば、出力側の終了の影響を全く受けません。ただし当然、受け取る側の外部サービスが死んだらロストするという危険性はありますがね！そこに関しては知らんがなというかshoganaiというか精一杯堅牢性を高めますとしか言い様がないですにぇ。</p>
<p>もう一つは、プログラム的に終了が完全に待機できるSubscriptionシステム。もともとEtwStreamは設定をC#で、Rxで書く必要があるので、購読状態に関して100%コントロールできます。というわけでその辺に仕掛けを入れといて</p>
<pre><code class="language-csharp">static void Main()
{
    // ApplicationStartの部分でこの2つを用意する
    var cts = new CancellationTokenSource();
    var container = new SubscriptionContainer();
    
    // でログの設定する
    ObservableEventListener.FromTraceEvent(&quot;SampleEventSource&quot;)
        .Buffer(TimeSpan.FromSeconds(5), 1000, cts.Token)
        .LogToFile(&quot;log.txt&quot;, x =&gt; $&quot;[{DateTime.Now.ToString(&quot;yyyy/MM/dd hh:mm:ss&quot;)}][{x.Level}]{x.DumpPayload()}&quot;, Encoding.UTF8, autoFlush: false)
        .AddTo(container);
        
    // --- 実際にアプリが動いてる部分 --- //
        
    // アプリが終了した時のイベントのところでハンドリングする(Form_ClosedでもApplication_Endでもなんでもいいですが)
    cts.Cancel(); // CancellationTokenのCancelによりBufferの残りが吐き出される
    container.Dispose(); // Subscriptionの完了を待機する
}
</code></pre>
<p>といった風にすれば、100%コントロールされて停止時のログ処理を完了させられます。csxでもEtwStreamService.TerminateTokenとか渡していたのと同じことをやればいいということで。</p>
<p>100%コントロールできる代わりに、逆にEtwStreamは自分でコントロールしないかぎりは、気の利いた終了の検知とか組み込んでないので、待たなければふつーにバッファは消えます。これに関しては、10年前はゴテゴテとブラックボックスの中で気の利いたことをしてくれるのが正義だったかもしれませんが、2015年の現代では仕組みはシンプルに、薄くしたうえで、自分でコントロールさせるのが正義だと思ってます。そういう流儀。どっちが正しいってこともないですが、まぁ、今風なんじゃないかな？</p>
<p>ついでに言えば、EtwStreamのFileSinkやRollingFileSinkのパフォーマンスはバッファしてる前提同士で比較しても、他のよりも高い性能を誇ります。理由は幾つかあって、そもそも性能を意識して書いてるから。というのと、.NET 4.6以外をサポートする気がないのでasync/awaitやTPL全開でコードを書いてるから。オプション自体も同期処理は一切なくて、書き出しは非同期I/Oのみに限定などの割り切り。そして、通常はログフォーマット整形などに独自テンプレート的なのを挟まなきゃいけないところを、csxのお陰でFuncで処理できるため、そもそもコードパスに一切のオーバーヘッドがない。C# Scriptingによるコンフィグはパフォーマンスにも寄与するわけです。</p>
<p>しかしまぁ、Javaでは<a href="https://github.com/Netflix/blitz4j/wiki/Blitz4j-at-a-glance">Blitz4j</a>や<a href="http://logging.apache.org/log4j/2.x/manual/async.html">log4j2のAsynchronous Logger</a>などのスピード競争があるのに、.NETの牧歌的なこと、といった感じは否めませんねぇ。そんなだから私のとりあえずの雑実装でもfastestになってしまうわけで……。</p>
<h2>出力先</h2>
<p>EtwStreamが提唱するのは構造化ログ(Structured/Semantic Log)ですし、テキストログが終着点ではありません！テキストログは無視して、構造化されたペイロードを、そのまま<a href="https://azure.microsoft.com/ja-jp/services/event-hubs/">Azure EventHubs</a>や<a href="https://aws.amazon.com/jp/kinesis/">Amazon Kinesis</a>、<a href="https://cloud.google.com/bigquery/">Google BigQueryのStreaming Insert</a>に流して、ただたんに溜めるのではなくて、即座に分析可能な状態にするのが理想形です。特にお薦めなのは、というか弊社で使ってるのはGoogle BigQueryです。事例として<a href="http://googlecloudplatform-japan.blogspot.jp/2015/12/google-cloud-platform-using-csharp.html">株式会社グラニの Google Cloud Platform 導入事例: 「using CSharp;」という軸と BigQuery の活用で、先進性を求め続ける。</a>を掲載してもらいました:)</p>
<p>今のとこEtwStream用のBigQuerySinkはないんですが（！）そのうち公開するかされるかするんじゃないでしょーか多分きっと。（本当はそれも作って持ってきたかったんですがもう完全に時間切れでして、すでに大遅刻だし……）。そういえばあとFromTraceEventでRegisteredTraceEventが取れるようになりました。これはつい数日前のTraceEventライブラリのアップデートでそうなったから、というだけなんですが、今まで取れてなかったんですよねー。これで大丈夫。というのと、SLABのOut-of-Process Serviceじゃダメな理由に.NET 4.6からEventSourceに追加されたself-describing events（超重要！）に対応してないとか色々あるんですが、そういった話はまたの機会にでも。</p>
<h2>まとめ</h2>
<p>ロガーの未来はこうあるべきだ、という構想自体は1年以上前からあったんですが、Roslyn C# Scripting APIが正式リリースされてやっと作れた！あと、基本的にはMicrosoft Patterns &amp; Practicesの<a href="https://github.com/mspnp/semantic-logging">Semantic Logging Application Block(SLAB)</a>の影響が濃くはあるんですが、更新されなすぎだし、v3はElastic Search + LogStash + Kibana on Azureとか言ってて、マジで終わってるなという感じでもはや見限るしかない……。P&amp;Pは相変わらず本当にやっぱダメですねーという残念さ加減。なにがPatterns &amp; Practicesだよっていう。</p>
<p>csxでコンフィグするライブラリとして<a href="https://github.com/config-r/config-r">ConfigR</a>というのがあるんですが、XMLをcsxで置き換えるだけじゃ、あんま意味がないかな。必要なのは、コンフィグができることじゃなくて、それそのものが実行されて自走することだというのに気づいたので、使うことはなかったし、多分他のアプリケーションでもConfigRを使うことはないと思います。XMLはいうて設定ファイルとしては悪くないんですよねー、XSLTなんかもやり過ぎなければ良い機構ですし。逆にJSONを設定ファイルとして使うのは最低最悪なチョイス(なのでDNXへのやる気が0.1ミリも起きない)</p>
<p>何れにせよ、徐々にではあるでしょうが、csxの面白い活用例というのはどんどん出てくるのではないかと思います、と言いたいんですがfsxが別に対して面白い活用はされてないことを考えるとそんなに出てこないかもしれませんね、とも思いますが、いえいや面白い活用例はやっぱ出てくるかもしれません。batをcsxにしましたとかってだけだと別に面白くもないし意味もそんなにないですからねー、まぁあってもいいけど。もっと本質的に変わるような事例が増えてくれれば何よりです。</p>
</div>
<h1><a href="https://neue.cc/2015/12/03_521.html">Unity 5.3のMulti Scene EditingをUniRxによるシーンナビゲーションで統合する</a></h1>
<ul class="date"><li>2015-12-03</li></ul>
<div class="entry_body"><p>今回は<a href="http://qiita.com/advent-calendar/2015/unity">Unity Advent Calendar 2015</a>のための記事になります。昨日はtsubaki_t1さんによる<a href="http://tsubakit1.hateblo.jp/entry/2015/12/02/212958">Unity初心者を脱するためのデバッグ入門…的なやつ</a>でした。私はとりあえずVisual Studioでアタッチしてステップ実行、でしょうか……。最近はiOSのIL2CPPのスタックトレースが行番号出してくれなくて禿げそうというのが<a href="http://grani.jp/">社内</a>のホットトピックスらすぃ。</p>
<p>去年もUnity Advent Calendarには参加していて、その時は<a href="http://neue.cc/2014/12/18_499.html">Unityのコルーチンの分解、或いはUniRxのMainThreadDispatcherについて</a>という内容でした。今回も引き続き、私の作成している<a href="https://github.com/neuecc/UniRx">UniRx - Reactive Extensions for Unity</a>のお話ということでお願いします。とはいえ、中身的にはMulti Scene Editingや、シーン間での引数渡しをやるのにどうすればいいのか、みたいなところなので、Rxのメソッドは特に説明なくバンバン出てきますが、Rxワカラナイ人はそのへんは雰囲気で流し読みしてもらって、シーン遷移についてのお話を読み取ってもらえれば嬉しいですねん。</p>
<h2>Multi Scene Editing</h2>
<p>Multi Scene Editingは初出が<a href="http://blogs.unity3d.com/jp/2014/08/04/multi-scene-editing/">2014/8/4のUnity Blogの記事</a>でしょうか、1年経ってやっと正式リリース、までまもなく！ですね、5.3から搭載されることになりました。実際どういうことになるかというと、ヒエラルキーウィンドウがこんな感じに。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11536347/744ba910-995b-11e5-8c55-fe18368d3c69.png" alt="image" /></p>
<p>シーン加算で読み込んだシーンがヒエラルキー上でもきっちり分けられます。DontDestroyOnLoadがついたものは専用のところに隔離される。シーンを削除する場合も、そのまま指定してサクッと消したり、マージできたりと、随分とシーン管理がやりやすくなりました。Unity 5.3からはいよいよシーン加算で管理する時代が到来する！</p>
<p>コード的にはUnityEngine.SceneManagement.SceneManagerに全部のAPIがつまってます。基本的にはLoadScene/Asyncか、UnloadSceneぐらいで事足りるのではないでせうか。</p>
<pre><code class="language-csharp">// SceneA -&gt; SceneBへボタン押したら加算
// 別にRx使う必要性はないけど無駄に使うエディション
button.OnClickAsObservable()
  .SelectMany(_ =&gt; SceneManager.LoadSceneAsync(&quot;SceneB&quot;, LoadSceneMode.Additive).AsObservable())
  .Subscribe(_ =&gt; { /* 完了時の処理何かあれば */ });
</code></pre>
<p>この程度だとRx使う必要性はゼロですが、一応、LoadSceneAsyncの戻り値であるAsyncOperationはAsObservableで直接サクッとRx的に変換可能です。</p>
<h2>シーン間に引数を渡す</h2>
<p>どういうこっちゃって話ですが、新しいシーンに遷移なり加算したいってことは、引数を渡したくて然りだと思うのです。そのシーンを表示する際の初期引数が。例えばアイテム一覧画面から、アイテムの詳細画面を出すなら、アイテムのIDを渡したいよね、とかね。別にAndroidやiOSアプリでも、ウェブのURLのクエリストリングなりなんなりでも、そんなのは普通によくある話です。さて、SceneManagerはその辺りのことは、別になにも面倒みてくれません。じゃあグローバル変数を経由してやりとりするのかというと果てしなくビミョウというかスパゲティ化まったなし。せっかく画面画面がシーンで独立しているなら、値の依存関係もシーン内に抑えてやりたい。</p>
<p>というわけで、遷移/加算時に引数を渡せるシーン遷移機構を作りましょう。</p>
<p>材料として使うのはUniRxの<a href="https://github.com/neuecc/UniRx#presenterbase">PresenterBase</a>です。これは何かというと、子要素の初期化の順序をコントロールするのと、値の受け渡しができる仕組みです。ご存知のとおりUnityのGameObjectの初期化順序は不定(Execution Orderでおおまかに指定できるけど、細かいコントロールのために使うものではない)ですが、PresenterBaseの管理下におくことで、Startフェーズにて決められた順序で起動するようにコード上で設定できます。</p>
<p>この性質は、シーンに引数が渡される、つまり全てのルートになるという条件にぴったりです！というわけで、引数を受け取るための基底クラス、SceneBaseをPresenterBaseを継承して作りましょう。</p>
<pre><code class="language-csharp">public abstract class SceneBase : PresenterBase
{
    // これがシーン遷移時にセットされる引数を表す
    public object Argument { get; set; }

    // 受け渡されたかどうかを管理するフラグ
    public bool IsLoaded { get; set; }

    protected override void OnAwake()
    {
        // 初期化が完了した際はロード済みと強制的にマークするおまじない
        this.InitializeAsObservable().Subscribe(_ =&gt; IsLoaded = true);
    }
}
</code></pre>
<p>こんなもので、割とあっさりめに。実際のシーンのクラスは</p>
<pre><code class="language-csharp">// このどうでもいいクラスを引数として渡していくということにする
public class Nanika
{
    public int HogeHoge { get; set; }
    public string Hugahuga { get; set; }
}

// 遷移元クラス、適当なボタン押したらSceneBに遷移する
public class SceneA : SceneBase
{
    public Button button;

    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize()
    {
    }

    protected override void Initialize()
    {
        button.OnClickAsObservable().Subscribe(_ =&gt;
        {
            // 直接SceneManager.LoadSceneAsyncを呼ぶのではなく、
            // 独自に作成したNavigationService.NavigateAsync経由で引数を渡して遷移/加算する
            var arg = new Nanika { HogeHoge = 100, Hugahuga = &quot;Tako&quot; };
            NavigationService.NavigateAsync(&quot;SceneB&quot;, arg, LoadSceneMode.Additive).Subscribe();
        });
    }
}

// 遷移先クラス、Argumentに引数が渡されてきてる
public class SceneB : SceneBase
{
    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize()
    {
    }

    protected override void Initialize()
    {
        // 前のシーンから渡された引数が取れる
        var arg = Argument as Nanika;
        Debug.Log(&quot;HogeHoge:&quot; + arg.HogeHoge + &quot; HugaHuga:&quot; + arg.Hugahuga);
    }
}
</code></pre>
<p>ちょっと長いですが、言いたいのは遷移元ではNavigationService.NavigateAsyncを使って引数を渡して遷移先を指定する。遷移先ではArgumentに渡されたものをキャストして取り出す。といった感じです。</p>
<p>作る上での制約としては、必ず各シーンに単一のSceneBaseがヒエラルキーの頂上にある必要があります。こんな感じに。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11538085/95c4fdfa-9963-11e5-95f4-9b4c1024bfc6.png" alt="image" /></p>
<p>うーん、随分と大きな制約であり不格好ですね……、この手の制約は実際のトコ、ないほうが望ましいです。別に、この手のヘンテコな制約をつけるのがアーキテクチャ、ではないです。自由なほうがよほど良いのです。とはいえしかし、どうにもならなかったので、そこは受け入れるしかなかったということで。この辺が今のところの手札でできる精一杯の形かなぁ。</p>
<h2>NavigationService</h2>
<p>では、肝心要のNavigationServiceの実装を見ましょう！</p>
<pre><code class="language-csharp">public static class NavigationService
{
    public static IObservable&lt;Unit&gt; NavigateAsync(string sceneName, object argument, LoadSceneMode mode = LoadSceneMode.Single)
    {        
        return Observable.FromCoroutine&lt;Unit&gt;(observer =&gt; HyperOptimizedFastAsyncOperationLoad(SceneManager.LoadSceneAsync(sceneName, mode), observer))
            .Do(_ =&gt;
            {
                // 型ベースでたぐり寄せる。Find系は避けたいとはいえ、シーン遷移時に一発だけなのでコスト的には許容できるでしょう。
                var scenes = GameObject.FindObjectsOfType&lt;SceneBase&gt;(); 
                var loadedScene = scenes.Single(x =&gt; !x.IsLoaded); // 一個だけになってるはず #雑
    
                loadedScene.IsLoaded = true;
                loadedScene.Argument = argument; // PresenterBase.BeforeInitializeが走る前にセットする
            });
    }
    
    static IEnumerator HyperOptimizedFastAsyncOperationLoad(AsyncOperation operation, IObserver&lt;Unit&gt; observer)
    {
        if (!operation.isDone) yield return operation;
    
        observer.OnNext(Unit.Default);
        observer.OnCompleted();
    }
}
</code></pre>
<p>なんてことはなく、LoadSceneAsyncが完了した時点でヒエラルキーに新しいシーンがぶちまけられているので、それのBeforeInitializeが走る前にArgumentにセットしておいてやる、というだけの割と単純なものです。ポイントは、BeforeInitializeの走るタイミングはStartということです。順序的に、LaodSceneAsyncが完了した時点で、新しいシーンのGameObjectのAwakeは走っています。なので、Awakeの前にArgumentを渡すのは何をどうやっても不可能です。しかし、Startの前に割り込むことは可能です。そこでルールとして遷移先のシーンでの初期化はStart以降に限定し(PresenterBaseがその辺を抽象化しているので実装者が意識する必要はない)、NavigateAsyncでは可能な限り最速のタイミングでArgumentをセットしにいきます。その秘訣がHyperOptimizedFastAsyncOperationLoadというフザケタ名前のコルーチンです。</p>
<h2>yield return null vs yield return AsyncOperation</h2>
<p>別にHyperOptimizedFastAsyncOperationLoadの中身は、見たまんまの超絶単純な yield return AsyncOperation です。そして、それこそが秘訣なのです。何を言ってるかというと……</p>
<pre><code class="language-csharp">IEnumerator WaitLoadAsyncA(AsyncOperation operation)
{
    while (!operation.isDone)
    {
        yield return null;
        Debug.Log(operation.progress); // 読み込み状態のプログレス通知
    }
}

IEnumerator WaitLoadAsyncB(AsyncOperation operation)
{
    yield return operation;
}
</code></pre>
<p>両者の違い、分かるでしょうか？ WaitLoadAsyncA のほうはプログレスを受け取るためにyield return nullでisDoneを監視するスタイル。WaitLoadAsyncBは直接待つスタイル。結果的に、どちらも待つことができます。プログレス通知は大事なので、WaitLoadAsyncAのようなスタイルを多用するほうが多いのではないかなー、と思います。WWWとか。が、しかし、両者には非常に大きな違いがあります。それは、完了時のタイミング。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11539070/9843e5a0-9968-11e5-82e7-58964692f6b2.png" alt="image" /></p>
<p>わざわざ無駄に画像を作ってまで声を大にして言いたいんですが、直接AsyncOperationをyieldすれば、AwakeとStartの間に割り込めます。yield return nullでは普通に1フレ後になるのでStartまで完了しちゃってます。これは超絶デカい違いです、この微妙なコントロールが死ぬほど大事です。きっと役に立ちます。どこかで。ちなみに一番最初に説明したAsyncOperation.AsObservableという神メソッドはyield return nullで待ってます。クソですね。カスですね。ゴミですね。すみません……（これは次のUniRxのリリースではプログレス通知を使わない場合は直接yieldするように変更します、それまでの間は手動コルーチン作成で対応してください）</p>
<p>もう一つ、コルーチンの駆動を各SceneのStartCoroutineで行うと、LoadSceneMode.Single（遷移）の場合、遷移元シーンが破壊された瞬間に紐付いてるコルーチンも強制的に止まる（そしてDestroyは遷移先シーンのAwakeの前）ため、Argumentを渡すという行為は不可能です。が、UniRxのFromCoroutineで駆動させると、中立であるMainThreadDispatcherによるコルーチン駆動となるため、元のシーンが壊れるとかそういうのとは無関係にコルーチンが動き続けるため、その手の制限と付き合わなくても済みます。この辺は実際UniRx強い。</p>
<h2>シーン表示を遅らせる</h2>
<p>実は、今のとこ別にRx使う必要性はあんまありません、なくても全然出来るレベルです（まぁコルーチンが破壊される件は回避しにくいですが）。それではあんまりなので、もう一歩次のレベルに行きましょう。例えばシーン遷移時に、引数を元にネットワークからデータを読み取って、その間はNow Loadingで待つ。ダウンロードが完了したら表示する。こうした、なんとなく良くありそうな気がする話を、NavigationServiceで対応させてみましょう。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11540034/cba474f0-996d-11e5-9089-1e1d63c1611d.gif" alt="animation" /></p>
<p>この、あんまり良くわからない例、SceneAボタンを押すとヒエラルキーにSceneBが表示されているけれど画面上には表示されていない、実際にはネットワークからデータをダウンロードしていて、それが完了したら、その結果と共にSceneBが表示される。というものです。なるほど……？</p>
<p>まず、SceneBaseにPrepareAsyncメソッドを追加します。</p>
<pre><code class="language-csharp">public abstract class SceneBase : PresenterBase
{
    public object Argument { get; set; }
    public bool IsLoaded { get; set; }

    // このPrepareAsyncメソッドを新設する
    public virtual IObservable&lt;Unit&gt; PrepareAsync()
    {
        return Observable.Return(Unit.Default);
    }

    protected override void OnAwake()
    {
        this.InitializeAsObservable().Subscribe(_ =&gt; IsLoaded = true);
    }
}
</code></pre>
<p>PrepareAsyncが完了するまで表示を待機する、といった感じで、それをIObservableによって表明しています。これで遷移先のSceneBクラスを書き換えると</p>
<pre><code class="language-csharp">public class SceneB : SceneBase
{
    public WwwStringPresenter display; // インスペクターから貼り付けてUnityEngineによるデシリアライズ時にセットされる(Awake前)

    string wwwString = null;

    protected override IPresenter[] Children
    {
        get { return new[] { display }; } // Sceneにぶら下がってる子をここで指定する（コードで！原始的！）
    }

    // 呼ばれる順番はPrepareAsync -&gt; BeforeInitialize -&gt; Initialize

    public override IObservable&lt;Unit&gt; PrepareAsync()
    {
        var url = Argument as string; // 前のシーンからURL、例えば http://unity3d.com/ が送られて来るとする

        // ネットワーク通信が完了するまでこのシーンの表示を待機できる
        // (もし自分で試して効果が分かりにくかったら Observable.Timer(TimeSpan.FromSeconds(5)) とかに差し替えてください、それで5秒後表示になります）
        return ObservableWWW.Get(url)
            .Select(x =&gt; // 本当はForEachAsyncを使いたいのですがまだ未リリース。
            {
                wwwString = x; // 副作用さいこー
                return Unit.Default;
            });
    }

    protected override void BeforeInitialize()
    {
        // この時点で通信が完了してるので、小階層に渡す。
        display.PropagateArgument(wwwString); // PresenterBase.PropagateArgumentで伝搬するルール
    }

    protected override void Initialize()
    {
    }
}
</code></pre>
<p>変えたところは、PrepareAsyncでWWW通信を挟んでいるところ。これが完了するまではシーン全体の表示が始まらない(BeforeInitializeが呼ばれない)です。表示に関しては、この程度の超絶単純な例では直接SceneBにTextをぶら下げたほうがいいんですが、無駄に複雑にするために、ではなくてPropagateArgumentの例として、もう一個、下にUI要素をぶら下げてます。それがWwwStringPresenterで、</p>
<pre><code class="language-csharp">public class WwwStringPresenter : PresenterBase&lt;string&gt;
{
    public Text displayView;

    protected override IPresenter[] Children
    {
        get { return EmptyChildren; }
    }

    protected override void BeforeInitialize(string argument)
    {
    }

    // 親からPropagteArugmentで渡されてくる
    protected override void Initialize(string argument)
    {
        displayView.text = argument;
    }
}
</code></pre>
<p>こんな感じに、親(この場合だとSceneB)から値が伝搬されます、適切な順序で（ふつーにやってるとGameObjectの生成順序は不定なので、値の伝搬というのは単純なようで深く、やりようが色々あるテーマだったり）。さて、一見複雑というか実際、色々ゴテゴテしてきてアレな気配を醸しだしてきましたが、実際どんな状態なのかというと、こんな感じ。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11540561/c1077148-9970-11e5-9d7b-dd94350d8979.png" alt="image" /></p>
<p>この分かったような分からないような図で言いたいことは、値の流れです。シーン間はNavigateAsyncによりArgumentが引き渡され、シーン内ではPresenterBaseによって構築されたチェーンがPropagateArgumentにより、ヒエラルキーの上流から下流へ流れていきます。これにより、グローバルでの変数保持が不要になり、値の影響範囲が局所化されます。スコープが狭いというのは基本的にいいことです、見通しの良さに繋がりますから。分かっちゃいても実現は中々むつかしい、に対する小道具を色々揃えておくと動きやすい。</p>
<h2>NavigateAsync最終形</h2>
<p>おお、そうだ、PrepareAsyncに対応したNavigateAsyncのコードを出し忘れている！こんな形になりました。</p>
<pre><code class="language-csharp">public static class NavigationService
{
    public static IObservable&lt;Unit&gt; NavigateAsync(string sceneName, object argument, LoadSceneMode mode = LoadSceneMode.Single)
    {
        return Observable.FromCoroutine&lt;Unit&gt;(observer =&gt; HyperOptimizedFastAsyncOperationLoad(SceneManager.LoadSceneAsync(sceneName, mode), observer))
            .SelectMany(_ =&gt;
            {
                var scenes = GameObject.FindObjectsOfType&lt;SceneBase&gt;();
                var loadedScene = scenes.Single(x =&gt; !x.IsLoaded);

                loadedScene.IsLoaded = true;
                loadedScene.Argument = argument;

                loadedScene.gameObject.SetActive(false); // 一旦非Activeにして止める

                return loadedScene.PrepareAsync() // PrepareAsyncが完了するまで待つ
                    .Do(__ =&gt;
                    {
                        loadedScene.gameObject.SetActive(true); // Activeにして動かしはぢめる
                    });
            });
    }

    static IEnumerator HyperOptimizedFastAsyncOperationLoad(AsyncOperation operation, IObserver&lt;Unit&gt; observer)
    {
        if (!operation.isDone) yield return operation;

        observer.OnNext(Unit.Default);
        observer.OnCompleted();
    }
}
</code></pre>
<p>足したコードは、Argumentをセットしたら即座にSetActive(false)ですね。これで画面に非表示になるのは勿論、Startも抑制されます。そうしてStartが止まっている間にPrepareAsyncを呼んでやって、終わったら再度 SetActive(true) にする、ことによりStartが発生しだして、PresenterBaseの初期化機構が自動で上流→下流への起動を開始します。</p>
<h2>まとめ</h2>
<p>実際にはPrepareAsyncだけでは足りなくて、シーンから出る時、シーンから戻ってきた時、機能としてシーンをキャッシュしてやろうとか、遷移でパラメータ渡ってくる前提だと開発時にパラメータが足りなくてダルいので任意で差し込めるようにする/開発用デフォルト用意するとか、色々やれることはあります、し、やったほうがいいでしょふ。それらも全てUniRx上で、IObservableになっていることにより、表現がある程度は容易になるのではないかと思います。非同期を表現する入れ物、が必要だというのは至極当然の答えになるのですけれど、そこにUniRxが一定の答え、定番を提供できているんじゃないかなー、と思いますね！些か長い記事となってしまいましたが、これに限らず応用例の発想に繋がってくれれば何よりです。</p>
<p>Advent Calendarの次は、<a href="http://qiita.com/Miyatin">@Miyatin</a>さんです！</p>
<h2>UniRx vNext</h2>
<p>ところで実はいまものすごい勢いで作り変えています！性能もかなり上が（って）るんですが、割と分かりやすく大きいのは、スタックトレースが物凄く見やすくなります。意味不明度が極まった複雑なスタックトレースはRx名物でデバッガビリティが最低最悪だったのですが、相当まともになってます。例えば、以下の様なふつーのチェーンのDebug.Logで表示されるスタックトレースは</p>
<pre><code class="language-csharp">var rxProp = new ReactiveProperty&lt;int&gt;();
rxProp
    .Where(x =&gt; x % 2 == 0)
    .Select(x =&gt; x)
    .Take(50)
    .Subscribe(x =&gt; Debug.Log(x));

rxProp.Value = 100;
</code></pre>
<p>Before</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11541721/187fc69a-9977-11e5-86f3-b0c2f1938a4a.png" alt="image" /></p>
<p>After</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/11541619/7d07daea-9976-11e5-8c5b-9e0a7414b57c.png" alt="image" /></p>
<p>劇的！Unityのスタックトレースの表示形式に100%フォーカスして、読みやすさ第一にハックしたので、圧倒的な読みやすさだと思います。スタックトレース芸極めた。普通にWhere.Select.Take.Subscribeがそのまま表示されてますからね。勿論、メソッドコール数が減っているのは単純に性能にも寄与しています。ここまでやれば文句もないでせう。</p>
<p>そんなvNextの完成時期ですが、今までやるやる詐欺すぎたのですが、そろそろ実際本当に出します。来週ぐらいには本当に出します。これは意地でも仕上げます（想像通りだけれど作業量は多いわコーナーケースの想定が複雑すぎて頭が爆発しそうになるしで辛い……）。というわけでもうちょっとだけ待っててください。</p>
</div>
<h1><a href="https://neue.cc/2015/11/03_520.html">EtwStream - ETW/EventSourceのRx化 + ビューアーとしてのLINQPad統合</a></h1>
<ul class="date"><li>2015-11-03</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/EtwStream">EtwStream</a>というのをリリースしました。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb968803.aspx">ETW(Event Tracing for Windows)</a> + <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.tracing.eventsource.aspx">EventSource</a>が.NETで構造化ログをやる際の決定版というか、ETWの最強度が高すぎてそれ以外考えられないレベルなんですが、しかし、がETWは最強な反面ビューアーがありませんでした。ETWというブラックホールにログを投げ込むのはいいんですが、それが自分自身ですら容易に見れないのは不便すぎる！PerfViewとか骨董品みたいなゴミUIを操ってなんとかして見るのは、無理ゲーなわけで、カジュアルにDumpしたいだけなんだよ！テキストのようなログビューアーが欲しいだけなんだよ！に対する答えです。いや、ほんと自分自身が死ぬほど欲しかったのが、これ。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10905625/cae5a122-825e-11e5-8def-d53feedb879d.gif" alt="etwstreamgif" /></p>
<p>インストールはLINQPadのNuGetで「EtwStream.LinqPad」。だけ。デフォルトにでも登録しとけばLINQPadを立ち上げるだけですぐにビューアーに！</p>
<p>EtwStreamが提供するのは、ETWをIObsevable[TraceEvent]に変換することです。Logs are streamsですから、そしてストリームといったらRxですから。あとは、LINQPadのDumpをそのまま流用して、色付けとか加えてあげただけです。フィルタリングしたい？グルーピングしたい？色々混ぜたい？そんなの全部Rxなんだから、ちょっとクエリ書けばいいだけなのです。最強の柔軟性がある。</p>
<pre><code class="language-csharp">Observable.Merge(
    ObservableEventListener.FromTraceEvent(&quot;LoggerEventSource&quot;),
    ObservableEventListener.FromTraceEvent(&quot;MyCompanyEvent&quot;),
    ObservableEventListener.FromTraceEvent(&quot;PhotonWire&quot;)
)
.DumpWithColor(withProviderName: true);
</code></pre>
<p>EventSourceの提供する構造化ログ(Structured Logging)に関しては<a href="http://www.buildinsider.net/column/kawai-yoshifumi/003">C#における構造化ログの手法、そしてデータ可視化のためのDomoの薦め</a>で書いたのでそっちを見てくださいな。そうしてEventSourceに移行した場合の最大の懸念であるビューアーがなさすぎ問題を、このEtwStreamが解決します。た。</p>
<p>ちなみについでにTailっぽくファイルもIObservable[string]に変換するObservableEventListener.FromFileTailもオマケとして入れといたので、そっちもそっちでログビューアー的に使うならきっとベンリ。</p>
<p>もしEventSourceを使ったロギングをやっていなくても、.NET標準組み込みの、例えばTplEventSourceあたりを眺めてみると、色々な挙動が見えて面白かったりします。あとFromClrTraceEventではGCやThraedPoolの挙動が見れたり、FromKernelTraceEventで普段絶対気にしないカーネルイベントが凄まじい勢いで流れて行ったりが簡単に観測できて、普通に勉強になります。オモチャとしてかなり良いと思いますねー。</p>
<h2>最初のEventSource</h2>
<p>EventSourceって何のことだかさっぱりわからん！という人におすすめなのが<a href="https://msdn.microsoft.com/en-us/library/dn440729.aspx">Logging What You Mean: Using the Semantic Logging Application Block</a>というMSDNに転がってるSLABのドキュメントです。これはさすがにひじょーによく書けてるしいいですね。あと、EtwStreamが提供してるのはObservableEventListenerだけで、ロガー的なファイル書き出しとかは一切ないので、そういうのやりたい人は普通にSLAB「も」使いましょう。という感じです。</p>
<p>さて、EventSourceですが、いきなり構造化ログってのもかなりダルいので、まずは非構造化ログをEventSourceで実現するところから初めてみましょう。いや実際それに、こういういのがちょっとあるとそれはそれでベンリでもありますし。</p>
<pre><code class="language-csharp">[EventSource(Name = &quot;LoggerEventSource&quot;)]
public class LoggerEventSource : EventSource
{
    public static readonly LoggerEventSource Log = new LoggerEventSource();

    public class Keywords
    {
        public const EventKeywords Logging = (EventKeywords)1;
    }

    string FormatPath(string filePath)
    {
        if (filePath == null) return &quot;&quot;;

        var xs = filePath.Split('\\');
        var len = xs.Length;
        if (len &gt;= 3)
        {
            return xs[len - 3] + &quot;/&quot; + xs[len - 2] + &quot;/&quot; + xs[len - 1];
        }
        else if (len == 2)
        {
            return xs[len - 2] + &quot;/&quot; + xs[len - 1];
        }
        else if (len == 1)
        {
            return xs[len - 1];
        }
        else
        {
            return &quot;&quot;;
        }
    }

    [Event(1, Level = EventLevel.LogAlways, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void LogAlways(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(1, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(2, Level = EventLevel.Critical, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Critical(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(2, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(3, Level = EventLevel.Error, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Error(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(3, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(4, Level = EventLevel.Warning, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Warning(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(4, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(5, Level = EventLevel.Informational, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Informational(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(5, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(6, Level = EventLevel.Verbose, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Verbose(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(6, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(7, Level = EventLevel.Error, Keywords = Keywords.Logging, Version = 1)]
    public void Exception(string type, string stackTrace, string message)
    {
        WriteEvent(7, type ?? &quot;&quot;, stackTrace ?? &quot;&quot;, message ?? &quot;&quot;);
    }

    [Conditional(&quot;DEBUG&quot;)]
    [Event(8, Level = EventLevel.Verbose, Keywords = Keywords.Logging, Message = &quot;[{2}:{3}][{1}]{0}&quot;)]
    public void Debug(string message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        WriteEvent(8, message ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [NonEvent]
    public IDisposable MeasureExecution(string label, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string filePath = &quot;&quot;, [CallerLineNumber] int line = 0)
    {
        return new StopwatchMonitor(this, label ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line);
    }

    [Event(9, Level = EventLevel.Informational, Keywords = Keywords.Logging, Message = &quot;[{0}][{2}:{3}][{1}]{4}ms&quot;)]
    void MeasureExecution(string label, string memberName, string filePath, int line, double duration)
    {
        WriteEvent(9, label ?? &quot;&quot;, memberName ?? &quot;&quot;, FormatPath(filePath) ?? &quot;&quot;, line, duration);
    }

    class StopwatchMonitor : IDisposable
    {
        readonly LoggerEventSource logger;
        readonly string label;
        readonly string memberName;
        readonly string filePath;
        readonly int line;
        Stopwatch stopwatch;

        public StopwatchMonitor(LoggerEventSource logger, string label, string memberName, string filePath, int line)
        {
            this.logger = logger;
            this.label = label;
            this.memberName = memberName;
            this.filePath = filePath;
            this.line = line;
            stopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            if (stopwatch != null)
            {
                stopwatch.Stop();
                logger.MeasureExecution(label, memberName, filePath, line, stopwatch.Elapsed.TotalMilliseconds);
                stopwatch = null;
            }
        }
    }
}
</code></pre>
<p>ちょっと長いですが、これで</p>
<pre><code class="language-csharp">LoggerEventSource.Log.Debug(&quot;ほげほげ!&quot;);
</code></pre>
<p>とか書いていくだけです。それを書いたアプリを、LINQPadでは</p>
<pre><code class="language-csharp">ObservableEventListener.FromTraceEvent(&quot;LoggerEventSource&quot;).DumpWithColor();
</code></pre>
<p>で、ファイルとかを通さずそのままストリームで外から観測できます。</p>
<h2>Logs are event streams</h2>
<p>脱ファイル。ちなみにETWで流したのは最終的にBigQueryに流すのが超おすすめですね！そして<a href="http://neue.cc/2015/10/25_519.html">LINQ to BigQuery + LINQPad</a>で解析する。完璧！これがC#の次世代ログのあるべき姿だ！と、オモイマス。というか逆にもう以前には戻れないかなあ、やっぱり世代が一つ変わった感あります、便利度が全然違うので。</p>
</div>
<h1><a href="https://neue.cc/2015/10/25_519.html">LINQPad Driver + LINQ to BigQueryによるBigQueryデスクトップGUIクライアント</a></h1>
<ul class="date"><li>2015-10-25</li></ul>
<div class="entry_body"><p>Happy signed！何かというと、長らく署名の付いていなかった<a href="http://google-api-dotnet-client.blogspot.jp/2015/07/announcing-release-of-192.html">Google APIの.NET SDKに署名が付いた</a>のです！署名が付くと何ができるかというと、<a href="http://www.linqpad.net/">LINQPad</a>のDriver(プラグイン)が作れます。LINQPadのDriverは署名なしだと起動できないので……。正直、私ももはや署名とか全然重視してないし100億年前の化石概念の負の異物だろ、ぐらいに思ってなくもないのですが、さすがに、LINQPad Driverを作れない、という事態には随分と嘆いたものでした。が、やっと作ることが出来て感無量。そして、実際動かしてみると相当便利ですね。これがやりたかったんですよ、これがー。</p>
<img src="https://cloud.githubusercontent.com/assets/46207/10714939/78e5bcb8-7b47-11e5-9262-c802040011f8.png" width=640 />
<p><a href="https://github.com/neuecc/LINQ-to-BigQuery">LINQ to BigQuery</a>のLINQPad Driverが可能にする範囲は、</p>
<ul>
<li>サイドバーでのスキーマのツリー表示</li>
<li>thisを読み込んでいるConnectionで認証済みのBigQueryContextに変更</li>
<li>関連するアセンブリと名前空間を自動で読み込み</li>
<li>スキーマに対応するクラスを動的に生成/読み込み</li>
<li>ちょっとしたユーティリティDumpの追加(DumpRun/DumpRunToArray/DumpChart/DumpGroupChart)</li>
<li>もちろんクエリのローカルでの保存/読み込みが可能</li>
</ul>
<p>です。元々のLINQ to BigQueryが提供している機能としては</p>
<ul>
<li>TableDateRangeに対するサポート</li>
<li>DateTimeの自動変換(一部のBigQueryの機能はUnix Timestampで書く必要があり、実質手で書くのは不可能なものもありましたが、自動変換により救われる）</li>
<li>結果セットをローカル時間に自動変換（基本的にUTCで帰ってくるので、ローカル時間で考える際に+9時間しなきゃいけなかったりしますが、C#側でデシリアライズする際にローカルタイムに自動変換する）</li>
<li>全てが型付きで入力補完が全面的に効く</li>
<li>全てのBigQuery関数の入力補完にドキュメント付き</li>
</ul>
<p>があって（この辺の詳しい話は以前に書いた<a href="http://neue.cc/2014/09/24_479.html">LINQ to BigQuery - C#による型付きDSLとLINQPadによるDumpと可視化</a>を見てください）、相乗効果でかなり強まったのではないでしょうか。</p>
<p>公式ウェブコンソールで叩くのとどっちがいいかといったら、まぁ私自身も結構、ウェブから叩くのは多かったりしますので、どっちでもいいといえばいいんですが、それもプラグインを作る前は……かしら。今後は私自身もLINQPad利用が増えるかなー。明らかにウェブから叩くのじゃ提供できない機能というか、素のBigQuery SQLじゃ中々できない機能を多く提供しているわけで、LINQPad + LINQ to BigQUeryにはかなりのアドバンテージがあります。</p>
<h2>Excel統合</h2>
<p>問答無用に愚直なExcel統合があります。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10721962/968632b4-7bee-11e5-9b48-904fcb48e75f.gif" alt="legendary_dump_to_excel" /></p>
<p>そう、DumpToExcel()で実行すると結果セットがダイレクトにExcelで開く……。しかし実際こういうのでいいんだよこういうので感あります。Excelでクエリ書く系の統合は面倒くさい（実際アレはダルいのでない）。いちいちCSVに落として開くのは面倒くさすぎる。LINQPadでクエリ書く、結果がExcelで見れる。あとはピボットテーブルなりで好きに分析できる。そう、そういうことなんですよ、これなんですよ #とは</p>
<h2>入れ方</h2>
<p>ExplorerのAdd Connection→View More Drivers からLINQ to BigQueryを探して、clickでインストールできます。簡単。</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10785534/2fcc7f7c-7da8-11e5-9c29-4dc2486aeffe.png" alt="image" /></p>
<p>かなり上の方のいい位置に入れてもらいました！</p>
<h2>using static</h2>
<p>BigQueryの関数はLINQ to BigQueryではBqFunc以下に押し込める形をとっていますが、C# 6.0から(Javaのように)静的メソッドのインポートが可能になりました。また、LINQPad 5でもスクリプトのバックエンドがRoslynになり、C# 6.0にフル対応しています。LINQ to BigQueryのDriverでは、LINQPad 5以上に読み込ませた場合のみ、using static BigQuery.Linq.BqFunc が自動インポートされます。</p>
<p>これにより、クエリを書いた際の見た目がより自然に、というかウザったいBqFuncが完全に消え去りました！関数名を覚えていない、ウロ覚えの時はBqFunc.を押して探せるし</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10714748/f252b694-7b3f-11e5-9658-3bb81032e257.png" alt="image" /></p>
<p>慣れきった関数なら、直接書くことができる。完璧。</p>
<h2>How to make LINQPad Driver</h2>
<p>難しいようで難しくないようで難しいです。<a href="https://www.linqpad.net/extensibility.aspx">しっかりしたドキュメントとサンプル</a>が付属しているので、スタートはそれなりにスムーズに行けるかと思います。一つ、大事なのはプラグイン開発だからってデバッグ環境に妥協しないでください。ふつーの開発と同じように、F5でVisual Studioが立ち上がってすぐにブレークポイント貼ってステップ実行できる環境を築きましょう。細かいハマりどころが多いので、それ出来ないと挫けます。逆に出来てれば、あとは気合、かな……？細かいやり方はここに書くには余白が（以下略</p>
<p>変わったハマりどころとしては、例えば別々に呼ばれるメソッド間で変数渡したいなー、と思ってprivate fieldに置くと、そもそも都度頻繁にコンストラクタが呼ばれて生成されなおすので、共有できない。なるほど、じゃあせめてstatic変数だったらどうだろうか？というと、LINQPadの内部の実行環境の都合上、AppDomainがガンガン切られて飛んで来るので、static fieldすら消える！マジか！なるほどねー厳しいねー、などなど。</p>
<p>ちなみに動的なアセンブリ生成ではCodeDomのCSharpCodeProviderを利用しています。つい先月、<a href="http://neue.cc/2015/09/29_517.html">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a>でCodeDomはオワコン、使わないとか言ってたくせに！舌の根も乾かぬうちに自分で使うことになるとは思わなかった！</p>
<h2>まとめ</h2>
<p>社内でのBigQuery活用法として、定形クエリのダッシュボードは<a href="http://www.buildinsider.net/column/kawai-yoshifumi/003">Domoにより可視化</a>、アドホックなクエリはLINQPad + LINQ to BigQueryによりクエリを色々書いたり、そのままExcelに送り込んで(LINQPadはデスクトップアプリなので、DumpToExcel()メソッドとかを作ることによりシームレスに結果セットをExcelに投げ込んだりできるのも強い)PowerPivotでこねくり回したり、などをしてます。とはいえ、今までは事前にスキーマに対応するクラスを生成して保存しておかなければならないという面倒くささがあったので、イマイチ活用しきれてなかったのも事実。実際、私自身ですらBigQueryの公式ウェブコンソールでクエリ叩いたりが多かったですし。それが、今回のLINQPad Driverにより圧倒的に利便性が上がった（というか前のがもはや原始時代に見える）ので、使える度合いが桁違いに上がったんじゃないかなー、と思います。</p>
<p>デスクトップGUIクライアントの便利さは、例えばMySQLだったらウェブでphpMyAdminよりもHeidiSQLやMySQL Workbenchのほうが100億倍便利なわけでして、良いところ沢山あるんですよね。BigQuery関連だと<a href="https://cloud.google.com/datalab/">Cloud DataLab</a>なんかもちょうど出ましたが、ウェブとデスクトップ、それぞれ良さがあるので、ここはうまく使い分けていきたいところです。</p>
<p>最近のBigQueryのアップデートへの追随だと、新メソッドは全部実装が完了してます。また、GroupByへのRollupなど文法の追加もOK。ただ、大きな目玉であるUDF(User Defined Function)への対応がまだです。別にそんな難しくもないんですが、APIの馴染ませ方どうしようかな、とか思ってる間にLINQPad Driverの作成に時間喰われたので、対応入れるのは近いうちの次回ということで。</p>
</div>
<h1><a href="https://neue.cc/2015/10/23_518.html">同期（風）コードと対比させたUnity+UniRxで非同期を扱う場合のパターン集</a></h1>
<ul class="date"><li>2015-10-23</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx/">UniRx</a>のGitHubのStar数が500行きました！</p>
<p><img src="https://cloud.githubusercontent.com/assets/46207/10682950/165b9eea-7977-11e5-87ec-9b98269e912a.png" alt="image" /></p>
<p>今のところGitHub上での<a href="https://github.com/search?l=C%23&amp;o=desc&amp;q=Unity&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93">Unity + C#</a>でスター順の検索だと、世界5位です。おおー。更に上を狙いたいところですね。最近はちょっと更新が滞っていますが、ネタはあるのでより完成度を高めたい。(滞った理由は、<a href="http://neue.cc/2015/09/29_517.html">PhotonWire</a>とか色々他のところに手を出していたため……)</p>
<p>さて、本題。イベント結合に使う際はあてはまりませんが、Rx(<a href="https://github.com/neuecc/UniRx/">UniRx</a>)を非同期（長さ1のIOservableシーケンス)として扱う場合、それなりに癖があります。とはいえ、基本的には同期（或いはyield return)で書いていた際と、1:1で対比できるパターン化した形で概ね対応できるので、そのためのチートシートを考えてみました。コード例はC# 5.0のasync/awaitで出しますが、同期コード or IEnumeratorと同じように思ってもらえればいいです。例えば</p>
<pre><code class="language-csharp">public void Sync()
{
    /* before action */
    Method();
    /* after action */
}

public IEnumerator IEnumerator()
{
    /* before action */
    yield return StartCoroutine(Method());
    /* after action */
}

public async Task Task()
{
    /* before action */
    await MethodAsync();
    /* after action */
}
</code></pre>
<p>みたいな感じです、awaitに馴染みのない人も、なんとなくイメージしながら眺めてみてもらえると嬉しいです。</p>
<h2>非同期汚染</h2>
<p>コード例の前に非同期汚染、或いは非同期の伝搬について。まぁ、あんまし汚染という言い方は好きじゃないのですが、基本的に非同期、つまりTaskでもFutureでもPromiseでもIObservableでも、は、下層から上層まで伝搬していきます。メソッドが非同期であるなら戻り値はIObservableであり、そのIObservableを呼ぶメソッドもまた自然と非同期でなければならないので、IObservableになる、と。何故非同期の連鎖でなければならないのか。消費(Subscribe)してしまうと、その瞬間Fire and Forgetになってしまい、戻りを待ったりキャンセルしたりなどの別の操作が行えなくなってしまうからです。別にFire and Forgetしたければ、呼び元がそれを選択(Subscribeして放置)すればいいわけで、呼ばれる側が決定することではない。</p>
<p>もちろん、最終的にはどこかの層で消費(Subscribe)しなければならないので、そこで伝搬は止まるのですけれど、それは、基本的には上層であればあるほどよいということですね。どこが上層やねんって話はあるかもしれませんが、ユーザーインタラクションに近かったり、MonoBehaviourのイベント層に近かったり、あたりがそうですかねー。あとは、ごく一部でしか使わないんだ！という確固たる思いがあれば、早い段階でSubscribeして伝搬を止めるのも策ではあります、その辺はケースバイケースで。</p>
<p>非同期の伝搬に都合の良いメソッドが現状のUniRxには足りてません。実は！というわけで、次期バージョンではForEachAsyncというものを足したいのですが、それまでは以下のものをコピペって代用してください。挙動的にはシーケンスを消費して長さ1のIObservable[Unit]を返すもので、元シーケンスが非同期(長さ1)ならDoやSelectと、概ね一緒です。</p>
<pre><code class="language-csharp">// 次期バージョンに入るので、それまでの代用ということで。
// 元シーケンスが非同期なら .Select(x =&gt; { /* action(); */ return Unit.Default; }) とほぼ同様
namespace UniRx
{
    public static class UniRxExtensions
    {
        public static IObservable&lt;Unit&gt; ForEachAsync&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext)
        {
            return Observable.Create&lt;Unit&gt;(observer =&gt;
            {
                return source.Subscribe(x =&gt;
                {
                    try
                    {
                        onNext(x);
                    }
                    catch (Exception ex)
                    {
                        observer.OnError(ex);
                        return;
                    }
                }, observer.OnError, () =&gt;
                {
                    observer.OnNext(Unit.Default);
                    observer.OnCompleted();
                });
            });
        }
    }
}
</code></pre>
<p>また、副作用（外の変数への代入など）に関しては、あまり気にしないほうが吉です。いや、Rxのパイプラインに押し込めたほうが美しくはあるんですが、それがオブジェクトであるなら、副作用かけてフィールド変数を変えたり、ReactivePropertyに結果を伝えたりとかは、あって然りかな、と。考える際には「もしこれが同期コードだったらどうなのか」を意識したほうがいいかもしれません、同期コードで自然なら、別にRxでそれを行っても、構わないのです。とはいえ、以下に紹介するコードは全部、副作用大前提みたいな説明なので、それはそれで若干の狂気でもありますが、その辺は慣れてきてからでよいかと。</p>
<h2>戻り値のない場合</h2>
<pre><code class="language-csharp">public async Task Demo1_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
}

public IObservable&lt;Unit&gt; Demo1_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .ForEachAsync(_ =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>メソッドに戻り値がない場合は、awaitの位置にForEachAsyncで、その中にactionを書く形になります。RxにおいてはIObservable[Unit]を戻り値のないことの表明として使います。</p>
<h2>内部に複数の非同期がある場合</h2>
<pre><code class="language-csharp">public async Task Demo2_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action 1 */
    var y = await Task.Factory.StartNew(() =&gt; 200);
    /* after action 2 */
}

public IObservable&lt;Unit&gt; Demo2_IO_1Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */

            return Observable.Start(() =&gt; 200);
        })
        .ForEachAsync(y =&gt;
        {
            /* after action 2 */
        });
}
</code></pre>
<p>awaitの位置にSelectManyを置くことで繋げることができます。最後の消費だけForEachAsyncで。</p>
<h2>パイプライン中に複数の値を伝搬したい場合</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y }) // transport argument to next chain
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y } 
        });
}

public IObservable&lt;Unit&gt; Demo2_IO_2_2Async()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            var z = SyncMethod();
            return Observable.Start(() =&gt; 200).Select(y =&gt; new { x, y, z });
        })
        .ForEachAsync(o =&gt;
        {
            /* after action 2 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>同期コードでは、そのスコープ中の全ての値が使えるわけですが、Rxのメソッドチェーンでは次のパイプラインに送り込める値は一つしかありません。というわけで、匿名型（もしくはUniRx.Tuple）を使って、次のパイプラインへは値をまとめて上げる必要があります。SelectManyには第二引数があり、それにより前の値と次の値をまとめることができます。また、SelectMany内部で作った値を送り込みたい場合は、戻り値のところでSelectを使ってスコープ内でキャプチャして返してあげればいいでしょう。(匿名型、Tupleともにclassなので、気になる場合はstructの入れ物を用意してもいいかもしれない、何か箱を作って運搬しなきゃいけないのは残念ながら仕様です)</p>
<h2>非同期が連鎖する場合</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo2_IO_2_MoreChainAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .SelectMany(x =&gt;
        {
            /* after action 1 */
            return Observable.Start(() =&gt; 200);
        }, (x, y) =&gt; new { x, y })
        .SelectMany(o =&gt;
        {
            /* after action 2 */
            return Observable.Start(() =&gt; 300);
        }, (o, z) =&gt; new { o.x, o.y, z }) // re-construct self
        .ForEachAsync(o =&gt;
        {
            /* after action 3 */
            // { o.x, o,y, o.z } 
        });
}
</code></pre>
<p>SelectManyの連打になります。また、伝搬する値は自分で分解して付け直してあげる必要があります、これは面倒くさいですね！この辺はクエリ構文を使った場合、Transparent Identifierという仕組みで自動的にコンパイラが行うのですが(<a href="http://www.slideshare.net/neuecc/an-internal-of-linq-to-objects-29200657">An Internal of LINQ to Objects</a>の35P、Rxでクエリ構文は結構頻繁にクエリ構文の範疇を逸脱するのと、副作用をパイプライン途中に書けないためあまり使い勝手は良くないので、面倒くさいながら手作業再構築を薦めます。</p>
<h2>戻り値を返す場合</h2>
<pre><code class="language-csharp">public async Task&lt;int&gt; Demo3_TaskAsync()
{
    /* before action */
    var x = await Task.Factory.StartNew(() =&gt; 100);
    /* after action */
    return x; // return value
}

public IObservable&lt;int&gt; Demo3_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Select(x =&gt;
        {
            /* after action */
            return x; // return value
        });
}
</code></pre>
<p>ForEachAsyncではなく、Selectを使っていきましょう。戻り値の型が同一で副作用だけ起こしたいならDoでも構わないのですが、まぁどっちでもいいです。また、awaitが複数になる場合は、SelectManyになります。そのうえでSelectManyのままreturnするか、最後に再びSelect(もしくはDo)を使うかどうかは、状況次第、かな。</p>
<h2>例外をキャッチ</h2>
<pre><code class="language-csharp">public async Task Demo4_TaskAsync()
{
    /* before action */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    catch (Exception ex)
    {
        /* onerror action */
        throw;
    }

    /* after action */
}

public IObservable&lt;Unit&gt; Demo4_IOAsync()
{
    /* before action */
    return Observable.Start(() =&gt; 100)
        .Catch((Exception ex) =&gt;
        {
            /* onerror action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>これはCatchで賄えます。なお、Catchメソッドを使う際は、Catch&lt;T&gt;で例外の型を指定するよりも、ラムダ式の引数側で例外の型を書いたほうが書きやすいです（そうしたほうが型推論の関係上、ソースシーケンスの型を書かなくて済むため）。Catchの戻り値では再スローをObservable.Throw、握りつぶしをObservable.Return/Emptyで表現可能です。</p>
<h2>Finally</h2>
<pre><code class="language-csharp">public async Task Demo5_TaskAsync()
{
    /* before action(1) */
    try
    {
        var x = await Task.Factory.StartNew(() =&gt; 100);
    }
    finally
    {
        /* finally action(2) */
    }

    /* after action(3) */
}

// not equivant try-finally
public IObservable&lt;Unit&gt; Demo5_IO_PseudoAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Finally(() =&gt;
        {
            /* finally action(3) */
        })
        .ForEachAsync(x =&gt;
        {
            /* after action(2) */
        });
}

public IObservable&lt;Unit&gt; Demo5_IO_CorrectLightweightButIsNotDryAsync()
{
    /* before action(1) */
    return Observable.Start(() =&gt; 100)
        .Do(_ =&gt; { /* finally action(2) */}, _ =&gt; {/* same finally action(2) */})
        .ForEachAsync(x =&gt;
        {
            /* after action(3) */
        });
}
</code></pre>
<p>Finallyに関しては、実は同じに扱える表現がありません!RxのFinallyはパイプラインの終了時の実行なので、実行順序がベタtry-finallyで書いた時と異なるんですよねえ。いちおう、DoでOnNextとOnErrorのところに同じコードを書くことでそれっぽい表現は可能ではありますが……。</p>
<h2>並列処理</h2>
<pre><code class="language-csharp">public async Task ParallelAsync()
{
    var a = Task.Factory.StartNew(() =&gt; 100);
    var b = Task.Factory.StartNew(() =&gt; 200);
    var c = Task.Factory.StartNew(() =&gt; 300);
    
    var xs = await Task.WhenAll(a, b, c);
    /* after action */
}


public IObservable&lt;Unit&gt; ParallelIO()
{
    var a = Observable.Start(() =&gt; 100);
    var b = Observable.Start(() =&gt; 200);
    var c = Observable.Start(() =&gt; 300);
    
    return Observable.WhenAll(a, b, c)
        .ForEachAsync(xs =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>並列処理は非同期固有の実行ですが、WhenAllでドバッとまとめるというのが基本方針。</p>
<h2>タイムアウト</h2>
<pre><code class="language-csharp">public async Task TimeoutAsync(TimeSpan timeout)
{
    var task = Task.Factory.StartNew(() =&gt; 100);    
    var delay = Task.Delay(timeout);
    if (await Task.WhenAny(task, delay) == delay)
    {
        /* timeout action */
        throw new TimeoutException();
    }
    /* after action */
}


public IObservable&lt;Unit&gt; TimeoutIO(TimeSpan timeout)
{
    return Observable.Start(() =&gt; 100)
        .Timeout(timeout)
        .Catch((TimeoutException ex) =&gt;
        {
            /* timeout action */
            return Observable.Throw&lt;int&gt;(ex);
        })
        .ForEachAsync(x =&gt;
        {
            /* after action */
        });
}
</code></pre>
<p>タイマウトも非同期固有の処理。async/awaitの場合、特有のイディオムがあります。UniRxの場合はTimeoutだけでOK。特に例外時に処理するものもないなら、Catchは不要です。</p>
<h2>IEnumeratorに戻す</h2>
<pre><code class="language-csharp">public IObservable&lt;Unit&gt; Demo6_IE()
{
    /* before action(1) */
    return Observable.FromCoroutine(() =&gt; Demo6_IECore());
}

IEnumerator Demo6_IECore()
{
    // 戻り値の不要な場合
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine();
    
    int ret;
    yield return Observable.Start(() =&gt; 100).StartAsCoroutine(x =&gt; ret = x);
}
</code></pre>
<p>SelectManyの連打が辛い場合、ふつーのコルーチンに戻して、更にIObservableでラップするという手段も取れます。まあ、この辺は複雑さ度合いで自由に！</p>
<p>だったらもはや最初から全部コルーチンでええやん！Rxでメソッドチェーン複雑だし見た目だけならコルーチン最強にスッキリじゃん！というのは正しい。正しいんですが、例外処理・戻り値・合成可能性・並列処理・マルチスレッド、などといった要素が欠落してるので、コルーチンはコルーチンで苦しいところが多いというか実際のところシンプルなケース以外では相当苦しいので、基本的にはRxのほうが有利です。</p>
<h2>async/awaitは必要？</h2>
<p>みたとーり、必要です。どう考えても。さすがにSelectManyの連打を同期コードほどスッキリと言い張るのは無理があるでしょう。とはいえまぁ、書いて書けないこともないので、今あるツールの中でベストを尽くすのまた良きかな、とは思いますねー。というわけで良き非同期生活を！UniRxでイベントを扱う際のパターン集は、またそのうちにでも！</p>
</div>
<h1><a href="https://neue.cc/2015/09/29_517.html">実例からみるC#でのメタプログラミング用法集</a></h1>
<ul class="date"><li>2015-09-29</li></ul>
<div class="entry_body"><p>Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用、という題で<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>にて話してきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/pF55iU0qXIeRFv" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/metaprogramming-universe-in-c-ilroslyn" title="Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例" target="_blank">Metaprogramming Universe in C# - 実例に見るILからRoslynまでの活用例</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>現在、PhotonWireというフレームワークを作っているのですが、それで使ったメタプロ技法を紹介しました。ExpressionTree, T4, ILGenerator, Roslyn(Analyzer), Mono.Cecilとそれなりに満遍なく使っているので、それらをどーいう時に使えばいいのかというヒントになれば幸いです。まとめに書きましたが、手法自体は少なくするに越したこたぁないです、メタプロってついやりすぎちゃう傾向にあるんで、目的Firstを忘れないようにしないと本末転倒になりがちです。あと、それぞれは別にそんなに難しくない、というか難しくやらないようにするのが良いですね、そもそも長い式木とか長いILとか書きたくないですし……。</p>
<p>Proxyのvirtual強制は制約強くてゲロなので喪われた技法って感じですが、Roslyn Analyzerでコンパイラエラーに制限できることによって復活したかもしれない気がするかもしれない！あと、Taskは大事ですね、非同期のシグネチャとしてTaskで表明できるようになったのはひじょーーーーーーに大きな事です。これは実際めちゃくちゃ大きなことなのに過小評価してたり勘違いしてたりすると、いくない。もちろん、async/awaitで手軽にハンドリングできるようになったことも大事。RPC Revisitedですよ。そんなわけでごった煮しつつも、私的な独断と偏見に基づくバランス感覚で取捨してます。この辺の感覚はかなり大事だと思うんだな。</p>
<p>なお、書籍では<a href="http://www.amazon.co.jp/dp/4048867741">メタプログラミング.NET</a>が良書なのでオススメです。</p>
<h2>PhotonWire</h2>
<p>題材のPhotonWireは、<a href="http://grani.jp/">グラニ</a>で現在開発中のリアルタイムネットワーク通信用フレームワークです(ところでUnity、特にUniRxをゴリゴリ活用した先端的(エキセントリックともいう)なスクリプティング環境や、クライアントからサーバーまで全てC#で統一したあいそもーふぃっくな開発に興味のある人はいつでもウェルカムで採用募集中です)。といってもレイヤー的には比較的高レベルで、下回りでは<a href="https://www.photonengine.com/">Photon Server</a>というミドルウェアを採用していて、その上のRPCフレームワークを提供という感じです。キャッチコピーは「Typed Asynchronous RPC Layer for Photon Server + Unity」ということで、特にUnityとの繋ぎ込みを重視していて、クライアント-サーバー、サーバー-クライアント、サーバー-サーバーの方向のRPCを提供します。クライアント-クライアントは非サポート（あれは百害あって一利なし）。</p>
<p>クライアント-サーバーはご存知<a href="https://github.com/SignalR/SignalR">SignalR</a>、サーバー-サーバーは<a href="https://github.com/dotnet/orleans">Orleans</a>という分散アクターフレームワークのAPIを参考にしています、が、サーバーの分散に関しては、別に全然賢くないです。というか機能全く無いです。もともとのPhotonがそこに対するサポートがゼロで、PhotonWireでもたいしたサポートを入れてません。私的にはこの素朴な割り切りは結構好きですね。変に透過的に見せるよりも、それぞれのサーバー/それぞれのレイヤーを独立して、ある程度プリミティブな操作を可能にしたほうがはまりどころも少ないし。別に賢くはないんだけど、手堅い。ゲームという用途で考えると、あまりカシコイものよりも、愚直なシステムのほうがマッチしそうな感触があります。必要になったら、まぁ適当に考える。</p>
<p>Photon(+Unity)にはもともとPhoton Unity Network(PUN)という高レベルなクライアントが用意されているのですが、正直あんまり良いものでもない（特にPhoton Serverで自前ロジックを入れてくような場合は）ので、無視です、無視。で、PUNを通さない低レベルのSDKもあって、こちらは相当低レベルで本当に接続とデータ転送しか提供していないので（ただし低レベルSDKとしてはこのぐらいのほうが好ましい、へたに変なのがゴチャゴチャついてるよりも）、サーバーSDK（こちらもかなり低レベル）ともども統一した形で、ちょっと高レベルなもの、ぐらいの位置づけで作り上げてみました。</p>
<p>クラスとメソッドに属性でIDつけさせて、それで振り分けしているのでJSON-RPC的なメソッド名なども送っちゃうのでサイズが大きくなる、ということはなく、通常の転送に較べてもオーバーヘッドは2byteです。別に全然ない。ユーザー定義の型を送る場合（通常のPhotonはこれをサポートしてない）は<a href="https://github.com/msgpack/msgpack-cli">MsgPack-CLI</a>でシリアライズ/デシリアライズするため、その際の容量増大も極小です。また、シリアライザ/デシリアライザはその型に合致したものを事前生成するため、Unityにおいても高速に動作させられます、といったシステムも含まれています。</p>
<p>デバッグ用の専用クライアント（WPF製）なども込み込みで(これのデザイン面の話は<a href="http://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a>に書いてます)、痒い所に手が届きつつも、機能自体は小さく「型付きの非同期RPCの提供」から逸脱しない程度におさめているので、まーまー使いやすいんじゃないかなー、と思いますね。もちろん、クライアント側は<a href="https://github.com/neuecc/UniRx">UniRx</a>前提です。</p>
<p>UniRx同様、GitHub/AssetStoreでの公開予定はあるというか、早く公開したいんですが、Photonの次バージョンのベータ版を使って開発してるので、そっちが正式リリースされないと公開できないので早く出ないかなぁ(ﾁﾗｯ とオモッテマス。</p>
</div>
<h1><a href="https://neue.cc/2015/09/10_515.html">Material Design In XAML Toolkitでお手軽にWPFアプリを美しく</a></h1>
<ul class="date"><li>2015-09-10</li></ul>
<div class="entry_body"><p>なんとブログ書くのは3ヶ月ぶり近い！えー、うーん、そんな経っちゃってるのか、こりゃいかん。と、いうわけかでWPFアプリを入り用で作ったんですが、見た目がショボくてゲッソリしてました。WPFでアプリ書いても別に綺麗な見た目にならんのですよね、むしろショボいというか。自分でデザイン作りこんだりなんて出来ないし、でもWPFのテーマ集なんかを適用してもクソダサいテーマしかなかったりして一層ダサくなるだけで全く意味ないとかそんなこんなんで、まぁ割とげっそりだったのですが、<a href="https://github.com/ButchersBoy/MaterialDesignInXamlToolkit">Material Design In XAML Toolkit</a>は相当良い！良かった、のでちょうど手元に作り中のWPFアプリがあって適用してみたんで紹介してきます。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>最終的に↑のような感じになりました。サクサクッとテーマ適用してくだけでこの程度に整えられるならば、上等すぎるかな、と。私的にはマテリアルデザイン、相当気に入りました。WindowsのModern UI風のフラットテーマは普通に適用しただけだと超絶ダサくなるという、センスが要求されすぎてキツかったんですが、マテリアルデザインはそれなりに質感が乗っかってるのでまぁまぁ見れる感じになる。また、画像からは分かりませんが結構細かくアニメーションが設定されていて感触が良い（マテリアルデザインの重要な要素だそうで）のも嬉しい。</p>
<h2>Before</h2>
<p>Beforeはこんな感じです。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml2.jpg' alt='' /></p>
<p>TextBoxとボタンの羅列、実にギョーミーな雰囲気。機能的には私の要件はこれで満たしてるんですが（ちなみにコレが何かは後日紹介するしGitHubで公開もするつもりですが今は本題ではないのでスルーします）、いかんせん見た目が悲しいかな、と。そこで現れたMaterial Design In XAML Toolkit！NuGetからのインストールとコピペ一発で素敵な見た目に……。
なるほど世の中はさすがに甘くなかったですね:)</p>
<p>適用は簡単で、NuGetからMaterialDesignThemesをダウンロード、そしてApp.xaml.csに<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MainDemo.Wpf/App.xaml">このApp.xaml</a>のApplication.Resourcesをコピペ。そしてMainWindowに以下の4項目を貼っつけてあげればできあがり。</p>
<pre><code class="language-xml">&lt;MainWindow
    xmlns:wpf=&quot;clr-namespace:MaterialDesignThemes.Wpf;assembly=MaterialDesignThemes.Wpf&quot;
    TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
    Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
    FontFamily=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto&quot;&gt;
</code></pre>
<p>簡単簡単。これで美しくなるなら素晴らしいですね？そしてその結果がこれ。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml3.jpg' alt='' /></p>
<p>うん、ダメ、理想とは程遠いダサさに溢れてます。Bootstrapを適用しただけじゃ普通にダサいままってのと同じ。ボーダーが吹っ飛んだので境目がわからず使いにくくなったし、やっぱダサ……、なんか一部のボタンは文字埋まっちゃってるし。で、引き返そうと思ったんですが、なんとなく良さそうな気配は感じたのでもう少し粘って作業することにしました。</p>
<h2>デモアプリを見ながら細工</h2>
<p>まずMaterialDesignInXamlToolkitのプロジェクトを落としましょう。CloneしてもいいしDownload Zipでもいいので。で、MainDemo.Wpfをビルドして実行しましょう、特に躓くことなくビルドできるはずですので。このデモアプリが非常によく出来ていて、出来ること全ての解説になってますし、当然それをやりたければそのxamlを開いてコピペすればなんとかなります！</p>
<p>というわけでデモアプリを眺めつつ自分のクソダサアプリのどこから手を入れようか。まず画面の構成要素のうち、上の部分のテキストボックスとボタンが並んでるところはコンフィグに近いので色分けしようかな、と。ヘッダ部分の色分け例はマテリアルデザインでよく見るパターンですしね。よく見るパターンということは、専用のパーツがしっかり用意されています。ColorZoneで囲むことで色がガラッと変わります。</p>
<pre><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Inverted&quot; Padding=&quot;0&quot;&gt;
    ...
&lt;/wpf:ColorZone&gt;
</code></pre>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml4.jpg' alt='' /></p>
<p>ModeのInvertedは逆転した色、というわけで、これだけでまぁまぁ引き締まった雰囲気が出てきました、これはやって正解。また、ボタンの文字が埋まっているのはMargin入れて小さくしてたせいだったので、Heightを設定する形で小さくすることにしました。この状態でちょっとだけ問題があって、コンボボックスの選択時のフォントが通常カラーのままなので色が薄く見えなくなってしまうことに……。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml5.jpg' alt='' /></p>
<p>これはテーマから外れたItemContainerStyleを設定して回避。</p>
<pre><code class="language-xml">&lt;ComboBox ItemsSource=&quot;{Binding UseConnectionType}&quot;&gt;
    &lt;ComboBox.ItemContainerStyle&gt;
        &lt;Style TargetType=&quot;ComboBoxItem&quot;&gt;
            &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Gray&quot; /&gt;
        &lt;/Style&gt;
    &lt;/ComboBox.ItemContainerStyle&gt;
&lt;/ComboBox&gt;
</code></pre>
<p>よくわからんけどこんなんでいいでしょふ、よくわからんけど。真面目にXAML書くの5年ぶりぐらいなんで正直もう全然覚えてないんですよね。</p>
<p>そういえば、オマケコントロール（？）としてTextBoxにウォーターマークがつけれるのが入ってます。使い方はwpf:TextFieldAssist.Hintを入れるだけ。</p>
<pre><code class="language-xml">&lt;TextBox wpf:TextFieldAssist.Hint=&quot;うぉーたーまーく&quot; /&gt;
</code></pre>
<p>かなり綺麗に出て素敵なので最高だと思いました、まる。</p>
<h2>MahAppsの導入</h2>
<p>タイトルウィンドウが乖離しててダサいというか気になってきた。ので、ここを手軽に改変できる<a href="http://mahapps.com/">MahApps</a>を入れましょう。MahAppsだけだと、Metro風ということでこれ単体では別に素敵な見た目に出来ないんですが（ほんとメトロ風はムズカスぃ！）、Material Design In XAML Toolkitと合わせるとお互いの領域をカバーできる。ちゃんとMaterial Design In XAML Toolkit側で統合のための設定が用意されているので組み合わせるのは簡単です。MahAppsの基本的な導入は<a href="http://mahapps.com/guides/quick-start.html">Quick Start</a>に従う通り、まずWindowをMetroWindowに差し替えて</p>
<pre><code class="language-xml">// Xaml 
&lt;Controls:MetroWindow
    xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;&gt;

// CodeBehind
public partial class MainWindow : MahApps.Metro.Controls.MetroWindow
</code></pre>
<p>App.xamlにリソースを投下、なのですが、MaterialDesignInXamlToolkitと統合するためのサンプルがMaterialDesignInXamlToolkit側に用意されているので、リソースは<a href="https://raw.githubusercontent.com/ButchersBoy/MaterialDesignInXamlToolkit/master/MahMaterialDragablzMashUp/App.xaml">MahMaterialDragablzMashUp/App.xaml</a>からコピペってきましょう。DragablzというChromeみたいなドラッグアンドドロップで切り離せるタブのためのライブラリを使わない場合（今回は使いませんでした）は、Dragablzに対する行は削除しておｋ（というか削除しないと動きません）。これで</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml6.jpg' alt='' /></p>
<p>となりました。うーん、よくなってきた！タイトルバーのところにテキストでいい感じなレイアウトで手軽にコマンドを突っ込めるのも嬉しかった。というわけでBeforeではステータスバーのところにやけくそにダサい感じで置いてたDuplicate Windowボタン（ウィンドウを複製する）をタイトルバーに移動。ついでにAlign Window（複数ウィンドウを整列させる）コマンドも追加。ちなみにこのアプリは複数ウィンドウを並べて使うのが前提なので、並べた時に重なって鬱陶しいためウィンドウ枠を光らせるのはあえて切ってるんですが、単体アプリなら光らせたほうが見栄え良いかもですね。入れるの自体は簡単で</p>
<pre><code class="language-xml">&lt;!-- 光らせるところ、GlowBrushを削れば光らない --&gt;
&lt;Controls:MetroWindow
    GlowBrush=&quot;{DynamicResource AccentColorBrush}&quot;&gt;    

    &lt;!-- コマンド入れるところ --&gt;
    &lt;Controls:MetroWindow.RightWindowCommands&gt;
        &lt;Controls:WindowCommands&gt;
            &lt;Button Content=&quot;Align Window&quot; Click=&quot;AlignWindow_Click&quot; /&gt;
            &lt;Button Content=&quot;Duplicate Window&quot; Click=&quot;DuplicateWindow_Click&quot; /&gt;
        &lt;/Controls:WindowCommands&gt;
    &lt;/Controls:MetroWindow.RightWindowCommands&gt;
</code></pre>
<p>をMainWindows.xamlに突っ込むだけです。お手軽素敵。</p>
<h2>最終調整</h2>
<p>Purpleじゃない色調にしたかったのでテーマをデモアプリのパレットから眺めてBlueGrayに決定。テーマはApp.xamlを弄ればヨイデス。MaterialDesignColor.xxx.xamlの部分ですね、他の色とかはデモアプリのPaletteで確認できます。その他Light/Darkの切り替えやSecondaryColourの設定なんかも、xxx.xamlのそれっぽい部分をなんとなく書き換えれば書き換わります。</p>
<pre><code class="language-xml">&lt;!-- include your primary palette --&gt;
&lt;ResourceDictionary.MergedDictionaries&gt;
    &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/MaterialDesignColor.BlueGrey.xaml&quot; /&gt;
&lt;/ResourceDictionary.MergedDictionaries&gt;
</code></pre>
<p>これで全体の色が変わったので、最後に、中央部分がMarginが消えてて区切りめがわからず使いづらいのは変わらずだったので、ここは枠をいれて明確な分離を。最初はボーダー入れて調整とかしてみたんですがイマイチしっくりこなかったんで、まぁ枠かな、と。マテリアルデザイン風のシャドウのある枠はヘッダーで色分けした時と同じく ColorZone で囲むだけです、ModeはStandardを選択。モードがどんなのがあるかもデモアプリを見れば一発で分かります。</p>
<pre><code class="language-xml">&lt;wpf:ColorZone Mode=&quot;Standard&quot; Padding=&quot;5&quot; CornerRadius=&quot;3&quot; Effect=&quot;{DynamicResource MaterialDesignShadowDepth1}&quot; Margin=&quot;2&quot;&gt;
    &lt;local:OperationItem /&gt;
&lt;/wpf:ColorZone&gt;
</code></pre>
<p>影の出方はMaterialDesignShadowDepthの1~5で調整可能で、今回は1にしてます。その他の調整として、ログを表示しているテキストボックスのボーダーを上にも出すようにしたり、中身によって拡縮するようになっちゃたのでVerticalContentAlignmentを設定したりとちょっとした調整を少し入れて、最初に出した画像のものになりました。もっかい同じのを載せますけれど。</p>
<p class="noindent"><img src='http://neue.cc/wp-content/uploads/image/materialxaml1.jpg' alt='' /></p>
<p>アプリの見た目が良くなるってのは純粋にテンション上がるんでいいものですねぇ、機能的には何も変わっちゃいないですが、気分は随分と良いです。まぁギョームコウリツとは関係ないとこなんであんまり手を入れまくってもアレですが、ちょっとテーマ適用して調整するだけで必要最低限整ってくれるのは実に良いです。</p>
<h2>＋アイコン</h2>
<p>あとパラメータのコピペが欲しくなりました、複数ウィンドウ間で貼って回ったりするので。というわけでボタンにアイコンを用意したくて、それもマテリアルデザインなら簡単！</p>
<img src='http://neue.cc/wp-content/uploads/2015/09/materialxamlicon.jpg' alt='' />
<pre><code class="language-xml">&lt;Button Background=&quot;{StaticResource PrimaryHueLightBrush}&quot;
        HorizontalAlignment=&quot;Left&quot;
        Width=&quot;24&quot; Height=&quot;24&quot; Padding=&quot;0&quot; Margin=&quot;5&quot;
        Command=&quot;{Binding PasteCommand}&quot;
        ToolTip=&quot;Paste&quot;&gt;
    &lt;Viewbox Width=&quot;16&quot; Height=&quot;16&quot;&gt;
        &lt;Canvas Width=&quot;24&quot; Height=&quot;24&quot;&gt;
            &lt;Path Data=&quot;M19,20H5V4H7V7H17V4H19M12,2A1,1 0 0,1 13,3A1,1 0 0,1 12,4A1,1 0 0,1 11,3A1,1 0 0,1 12,2M19,2H14.82C14.4,0.84 13.3,0 12,0C10.7,0 9.6,0.84 9.18,2H5A2,2 0 0,0 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V4A2,2 0 0,0 19,2Z&quot;
                     Fill=&quot;{DynamicResource MaterialDesignBody}&quot; /&gt;
        &lt;/Canvas&gt;
    &lt;/Viewbox&gt;
&lt;/Button&gt;
</code></pre>
<p>これは<a href="https://materialdesignicons.com/">Material Design Icons</a>にあるアイコンから取ってきてます。そこにはXAMLのPath Dataも載ってるので、タグをそのまま貼り付けるだけでアイコンとして使えます。これは楽ちんでめっちゃ良い！アイコンは揃えるのどうしても面倒ですからねー、このお手軽さは嬉しすぎます。色とかを用意されてるMaterialDesignのスタイルを入れ込んでやればそれだけで中々見栄えのするアイコンの出来上がり。</p>
<h2>ReactiveCommand</h2>
<p>えむぶいぶいえむ的なのは<a href="https://github.com/runceel/ReactiveProperty">ReactiveProperty</a>で実装してます。で、ReactivePropertyもいーんですが、私的には昔から結構ReactiveCommand押しなんですよ、ReactiveCommandいいんだけどなー。例えば実際こんなコードになってます。</p>
<pre><code class="language-csharp">// peer = ReactiveProperty&lt;Connection&gt;
// ObserveStatusChangedで状態の変化の監視 + コネクションは切り替わることがあるので前のを破棄するSwitch
// Disconnectが押せるのはStatusがConnectの時だけ
Disconnect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .Select(x =&gt; x == StatusCode.Connect)
    .ToReactiveCommand();

// Disconnectの逆、だけどConnectが押せるのはそれに加えて接続先アドレス入力欄が空でない場合
Connect = peer.Select(x =&gt; x.ObserveStatusChanged())
    .Switch()
    .CombineLatest(Address, (x, y) =&gt; x != StatusCode.Connect &amp;&amp; !string.IsNullOrEmpty(y))
    .ToReactiveCommand();
</code></pre>
<p>とか。若干込み入って面倒くさいのがスッキリ + ボタンのCanExecuteとぴったり来る。あとはプロセスを監視してて、存在してれば止めるボタンが押せるというのは、一秒毎のチェックにしていて、Observable.Intervalで繋ぎあわせてます。</p>
<pre><code class="language-csharp">// PhotonSocketServerが存在すれば押せるコマンド、1秒毎のポーリングで監視
KillPhotonProcess = Observable.Interval(TimeSpan.FromSeconds(1))
    .Select(x =&gt; Process.GetProcessesByName(&quot;PhotonSocketServer&quot;).Any()); 
    .ToReactiveCommand();
</code></pre>
<p>こういうの悩まずサクサク書けるのは幸せ度高い。</p>
<h2>で、これ何なの？</h2>
<p>なんなんでしょーねぇ。ということの一端は<a href="https://roommetro.doorkeeper.jp/events/30482">Metro.cs #1</a>という勉強会で「IL から Roslyn まで - Metaprogramming Universe in C#」というタイトルでお話しますよ！2015-09-16（水）19:30 - 22:00に渋谷でやりますので、気になる人は是非是非参加くだしあ。内容はRoslyn 20%, C#全般 60%, WPF 10%, Unity 10%ぐらいなイメージですかしらん。このWPFのどこにメタプログラミング要素があるかというと、中身は<a href="https://github.com/jbevain/cecil">Mono.Cecil</a>使ってアセンブリ解析してるからです。へー。とかそういうことを話します。</p>
</div>
<h1><a href="https://neue.cc/2015/06/20_514.html">第一回UniRx勉強会を開催しました＋スライドまとめ</a></h1>
<ul class="date"><li>2015-06-20</li></ul>
<div class="entry_body"><p>と、いうわけかで<a href="https://unirx.doorkeeper.jp/events/25218">UniRx勉強会</a>を開催しました。当日の模様は<a href="http://togetter.com/li/837045">togetterまとめ</a>で。登録が150人ほど、生憎の雨天でしたが130人以上来てくださってめっちゃ嬉しかったですね。慣れないというかはぢめての主催＋司会でその辺アレだったのですが、会場をお貸し下さったgloopsさんの手厚い協力のお陰で、なんとか成立させることができ、ほんとうに感謝です。</p>
<p>私の発表資料は「History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法」になります。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/5F9QtUqHz35hz6" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/history-practices-for-unirx-unirx" title="History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法" target="_blank">History &amp; Practices for UniRx UniRxの歴史、或いは開発(中)タイトルの用例と落とし穴の回避法</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>あまりUniRx固有、という感じでもなく、また凄い話、でもなんでもない地味な内容なのですけれど、ちょっとはまると嫌だなー、けどはまりがちなポイントを説明してみた、といった感。地味すぎてトリとしてはなんともいえない感じでしたね、うむむむ。ちなみにReal World UniRxというのは、<a href="http://www.amazon.co.jp/dp/4873114233">Real World Haskell―実戦で学ぶ関数型言語プログラミング</a>という本が名前的には元ネタです。Real World、現実世界で使われるUniRx。というわけで要約すれば事例求む、みたいな。</p>
<h2>はじめてのUniRx</h2>
<p>toRisouPさんの発表です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/y3Mc90k0Kg2W6h" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/torisoup/uni-rx" title="はじめてのUniRx" target="_blank">はじめてのUniRx</a> </strong> from <strong><a href="//www.slideshare.net/torisoup" target="_blank">torisoup</a></strong> </div>
<p>資料的価値が非常に高く、わかりやすい。めっちゃ読みこむと良いと思います、スゴクイイ！Cold/Hotとか大事なんですがむつかしいところですしねー。</p>
<h2>若輩エンジニアから見たUniRxを利用したゲーム開発</h2>
<p>gloopsの森永さんの発表です。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/Lm53c7Fx4wEkiW" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/HirohitoMorinaga/unirx" title="若輩エンジニアから見たUniRxを利用したゲーム開発" target="_blank">若輩エンジニアから見たUniRxを利用したゲーム開発</a> </strong> from <strong><a href="//www.slideshare.net/HirohitoMorinaga" target="_blank">Hirohito Morinaga</a></strong> </div>
<p>toRisouPさんのが中級者向けでしたので、こちらが初心者向けでしたね。UniRxがどういう風に自分の中で浸透というか理解が進んでいくか、というのがstep by stepで紹介されていて、伝わりやすいと思います。あと、全然紹介していなかったObservableTriggerまわりの応用が完璧に書かれていてすばら。</p>
<h2>Interactive UI with UniRx</h2>
<p>トライフォートの岩下さんのセッションです。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/peEH4Z6NuD6iaJ" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/yutoiwashita/reactive-ui-withunirx" title="Interactive UI with UniRx" target="_blank">Interactive UI with UniRx</a> </strong> from <strong><a href="//www.slideshare.net/yutoiwashita" target="_blank">Yuto Iwashita</a></strong> </div>
<p>UniRxって基本的にスクリプティング領域の技術なので、とにかく地味！なのですが、このセッションは地味どころかDemo含め、めっちゃ伝わるし美しさ、手触りが伝わって凄かった。実際本日一番の感動でしたにゃ。</p>
<h2>「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜</h2>
<p>ユニティ・テクノロジーズ・ジャパンの名雪さんのLTです。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/JkKnfNJRjYkkKY" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/tnayuki/uni-rx-49594996" title="「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜" target="_blank">「ずいぶんとダサいライティングを使っているのね」〜UniRxを用いた物理ベースライティング制御〜</a> </strong> from <strong><a href="//www.slideshare.net/tnayuki" target="_blank">Toru Nayuki</a></strong> </div>
<p>色々なものへのReactiveな入力/出力ができるんじゃもん！と言ってはいるし興味はかなりあるのだけれど、自分でやったことが全くない領域で、それが実際になされてる様を目にするとオオーッってなりました。</p>
<h2>その他</h2>
<p>そういえば、ブログに書いてなかったんですがちょっと前に「Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方」という発表をしていました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/sPOoYnUU3lXtpq" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/observable-everywhere-rxuni-rx" title="Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方" target="_blank">Observable Everywhere - Rxの原則とUniRxにみるデータソースの見つけ方</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>これ、自分的には結構良い内容だなー、と思っているので見たことないかたは是非目を通してもらえると。</p>
<h2>まとめ</h2>
<p>第一回、というわけなんですがかなり密度濃い内容になったのでは！？懇親会でも、自分の思っていたよりもずっと遥かに使い出している、注目している、という声をいただき嬉しかったですねー。もっとドンドン良くしていかなければ、と気が引き締まります。次回がいつになるかは完全不明（というか当分後かな？）ですが、やっていきたいなー、と思いましたです。</p>
</div>
<h1><a href="https://neue.cc/2015/06/13_513.html">NotifyPropertyChangedGenerator - RoslynによるVS2015時代の変更通知プロパティの書き方</a></h1>
<ul class="date"><li>2015-06-13</li></ul>
<div class="entry_body"><p>半月前にIntroduction to NotifyPropertyChangedGeneratorというタイトルでセッションしてきました。</p>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/2wWO7MM7GaH1Uc" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/neuecc/introduction-to-notifypropertychangedgenerator" title="Introduction to NotifyPropertyChangedGenerator" target="_blank">Introduction to NotifyPropertyChangedGenerator</a> </strong> from <strong><a href="//www.slideshare.net/neuecc" target="_blank">Yoshifumi Kawai</a></strong> </div>
<p>コードはGitHubで公開しているのと、NuGetでインストールもできます。</p>
<ul>
<li><a href="https://github.com/neuecc/NotifyPropertyChangedGenerator">GitHub - NotifyPropertyChangedGenerator</a></li>
<li><a href="http://www.nuget.org/packages/NotifyPropertyChangedGenerator">Install-Package NotifyPropertyChangedGenerator</a></li>
</ul>
<p>なにかというとVS2015のRoslynでのAnalyzerです。AnalyzerというとStyle Copに毛の生えたようなもの、をイメージしてしまうかもなのですが、全くそれだけじゃなく、真価はコードジェネレーターのほうにあると思っています。コンパイラでのエラーや警告も出せて、自然にVSやプロジェクトと統合されることから、Compiler Extension + Code Generatorとして私は捉えています。その例としてのINotifyPropertyChangedの生成となります。</p>
<h2>POMO</h2>
<p>Plain Old MVVM Object（笑）を定着させたいという意図は特にないのですが、割と語感が気に入ったので使ってみまふ。まぁとはいえ、やっぱ変更通知プロパティ程度で基底クラスを継承させるのは、そんなによろしいことではない、という認識はあるかなぁ、と。そのためのアプローチとして、こういったものが現実解にはなってくると思います、VS2015時代では。</p>
<p>さて、ちょうどufcppさんが<a href="http://ufcpp.net/blog/2015/6/valuechangedganerator/">【Roslynメタプログラミング】ValueChangedGanerator</a>を公開されました。アプローチが異なるわけですが、結構好みも出てくるかな、と思います。特に違いはpartialで外部ファイルに隔離 or 同一ファイル内で成形、は根本的に違うかもです。私はあまりpartialって好きではなくて、というのも結構迷子になるんですよね。いや、partial自体は素晴らしい機構でT4生成の時などに捗るんですが、このINotifyPropertyChanged程度のものでファイル分離されると、ファイル数が膨大になって、ちょっと……。また、プロパティのようなコードで触るものが外のファイルにあるのも、綺麗にはなるものの見通しは低下してしまうのではないかなあ、と。まぁ、この辺は良し悪しというかは好みかなー、といった感ですね。</p>
<p>色々なアプローチが考えられると思うので、色々試してみるのが良いと思います、Analyzer、可能性あって面白いです。ぜひ触ってみてくださいな。</p>
</div>
<h1><a href="https://neue.cc/2015/05/11_512.html">UniRxでの空呼び出し検出、或いはRoslynによるCode Aware Libraries時代の到来について</a></h1>
<ul class="date"><li>2015-05-11</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx - Reactive Extensions for Unity</a>用に、メソッド呼んだだけで何も処理してないIObservable&lt;T&gt;があったらWarningを出すAnalyzerを作ってみました。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/AnalyzerReference.jpg" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/VSAnalyzer.jpg" alt="" /></p>
<p>AnalyzerはVisual Studio 2015からの機能です。というわけで<a href="https://www.microsoft.com/ja-jp/dev/products/visual-studio-2015.aspx">Visual Studio 2015 RC</a>が必要です。あとは、NuGetからAnalyzerが入れられるようになっているので</p>
<ul>
<li>Install-Package <a href="http://www.nuget.org/packages/UniRxAnalyzer">UniRxAnalyzer</a></li>
</ul>
<p>でOK。Unityのプロジェクトであっても問題なく使えます(ただしVSTUのcsproj自動生成でAnalyzerタグは吹っ飛ぶので、生成をフックして復元する必要はあります、フック方法の詳細は<a href="https://speakerdeck.com/grabacr07/minnada-hao-ki-boo-dot-lang-wo-satsugai-surufang-fa">みんな大好き Boo.Lang を SATSUGAI する方法</a>を参照のこと)。もし、他にこういうAnalyzerがあったら便利なのになー、とかってアイディアあったら気楽に言ってください！作りますので！</p>
<p>現在の<a href="http://grani.jp/">うちの会社（グラニ）</a>のプロジェクトはRxが土台から、ありとあらゆる全てで使われているので、ちょっとした呼び出しのつもりでやってたら何もおこらなくて(Susbcribe漏れ)クソが！となるシチュエーションが少なくなかったので、こういうAnalyzerが必需品だったのでした。</p>
<p>ようするにC# 5.0のTaskでawaitしてないと警告が出るのと同じ話なのですが、そういうのが言語組み込みキーワードでなくても自由に、（VS2015で動かせるなら）簡単にプロジェクト単位で追加出来る、というのがミソです。こういったライブラリとアナライザーの組み合わせは、Code Aware Librariesという言葉でまとめられます。<a href="http://channel9.msdn.com/Events/Build/2015/3-725">.NET Compiler Platform (&quot;Roslyn&quot;): Analyzers and the Rise of Code-Aware Libraries</a>。従来はライブラリのみの提供でしたが、そこにAnalyzerも組み合わせて、Best Practiceを一体化して伝えていくような世界観が広がっています。</p>
<p>例えば、私は<a href="https://github.com/neuecc/LightNode">LightNode</a>というWebAPIフレームワークを作っていますが、これは引数の型に幾つかの制約があります。また、メソッドのオーバーロードを許していなかったりします。それらは実行時のウォームアップのタイミングでフェイルファストとして気づかせるようにしていますが、それよりも前のタイミング、コードを書いている最中にリアルタイムで警告できれば、より良いでしょう。なので、Analyzerを同梱すれば、より良い形、より良いライブラリの有り様になります。</p>
<h2>DiagnosticAnalyzerの作り方 Part2</h2>
<p>以前に<a href="http://neue.cc/2014/11/20_485.html">VS2015のRoslynでCode Analyzerを自作する(ついでにUnityコードも解析する)</a>と<a href="http://neue.cc/2014/12/08_496.html">VS2015+RoslynによるCodeRefactoringProviderの作り方と活用法</a>という記事を書きましたが、基本的にはそれらと同じです、アタリマエですが。↑の記事はCTPの頃のもので、若干インターフェイスが変わっちゃっていますが、少し修正するだけでほぼほぼ同じかな。</p>
<p>今回作ったのはCode Analyzerで、Fixは含めていないのでcsファイル一個だけで済んでいます。</p>
<pre><code class="language-csharp">[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class HandleObservableAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = &quot;HandleObservable&quot;;

    internal const string Title = &quot;IObservable&lt;T&gt; does not handled.&quot;;
    internal const string MessageFormat = &quot;This call does not handle IObservable&lt;T&gt;.&quot;;
    internal const string Description = &quot;IObservable&lt;T&gt; should be handled(assign, subscribe, chain operator).&quot;;
    internal const string Category = &quot;Usage&quot;;

    internal static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);

    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        var invocationExpressions = context.Node
            .DescendantNodes(descendIntoChildren: x =&gt; !(x is InvocationExpressionSyntax))
            .OfType&lt;InvocationExpressionSyntax&gt;();

        foreach (var expr in invocationExpressions)
        {
            var type = context.SemanticModel.GetTypeInfo(expr).Type;
            // UniRx.IObservable? System.IObservable?
            if (new[] { type }.Concat(type.AllInterfaces).Any(x =&gt; x.Name == &quot;IObservable&quot;))
            {
                // Okay =&gt; x = M(), var x = M(), return M(), from x in M()
                if (expr.Parent.IsKind(SyntaxKind.SimpleAssignmentExpression)) continue;
                if (expr.Parent.IsKind(SyntaxKind.EqualsValueClause) &amp;&amp; expr.Parent.Parent.IsKind(SyntaxKind.VariableDeclarator)) continue;
                if (expr.Parent.IsKind(SyntaxKind.ReturnStatement)) continue;
                if (expr.Parent.IsKind(SyntaxKind.FromClause)) continue;

                // Okay =&gt; M().M()
                if (expr.DescendantNodes().OfType&lt;InvocationExpressionSyntax&gt;().Any()) continue;

                // Report Warning
                var diagnostic = Diagnostic.Create(Rule, expr.GetLocation());
                context.ReportDiagnostic(diagnostic);
            }
        }
    }
}
</code></pre>
<p>戦略的には、メソッド呼び出し、つまりInvocationExpressionを拾いだして、そこからローカル変数代入/フィールド代入/return/LINQクエリ構文/メソッド呼び出しで使われていなければダメ扱いにする、という流れ。コード自体は行数も少なくて難しくはないのですけれど、戦略を決定するまでは割と悩みました。SyntaxTree自体も大量のメソッドがあり、SemanticModelも絡めると、色々な手段が取れそうでいて取れなさそうで、相当悩ましい。最終的にはかなり単純な手法に落ち着きましたが、直線距離で到達できるようになるまでには、かなり慣れが必要そうです。あと、最初作った時はクエリ構文のチェックを見落としてたりとか（さすがにこれを最初から気づくのは無理）、必要なケースを全て洗い出すのはそこそこ大変かな、といった感はあります。</p>
<p>DescendantNodesのdescendIntoChildrenという引数が中々面白くて、これは子孫ノードの探索を打ち切る条件を指定できます。これの何がいいって、例えばメソッド Observable.Range().Where().Select() があった場合、最上位のInvocationExpressionはObservable.Range().Where().Select()なのですが、その子孫に Observable.Range().Where() や Observable.Range() がいます。ふつーのDescendantNodesだとそれら全部を列挙してしまうんですが、今回は欲しいのは最上位だけなので、descendIntoChildrenで条件フィルタを足しています。</p>
<p>以前には紹介していない、ユニットテストのやり方も紹介しましょう。といっても、テンプレートに最初からTestプロジェクトと、便利クラス群が同梱されています。Analyzerだけの場合は基底クラスをDiagnosticVerifierに変えて……</p>
<pre><code class="language-csharp">namespace UniRxAnalyzer.Test
{
    [TestClass]
    public class HandleObservableAnalyzerTest : DiagnosticVerifier
    {
        protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()
        {
            return new UniRxAnalyzer.HandleObservableAnalyzer();
        }

        [TestMethod]
        public void UnHandle()
        {
            var source = @&quot;
using System;
   
class Test
{
    IObservable&lt;int&gt; GetObservable() =&gt; null;

    void Hoge()
    {
        GetObservable();
    }
}&quot;;
            var expected = new DiagnosticResult
            {
                Id = UniRxAnalyzer.HandleObservableAnalyzer.DiagnosticId,
                Message = &quot;This call does not handle IObservable&lt;T&gt;.&quot;,
                Severity = DiagnosticSeverity.Warning,
                Locations = new[]
                {
                    new DiagnosticResultLocation(&quot;Test0.cs&quot;, 10, 9)
                }
            };

            this.VerifyCSharpDiagnostic(source, expected);
        }
    }
}
</code></pre>
<p>ようするにVerifyCSharpDiagnosticにテスト用のC#コードと、期待するDiagnosticResultを渡すだけです、実に簡単。もしエラーじゃなくOKの場合はsourceだけをVerifyCSharpDiagnosticに渡せば、そういうことになります。</p>
<h2>まとめ</h2>
<p>Analyzer、かなりイイです。実際。とにかくとりあえず触ってみませう。現状リファレンスとかは特にないですが、まぁLINQ to XML辺りがわかっていればSyntaxVisualizerとIntelliSenseを頼りになんとか作り上げられるでしょう！メソッド名を見ながらカンを働かせましょう。大丈夫大丈夫。また、GitHubには既にお手本となるAnalyzerが出回っているので、それを参照にすればかなりいけます。代表的なところでは<a href="http://nr6pack.net/">NR6Pack</a>, <a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers">StyleCopAnalyzers</a>, <a href="https://github.com/code-cracker/code-cracker">Code Cracker</a>などがあります。</p>
<p>では、よきRoslynライフを！</p>
</div>
<h1><a href="https://neue.cc/2015/04/19_511.html">LightNode 1.2.0 - Swagger統合によるAPIのデバッグ実行</a></h1>
<ul class="date"><li>2015-04-19</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2015/03/25_508.html">グラニのC#フレームワークの過去と未来、現代的なASP.NETライブラリの選び方</a>という記事で、スライドと補足は先に上げましたが、以前に弊社で行った勉強会「Build Insider MEETUP with Grani 第1回」のレポートがBuild Insiderに上がっています。<a href="http://www.buildinsider.net/enterprise/granireport/0101">「using CSharp;」な企業を支える技術方針とベスト.NETライブラリ</a>記事によるレポートは、さくさく読めるし、スライドで欠けていた部分も補完できていーんじゃないでしょーか。まる。</p>
<p>さて、で、基本的にAPIサーバーはOWINで行くんですが、API開発はとにかくふつーのウェブよりも開発がしにくい！の欠点を、前回<a href="http://neue.cc/2015/02/16_505.html">LightNode 1.0、或いはWeb APIでのGlimpseの使い方</a>はGlimpseフル統合で補おうとしました。それはそれでいいんですが、もう一つ足りない。それはともかく根本的にそもそも実行しづらい。さすがにモバイルのエミュレーターなりUnityのEditorなりから毎度実行は効率悪すぎてありえないし、<a href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm">POSTMAN</a>や<a href="http://www.telerik.com/fiddler">Fiddler</a>で叩くのも面倒くせえ。</p>
<p>そこで<a href="http://swagger.io/">Swagger</a>。とはなにか、というのは見てもらえれば。</p>
<p class="noindent">
<img src="https://raw.githubusercontent.com/neuecc/LightNode/master/Img/swagger_support.jpg" width="640" />
</p>
<p>実行機付きのAPIのヘルプ・ドキュメントです。ヘルプ/ドキュメントはどうでもいいんですが、この実行機がかなり使いやすくいい！パラメータ入力してTry it out!でOK。認証が必要な場合も、右上にapi_keyというのが見えてますが、ちょっとindex.htmlを書き換えてこのapi_keyの部分を好きに都合のいい形態に変えてしまえば、機能します。実に便利。</p>
<p>SwaggerはAzureのAPI Appsでも利用されるようになったので、今後.NETでも目にする機会はちょっとずつ増えていくのではないでしょうか？ASP.NET Web APIで利用する方法はみそせんせーの<a href="http://miso-soup3.hateblo.jp/entry/2014/12/17/233409">Swagger を使った ASP.NET Web API のドキュメント生成</a>を参照すれば良いでしょふ。</p>
<p>さて、<a href="https://github.com/neuecc/LightNode">LightNode</a>(ってここではじめて解説しますが、私の作っているOwin上で動くMicro REST/RPCフレームワークです)では、Swagger統合はMiddlewareとして実装してあります。</p>
<ul>
<li>PM&gt; Install-Package <a href="https://www.nuget.org/packages/LightNode.Swagger/">LightNode.Swagger</a></li>
</ul>
<p>ルートをapiと別系統にswaggerとして切ってもらって、</p>
<pre><code class="language-csharp">// 今のところPOSTしかサポートしてないのでPostを有効にしてね
app.Map(&quot;/api&quot;, builder =&gt;
{
    builder.UseLightNode(new LightNodeOptions(AcceptVerbs.Get | AcceptVerbs.Post, new JilContentFormatter(), new GZipJilContentFormatter())
    {
        ParameterEnumAllowsFieldNameParse = true, // Enumを文字列で並べたいならこれをONにして
        // 下2つはSwagger前提で使うならエラー表示的に便利
        ErrorHandlingPolicy = ErrorHandlingPolicy.ReturnInternalServerErrorIncludeErrorDetails,
        OperationMissingHandlingPolicy = OperationMissingHandlingPolicy.ReturnErrorStatusCodeIncludeErrorDetails
    });
});

// こっちでSwaggerを有効にする
app.Map(&quot;/swagger&quot;, builder =&gt;
{
    // XMLコメントから引っ張ってくるばあい（オプション）はパスを指定してください
    // メソッドに付与されているsummary, remarks, paramを情報として使います     
    var xmlName = &quot;LightNode.Sample.GlimpseUse.xml&quot;;
    var xmlPath = System.AppDomain.CurrentDomain.BaseDirectory + &quot;\\bin\\&quot; + xmlName; // もしくは HttpContext.Current.Server.MapPath(&quot;~/bin/&quot; + xmlName);

    // LightNode側のAPIのbasePathを指定
    builder.UseLightNodeSwagger(new Swagger.SwaggerOptions(&quot;LightNodeSample&quot;, &quot;/api&quot;)
    {
        XmlDocumentPath = xmlPath,
        IsEmitEnumAsString = true // Enumを文字列で並べたいならtrueに
    });
});
</code></pre>
<p>といった感じです。ちょっとややこしーですが、基本的にはUseLightNodeSwaggerだけでOK、ということで。これで、例えば http://localhost:41932/Swagger/ にアクセスすればSwaggerの画面が出てきます。Swagger-UI自体はdllに埋め込まれています。また、定義ファイル(JSON)はapi-default.jsonにアクセスすることで、直接取得できます。</p>
<p>もしOwinをIISでホストしている場合、IISのStaticFileハンドラーが邪魔してうまくホストできない場合があります。その場合、StaticFileハンドラーを殺してください。Owinでやる場合は、とにかくOwinに寄せたほうがいいですね（StaticFile系はMicrosoft.Owin.StaticFiles使いましょう）</p>
<pre><code class="language-xml">&lt;system.webServer&gt;
    &lt;handlers&gt;
        &lt;remove name=&quot;StaticFile&quot; /&gt;
        &lt;!-- もしGlimpseもホストする場合はGlimpseのを先に書いといて --&gt;
        &lt;add name=&quot;Glimpse&quot; path=&quot;glimpse.axd&quot; verb=&quot;GET&quot; type=&quot;Glimpse.AspNet.HttpHandler, Glimpse.AspNet&quot; preCondition=&quot;integratedMode&quot; /&gt;
        &lt;add name=&quot;OWIN&quot; path=&quot;*&quot; verb=&quot;*&quot; type=&quot;Microsoft.Owin.Host.SystemWeb.OwinHttpHandler&quot; /&gt;
    &lt;/handlers&gt;
&lt;/system.webServer&gt;
</code></pre>
<p>もし、例えば最初に例に出しましたが、認証情報を付与するとかでindex.htmlを埋め込みのではなくカスタムのを使いたい場合、OptionのResolveCustomResourceをハンドリングすればできます。例えばこんな感じに、別の埋め込みリソースから取り出したものに差し替えたり。</p>
<pre><code class="language-csharp">app.Map(&quot;/swagger&quot;, builder =&gt;
{
    builder.UseLightNodeSwagger(new LightNode.Swagger.SwaggerOptions(&quot;MySample&quot;, &quot;/api&quot;)
    {
        ResolveCustomResource = (filePath, loadedEmbeddedBytes) =&gt;
        {
            if (filePath == &quot;index.html&quot;)
            {
                using (var resourceStream = typeof(Startup).Assembly.GetManifestResourceStream(&quot;MySample.Swagger.index.html&quot;))
                using (var ms = new MemoryStream())
                {
                    resourceStream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return loadedEmbeddedBytes;
        }
    });
});
</code></pre>
<p>当然、index以外でもハンドリングできます。</p>
<h2>まとめ</h2>
<p>GlimpseとSwaggerがあわさって最強に見える！あとはもともとあるクライアント自動生成もあるので、三種の神器コンプリート。実際、これでAPI開発の苦痛に思えるところがかなり取り除かれたのではないかなー、って思ってます。これを全部自分で用意するのはそれはそれは大変なので、Owinで良かったし、組み合わせに関しても、.NETでOSSを使うってこういうことですよね？という例になればよいかな。</p>
</div>
<h1><a href="https://neue.cc/2015/04/13_510.html">UniRx 4.8 - 軽量イベントフックとuGUI連携によるデータバインディング</a></h1>
<ul class="date"><li>2015-04-13</li></ul>
<div class="entry_body"><p><a href="https://github.com/neuecc/UniRx">UniRx(Reactive Extensions for Unity)</a>のVer 4.8が昨日、AssetStoreにリリースされました。UniRxとはなにか、というと、巷で流行りのReactive Programming、の.NET実装のReactive Extensions、のUnity実装で、私が去年ぐらいからチマチマと作っています。実際のところ細かいリリースは何度も行っているんで（差分は<a href="https://github.com/neuecc/UniRx/releases">GitHubのReleases</a>に書いてあります)、開発/アップデートはかなりアクティブな状態でした。その間に、Google PlayやiOSのAppStoreでもチラホラと使用しているタイトルがあったりと（ありがとうございます！！！）、案外存外しっかりRealWorldしていました。GitHubのStarも順調に伸びていて、まぁまぁメジャーになってきた気はします。</p>
<p>その間に、いくつか素晴らしいプレゼン資料も作っていただきました！<a href="https://twitter.com/torisoup">@torisoup</a>さんの<a href="http://www.slideshare.net/torisoup/unity-unirx">未来のプログラミング技術をUnityで -UniRx-</a>は、分かりやすく魅力を感じさせてくれる内容になっていて、とても素晴らしいです。読むべし読むべし。<a href="http://qiita.com/toRisouP">toRisouPさんはQiita</a>でも多くの記事を書いてくださっていて、（私がｇｄｇｄ書くよりも）はるかに分かりやすくていいですね！</p>
<p>また、<a href="https://twitter.com/Grabacr07">@Grabacr07</a>さんの<a href="https://speakerdeck.com/grabacr07/unirx-toka-reactive-property-toka">UniRx とか ReactiveProperty とか</a>は、今回紹介するuGUI連携についての話が、分かりやすく綺麗に紹介されているので、こちらも必読です。必読。</p>
<p>UniRxの最初の発表は2014/04/19の<a href="http://www.slideshare.net/neuecc/unityrx-reactive-extensions-for-unity">UniRx - Reactive Extensions for Unity</a>というところで、発端は非同期処理の解消、という一面からスタートしていたのですが、すぐにUnityの発する色々なイベント処理をRxで行おうという、本来の、でありつつも応用的なところが盛んに試されるようになったのは素晴らしいことだなぁ、と思っています。これはゲームプログラミングの持つ複雑さが、Reactive Programmingの使い道を無数に産むという、相性の良さがあるのかしらん。非同期だけじゃない、データバインドだけじゃないRealなReactive Programmingがここにあり、プログラミングを、C#の可能性を、パラダイムシフトを大いに楽しめる環境です。是非楽しんでください。もちろん、実用性もありますしね！</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx">GitHub - UniRx</a></li>
<li><a href="http://u3d.as/7tT">UnityAssetStore - UniRx</a></li>
</ul>
<p>当然（？）フリーです。</p>
<h2>ObservableTriggers</h2>
<p>UniRx 4.8から、MonoBehaviourのイベントハンドリング手法をObservableTriggersという概念に全面移行しました。どういうことかというと、まず、ObservableMonoBehaviourは廃止です:) Obsoleteはつけていないし、動作はしますが、非推奨になりました。その代わりとなるのがObservableTriggersです。まず利用例を。</p>
<pre><code class="language-csharp">using UniRx;
using UniRx.Triggers; // この名前空間以下にTriggerは入ってるのでusingしときましょう

public class MyComponent : MonoBehaviour
{
    void Start()
    {
        // AddComponentでTriggerを付与する
        var trigger = this.gameObject.AddComponent&lt;ObservableUpdateTrigger&gt;();

        // すると*Event*AsObservableが使えるようになる
        trigger.UpdateAsObservable()
            .SampleFrame(30)
            .Subscribe(x =&gt; Debug.Log(x), () =&gt; Debug.Log(&quot;destroy&quot;));

        // 3秒後に自殺:)
        GameObject.Destroy(this, 3f);
    }
}
</code></pre>
<p>Triggerは対象GameObjectがDestroyされると、OnCompletedを流してイベント発火を終了します。</p>
<p>ObservableMonoBehaviourを継承するのではなく、AddComponentで必要なイベントのためのTriggerを与えてください。そうすれば、そのイベントがRxで取り扱えるようになります。標準では ObservableAnimatorTrigger, ObservableCollision2DTrigger, ObservableCollisionTrigger, ObservableDestroyTrigger, ObservableEnableTrigger, ObservableFixedUpdateTrigger, ObservableUpdateTrigger, ObservableLastUpdateTrigger, ObservableMouseTrigger, ObservableTrigger2DTrigger, ObservableTriggerTrigger, ObservableVisibleTrigger, ObservableTransformChangedTrigger, ObservableRectTransformTrigger, ObservableCanvasGroupChangedTrigger, ObservableStateMachineTrigger, ObservableEventTrigger を用意してあります。「ほぼ」全部です。4.6から追加された新しいイベント(OnTransformChildrenChangedとか)も網羅しています。（とはいえ全部ではないので、足りなくて必要なものがあったら自分で追加するか、私にリクエストください、単純にあまり需要なさそうだと勝手に判断したものはオミットしちゃっているので……）</p>
<p>また、AddComponentが面倒くさい！ので、GameObject/Componentに対して、UniRx.Triggersをusingしている場合は、XxxAsObservableメソッドを直接拡張メソッドから呼べて、するとTriggerが自動付与されるようになっています。</p>
<pre><code class="language-csharp">using UniRx;
using UniRx.Triggers; // 必ずこのusingが必要です

public class DragAndDropOnce : MonoBehaviour
{
    void Start()
    {
        // OnMouseDownAsObservableが生えてる
        this.OnMouseDownAsObservable()
            .SelectMany(_ =&gt; this.UpdateAsObservable()) // UpdateAsObservableが生えてる
            .TakeUntil(this.OnMouseUpAsObservable()) // OnMouseUpAsObservableが生えてる
            .Select(_ =&gt; Input.mousePosition)
            .Subscribe(x =&gt; Debug.Log(x));
    }
}
</code></pre>
<p>なので、通常使う場合は、Triggerに関しては意識する必要はありません。(ObservableEventTrigger(uGUI用)とObservableStateMachineTrigger(Animation用)だけは自動付与がないので、これらの場合だけ自分で意識的に付与する必要があります)</p>
<p>ObservableMonoBehaviourは継承が必要だったり（基底クラスが強制される！）、baseメソッドの呼び出しが必須だったり、空イベントの呼び出しが必ず含まれるパフォーマンス低下などなど、決して使い勝手の良いものではありませんでした。というか使い勝手は最悪でした。なんで当初からObservableTriggerのようなやり方じゃなかったか、というと……、まぁ、単純に私のUnityへの理解不足です、すびばせん。ObservableTriggerは、Unityのコンポーネント指向を活かしつつ、Rxによってイベントを自然に外側で取り出せるようになっているので、圧倒的に便利な形になったのではないかなと思います。</p>
<h2>uGUI</h2>
<p>uGUIのイベントがUniRxでパーフェクトにハンドリングできます！この辺の話は前述のスライド<a href="https://speakerdeck.com/grabacr07/unirx-toka-reactive-property-toka">UniRx とか ReactiveProperty とか</a>に綺麗にまとまっているのですが、例えばボタンとかが</p>
<pre><code class="language-csharp">// インスペクタから貼っつけるとか
public Button MyButton;

// こんな感じで取る(onClick.AsObservable もしくは OnClickAsObservable)
MyButton.onClick.AsObservable().Subscribe(_ =&gt; Debug.Log(&quot;clicked&quot;));
</code></pre>
<p>ほぅ……。普通だ。どうでも良さそうだ。と、いう具合にuGUIのEvent + AsObservableでイベントハンドリングができるようになっています。もう少し例を出すと</p>
<pre><code class="language-csharp">// ビューからのコントロールはインスペクタでペタペタ貼り付ける
public Toggle MyToggle;
public InputField MyInput;
public Text MyText;
public Slider MySlider;

// Startとかで宣言的にUIを記述していきましょう
void Start()
{
    // チェックボックスのオン/オフでボタンの有効/非有効が切り替わるようにします
    // OnValueChangedAsObservableは.onValueChanged.AsObservableのヘルパーで、単純に省略が楽という他に、
    // 初期値(最初のisOnの値)がSubscribe時に流れていきます
    // また、SubscribeToInteractableはUniRxのヘルパーで、 x =&gt; .interactable = x を省略できます
    MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);

    // 入力文字は1秒後にテキストラベルに反映されます
    MyInput.OnValueChangeAsObservable()
        .Where(x =&gt; x != null)
        .Delay(TimeSpan.FromSeconds(1))
        .SubscribeToText(MyText); // SubscribeToTextを使うと簡単に紐付けできます

    // SubscribeToTextの人間の読める形に変換したい場合用ヘルパ
    MySlider.OnValueChangedAsObservable()
        .SubscribeToText(MyText, x =&gt; Math.Round(x, 2).ToString());
}
</code></pre>
<p>こんな風になります。uGUIの標準コントロールに関しては直接EventAsObservableできるように拡張されてます。ともあれ、uGUIのイベントハンドリングはスクリプトで行いましょう。uGUI標準のAddHandlerなどはやりづらいですが、UniRxはそれを簡単に行える仕組みが用意してあります。uGUIのチュートリアルや解説本では、インスペクタのイベントの部分をクリックしてメソッドと紐付けてー、などとやるかもしれませんが、あのやり方は最低最悪なので忘れましょう。スクリプトレスでイベント設定できるとか幻想なんで、少なくともRxを使おうとしているようなプログラマなら、一切見なかったことにしましょう。100億パーセントどうでもいい次元の話なので無視しておきましょう。やりづらいだけです。</p>
<p>unityEvent.AsObservableのかわりに、全てのUnityコントロールにはUnityEventAsObservableが定義されています。ButtonのonClickの場合は違いはないのですが、一部の値が流れるものに関しては違いがあって、コントロールに直接生えているものは初期値が流れるようになっています。この初期値が流れる、という性質は非常に重要です。と、いうのも、今回のようにUIを宣言的に記述した場合、初期値が流れないと、初期値を設定して回らなければならなくて全体の構築が狂ってしまうからです。と、いうわけで、基本的にはコントロールに生えているAsObservableを使いましょう。</p>
<h2>ReactiveProperty</h2>
<p>UniRx 4.8からReactivePropertyという特別な型が用意されています（あとReactiveCollectionとReactiveDictionary）。これは何かというと、通知可能なプロパティ。なんのこっちゃ。うーん、イベントと値がセットになった型。うーん、なんのこっちゃ……。</p>
<pre><code class="language-csharp">// 変更通知付きなモデル
public class Enemy
{
    // HPは変更あったら通知して他のところでなんか変化を起こすよね？
    public ReactiveProperty&lt;long&gt; CurrentHp { get; private set; }

    // 死んだら通知起こすよね？
    public ReadOnlyReactiveProperty&lt;bool&gt; IsDead { get; private set; }

    public Enemy(int initialHp)
    {
        // 宣言的に記述していく。
        // ReactivePropertyはそれ自体がIObservable&lt;T&gt;なので、Rxでチェーン可能で、更にそれをReactivePropertyに変換も可能
        // 死んだかどうかというのはHPが0以下になったら、で表現できる         
        CurrentHp = new ReactiveProperty&lt;long&gt;(initialHp);
        IsDead = CurrentHp.Select(x =&gt; x &lt;= 0).ToReadOnlyReactiveProperty();
    }
}

// こんなふうにして使う
// ボタンクリックしたらHPが99減ってくとする（実際はなんかCollision受けたら減るとか色々）
// ReactivePropertyの値は.Valueで取り出せる)
MyButton.OnClickAsObservable().Subscribe(_ =&gt; enemy.CurrentHp.Value -= 99);

// その変更を受けてUIに変更を戻す
enemy.CurrentHp.SubscribeToText(MyText); // とりあえず現在HPをTextに表示

// もし死んだらボタンクリックできないようにする
enemy.IsDead.Select(isDead =&gt; !isDead).SubscribeToInteractable(MyButton);
</code></pre>
<p>今まではイベント＋普通の値で表現していたものが、プロパティ一個で表現できるようになります。また、イベント自体の取り扱いもRxなので合成可能になっていて、取り回しが向上します。というわけで、めちゃくちゃ便利。実際便利。通知が必要な値は片っ端からReactivePropertyにしましょう、それで幸せになれます！</p>
<p>更にReactivePropertyはInspectorで利便性が向上しています。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/RxPropInspector.png" alt="" /></p>
<p>IntRxPropのところ、インスペクタに値を表示しているのですが、これの値をインスペクタで変更すると、紐付けていたイベント(.Subscribeしているもの)への通知も飛んでいきます。地味に捗る神機能。注意点としては、ジェネリックの型はインスペクタに表示できないという制限を引き継いでいるので、インスペクタに表示したいReactiveProeprtyは、専用のReactivePropertyを使いましょう。例えばIntReactivePropertyやBoolReactiveProperty、Vector2ReactivePropertyなどが標準では用意されています。EnumをReactiveProeprtyとして表示したい、というシチュエーションも多いと思います。その場合はSpecializedなReactivePropertyを定義していきましょう。例えば</p>
<pre><code class="language-csharp">// こんなEnumがあるとして
public enum Fruit
{
    Apple, Grape
}

// こういう特化したReactiveProeprtyを作ればOK
[Serializable]
public class FruitReactiveProperty : ReactiveProperty&lt;Fruit&gt;
{
    public FruitReactiveProperty()
    {
    }

    public FruitReactiveProperty(Fruit initialValue)
        :base(initialValue)
    {
    }
}

// また、InspectorDisplayDrawerにたいしてCustomPropertyDrawerを指定するとインスペクタでの表示が向上/イベント通知が可能になるので
// 特化ReactiveProeprtyの作成とワンセットで行いましょう
// ExtendInspectorDisplayDrawer自体は一個あればそれで大丈夫です
[UnityEditor.CustomPropertyDrawer(typeof(FruitReactiveProperty))]
[UnityEditor.CustomPropertyDrawer(typeof(YourSpecializedReactiveProperty2))] // 他、沢山ここにtypeofを追加していく
public class ExtendInspectorDisplayDrawer : InspectorDisplayDrawer
{
}
</code></pre>
<p>といった感じに拡張することで、より便利になっていきます。</p>
<h2>MV(R)P</h2>
<p>これらのUIの作り方を指して、Model-View-(Reactive)Presenterパターンというものを提唱します。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVP_Pattern.png" alt="" /></p>
<p>なぜMVPか、なんでMVVMではないか。まず、Unityはバインディングエンジンを持っていません。一般的にMVVMはViewとViewModelの間をバインディングエンジンが受け持ちます。なので、素の状態ではそもそもMVVMはできません。じゃあバインディングエンジンを作るか、となると、そんなレイヤーを挟むのは複雑になるしパフォーマンスも低下するし、デメリットがメリットを上回るバインディングエンジンを作るのは難しい。バインディングは誰かが動的レイヤーを引き受けなければならなくて（例えばName直書きなINotifyPropertyChangedであったり)、ピュアC#の世界とは相性が悪い。それをWPFではXAMLに押し付けているが、動的コード生成高速化の手段が取れないUnityでは、無理して実現する価値はない。</p>
<p>そんなわけで、MVVMはやらない。やらないとなると、バインディング機構が存在しない都合上、どこかで、だれかが、Vを知る必要がある(じゃなきゃViewのUpdateがかけれない)。というわけでVMは存在できず、Presenterを立てる。Model自体はPresenterにも依存しないし、Viewは知らない。ただしViewまで伝搬するため通知は可能でなければならない。それらをRxが繋ぎます。従来のMVPはステートの複雑化や伝搬に困難があったが、Observableはバインディングのようにシンプルに通知を行うことができるし、Viewへの適用もバインディングであるかのように綺麗に見せることができる。Rxを介すことによって、アプリケーションを作る上での問題が解消する。しかもレイヤー的にはないに等しく薄いので、一切のデメリットはない。</p>
<p>再度、コードと当てはめてみましょう。</p>
<pre><code class="language-csharp">// Presenter(Canvasのルートだったり、Prefabやパーツ分割単位のルート)
public class ReactivePresenter : MonoBehaviour
{
    // PresenterはViewのコンポーネントを知っている（さわれる）
    public Button MyButton;
    public Toggle MyToggle;
    
    // ModelからのState-Change-EventsはReactivePropertyによって伝搬される
    // Modelの変更は基本的に自身が上層に通知可能であり、それはReactiveProeprtyで表現される
    Enemy enemy = new Enemy(1000);

    void Start()
    {
        // Viewからのuser eventsはRxによって伝搬され、Modelにまでリアクティブに浸透していく
        MyButton.OnClickAsObservable().Subscribe(_ =&gt; enemy.CurrentHp.Value -= 99);
        MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);

        // Modelからの伝搬もまた、Presenterを介してRxによってViewのUpdateをかける
        enemy.CurrentHp.SubscribeToText(MyText);
        enemy.IsDead.Where(isDead =&gt; isDead == true)
            .Subscribe(_ =&gt;
            {
                MyToggle.interactable = MyButton.interactable = false;
            });
    }
}
</code></pre>
<p>この場合、ViewとPresenterの紐付けはUnityのインスペクタでやります、ぴっ、ぴっ、ぴっってドラッグアンドドロップですねん。ふつーの（？）MVPだと、このViewをIViewとしてモックと差し替え可能にしたりもしたりしなかったりですが、そこまでやってもメリットゼロなんでそんなことはやらないでダイレクトにViewの実体とひもづける形でOK。</p>
<p><img src="https://raw.githubusercontent.com/neuecc/UniRx/master/StoreDocument/MVRP_Loop.png" alt="" /></p>
<p>それぞれの伝搬ポイントにUniRxのメソッドやクラスが用意されているので、全てをシームレスに、Reactiveにつなぎ合わせることが可能です。UniRxならね。これの何が嬉しいかというと、見通しが良く、コード量が減ります。それがもう単純に嬉しい。また、イベントの関連付けはスクリプト側に寄っているので、インスペクタがカオティックにならずに済みます。かなりUnity(+Rx)の現実に沿った作り方なのではないかなー、と思うのですがどうでしょう？この辺は意見大募集中といったところです。</p>
<h2>カスタムトリガーを作ろう</h2>
<p>そんな風にアプリケーションを作っていくと、イベントはRx的に発動させるのが都合が良い、ということがわかってきます。実際そう。で、SubjectやReactivePropertyなどを駆使することによりModelをRx的に作っていくのは可能なのですが、ViewからのイベントをRx的に流すためにはどうすればいいのか。標準ではTriggerが用意されてますが、それだけじゃ足りない、例えばロングタップ作りたいとかジェスチャー作りたいとか……。という場合はTriggerを自作します。作り方は、ObservableTriggerBaseを継承して……</p>
<pre><code class="language-csharp">public class ObservableLongPointerDownTrigger : ObservableTriggerBase, IPointerDownHandler, IPointerUpHandler
{
    public float IntervalSecond = 1f;

    Subject&lt;Unit&gt; onLongPointerDown;

    float? raiseTime;

    void Update()
    {
        if (raiseTime != null &amp;&amp; raiseTime &lt;= Time.realtimeSinceStartup)
        {
            if (onLongPointerDown != null) onLongPointerDown.OnNext(Unit.Default);
            raiseTime = null;
        }
    }

    void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
    {
        raiseTime = Time.realtimeSinceStartup + IntervalSecond;
    }

    void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
    {
        raiseTime = null;
    }

    public IObservable&lt;Unit&gt; OnLongPointerDownAsObservable()
    {
        return onLongPointerDown ?? (onLongPointerDown = new Subject&lt;Unit&gt;());
    }

    protected override void RaiseOnCompletedOnDestroy()
    {
        if (onLongPointerDown != null)
        {
            onLongPointerDown.OnCompleted();
        }
    }
}
</code></pre>
<p>こんな感じ、これで他のTriggerと同じノリ、OnPointerDownAsObservableでタップを拾えるように、OnLongPointerDownAsObservableでロングタップを拾えるようになります。Subjectでイベント通知することと、RaiseOnCompletedOnDestroyのところでOnCompletedを発行するのが原則です。こういう形でイベントを拡張すると、よりスムーズにRxで全てが繋がっていきます！</p>
<h2>ライフサイクル管理</h2>
<p>で、全部がRxになると、イベントをSubscribeしたのをどこで解除すればいーんですかー、って話になってきたりこなかったりする。基本的にTrigger系は自身が死んだ時に終了するからいいんですが、それ意外のもの、例えばObservable.TimerやObservable.EveryUpdateは自動的に止まらないので、自分で登録解除する必要があります。そのためのヘルパーとして、IDisposable.AddToがUniRxには用意されています。また、CompositeDisposableがSubscriptionの管理に使えます。</p>
<pre><code class="language-csharp">// CompositeDisposableはList&lt;IDisposable&gt;のようなもので、複数のIDisposableが管理できます
CompositeDisposable disposables = new CompositeDisposable(); // これをfieldにおいておいて

void Start()
{
    Observable.EveryUpdate().Subscribe(x =&gt; Debug.Log(x)).AddTo(disposables); // AddToで詰める
}

void OnTriggerEnter(Collider other)
{
    // .Clear() =&gt; 中の全てのdisposableのDisposeが呼ばれて、Listが空になります
    // .Dispose() =&gt; 中の全てのdisposableのDisposeが呼ばれて、以降はAddされたら即対象をDisposeするようになります
    disposables.Clear();
}
</code></pre>
<p>よくあるシチュエーションとして、Destroyした瞬間に解除したい、というのがあると思います。その場合AddTo(gameObject/component)が使えます。</p>
<pre><code class="language-csharp">void Start()
{
    // 自分が消滅したらDispose
    Observable.IntervalFrame(30).Subscribe(x =&gt; Debug.Log(x)).AddTo(this);
}
</code></pre>
<p>DisposeじゃなくてOnCompletedを出して欲しい、という場合にはTakeWhile, TakeUntil, TakeUntilDestroy, TakeUntilDisable辺りが使えます。</p>
<pre><code class="language-csharp">Observable.IntervalFrame(30).TakeUntilDisable(this)
    .Subscribe(x =&gt; Debug.Log(x), () =&gt; Debug.Log(&quot;completed!&quot;));
</code></pre>
<p>イベントを「繰り返す」場合に、Repeatが通常使われますが、実は危険です。源流がOnCompletedを発行すると無限ループ化するからです。ObservableTriggersが終了するとOnCompletedを発行するため、安易なRepeatの使用は無限ループ行きとなります。それを避けるには、RepeatUntilDestroy(gameObject/component), RepeatUntilDisable(gameObject/component), RepeatSafeが使えます。RepeatUntilDestroyとかは文字通りなんですが、RepeatSafeは連続してOnCompltedが発行された場合はRepeatを取りやめるという、無限ループ禁止機構のついたRepeatです。ベンリ。</p>
<p>最後に、ObserveEveryValueChangedを紹介します。これは、ラムダ式で指定した値を変更のあった時にだけ通知するという、つまり変更通知のない値を変更通知付きに変換するという魔法のような（実際ベンリ！）機能です（実際は毎フレーム監視してるんで、ポーリングによる擬似的なPull→Push変換）</p>
<pre><code class="language-csharp">// watch position change
this.transform.ObserveEveryValueChanged(x =&gt; x.position).Subscribe(x =&gt; Debug.Log(x));
</code></pre>
<p>これは監視対象がGameObjectの場合はDestroy時にOnCompletedを発行して監視を止めます。通常のC#クラス（POCO）の場合は、GCされた時に、同様にOnCompletedを発行して監視を止めるようになっています（内部的にはWeakReferenceを用いて実装されています）。ただのポーリングなので多用すぎるとアレですが、お手軽でベンリには違いないので適宜どうぞ。</p>
<h2>パフォーマンス</h2>
<p>パフォーマンスの話は一口で言うには結構難しいところです。まずいうと、RxとLINQを関連付けてLINQだからパフォーマンスがー、というのは微妙にあてはまりません。RxはPush型、最初のタイミングでパイプラインを構築し、それを（大抵の場合）かなり長い期間（最長でObjectが消滅するまで）購読する形になります。つまり、ライフサイクルが非常に長い。だから、パイプライン構築のためのオブジェクト（のGC）のコストというのは、そんなでもないと思ってもらっていいでしょふ。Updateの度に頻繁に数千構築/解体を繰り返すようなものではない、ということですねん。パイプラインに流れる値に関しては、その頻度と書きよう次第ですけれど。また、Rxのメソッドも軽いメソッドと重いメソッドがあるので、それ次第という面もあります。とはいえそこまで気にするほどではないかなー、と。</p>
<p>全体的にRxを適用すると、アプリケーションはPushベースで構築されることになるので、頻繁な問い合わせ処理(Pullベース)が消え、つまり更新駆動の最小限の差分処理だけが走るので、逆にパフォーマンスは上がる、という見方もできなくもないですが、まぁさすがにそれは都合の良すぎる捉え方でしょう:) ともあれ、そういったアプリケーション構築手法の変革もあるので、そこのところも含めて評価しなければなりません。</p>
<p>単純なコルーチンの代替、非同期通信処理の代替レベルでなら、実質ない、と言っても過言ではないところなので、それぐらいならばもうまるっきり気にせず、ですね。また、今まではObservableMonoBehaviourが不要な場合にも空イベントを回していて、それが若干の消費があったのですが、今回からは軽量なTriggerベースで必要なものにしかイベントを付与しないスタイルになったので、全体的にはかなり取り回しよくなってきたんじゃないかなー、と思います。</p>
<p>まだまだ全然パフォーマンスチューニングできる領域は沢山あるので、都度行っていくつもりです（分かりやすく効果の出るところでいえばWhere.Where.Whereチェーンは1個のWhereにできたり、かなり多用されるWhere.Selectチェーンも1個のWhereSelectチェーンにまとめあげられたり、などなど）</p>
<h2>LINQ to GameObject</h2>
<p>あと、これはUniRxとは関係ないのですがLINQ to GameObjectもアップデートしてます。</p>
<ul>
<li><a href="https://github.com/neuecc/LINQ-to-GameObject-for-Unity">GitHub - LINQ to GameObject</a></li>
<li><a href="http://u3d.as/content/neuecc/linq-to-game-object">UnityAssetStore - LINQ to GameObject</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/neuecc/LINQ-to-GameObject-for-Unity/master/Images/axis.jpg" alt="" /></p>
<p>メインはLINQ風メソッドでtransformを自在に辿れるってところで、それは<a href="http://neue.cc/2014/11/11_482.html">LINQ to GameObjectによるUnityでのLINQの活用</a>を読んでいたたきたいのですが、もう一つの機能に、階層上の任意の位置にGameObjectをAddしたりMoveしたりするメソッドもあります。今回のアップデートで、これがuGUIのRectTransformに対応しました！uGUIはヒエラルキーの位置を表示情報としてかなり大事に扱うため、それのコントロールが容易になるLINQ to GameObjectは役立つはずです。</p>
<h2>まとめ</h2>
<p>今回のObservableTrigger、uGUI連携、そしてLifetime管理といった機能によって、より様々なところに導入しやすくなった、より使いやすくなったのではないでしょうか！</p>
<p>直近では4/16 18:30~の<a href="http://kbkz.connpass.com/event/12597/">歌舞伎座.tech#7「Reactive Extensions」</a>で「Observable Everywhere - UniRxによるUnityでのReactive Programming」と題して発表を行います。こちらはニコ生での放送もあるようなので、見るといいんじゃないかなー、ということで！</p>
</div>
<h1><a href="https://neue.cc/2015/04/02_509.html">Microsoft MVP for .NET(C#)を再々々々受賞しました</a></h1>
<ul class="date"><li>2015-04-02</li></ul>
<div class="entry_body"><p>今年も受賞で、5年目です。実は今年から受賞分野がC#が.NETに統合されたので、エキスパタイズとしてはfor .NETになります。</p>
<p>会社は第一段階が終わり、といった感じで、それに付随する活動内容としても総まとめみたいなものが多かったかな、といったところでしょうか。今年はまた次の段階の始まりということで、より新しい勝負が必要になってきています。今、私が主に力を入れているのはUnityと、そのReactive Extensions実装の<a href="https://github.com/neuecc/UniRx">UniRx</a>で、特にUniRxはかなりヒットさせられたとは思います。が、まだまだ兆しといったところなので、確固たるものにしなければならない。また、それを基盤にして、C#の強さというのを、ただの今までの.NETコミュニティにだけに留まらず、幅広い世界に届ける、伝えていきたいし、幸いにして私はそれが出来る立場にいると思っています。</p>
<p>より力強く、Real World C#というのを示し続けてきます。そんなわけで引き続き、今年もよろしくお願いします。</p>
</div>
<a href="https://neue.cc/2015/2">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2022<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
