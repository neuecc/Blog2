<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2011-09-10" data-pagefind-meta="published:2011-09-10"><a href="https://neue.cc/2011/09/10_342.html">Re:FromEvent vs FromEventPattern</a></h1>
<ul class="date"><li>2011-09-10</li></ul>
<div class="entry_body"><p>現在のRxで最大の分かりにくいポイントになっているFromEventとFromEventPattern。以前に<a href="http://neue.cc/2011/07/06_332.html" title="neue cc - Rxでのイベント変換まとめ - FromEvent vs FromEventPattern">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a>として軽くまとめましたが、改めて、詳細に考えてみたいと思います。なお、ここでいうFromEventPatternはWP7版のRxではFromEventを指しています（ここも分かりにくいポイントです）。そして、ここでいうFromEventはWP7版のRxには未搭載です、あらあらかしこ。</p>
<p>ネタ元ですが、<a href="http://techblog.hilife-jp.info/2011/09/silverlight-5-3-doubleclicktrigger-rx.html?spref=tw" title="銀の光と藍い空: Silverlight 5 の新機能その3 番外編 DoubleClickTrigger をRxっぽくしてみた">銀の光と藍い空: Silverlight 5 の新機能その3 番外編 DoubleClickTrigger をRxっぽくしてみた</a>を拝見して、FromEventに関して実行時に例外が出るとのことなので、その部分の説明を書こうかと。最初コメント欄に書いたのですが、少しコメントにトチってしまったので、自分のブログに書かせていただきます、どうもすみません……。</p>
<p>FromEventとFromEventPatternの最大の違いは、FromEventがAction&lt;EventArgs&gt;を対象にしていて、FromEventPatternはAction&lt;object, EventArgs&gt;を対象にしているということです。Action&lt;object, EventArgs&gt;は、つまりEventHandler。ではAction&lt;EventArgs&gt;って何なんだよ、というと、通常は存在しません。というのもeventはデリゲートなら何でもアリということに仕様上はなっていますが、慣例としてobject sender, EventArgs eを引数に持つデリゲートを選択しているはずですから。</p>
<p>さて、デリゲート間には同じ引数の型・同じ戻り値の型を持っていても、型自体に互換性がないので（例えばEventHandlerとEventHandler&lt;T&gt;）、FromEventもFromEventPatternも、引数を3つ持つオーバーロードの第一引数は
conversionという、デリゲートの型を変換するラムダ式を受け入れるようになっています。よって</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.FromEventPattern&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
    h =&gt; h.Invoke,
    h =&gt; AssociatedObject.MouseLeftButtonDown += h,
    h =&gt; AssociatedObject.MouseLeftButtonDown -= h);
</code></pre>
<p>これが、リフレクションなしで変換出来る形式になります。conversionが不要なオーバーロードもあるのですが(+=と-=を書くだけ)、それはリフレクションを使ってデリゲートの変換をしていて今一つ効率が悪いので、わざわざ+=, -=を書いているのだから、もう一手間かけて、 h =&gt; h.Invoke を書いておいたほうがお得です。（もし対象がEventHandler&lt;T&gt;の場合は事情が違ってconversionが不要なので+=と-=だけで済みます、この辺の事情の違いが面倒臭く混乱を招きがちなんですよね…… Rxチームには「便利そうだから」機能を追加する、とかやる前に、もう少し深く考えてくださいと苦情を言いたい）</p>
<p>h =&gt; h.Invoke だけで何故変換出来ているのかを詳しく説明します。これは正しく書くのならば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">(EventHandler&lt;MouseButtonEventArgs&gt; h) =&gt; new MouseButtonEventHandler(h)
</code></pre>
<p>が正解です。(左側の型に関しては省略可能ですが、説明用には型を書いていたほうが分かりやすいので明記しておきます、また、この最初からEventHandler&lt;T&gt;であることが、対象がEventHandler&lt;T&gt;である場合はconversionが不要な理由になっています）。ただし、関数を直接渡すとコンパイラがデリゲートの型を変換してくれるため、h =&gt; h.Invokeを渡した場合は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">h =&gt; new MouseButtonEventHandler(h.Invoke)
</code></pre>
<p>という風に内部的には自動で整形してくれます。そのため、new MouseButtonEventHandlerを書く手間が省けるということになっています。h と h.Invoke はやってることは完全一緒なのですけど、この辺はコンパイラの仕組みの都合に合わせるという感じで。むしろ仕組みの隙間をついたやり方といいましょうか。</p>
<p>では、FromEventなのですが、まず正しく変換出来る形を見ると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Observable.FromEvent&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
    h =&gt; (sender, e) =&gt; h(e),
    h =&gt; AssociatedObject.MouseLeftButtonDown += h,
    h =&gt; AssociatedObject.MouseLeftButtonDown -= h);
</code></pre>
<p>です。もし第一引数を省いた場合はAction&lt;EventArgs&gt;を探してリフレクションをかけるようになっていて、そして、通常はそんなイベントを使うことはないので、十中八九例外が出るのではかと思われます（だからこういう混乱を招くだけのオーバーロードを入れるなとRxチームには苦情を言いたい）。</p>
<p>型まで明記すれば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">Action&lt;MouseButtonEventArgs&gt; h =&gt; (object sender, MouseEventArgs e) =&gt; h(e)
</code></pre>
<p>となっているわけで、senderを捨ててMouseEventArgsだけを引数に渡す独自のconversionを渡しています。これですが、FromEventPatternであっても</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">h =&gt; (sender, e) =&gt; h(sender, e)
</code></pre>
<p>とも書けるので(つまるところ h.Invoke って何かといえば (sender, e) =&gt; h(sender,e) なのです)、それのsender抜きバージョンを渡しているということになります。</p>
<p>わかりづらい？例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">.Subscribe(Console.WriteLine)
.Subscribe(x =&gt; Console.WriteLine(x))
</code></pre>
<p>この二つはやってること一緒なんですよ、ということですね。ラムダ式が入れ子になるとワケガワカラナイ度が加速されるので、私は関数型言語erにはなれないな、と思ったり思わなかったり。</p>
<h2>まとめ</h2>
<p>ただたんに使うにあたっては、こんなことは知ってる必要はなくh =&gt; h.Invoke と h =&gt; (sender, e) =&gt; h(e) を定型句だと思って暗記してもらうだけで十分です。はい。本来は、こういう部分はちゃんと隠蔽されてたほうがいいんですけれど、まあ、C#の限界としてはそうはいかないというとこですね(F#だとイベントがもう少し扱いやすいんですが)。</p>
<p>また、FromEventにせよFromEventPatternにせよFromAsyncPatternにせよ、実際に使うコードに直接書いてくにはノイズが多すぎるので、<a href="http://neue.cc/2011/07/06_332.html" title="neue cc - Rxでのイベント変換まとめ - FromEvent vs FromEventPattern">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a>で書いたように、拡張メソッドに隔離するのを私はお薦めしています。そうこうして裏側で地道に努力することでF#とC#の壁を縮める！とかなんとかかんとか。</p>
</div>
<h1 data-pagefind-sort="date:2011-08-26" data-pagefind-meta="published:2011-08-26"><a href="https://neue.cc/2011/08/26_341.html">ReactiveProperty : Rx + MVVMへの試み</a></h1>
<ul class="date"><li>2011-08-26</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>といったら非同期、じゃなくて、その前にイベントですよ！イベント！というわけで、随分手薄になっていたイベント周りの話を増強したいこの頃です。イベントと一口に言っても色々あります。UI(クリックやマウスムーブ)、センサー、変更通知(INotifyPropertyChanged)などなど。中でも一番よく使うのは、UI周りのイベントでしょう。</p>
<p>しかし、UIの持つTextChangedイベントだのから直接FromEventPatternで変換してしまったら、Viewと密接に結びついてしまってよろしくない。ここはMVVM的にやりましょう。でも、どうやって？</p>
<p>View(UI)が持つネイティブなイベントを、ViewModelの持つ更新通知付きのプロパティに変換します。これはバインディングにより可能です。そこはWPF/SLの仕組みに任せましょう。ということで、RxでUIに対してプログラミングするというのは、ViewModelの通知に対してプログラミングするという形になります。</p>
<p>テキストボックスの変更に反応して、1秒ディレイをかけた後に表示する、という簡単な例を(何の面白みもありません、すみません)</p>
<p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="50px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/ReactiveProperty.SL4.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class ToaruViewModel : INotifyPropertyChanged
{
    private string input;
    public string Input
    {
        get { return input; }
        set { input = value; RaiseEvent(&quot;Input&quot;); }
    }

    private string output;
    public string Output
    {
        get { return output; }
        set { output = value; RaiseEvent(&quot;Output&quot;); }
    }

    public ToaruViewModel()
    {
        Observable.FromEvent&lt;PropertyChangedEventHandler, PropertyChangedEventArgs&gt;(
                h =&gt; (sender, e) =&gt; h(e),
                h =&gt; this.PropertyChanged += h, h =&gt; this.PropertyChanged -= h)
            .Where(e =&gt; e.PropertyName == &quot;Input&quot;) // Inputが更新されたら
            .Select(_ =&gt; Input) // Inputの値を
            .Delay(TimeSpan.FromSeconds(1)) // 1秒遅らせて
            .ObserveOnDispatcher() // Dispatcherで(Silverlightではこれ必要・WPFでは不要)
            .Subscribe(s =&gt; Output = &quot;入力が1秒後に表示される:&quot; + s); // Outputへ代入
    }

    // この辺は別途、ライブラリを使って持ってくるほうが良いかも
    public void RaiseEvent(string propertyName)
    {
        var handler = PropertyChanged;
        if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
    }

    public event PropertyChangedEventHandler PropertyChanged;
}

// xaml.csはInitializeだけ、xamlのバインディングは各プロパティへ当てるだけ。
// ただしSL/WP7はUpdateSourceTrigger=PropertyChangedに対応してないので別途Behaviorの適用が必要
// 詳しくは、最後にソース配布(WPF/SL/WP7全て含む)URLを置いているのでそちらを見てください
</code></pre>
<p>……実にダサい。はい。全くいけてないです。バインディング可能なのはプロパティなので、そういった中間レイヤへの中継が発生していて、冗長だし、美味しさがかなり損なわれています。わかりきったINotifyPropertyChangedのWhere, Selectは無駄そのもので。勿論、簡単にDelayを混ぜられるといった時間の扱いの容易さはRxならでは、ではあるのですけれど。</p>
<h2>ReactiveProperty</h2>
<p>中継が手間ならば、中間レイヤだけを抜き出してやればいい。通知処理を内包したIObservable&lt;T&gt;があれば解決する。というわけで、ReactivePropertyと名付けたものを作りました。それを使うと、こうなります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class SampleViewModel : INotifyPropertyChanged
{
    public ReactiveProperty&lt;string&gt; ReactiveIn { get; private set; }
    public ReactiveProperty&lt;string&gt; ReactiveOut { get; private set; }

    public SampleViewModel()
    {
        // UIから入力されるものはnewで作成、デフォルト値も同時に指定出来る。
        ReactiveIn = new ReactiveProperty&lt;string&gt;(_ =&gt; RaiseEvent(&quot;ReactiveIn&quot;), &quot;でふぉると&quot;);

        // UIへ出力するIO&lt;T&gt;はToReactivePropertyで、初期値での発火も自動的にされます。
        ReactiveOut = ReactiveIn
            .Delay(TimeSpan.FromSeconds(1))
            .Select(s =&gt; &quot;入力が1秒後に表示される:&quot; + s)
            .ToReactiveProperty(_ =&gt; RaiseEvent(&quot;ReactiveOut&quot;));
    }

    // 通常は、他のMVVMフレームワークなりを使い、それの更新通知システムを利用するといいでしょう
    // Rxを使ったからって、決してMVVMフレームワークと競合するわけではなく、むしろ協調すると考えてください
    public void RaiseEvent(string propertyName)
    {
        var handler = PropertyChanged;
        if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
    }

    public event PropertyChangedEventHandler PropertyChanged;
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">// これはWPF版のもの
&lt;Window x:Class=&quot;ReactiveProperty.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:l=&quot;clr-namespace:ReactiveProperty&quot;
        Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt;
    &lt;Window.DataContext&gt;
        &lt;l:SampleViewModel /&gt;
    &lt;/Window.DataContext&gt;
    &lt;StackPanel&gt;
        &lt;TextBox Text=&quot;{Binding ReactiveIn.Value, UpdateSourceTrigger=PropertyChanged}&quot; /&gt;
        &lt;TextBlock Text=&quot;{Binding ReactiveOut.Value}&quot; /&gt;
    &lt;/StackPanel&gt;
&lt;/Window&gt;
</code></pre>
<p>XAMLではPathに必ず.Valueまで指定します。これによりGetが求められれば最新の値を返し、値をSetされればPushするようになります。</p>
<p>今回はUI-&gt;ReactiveProperty-&gt;クエリ演算-&gt;ReactiveProperty-&gt;UIという風に戻してやりましたが、勿論、UIからの入力をModelに流してそれで止めてもいいし、Modelからの値をUIに流すだけでもいいし、トリガーはタイマーであってもいいし、その辺は完全に自由です。普通の通知プロパティと何も変わりません。また普通のプロパティとして使いたい時は.Valueで値を取り出す/セットできます。</p>
<p>かなりシンプルに仕上がります。通知付きプロパティは、本質的に値の変更毎に通知される無限長のIObservable&lt;T&gt;と見なせるので、そのことにより表現がより自然になっています。書き味も、リアクティブプログラミング(といわれてパッと浮かばれる値が自動更新されるという奴)にかなり近い感じの風合い。XAMLでのバインドも簡単ですし、VMの実装も自動実装プロパティだけで書けるので記述が楽チン。</p>
<p>そして、Rxを使うことによる最大の利点である、他のイベント(他の変更通知プロパティ)と合成しやすかったり、時間が扱いやすくなったり、非同期と混ぜても同じように扱えたり、スレッドの切り替えが簡単であったり、などを最大限に甘受できます。VMとして独立している、かつ全てがRxに乗っているため、単体テストも非常に作成しやすい状態です(時間軸を扱う処理のテストは通常難しいのですが、Rxの場合は自分で時間をコントロール可能なSchedulerを中間に挟むと、好きなように時間を進められるようになります、イベントのテストも、この状態ならばプロパティを変更するだけで生成されますし)。また、決して他のMVVMフレームワークと競合が起こるわけではない(多分……)のも見逃せない利点です。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ReactivePropertyModel.jpg">
</p>
<p>単純な例なのでModelがありませんが、まあこんな感じ？(それと今はコマンドがないので単純なデータバインドのみの図です)。Modelへのアクセスは通常恐らくRx:Query内で行い、Modelの形態は色々だと思いますが、通信してデータを処理して返す、みたいなものはRxになっているとVMのReactiveProperty側での合成処理が容易なので、非同期にしてIObservable&lt;T&gt;で返すと良いのではかと思います。自身が通知を持つReactivePropertyになっていてもいいですね。そうなると、コードのほとんどがLINQになるという素敵な夢が見れる気がしますが気のせいです。</p>
<h2>実装</h2>
<p>ReactivePropertyの実装はこんな感じです。ご自由にコピペって使ってみてください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
#if WINDOWS_PHONE
using Microsoft.Phone.Reactive;
#else
using System.Reactive.Linq;
using System.Reactive.Subjects;
#endif

public class ReactiveProperty&lt;T&gt; : IObservable&lt;T&gt;, IDisposable
{
    T latestValue;
    IObservable&lt;T&gt; source;
    Subject&lt;T&gt; anotherTrigger = new Subject&lt;T&gt;();
    IDisposable sourceDisposable;

    public ReactiveProperty(Action&lt;T&gt; propertyChanged, T initialValue = default(T))
        : this(Observable.Never&lt;T&gt;(), propertyChanged, initialValue)
    { }

    public ReactiveProperty(IObservable&lt;T&gt; source, Action&lt;T&gt; propertyChanged, T initialValue = default(T))
    {
        this.latestValue = initialValue;

        var merge = source.Merge(anotherTrigger)
            .DistinctUntilChanged()
            .Publish(initialValue);
        this.sourceDisposable = merge.Connect();

        // PropertyChangedの発火はUIスレッドで行うことにする
        // UIへの反映の際に、WPFでは問題ないが、SL/WP7ではUIスレッドから発行しないと例外が出るため
        merge.ObserveOnDispatcher().Subscribe(x =&gt;
        {
            latestValue = x;
            propertyChanged(x);
        });

        this.source = merge;
    }

    public T Value
    {
        get
        {
            return latestValue;
        }
        set
        {
            latestValue = value;
            anotherTrigger.OnNext(value);
        }
    }

    public IDisposable Subscribe(IObserver&lt;T&gt; observer)
    {
        return source.Subscribe(observer);
    }

    public void Dispose()
    {
        sourceDisposable.Dispose();
    }
}

// 拡張メソッド
public static class ObservableExtensions
{
    public static ReactiveProperty&lt;T&gt; ToReactiveProperty&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; propertyChanged, T initialValue = default(T))
    {
        return new ReactiveProperty&lt;T&gt;(source, propertyChanged, initialValue);
    }
}
</code></pre>
<p>Valueで値の中継をしているという、それだけです。Publish(value)はBehaviorSubjectというものを使った分配で、必ず最新の値一つをキャッシュとして持っていて、Subscribeされると同時に、まずその値で通知してくれます。これにより「初期値での自動発火」が自然に行える、という仕組みになっています。また、プロパティの変更時に同値の場合は変更通知をしない、というよくあるほぼ必須処理も、ここでDistinctUntilChangedを挟んで行っています(オプションで選択制にしてもいいかもしれない)。</p>
<h2>それReactiveUI？</h2>
<p><a href="http://www.reactiveui.net/">ReactiveUI</a>というRxを前提にしたMVVMフレームワークがあって、それに用意されているObservableAsPropertyHelperと、ReactivePropertyはかなり近いです(ということにプロトタイプ作ってから気づいた、ReactiveUIはこれまで名前は知ってたけど中身完全ノーチェックだったので)。ただ、機能的にはOAPHは双方向バインディングに対応していないので、ReactivePropertyのほうが上です。また、OAPHは使い勝手もあまり良くないし、名前がダサい(ObservableAsPropertyHelperは長すぎるし型名として宣言させるにはイマイチに思える……)などなどで、あまり気に入るものではなかったです。</p>
<p>ReactiveUIは全体的には軽く眺めた程度なのですが、今ひとつ私には合わない。ちょっと、いや、かなり気にいらない。なので、私としてはそのうち他のMVVMライブラリをベースに置いた上での拡張として、Rx用のUI周りライブラリを作りたい。独自に上から下まで面倒を見るフレームワーク、という指針は今一つに思えるので、Rxならではの特異な部分だけを、最初から他のMVVMフレームワークの拡張として用意していく、という方向性のほうが良いものが作れると思っています。素のままのRxでは辛いので、何かしらの中間層が必要なのは間違いないので。</p>
<p>次は、ReactiveCommandを！あー、あとReactiveCollectionも必要かしら。Validationとかも……。まあ、そういうところは普通に書けばいいんですよ、何も全部Rxでやる必要はないですからね。</p>
<h2>まとめ</h2>
<p>WPFのバインディングの美味しさをRxで更に美味しくする、ということでした。世の中的には弱参照が～などなどというお話もありますが、それには全然追いついてませんので、おいおいちかぢかそのうち。</p>
<p>今回のコードの全体(WPF/SL/WP7)は<a href="https://bitbucket.org/neuecc/reactiveproperty" title="neuecc / ReactiveProperty / overview — Bitbucket">neuecc / ReactiveProperty /Bitbucket</a>に置いてありますので、好きに見てください。例が単純すぎると美味しさもよくわからないので、もう少し複雑な例で、サンプル準備中なのでしばしお待ちを。</p>
<p>ところで9/15にいよいよRx本が出ます。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>オライリーで出ているProgramming C#の著者と、ReactiveUIの作者(元Microsoft Office Labs、つい最近Githubに転職した模様)の共著です。私も買いますので、うーん、読書会とかやったら来てくれる方います？</p>
</div>
<h1 data-pagefind-sort="date:2011-08-22" data-pagefind-meta="published:2011-08-22"><a href="https://neue.cc/2011/08/22_340.html">linq.js LT資料</a></h1>
<ul class="date"><li>2011-08-22</li></ul>
<div class="entry_body"><p>LTで簡単に<a href="http://linqjs.codeplex.com/">linq.js</a>の紹介をしましたので、その資料を。といっても、資料は全く使わないでLTの場では完全にデモ一本にしました。ええ、こういう場では、やっぱデモ優先のほうがいいかなー、と。資料は資料で、要素がきっちりまとまって紹介という感じなので、見てもらえればと思います。</p>
<div style="width:595px" id="__ss_8930196"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/linqjs-linq-to-objects-for-javascript" title="linq.js - Linq to Objects for JavaScript" target="_blank">linq.js - Linq to Objects for JavaScript</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/8930196" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>スライドのテンプレは同じの使っていてそろそろ飽きたので、新しいのに変えたいところ。基本的にはテンプレのテーマまんまですが、やっぱ細かいところでスライドマスタの調整は必要なので、面倒くさー、と思ってしまい中々に気力が。むしろデザイン変更は一年に一回でいいかしらいいかしら？</p>
<p>そういえばどうでもよくないのですが、SlideshareをBlogに埋め込む時はlargeサイズを選んで欲しい。文字潰れてしまうもの、わざわざ小さいサイズで埋め込む必要はどこにもなくて。</p>
</div>
<h1 data-pagefind-sort="date:2011-08-19" data-pagefind-meta="published:2011-08-19"><a href="https://neue.cc/2011/08/19_339.html">文字列を先頭から見て同じところまで除去をlinq.jsとC#で解いてみた</a></h1>
<ul class="date"><li>2011-08-19</li></ul>
<div class="entry_body"><p><a href="http://blog.livedoor.jp/okashi1/archives/51778281.html">JavaScript で「文字列を先頭から見て同じところまで除去」をやってみました。</a>という記事を見て、「linq.js を使いたかったのですが使いどころがパッと思い浮かびませんでした」とのことなので、<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js - LINQ for JavaScript</a>で答えてみます。お題の元は<a href="http://d.hatena.ne.jp/fumokmm/20110812/1313138407">お題：文字列を先頭から見て同じところまで除去</a>からです。解き方も色々あると思いますが、最長の一致する文字を見つけて、それを元に文字列を削除していく、という方法を取ることにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">function dropStartsSame(array)
{
    var seq = Enumerable.From(array);
    return Enumerable.From(seq.First())
        .Scan(&quot;$+$$&quot;)
        .TakeWhile(function (x) { return seq.All(function (y) { return y.indexOf(x) == 0 }) })
        .Insert(0, [&quot;&quot;]) // 一つもマッチしなかった場合のため
        .TakeFromLast(1)
        .SelectMany(function (x) { return seq.Select(function (y) { return y.substring(x.length) }) });
}

dropStartsSame([&quot;abcdef&quot;, &quot;abc123&quot;]).WriteLine();
dropStartsSame([&quot;あいうえお&quot;, &quot;あいさんさん&quot;, &quot;あいどる&quot;]).WriteLine();
dropStartsSame([&quot;12345&quot;, &quot;67890&quot;, &quot;12abc&quot;]).WriteLine();
</code></pre>
<p>はい、ワンライナーで書けました、って何だか意味不明ですね！まず、例えば&quot;abcdef&quot;から[&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;abcd&quot;,&quot;abcde&quot;,&quot;abcdef&quot;]を作ります。これはものすごく簡単で、Scanを使うだけです。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;abcd&quot;,&quot;abcde&quot;,&quot;abcdef&quot;]
Enumerable.From(&quot;abcdef&quot;).Scan(&quot;$+$$&quot;)
</code></pre>
<p>素晴らしい！そうして比較のタネができたら、あとは全てのindexOfが0(先頭に一致する)の間だけ取得(TakeWhile)します。[&quot;abcdef&quot;,&quot;abc123&quot;]だとシーケンスは[&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;]に絞られます。必要なのは最長のもの一つだけなのでTakeFromLast(1)で最後のものだけを取得。もし一つもマッチしなかった場合は代わりに&quot;&quot;が通るようにInsertで事前に先頭にさしてやってます。あとは、その&quot;abc&quot;を元にして文字列を置換したシーケンスを返してやるようにすればいい、というわけです、はい。</p>
<h2>少し修正</h2>
<p>SelectManyで繋げるのは悪趣味なので、ちょっと変えましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">function dropStartsSame(array)
{
    var seq = Enumerable.From(array);
    var pre = Enumerable.From(seq.First())
        .Scan(&quot;$+$$&quot;)
        .TakeWhile(function (x) { return seq.All(function (y) { return y.indexOf(x) == 0 }) })
        .LastOrDefault(&quot;&quot;);

    return seq.Select(function (x) { return x.substring(pre.length) });
}
</code></pre>
<p>変数を一つ置いてやるだけで随分とすっきり。無理に全部繋げるのはよくないね、という当たり前の話でした。</p>
<h2>C# + Ix</h2>
<p>C#とIxで書くとこうなるかな？基本的には同じです。(Ixって何？という人は<a href="http://neue.cc/2011/08/10_337.html" title="neue cc - LINQ to Objects &amp; Interactive Extensions &amp; linq.js 全メソッド概説">neue cc - LINQ to Objects &amp; Interactive Extensions &amp; linq.js 全メソッド概説</a>を参照ください)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IEnumerable&lt;string&gt; DropStartsSame(params string[] args)
{
    var pre = args.First()
        .Scan(&quot;&quot;, (x, y) =&gt; x + y)
        .TakeWhile(x =&gt; args.All(y =&gt; y.StartsWith(x)))
        .LastOrDefault() ?? &quot;&quot;;
    return args.Select(x =&gt; x.Substring(pre.Length));
}

static void Main()
{
    var x = DropStartsSame(&quot;abcdef&quot;, &quot;abc123&quot;).SequenceEqual(new[] { &quot;def&quot;, &quot;123&quot; });
    var y = DropStartsSame(&quot;あいうえお&quot;, &quot;あいさんさん&quot;, &quot;あいどる&quot;).SequenceEqual(new[] { &quot;うえお&quot;, &quot;さんさん&quot;, &quot;どる&quot; });
    var z = DropStartsSame(&quot;12345&quot;, &quot;67890&quot;, &quot;12abc&quot;).SequenceEqual(new[] { &quot;12345&quot;, &quot;67890&quot;, &quot;12abc&quot; });

    Console.WriteLine(x == y == z == true);
}
</code></pre>
<p>Ixで使ってるのはScanだけですけれど。</p>
<h2>Deferの使い道</h2>
<p>ところで、上のコードは遅延評価なのか遅延評価でないのか、微妙な感じです。preの計算までは即時で、その後は遅延されています。まるごと遅延したい場合はIxのDeferというメソッドが使えます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Deferで生成を遅延する
static IEnumerable&lt;string&gt; DropStartsSame2(params string[] args)
{
    return EnumerableEx.Defer(() =&gt;
    {
        var pre = args.First()
            .Scan(&quot;&quot;, (x, y) =&gt; x + y)
            .TakeWhile(x =&gt; args.All(y =&gt; y.StartsWith(x)))
            .LastOrDefault() ?? &quot;&quot;;
        return args.Select(x =&gt; x.Substring(pre.Length));
    });
}

// もしくはyield returnを使ってしまうという手も私はよく使っていました
static IEnumerable&lt;string&gt; DropStartsSame3(params string[] args)
{
    var pre = args.First()
        .Scan(&quot;&quot;, (x, y) =&gt; x + y)
        .TakeWhile(x =&gt; args.All(y =&gt; y.StartsWith(x)))
        .LastOrDefault() ?? &quot;&quot;;
    var query = args.Select(x =&gt; x.Substring(pre.Length));
    
    foreach (var item in query) yield return item;
}

// 勿論、全部LINQで組んでしまってもOK
static IEnumerable&lt;string&gt; DropStartsSame4(params string[] args)
{
    return args.First()
        .Scan(&quot;&quot;, (x, y) =&gt; x + y)
        .TakeWhile(x =&gt; args.All(y =&gt; y.StartsWith(x)))
        .StartWith(&quot;&quot;) // linq.jsではInsert(0, [])でした
        .TakeLast(1) // linq.jsではTakeFromLastでした
        .SelectMany(x =&gt; args.Select(y =&gt; y.Substring(x.Length)));
}
</code></pre>
<p>私はIx以前はyield returnを結構よく使ってました。今は、Deferのほうが、例えば if(args == null) throw new ArgumentNullException(); とかがそのまま書けるのでDeferを選びたいかも。この辺の評価タイミングの話は前回、<a href="http://neue.cc/2011/08/15_338.html" title="neue cc - 詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)">詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)</a>で書きました。</p>
<h2>まとめ</h2>
<p>というわけで、Scanの使い方でした。Scan可愛いよScan。ようするにAggregateの計算途中も列挙する版なわけなので、これ、標準クエリ演算子にも入って欲しかったなあ。結構使えるシーン多いです。</p>
<p>ああ、あとJavaScriptでもforなんて使いません(ｷﾘｯ。<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js</a>は真面目に普通に多機能なので遅い、じゃなくて、いや、それはまあ事実なんですが、便利には違いないです。他の普通のコレクションライブラリじゃ出来ないことも平然と出来ます。でもかわりに（ry</p>
</div>
<h1 data-pagefind-sort="date:2011-08-15" data-pagefind-meta="published:2011-08-15"><a href="https://neue.cc/2011/08/15_338.html">詳説Ix Share/Memoize/Publish編(もしくはyield returnの注意点)</a></h1>
<ul class="date"><li>2011-08-15</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2011/08/10_337.html" title="neue cc - LINQ to Objects &amp; Interactive Extensions &amp; linq.js 全メソッド概説">LINQ to Objects &amp; Interactive Extensions &amp; linq.js 全メソッド概説</a>でのIxのPublishの説明がおざなりだったので、一族について詳しく説明したいと思います(Ixの詳細・入手方法などは先の全メソッド概説のほうを参照ください)。ええ、これらはIBuffer&lt;T&gt;を返すという一族郎党だという共通点があります。なので、並べてみれば分かりやすい、かも？挙動を検証するためのコードは後で出しますので、ひとまず先に図をどうぞ。星がGetEnumerator、丸がMoveNext(+Current)、矢印線が二つ目の列挙子を取得したタイミングを表しています。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ShareMemoizePublish.jpg">
</p>
<p>これだけじゃよく分かりません。と、いうわけで、少しだけ上の図を頭に入れて、以下の解説をどうぞ。</p>
<h2>Memoize</h2>
<p>Memoizeはメモ化。メモイズ。メモライズじゃないっぽいです。二度目三度目の列挙時は値をキャッシュから返すので、前段がリソースから取得したり複雑な計算処理をしていたりで重たい場合に有効、という使い道が考えられます。とりあえずEnumeratorを取ってきて、それでじっくり動きを観察してみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ShareやMemoizeやPublishの戻り値の型はIBuffer&lt;T&gt;で、これはIDisposableです。
// もしリソースを抱えるものに適用するなら、usingしたほうがいいかも？
using (var m = Enumerable.Range(1, int.MaxValue)
    .Do(x =&gt; Console.WriteLine(&quot;spy:&quot; + x)) // 元シーケンスが列挙される確認
    .Memoize())
{
    var e1 = m.GetEnumerator();
    e1.MoveNext(); e1.MoveNext(); e1.MoveNext(); // spy:1,spy:2,spy:3
    Console.WriteLine(e1.Current); // 3

    var e2 = m.GetEnumerator();
    e2.MoveNext(); // キャッシュから返されるので元シーケンスは不動
    Console.WriteLine(e2.Current); // 1

    e2.MoveNext(); e2.MoveNext(); e2.MoveNext(); // spy:4
    Console.WriteLine(e2.Current); // 4

    e1.MoveNext(); // 今度はe2が先行したので、こちらもキャッシュから
    Console.WriteLine(e1.Current); // 4
}
</code></pre>
<p>特に考える必要もなく分かりやすい内容です。オーバーロードにはreaderCountを受けるものがありますが、それの挙動は以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Memoizeの第二引数はreaderCount(省略した場合は無限個)
using (var m = Enumerable.Range(1, int.MaxValue).Memoize(2))
{
    // readerCountはEnumeratorの取得可能数を表す
    var e1 = m.GetEnumerator();
    e1.MoveNext(); // MoveNextするとMemoizeに登録される
    var e2 = m.GetEnumerator();

    var e3 = m.GetEnumerator();
    e3.MoveNext();

    e2.MoveNext(); // 3つめはNGなので例外が飛んで来る
}
</code></pre>
<p>これを使うと、キャッシュから値が随時削除されていくので、メモ化しつつ巨大なシーケンスを取り扱いたい場合には、メモリ節約で有効なこともあるかもしれません。とはいっても、普段はあまり考えなくてもいいかな？毎回削除処理が入るので、実行時間は当然ながら遅くなります。</p>
<h2>Share</h2>
<p>Shareは列挙子を共有します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var s = Enumerable.Range(1, int.MaxValue).Share())
{
    var e1 = s.GetEnumerator();
    e1.MoveNext(); e1.MoveNext(); e1.MoveNext();
    Console.WriteLine(e1.Current); // 3

    var e2 = s.GetEnumerator(); // 列挙子が共有されているので3からスタート
    Console.WriteLine(e2.Current); // 0。共有されるといっても、MoveNext前の値は不定です
    e2.MoveNext();
    Console.WriteLine(e2.Current); // 4。正しく初期値といえるのはここ

    Console.WriteLine(e1.Current); // 3。e1とe2は同じものを共有していますが、Currentの値はMoveNextしない限りは変わらない

    e1.MoveNext();
    Console.WriteLine(e1.Current); // 5。列挙子を共有しているので、e2の続き
}
</code></pre>
<p>といった形です。これの何が美味しいの？というと、例えば自分自身と結合させると、隣り合った値とくっつけられます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Share, Memoize, Publishにはselectorを受けるオーバーロードがある
// このselectorには var xs = source.Share() の xsが渡される
// つまり、一度外部変数に置かなくてもよいという仕組み、Zipなどと相性が良い

// 結果は {x = 1, y = 2}, { x = 3, y = 4}, { x = 5, y = 6}
// 列挙子を共有して自分自身と結合するので、隣り合った値とくっつく
Enumerable.Range(1, 6)
    .Share(xs =&gt; xs.Zip(xs, (x, y) =&gt; new { x, y }))
    .ForEach(x =&gt; Console.WriteLine(x));
</code></pre>
<p>なんだか、へぇー、という感じの動き。このShareを使うと<a href="http://d.hatena.ne.jp/okazuki/20110611/1307759414">stringの配列からDictionary&lt;string, string&gt;への変換 まとめ - かずきのBlog@Hatena</a>のコードは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// {&quot;1&quot;:&quot;one&quot;}, {&quot;2&quot;:&quot;two&quot;}
var array = new[] { &quot;1&quot;, &quot;one&quot;, &quot;2&quot;, &quot;two&quot; };
var dict = array.Share(xs =&gt; xs.Zip(xs, Tuple.Create))
    .ToDictionary(t =&gt; t.Item1, t =&gt; t.Item2);
</code></pre>
<p>物凄くシンプルになります。ループを回すなんて、やはり原始人のやることでしたね！</p>
<h2>Publish</h2>
<p>PublishはRxでは値を分散させましたが、Ixでも分散です。ただ、挙動にはかなりクセがあり、あまりお薦め出来ないというか……。動きとしては、取得時には共有された列挙子から流れてくるのでShareのようであり、列挙子取得後は全て必ず同じ値が返ってくることからMemoizeのようでもある。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using (var p = Enumerable.Range(1, int.MaxValue).Publish())
{
    var e1 = p.GetEnumerator();
    e1.MoveNext(); e1.MoveNext(); e1.MoveNext();
    Console.WriteLine(e1.Current); // 3

    var e2 = p.GetEnumerator(); // 取得時は列挙子の状態が共有されているので3からスタート
    Console.WriteLine(e2.Current); // 0。 共有されるといっても、MoveNext前の値はやはり不定
    e2.MoveNext();
    Console.WriteLine(e2.Current); // 4。正しく初期値といえるのはここ

    e1.MoveNext(); e1.MoveNext(); e1.MoveNext(); e1.MoveNext(); e1.MoveNext();
    Console.WriteLine(e1.Current); // 8

    e2.MoveNext(); // 取得後の状態はそれぞれ別、またキャッシュから返される
    Console.WriteLine(e2.Current); // 5
}
</code></pre>
<p>このPublish、こうして生イテレータを操作している分には理解できますが、普通に使うように演算子を組み合わせると予測不能の挙動になります。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 自分自身と結合、GetEnumeratorのタイミングが同じなので同値で結合される
// {1,1},{2,2},{3,3},{4,4},{5,5}
Enumerable.Range(1, 5)
    .Publish(xs =&gt; xs.Zip(xs, (x, y) =&gt; new { x, y }))
    .ForEach(a =&gt; Console.WriteLine(a));

// もし後者のほうをSkip(1)したらこうなります
// {1,3},{2,4},{3,5}
Enumerable.Range(1, 5)
    .Publish(xs =&gt; xs.Zip(xs.Skip(1), (x, y) =&gt; new { x, y }))
    .ForEach(a =&gt; Console.WriteLine(a));
</code></pre>
<p>Skip(1)すると {1,2},{2,3}... ではなくて {1,3},{2,4}... になる理由、すぐにティンと来ますか？正直私はわけがわかりませんでした。Zipの実装を見ながら考えると、少し分かりやすくなります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IEnumerable&lt;TR&gt; Zip&lt;T1, T2, TR&gt;(this IEnumerable&lt;T1&gt; source1, IEnumerable&lt;T2&gt; source2, Func&lt;T1, T2, TR&gt; selector)
{
    using (var e1 = source1.GetEnumerator())
    using (var e2 = source2.GetEnumerator())
    {
        while (e1.MoveNext() &amp;&amp; e2.MoveNext())
        {
            yield return selector(e1.Current, e2.Current);
        }
    }
}
</code></pre>
<p>Skip(1)のない、そのままZipで結合したものはEnumeratorを取得するタイミングは同じなので、 {1,1},{2,2}... になるのは妥当です。では、source2がSkip(1)である場合は、というと、source2.GetEnumeratorの時点で取得されるのはSkip(1)のEnumeratorであり、Publishで分配されているEnumeratorはまだ取得開始されていません。では、いつPublishされているEnumeratorを取得するか、というと、これは最初にe2.MoveNextが呼ばれたときになります。なので、e1.MoveNextにより一回列挙されているから、e2の(MoveNext済みでの)初期値は2。更にSkip(1)するので、{1,3},{2,4}... という結果が導かれます。</p>
<p>ZipやSkipなど、他のメソッドを組み合わせるなら、それらの内部をきっちり知らなければ挙動が導けないという、ものすごく危うさを抱えているので、Publishを上手く活用するのは難しい印象です、今のところ、私には。もともとPublishはRxに分配のためのメソッドとして存在して、その鏡としてIxにも移植されているという出自なのですが、どうしてもPull型で実現するには不向きなため、不自然な挙動となってしまっています。分配はPull(Ix)じゃなくてPush(Rx)のほうが向いている、というわけで、分配したいのならToObservableして、Observable側のPublishを使ったほうが、素直な動きをして良いと思います。</p>
<h2>yield returnを突っつく</h2>
<p>MemoizeのreaderCountの例でもそうでしたが、Publish/Memoizeされている列挙子を取得するのがGetEnumerator時ではなくて最初のMoveNextの時、になるのはyield returnを使うとそういう挙動で実装されるからです。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IEnumerable&lt;T&gt; Hide&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    Console.WriteLine(&quot;列挙前&quot;);
    using (var e = source.GetEnumerator()) // 通常は、foreachを使いますが。
    {
        while (e.MoveNext()) yield return e.Current;
    }
    Console.WriteLine(&quot;Dispose済み&quot;);
} // yield break

static void Main(string[] args)
{
    var e = Enumerable.Repeat(&quot;hoge&quot;, 1).Hide().GetEnumerator(); // ここではまだ何も起こらない
    e.MoveNext(); // 列挙前 ← ここでメソッド冒頭からyield return e.Currentのところまで移動
    Console.WriteLine(e.Current); // hoge
    e.MoveNext(); // Dispose済み ← 最終行まで到達して終了
}
</code></pre>
<p>イテレータの自動実装でメソッド本文を動きだすのは、最初のMoveNextから、というわけです。また、イテレータ内でusingなどリソースを掴む実装をしている場合は、普通にブロックを(using,lock,try-finally)超えた時に解放されます。ただし、ちゃんとブロックを超えるまでMoveNextを呼びきれる保証なんてない(例外が発生したり)ので、GetEnumeratorする時はusingも忘れずに、は大原則です。using、つまりEnumeratorをDisposeすると、using,lock,finallyがメソッド本文中で呼ばれていなかった場合は、呼ぶようになってます。</p>
<p>ところで、本文が動き出すのは最初のMoveNextから、であることが困る場合もあります。例えば引数チェック。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;string&gt; Hoge(string arg)
{
    if (arg == null) throw new ArgumentNullException();

    yield return arg;
}

void Main(string[] args)
{
    var hoge = Hoge(null); // ここでは何も起こらない！
    hoge.GetEnumerator().MoveNext(); // ArgumentNullException発生
}
</code></pre>
<p>nullチェックはメソッドに渡したその時にチェックして欲しいわけで、これではタイミングが違って良くない。これを回避するにはどうすればいいか、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 先にnullチェックを済ませて普通にreturn
public static IEnumerable&lt;string&gt; Hoge(string arg)
{
    if (arg == null) throw new ArgumentNullException();

    return HogeCore(arg);
}

// privateなメソッドで、こちらにyield returnで本体を書く
private static IEnumerable&lt;string&gt; HogeCore(string arg)
{
    yield return arg;
}

static void Main(string[] args)
{
    var hoge = Hoge(null); // 例外発生！
}
</code></pre>
<p>こうすれば、完璧な引数チェックの完成。実際に、LINQ to Objectsの実装はそうなっています。この時のprivateメソッドの命名には若干困りますが、私は今のところXxxCoreという形で書くようにしてます。MicrosoftのEnumerable.csではXxxIteratorという命名のようですね。また、Ixを覗くとXxx_という名前を使っている感じ。みんなバラバラなので好きな命名でいいのではかと。</p>
<p>なお、こんなことのためだけにメソッドを分割しなければならないというのは、無駄だしバッドノウハウ的な話なので、かなり嫌いです。インラインにラムダ式でyield returnが使えればこんなことにはならないんだけれどなー、ﾁﾗﾁﾗ(次期C#に期待)</p>
<h2>まとめ</h2>
<p>再度、冒頭の図を眺め直してもらうと、ああ、なるほどそういうことね、と分かりますでしょうか？</p>
<p>とはいえ、ShareもMemoizeもPublishもあんま使うことはないかと思いますぶっちゃけ！Memoizeは、使いたいシチュエーションは確かに多いのですけれど、しかし事前にToArrayしちゃってたりしちゃうことのほうが多いかなー、と。Shareは面白いんだけど使いどころを選ぶ。Publishは挙動が読みきれなくなりがちなので、避けたほうがいいと思います。</p>
</div>
<h1 data-pagefind-sort="date:2011-08-10" data-pagefind-meta="published:2011-08-10"><a href="https://neue.cc/2011/08/10_337.html">LINQ to Objects & Interactive Extensions & linq.js 全メソッド概説</a></h1>
<ul class="date"><li>2011-08-10</li></ul>
<div class="entry_body"><p>@ITに以前書いたLINQの基礎知識の話が載りました -&gt; <a href="http://www.atmarkit.co.jp/fdotnet/chushin/greatblogentry_06/greatblogentry_06_01.html" title="LINQの仕組み＆遅延評価の正しい基礎知識 － ＠IT">LINQの仕組み＆遅延評価の正しい基礎知識 － ＠IT</a>。ああ、もっとしっかり書いていれば(図もへっぽこだし)、と思ったり思わなかったり。それでも校正していただいたのと、細部は修正してあるので、元のものよりも随分と読みやすいはずです。そういえばで1月頭の話なんですね、姉妹編としてRxの基礎知識もやるつもりだったのにまだやってないよ！</p>
<p>ところでそもそも基礎知識といったら標準クエリ演算子が何をできるかではないのでしょうか？知ってるようで知らない標準クエリ演算子。<a href="http://msdn.microsoft.com/ja-jp/vcsharp/aa336746">101 LINQ Samples</a>もあるし<a href="http://msdn.microsoft.com/ja-jp/library/bb397926.aspx">MSDNのリファレンス</a>は十分に充実していますが、しかし意外と見逃しもあるかもしれません。また、Interactive Extensionsで何が拡張されているのかは知っていますか？ついでにJS実装のlinq.jsには何があるのか知っていますか？</p>
<p>そんなわけで、LINQ to Objects、Ix、linq.jsの全メソッドを一行解説したいと思います。</p>
<h2>LINQ to Objects</h2>
<p>いわゆる、標準クエリ演算子。.NET 3.5から使えます。.NET4.0からはZipメソッドが追加されました。なお、サンプルと実行例は<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>に「完全に」同じ挙動をするJS実装での例がありますので、そちらを参照にどうぞ。こういう場合はJS実装だと便利ですね。</p>
<table>
  <tr>
    <td>Aggregate</td>
    <td>汎用的な値算出</td>
  </tr>
  <tr>
    <td>All</td>
    <td>条件に全て一致するか</td>
  </tr>
  <tr>
    <td>Any</td>
    <td>条件に一つでも一致するか、引数なしの場合は空かどうか</td>
  </tr>
  <tr>
    <td>AsEnumerable</td>
    <td>IEnumerable&lt;T&gt;へアップキャスト</td>
  </tr>
  <tr>
    <td>Average</td>
    <td>平均</td>
  </tr>
  <tr>
    <td>Cast</td>
    <td>値のダウンキャスト、主な用途はIEnumerableからIEnumerable&lt;T&gt;への変換</td>
  </tr>
  <tr>
    <td>Concat</td>
    <td>引数のシーケンスを後ろに連結</td>
  </tr>
  <tr>
    <td>Contains</td>
    <td>値が含まれているか、いわばAnyの簡易版</td>
  </tr>
  <tr>
    <td>Count</td>
    <td>シーケンスの件数</td>
  </tr>
  <tr>
    <td>DefaultIfEmpty</td>
    <td>シーケンスが空の場合、デフォルト値を返す(つまり長さ1)</td>
  </tr>
  <tr>
    <td>Distinct</td>
    <td>重複除去</td>
  </tr>
  <tr>
    <td>ElementAt</td>
    <td>指定インデックスの要素の取得</td>
  </tr>
  <tr>
    <td>ElementAtOrDefault</td>
    <td>指定インデックスの要素の取得、なければデフォルト値を返す</td>
  </tr>
  <tr>
    <td>Empty</td>
    <td>空シーケンスの生成</td>
  </tr>
  <tr>
    <td>Except</td>
    <td>差集合・差分だけ、集合なので重複は除去される</td>
  </tr>
  <tr>
    <td>First</td>
    <td>最初の値の取得、ない場合は例外が発生</td>
  </tr>
  <tr>
    <td>FirstOrDefault</td>
    <td>最初の値を取得、ない場合はデフォルト値を返す</td>
  </tr>
  <tr>
    <td>GroupBy</td>
    <td>グループ化、ToLookupの遅延評価版(ただしストリーミングでの遅延評価ではない)</td>
  </tr>
  <tr>
    <td>GroupJoin</td>
    <td>右辺をグループにして結合、外部結合をしたい時にDefaultIfEmptyと合わせて使ったりもする</td>
  </tr>
  <tr>
    <td>Intersect</td>
    <td>積集合・共通の値だけ、集合なので重複は除去される</td>
  </tr>
  <tr>
    <td>Join</td>
    <td>内部結合</td>
  </tr>
  <tr>
    <td>Last</td>
    <td>最後の値を取得、ない場合は例外が発生</td>
  </tr>
  <tr>
    <td>LastOrDefault</td>
    <td>最後の値を取得、ない場合はデフォルト値を返す</td>
  </tr>
  <tr>
    <td>LongCount</td>
    <td>シーケンスの件数、longなので長い日も安心</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>最大値</td>
  </tr>
  <tr>
    <td>Min</td>
    <td>最小値</td>
  </tr>
  <tr>
    <td>OfType</td>
    <td>指定した型の値だけを返す、つまりWhereとisが組み合わさったようなもの</td>
  </tr>
  <tr>
    <td>OrderBy</td>
    <td>昇順に並び替え</td>
  </tr>
  <tr>
    <td>OrderByDescending</td>
    <td>降順に並び替え</td>
  </tr>
  <tr>
    <td>Range</td>
    <td>指定個数のintシーケンスの生成</td>
  </tr>
  <tr>
    <td>Repeat</td>
    <td>一つの値を繰り返すシーケンスの生成</td>
  </tr>
  <tr>
    <td>Reverse</td>
    <td>逆から列挙</td>
  </tr>
  <tr>
    <td>Select</td>
    <td>射影、関数の第二引数はインデックス</td>
  </tr>
  <tr>
    <td>SelectMany</td>
    <td>シーケンスを一段階平らにする、モナドでいうbind</td>
  </tr>
  <tr>
    <td>SequenceEqual</td>
    <td>二つのシーケンスを値で比較</td>
  </tr>
  <tr>
    <td>Single</td>
    <td>唯一の値を取得、複数ある場合は例外が発生</td>
  </tr>
  <tr>
    <td>SingleOrDefault</td>
    <td>唯一の値を取得、複数ある場合はデフォルト値を返す</td>
  </tr>
  <tr>
    <td>Skip</td>
    <td>指定個数だけ飛ばす</td>
  </tr>
  <tr>
    <td>SkipWhile</td>
    <td>条件が正のあいだ飛ばす</td>
  </tr>
  <tr>
    <td>Sum</td>
    <td>合計</td>
  </tr>
  <tr>
    <td>Take</td>
    <td>指定個数列挙、シーケンスの個数より多く指定した場合はシーケンスの個数分だけ</td>
  </tr>
  <tr>
    <td>TakeWhile</td>
    <td>条件が正のあいだ列挙</td>
  </tr>
  <tr>
    <td>ThenBy</td>
    <td>同順の場合のソートキーの指定、昇順に並び替え</td>
  </tr>
  <tr>
    <td>ThenByDescending</td>
    <td>同順の場合のソートキーの指定、降順に並び替え</td>
  </tr>
  <tr>
    <td>ToArray</td>
    <td>配列に変換</td>
  </tr>
  <tr>
    <td>ToDictionary</td>
    <td>辞書に変換</td>
  </tr>
  <tr>
    <td>ToList</td>
    <td>リストに変換</td>
  </tr>
  <tr>
    <td>ToLookup</td>
    <td>不変のマルチ辞書(一つのキーに複数の値を持つ)に変換</td>
  </tr>
  <tr>
    <td>Union</td>
    <td>和集合・両方の値全て、集合なので重複は除去される</td>
  </tr>
  <tr>
    <td>Where</td>
    <td>フィルタ</td>
  </tr>
  <tr>
    <td>Zip</td>
    <td>二つのシーケンスの結合、長さが異なる場合短いほうに合わされる</td>
  </tr>
</table>
<p>暗記する必要はなくて、なんとなくこういうのがあってこんな名前だったかなー、とぐらいに覚えておけば、IntelliSenseにお任せできるので、それで十分です。</p>
<p>リスト処理という観点からみるとLINQはかなり充実しているわけですが、更に他の言語と比較した場合の特色は、やはりクエリ構文。SelectManyへの構文は多くの言語が備えていますが(<a href="http://matarillo.com/general/monads.php">モナドの驚異</a>を参照のこと、LINQはLINM:言語統合モナドである、というお話)、SQLの構文をベースにしたJoin、GroupBy、OrderByへの専用記法は、意外と、というか普通に便利。</p>
<p>特にJoinはあってよかったな、と思います、インメモリで色々なところからデータ引っ張ってきて結合などすると特に。一つぐらいの結合なら別にメソッド構文でいいのですが、フツーのSQLと同じように大量のjoinを並べる場合に、クエリ構文じゃないとシンドい。インメモリからデータベースまで統一的な記法で扱える、ということの凄さを実感するところ。</p>
<p>といっても、普段はほとんどメソッド構文で書いてるんですけどねー。あくまで、込み入った状況になるときだけクエリ構文にしています。クエリ構文では表現できないものが結構多いわけで、わざわざ、これはクエリ構文だけで表現できるからクエリ構文にするかー、とか考えるのもカッタルイので。あと、単純にIntelliSenseでポコポコ打ってるほうが快適、というのもあります。</p>
<p>クエリ構文は、モナドへの記法というよりも、強力なリスト内包表記といった印象も、<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/list-comp/index.htm">HaskellへのOrder By, Group Byのペーパー</a>見て思ったりなんかしたりして。</p>
<h2>Ix</h2>
<p>Ix(Interactive Extensions)は<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>で、現在は実験的なものとして提供されている、Enumerableの拡張メソッド群。NuGetの<a href="http://nuget.org/List/Packages/Ix_Experimental-Main" title="NuGet gallery">Ix_Experimental-Main</a>で入れるのが使いやすい感じ。<a href="http://www.infoq.com/jp/news/2011/07/Ix">InfoQ: LINQ to Objectsのためのインタラクティブエクステンション</a>に解説が少し出ていましたが、少し不足していたり、間違っていたり(DoWhileとTakeWhileは一見似ていますが、挙動は全然異なるし、Forは別に全く興味深くなくSelectManyと同じです)したので、こちらの方が正しいです(ｷﾘｯ</p>
<table>
  <tr>
    <td>Buffer</td>
    <td>指定個数分に区切って配列で値を列挙</td>
  </tr>
  <tr>
    <td>Case</td>
    <td>引数のIDictionaryを元に列挙するシーケンスを決める、辞書に存在しない場合はEmpty</td>
  </tr>
  <tr>
    <td>Catch</td>
    <td>例外発生時に代わりに後続のシーケンスを返す</td>
  </tr>
  <tr>
    <td>Concat</td>
    <td>可変長引数を受け入れて連結する生成子、拡張メソッド版はシーケンスのシーケンスを平らにする</td>
  </tr>
  <tr>
    <td>Create</td>
    <td>getEnumeratorを渡し任意のIEnumerableを生成する、といってもEnumerator.Createがないため、あまり意味がない</td>
  </tr>
  <tr>
    <td>Defer</td>
    <td>シーケンスの生成をGetEumerator時まで遅延</td>
  </tr>
  <tr>
    <td>Distinct</td>
    <td>比較キーを受け入れるオーバーロード</td>
  </tr>
  <tr>
    <td>DistinctUntilChanged</td>
    <td>同じ値が続くものを除去</td>
  </tr>
  <tr>
    <td>Do</td>
    <td>副作用として各値にActionを適用し、値をそのまま列挙</td>
  </tr>
  <tr>
    <td>DoWhile</td>
    <td>一度列挙後に条件判定し、合致すれば再列挙</td>
  </tr>
  <tr>
    <td>Expand</td>
    <td>幅優先探索でシーケンスを再帰的に平らにする</td>
  </tr>
  <tr>
    <td>Finally</td>
    <td>列挙完了時に指定したActionを実行</td>
  </tr>
  <tr>
    <td>For</td>
    <td>SelectManyと一緒なので存在意義はない(Rxと鏡にするためだけに存在)</td>
  </tr>
  <tr>
    <td>ForEach</td>
    <td>foreach、関数の第二引数はインデックス</td>
  </tr>
  <tr>
    <td>Generate</td>
    <td>forループを模した初期値、終了判定、増加関数、値成形関数を指定する生成子</td>
  </tr>
  <tr>
    <td>Hide</td>
    <td>IEnumerable&lt;T&gt;に変換、具象型を隠す</td>
  </tr>
  <tr>
    <td>If</td>
    <td>条件が正なら指定したシーケンスを、負なら指定したシーケンス、もしくはEmptyで列挙する</td>
  </tr>
  <tr>
    <td>IgnoreElements</td>
    <td>後に続くメソッドに何の値も流さない</td>
  </tr>
  <tr>
    <td>IsEmpty</td>
    <td>シーケンスが空か、!Any()と等しい</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>IComparer&lt;T&gt;を受け入れるオーバーロード</td>
  </tr>
  <tr>
    <td>MaxBy</td>
    <td>指定されたキーで比較し最大値だった値を返す</td>
  </tr>
  <tr>
    <td>Memoize</td>
    <td>メモ化、複数回列挙する際にキャッシュされた値を返す</td>
  </tr>
  <tr>
    <td>Min</td>
    <td>IComparer&lt;T&gt;を受け入れるオーバーロード</td>
  </tr>
  <tr>
    <td>MinBy</td>
    <td>指定されたキーで比較し最小値だった値を返す</td>
  </tr>
  <tr>
    <td>OnErrorResumeNext</td>
    <td>例外が発生してもしなくても後続のシーケンスを返す</td>
  </tr>
  <tr>
    <td>Publish</td>
    <td>ShareとMemoizeが合わさったような何か</td>
  </tr>
  <tr>
    <td>Repeat</td>
    <td>無限リピート生成子、拡張メソッドのほうは列挙後に無限/指定回数最列挙</td>
  </tr>
  <tr>
    <td>Retry</td>
    <td>例外発生時に再度列挙する</td>
  </tr>
  <tr>
    <td>Return</td>
    <td>単一シーケンス生成子</td>
  </tr>
  <tr>
    <td>Scan</td>
    <td>Aggregateの算出途中の値も列挙する版</td>
  </tr>
  <tr>
    <td>SelectMany</td>
    <td>引数を使わず別のシーケンスに差し替えるオーバーロード</td>
  </tr>
  <tr>
    <td>Share</td>
    <td>列挙子を共有</td>
  </tr>
  <tr>
    <td>SkipLast</td>
    <td>後ろからn個の値をスキップ</td>
  </tr>
  <tr>
    <td>StartWith</td>
    <td>先頭に値を連結</td>
  </tr>
  <tr>
    <td>TakeLast</td>
    <td>後ろからn個の値だけを列挙</td>
  </tr>
  <tr>
    <td>Throw</td>
    <td>例外が発生するシーケンス生成子</td>
  </tr>
  <tr>
    <td>Using</td>
    <td>列挙完了後にDisposeするためのシーケンス生成子</td>
  </tr>
  <tr>
    <td>While</td>
    <td>列挙前に条件判定し合致したら列挙し、終了後再度条件判定を繰り返す生成子</td>
  </tr>
</table>
<p>みんな実装したことあるForEachが載っているのが一番大きいのではないでしょうか。別に自分で実装するのは簡単ですが、公式に(といってもExperimental Releaseですが)あると、全然違いますから。なお、何故ForEachが標準クエリ演算子にないのか、というのは、<a href="http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx">“foreach” vs “ForEach” - Fabulous Adventures In Coding</a>によれば副作用ダメ絶対とのことで。納得は……しない。</p>
<p>Ixに含まれるメソッドは標準クエリ演算子では「できない」もしくは「面倒くさい」。Ixを知ることは標準だけでは何ができないのかを知ること。何ができないのかを知っていれば、必要な局面でIxを使うなり自前実装するなりといった対応がすぐに取れます、無理に標準クエリ演算子をこねくり回すことなく。例えばBufferやExpandは非常に有益で、使いたいシチュエーションはいっぱいあるんですが、標準クエリ演算子ではできないことです。</p>
<p>While, DoWhileとTakeWhileの違いは条件判定する箇所。While,DoWhileは列挙完了前/後に判定し、判定がtrueならシーケンスを再び全て列挙する。TakeWhileは通る値で毎回判定する。</p>
<p>PublishとMemoizeの違いは難解です。Memoizeは直球そのままなメモ化なんですが、Publishが凄く説明しづらくて……。Enumerator取得まではShareと同じく列挙子の状態は共有されてるんですが、取得後はMemoizeのようにキャッシュした値を返すので値の順番は保証される、といった感じです。うまく説明できません。</p>
<p>存在意義が微妙なものも、それなりにありますね。例えばIfとCaseとForなどは、正直、使うことはないでしょう。Usingも、これを使うなら別メソッドに分けて、普通にusing + yield returnで書いてしまうほうが良いと私は考えています。</p>
<p>Ixを加えると、ほとんど全てをLINQで表現出来るようになりますが、やりすぎて解読困難に陥ったりしがちなのには少し注意を。複雑になるようならベタベタ書かずに、一定の塊にしたものを別メソッドに分ければいいし、分けた先では、メソッドを組み合わせるよりも、yield returnで書いたほうが素直に表現出来るかもしれません。</p>
<p>適切なバランス感覚を持って、よきLINQ生活を！</p>
<h2>linq.js</h2>
<p>LINQ to ObjectsのJavaScript実装である<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript">linq.js</a>にも、標準クエリ演算子の他に(作者の私の趣味で)大量のメソッドが仕込んであるので、せっかくなのでそれの解説も。標準クエリ演算子にあるものは省きます(挙動は同一なので)。また、C#でIEqualityComparer&lt;T&gt;を受け取るオーバーロードは、全てキーセレクター関数のオーバーロードに置き換えられています。</p>
<p>一行サンプルと実行は<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>のほうをどうぞ。</p>
<table>
  <tr>
    <td>Alternate</td>
    <td>値の間にセパレーターを織り込む、HaskellのIntersperseと同じ</td>
  </tr>
  <tr>
    <td>BufferWithCount</td>
    <td>IxのBufferと同じ、次のアップデートでBufferに改称予定</td>
  </tr>
  <tr>
    <td>CascadeBreadthFirst</td>
    <td>幅優先探索でシーケンスを再帰的に平らにする、IxのExpandと同じ</td>
  </tr>
  <tr>
    <td>CascadeDepthFirst</td>
    <td>深さ優先探索でシーケンスを再帰的に平らにする</td>
  </tr>
  <tr>
    <td>Catch</td>
    <td>IxのCatchと同じ</td>
  </tr>
  <tr>
    <td>Choice</td>
    <td>引数の配列、もしくは可変長引数をランダムに無限に列挙する生成子</td>
  </tr>
  <tr>
    <td>Cycle</td>
    <td>引数の配列、もしくは可変長引数を無限に繰り返す生成子</td>
  </tr>
  <tr>
    <td>Do</td>
    <td>IxのDoと同じ</td>
  </tr>
  <tr>
    <td>Finally</td>
    <td>IxのFinallyと同じ</td>
  </tr>
  <tr>
    <td>Flatten</td>
    <td>ネストされた配列を平らにする</td>
  </tr>
  <tr>
    <td>Force</td>
    <td>シーケンスを列挙する</td>
  </tr>
  <tr>
    <td>ForEach</td>
    <td>IxのForEachと同じ</td>
  </tr>
  <tr>
    <td>From</td>
    <td>配列やDOMなど長さを持つオブジェクトをEnumerableに変換、linq.jsの要の生成子</td>
  </tr>
  <tr>
    <td>Generate</td>
    <td>ファクトリ関数を毎回実行して値を作る無限シーケンス生成子、IxのGenerateとは違う(IxのGenerateはUnfoldで代用可)</td>
  </tr>
  <tr>
    <td>IndexOf</td>
    <td>指定した値を含む最初のインデックス値を返す</td>
  </tr>
  <tr>
    <td>Insert</td>
    <td>指定したインデックスの箇所に値を挿入、Insert(0, value)とすればIxのStartWithと同じ</td>
  </tr>
  <tr>
    <td>LastIndexOf</td>
    <td>指定した値を含む最後のインデックス値を返す</td>
  </tr>
  <tr>
    <td>Let</td>
    <td>自分自身を引数に渡し、一時変数を使わず自分自身に変化を加えられる</td>
  </tr>
  <tr>
    <td>Matches</td>
    <td>正規表現のマッチ結果をシーケンスとして列挙する生成子</td>
  </tr>
  <tr>
    <td>MaxBy</td>
    <td>IxのMaxByと同じ</td>
  </tr>
  <tr>
    <td>MemoizeAll</td>
    <td>IxのMemoizeと同じ、次のアップデートでMemoizeに改称予定</td>
  </tr>
  <tr>
    <td>MinBy</td>
    <td>IxのMinByと同じ</td>
  </tr>
  <tr>
    <td>Pairwise</td>
    <td>隣り合う要素とのペアを列挙</td>
  </tr>
  <tr>
    <td>PartitionBy</td>
    <td>キーで指定した同じ値が続いているものをグループ化する</td>
  </tr>
  <tr>
    <td>RangeDown</td>
    <td>指定個数のマイナス方向数値シーケンス生成子</td>
  </tr>
  <tr>
    <td>RangeTo</td>
    <td>指定した値まで(プラス方向、マイナス方向)の数値シーケンス生成子</td>
  </tr>
  <tr>
    <td>RepeatWithFinalize</td>
    <td>単一要素の無限リピート、列挙完了時にその要素を受け取る指定した関数を実行</td>
  </tr>
  <tr>
    <td>Return</td>
    <td>IxのReturnと同じ</td>
  </tr>
  <tr>
    <td>Scan</td>
    <td>IxのScanと同じ</td>
  </tr>
  <tr>
    <td>Share</td>
    <td>IxのShareと同じ</td>
  </tr>
  <tr>
    <td>Shuffle</td>
    <td>シーケンスをランダム順に列挙する</td>
  </tr>
  <tr>
    <td>TakeExceptLast</td>
    <td>IxのSkipLastと同じ</td>
  </tr>
  <tr>
    <td>TakeFromLast</td>
    <td>IxのTakeLastと同じ</td>
  </tr>
  <tr>
    <td>ToInfinity</td>
    <td>無限大までの数値シーケンス生成子</td>
  </tr>
  <tr>
    <td>ToJSON</td>
    <td>シーケンスをJSON文字列に変換(組み込みのJSON関数のあるブラウザかjson2.jsの読み込みが必要)</td>
  </tr>
  <tr>
    <td>ToNegativeInfinity</td>
    <td>マイナス無限大までの数値シーケンス生成子</td>
  </tr>
  <tr>
    <td>ToObject</td>
    <td>JSのオブジェクトに変換</td>
  </tr>
  <tr>
    <td>ToString</td>
    <td>文字列として値を連結</td>
  </tr>
  <tr>
    <td>Trace</td>
    <td>console.logで値をモニタ</td>
  </tr>
  <tr>
    <td>Unfold</td>
    <td>Aggregateの逆、関数を連続適用する無限シーケンス生成子</td>
  </tr>
  <tr>
    <td>Write</td>
    <td>document.writelnで値を出力</td>
  </tr>
  <tr>
    <td>WriteLine</td>
    <td>document.writeln + &lt;br /&gt;で値を出力</td>
  </tr>
</table>
<table>
  <tr>
    <td>TojQuery</td>
    <td>シーケンスをjQueryオブジェクトに変換</td>
  </tr>
  <tr>
    <td>toEnumerable</td>
    <td>jQueryの選択している複数の要素を単一要素のjQueryオブジェクトにしてEnumerableへ変換</td>
  </tr>
  <tr>
    <td>ToObservable</td>
    <td>引数のSchduler上で(デフォルトはCurrentThread)Observableへ変換</td>
  </tr>
  <tr>
    <td>ToEnumerable</td>
    <td>Cold ObservableのみEnumerableへ変換</td>
  </tr>
</table>
<p>Ixと被るものもあれば、そうでもないものも。ToStringなどは分かりやすく便利でよく使うのではかと。ToJSONもいいですね。Fromは拡張メソッドのない/prototype汚染をしないための、JavaScriptだけのためのメソッド。Matchesは地味に便利です、JSの正規表現は使いやすいようでいて、マッチの列挙はかなり面倒くさいので、そこを解消してくれます。linq.jsは移植しただけ、ではあるんですが、同時に移植しただけではなくて、JavaScriptでLINQはどうあるべきか、どうあると便利なのか、という考えに基づいて調整されています。</p>
<p>JavaScriptにはyield returnがないので(Firefoxにはyieldありますが)、シーケンスは全て演算子の組み合わせだけで表現できなければならない。というのが、手厚くメソッドを用意している理由でもあります。これだけあれば何だって作れるでしょう、きっと多分恐らく。</p>
<h2>まとめ</h2>
<p>これで今日からLINQ to Objectsマスター。Rx版もそのうち書きます(以前に<a href="http://neue.cc/2010/07/28_269.html" title="neue cc - Reactive Extensions入門 + メソッド早見解説表">Reactive Extensions入門 + メソッド早見解説表</a>を書きましたが、今は結構変わってしまいましたからね)。</p>
</div>
<h1 data-pagefind-sort="date:2011-08-03" data-pagefind-meta="published:2011-08-03"><a href="https://neue.cc/2011/08/03_336.html">ToArray vs ToList</a></h1>
<ul class="date"><li>2011-08-03</li></ul>
<div class="entry_body"><p>LINQの結果は遅延評価なので、その場で全部評価して欲しかったりする場合などに使うToArrayとToList。どちらを使っていますか？私はToArrayのほうが好みです。と、いうのも、LINQで書く以上、長さは決まったようなものなので、これ以上AddやRemoveしたいことなんてほとんどない。勿論、必ずないとは言いませんので、その場合だけToListを使いますが、そうでない場合は、長さが固定だという意図を示すためにもToArrayが好ましい。</p>
<h2>パフォーマンス</h2>
<p>T[]やList&lt;T&gt;に変換されたあとだと、T[]のほうが、大体においてパフォーマンスは良い。という点でもToArrayがいいかなあ、と思うわけですが、それはさておき、ではToArrayとToListメソッドそれ自体のパフォーマンスはどちらのほうが良いでしょうか？理屈の上ではToListのほうが上です。というのも、変換処理は下記の図のようになっているからです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/toarraytolist.jpg">
</p>
<p>元ソースがIEnumerable&lt;T&gt;である以上、長さは分からないので、ToArrayでも動的配列としていっぱいになったら二倍に拡大する、という動作を行うのはToListと変わりありません。この辺の話は<a href="http://chasen.org/%7Etaku/blog/archives/2007/02/_o1.html" title="きまぐれ日記: 動的配列への追加コストはなぜ O(1)?">動的配列への追加コストはなぜ O(1)?</a>や、<a href="http://www.kmonos.net/wlog/111.html#_2334100705" title="d.y.d.">２倍だけじゃない</a>を参考に。.NETは2倍です。そして、最後に拡大された配列の長さを整えるためコピーするのがToArray、そのまま渡すのがToList。つまり、ToArrayのほうが最後の一回のコピー動作が増えているわけです。</p>
<p>でも、ベンチマークをとると、ToArrayのほうが速かったりします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 適当さ溢れている（若干恣意的な）測り方なので、それはそれとしてくだしあ
// ToArray:00:00:01.5002685
// ToList :00:00:01.8124284
var source = Enumerable.Range(1, 100000000);

var sw = Stopwatch.StartNew();
source.ToArray();
Console.WriteLine(&quot;ToArray:&quot; + sw.Elapsed);
GC.Collect();
sw.Restart();
source.ToList();
Console.WriteLine(&quot;ToList:&quot; + sw.Elapsed);
</code></pre>
<p>へー、ToArrayのほうが速いんだー、ではなくて、要素数1億件でこの程度しかでないので、どうでもいい程度の差でしかないということです。ここ注意。こういう適当なマイクロベンチのマイクロな差で、こっちのほうが速いからこうしなければならない、これが最適化のための10箇条、みたいなことをやるのは間抜けだと思います。JavaScriptにはそういう記事があまりにも多すぎるとも思っています。</p>
<p>それはともかく、何で理屈の上ではコピーが多いToArrayのほうが&quot;速い&quot;のか。それは中身をゴニョゴニョしてみてみれば分かりますが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static List&lt;T&gt; ToList&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    // ICollection&lt;T&gt;の場合はnew List&lt;T&gt;(source)の中で最適化されてます
    // 最適化されない場合はforach(var item in source) this.Add(item) という感じ
    return new List&lt;T&gt;(source)
}

// 実際のコードとは違います、あくまでイメージです
public static T[] ToArray&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    // ICollection&lt;T&gt;の場合はCopyToで最適化
    var collection = source as ICollection&lt;T&gt;;
    if (collection!= null)
    {
        var dest = new T[collection.Count];
        collection.CopyTo(dest, 0);
        return dest;
    }

    // そうでないなら列挙して配列を伸ばしながら作る
    var array = new T[4];
    var count = 0;
    foreach (var item in source)
    {
        if (array.Length == count)
        {
            var dest = new T[count * 2];
            Array.Copy(array, dest, count);
            array = dest;
        }
        array[count++] = item;
    }

    // 生成したものと長さが同じならそのまま返す
    if (array.Length == count) return array;

    // そうでないなら長さを整えてから返す
    var result = new T[count];
    Array.Copy(array, result, count);
    return result;
}
</code></pre>
<p>これだけだとよくわからない？うーん、そうですね。ToArrayの場合は配列を作る、それだけに最適化されていて余計なコードが一切ありません。反面、ToList、というかnew List&lt;T&gt;(source)は、内部では少し色々なものの呼び出し回数が多かったりしています。その辺のことが、コピー回数以上に「ほんの少しだけ」速度の差を生んでいるのではないかな、ということのようです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// パフォーマンスを一切考えないのならこれでいいのよね
public static T[] ToArray&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    // 実際はreturn new Buffer&lt;T&gt;(source).ToArray();
    return new List&lt;T&gt;(source).ToArray();
}
</code></pre>
<p>理屈的にはこれでいいわけですが、実際はBuffer&lt;T&gt;クラスというものをinternalでもっていて、それはLINQで使うためだけに余計なものが一切ない動的配列で、LINQ to Objectsの各メソッドは、動的配列が必要な場合ではList&lt;T&gt;ではなく、そのBuffer&lt;T&gt;クラスを使っています。DRYはどうした、という気は少しだけしますが、まあ、ユーザーとしては速いに越したことはないです。</p>
<h2>Array.Copy</h2>
<p>ところで、Array.CopyやICollection&lt;T&gt;のCopyToって面倒くさいですよね、長さを持った空の配列を作って、渡さなければならないって。と、<a href="http://d.hatena.ne.jp/fezg00/20110802/1312267034" title="Array Copy - Memo+">Array Copy - Memo+</a>の記事を見て改めて思いましたが、しかし、一番よくあるケースである一次元配列のコピーならToArrayを使えばOKです。↑の実装イメージであるように、ちゃんとis asで判定して最適化してくれているので、LINQだとforeachで全部舐めるから遅いんじゃないかなー、と考えなくても大丈夫。</p>
<h2>まとめ</h2>
<p>今日、Twitterで間違ったこと投稿しちゃって恥ずかすぃかったので反省して書いた。まる。とりあえずToArray使えばいいです。</p>
</div>
<h1 data-pagefind-sort="date:2011-07-27" data-pagefind-meta="published:2011-07-27"><a href="https://neue.cc/2011/07/27_335.html">Deep Dive AsEnumerable</a></h1>
<ul class="date"><li>2011-07-27</li></ul>
<div class="entry_body"><p>AsEnumerable、といったらLINQのAsEnumerableです。その挙動は、IEnumerable&lt;T&gt;へと型変換をします。それだけ、なので実に影が薄いのですが、それでいて奥深く使いこなしが求められる、はずなのですが陰が薄いので無視されている感がなきにしもあらずなので、しっかりと紹介したいと思います。</p>
<h2>AsEnumerableの実装</h2>
<p>実装は非常に単純明快で、中身ほとんど空っぽです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;T&gt; AsEnumerable&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    return source;
}
</code></pre>
<p>ようするにアップキャストです。どういう時に使えばいいかというと、例えば可変長引数とIEnumerable&lt;T&gt;の両方を受けたいオーバーロードを作る場合。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Show(params string[] values)
{
    Show(values.AsEnumerable());
}

public void Show(IEnumerable&lt;string&gt; values)
{
    foreach (var item in values)
    {
        Console.WriteLine(item);
    }
}
</code></pre>
<p>foreachでグルグル値を取り出すだけなので、IEnumerable&lt;T&gt;で受けるようにしたい。でも利便性のため可変長引数も用意しておきたい。という場合はよくあります。なので毎回このオーバーロードを用意するんですが、その時に、こうしてAsEnumerableを使います。なお、AsEnumerableを忘れると無限に再帰してStackOverflowしてしまいます……。</p>
<p>AsEnumerableがラップするのではなく、ただのアップキャストにすぎないということは重要です。以前に<a href="http://neue.cc/2009/07/21_178.html" title="neue cc - LinqとCountの効率">LinqとCountの効率</a>でも書きましたが、LINQの一部のメソッドはIList&lt;T&gt;であったりICollection&lt;T&gt;であるとき、asやisを使って最適化を図ります。foreachするだけだとあまり関係ないですが、受け取ったIEnumerable&lt;T&gt;を使ってLINQで処理する場合だと、このことが効いてきます。</p>
<p>ならば常にアップキャストでよくて、ラップなど必要ないのではないか？というと必ずしもそうではありません。アップキャストは、ダウンキャストを可能にします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// アップキャストされている状態というのは
var numbers = new List&lt;int&gt;().AsEnumerable();

// ダウンキャストが可能にするということ、そして、ダウンキャストは危険
var list = (List&lt;int&gt;)numbers;
</code></pre>
<p>ダウンキャストが危険だ、やるな、というのなら、そもそもアップキャストをすべきではない。抽象で受けることこそがオブジェクト指向だとか、形だけのパターンにはまってるとそうなる。原則は比較的シンプルで。メソッドのシグネチャにおいて、引数の型は最大に受け入れるため出来る限り抽象で、戻り値の型は最大に利用出来るようにするため具象にすればいい。ローカル変数に関しては、原則varでよし。どうしても必要ならば、ローカル変数側、つまりメソッドの利用側が安全なアップキャストで適宜、抽象で受ければよいでしょう。</p>
<p>ダウンキャストはダメ基本的に。そして、ダウンキャストは可能な状態にすること自体がダメなので、アップキャストも最小限に。というのがメソッド定義の基本だと思っていますが、プロパティだと少し事情は変わってくるかも。一々ラップすることのパフォーマンスロスや手間を考えると、しかたがなくアップキャストで提供するのも、ありかなー、とは。</p>
<h2>Hide</h2>
<p>そんなわけで、具象型を消去して、完全にラップしてIEnumerable&lt;T&gt;として提供したいという場合もあるかと思います。そこで、Ix(Interactive Extensions、<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>のオマケで提供されているEnumerableの拡張メソッド群、NuGetの<a href="http://nuget.org/List/Packages/Ix_Experimental-Main" title="NuGet gallery">Ix_Experimental-Main</a>で入れるのが手っ取り早い。Experimentalのとおり、まだ実験的な代物で保証されていないことは注意)にはHideというものがあります。これも実装は単純明快で</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;T&gt; Hide&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    foreach (var item in source)
    {
        yield return item;
    }
}
</code></pre>
<p>といった形。Hideというメソッド名は具体的な型を隠す、といった意味合いで付けられているのでしょうね。</p>
<h2>Rx(AsObservable)の場合</h2>
<p>Enumerableと関連性の深いObservable、Rxにも同様に型変換をするAsObservableというメソッドが用意されています。主に使うシチュエーションは、Subjectの隠蔽をするときでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 5秒後に非同期で値を返すというだけのもの
public static IObservable&lt;T&gt; SendValueAfter5Seconds&lt;T&gt;(T value)
{
    var asyncSubject = new AsyncSubject&lt;T&gt;();

    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        Thread.Sleep(TimeSpan.FromSeconds(5)); // とりまsleep

        asyncSubject.OnNext(value); // AsyncSubjectのキャッシュへ値送信
        asyncSubject.OnCompleted(); // 非同期処理完了の合図（ここでObserverに値が送られる）
    });

    return asyncSubject.AsObservable();
}
</code></pre>
<p>このコード自体には何の意味もありません、非同期処理を模して、スレッドプールで5秒待って値を送る、というだけです。大事なのはAsyncSubjectをAsObservableして返していること。このAsObservableはただのアップキャストではなく、新しい型でラップして具象型(AsyncSubject)を隠しています。つまり、AsEnumerableではなくHideに等しい挙動です。ここで、もしAsObservableを書いていないと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// return時にAsObservableが書かれていないとダウンキャスト可能になる
var subject = (AsyncSubject&lt;int&gt;)SendValueAfter5Seconds(100);

subject.Subscribe(Console.WriteLine);

// なので、外側から発火可能になってしまう、これは最悪
subject.OnNext(-1);
subject.OnCompleted(); 
</code></pre>
<p>Subject（標準だと4種類ある）は、Rxにおけるイベントの表現です。C#でのイベントは、内部からは発火可能、外側からは購読しかできない。というようになっていると思います。その挙動にするために、また、純粋に安全性のために、Subjectを購読させるために外側に出す場合は、AsObservableでラップして型を消さなければなりません。</p>
<p>※極初期(RxがReactive Frameworkと言われていた頃なぐらいに前)は、このAsObservableはHideというメソッド名でした。AsObservableのほうが分かりやすくて良いとは思いますが、Enumerableでの挙動と合わせるなら、キャストするだけのAsObservableとHideに分けるべきだったのでは？と思わなくは全くないです←Rxにおいてはただのキャストしただけのものは使う機会ないと思うので、現在の形で正解</p>
<h2>IQueryableにおけるAsEnumerableの重要性</h2>
<p>Enumerable、Observableと来たので、QueryableでのAsEnumerableも見てみましょう。QueryableにおけるAsEnumerableは、クエリ構築の終了です。IQueryableでのクエリ構築をそこで打ち切るというスイッチです。どういうことか、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// とあるContextによるQueryableはSkipWhileとCountをサポートしていなかったとします
var count = toaru.createContext() // IQueryeable&lt;T&gt;とする
    .Where(x =&gt; x % 2 == 0)
    .SkipWhile(x =&gt; x &lt; 100)
    .Count(); // 未サポートなのでExceptionが来る！

// そういう場合、ToListするといい、というアドバイスがよく上がります
var count = toaru.createContext()
    .Where(x =&gt; x % 2 == 0)
    .ToList() // ここまでの式でクエリ生成+List化
    .SkipWhile(x =&gt; x &lt; 100) // ここからはIEnumerable&lt;T&gt;
    .Count();

// でも、それならAsEnumerableでいいんだよ？
var count = toaru.createContext()
    .Where(x =&gt; x % 2 == 0)
    .AsEnumerable() // 後続がGetEnumeratorを呼んだ時にここまででクエリ生成
    .SkipWhile(x =&gt; x &lt; 100) // ここからはIEnumerable&lt;T&gt;
    .Count();
</code></pre>
<p>Queryableの連鎖で、例えばLinq to SqlだったらSQL文を作っていきます。で、foreachであったりToListであったりをすると、SQLが作られて発行されてデータベースと通信されて。それって、どのタイミングでQueryableの中の式木がSQL文に変換されるかというと、GetEnumeratorが呼ばれた時、です。それはいつ呼ばれるの？というと、foreachされたりToListされたり、AsEnumerableしてその後のEnumerableのメソッドがGetEnumeratorを呼んだ、その時。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/quaryable_getenumerator_enumerable.jpg">
</p>
<p>こんな感じです。ToArrayやToListは、そこで実体化するので、メソッドチェーンの後続がIEnumerable&lt;T&gt;なのは当然のことですが、AsEnumerableがただのキャストにすぎないのに意味合いが変化するのは、拡張メソッドの解決の優先度のため。型がIQueryable&lt;T&gt;の状態だとWhereやSelectはQueryableのWhereやSelectが選択されますが、型がIEnumerable&lt;T&gt;の状態だとEnumerableのWhereやSelectが選択される、ということです。Enumerable自体は遅延評価なので、後続のIEnumerable&lt;T&gt;がGetEnumeratorを呼び出したときに評価が開始されるのは変わらず。</p>
<p>AsEnumerableやToArray、ToListは実はQueryableクラスにはありません。なので、素の状態で拡張メソッドの解決がIEnumerable&lt;T&gt;側を呼び出すようになっています。</p>
<p>ところでクエリ文の構築はGetEnumeratorが呼ばれた時と言いましたが、GetEnumeratorを呼ばないとき、例えばQueryableでのFirstやSumはどうなっているのかというと、内部でExecuteが呼ばれた時です。IQueryProviderはこんなインターフェイス。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IQueryProvider
{
    IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression);
    TResult Execute&lt;TResult&gt;(Expression expression);
    // 非ジェネリックなものもありますが省略
}
</code></pre>
<p>FirstやSumなど、単独の結果を返すものは内部でExecuteを呼びます。なので、クエリプロバイダの実装次第ですが、通常はこのExecuteが呼ばれた時にクエリ文の構築と実行を同時に行うものと思われます。SelectやWhereなど、後続にIQueryableのチェーンを繋げるものは、内部でCreateQueryのほうを呼びます。そして最終的に複数の結果(IEnumerable&lt;T&gt;)を返す場合は、GetEnumeratorが呼ばれた時にクエリ文の構築と実行を行うものと思われます。</p>
<h2>まとめ</h2>
<p>AsEnumerableは、ようするにただのキャストなだけですが、その果たしている役割というものを考えると非常に深い。その割には(QueryableでToListばかり使われたりと)今ひとつ知名度に欠ける気もしますので、ドサッと紹介を書いてみました。ただのキャストだって語ろうと思えば幾らでも語れるLINQは素敵ですね！</p>
</div>
<h1 data-pagefind-sort="date:2011-07-25" data-pagefind-meta="published:2011-07-25"><a href="https://neue.cc/2011/07/25_334.html">DynamicObjectでより沢山の型情報を取る方法</a></h1>
<ul class="date"><li>2011-07-25</li></ul>
<div class="entry_body"><p><a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>のAsDynamicに少し不具合があったので、ver.1.5.0.0として更新しました。今まではメソッドの引数にnullを渡すと死んでました。ぬるぽ！まあしかし、引数そのもののからしかTypeが取れなかったので、nullだと、どのみちメソッドを特定するための型情報がないからオーバーロードの解決は不可能なので、仕様ですよ仕様、という言い訳。</p>
<p>などとふざけたことを思っていたのですけれど、コンパイル時に決定される引数の型を取り出す方法が判明したので、そのへんも含めて完全に解決しました。やったね。その方法は、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
{
    var csharpBinder = binder.GetType().GetInterface(&quot;Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder&quot;);
    if (csharpBinder == null) throw new ArgumentException(&quot;is not csharp code&quot;); // CSharpコードではない

    // ジェネリックの型引数の取得(Hoge&lt;T&gt;(1, t)とかでのTのこと)
    var typeArgs = (csharpBinder.GetProperty(&quot;TypeArguments&quot;).GetValue(binder, null) as IList&lt;Type&gt;).ToArray();
    // コンパイル時に決定されているパラメータの型の取得
    var parameterTypes = (binder.GetType().GetField(&quot;Cache&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(binder) as Dictionary&lt;Type, object&gt;)
        .First()
        .Key
        .GetGenericArguments()
        .Skip(2)
        .Take(args.Length)
        .ToArray();
    
    // それらの情報からMethodInfoを特定する
    var method = MatchMethod(binder.Name, args, typeArgs, parameterTypes);
    // 呼び出し
    result = method.Invoke(target, args);

    return true; // 呼べてれば必ずTrueなので。
}
</code></pre>
<p>……。ひどそうな匂いが！まず、素のままでは情報が足りなすぎるので、基本的にリフレクション全開です。その中でも、parameterTypesが今回追加したところです。binderのCacheに、CallSiteのデリゲート(dynamicを使って呼び出すと、コンパイル時にこの辺のものが自動生成される)があるので、そこから型情報を持ってこれることに気づいたのだ(ｷﾘｯ</p>
<p>もう少し詳しく説明しますと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// このヘンテツもないどうでもいいコードは
dynamic d = null;
var result = d.Hoge&lt;string, int&gt;(100, (string)null, (ICollection&lt;int&gt;)null);

// コンパイル後はこんな結果に化けちゃいますあら不思議！
object d = null;
if (Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1 == null)
{
	Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1 = CallSite&lt;Func&lt;CallSite, object, int, string, ICollection&lt;int&gt;, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.None, &quot;Hoge&quot;, new Type[]
	{
		typeof(string), 
		typeof(int)
	}, typeof(Program), new CSharpArgumentInfo[]
	{
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null)
	}));
}
object result = Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1.Target(Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1, d, 100, null, null);
</code></pre>
<p>細かい部分はどうでもいいので、良く分からないFuncが生成されてるんだな、というとこだけ見てもらえれば。さて、これを頭に入れた上で、DynamicObjectのTryInvokeMemberでbinderの奥底のCacheを探してみると、</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/binder_cache.jpg">
</p>
<p>このFunc6というものが、Func&lt;CallSite, object, int, string, ICollection&lt;int&gt;, object&gt;です、発見出来ました！これの型引数が、コード上での呼び出し時の型引数になるわけです。なお、第一引数はCallSite、第二引数はインスタンスなので無視してSkip(2)、そして引数の個数分だけTake(まあ、ようするに最後が戻り値の型なわけですが)。</p>
<p>というわけで、実際に改善されたAsDynamicを使ってみますと、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな何のヘンテツもないオーバーロードのあるクラスがあるとして
public class PrivateClass
{
    private string Hoge(IEnumerable&lt;int&gt; xs)
    {
        return &quot;enumerable&quot;;
    }

    private string Hoge(List&lt;int&gt; xs)
    {
        return &quot;list&quot;;
    }
}

// 型はdynamicです←意地でもvarで書きたい人
var mock = new PrivateClass().AsDynamic();

// 型でオーバーロード分けが出来るようになった！
List&lt;int&gt; list = new List&lt;int&gt;();
IEnumerable&lt;int&gt; enumerable = new List&lt;int&gt;();

(mock.Hoge(list) as string).Is(&quot;list&quot;);
(mock.Hoge(enumerable) as string).Is(&quot;enumerable&quot;);
</code></pre>
<p>というわけで、より正確なオーバーロードの解決が図れるようになりました。何をアタリマエのことを言ってるんだお前は、と思うかもしれませんが、TryInvokeMemberに渡ってくる情報はobject[] argsなのです。args[0]の型はobjectなわけで、それをGetTypeしたら、出てくるのはList&lt;int&gt;なのです。何をどうやっても、.csファイルではIEnumerable&lt;int&gt;と書かれているという情報を得ることは出来なかったわけです、今までは。ましてやnullだったら型もヘッタクレもなかったわけです。でもこれからは違う。コード上のデータが取れる！</p>
<p>などとツラツラと書いてみましたが、利用者的にはどうでもいい話ですね、はい。それに、リフレクションはいいとしても、Cacheって何よ？CacheのFirstが決め打ちなのって何よ？などなどは、ぶっちゃけよくわかっていなくて(だって全部internalだしね……)若干怖いのですが、まあ、多分、大丈夫でしょう、多分……。それと、まだ完璧じゃあなくてサポートしてないオーバーロードのケースが幾つかあります。とはいえ、ほとんどのシチュエーションでは問題ないのではかと思います。</p>
<h2>まとめ</h2>
<p>この<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>ですが、私は結構普通に使いまくっていて、ないと死にます。激しく便利。そうそう、紹介しますと、 actual.Is(expected) と、メソッドチェーン形式で流れるようにアサーションが書けます。ラムダ式での指定やコレクションへの可変長引数など、ちょうどかゆいところに手が届く拡張を施してあって、随分とテストを書くのが楽になります。</p>
<p>AsDynamicは、オマケ機能というか。privateなメソッドやプロパティ、フィールドにもdynamicを通してアクセス出来るように変換します。たまにしか使いませんが（MSTestにはPrivate Accessorがあるので）、あると便利よね、という時もそこそこあり。</p>
<p>MSTestだけではなく、NUnitやMbUnit、xUnit.NETでも使えますので＆NuGet経由でも入れられますので、一度是非お試しを。</p>
</div>
<h1 data-pagefind-sort="date:2011-07-09" data-pagefind-meta="published:2011-07-09"><a href="https://neue.cc/2011/07/09_333.html">非同期の再帰的な辿り方、或いはRxとC# 5.0 Asyncの連携について</a></h1>
<ul class="date"><li>2011-07-09</li></ul>
<div class="entry_body"><p>例えば、ページを辿る。何度もアクセスを繰り返して、辿る。非同期で。単純なようで、やってみると何気にこれが結構難しい。例としてコードレシピの<a href="http://code.msdn.microsoft.com/Reactive-ExtensionsTwitter-b8238b51">Reactive Extensionsを使用してTwitterから非同期にデータを取得し表示する</a>がありました。MVVMも絡めて、素晴らしいサンプルですね！</p>
<p>というわけで、お題を拝借して、Twitter ApiのGET statuses/friendsを使わせて頂きます。んが、今回は、手を抜いてフォロワーのscreen_name(@hogehogeのhogehogeの部分)だけを取れれば良い、ということにします。JSON解析やデシリアライズも面倒だし話の本題でもないので省略するため、<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を使って、JSONを生のまんまっぽく扱うことにします。DynamicJsonは便利だなあ（棒）</p>
<p>さて、まずTwitter APIのcursorですが、大体こんな風になっています。目的はカーソルを辿って全てのuser(に含まれるscreen_name)を集めること。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/twitter_nextcursor.jpg">
</p>
<p>JSON取得毎にnext_cursor_strという、次のページへのIDが取れるので、それを辿っていって、0が出たらページ末尾。といった具合です。next_cursor_strの値は一見ランダムに見える整数(2121409421とかそんな値になっている)であり、next_cursorという数字のものもあるのに、_strという文字列として得られるほうを使っています。何故かというと、<a href="http://d.hatena.ne.jp/tmyt/20101201/1291166929">TwitterのステータスIDが53bitを越えたお話 - tmytのらくがき</a>を参照ください。DynamicJsonでは数字(Number)はdoubleとして扱うので、_strのほうを使わないと、危ういわけです。</p>
<p>まあ、ただのお題で本題な話ではないので、その辺は深く考えずそういうものなのだなあ、ぐらいで。</p>
<h2>同期とyield returnと非同期</h2>
<p>コードレシピのサンプルを見させて頂いたのですが、ネットワークアクセス部分がOpenReadなので、非同期&quot;ではない&quot;です。でも挙動は非同期だよ？というのは、Scheduler.ThreadPoolを使っているからなわけですが、つまるところ挙動的にはBackgroundWorkerを使って非同期にするのと同じことです。その場合ですと、Generateも確かに良いのですが、APIへのアクセスがそもそも同期であるならば、難しく考える必要はなく、yield returnを使ったほうが簡単です。単純なものは演算子の組み合わせで、複雑なものは素直に偉大なるコンパイラ生成(yield return)に頼る。そういう切り分けがLINQ的には大事かなって。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IEnumerable&lt;string&gt; EnumerateFriends(string screenName)
{
    var cursor = &quot;-1&quot;; // 初期値は-1から
    while (cursor != &quot;0&quot;) // 0が出たら終了
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        using (var stream = new WebClient().OpenRead(url))
        {
            var json = DynamicJson.Parse(stream); // 面倒くさいんでDynamicJson使いますよ:)
            foreach (var item in json.users)
            {
                yield return item.screen_name; // screen_nameを列挙
            }
            cursor = json.next_cursor_str; // 次のカーソルにセット
        }
    }
}

static void Main()
{
    var friends = EnumerateFriends(&quot;neuecc&quot;).ToArray();
}
</code></pre>
<p>すっきりと書けるのが分かると思います。え、これだとブロックしてしまって良くない？その通り。じゃあ非同期にしましょう。いえ、<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>で簡単にできてしまいます。yield returnで生成されたEnumerableをObservableに変換するのは、ToObservableです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void Main()
{
    EnumerateFriends(&quot;neuecc&quot;)
        .ToObservable(Scheduler.ThreadPool) // ThreadPoolで実行！
        .Subscribe(Console.WriteLine);
        
    Console.ReadLine(); // 終了してしまうからね
}
</code></pre>
<p>ToObservableはデフォルトでは Scheduler.CurrentThread 上で実行されるため、同期的にブロックしますが(※Push型シーケンスだからといって必ずしも非同期とは限らない)、任意のものに変更することも可能です。今回はScheduler.ThreadPoolを指定したので、ThreadPool上で動くようになっています。そのため、ブロックされません。</p>
<p>こういった書き方のほうが、コードがクリアになるし、IEnumerable&lt;T&gt;とIObservable&lt;T&gt;に両対応できてる、という柔軟性の点でも良いかと思います。また、BackgroundWorkerを使うよりも遥かに簡単ですよね。プログレス通知もなく、ただ処理をバックグラウンドでやりたい、というだけならば、Rxを使ったほうが楽チンです。プログレスが必要な場合は、Rxだとその辺の処理を作りこまなければならないので、素直にBackgroundWorkerを用いるのもいいかもしれません。私だったらRxをちょっと拡張してプログレス処理を作り込むほうを選ぶかな？その辺の話は<a href="http://neue.cc/2010/12/09_288.html" title="neue cc - Reactive ExtensionsとAsync CTPでの非同期のキャンセル・プログレス処理">Reactive ExtensionsとAsync CTPでの非同期のキャンセル・プログレス処理</a>を参照ください。</p>
<p>また、Observable化するとPublishによる分配 - <a href="http://neue.cc/2010/04/29_255.html" title="neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions">C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions</a>など、色々と応用な使い方が広がるのもメリットの一つと言えるでしょう。</p>
<h2>Async CTP</h2>
<p>今回は例がWPFなため、WebClientで同期的(OpenRead)に取ってしまいましたし、それでも全然問題ないわけですが、SilverlightとかWP7だったらこの手(同期でJSON取ってきてyield returnで返す)は使えません。同期のOpenReadがそもそもなくて、非同期のOpenReadAsyncしかないからね。どうしましょう？それだとyield returnが使えないのはモチロンのこと、Generateでもうまく動きません。もしページ番号がカーソルのように不定ではなく1,2,3...といった形で辿れたとしても、Observable.Rangeでやると、うまくいきません。非同期なので結果が帰ってくる時間が不定だからです。結果を取得してから次の結果を取得する、という形式にしないとダメなのです。</p>
<p>ところでそもそも、同期的に書いたとしても、本来は書くのは大変なはずなのです。それが、yield returnというコンパイラ生成があるから簡単に書ける。ということは、そうです、非同期もコンパイラ生成してしまえばいいのです、ということで<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360">Async CTP</a>で書きましょう。Async CTPはC# 5.0で入る、かもしれない、async/await構文を使えるようにするためのものです。コミュニティテクノロジープレビュー。ようするにベータ版ですね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// このコードはAsync CTP (SP1 Refresh)によるもので、将来的にも同じコードで動作することは保証しません
async static Task&lt;List&lt;string&gt;&gt; EnumerateFriends(string screenName)
{
    var list = new List&lt;string&gt;();

    var cursor = &quot;-1&quot;;
    while (cursor != &quot;0&quot;)
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        using (var stream = await new WebClient().OpenReadTaskAsync(url)) // await!
        {
            var json = DynamicJson.Parse(stream);
            foreach (var item in json.users)
            {
                list.Add(item.screen_name); // yield returnの代わりに……
            }
            cursor = json.next_cursor_str;
        }
    }

    return list;
}
</code></pre>
<p>Async CTPは簡単に解説すると、awaitキーワードを使うと、本来非同期のものが同期のように書けるようになります。詳しくは<a href="http://ufcpp.net/study/csharp/sp5_async.html">非同期処理 (C# によるプログラミング入門)</a>を参照のこと。コード的にも見たように、差異はWebClientのOpenReadの部分を、await OpenReadTaskAsyncに変更しただけで、あとはまるっきり一緒です。非同期なんて簡単なものだね。と、言いたかったのですが、全部読み込んでListで返してるぢゃん……。これじゃEnumerateじゃないよ、yield returnじゃないの？これだと結果取得に時間かかるし、Takeなどを用いて、途中で止めることもできないし。あまりよくない。</p>
<p>結論としては今のところどうやら無理ということで。asyncの返すものはTaskもしくはTask&lt;T&gt;でなければならない。いや、Task&lt;IEnumerable&lt;T&gt;&gt;を返してくれればいいぢゃん、await yield returnとか出来たら素敵ぢゃないのん？と思わなくもないというか、<a href="http://social.msdn.microsoft.com/Forums/en-ZW/async/thread/f7a42c29-4ee6-4a3c-b346-b3718e253dc0">普通にそういうリクエストも上がっている</a>のですが、それにはIAsyncEnumerable&lt;T&gt;のようなものと、それに対するコンパイラサポートが必要だよね、という返しでした。</p>
<h2>Rx + Async</h2>
<p>IAsyncEnumerable&lt;T&gt;、それってIObservable&lt;T&gt;で代替出来る話だよね。IObservable&lt;T&gt;は連続的な非同期を内包しているから。（※IObservable&lt;T&gt;は一つのインターフェイスであまりにも多くのものを表現出来てしまい、内部の状態が読みづらく(同期なのか非同期なのか、遅延なのか即時なのか)混乱を生みがちという問題もありますが……）。なので、Rxでやってみましょう。といっても、Rxで完全に自前でやるのは相当大変なので、Async CTPのサポートも併用します。これにより非同期の待機が同期的に書けるようになり、yield returnであったりlist.Addであったりの部分を、OnNextに置き換えるだけになります。</p>
<p>Stable版のRxにはAsync CTP連携は入っていないのですが、Experimental(実験的)版には、awaitで待機出来る、というだけはなく、幾つかAsync CTPと連携できるメソッドが入っています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ExperimentalのRxのため、将来的にもこのコードが動作し続けることは保証しません
static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    // ラムダ式の中でasync書けることがポイント
    return Observable.Create&lt;string&gt;(async (observer, cancelToken) =&gt;
    {
        try
        {
            var cursor = &quot;-1&quot;;
            while (cursor != &quot;0&quot;)
            {
                if (cancelToken.IsCancellationRequested) return; // cancelをチェック

                var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
                    screenName, cursor);
                using (var stream = await new WebClient().OpenReadTaskAsync(url)) // await!
                {
                    var json = DynamicJson.Parse(stream);
                    foreach (var item in json.users)
                    {
                        observer.OnNext(item.screen_name); // yield returnのかわりに
                    }
                    cursor = json.next_cursor_str;
                }
            }
        }
        catch (Exception ex)
        {
            observer.OnError(ex);
            return; // 例外発生時はOnErrorを呼んで終了
        }

        observer.OnCompleted(); // 例外発生もキャンセルもなく完了したなら、OnCompletedを呼ぶ
    });
}

static void Main()
{
    EnumerateFriends(&quot;neuecc&quot;)
        .Take(350) // 350件後にDisposeされてtokenがcancelになる
        .Subscribe(
            s =&gt; Console.WriteLine(s),
            e =&gt; Console.WriteLine(&quot;error:&quot; + e),
            () =&gt; Console.WriteLine(&quot;完了&quot;)); // Takeのほうから呼び出されるので、cancel扱いになっても表示される

    Console.ReadLine();
}
</code></pre>
<p>Observable.Create(RangeやGenerateなどの生成子、WhereやSelectなどの演算子の全てが使っている、本当のプリミティブの生成子)を使って、生のobserverでOnNext, OnError, OnCompletedの3つを制御してやります。Createやtry-catchの分、ネストが深くなってしまっていますが、コード自体は同期的に、yield returnを使って書いていたものとほとんど変わってないのが分かると思います。yield returnの部分にOnNextを置いた、それだけでそのまま置き換えられています。</p>
<p>これならIObservable&lt;T&gt;でも十分に自動生成のサポートが効いていると言えなくもないですね。やってみて、結構満足できてしまった。パフォーマンス的にも、演算子をベタベタ組み合わせるのはあまり良くはならないので、こうしてasync/awaitと連携させて作れると、素直に書けるうえに、パフォーマンス向上も狙えるのが嬉しい。ただ、OnErrorやOnCompleted、キャンセル(Dispose)をどうするか。考慮する事項が多いので、ある程度分かっていないと大変かもしれません。全て考えておかないと、正しく動作しません。既存演算子の組み合わせだけで済ませられるなら、そういった考慮事項は演算子が受け持ってくれるので、考えなくて済むのですが……。どうしても演算子の組み合わせじゃうまく出来ない、逆に複雑になりすぎる、そういった時の奥の手、ぐらいに考えておくと良さそう。</p>
<p>ところでasyncはメソッドの宣言だけでなく、ラムダ式の部分でも宣言できてawaitすることが出てきてしまうんですよね、ならば、同じようなコンパイラ生成であるyield returnも、現状は外部メソッドでしか使えないわけですが、以下のようにインラインでも使えるようになってくれると嬉しいなって。思ってしまうのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 妄想なので、現状はこれは出来ませんが！
var infinity = Enumerable.Create(()=&gt;
{
    var num = 0;
    while(true)
    {
        yield return num++;
    }
});
</code></pre>
<p>そんなもの散々突っ込み受けたですって？<a href="http://blogs.msdn.com/b/ericlippert/archive/2009/08/24/iterator-blocks-part-seven-why-no-anonymous-iterators.aspx">Iterator Blocks Part Seven: Why no anonymous iterators? - Fabulous Adventures In Coding</a>。ええ、知ってます。しかし、awaitなどで必要さの要請を受けて、コストとベネフィットが逆転するときが来た、と、思うのです。それに、VBでも、いや、なんでもない。</p>
<h2>Expand</h2>
<p>さて、ともかくAsync CTPは未来の話であり、現状手元にあるもので何とかする方法はないのだろうかというと、あります。ようするところ、再帰的に辿ってるわけですよね、cursorを。じゃあ、Expandです。Expandは<a href="http://neue.cc/2011/06/30_331.html">Reactive Extensions v1.0安定版リリース</a>でEnumerableバージョンのものを説明しましたが、Observableバージョンもあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 補助メソッド、Async CTPにはOpenReadTaskAsyncとか、そういうのがデフォで用意されてますが、
// Rxにはないので、自前で用意しなきゃあいけないという、それだけの話です(ダウンロードしてストリングを返すだけのもの)
public static class WebRequestExtensions
{
    public static IObservable&lt;string&gt; DownloadStringAsync(this WebRequest request)
    {
        return Observable.Defer(() =&gt; Observable.FromAsyncPattern&lt;WebResponse&gt;(
                request.BeginGetResponse, request.EndGetResponse)())
            .Select(res =&gt;
            {
                using (var stream = res.GetResponseStream())
                using (var sr = new StreamReader(stream))
                {
                    return sr.ReadToEnd();
                }
            });
    }
}

// ExpandはStable版にはまだ搭載されていないので、Experimental版を使ってください
static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    Func&lt;string, IObservable&lt;dynamic&gt;&gt; downloadJson = cursor =&gt;
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        return WebRequest.Create(url).DownloadStringAsync().Select(DynamicJson.Parse);
    };

    return downloadJson(&quot;-1&quot;)
        .Expand(d =&gt; (d.next_cursor_str == &quot;0&quot;)
            ? Observable.Empty&lt;dynamic&gt;() // TakeWhileで判定すると最後の一つを取りこぼすので
            : downloadJson(d.next_cursor_str))
        .SelectMany(d =&gt; (dynamic[])d.users)
        .Select(d =&gt; (string)d.screen_name);
}
</code></pre>
<p>そこそこ直感的ではないでしょうか？最初 Expand().TakeWhile(next_cursor_str != &quot;0&quot;) と書いたのですが、それだと最後のページを取りこぼしてしまうのに気づいて、Emptyを投げる方針に変更しました。その辺、境界については注意を払わなきゃですね。</p>
<p>そして、残念ながら、ExpandはRxのStable版にはまだない。ということはWP7にもないわけで。</p>
<h2>再帰とRx</h2>
<p>Stable版でもやりましょう。awaitなし、Expandなし。では、どうやって作りましょうか。うーん、再帰的というのなら、本当に再帰させてしまえばいいのではないか？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    Func&lt;string, IObservable&lt;dynamic&gt;&gt; downloadJson = null; // 再帰するにはこーして最初にnull代入
    downloadJson = cursor =&gt;
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        return WebRequest.Create(url)
            .DownloadStringAsync()
            .Select(DynamicJson.Parse) // ここまでExpandと共通
            .SelectMany(json =&gt;
            {
                // Expandメソッドの中でやってることを大幅簡易化、ということです、つまるところ。
                var next = (json.next_cursor_str == &quot;0&quot;)
                    ? Observable.Empty&lt;dynamic&gt;()
                    : downloadJson((string)json.next_cursor_str);
                return (IObservable&lt;dynamic&gt;)Observable.StartWith(next, json);
            });
    };

    return downloadJson(&quot;-1&quot;)
        .SelectMany(d =&gt; (dynamic[])d.users) // ここからもExpandと共通
        .Select(d =&gt; (string)d.screen_name);
}
</code></pre>
<p>これを再帰というには、あまり再帰してないのですが、まあ雰囲気雰囲気。Expandと大体共通です。つまるところ、Expandを自前で作る、のは結構大変なので、Expandのように汎用的ではなく、特化したものをその場で作る、といった程度の代物。そうすれば、少しは簡単に用意できます。</p>
<h2>まとめ</h2>
<p>同期でListに格納するだけなら簡単。遅延でやるのもyield returnのお陰で簡単。非同期で辿るのは難しい。awaitで複数の値をyield的に列挙するのは現状難しい。Rxとawaitの連携は大変素晴らしい。Expandは便利。なければないで何とかなる。でもやっぱ大変。</p>
<p>一見簡単なことが存外難しいってのはいくないですね。一見簡単なら、簡単なままでできないと。Expandも悪くはないんですけど、中々どうして慣れてないと分かりづらい。しかし、将来のC#には十分期待できそう。と、思いました、まる。あとRxとAsyncは全然仲良しなんですよ～、というところです。</p>
</div>
<h1 data-pagefind-sort="date:2011-07-06" data-pagefind-meta="published:2011-07-06"><a href="https://neue.cc/2011/07/06_332.html">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a></h1>
<ul class="date"><li>2011-07-06</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の機能の一つに.NETにおけるイベントをIObservable&lt;T&gt;に変換する、というものがあります。<a href="http://msdn.microsoft.com/en-us/library/hh242978(v=VS.103).aspx">Bridging with Existing .NET Events</a>。そして、そのためのメソッドがFromEventでした。ところが最近のRxでは二つ、FromEventとFromEventPatternが用意されています。この差異は何なのでしょうか？</p>
<p>結論としては、過去のRx(このサイトの古い記事や他のサイトの過去の記事などで触れられている)やWindows Phone 7でのFromEventはFromEventPatternに改名されました。後続にEventPatternという(object Sender, TEventArgs EventArgs)を持つ.NETのイベントの引数そのものを渡すものです。そして、空席になったFromEventに新しく追加されたFromEvent(紛らわしい！)は、EventArgsだけを送ります。それ以外の差異はありません。</p>
<p>つまるところFromEventは FromEventPattern.Select(e =&gt; e.EventArgs) ということになります。なら、それでいいぢゃん、何も混乱を生む(WP7のFromEventがFromEventPatternである、というのは致命的よねえ)ことはないよ、とは思うのですが、パフォーマンスの問題でしょうかね。確かに、Senderは必要なく使うのはEventArgsだけの場合が多い。それなのに、毎回EventPatternを生成していたり、Selectというメソッド呼び出しが入るのは無駄です。</p>
<p>そもそもインスタンスに対してFromEventで包むということは、クロージャでsenderは変数としていつでもどこでも使えてしまうのですよね、そもそも、そもそも。そういう意味でも送られてくるのはEventArgsだけでいいのであった。というわけで、基本的にはFromEventでいいと思います。</p>
<h2>FromEventPatternについて</h2>
<p>では、改めてFromEventPatternを復習します(WP7の人はFromEventで考えてください)。<a href="http://msdn.microsoft.com/en-us/library/hh229705(v=VS.103).aspx">Observable.FromEventPattern(TEventArgs) Method (Object, String) (System.Reactive.Linq)</a>にサンプルコードがあるのですけれどね。そうそう、MSDNのリファレンスには、一部のメソッド/一部のオーバーロードにはサンプルコードがあります。全部ではないのがミソです、見て回って発掘しましょう。まあ、というわけで、とりあえずそのFileSystemWatcherで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FileSystemWatcherは指定フォルダを監視して、変化があった場合にイベントを通知します
// 例えばCreatedイベントはファイルが作成されたらイベントが通知されます
var fsw = new FileSystemWatcher(@&quot;C:\&quot;, &quot;*.*&quot;) { EnableRaisingEvents = true };

// FromEventPatternその1、文字列でイベント名指定
Observable.FromEventPattern&lt;FileSystemEventArgs&gt;(fsw, &quot;Created&quot;)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));

// FromEventPatternその2、静的なイベントをイベント名指定(WP7にはない)
Observable.FromEventPattern&lt;ConsoleCancelEventArgs&gt;(typeof(Console), &quot;CancelKeyPress&quot;)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.SpecialKey));
</code></pre>
<p>一番馴染み深いと思うのですが、文字列でイベント名を指定するものです。その2のほうはあまり見ないかもしれませんが、静的イベントに対しての指定も可能です。これら文字列指定によるメリットは、比較的シンプルであること。デメリットは、リフレクションを使うので若干遅い・スペルミスへの静的チェックが効かない・リファクタリングが効かない、といった、リフレクション系のデメリットそのものとなります。</p>
<p>リフレクションしかないの？というと、勿論そんなことはありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEventPatternその3、EventHandlerに対する変換
var current = AppDomain.CurrentDomain;
Observable.FromEventPattern(h =&gt; current.ProcessExit += h, h =&gt; current.ProcessExit -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs));

// FromEventPatternその4、EventHandler&lt;T&gt;に対する変換
Observable.FromEventPattern&lt;ContractFailedEventArgs&gt;(
        h =&gt; Contract.ContractFailed += h, h =&gt; Contract.ContractFailed -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.Message));

// FromEventPatternその5、独自イベントハンドラに対する変換
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; new FileSystemEventHandler(h),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>イベントの登録と削除を行うためのラムダ式を渡してやります。その3とその4は比較的分かりやすいのではないでしょうか。その5の第一引数が謎いのですが、これはconversionです。C#の型システムの都合上、そのまんまだと独自イベントハンドラを処理出来ないので、型を変換してやる必要があるという定型句。</p>
<p>数あるFromEventPatternのオーバーロードの中で、一番多く使うのはその5だと思います。何故なら、C#のイベントは独自イベントハンドラになっていることが多いから。はっきしいって、最低です。EventHandler&lt;T&gt;を使ってくれてさえいれば、こんな苦労はしなくて済むというのに。独自イベントハンドラは100害あって一利なし。え、WPFとか.NET標準がイベントハンドラは独自のものを使ってる？それは、WPFが悪い、.NET設計の黒歴史、悪しき伝統。</p>
<p>それと、もはや独自デリゲートも最低です。FuncやActionを使いましょう。C#のデリゲートはメソッドの引数や戻り値が一致していようが、型が違ったら別のものとして扱われます。そのことによる不都合は、↑で見たように、あるんです。極力ジェネリックデリゲートを使いましょう。そうすれば、こんな腐った目に合わなくても済みます。</p>
<p>ところで、その5は、もう少しだけ記述が短くなります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEventPatternその5、第一引数別解、こう書くと短くて素敵
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; h.Invoke,
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>h.Invoke。というのは、割とhそのものなわけですが、しかしInvokeと書くことで型が変換されます。この辺はコンパイラの都合上のマジックというか何というか。そういうものだと思えばいいのではかと。その5のスタイルで書くときは、この書き方をすると良いと思います。で、まだオーバーロードがあって</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// その6
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; fsw.Created += h, h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>conversionが不要で書けたりもします。一見素晴らしい、のですが、これ、中でなにやってるかというとconversionに相当するものをリフレクションで生成してるだけだったりして。そのため、なるべくconversionを使うオーバーロードのほうを使ったほうがよいでしょう。h =&gt; h.Invokeを書くだけですしね。このオーバーロードは紛らわしいだけで存在意義が不明すぎる。</p>
<h2>FromEventについて</h2>
<p>と、長々と見てきましたが、ではFromEventのほうも。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEvent
Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(e),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.FullPath));

// FromEventPatternその5(比較用)
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(sender, e),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Select(e =&gt; e.EventArgs)
    .Subscribe(e =&gt; Console.WriteLine(e.FullPath));
</code></pre>
<p>というわけで、FromEventPatternのその5に近いわけですが、conversionでEventArgsしか渡していない、という点が差異ですね。なので、後続にはsenderが伝わってこず、EventArgsしか通りません。まあ、senderは、↑の例ですとfswでどこでも使えるので、そもそも不要なわけで、これで良いかと思います。</p>
<p>ところでFromEventも色々なオーバーロードがあるにはあるんですが、私の頭では存在意義が理解できなかったので無視します。挙動とかは理解したんですが、なんというか、存在する必要性、有効な利用法がさっぱり分からなかったのです……。まあ、多分、あんま意味ないと思うので気にしないでもいいかと。</p>
<h2>拡張メソッドに退避させよう</h2>
<p>FromEventにせよFromEventPatternにせよ、長いです。長い上に定型句です。なので、拡張メソッドに退避させると、スッキリします。例えば、今まで見てきたFileSystemWatcherだったら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// .NETのFromEventなら IObservable&lt;TEventArgs&gt;
// .NETのFromEventPatternなら IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;
// WP7のFromEventなら IObservable&lt;IEvent&lt;TEventArgs&gt;&gt;
// を返す拡張メソッド群を用意する。
// 命名規則はイベント名AsObservableがIntelliSenseの順序的にお薦め
public static class FileSystemWatcherExtensions
{
    public static IObservable&lt;FileSystemEventArgs&gt; CreatedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Created += h, h =&gt; watcher.Created -= h);
    }

    public static IObservable&lt;FileSystemEventArgs&gt; DeletedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Deleted += h, h =&gt; watcher.Deleted -= h);
    }

    public static IObservable&lt;RenamedEventArgs&gt; RenamedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;RenamedEventHandler, RenamedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Renamed += h, h =&gt; watcher.Renamed -= h);
    }

    public static IObservable&lt;FileSystemEventArgs&gt; ChangedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Changed += h, h =&gt; watcher.Changed -= h);
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var fsw = new FileSystemWatcher(@&quot;C:\&quot;, &quot;*.*&quot;) { EnableRaisingEvents = true };

// 例えば、ただ変更をロギングしたいだけなんだよ、という場合の結合
// FromEventを外出ししていることによって、すっきり書ける
Observable.Merge(
        fsw.CreatedAsObservable(),
        fsw.DeletedAsObservable(),
        fsw.ChangedAsObservable(),
        fsw.RenamedAsObservable())
    .Subscribe(e =&gt; Console.WriteLine(e.ChangeType + &quot;:&quot; + e.Name));
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fsw_intellisense.jpg">
</p>
<p>といった形です。また、普通に+-でのイベント以外のものへの登録も可能です。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// LayoutRootはWPFの一番外枠の&lt;Grid Name=&quot;LayoutRoot&quot;&gt;ということで。
Observable.FromEvent&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(e),
        h =&gt; LayoutRoot.AddHandler(UIElement.MouseDownEvent, h),
        h =&gt; LayoutRoot.RemoveHandler(UIElement.MouseDownEvent, h))
    .Subscribe(e =&gt; Debug.WriteLine(e.ClickCount));
</code></pre>
<p>こんな形のものもObservable化が可能です。</p>
<h2>イベントの解除</h2>
<p>Subscribeの戻り値はIDisposableで、Disposeを呼ぶことでイベントが解除されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// アタッチ
var events = Observable.Merge(
        fsw.CreatedAsObservable(),
        fsw.DeletedAsObservable(),
        fsw.ChangedAsObservable(),
        fsw.RenamedAsObservable())
    .Subscribe(e =&gt; Console.WriteLine(e.ChangeType + &quot;:&quot; + e.Name));

// デタッチ(合成などをしていて、元ソースが複数ある場合も、すべて解除されます)
events.Dispose();
</code></pre>
<p>Rxのこの仕組みは、従来に比べて圧倒的にイベントの解除がやりやすくなっていると思います。</p>
<h2>まとめ</h2>
<p>非同期の説明ばかりしてきていて、イベントはすっかり置き去りだったことを、まずはゴメンナサイ。少し前からFromEvent周りは大きな仕様変更が入ったわけですが、ようやくまともに解説できました。基本中のキの部分であるここが、過去のリソースがそのまま適用出来ないという最悪の自体に陥っていたので、とりあえずこれで何とか、でしょうかどうでしょうか。</p>
<p>小さなこととはいえ、WP7との互換性が絶えているのが痛いのですが、その辺どうにかならなかったのかねー、とは思います。けれど、このEventArgsだけ送るFromEvent自体は良いと思います。 .Select(e =&gt; e.EventArgs) が定型句だったので、こういった変更は喜ばしい限り。それと、今まで思っていた、ぶっちゃけラムダ式とかRxでイベント登録するならsenderって不要じゃね？に対する答え(その通りで、完全に不要)を出してくれたのが嬉しい。</p>
<p>さて、変換できるのはいいけれど、じゃあどこで使うのがいいの？という話がいつもありません。次回は、時間周りと絡めて、その辺のお話が出来ればと思いますが、いつも次回予告が達成されたことはないので、別のことを書くでしょう←ダメぢゃん。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-30" data-pagefind-meta="published:2011-06-30"><a href="https://neue.cc/2011/06/30_331.html">Reactive Extensions v1.0安定版リリース</a></h1>
<ul class="date"><li>2011-06-30</li></ul>
<div class="entry_body"><p><a href="http://blogs.msdn.com/b/rxteam/archive/2011/06/29/first-official-release.aspx">Reactive Extensions v1.0 Stable and v1.1 Experimental available now!</a> ということで、今までも安定版だの正式だの何なり言っていましたが、今回こそ、本当に本当に正式リリース、v1.0だそうです。整理されたドキュメント、多くのチュートリアルビデオ、<a href="http://enumeratethis.com/2011/06/29/rx-performance-improvements/">大幅なパフォーマンス改善</a>、そして、よくテストされた(かどうかは不明)安定版としてのライブラリ本体。全てが整いました。さあ、使いましょう！実際のプロダクトに！</p>
<ul>
<li><p><a href="http://channel9.msdn.com/Blogs/Charles/Announcing-the-Official-Release-of-Rx">Announcing the Official Release of Rx! | Charles | Channel 9</a><br />
下のリンク先にあるRx Workshopで、沢山のビデオで学ぶことが出来ます。</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/hh242985(VS.103).aspx">MSDN - .NET Development - Reactive Extensions</a><br />
MSDNでのドキュメント。コンセプトから細かい使い方まで、しっかり書かれています。</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/hh242986(VS.103).aspx">Reactive Extensions Class Library Reference</a><br />
MSDNでのクラスライブラリリファレンス。</p>
</li>
</ul>
<p>また、NuGetではRx-でStable版を、Rx_experimental-で実験版を、他にIx_experimental-でIxをインストールすることが可能です。</p>
<h2>Ix復活</h2>
<p>Ix(Interactive Extensions、Reactiveの反対ということでEnumerableEx、Linq to Objectsを拡張する拡張メソッド群)が復活しました。復活前に、<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/1a75496f-0b33-41c0-bf7a-92f9802c3f0a">今後についての意見を募集</a>していたのですが、素敵なことに私の意見が全部反映されていました！XxxEnumerableはIntelliSenseの邪魔だから廃止してね、とかForEachにはindex付きのオーバーロード入れてよ、とかTreeを走査するメソッド入れてよ、とか。これは嬉しい。いやあ、やっぱり言っておくものですね。</p>
<p>そんなわけで、もうForEachを自作する必要はありません:)</p>
<p>標準クエリ演算子で何が「出来ない」のかを知っておくことは大切です。標準では複数回列挙なしで前後の値を使うことは出来ないし、再帰的に辿るような、複数段のSelectManyも出来ない。MaxByなどキーを使った最大値の取得もない。</p>
<p>Ixは、そこを補完してくれます。</p>
<h2>Expand</h2>
<p>Ixの中から、Expandを紹介します。なお、Rx(Observable)にはExperimental Releaseのほうにはあるのですが、まだStableには入っていません。</p>
<p>これは何かというと幅優先探索でツリーを解きほぐします。イミワカリマセンネ。ええと、ツリー状のオブジェクトを辿る場合は、通常は再帰を使って書くと思います。でも、そうして再帰で辿るのって、各枝の値が欲しいわけなんですよね？もしそうなら、ツリーは一直線上に出来る。IEnumerable&lt;T&gt;に出来る。LINQが適用できる。</p>
<p>ええ。<a href="http://d.hatena.ne.jp/NyaRuRu/20080127/p2">熟練した C# 使いは再帰を書かない</a>のです。で、ツリーです。ツリーを辿るのは頻出の再帰構造でパターン化できて、うんたらかんたら。ああ、もう！<a href="http://d.hatena.ne.jp/NyaRuRu/20080604/p1">与えられた木から，子→親への対応を作る，を C# で - NyaRuRuの日記</a>を見るといいです、それで全部解決です！</p>
<p>ExpandはBreadthFirstにあたります。DepthFirstはないの？というと、今のところないですねー。ないものはないです、しょうがない。それはさておき、このツリー的なものを辿るのというのは割とあるシチュエーションで、そしてExpandというメソッドは実に強力なので、是非使い方をマスターして欲しい。ので、例を出します。例えばWinFormsのコントロール。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ix_forms.jpg">
</p>
<p>Panelの下にButtonや、子Panelが並んでいます。さて、この中から全てのButtonを取り出したいのですが、どうしましょうか？予め配列にButtonを持っておく、のもまあ答えですが、ルート階層から辿るようにしましょう。Formに並ぶコントロールは、階層に別れたツリー構造をしています。Expandを使ってみましょう。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ix_buttons.jpg">
</p>
<p>Expandはセレクターの結果がEmptyになるまで、辿り続けます。辿る順番は階層順(幅優先)。今回はContorolsを辿って全てのControlを列挙、Buttonが欲しいのでOfTypeでフィルタリング。というわけです。WPFやSilverlightでも、同様に辿ることが出来ます(ちょっとWPFのコントロール階層が面倒くさくて、コードがゴチャゴチャするので、今回はWinFormsを例とさせていただきました)</p>
<p>こういった走査メソッドは<a href="http://linqjs.codeplex.com/">linq.js</a>にもあります(CascadeBreadthFirst、メソッド名のとおり、NyaRuRuさんの作成されたAchiralから大きな影響を受けています)。JavaScriptの場合、ツリーの代表的なものはDOMです、というわけで勿論DOMに適用できるのですが、DOMの列挙はjQueryでやったほうがいいですよー、なので、JSONやオブジェクト(これもまたツリーになっている)の走査に使うのがいいかもしれません。何にせよ、使いどころというのは存外あるものです。</p>
<h2>気になった点</h2>
<p>そんな素敵なIxですが、触っていて幾つか気になった点があったので、<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/278f57aa-f0ef-4a95-be41-822d3dd5e299">またForumに投げておきました</a>。リクエストが反映されたことで、調子に乗って味を占めているのかもしれません。ではなくて、フィードバックは積極的に出してあげたほうがいいでしょう常識的に考えて。英語？全部機械翻訳です、はは、まあ、コードがあれば伝わるはず。伝わりました。返答が15分で来た。</p>
<p>まず、Scanの挙動。seedなしの場合に、Rxは最初の値も列挙しますが、Ixは最初の値をスルーするという、挙動の違い。で、これ、最初の値がスルーされるのは都合が悪いので(スルーしたきゃあSkip(1)すればいい)、修正かなあ、と思います。返答では、この点については何も言ってませんでしたが。</p>
<p>Scanにはもう一つ、seed有りの際に、Rx, Ixともにseedをスルーしますが、F#などはseedも列挙します。これは以前はScan0というseed含めて列挙する別のメソッドがあった(WP7版にはある)のですが、今はScan0は廃止されたので、それならScanの挙動をseed込みでの列挙に変更すべき。と、思ったのですが、返答はStartWith(seed)を使えばいいとのこと。それでも確かにいいのですが、基本seed有りにしてseed飛ばしたい時はSkip(1)のほうが使いやすいと思うのだけど。まあ、これはWP7版との互換性の問題もありますし、そもそもRxはStableと言った以上、もう挙動は変えられないので、しょうがないところかもしれません。</p>
<p>他にはRepeat拡張メソッド(無限リピートする)のソースがEmptyの場合の挙動。例えば Range(1,1).Repeat().Take(3) と1,1,1になるわけですが、 Empty<int>().Repeat().Take(3) の結果はどうでしょう？答えは、無限ループを彷徨って止まらなくなります。Emptyに対するRepeatをどう解釈するか、は正直微妙なところですけれど、元ソースが空だと死ぬというのは、結構リスキーなのではないかな、と考えてしまうのです。また、Takeをつけるのは止まることを期待するという点もあるわけですが、この場合はTakeをつけようが何しようが無駄、というのも怖い。Rxチームからの回答は、この挙動は仕様とのことでした。</p>
<p>最後にちょっとリクエストしてみた。今回のIxではDistinctにオーバーロードが足されています。通常だとIEqualityComparer&lt;T&gt;というダルいものをクラス定義して(ここが最悪！)渡さなければいけないのですが、ラムダ式でキーを指定するだけで済みます。言うならばDistinctByといったところ。これは、実に大変有益です。このオーバーロードは、<a href="http://linqcomparer.codeplex.com/">AnonymousComparer</a>という私が以前に作ったものにも載っているのですが(ちなみに拡張メソッドがかち合ってしまうため、Ixと同時使用は不可能になってしまった！まあ、.csファイル一個のライブラリなので、かち合う部分はコメントアウトすればいいのですが)、大変重宝しています。しょっちゅう使ってます。特にExceptとかで多用しているんですが……、今回IxではDistinctにしかオーバーロード足されていません。他の集合系メソッドであるIntersect, Except, Unionでも使えると便利なのになー、って思ってしまうのです。なのでリクエストしておきました。回答は、考えておく、とのことなのでもしかしたら次のバージョンでは乗っかっているかもしれません。</p>
<p>日本語だと言えるけれど、バッサリ切って機械翻訳した英語だと伝えたいニュアンスは吹っ飛んでしまうなあ、ううみぅ。必ずしもコードがあれば伝えられる、わけでもないか、当たり前だけど。</p>
<h2>QueryableEx(笑)</h2>
<p>ネタ。NuGetではIx_Experimental-Providerで入るんですが、まあ、ネタ。中身はEnumerableExのIQueryable版です。何がネタなのかというと、IQueryableはそれだけでは何の意味もなくて、解釈するエンジン(Linq to SqlなりLinq to Twitterなり)が大事なわけです。そうでなければ、not supportedをぶん投げるだけです。さて、そして、標準クエリ演算子ですらnot supported率が少なくないのに、QueryableExに対応するクエリプロバイダ……。ありえない、です。</p>
<p>そんなわけで、使う機会はないでしょう。んまあ、気合でQueryableExすらもフルサポートするクエリプロバイダを自作すれば、活用出来ますが、やはりそんな機会はないでしょう。</p>
<h2>RxJSは？</h2>
<p>ドキュメント書いたりとか、QueryableEx作ったり(笑)とか、色々忙しかったのでしょふ。今回「も」全く音沙汰なしですが、次こそは更新されるんじゃないですかねー、分かりませんけど。jQueryにはDeferred乗りましたが、アレは正直かなり使いづらいのでその点でも私はRxJSにしたいなあ。それと、<a href="http://www.publickey1.jp/blog/11/nodejswindows_azure.html">MS支援でのNode.jsのWindows対応</a>も発表されましたし、JavaScriptのAsyncを何とかするためのRx、はかなり価値があると思うので、もう少し頑張って欲しいな、と思います。</p>
<h2>まとめ</h2>
<p>しっかりとMSDN入りしている、ドキュメントもある、正式にv1 Stableと告知されている、など、もう採用できない理由はなくなりました。日本語リソースはないですが、それは気合で乗り切ればいいぢゃない(とか言ってるうちはダメなのでしょうがー)。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>Jesse Liberty(オライリーから出ているプログラミングC#の著者)による解説本も今秋に出るようだし、確実に、順調にメインストリームに乗るテクノロジとしての道を歩んでいますので、安心して追えるのではないかと思います。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-23" data-pagefind-meta="published:2011-06-23"><a href="https://neue.cc/2011/06/23_330.html">ReactiveOAuth ver.0.4 - Twitpic(OAuth Echo)対応</a></h1>
<ul class="date"><li>2011-06-23</li></ul>
<div class="entry_body"><ul>
<li><a href="http://reactiveoauth.codeplex.com/" title="ReactiveOAuth - Home">ReactiveOAuth - CodePlex</a></li>
</ul>
<p>ver.0.4になりました。少し前に0.3.0.1をこっそり出していたので、それを含めて0.3からの差分は、「対象Rxのバージョンが現在最新の1.0.10605(Stable)」に、というのと「Realmが含まれていると認証が正しく生成出来なかったバグの修正」と、「TwitpicClientサンプルの追加」になります。バグのほうは本当にすみません……。Twitterでしかテストしてない＆TwitterはRealm使わないため、全然気づいていなくて。ダメですねホント。</p>
<h2>OAuth Echo</h2>
<p>TwitpicはOAuth Echoという仕組みでTwitterと連携した認証をして、画像を投稿できます。詳しくは<a href="http://dev.twitter.com/pages/oauth_echo">Using OAuth Echo | dev.twitter.com</a>や<a href="http://dev.twitpic.com/docs/2/upload/">TwitPic Developers - API Documentation - API v2 » upload</a>にありますが、よくわかりませんね！Twitpicに画像を投稿、というわけでTwitpicのAPIにアクセスするわけですが、その際のヘッダにTwitterに認証するためのOAuthのヘッダを付けておくと、Twitpic側がTwitterに問い合せて認証を行う。という仕組みです、大雑把に言って。</p>
<p>ただのOAuthとはちょっと違うので、今までのReactiveOAuthのOAuthClientクラスは使えない。けれど、認証用ヘッダの生成は同じように作る。というわけで、ここはReactiveOAuthにひっそり用意されているOAuthBaseクラスを継承して、Twitpic専用のTwitpicClientクラスを作りましょう。</p>
<p>が、作るのもまた少し面倒なので Sample/TwitpicClient/TwitpicClient.cs に作成したのを置いておきました。ファイルごとコピペってご自由にお使いください。.NET 4 Client Profile, Silverlight 4, Windows Phone 7の全てに対応しています。</p>
<h2>Windows Phone 7でのカメラ撮影＋投稿のサンプル</h2>
<p>TwitpicClient.cs の解説は後でやりますが、その前に利用例を。WP7でカメラ撮影＋投稿をしてみます。CameraCaptureTaskの利用法に関しては <a href="http://ch3cooh.jp/index.php/tips/windowsphone7/tasks/cameracapturetask/">CameraCaptureTaskを使ってカメラで静止画撮影を行う – CH3COOH(酢酸)の実験室</a> を参考にさせて頂きました。TwitterのAccessTokenの取得に関しては、ここでは解説しませんので <a href="http://neue.cc/2010/09/12_276.html">neue cc - ReactiveOAuth - Windows Phone 7対応のOAuthライブラリ</a> を参照ください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// CameraCaptureTaskのCompletedイベント
void camera_Completed(object sender, PhotoResult e)
{
    if (e.TaskResult == TaskResult.OK)
    {
        // 撮影画像(Stream)をバイト配列に格納
        var stream = e.ChosenPhoto;
        var buffer = new byte[stream.Length];
        stream.Read(buffer, 0, buffer.Length);

        // key, secret, tokenは別に設定・取得しておいてね
        new TwitpicClient(ConsumerKey, ConsumerSecret, accessToken)
            .UploadPicture(e.OriginalFileName, &quot;from WP7!&quot;, buffer)
            .ObserveOnDispatcher()
            .Catch((WebException ex) =&gt;
            {
                MessageBox.Show(new StreamReader(ex.Response.GetResponseStream()).ReadToEnd());
                return Observable.Empty&lt;string&gt;();
            })
            .Subscribe(s =&gt; MessageBox.Show(s), ex =&gt; MessageBox.Show(ex.ToString()));
    }
}
</code></pre>
<p>new TwitpicClient(キー, シークレット, アクセストークン).UploadPicture(ファイル名, メッセージ, 画像) といった風に使います。戻り値はIObservable&lt;string&gt;で結果(投稿後のURLとか)が返ってくるので、あとは好きなように。投稿に失敗した場合は、WebExceptionが投げられるので、それを捉えてエラーメッセージを読み取ると開発には楽になれそうです。</p>
<h2>TwitpicClient.cs</h2>
<p>以下ソース。Sample/TwitpicClient/TwitpicClient.cs と同じですが、自由にコピペって使ってください。大事なことなので2回言いました。このコード自体はTwitpicに特化してありますが、認証部分のヘッダを少しと画像アップロードを変更する部分を弄れば、他のOAuth Echoサービスにも対応させることができると思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;

#if WINDOWS_PHONE
using Microsoft.Phone.Reactive;
#else
using System.Reactive.Linq;
#endif

namespace Codeplex.OAuth
{
    public class TwitpicClient : OAuthBase
    {
        const string ApiKey = &quot;&quot;; // set your apikey

        readonly AccessToken accessToken;

        public TwitpicClient(string consumerKey, string consumerSecret, AccessToken accessToken)
            : base(consumerKey, consumerSecret)
        {
            this.accessToken = accessToken;
        }

        private WebRequest CreateRequest(string url)
        {
            const string ServiceProvider = &quot;https://api.twitter.com/1/account/verify_credentials.json&quot;;
            const string Realm = &quot;http://api.twitter.com/&quot;;

            var req = WebRequest.Create(url);

            // generate oauth signature and parameters
            var parameters = ConstructBasicParameters(ServiceProvider, MethodType.Get, accessToken);
            // make auth header string
            var authHeader = BuildAuthorizationHeader(new[] { new Parameter(&quot;Realm&quot;, Realm) }.Concat(parameters));

            // set authenticate headers
            req.Headers[&quot;X-Verify-Credentials-Authorization&quot;] = authHeader;
            req.Headers[&quot;X-Auth-Service-Provider&quot;] = ServiceProvider;

            return req;
        }

        public IObservable&lt;string&gt; UploadPicture(string filename, string message, byte[] file)
        {
            var req = CreateRequest(&quot;http://api.twitpic.com/2/upload.xml&quot;); // choose xml or json
            req.Method = &quot;POST&quot;;

            var boundaryKey = Guid.NewGuid().ToString();
            var boundary = &quot;--&quot; + boundaryKey;
            req.ContentType = &quot;multipart/form-data; boundary=&quot; + boundaryKey;

            return Observable.Defer(() =&gt;
                    Observable.FromAsyncPattern&lt;Stream&gt;(req.BeginGetRequestStream, req.EndGetRequestStream)())
                .Do(stream =&gt;
                {
                    using (stream)
                    using (var sw = new StreamWriter(stream, new UTF8Encoding(false)))
                    {
                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;key\&quot;&quot;);
                        sw.WriteLine();
                        sw.WriteLine(ApiKey);

                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;message\&quot;&quot;);
                        sw.WriteLine();
                        sw.WriteLine(message);

                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;media\&quot;; filename=\&quot;&quot; + filename + &quot;\&quot;&quot;);
                        sw.WriteLine(&quot;Content-Type: application/octet-stream&quot;);
                        sw.WriteLine(&quot;Content-Transfer-Encoding: binary&quot;);
                        sw.WriteLine();
                        sw.Flush();

                        stream.Write(file, 0, file.Length);
                        stream.Flush();

                        sw.WriteLine();
                        sw.WriteLine(&quot;--&quot; + boundaryKey + &quot;--&quot;);
                        sw.Flush();
                    }
                })
                .SelectMany(_ =&gt; Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)())
                .Select(res =&gt;
                {
                    using (res)
                    using (var stream = res.GetResponseStream())
                    using (var sr = new StreamReader(stream, Encoding.UTF8))
                    {
                        return sr.ReadToEnd();
                    }
                });
        }
    }
}
</code></pre>
<p>認証ヘッダ作成はConstructBasicParametersとBuildAuthorizationHeaderというprotectedメソッドで行います。わけわかんないよね…気持ち悪いよね…。使いにくいメソッドです、すみません、私もそう思います。そういうものだと思って、見ないふりしてもらえれば幸いです。</p>
<p>コードの大半を占めているのは画像を投稿するためのmultipart/form-dataのもので、これはもうOAuth Echo関係ない話、で、面倒ぃ。特にWP7での非同期だと涙が出る。POSTはBeginGetRequestStreamとBeginGetResponseの二つの非同期メソッドをセットで使う必要があるため、コードがごちゃごちゃするのです。</p>
<p>しかし<a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>を使えばあら不思議！でもないですが、ネストがなくなって完全に平らなので、結構普通に読めるのではないでしょうか？(ストリーム書き込みのコード量が多いのは、これは同期でやっても同じ話なので)。例外処理も利用例のところで見たように、Catchメソッドをくっつけるだけ。実に色々とスッキリします。</p>
<p>Rxがあれば非同期POSTも怖くない。</p>
<p>やっていることは単純で、FromAsyncPatternでBegin-Endを変換。StreamへのWriteは後続への射影はなく、対象(Stream)に対しての副作用(書き込み)のみなのでDo、RequestStream-&gt;Responseへの切り替えはSelectMany、Responseから結果のStringへの変換はSelect、と、お決まりの定型メソッドに置き換えていっただけです。この辺はパターンみたいなものなので、これやるにはこのメソッドね、というのを覚えてしまえばそれでお終いです。</p>
<h2>Stream読み書きは非同期にしないの？</h2>
<p>StreamにもBeginReadとかBeginWriteとかありますものね。しかし、しません(ｷﾘｯ。理由は死ぬほど面倒だからです。やってみると分かりますが想像以上に大変で、おまけに何とか実現するためにはRxでのチェーンを大量に重ねる必要がありオーバーヘッドがバカにならない……。なので、わざわざやるメリットも全くありません。</p>
<p>一応、ReactiveOAuthのOAuthClientは、そこも非同期でやってますが、わざわざ頑張った意味があったかは、かなり微妙なところ。実装は Internal/AsynchronousExtensions.cs にあるので参照ください。それと、この AsynchronousExtensions.cs は<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>で言った「拡張メソッドのすゝめ」を実践したものでもあります。WebRequestはプリミティブすぎて扱い難いので、Rxに特化したうえで簡単に扱えるようにDownloadStringやUploadValueなどといったメソッドを拡張してあります。便利だと思いますので、こちらも TwitpicClient.cs と同様に、ファイルごと自由にコピペって使ってやってください。</p>
<h2>まとめ</h2>
<p>ReactiveOAuthを公開する目的に、「これが入り口になってRxの世界を知ってもらえると嬉しい」というのもあったのですが、WP7開発で利用してもらったりと、その目的は少しは達成出来たかもで、良かった良かった。ちょっと練りたりなかったり、未だにバグがあったり(本当にごめんなさい！)と至らない点も多いですが、今後も改善していきますのでよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-15" data-pagefind-meta="published:2011-06-15"><a href="https://neue.cc/2011/06/15_329.html">MSDNの上のReactive Extensions</a></h1>
<ul class="date"><li>2011-06-15</li></ul>
<div class="entry_body"><p>DevLabsを卒業し、晴れて正式に<a href="http://msdn.microsoft.com/en-us/data/aa937685" title="Data Developer Center">Data Developer Center</a>入りした<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>ですが、徐々に正式リリースへ向かう準備として、ついにドキュメントがMSDN入りを果たしました。</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/hh242985(v=VS.103).aspx" title="Reactive Extensions">MSDN Library &gt; .NET Development &gt; Reactive Extensions</a></li>
</ul>
<p>まだPre-releaseということで工事中の部分が多いですが、これはドキドキしますね。Getting Started with Rxはどんなところで使えるかの説明とダウンロード先について、Using Rxは詳細なドキュメント（まだ工事中項目も幾つか、でもかなり充実している感）、Reactive Extensions Class Libraryはリファレンス。必要十分には揃っていますね、あとは大きめのサンプルも欲しいところだけど、追加されるかな？</p>
<p>ところで、ツリー階層を見てください。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_msdn_tree.jpg">
</p>
<p>.NET Development直下です。何て素晴らしい位置にあるのか！Entity FrameworkやSilverlight
などと同列に並べられているのを見ると、ついに始まったな、と感無量です。</p>
<h2>その他のRx</h2>
<p>Rx本体が順風満帆なのに比べると、RxJSとIx(EnumerableEx)はどうしちゃったのでしょう……。まず、RxJSは、やる気は一応あるみたいです。ダウンロードも可能ですしね。APIは随分更新されていなくて、.NET版Rxとかなり差が開いてしまいましたが（バグも幾つか見つかっているのですが）。今はRxチーム自体がドキュメント周りで忙しいということで手を付けてられないっぽく、ゆっくり待つしかないです。プロジェクト自体は死んでいないそうなので、そこだけは安心してもいいかと。（私は内心不安ですが！）</p>
<p>Ixのほうは、一旦死亡です。ダウンロードセンターはもとより、NuGetからも、もう手に入らなくなりました。が、しかし、完全終了ではなく、一旦引っ込めて練りなおして、Rxとは別枠となるかもですが提供する意思はあるそうで。「Don't worry.  Ix is not disappearing forever.」とのこと。そこで、フィードバックが欲しいとのことなので、答えてあげるといいんじゃないかしら。<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/1a75496f-0b33-41c0-bf7a-92f9802c3f0a" title="Asking your input - Interactive Extensions functionality">Asking your input - Interactive Extensions functionality</a>。私も好きなメソッドと嫌いなもの(XxxEnumerableがIntelliSenseを汚染して嫌いだった)、それとドサクサに紛れて再帰/ツリー探索系のメソッドを入れてよ！とリクエストしておきました。</p>
<h2>NuGet</h2>
<p>6月頭にバージョンが少し上がって、現在はStableがv1.0.10605、Experimentalがv1.1.10605が最新バージョンとなっています。そしてNuGetのパッケージ名も少し変化して、Stable版はRx-MainなどプリフィックスがRx-のもの、ExperimentalはRx_Experimental-MainなどプリフィックスがRx_Experimental-と完全に別れて提供されるようになりました。</p>
<h2>と、まあ</h2>
<p>そんなところです。最近は私もこうして、更新されたよー、と言うだけで、技術的な情報提供を怠っていてすみませんすみませんなので、徐々に再開していきたいと思います。Schedulerの話とか非常に重要なのに、このブログでは一度も書いていないですしね、全くもってイクない。こないだのセッション<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041" title="Reactive Extensionsで非同期処理を簡単に">Reactive Extensionsで非同期処理を簡単に</a>は非同期中心だったので、イベントサイドについての話もしっかりまとめたいなあ、とかも思いつつ。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-09" data-pagefind-meta="published:2011-06-09"><a href="https://neue.cc/2011/06/09_328.html">linq.js入門記事を書きました</a></h1>
<ul class="date"><li>2011-06-09</li></ul>
<div class="entry_body"><p>お話をいただき、@ITの.NET TIPSに<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript - Home">linq.js</a>の入門記事を、二週に渡り書きました。</p>
<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/dotnettips/1058linqjsbasic/linqjsbasic.html" title="JavaScriptで配列をLINQにより処理できるライブラリ「linq.js」を利用するには？ － ＠IT">JavaScriptで配列をLINQにより処理できるライブラリ「linq.js」を利用するには？ － ＠IT</a></li>
<li><a href="http://www.atmarkit.co.jp/fdotnet/dotnettips/1059linqjquery/linqjquery.html" title="jQueryと「linq.js」を連携させてDOMをLINQにより処理するには？ － ＠IT">jQueryと「linq.js」を連携させてDOMをLINQにより処理するには？ － ＠IT</a></li>
</ul>
<p>このサイトでやると、アレもコレもとダラダラと書いてしまって分かりづらくなっていたのですが、記事では文字数制限などのお陰で構成がすっきり、校正してもらったお陰で文章の揺れもなく。つまるところ、ほとんど編集で助けてもらったというだけで、本当にありがとうございました。サンプルコードは、コードを見ただけで伝わるよう単純に、でもlinq.jsの威力を伝えなければならないので多少の複雑さは持たなければならない。などと思い結構悩んで作りました。</p>
<p>お陰様で反響も結構良かったみたいでなによりです。実績も良く分からない外部ライブラリは導入できない…… という方も、@ITに載ってるから大丈夫だよ！を説得材料(？)にできるのではないでしょうか。これを機に、是非試してみてください。</p>
<p>ところで幾つかの話。</p>
<h2>メソッド名大文字</h2>
<p>失敗した。かな……。特にTojQuery()でjQueryと見かけ上(あくまで見かけだけなんですが)シームレスに繋がっていると違和感が結構あります。以前に、jQueryとLINQの世界が視覚上切れて見えるから、むしろイイぐらいなんです、とか言ってましたが勿論ただの強がりです。この辺は今更変えにくいところで、どうしたものかな、と悩んでいるところです。</p>
<h2>パフォーマンスについて</h2>
<p>気になりますよね？ベンチマーク的に言えば、遅い。遅延評価の実現や豊富な機能は、速度を相当犠牲にしています。では、その遅さが許容できるほどか無視できないか。これは、卑怯な逃げ口になってしまいますが、状況次第。少なくとも普通のサイトでは問題ないレベルだと思いますし、また、ブラウザのJSはどんどん速くなっていってます。Chrome/Fx4/IE9の速さ！「許容できる」の範囲はどんどん広がっていってるのでは、と。</p>
<p>こういった話はC#でもそうです。LINQはベタforループより確実に遅い、が、じゃあベタforループで書くかといったら、よほどエクストリームに速度を求める場合以外は書きはしません。</p>
<p>Pentium3でWindows XPでIE6な奴らにも配慮する！というのも確かに美学なのですが、そうではない方向も見ないと、素敵な未来はやってこないのではないかな、って。21世紀にもなるのに<a href="http://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%97%E5%B1%95%E9%96%8B">ループアンローリング</a>で高速化！とかいう記事ばかりが踊る世界なんて悲しいじゃないですか。</p>
<p>モバイル機器のことも考えなければならないし、HTML5も控え、JavaScriptで高負荷な処理をすることも少なくないので、まだまだ時代は追いついていないけれど。それでも、私はもう少し先の未来を見ていたい……。JavaScriptがこれから先、本当に一級の言語となっていくのなら尚の事です。</p>
</div>
<a href="https://neue.cc/16">Prev |</a>
<a href="https://neue.cc/18">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/12/">2024-12</a>
<li><a href="https://neue.cc/2024/11/">2024-11</a>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
