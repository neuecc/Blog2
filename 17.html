<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="./pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 10,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2011-07-27" data-pagefind-meta="published:2011-07-27"><a href="https://neue.cc/2011/07/27_335.html">Deep Dive AsEnumerable</a></h1>
<ul class="date"><li>2011-07-27</li></ul>
<div class="entry_body"><p>AsEnumerable、といったらLINQのAsEnumerableです。その挙動は、IEnumerable&lt;T&gt;へと型変換をします。それだけ、なので実に影が薄いのですが、それでいて奥深く使いこなしが求められる、はずなのですが陰が薄いので無視されている感がなきにしもあらずなので、しっかりと紹介したいと思います。</p>
<h2>AsEnumerableの実装</h2>
<p>実装は非常に単純明快で、中身ほとんど空っぽです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;T&gt; AsEnumerable&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    return source;
}
</code></pre>
<p>ようするにアップキャストです。どういう時に使えばいいかというと、例えば可変長引数とIEnumerable&lt;T&gt;の両方を受けたいオーバーロードを作る場合。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public void Show(params string[] values)
{
    Show(values.AsEnumerable());
}

public void Show(IEnumerable&lt;string&gt; values)
{
    foreach (var item in values)
    {
        Console.WriteLine(item);
    }
}
</code></pre>
<p>foreachでグルグル値を取り出すだけなので、IEnumerable&lt;T&gt;で受けるようにしたい。でも利便性のため可変長引数も用意しておきたい。という場合はよくあります。なので毎回このオーバーロードを用意するんですが、その時に、こうしてAsEnumerableを使います。なお、AsEnumerableを忘れると無限に再帰してStackOverflowしてしまいます……。</p>
<p>AsEnumerableがラップするのではなく、ただのアップキャストにすぎないということは重要です。以前に<a href="http://neue.cc/2009/07/21_178.html" title="neue cc - LinqとCountの効率">LinqとCountの効率</a>でも書きましたが、LINQの一部のメソッドはIList&lt;T&gt;であったりICollection&lt;T&gt;であるとき、asやisを使って最適化を図ります。foreachするだけだとあまり関係ないですが、受け取ったIEnumerable&lt;T&gt;を使ってLINQで処理する場合だと、このことが効いてきます。</p>
<p>ならば常にアップキャストでよくて、ラップなど必要ないのではないか？というと必ずしもそうではありません。アップキャストは、ダウンキャストを可能にします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// アップキャストされている状態というのは
var numbers = new List&lt;int&gt;().AsEnumerable();

// ダウンキャストが可能にするということ、そして、ダウンキャストは危険
var list = (List&lt;int&gt;)numbers;
</code></pre>
<p>ダウンキャストが危険だ、やるな、というのなら、そもそもアップキャストをすべきではない。抽象で受けることこそがオブジェクト指向だとか、形だけのパターンにはまってるとそうなる。原則は比較的シンプルで。メソッドのシグネチャにおいて、引数の型は最大に受け入れるため出来る限り抽象で、戻り値の型は最大に利用出来るようにするため具象にすればいい。ローカル変数に関しては、原則varでよし。どうしても必要ならば、ローカル変数側、つまりメソッドの利用側が安全なアップキャストで適宜、抽象で受ければよいでしょう。</p>
<p>ダウンキャストはダメ基本的に。そして、ダウンキャストは可能な状態にすること自体がダメなので、アップキャストも最小限に。というのがメソッド定義の基本だと思っていますが、プロパティだと少し事情は変わってくるかも。一々ラップすることのパフォーマンスロスや手間を考えると、しかたがなくアップキャストで提供するのも、ありかなー、とは。</p>
<h2>Hide</h2>
<p>そんなわけで、具象型を消去して、完全にラップしてIEnumerable&lt;T&gt;として提供したいという場合もあるかと思います。そこで、Ix(Interactive Extensions、<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>のオマケで提供されているEnumerableの拡張メソッド群、NuGetの<a href="http://nuget.org/List/Packages/Ix_Experimental-Main" title="NuGet gallery">Ix_Experimental-Main</a>で入れるのが手っ取り早い。Experimentalのとおり、まだ実験的な代物で保証されていないことは注意)にはHideというものがあります。これも実装は単純明快で</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static IEnumerable&lt;T&gt; Hide&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    foreach (var item in source)
    {
        yield return item;
    }
}
</code></pre>
<p>といった形。Hideというメソッド名は具体的な型を隠す、といった意味合いで付けられているのでしょうね。</p>
<h2>Rx(AsObservable)の場合</h2>
<p>Enumerableと関連性の深いObservable、Rxにも同様に型変換をするAsObservableというメソッドが用意されています。主に使うシチュエーションは、Subjectの隠蔽をするときでしょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 5秒後に非同期で値を返すというだけのもの
public static IObservable&lt;T&gt; SendValueAfter5Seconds&lt;T&gt;(T value)
{
    var asyncSubject = new AsyncSubject&lt;T&gt;();

    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        Thread.Sleep(TimeSpan.FromSeconds(5)); // とりまsleep

        asyncSubject.OnNext(value); // AsyncSubjectのキャッシュへ値送信
        asyncSubject.OnCompleted(); // 非同期処理完了の合図（ここでObserverに値が送られる）
    });

    return asyncSubject.AsObservable();
}
</code></pre>
<p>このコード自体には何の意味もありません、非同期処理を模して、スレッドプールで5秒待って値を送る、というだけです。大事なのはAsyncSubjectをAsObservableして返していること。このAsObservableはただのアップキャストではなく、新しい型でラップして具象型(AsyncSubject)を隠しています。つまり、AsEnumerableではなくHideに等しい挙動です。ここで、もしAsObservableを書いていないと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// return時にAsObservableが書かれていないとダウンキャスト可能になる
var subject = (AsyncSubject&lt;int&gt;)SendValueAfter5Seconds(100);

subject.Subscribe(Console.WriteLine);

// なので、外側から発火可能になってしまう、これは最悪
subject.OnNext(-1);
subject.OnCompleted(); 
</code></pre>
<p>Subject（標準だと4種類ある）は、Rxにおけるイベントの表現です。C#でのイベントは、内部からは発火可能、外側からは購読しかできない。というようになっていると思います。その挙動にするために、また、純粋に安全性のために、Subjectを購読させるために外側に出す場合は、AsObservableでラップして型を消さなければなりません。</p>
<p>※極初期(RxがReactive Frameworkと言われていた頃なぐらいに前)は、このAsObservableはHideというメソッド名でした。AsObservableのほうが分かりやすくて良いとは思いますが、Enumerableでの挙動と合わせるなら、キャストするだけのAsObservableとHideに分けるべきだったのでは？と思わなくは全くないです←Rxにおいてはただのキャストしただけのものは使う機会ないと思うので、現在の形で正解</p>
<h2>IQueryableにおけるAsEnumerableの重要性</h2>
<p>Enumerable、Observableと来たので、QueryableでのAsEnumerableも見てみましょう。QueryableにおけるAsEnumerableは、クエリ構築の終了です。IQueryableでのクエリ構築をそこで打ち切るというスイッチです。どういうことか、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// とあるContextによるQueryableはSkipWhileとCountをサポートしていなかったとします
var count = toaru.createContext() // IQueryeable&lt;T&gt;とする
    .Where(x =&gt; x % 2 == 0)
    .SkipWhile(x =&gt; x &lt; 100)
    .Count(); // 未サポートなのでExceptionが来る！

// そういう場合、ToListするといい、というアドバイスがよく上がります
var count = toaru.createContext()
    .Where(x =&gt; x % 2 == 0)
    .ToList() // ここまでの式でクエリ生成+List化
    .SkipWhile(x =&gt; x &lt; 100) // ここからはIEnumerable&lt;T&gt;
    .Count();

// でも、それならAsEnumerableでいいんだよ？
var count = toaru.createContext()
    .Where(x =&gt; x % 2 == 0)
    .AsEnumerable() // 後続がGetEnumeratorを呼んだ時にここまででクエリ生成
    .SkipWhile(x =&gt; x &lt; 100) // ここからはIEnumerable&lt;T&gt;
    .Count();
</code></pre>
<p>Queryableの連鎖で、例えばLinq to SqlだったらSQL文を作っていきます。で、foreachであったりToListであったりをすると、SQLが作られて発行されてデータベースと通信されて。それって、どのタイミングでQueryableの中の式木がSQL文に変換されるかというと、GetEnumeratorが呼ばれた時、です。それはいつ呼ばれるの？というと、foreachされたりToListされたり、AsEnumerableしてその後のEnumerableのメソッドがGetEnumeratorを呼んだ、その時。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/quaryable_getenumerator_enumerable.jpg">
</p>
<p>こんな感じです。ToArrayやToListは、そこで実体化するので、メソッドチェーンの後続がIEnumerable&lt;T&gt;なのは当然のことですが、AsEnumerableがただのキャストにすぎないのに意味合いが変化するのは、拡張メソッドの解決の優先度のため。型がIQueryable&lt;T&gt;の状態だとWhereやSelectはQueryableのWhereやSelectが選択されますが、型がIEnumerable&lt;T&gt;の状態だとEnumerableのWhereやSelectが選択される、ということです。Enumerable自体は遅延評価なので、後続のIEnumerable&lt;T&gt;がGetEnumeratorを呼び出したときに評価が開始されるのは変わらず。</p>
<p>AsEnumerableやToArray、ToListは実はQueryableクラスにはありません。なので、素の状態で拡張メソッドの解決がIEnumerable&lt;T&gt;側を呼び出すようになっています。</p>
<p>ところでクエリ文の構築はGetEnumeratorが呼ばれた時と言いましたが、GetEnumeratorを呼ばないとき、例えばQueryableでのFirstやSumはどうなっているのかというと、内部でExecuteが呼ばれた時です。IQueryProviderはこんなインターフェイス。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public interface IQueryProvider
{
    IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression);
    TResult Execute&lt;TResult&gt;(Expression expression);
    // 非ジェネリックなものもありますが省略
}
</code></pre>
<p>FirstやSumなど、単独の結果を返すものは内部でExecuteを呼びます。なので、クエリプロバイダの実装次第ですが、通常はこのExecuteが呼ばれた時にクエリ文の構築と実行を同時に行うものと思われます。SelectやWhereなど、後続にIQueryableのチェーンを繋げるものは、内部でCreateQueryのほうを呼びます。そして最終的に複数の結果(IEnumerable&lt;T&gt;)を返す場合は、GetEnumeratorが呼ばれた時にクエリ文の構築と実行を行うものと思われます。</p>
<h2>まとめ</h2>
<p>AsEnumerableは、ようするにただのキャストなだけですが、その果たしている役割というものを考えると非常に深い。その割には(QueryableでToListばかり使われたりと)今ひとつ知名度に欠ける気もしますので、ドサッと紹介を書いてみました。ただのキャストだって語ろうと思えば幾らでも語れるLINQは素敵ですね！</p>
</div>
<h1 data-pagefind-sort="date:2011-07-25" data-pagefind-meta="published:2011-07-25"><a href="https://neue.cc/2011/07/25_334.html">DynamicObjectでより沢山の型情報を取る方法</a></h1>
<ul class="date"><li>2011-07-25</li></ul>
<div class="entry_body"><p><a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>のAsDynamicに少し不具合があったので、ver.1.5.0.0として更新しました。今まではメソッドの引数にnullを渡すと死んでました。ぬるぽ！まあしかし、引数そのもののからしかTypeが取れなかったので、nullだと、どのみちメソッドを特定するための型情報がないからオーバーロードの解決は不可能なので、仕様ですよ仕様、という言い訳。</p>
<p>などとふざけたことを思っていたのですけれど、コンパイル時に決定される引数の型を取り出す方法が判明したので、そのへんも含めて完全に解決しました。やったね。その方法は、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
{
    var csharpBinder = binder.GetType().GetInterface(&quot;Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder&quot;);
    if (csharpBinder == null) throw new ArgumentException(&quot;is not csharp code&quot;); // CSharpコードではない

    // ジェネリックの型引数の取得(Hoge&lt;T&gt;(1, t)とかでのTのこと)
    var typeArgs = (csharpBinder.GetProperty(&quot;TypeArguments&quot;).GetValue(binder, null) as IList&lt;Type&gt;).ToArray();
    // コンパイル時に決定されているパラメータの型の取得
    var parameterTypes = (binder.GetType().GetField(&quot;Cache&quot;, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(binder) as Dictionary&lt;Type, object&gt;)
        .First()
        .Key
        .GetGenericArguments()
        .Skip(2)
        .Take(args.Length)
        .ToArray();
    
    // それらの情報からMethodInfoを特定する
    var method = MatchMethod(binder.Name, args, typeArgs, parameterTypes);
    // 呼び出し
    result = method.Invoke(target, args);

    return true; // 呼べてれば必ずTrueなので。
}
</code></pre>
<p>……。ひどそうな匂いが！まず、素のままでは情報が足りなすぎるので、基本的にリフレクション全開です。その中でも、parameterTypesが今回追加したところです。binderのCacheに、CallSiteのデリゲート(dynamicを使って呼び出すと、コンパイル時にこの辺のものが自動生成される)があるので、そこから型情報を持ってこれることに気づいたのだ(ｷﾘｯ</p>
<p>もう少し詳しく説明しますと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// このヘンテツもないどうでもいいコードは
dynamic d = null;
var result = d.Hoge&lt;string, int&gt;(100, (string)null, (ICollection&lt;int&gt;)null);

// コンパイル後はこんな結果に化けちゃいますあら不思議！
object d = null;
if (Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1 == null)
{
	Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1 = CallSite&lt;Func&lt;CallSite, object, int, string, ICollection&lt;int&gt;, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.None, &quot;Hoge&quot;, new Type[]
	{
		typeof(string), 
		typeof(int)
	}, typeof(Program), new CSharpArgumentInfo[]
	{
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null), 
		CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, null)
	}));
}
object result = Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1.Target(Program.&lt;Main&gt;o__SiteContainer0.&lt;&gt;p__Site1, d, 100, null, null);
</code></pre>
<p>細かい部分はどうでもいいので、良く分からないFuncが生成されてるんだな、というとこだけ見てもらえれば。さて、これを頭に入れた上で、DynamicObjectのTryInvokeMemberでbinderの奥底のCacheを探してみると、</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/binder_cache.jpg">
</p>
<p>このFunc6というものが、Func&lt;CallSite, object, int, string, ICollection&lt;int&gt;, object&gt;です、発見出来ました！これの型引数が、コード上での呼び出し時の型引数になるわけです。なお、第一引数はCallSite、第二引数はインスタンスなので無視してSkip(2)、そして引数の個数分だけTake(まあ、ようするに最後が戻り値の型なわけですが)。</p>
<p>というわけで、実際に改善されたAsDynamicを使ってみますと、</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こんな何のヘンテツもないオーバーロードのあるクラスがあるとして
public class PrivateClass
{
    private string Hoge(IEnumerable&lt;int&gt; xs)
    {
        return &quot;enumerable&quot;;
    }

    private string Hoge(List&lt;int&gt; xs)
    {
        return &quot;list&quot;;
    }
}

// 型はdynamicです←意地でもvarで書きたい人
var mock = new PrivateClass().AsDynamic();

// 型でオーバーロード分けが出来るようになった！
List&lt;int&gt; list = new List&lt;int&gt;();
IEnumerable&lt;int&gt; enumerable = new List&lt;int&gt;();

(mock.Hoge(list) as string).Is(&quot;list&quot;);
(mock.Hoge(enumerable) as string).Is(&quot;enumerable&quot;);
</code></pre>
<p>というわけで、より正確なオーバーロードの解決が図れるようになりました。何をアタリマエのことを言ってるんだお前は、と思うかもしれませんが、TryInvokeMemberに渡ってくる情報はobject[] argsなのです。args[0]の型はobjectなわけで、それをGetTypeしたら、出てくるのはList&lt;int&gt;なのです。何をどうやっても、.csファイルではIEnumerable&lt;int&gt;と書かれているという情報を得ることは出来なかったわけです、今までは。ましてやnullだったら型もヘッタクレもなかったわけです。でもこれからは違う。コード上のデータが取れる！</p>
<p>などとツラツラと書いてみましたが、利用者的にはどうでもいい話ですね、はい。それに、リフレクションはいいとしても、Cacheって何よ？CacheのFirstが決め打ちなのって何よ？などなどは、ぶっちゃけよくわかっていなくて(だって全部internalだしね……)若干怖いのですが、まあ、多分、大丈夫でしょう、多分……。それと、まだ完璧じゃあなくてサポートしてないオーバーロードのケースが幾つかあります。とはいえ、ほとんどのシチュエーションでは問題ないのではかと思います。</p>
<h2>まとめ</h2>
<p>この<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>ですが、私は結構普通に使いまくっていて、ないと死にます。激しく便利。そうそう、紹介しますと、 actual.Is(expected) と、メソッドチェーン形式で流れるようにアサーションが書けます。ラムダ式での指定やコレクションへの可変長引数など、ちょうどかゆいところに手が届く拡張を施してあって、随分とテストを書くのが楽になります。</p>
<p>AsDynamicは、オマケ機能というか。privateなメソッドやプロパティ、フィールドにもdynamicを通してアクセス出来るように変換します。たまにしか使いませんが（MSTestにはPrivate Accessorがあるので）、あると便利よね、という時もそこそこあり。</p>
<p>MSTestだけではなく、NUnitやMbUnit、xUnit.NETでも使えますので＆NuGet経由でも入れられますので、一度是非お試しを。</p>
</div>
<h1 data-pagefind-sort="date:2011-07-09" data-pagefind-meta="published:2011-07-09"><a href="https://neue.cc/2011/07/09_333.html">非同期の再帰的な辿り方、或いはRxとC# 5.0 Asyncの連携について</a></h1>
<ul class="date"><li>2011-07-09</li></ul>
<div class="entry_body"><p>例えば、ページを辿る。何度もアクセスを繰り返して、辿る。非同期で。単純なようで、やってみると何気にこれが結構難しい。例としてコードレシピの<a href="http://code.msdn.microsoft.com/Reactive-ExtensionsTwitter-b8238b51">Reactive Extensionsを使用してTwitterから非同期にデータを取得し表示する</a>がありました。MVVMも絡めて、素晴らしいサンプルですね！</p>
<p>というわけで、お題を拝借して、Twitter ApiのGET statuses/friendsを使わせて頂きます。んが、今回は、手を抜いてフォロワーのscreen_name(@hogehogeのhogehogeの部分)だけを取れれば良い、ということにします。JSON解析やデシリアライズも面倒だし話の本題でもないので省略するため、<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>を使って、JSONを生のまんまっぽく扱うことにします。DynamicJsonは便利だなあ（棒）</p>
<p>さて、まずTwitter APIのcursorですが、大体こんな風になっています。目的はカーソルを辿って全てのuser(に含まれるscreen_name)を集めること。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/twitter_nextcursor.jpg">
</p>
<p>JSON取得毎にnext_cursor_strという、次のページへのIDが取れるので、それを辿っていって、0が出たらページ末尾。といった具合です。next_cursor_strの値は一見ランダムに見える整数(2121409421とかそんな値になっている)であり、next_cursorという数字のものもあるのに、_strという文字列として得られるほうを使っています。何故かというと、<a href="http://d.hatena.ne.jp/tmyt/20101201/1291166929">TwitterのステータスIDが53bitを越えたお話 - tmytのらくがき</a>を参照ください。DynamicJsonでは数字(Number)はdoubleとして扱うので、_strのほうを使わないと、危ういわけです。</p>
<p>まあ、ただのお題で本題な話ではないので、その辺は深く考えずそういうものなのだなあ、ぐらいで。</p>
<h2>同期とyield returnと非同期</h2>
<p>コードレシピのサンプルを見させて頂いたのですが、ネットワークアクセス部分がOpenReadなので、非同期&quot;ではない&quot;です。でも挙動は非同期だよ？というのは、Scheduler.ThreadPoolを使っているからなわけですが、つまるところ挙動的にはBackgroundWorkerを使って非同期にするのと同じことです。その場合ですと、Generateも確かに良いのですが、APIへのアクセスがそもそも同期であるならば、難しく考える必要はなく、yield returnを使ったほうが簡単です。単純なものは演算子の組み合わせで、複雑なものは素直に偉大なるコンパイラ生成(yield return)に頼る。そういう切り分けがLINQ的には大事かなって。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IEnumerable&lt;string&gt; EnumerateFriends(string screenName)
{
    var cursor = &quot;-1&quot;; // 初期値は-1から
    while (cursor != &quot;0&quot;) // 0が出たら終了
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        using (var stream = new WebClient().OpenRead(url))
        {
            var json = DynamicJson.Parse(stream); // 面倒くさいんでDynamicJson使いますよ:)
            foreach (var item in json.users)
            {
                yield return item.screen_name; // screen_nameを列挙
            }
            cursor = json.next_cursor_str; // 次のカーソルにセット
        }
    }
}

static void Main()
{
    var friends = EnumerateFriends(&quot;neuecc&quot;).ToArray();
}
</code></pre>
<p>すっきりと書けるのが分かると思います。え、これだとブロックしてしまって良くない？その通り。じゃあ非同期にしましょう。いえ、<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>で簡単にできてしまいます。yield returnで生成されたEnumerableをObservableに変換するのは、ToObservableです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static void Main()
{
    EnumerateFriends(&quot;neuecc&quot;)
        .ToObservable(Scheduler.ThreadPool) // ThreadPoolで実行！
        .Subscribe(Console.WriteLine);
        
    Console.ReadLine(); // 終了してしまうからね
}
</code></pre>
<p>ToObservableはデフォルトでは Scheduler.CurrentThread 上で実行されるため、同期的にブロックしますが(※Push型シーケンスだからといって必ずしも非同期とは限らない)、任意のものに変更することも可能です。今回はScheduler.ThreadPoolを指定したので、ThreadPool上で動くようになっています。そのため、ブロックされません。</p>
<p>こういった書き方のほうが、コードがクリアになるし、IEnumerable&lt;T&gt;とIObservable&lt;T&gt;に両対応できてる、という柔軟性の点でも良いかと思います。また、BackgroundWorkerを使うよりも遥かに簡単ですよね。プログレス通知もなく、ただ処理をバックグラウンドでやりたい、というだけならば、Rxを使ったほうが楽チンです。プログレスが必要な場合は、Rxだとその辺の処理を作りこまなければならないので、素直にBackgroundWorkerを用いるのもいいかもしれません。私だったらRxをちょっと拡張してプログレス処理を作り込むほうを選ぶかな？その辺の話は<a href="http://neue.cc/2010/12/09_288.html" title="neue cc - Reactive ExtensionsとAsync CTPでの非同期のキャンセル・プログレス処理">Reactive ExtensionsとAsync CTPでの非同期のキャンセル・プログレス処理</a>を参照ください。</p>
<p>また、Observable化するとPublishによる分配 - <a href="http://neue.cc/2010/04/29_255.html" title="neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions">C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions</a>など、色々と応用な使い方が広がるのもメリットの一つと言えるでしょう。</p>
<h2>Async CTP</h2>
<p>今回は例がWPFなため、WebClientで同期的(OpenRead)に取ってしまいましたし、それでも全然問題ないわけですが、SilverlightとかWP7だったらこの手(同期でJSON取ってきてyield returnで返す)は使えません。同期のOpenReadがそもそもなくて、非同期のOpenReadAsyncしかないからね。どうしましょう？それだとyield returnが使えないのはモチロンのこと、Generateでもうまく動きません。もしページ番号がカーソルのように不定ではなく1,2,3...といった形で辿れたとしても、Observable.Rangeでやると、うまくいきません。非同期なので結果が帰ってくる時間が不定だからです。結果を取得してから次の結果を取得する、という形式にしないとダメなのです。</p>
<p>ところでそもそも、同期的に書いたとしても、本来は書くのは大変なはずなのです。それが、yield returnというコンパイラ生成があるから簡単に書ける。ということは、そうです、非同期もコンパイラ生成してしまえばいいのです、ということで<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360">Async CTP</a>で書きましょう。Async CTPはC# 5.0で入る、かもしれない、async/await構文を使えるようにするためのものです。コミュニティテクノロジープレビュー。ようするにベータ版ですね。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// このコードはAsync CTP (SP1 Refresh)によるもので、将来的にも同じコードで動作することは保証しません
async static Task&lt;List&lt;string&gt;&gt; EnumerateFriends(string screenName)
{
    var list = new List&lt;string&gt;();

    var cursor = &quot;-1&quot;;
    while (cursor != &quot;0&quot;)
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        using (var stream = await new WebClient().OpenReadTaskAsync(url)) // await!
        {
            var json = DynamicJson.Parse(stream);
            foreach (var item in json.users)
            {
                list.Add(item.screen_name); // yield returnの代わりに……
            }
            cursor = json.next_cursor_str;
        }
    }

    return list;
}
</code></pre>
<p>Async CTPは簡単に解説すると、awaitキーワードを使うと、本来非同期のものが同期のように書けるようになります。詳しくは<a href="http://ufcpp.net/study/csharp/sp5_async.html">非同期処理 (C# によるプログラミング入門)</a>を参照のこと。コード的にも見たように、差異はWebClientのOpenReadの部分を、await OpenReadTaskAsyncに変更しただけで、あとはまるっきり一緒です。非同期なんて簡単なものだね。と、言いたかったのですが、全部読み込んでListで返してるぢゃん……。これじゃEnumerateじゃないよ、yield returnじゃないの？これだと結果取得に時間かかるし、Takeなどを用いて、途中で止めることもできないし。あまりよくない。</p>
<p>結論としては今のところどうやら無理ということで。asyncの返すものはTaskもしくはTask&lt;T&gt;でなければならない。いや、Task&lt;IEnumerable&lt;T&gt;&gt;を返してくれればいいぢゃん、await yield returnとか出来たら素敵ぢゃないのん？と思わなくもないというか、<a href="http://social.msdn.microsoft.com/Forums/en-ZW/async/thread/f7a42c29-4ee6-4a3c-b346-b3718e253dc0">普通にそういうリクエストも上がっている</a>のですが、それにはIAsyncEnumerable&lt;T&gt;のようなものと、それに対するコンパイラサポートが必要だよね、という返しでした。</p>
<h2>Rx + Async</h2>
<p>IAsyncEnumerable&lt;T&gt;、それってIObservable&lt;T&gt;で代替出来る話だよね。IObservable&lt;T&gt;は連続的な非同期を内包しているから。（※IObservable&lt;T&gt;は一つのインターフェイスであまりにも多くのものを表現出来てしまい、内部の状態が読みづらく(同期なのか非同期なのか、遅延なのか即時なのか)混乱を生みがちという問題もありますが……）。なので、Rxでやってみましょう。といっても、Rxで完全に自前でやるのは相当大変なので、Async CTPのサポートも併用します。これにより非同期の待機が同期的に書けるようになり、yield returnであったりlist.Addであったりの部分を、OnNextに置き換えるだけになります。</p>
<p>Stable版のRxにはAsync CTP連携は入っていないのですが、Experimental(実験的)版には、awaitで待機出来る、というだけはなく、幾つかAsync CTPと連携できるメソッドが入っています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ExperimentalのRxのため、将来的にもこのコードが動作し続けることは保証しません
static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    // ラムダ式の中でasync書けることがポイント
    return Observable.Create&lt;string&gt;(async (observer, cancelToken) =&gt;
    {
        try
        {
            var cursor = &quot;-1&quot;;
            while (cursor != &quot;0&quot;)
            {
                if (cancelToken.IsCancellationRequested) return; // cancelをチェック

                var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
                    screenName, cursor);
                using (var stream = await new WebClient().OpenReadTaskAsync(url)) // await!
                {
                    var json = DynamicJson.Parse(stream);
                    foreach (var item in json.users)
                    {
                        observer.OnNext(item.screen_name); // yield returnのかわりに
                    }
                    cursor = json.next_cursor_str;
                }
            }
        }
        catch (Exception ex)
        {
            observer.OnError(ex);
            return; // 例外発生時はOnErrorを呼んで終了
        }

        observer.OnCompleted(); // 例外発生もキャンセルもなく完了したなら、OnCompletedを呼ぶ
    });
}

static void Main()
{
    EnumerateFriends(&quot;neuecc&quot;)
        .Take(350) // 350件後にDisposeされてtokenがcancelになる
        .Subscribe(
            s =&gt; Console.WriteLine(s),
            e =&gt; Console.WriteLine(&quot;error:&quot; + e),
            () =&gt; Console.WriteLine(&quot;完了&quot;)); // Takeのほうから呼び出されるので、cancel扱いになっても表示される

    Console.ReadLine();
}
</code></pre>
<p>Observable.Create(RangeやGenerateなどの生成子、WhereやSelectなどの演算子の全てが使っている、本当のプリミティブの生成子)を使って、生のobserverでOnNext, OnError, OnCompletedの3つを制御してやります。Createやtry-catchの分、ネストが深くなってしまっていますが、コード自体は同期的に、yield returnを使って書いていたものとほとんど変わってないのが分かると思います。yield returnの部分にOnNextを置いた、それだけでそのまま置き換えられています。</p>
<p>これならIObservable&lt;T&gt;でも十分に自動生成のサポートが効いていると言えなくもないですね。やってみて、結構満足できてしまった。パフォーマンス的にも、演算子をベタベタ組み合わせるのはあまり良くはならないので、こうしてasync/awaitと連携させて作れると、素直に書けるうえに、パフォーマンス向上も狙えるのが嬉しい。ただ、OnErrorやOnCompleted、キャンセル(Dispose)をどうするか。考慮する事項が多いので、ある程度分かっていないと大変かもしれません。全て考えておかないと、正しく動作しません。既存演算子の組み合わせだけで済ませられるなら、そういった考慮事項は演算子が受け持ってくれるので、考えなくて済むのですが……。どうしても演算子の組み合わせじゃうまく出来ない、逆に複雑になりすぎる、そういった時の奥の手、ぐらいに考えておくと良さそう。</p>
<p>ところでasyncはメソッドの宣言だけでなく、ラムダ式の部分でも宣言できてawaitすることが出てきてしまうんですよね、ならば、同じようなコンパイラ生成であるyield returnも、現状は外部メソッドでしか使えないわけですが、以下のようにインラインでも使えるようになってくれると嬉しいなって。思ってしまうのです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 妄想なので、現状はこれは出来ませんが！
var infinity = Enumerable.Create(()=&gt;
{
    var num = 0;
    while(true)
    {
        yield return num++;
    }
});
</code></pre>
<p>そんなもの散々突っ込み受けたですって？<a href="http://blogs.msdn.com/b/ericlippert/archive/2009/08/24/iterator-blocks-part-seven-why-no-anonymous-iterators.aspx">Iterator Blocks Part Seven: Why no anonymous iterators? - Fabulous Adventures In Coding</a>。ええ、知ってます。しかし、awaitなどで必要さの要請を受けて、コストとベネフィットが逆転するときが来た、と、思うのです。それに、VBでも、いや、なんでもない。</p>
<h2>Expand</h2>
<p>さて、ともかくAsync CTPは未来の話であり、現状手元にあるもので何とかする方法はないのだろうかというと、あります。ようするところ、再帰的に辿ってるわけですよね、cursorを。じゃあ、Expandです。Expandは<a href="http://neue.cc/2011/06/30_331.html">Reactive Extensions v1.0安定版リリース</a>でEnumerableバージョンのものを説明しましたが、Observableバージョンもあります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 補助メソッド、Async CTPにはOpenReadTaskAsyncとか、そういうのがデフォで用意されてますが、
// Rxにはないので、自前で用意しなきゃあいけないという、それだけの話です(ダウンロードしてストリングを返すだけのもの)
public static class WebRequestExtensions
{
    public static IObservable&lt;string&gt; DownloadStringAsync(this WebRequest request)
    {
        return Observable.Defer(() =&gt; Observable.FromAsyncPattern&lt;WebResponse&gt;(
                request.BeginGetResponse, request.EndGetResponse)())
            .Select(res =&gt;
            {
                using (var stream = res.GetResponseStream())
                using (var sr = new StreamReader(stream))
                {
                    return sr.ReadToEnd();
                }
            });
    }
}

// ExpandはStable版にはまだ搭載されていないので、Experimental版を使ってください
static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    Func&lt;string, IObservable&lt;dynamic&gt;&gt; downloadJson = cursor =&gt;
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        return WebRequest.Create(url).DownloadStringAsync().Select(DynamicJson.Parse);
    };

    return downloadJson(&quot;-1&quot;)
        .Expand(d =&gt; (d.next_cursor_str == &quot;0&quot;)
            ? Observable.Empty&lt;dynamic&gt;() // TakeWhileで判定すると最後の一つを取りこぼすので
            : downloadJson(d.next_cursor_str))
        .SelectMany(d =&gt; (dynamic[])d.users)
        .Select(d =&gt; (string)d.screen_name);
}
</code></pre>
<p>そこそこ直感的ではないでしょうか？最初 Expand().TakeWhile(next_cursor_str != &quot;0&quot;) と書いたのですが、それだと最後のページを取りこぼしてしまうのに気づいて、Emptyを投げる方針に変更しました。その辺、境界については注意を払わなきゃですね。</p>
<p>そして、残念ながら、ExpandはRxのStable版にはまだない。ということはWP7にもないわけで。</p>
<h2>再帰とRx</h2>
<p>Stable版でもやりましょう。awaitなし、Expandなし。では、どうやって作りましょうか。うーん、再帰的というのなら、本当に再帰させてしまえばいいのではないか？</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IObservable&lt;string&gt; EnumerateFriends(string screenName)
{
    Func&lt;string, IObservable&lt;dynamic&gt;&gt; downloadJson = null; // 再帰するにはこーして最初にnull代入
    downloadJson = cursor =&gt;
    {
        var url = string.Format(&quot;http://api.twitter.com/1/statuses/friends.json?screen_name={0}&amp;cursor={1}&quot;,
            screenName, cursor);
        return WebRequest.Create(url)
            .DownloadStringAsync()
            .Select(DynamicJson.Parse) // ここまでExpandと共通
            .SelectMany(json =&gt;
            {
                // Expandメソッドの中でやってることを大幅簡易化、ということです、つまるところ。
                var next = (json.next_cursor_str == &quot;0&quot;)
                    ? Observable.Empty&lt;dynamic&gt;()
                    : downloadJson((string)json.next_cursor_str);
                return (IObservable&lt;dynamic&gt;)Observable.StartWith(next, json);
            });
    };

    return downloadJson(&quot;-1&quot;)
        .SelectMany(d =&gt; (dynamic[])d.users) // ここからもExpandと共通
        .Select(d =&gt; (string)d.screen_name);
}
</code></pre>
<p>これを再帰というには、あまり再帰してないのですが、まあ雰囲気雰囲気。Expandと大体共通です。つまるところ、Expandを自前で作る、のは結構大変なので、Expandのように汎用的ではなく、特化したものをその場で作る、といった程度の代物。そうすれば、少しは簡単に用意できます。</p>
<h2>まとめ</h2>
<p>同期でListに格納するだけなら簡単。遅延でやるのもyield returnのお陰で簡単。非同期で辿るのは難しい。awaitで複数の値をyield的に列挙するのは現状難しい。Rxとawaitの連携は大変素晴らしい。Expandは便利。なければないで何とかなる。でもやっぱ大変。</p>
<p>一見簡単なことが存外難しいってのはいくないですね。一見簡単なら、簡単なままでできないと。Expandも悪くはないんですけど、中々どうして慣れてないと分かりづらい。しかし、将来のC#には十分期待できそう。と、思いました、まる。あとRxとAsyncは全然仲良しなんですよ～、というところです。</p>
</div>
<h1 data-pagefind-sort="date:2011-07-06" data-pagefind-meta="published:2011-07-06"><a href="https://neue.cc/2011/07/06_332.html">Rxでのイベント変換まとめ - FromEvent vs FromEventPattern</a></h1>
<ul class="date"><li>2011-07-06</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の機能の一つに.NETにおけるイベントをIObservable&lt;T&gt;に変換する、というものがあります。<a href="http://msdn.microsoft.com/en-us/library/hh242978(v=VS.103).aspx">Bridging with Existing .NET Events</a>。そして、そのためのメソッドがFromEventでした。ところが最近のRxでは二つ、FromEventとFromEventPatternが用意されています。この差異は何なのでしょうか？</p>
<p>結論としては、過去のRx(このサイトの古い記事や他のサイトの過去の記事などで触れられている)やWindows Phone 7でのFromEventはFromEventPatternに改名されました。後続にEventPatternという(object Sender, TEventArgs EventArgs)を持つ.NETのイベントの引数そのものを渡すものです。そして、空席になったFromEventに新しく追加されたFromEvent(紛らわしい！)は、EventArgsだけを送ります。それ以外の差異はありません。</p>
<p>つまるところFromEventは FromEventPattern.Select(e =&gt; e.EventArgs) ということになります。なら、それでいいぢゃん、何も混乱を生む(WP7のFromEventがFromEventPatternである、というのは致命的よねえ)ことはないよ、とは思うのですが、パフォーマンスの問題でしょうかね。確かに、Senderは必要なく使うのはEventArgsだけの場合が多い。それなのに、毎回EventPatternを生成していたり、Selectというメソッド呼び出しが入るのは無駄です。</p>
<p>そもそもインスタンスに対してFromEventで包むということは、クロージャでsenderは変数としていつでもどこでも使えてしまうのですよね、そもそも、そもそも。そういう意味でも送られてくるのはEventArgsだけでいいのであった。というわけで、基本的にはFromEventでいいと思います。</p>
<h2>FromEventPatternについて</h2>
<p>では、改めてFromEventPatternを復習します(WP7の人はFromEventで考えてください)。<a href="http://msdn.microsoft.com/en-us/library/hh229705(v=VS.103).aspx">Observable.FromEventPattern(TEventArgs) Method (Object, String) (System.Reactive.Linq)</a>にサンプルコードがあるのですけれどね。そうそう、MSDNのリファレンスには、一部のメソッド/一部のオーバーロードにはサンプルコードがあります。全部ではないのがミソです、見て回って発掘しましょう。まあ、というわけで、とりあえずそのFileSystemWatcherで。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FileSystemWatcherは指定フォルダを監視して、変化があった場合にイベントを通知します
// 例えばCreatedイベントはファイルが作成されたらイベントが通知されます
var fsw = new FileSystemWatcher(@&quot;C:\&quot;, &quot;*.*&quot;) { EnableRaisingEvents = true };

// FromEventPatternその1、文字列でイベント名指定
Observable.FromEventPattern&lt;FileSystemEventArgs&gt;(fsw, &quot;Created&quot;)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));

// FromEventPatternその2、静的なイベントをイベント名指定(WP7にはない)
Observable.FromEventPattern&lt;ConsoleCancelEventArgs&gt;(typeof(Console), &quot;CancelKeyPress&quot;)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.SpecialKey));
</code></pre>
<p>一番馴染み深いと思うのですが、文字列でイベント名を指定するものです。その2のほうはあまり見ないかもしれませんが、静的イベントに対しての指定も可能です。これら文字列指定によるメリットは、比較的シンプルであること。デメリットは、リフレクションを使うので若干遅い・スペルミスへの静的チェックが効かない・リファクタリングが効かない、といった、リフレクション系のデメリットそのものとなります。</p>
<p>リフレクションしかないの？というと、勿論そんなことはありません。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEventPatternその3、EventHandlerに対する変換
var current = AppDomain.CurrentDomain;
Observable.FromEventPattern(h =&gt; current.ProcessExit += h, h =&gt; current.ProcessExit -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs));

// FromEventPatternその4、EventHandler&lt;T&gt;に対する変換
Observable.FromEventPattern&lt;ContractFailedEventArgs&gt;(
        h =&gt; Contract.ContractFailed += h, h =&gt; Contract.ContractFailed -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.Message));

// FromEventPatternその5、独自イベントハンドラに対する変換
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; new FileSystemEventHandler(h),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>イベントの登録と削除を行うためのラムダ式を渡してやります。その3とその4は比較的分かりやすいのではないでしょうか。その5の第一引数が謎いのですが、これはconversionです。C#の型システムの都合上、そのまんまだと独自イベントハンドラを処理出来ないので、型を変換してやる必要があるという定型句。</p>
<p>数あるFromEventPatternのオーバーロードの中で、一番多く使うのはその5だと思います。何故なら、C#のイベントは独自イベントハンドラになっていることが多いから。はっきしいって、最低です。EventHandler&lt;T&gt;を使ってくれてさえいれば、こんな苦労はしなくて済むというのに。独自イベントハンドラは100害あって一利なし。え、WPFとか.NET標準がイベントハンドラは独自のものを使ってる？それは、WPFが悪い、.NET設計の黒歴史、悪しき伝統。</p>
<p>それと、もはや独自デリゲートも最低です。FuncやActionを使いましょう。C#のデリゲートはメソッドの引数や戻り値が一致していようが、型が違ったら別のものとして扱われます。そのことによる不都合は、↑で見たように、あるんです。極力ジェネリックデリゲートを使いましょう。そうすれば、こんな腐った目に合わなくても済みます。</p>
<p>ところで、その5は、もう少しだけ記述が短くなります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEventPatternその5、第一引数別解、こう書くと短くて素敵
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; h.Invoke,
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>h.Invoke。というのは、割とhそのものなわけですが、しかしInvokeと書くことで型が変換されます。この辺はコンパイラの都合上のマジックというか何というか。そういうものだと思えばいいのではかと。その5のスタイルで書くときは、この書き方をすると良いと思います。で、まだオーバーロードがあって</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// その6
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; fsw.Created += h, h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.EventArgs.FullPath));
</code></pre>
<p>conversionが不要で書けたりもします。一見素晴らしい、のですが、これ、中でなにやってるかというとconversionに相当するものをリフレクションで生成してるだけだったりして。そのため、なるべくconversionを使うオーバーロードのほうを使ったほうがよいでしょう。h =&gt; h.Invokeを書くだけですしね。このオーバーロードは紛らわしいだけで存在意義が不明すぎる。</p>
<h2>FromEventについて</h2>
<p>と、長々と見てきましたが、ではFromEventのほうも。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// FromEvent
Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(e),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Subscribe(e =&gt; Console.WriteLine(e.FullPath));

// FromEventPatternその5(比較用)
Observable.FromEventPattern&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(sender, e),
        h =&gt; fsw.Created += h,
        h =&gt; fsw.Created -= h)
    .Select(e =&gt; e.EventArgs)
    .Subscribe(e =&gt; Console.WriteLine(e.FullPath));
</code></pre>
<p>というわけで、FromEventPatternのその5に近いわけですが、conversionでEventArgsしか渡していない、という点が差異ですね。なので、後続にはsenderが伝わってこず、EventArgsしか通りません。まあ、senderは、↑の例ですとfswでどこでも使えるので、そもそも不要なわけで、これで良いかと思います。</p>
<p>ところでFromEventも色々なオーバーロードがあるにはあるんですが、私の頭では存在意義が理解できなかったので無視します。挙動とかは理解したんですが、なんというか、存在する必要性、有効な利用法がさっぱり分からなかったのです……。まあ、多分、あんま意味ないと思うので気にしないでもいいかと。</p>
<h2>拡張メソッドに退避させよう</h2>
<p>FromEventにせよFromEventPatternにせよ、長いです。長い上に定型句です。なので、拡張メソッドに退避させると、スッキリします。例えば、今まで見てきたFileSystemWatcherだったら</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// .NETのFromEventなら IObservable&lt;TEventArgs&gt;
// .NETのFromEventPatternなら IObservable&lt;EventPattern&lt;TEventArgs&gt;&gt;
// WP7のFromEventなら IObservable&lt;IEvent&lt;TEventArgs&gt;&gt;
// を返す拡張メソッド群を用意する。
// 命名規則はイベント名AsObservableがIntelliSenseの順序的にお薦め
public static class FileSystemWatcherExtensions
{
    public static IObservable&lt;FileSystemEventArgs&gt; CreatedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Created += h, h =&gt; watcher.Created -= h);
    }

    public static IObservable&lt;FileSystemEventArgs&gt; DeletedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Deleted += h, h =&gt; watcher.Deleted -= h);
    }

    public static IObservable&lt;RenamedEventArgs&gt; RenamedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;RenamedEventHandler, RenamedEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Renamed += h, h =&gt; watcher.Renamed -= h);
    }

    public static IObservable&lt;FileSystemEventArgs&gt; ChangedAsObservable(this FileSystemWatcher watcher)
    {
        return Observable.FromEvent&lt;FileSystemEventHandler, FileSystemEventArgs&gt;(
            h =&gt; (sender, e) =&gt; h(e), h =&gt; watcher.Changed += h, h =&gt; watcher.Changed -= h);
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">var fsw = new FileSystemWatcher(@&quot;C:\&quot;, &quot;*.*&quot;) { EnableRaisingEvents = true };

// 例えば、ただ変更をロギングしたいだけなんだよ、という場合の結合
// FromEventを外出ししていることによって、すっきり書ける
Observable.Merge(
        fsw.CreatedAsObservable(),
        fsw.DeletedAsObservable(),
        fsw.ChangedAsObservable(),
        fsw.RenamedAsObservable())
    .Subscribe(e =&gt; Console.WriteLine(e.ChangeType + &quot;:&quot; + e.Name));
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fsw_intellisense.jpg">
</p>
<p>といった形です。また、普通に+-でのイベント以外のものへの登録も可能です。例えば</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// LayoutRootはWPFの一番外枠の&lt;Grid Name=&quot;LayoutRoot&quot;&gt;ということで。
Observable.FromEvent&lt;MouseButtonEventHandler, MouseButtonEventArgs&gt;(
        h =&gt; (sender, e) =&gt; h(e),
        h =&gt; LayoutRoot.AddHandler(UIElement.MouseDownEvent, h),
        h =&gt; LayoutRoot.RemoveHandler(UIElement.MouseDownEvent, h))
    .Subscribe(e =&gt; Debug.WriteLine(e.ClickCount));
</code></pre>
<p>こんな形のものもObservable化が可能です。</p>
<h2>イベントの解除</h2>
<p>Subscribeの戻り値はIDisposableで、Disposeを呼ぶことでイベントが解除されます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// アタッチ
var events = Observable.Merge(
        fsw.CreatedAsObservable(),
        fsw.DeletedAsObservable(),
        fsw.ChangedAsObservable(),
        fsw.RenamedAsObservable())
    .Subscribe(e =&gt; Console.WriteLine(e.ChangeType + &quot;:&quot; + e.Name));

// デタッチ(合成などをしていて、元ソースが複数ある場合も、すべて解除されます)
events.Dispose();
</code></pre>
<p>Rxのこの仕組みは、従来に比べて圧倒的にイベントの解除がやりやすくなっていると思います。</p>
<h2>まとめ</h2>
<p>非同期の説明ばかりしてきていて、イベントはすっかり置き去りだったことを、まずはゴメンナサイ。少し前からFromEvent周りは大きな仕様変更が入ったわけですが、ようやくまともに解説できました。基本中のキの部分であるここが、過去のリソースがそのまま適用出来ないという最悪の自体に陥っていたので、とりあえずこれで何とか、でしょうかどうでしょうか。</p>
<p>小さなこととはいえ、WP7との互換性が絶えているのが痛いのですが、その辺どうにかならなかったのかねー、とは思います。けれど、このEventArgsだけ送るFromEvent自体は良いと思います。 .Select(e =&gt; e.EventArgs) が定型句だったので、こういった変更は喜ばしい限り。それと、今まで思っていた、ぶっちゃけラムダ式とかRxでイベント登録するならsenderって不要じゃね？に対する答え(その通りで、完全に不要)を出してくれたのが嬉しい。</p>
<p>さて、変換できるのはいいけれど、じゃあどこで使うのがいいの？という話がいつもありません。次回は、時間周りと絡めて、その辺のお話が出来ればと思いますが、いつも次回予告が達成されたことはないので、別のことを書くでしょう←ダメぢゃん。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-30" data-pagefind-meta="published:2011-06-30"><a href="https://neue.cc/2011/06/30_331.html">Reactive Extensions v1.0安定版リリース</a></h1>
<ul class="date"><li>2011-06-30</li></ul>
<div class="entry_body"><p><a href="http://blogs.msdn.com/b/rxteam/archive/2011/06/29/first-official-release.aspx">Reactive Extensions v1.0 Stable and v1.1 Experimental available now!</a> ということで、今までも安定版だの正式だの何なり言っていましたが、今回こそ、本当に本当に正式リリース、v1.0だそうです。整理されたドキュメント、多くのチュートリアルビデオ、<a href="http://enumeratethis.com/2011/06/29/rx-performance-improvements/">大幅なパフォーマンス改善</a>、そして、よくテストされた(かどうかは不明)安定版としてのライブラリ本体。全てが整いました。さあ、使いましょう！実際のプロダクトに！</p>
<ul>
<li><p><a href="http://channel9.msdn.com/Blogs/Charles/Announcing-the-Official-Release-of-Rx">Announcing the Official Release of Rx! | Charles | Channel 9</a><br />
下のリンク先にあるRx Workshopで、沢山のビデオで学ぶことが出来ます。</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/hh242985(VS.103).aspx">MSDN - .NET Development - Reactive Extensions</a><br />
MSDNでのドキュメント。コンセプトから細かい使い方まで、しっかり書かれています。</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/hh242986(VS.103).aspx">Reactive Extensions Class Library Reference</a><br />
MSDNでのクラスライブラリリファレンス。</p>
</li>
</ul>
<p>また、NuGetではRx-でStable版を、Rx_experimental-で実験版を、他にIx_experimental-でIxをインストールすることが可能です。</p>
<h2>Ix復活</h2>
<p>Ix(Interactive Extensions、Reactiveの反対ということでEnumerableEx、Linq to Objectsを拡張する拡張メソッド群)が復活しました。復活前に、<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/1a75496f-0b33-41c0-bf7a-92f9802c3f0a">今後についての意見を募集</a>していたのですが、素敵なことに私の意見が全部反映されていました！XxxEnumerableはIntelliSenseの邪魔だから廃止してね、とかForEachにはindex付きのオーバーロード入れてよ、とかTreeを走査するメソッド入れてよ、とか。これは嬉しい。いやあ、やっぱり言っておくものですね。</p>
<p>そんなわけで、もうForEachを自作する必要はありません:)</p>
<p>標準クエリ演算子で何が「出来ない」のかを知っておくことは大切です。標準では複数回列挙なしで前後の値を使うことは出来ないし、再帰的に辿るような、複数段のSelectManyも出来ない。MaxByなどキーを使った最大値の取得もない。</p>
<p>Ixは、そこを補完してくれます。</p>
<h2>Expand</h2>
<p>Ixの中から、Expandを紹介します。なお、Rx(Observable)にはExperimental Releaseのほうにはあるのですが、まだStableには入っていません。</p>
<p>これは何かというと幅優先探索でツリーを解きほぐします。イミワカリマセンネ。ええと、ツリー状のオブジェクトを辿る場合は、通常は再帰を使って書くと思います。でも、そうして再帰で辿るのって、各枝の値が欲しいわけなんですよね？もしそうなら、ツリーは一直線上に出来る。IEnumerable&lt;T&gt;に出来る。LINQが適用できる。</p>
<p>ええ。<a href="http://d.hatena.ne.jp/NyaRuRu/20080127/p2">熟練した C# 使いは再帰を書かない</a>のです。で、ツリーです。ツリーを辿るのは頻出の再帰構造でパターン化できて、うんたらかんたら。ああ、もう！<a href="http://d.hatena.ne.jp/NyaRuRu/20080604/p1">与えられた木から，子→親への対応を作る，を C# で - NyaRuRuの日記</a>を見るといいです、それで全部解決です！</p>
<p>ExpandはBreadthFirstにあたります。DepthFirstはないの？というと、今のところないですねー。ないものはないです、しょうがない。それはさておき、このツリー的なものを辿るのというのは割とあるシチュエーションで、そしてExpandというメソッドは実に強力なので、是非使い方をマスターして欲しい。ので、例を出します。例えばWinFormsのコントロール。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ix_forms.jpg">
</p>
<p>Panelの下にButtonや、子Panelが並んでいます。さて、この中から全てのButtonを取り出したいのですが、どうしましょうか？予め配列にButtonを持っておく、のもまあ答えですが、ルート階層から辿るようにしましょう。Formに並ぶコントロールは、階層に別れたツリー構造をしています。Expandを使ってみましょう。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/ix_buttons.jpg">
</p>
<p>Expandはセレクターの結果がEmptyになるまで、辿り続けます。辿る順番は階層順(幅優先)。今回はContorolsを辿って全てのControlを列挙、Buttonが欲しいのでOfTypeでフィルタリング。というわけです。WPFやSilverlightでも、同様に辿ることが出来ます(ちょっとWPFのコントロール階層が面倒くさくて、コードがゴチャゴチャするので、今回はWinFormsを例とさせていただきました)</p>
<p>こういった走査メソッドは<a href="http://linqjs.codeplex.com/">linq.js</a>にもあります(CascadeBreadthFirst、メソッド名のとおり、NyaRuRuさんの作成されたAchiralから大きな影響を受けています)。JavaScriptの場合、ツリーの代表的なものはDOMです、というわけで勿論DOMに適用できるのですが、DOMの列挙はjQueryでやったほうがいいですよー、なので、JSONやオブジェクト(これもまたツリーになっている)の走査に使うのがいいかもしれません。何にせよ、使いどころというのは存外あるものです。</p>
<h2>気になった点</h2>
<p>そんな素敵なIxですが、触っていて幾つか気になった点があったので、<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/278f57aa-f0ef-4a95-be41-822d3dd5e299">またForumに投げておきました</a>。リクエストが反映されたことで、調子に乗って味を占めているのかもしれません。ではなくて、フィードバックは積極的に出してあげたほうがいいでしょう常識的に考えて。英語？全部機械翻訳です、はは、まあ、コードがあれば伝わるはず。伝わりました。返答が15分で来た。</p>
<p>まず、Scanの挙動。seedなしの場合に、Rxは最初の値も列挙しますが、Ixは最初の値をスルーするという、挙動の違い。で、これ、最初の値がスルーされるのは都合が悪いので(スルーしたきゃあSkip(1)すればいい)、修正かなあ、と思います。返答では、この点については何も言ってませんでしたが。</p>
<p>Scanにはもう一つ、seed有りの際に、Rx, Ixともにseedをスルーしますが、F#などはseedも列挙します。これは以前はScan0というseed含めて列挙する別のメソッドがあった(WP7版にはある)のですが、今はScan0は廃止されたので、それならScanの挙動をseed込みでの列挙に変更すべき。と、思ったのですが、返答はStartWith(seed)を使えばいいとのこと。それでも確かにいいのですが、基本seed有りにしてseed飛ばしたい時はSkip(1)のほうが使いやすいと思うのだけど。まあ、これはWP7版との互換性の問題もありますし、そもそもRxはStableと言った以上、もう挙動は変えられないので、しょうがないところかもしれません。</p>
<p>他にはRepeat拡張メソッド(無限リピートする)のソースがEmptyの場合の挙動。例えば Range(1,1).Repeat().Take(3) と1,1,1になるわけですが、 Empty<int>().Repeat().Take(3) の結果はどうでしょう？答えは、無限ループを彷徨って止まらなくなります。Emptyに対するRepeatをどう解釈するか、は正直微妙なところですけれど、元ソースが空だと死ぬというのは、結構リスキーなのではないかな、と考えてしまうのです。また、Takeをつけるのは止まることを期待するという点もあるわけですが、この場合はTakeをつけようが何しようが無駄、というのも怖い。Rxチームからの回答は、この挙動は仕様とのことでした。</p>
<p>最後にちょっとリクエストしてみた。今回のIxではDistinctにオーバーロードが足されています。通常だとIEqualityComparer&lt;T&gt;というダルいものをクラス定義して(ここが最悪！)渡さなければいけないのですが、ラムダ式でキーを指定するだけで済みます。言うならばDistinctByといったところ。これは、実に大変有益です。このオーバーロードは、<a href="http://linqcomparer.codeplex.com/">AnonymousComparer</a>という私が以前に作ったものにも載っているのですが(ちなみに拡張メソッドがかち合ってしまうため、Ixと同時使用は不可能になってしまった！まあ、.csファイル一個のライブラリなので、かち合う部分はコメントアウトすればいいのですが)、大変重宝しています。しょっちゅう使ってます。特にExceptとかで多用しているんですが……、今回IxではDistinctにしかオーバーロード足されていません。他の集合系メソッドであるIntersect, Except, Unionでも使えると便利なのになー、って思ってしまうのです。なのでリクエストしておきました。回答は、考えておく、とのことなのでもしかしたら次のバージョンでは乗っかっているかもしれません。</p>
<p>日本語だと言えるけれど、バッサリ切って機械翻訳した英語だと伝えたいニュアンスは吹っ飛んでしまうなあ、ううみぅ。必ずしもコードがあれば伝えられる、わけでもないか、当たり前だけど。</p>
<h2>QueryableEx(笑)</h2>
<p>ネタ。NuGetではIx_Experimental-Providerで入るんですが、まあ、ネタ。中身はEnumerableExのIQueryable版です。何がネタなのかというと、IQueryableはそれだけでは何の意味もなくて、解釈するエンジン(Linq to SqlなりLinq to Twitterなり)が大事なわけです。そうでなければ、not supportedをぶん投げるだけです。さて、そして、標準クエリ演算子ですらnot supported率が少なくないのに、QueryableExに対応するクエリプロバイダ……。ありえない、です。</p>
<p>そんなわけで、使う機会はないでしょう。んまあ、気合でQueryableExすらもフルサポートするクエリプロバイダを自作すれば、活用出来ますが、やはりそんな機会はないでしょう。</p>
<h2>RxJSは？</h2>
<p>ドキュメント書いたりとか、QueryableEx作ったり(笑)とか、色々忙しかったのでしょふ。今回「も」全く音沙汰なしですが、次こそは更新されるんじゃないですかねー、分かりませんけど。jQueryにはDeferred乗りましたが、アレは正直かなり使いづらいのでその点でも私はRxJSにしたいなあ。それと、<a href="http://www.publickey1.jp/blog/11/nodejswindows_azure.html">MS支援でのNode.jsのWindows対応</a>も発表されましたし、JavaScriptのAsyncを何とかするためのRx、はかなり価値があると思うので、もう少し頑張って欲しいな、と思います。</p>
<h2>まとめ</h2>
<p>しっかりとMSDN入りしている、ドキュメントもある、正式にv1 Stableと告知されている、など、もう採用できない理由はなくなりました。日本語リソースはないですが、それは気合で乗り切ればいいぢゃない(とか言ってるうちはダメなのでしょうがー)。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>Jesse Liberty(オライリーから出ているプログラミングC#の著者)による解説本も今秋に出るようだし、確実に、順調にメインストリームに乗るテクノロジとしての道を歩んでいますので、安心して追えるのではないかと思います。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-23" data-pagefind-meta="published:2011-06-23"><a href="https://neue.cc/2011/06/23_330.html">ReactiveOAuth ver.0.4 - Twitpic(OAuth Echo)対応</a></h1>
<ul class="date"><li>2011-06-23</li></ul>
<div class="entry_body"><ul>
<li><a href="http://reactiveoauth.codeplex.com/" title="ReactiveOAuth - Home">ReactiveOAuth - CodePlex</a></li>
</ul>
<p>ver.0.4になりました。少し前に0.3.0.1をこっそり出していたので、それを含めて0.3からの差分は、「対象Rxのバージョンが現在最新の1.0.10605(Stable)」に、というのと「Realmが含まれていると認証が正しく生成出来なかったバグの修正」と、「TwitpicClientサンプルの追加」になります。バグのほうは本当にすみません……。Twitterでしかテストしてない＆TwitterはRealm使わないため、全然気づいていなくて。ダメですねホント。</p>
<h2>OAuth Echo</h2>
<p>TwitpicはOAuth Echoという仕組みでTwitterと連携した認証をして、画像を投稿できます。詳しくは<a href="http://dev.twitter.com/pages/oauth_echo">Using OAuth Echo | dev.twitter.com</a>や<a href="http://dev.twitpic.com/docs/2/upload/">TwitPic Developers - API Documentation - API v2 » upload</a>にありますが、よくわかりませんね！Twitpicに画像を投稿、というわけでTwitpicのAPIにアクセスするわけですが、その際のヘッダにTwitterに認証するためのOAuthのヘッダを付けておくと、Twitpic側がTwitterに問い合せて認証を行う。という仕組みです、大雑把に言って。</p>
<p>ただのOAuthとはちょっと違うので、今までのReactiveOAuthのOAuthClientクラスは使えない。けれど、認証用ヘッダの生成は同じように作る。というわけで、ここはReactiveOAuthにひっそり用意されているOAuthBaseクラスを継承して、Twitpic専用のTwitpicClientクラスを作りましょう。</p>
<p>が、作るのもまた少し面倒なので Sample/TwitpicClient/TwitpicClient.cs に作成したのを置いておきました。ファイルごとコピペってご自由にお使いください。.NET 4 Client Profile, Silverlight 4, Windows Phone 7の全てに対応しています。</p>
<h2>Windows Phone 7でのカメラ撮影＋投稿のサンプル</h2>
<p>TwitpicClient.cs の解説は後でやりますが、その前に利用例を。WP7でカメラ撮影＋投稿をしてみます。CameraCaptureTaskの利用法に関しては <a href="http://ch3cooh.jp/index.php/tips/windowsphone7/tasks/cameracapturetask/">CameraCaptureTaskを使ってカメラで静止画撮影を行う – CH3COOH(酢酸)の実験室</a> を参考にさせて頂きました。TwitterのAccessTokenの取得に関しては、ここでは解説しませんので <a href="http://neue.cc/2010/09/12_276.html">neue cc - ReactiveOAuth - Windows Phone 7対応のOAuthライブラリ</a> を参照ください。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// CameraCaptureTaskのCompletedイベント
void camera_Completed(object sender, PhotoResult e)
{
    if (e.TaskResult == TaskResult.OK)
    {
        // 撮影画像(Stream)をバイト配列に格納
        var stream = e.ChosenPhoto;
        var buffer = new byte[stream.Length];
        stream.Read(buffer, 0, buffer.Length);

        // key, secret, tokenは別に設定・取得しておいてね
        new TwitpicClient(ConsumerKey, ConsumerSecret, accessToken)
            .UploadPicture(e.OriginalFileName, &quot;from WP7!&quot;, buffer)
            .ObserveOnDispatcher()
            .Catch((WebException ex) =&gt;
            {
                MessageBox.Show(new StreamReader(ex.Response.GetResponseStream()).ReadToEnd());
                return Observable.Empty&lt;string&gt;();
            })
            .Subscribe(s =&gt; MessageBox.Show(s), ex =&gt; MessageBox.Show(ex.ToString()));
    }
}
</code></pre>
<p>new TwitpicClient(キー, シークレット, アクセストークン).UploadPicture(ファイル名, メッセージ, 画像) といった風に使います。戻り値はIObservable&lt;string&gt;で結果(投稿後のURLとか)が返ってくるので、あとは好きなように。投稿に失敗した場合は、WebExceptionが投げられるので、それを捉えてエラーメッセージを読み取ると開発には楽になれそうです。</p>
<h2>TwitpicClient.cs</h2>
<p>以下ソース。Sample/TwitpicClient/TwitpicClient.cs と同じですが、自由にコピペって使ってください。大事なことなので2回言いました。このコード自体はTwitpicに特化してありますが、認証部分のヘッダを少しと画像アップロードを変更する部分を弄れば、他のOAuth Echoサービスにも対応させることができると思います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">using System;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;

#if WINDOWS_PHONE
using Microsoft.Phone.Reactive;
#else
using System.Reactive.Linq;
#endif

namespace Codeplex.OAuth
{
    public class TwitpicClient : OAuthBase
    {
        const string ApiKey = &quot;&quot;; // set your apikey

        readonly AccessToken accessToken;

        public TwitpicClient(string consumerKey, string consumerSecret, AccessToken accessToken)
            : base(consumerKey, consumerSecret)
        {
            this.accessToken = accessToken;
        }

        private WebRequest CreateRequest(string url)
        {
            const string ServiceProvider = &quot;https://api.twitter.com/1/account/verify_credentials.json&quot;;
            const string Realm = &quot;http://api.twitter.com/&quot;;

            var req = WebRequest.Create(url);

            // generate oauth signature and parameters
            var parameters = ConstructBasicParameters(ServiceProvider, MethodType.Get, accessToken);
            // make auth header string
            var authHeader = BuildAuthorizationHeader(new[] { new Parameter(&quot;Realm&quot;, Realm) }.Concat(parameters));

            // set authenticate headers
            req.Headers[&quot;X-Verify-Credentials-Authorization&quot;] = authHeader;
            req.Headers[&quot;X-Auth-Service-Provider&quot;] = ServiceProvider;

            return req;
        }

        public IObservable&lt;string&gt; UploadPicture(string filename, string message, byte[] file)
        {
            var req = CreateRequest(&quot;http://api.twitpic.com/2/upload.xml&quot;); // choose xml or json
            req.Method = &quot;POST&quot;;

            var boundaryKey = Guid.NewGuid().ToString();
            var boundary = &quot;--&quot; + boundaryKey;
            req.ContentType = &quot;multipart/form-data; boundary=&quot; + boundaryKey;

            return Observable.Defer(() =&gt;
                    Observable.FromAsyncPattern&lt;Stream&gt;(req.BeginGetRequestStream, req.EndGetRequestStream)())
                .Do(stream =&gt;
                {
                    using (stream)
                    using (var sw = new StreamWriter(stream, new UTF8Encoding(false)))
                    {
                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;key\&quot;&quot;);
                        sw.WriteLine();
                        sw.WriteLine(ApiKey);

                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;message\&quot;&quot;);
                        sw.WriteLine();
                        sw.WriteLine(message);

                        sw.WriteLine(boundary);
                        sw.WriteLine(&quot;Content-Disposition: form-data; name=\&quot;media\&quot;; filename=\&quot;&quot; + filename + &quot;\&quot;&quot;);
                        sw.WriteLine(&quot;Content-Type: application/octet-stream&quot;);
                        sw.WriteLine(&quot;Content-Transfer-Encoding: binary&quot;);
                        sw.WriteLine();
                        sw.Flush();

                        stream.Write(file, 0, file.Length);
                        stream.Flush();

                        sw.WriteLine();
                        sw.WriteLine(&quot;--&quot; + boundaryKey + &quot;--&quot;);
                        sw.Flush();
                    }
                })
                .SelectMany(_ =&gt; Observable.FromAsyncPattern&lt;WebResponse&gt;(req.BeginGetResponse, req.EndGetResponse)())
                .Select(res =&gt;
                {
                    using (res)
                    using (var stream = res.GetResponseStream())
                    using (var sr = new StreamReader(stream, Encoding.UTF8))
                    {
                        return sr.ReadToEnd();
                    }
                });
        }
    }
}
</code></pre>
<p>認証ヘッダ作成はConstructBasicParametersとBuildAuthorizationHeaderというprotectedメソッドで行います。わけわかんないよね…気持ち悪いよね…。使いにくいメソッドです、すみません、私もそう思います。そういうものだと思って、見ないふりしてもらえれば幸いです。</p>
<p>コードの大半を占めているのは画像を投稿するためのmultipart/form-dataのもので、これはもうOAuth Echo関係ない話、で、面倒ぃ。特にWP7での非同期だと涙が出る。POSTはBeginGetRequestStreamとBeginGetResponseの二つの非同期メソッドをセットで使う必要があるため、コードがごちゃごちゃするのです。</p>
<p>しかし<a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>を使えばあら不思議！でもないですが、ネストがなくなって完全に平らなので、結構普通に読めるのではないでしょうか？(ストリーム書き込みのコード量が多いのは、これは同期でやっても同じ話なので)。例外処理も利用例のところで見たように、Catchメソッドをくっつけるだけ。実に色々とスッキリします。</p>
<p>Rxがあれば非同期POSTも怖くない。</p>
<p>やっていることは単純で、FromAsyncPatternでBegin-Endを変換。StreamへのWriteは後続への射影はなく、対象(Stream)に対しての副作用(書き込み)のみなのでDo、RequestStream-&gt;Responseへの切り替えはSelectMany、Responseから結果のStringへの変換はSelect、と、お決まりの定型メソッドに置き換えていっただけです。この辺はパターンみたいなものなので、これやるにはこのメソッドね、というのを覚えてしまえばそれでお終いです。</p>
<h2>Stream読み書きは非同期にしないの？</h2>
<p>StreamにもBeginReadとかBeginWriteとかありますものね。しかし、しません(ｷﾘｯ。理由は死ぬほど面倒だからです。やってみると分かりますが想像以上に大変で、おまけに何とか実現するためにはRxでのチェーンを大量に重ねる必要がありオーバーヘッドがバカにならない……。なので、わざわざやるメリットも全くありません。</p>
<p>一応、ReactiveOAuthのOAuthClientは、そこも非同期でやってますが、わざわざ頑張った意味があったかは、かなり微妙なところ。実装は Internal/AsynchronousExtensions.cs にあるので参照ください。それと、この AsynchronousExtensions.cs は<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>で言った「拡張メソッドのすゝめ」を実践したものでもあります。WebRequestはプリミティブすぎて扱い難いので、Rxに特化したうえで簡単に扱えるようにDownloadStringやUploadValueなどといったメソッドを拡張してあります。便利だと思いますので、こちらも TwitpicClient.cs と同様に、ファイルごと自由にコピペって使ってやってください。</p>
<h2>まとめ</h2>
<p>ReactiveOAuthを公開する目的に、「これが入り口になってRxの世界を知ってもらえると嬉しい」というのもあったのですが、WP7開発で利用してもらったりと、その目的は少しは達成出来たかもで、良かった良かった。ちょっと練りたりなかったり、未だにバグがあったり(本当にごめんなさい！)と至らない点も多いですが、今後も改善していきますのでよろしくお願いします。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-15" data-pagefind-meta="published:2011-06-15"><a href="https://neue.cc/2011/06/15_329.html">MSDNの上のReactive Extensions</a></h1>
<ul class="date"><li>2011-06-15</li></ul>
<div class="entry_body"><p>DevLabsを卒業し、晴れて正式に<a href="http://msdn.microsoft.com/en-us/data/aa937685" title="Data Developer Center">Data Developer Center</a>入りした<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">Reactive Extensions</a>ですが、徐々に正式リリースへ向かう準備として、ついにドキュメントがMSDN入りを果たしました。</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/hh242985(v=VS.103).aspx" title="Reactive Extensions">MSDN Library &gt; .NET Development &gt; Reactive Extensions</a></li>
</ul>
<p>まだPre-releaseということで工事中の部分が多いですが、これはドキドキしますね。Getting Started with Rxはどんなところで使えるかの説明とダウンロード先について、Using Rxは詳細なドキュメント（まだ工事中項目も幾つか、でもかなり充実している感）、Reactive Extensions Class Libraryはリファレンス。必要十分には揃っていますね、あとは大きめのサンプルも欲しいところだけど、追加されるかな？</p>
<p>ところで、ツリー階層を見てください。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rx_msdn_tree.jpg">
</p>
<p>.NET Development直下です。何て素晴らしい位置にあるのか！Entity FrameworkやSilverlight
などと同列に並べられているのを見ると、ついに始まったな、と感無量です。</p>
<h2>その他のRx</h2>
<p>Rx本体が順風満帆なのに比べると、RxJSとIx(EnumerableEx)はどうしちゃったのでしょう……。まず、RxJSは、やる気は一応あるみたいです。ダウンロードも可能ですしね。APIは随分更新されていなくて、.NET版Rxとかなり差が開いてしまいましたが（バグも幾つか見つかっているのですが）。今はRxチーム自体がドキュメント周りで忙しいということで手を付けてられないっぽく、ゆっくり待つしかないです。プロジェクト自体は死んでいないそうなので、そこだけは安心してもいいかと。（私は内心不安ですが！）</p>
<p>Ixのほうは、一旦死亡です。ダウンロードセンターはもとより、NuGetからも、もう手に入らなくなりました。が、しかし、完全終了ではなく、一旦引っ込めて練りなおして、Rxとは別枠となるかもですが提供する意思はあるそうで。「Don't worry.  Ix is not disappearing forever.」とのこと。そこで、フィードバックが欲しいとのことなので、答えてあげるといいんじゃないかしら。<a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/1a75496f-0b33-41c0-bf7a-92f9802c3f0a" title="Asking your input - Interactive Extensions functionality">Asking your input - Interactive Extensions functionality</a>。私も好きなメソッドと嫌いなもの(XxxEnumerableがIntelliSenseを汚染して嫌いだった)、それとドサクサに紛れて再帰/ツリー探索系のメソッドを入れてよ！とリクエストしておきました。</p>
<h2>NuGet</h2>
<p>6月頭にバージョンが少し上がって、現在はStableがv1.0.10605、Experimentalがv1.1.10605が最新バージョンとなっています。そしてNuGetのパッケージ名も少し変化して、Stable版はRx-MainなどプリフィックスがRx-のもの、ExperimentalはRx_Experimental-MainなどプリフィックスがRx_Experimental-と完全に別れて提供されるようになりました。</p>
<h2>と、まあ</h2>
<p>そんなところです。最近は私もこうして、更新されたよー、と言うだけで、技術的な情報提供を怠っていてすみませんすみませんなので、徐々に再開していきたいと思います。Schedulerの話とか非常に重要なのに、このブログでは一度も書いていないですしね、全くもってイクない。こないだのセッション<a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041" title="Reactive Extensionsで非同期処理を簡単に">Reactive Extensionsで非同期処理を簡単に</a>は非同期中心だったので、イベントサイドについての話もしっかりまとめたいなあ、とかも思いつつ。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-09" data-pagefind-meta="published:2011-06-09"><a href="https://neue.cc/2011/06/09_328.html">linq.js入門記事を書きました</a></h1>
<ul class="date"><li>2011-06-09</li></ul>
<div class="entry_body"><p>お話をいただき、@ITの.NET TIPSに<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript - Home">linq.js</a>の入門記事を、二週に渡り書きました。</p>
<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/dotnettips/1058linqjsbasic/linqjsbasic.html" title="JavaScriptで配列をLINQにより処理できるライブラリ「linq.js」を利用するには？ － ＠IT">JavaScriptで配列をLINQにより処理できるライブラリ「linq.js」を利用するには？ － ＠IT</a></li>
<li><a href="http://www.atmarkit.co.jp/fdotnet/dotnettips/1059linqjquery/linqjquery.html" title="jQueryと「linq.js」を連携させてDOMをLINQにより処理するには？ － ＠IT">jQueryと「linq.js」を連携させてDOMをLINQにより処理するには？ － ＠IT</a></li>
</ul>
<p>このサイトでやると、アレもコレもとダラダラと書いてしまって分かりづらくなっていたのですが、記事では文字数制限などのお陰で構成がすっきり、校正してもらったお陰で文章の揺れもなく。つまるところ、ほとんど編集で助けてもらったというだけで、本当にありがとうございました。サンプルコードは、コードを見ただけで伝わるよう単純に、でもlinq.jsの威力を伝えなければならないので多少の複雑さは持たなければならない。などと思い結構悩んで作りました。</p>
<p>お陰様で反響も結構良かったみたいでなによりです。実績も良く分からない外部ライブラリは導入できない…… という方も、@ITに載ってるから大丈夫だよ！を説得材料(？)にできるのではないでしょうか。これを機に、是非試してみてください。</p>
<p>ところで幾つかの話。</p>
<h2>メソッド名大文字</h2>
<p>失敗した。かな……。特にTojQuery()でjQueryと見かけ上(あくまで見かけだけなんですが)シームレスに繋がっていると違和感が結構あります。以前に、jQueryとLINQの世界が視覚上切れて見えるから、むしろイイぐらいなんです、とか言ってましたが勿論ただの強がりです。この辺は今更変えにくいところで、どうしたものかな、と悩んでいるところです。</p>
<h2>パフォーマンスについて</h2>
<p>気になりますよね？ベンチマーク的に言えば、遅い。遅延評価の実現や豊富な機能は、速度を相当犠牲にしています。では、その遅さが許容できるほどか無視できないか。これは、卑怯な逃げ口になってしまいますが、状況次第。少なくとも普通のサイトでは問題ないレベルだと思いますし、また、ブラウザのJSはどんどん速くなっていってます。Chrome/Fx4/IE9の速さ！「許容できる」の範囲はどんどん広がっていってるのでは、と。</p>
<p>こういった話はC#でもそうです。LINQはベタforループより確実に遅い、が、じゃあベタforループで書くかといったら、よほどエクストリームに速度を求める場合以外は書きはしません。</p>
<p>Pentium3でWindows XPでIE6な奴らにも配慮する！というのも確かに美学なのですが、そうではない方向も見ないと、素敵な未来はやってこないのではないかな、って。21世紀にもなるのに<a href="http://ja.wikipedia.org/wiki/%E3%83%AB%E3%83%BC%E3%83%97%E5%B1%95%E9%96%8B">ループアンローリング</a>で高速化！とかいう記事ばかりが踊る世界なんて悲しいじゃないですか。</p>
<p>モバイル機器のことも考えなければならないし、HTML5も控え、JavaScriptで高負荷な処理をすることも少なくないので、まだまだ時代は追いついていないけれど。それでも、私はもう少し先の未来を見ていたい……。JavaScriptがこれから先、本当に一級の言語となっていくのなら尚の事です。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-06" data-pagefind-meta="published:2011-06-06"><a href="https://neue.cc/2011/06/06_327.html">Reactive ExtensionsとSQLの非同期実行</a></h1>
<ul class="date"><li>2011-06-06</li></ul>
<div class="entry_body"><p><a href="http://dbexecutor.codeplex.com/">DbExecutor</a>のパフォーマンスが十分トップクラスであることは、<a href="http://neue.cc/2011/06/03_326.html">こないだの計測</a>で分かりました。では次のステップはどこへ向かおう。IL生成を頑張っても、もうほんの少ししか稼げる余地は残ってない。ならば、もっと根本的なところから行こう。ええ、非同期IOを。DbExecutorは一応、拡張性を考慮してあるので継承して非同期対応しましょう。</p>
<p>……ところで、この記事はAsyncDbExecutorの作り方、みたいになっていますが、読み取ってほしいのは「<a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>の使い方」です。AsyncDbExecutorは、あくまでRxの利用法のサンプルにすぎません。DbExecutorなんて使わないしー、とか思わず、その辺を念頭において眺めてみてください。</p>
<h2>BeginExecuteReader/EndExecuteReader</h2>
<p>SqlServerならば<a href="http://msdn.microsoft.com/ja-jp/library/1a674khd.aspx">SqlCommand.BeginExecuteReaderメソッド</a>が使えます。IDbCommandにはないので、対象はSqlServer特化ということになってしまいますが、まあ、それはしょうがない(非同期対応してないDBもあるわけだし)。対応させる方法ですが、まずはDbExecutorを継承してコンストラクタを弄ります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class AsyncDbExecutor : DbExecutor
{
    public AsyncDbExecutor(string connectionString)
        : base(new SqlConnection(connectionString))
    { }

    public AsyncDbExecutor(SqlConnection connection)
        : base(connection)
    { }

    public AsyncDbExecutor(string connectionString, IsolationLevel isolationLevel)
        : base(new SqlConnection(connectionString), isolationLevel)
    { }

    public AsyncDbExecutor(SqlConnection connection, IsolationLevel isolationLevel)
        : base(connection, isolationLevel)
    { }
}
</code></pre>
<p>通常のDbExecutorはIDbConnectionを受け入れるようにしていましたが、今回はSqlServer特化なのでSqlConnectionで。また、利便性を考えて生の接続文字列からも作れるようにしてやりました。IsolationLevelを受け入れるオーバーロードはTransaction処理する場合のためとなっています(別にTransactionScope使ってもいいですけどね)。あとは、非同期に対応するメソッドを作ってやれば良いだけ。</p>
<h2>Reactive Extensions</h2>
<p>BeginXxx-EndXxxがカッタルイのは分かりきっているので、当然のようにRxを持ち出します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 引数が横に長いですがほとんど省略可能なので……
public IObservable&lt;SqlDataReader&gt; ExecuteReaderAsyncRaw(string query, object parameter = null, CommandType commandType = CommandType.Text, CommandBehavior commandBehavior = CommandBehavior.Default)
{
    var cmd = (SqlCommand)this.PrepareExecute(query, commandType, parameter);
    return Observable.FromAsyncPattern&lt;SqlDataReader&gt;(
            (ac, o) =&gt; cmd.BeginExecuteReader(ac, o, commandBehavior), cmd.EndExecuteReader)
        .Invoke()
        .Finally(() =&gt; cmd.Dispose());
}
</code></pre>
<p>this.PrepareExecuteですが、これはDbExecutorのprotectedメソッドで、クエリ文字列や匿名型で渡すパラメータからIDbCommandを生成します。こんなこともあろうかとちゃんとprotectedにしておいて良かった。そしてキャストですが、今回はconnectionは必ずSqlConnectionで(そうなるようコンストラクタを調整してある)、戻り値がSqlCommandであることが保証されているためアップキャストしてやります。そうしないと非同期APIが使えないですから。</p>
<p>あとは、いつものように(？)FromAsyncPatternして、それとFinallyでcommandをDisposeしてやることを忘れないと気が効いてるかもり。利用する時は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// async=trueを忘れずに
var connstr = @&quot;Data Source=.;async=true;Initial Catalog=master;Integrated Security=True;&quot;;

var executor = new AsyncDbExecutor(connstr);
executor.ExecuteReaderAsyncRaw(&quot;select * from sys.tables&quot;)
    .Finally(() =&gt; executor.Dispose()) // 接続のDisposeも忘れずに...
    .Subscribe(dr =&gt;
    {
        while (dr.Read())
        {
            Console.WriteLine(dr.GetValue(0));
        }
    });
</code></pre>
<p>といった感じです。非同期APIはDisposeをどう仕込めばいいのかが悩ましいのですが、Rxなら簡単です、Finallyに突っ込めばいいだけ。同期APIでusingで囲むのと同じ感覚で、RxではFinallyに置いてください。非同期実行ということで、複数同時に走らせることも少なくないと思うのですが、その場合は全ての完了を自然に扱えるよう、結合して一本の流れにしてやる必要はあるでしょう。恐らくきっと。</p>
<p>そういえば忘れてはいけないのは、非同期APIを使う場合は接続文字列にasync=trueが必要です。これについては<a href="http://msdn.microsoft.com/ja-jp/library/dd229385.aspx">ADO.NET 2.0 における非同期コマンド実行</a>によると</p>
<blockquote>
<p>非同期コマンドを使用するためには、コマンドが実行される接続は、接続文字列を async=true と指定して初期化する必要があります。 非同期メソッドが接続文字列に async=true と指定されていない接続を使用するコマンドで呼び出されると、例外がスローされます。</p>
</blockquote>
<blockquote>
<p>所定の接続オブジェクトで同期コマンドのみを使用するとわかっている場合は、接続文字列に async キーワードを指定しないか、false に設定することをお勧めします。 非同期操作が有効になっている接続で同期操作を実行すると、リソースの利用率は著しく増大します。</p>
</blockquote>
<blockquote>
<p>同期 API と非同期 API の両方が必要な場合は、可能であれば別々の接続を使用することをお勧めします。 これが不可能であれば、async=true を指定して開かれた接続で同期メソッドを使用することもできます。この場合、通常どおりに動作しますが、パフォーマンスは若干劣化します。</p>
</blockquote>
<p>とのことなので、少し気をつけたほうがいいかもしれません。まあ、Rx愛好家なら全てRxで非同期でやるに決まっているので(?)、別にasync=trueでも怖くありません。</p>
<h2>SelectMany</h2>
<p>しかし、生のDataReaderをwhileで回すとか、ダサ……。せっかくのRxなのだから値もPushで送ればいいぢゃない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">IEnumerable&lt;IDataRecord&gt; EnumerateSqlDataReader(SqlDataReader reader)
{
    using (reader)
    {
        // Closeされるタイミングがコントロール出来ないので、IsClosedのチェックは必須
        while (!reader.IsClosed &amp;&amp; reader.Read())
        {
            yield return reader;
        }
    }
}

// 前に定義したAsyncRawを呼んでSelectManyするだけ
public IObservable&lt;IDataRecord&gt; ExecuteReaderAsync(string query, object parameter = null, CommandType commandType = CommandType.Text, CommandBehavior commandBehavior = CommandBehavior.Default)
{
    return ExecuteReaderAsyncRaw(query, parameter, commandType, commandBehavior)
        .SelectMany(dr =&gt; EnumerateSqlDataReader(dr));
}

// 使うときはこんな感じ
var executor = new AsyncDbExecutor(connstr);
executor.ExecuteReaderAsync(&quot;select * from sys.tables&quot;)
    .Select(dr =&gt; new
    {
        Name = dr.GetString(0),
        ObjectId = dr.GetInt32(1)
    })
    .Finally(() =&gt; executor.Dispose())
    .Subscribe(Console.WriteLine);
</code></pre>
<p>実にLINQっぽく自然になりました。yield returnを使ったのは、IObservableのSelectManyはIEnumerableも受け入れて平らにしてくれるからです。これ、Observable.UsingとかObservable.Generateを使って、Rxだけで頑張ることも可能ではあるのですが、面倒くさいしゴチャゴチャします。なので、yield returnが使えるなら、使ってしまったほうが楽。この辺はIEnumerable&lt;T&gt;を生成するためのyield returnがあるように、IObservable&lt;T&gt;を生成するためのコンパイラサポートが欲しいところ。awaitが乗ればTaskからIObservableへの変換(は基本的に容易)なので、ある程度可能になるのかなあ、と思いつつ、謂わばAsyncEnumerableになることの難しさもあるので今のところ何とも言えません。</p>
<p>ExecuteReaderAsyncがあればExecuteReaderAsyncRawいらないぢゃん！って感じですけれど、パフォーマンスのために非同期にするのに、SelectManyとかオーバーヘッドがあるのも嫌かなあ、と思う場合もあるかもなので、生のSqlDataReaderを返すものも残してあげるのもいいかな、とか思ったりはするところ。EnumerateSqlDataReaderのような拡張メソッドを別途定義してやれば、生のSqlDataReaderも、そう扱いが面倒というわけでもないですしね。いや、どうだろう……。</p>
<h2>次バージョン</h2>
<p>この調子でExecuteNonQueryやSelectなども書いていけば完成です。って、そういえばアクセサの動的生成＆キャッシュの部分はinternalで外から触れない(せいぜいPrepareExecuteだけ)からSelectは書けないぢゃん。うげげ。うーん、publicにするのもどうかと思うので、InternalVisibleToで対処しようかなあ。そんなわけで、このAsyncDbExecutorは今はまだアイディア段階で内容を詰めてませんが、もっとブラッシュアップさせて、次の<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>の更新時に含めたいと思っています。Rxが必要という都合もあるので、本体とは別DLLで。勿論、NuGet対応で依存解決でインストール楽々、です。</p>
<h2>ところで本当に速いの？</h2>
<p>うん、分かりません。<a href="http://msdn.microsoft.com/ja-jp/library/dd229385.aspx">ADO.NET 2.0 における非同期コマンド実行</a>によれば</p>
<blockquote>
<p>ADO.NET/SqlClient の非同期コマンド実行サポートは、実際に、本当の意味での非同期ネットワーク I/O （共有メモリの場合は非ブロッキングのシグナル通知） を基礎としています。 ご要望が多ければ、いずれ内部実装について文書にしたいと思います。 ここでは、&quot;真の非同期&quot; を行っており、特定の I/O 操作が終わるまで待機しているブロックされたバックグラウンドのスレッドは存在しない、と申し上げておきます。Windows 2000/XP/2003 オペレーティング システムのオーバーラップ I/O 機能と I/O 完了ポートの機能を利用し、単一スレッド （または少数スレッド） によって、所定のプロセスに対する未処理の要求をすべて処理することを可能にしています。</p>
</blockquote>
<p>というわけで、まあ速いんじゃないかねえ、とは思うんですが、計らないことには分かりません。ベンチマークはAsyncDbExecutorのリリース時に、ちゃんと計ってみたいと思います。とりあえず非同期IOで万歳なNode.jsに負けてられませんからね(謎)。というのはともかく、この辺は以前にmono meetingでAzure Tableのパフォーマンスの話を聞いた時→資料:<a href="http://www.slideshare.net/takekazuomi/20110126-azure-monomeeting">20110126 azure table in mono meeting</a>全くサッパリだったこともあるので、ちゃんと調べたいとずっと思っていたのです(が、IOCPとかネイティブな話はさっぱり＆データベースの挙動の中身も全然なので、あくまで.NETな上層のほうで…… いずれは何とかしたいのですけれど、手一杯でどうにも)。</p>
<p>やっぱ非同期が必須なのはサーバーサイドの話になるのですかねえ。IHttpAsyncHandlerとRx、とかそのうち書きたいのですが、そもそも私はASP.NETあんま分かりませんですよというところから始める必要があり。調べたいことがありすぎて積みタスクの山にうもれて完全死亡中。</p>
<h2>デフォルトExecutor</h2>
<p>最後に話は変わりますが、new DbExecutorするのに毎回コンストラクタにSqlConnection渡すのがダルいし不自然！という場合は、これまた継承して接続文字列が固定されたExecutorを用意すると良いです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class HogeExecutor : DbExecutor
{
    public HogeExecutor()
        : base(new SqlConnection(&quot;Data Source=hogehoge;&quot;))
    { }

    public HogeExecutor(IsolationLevel isolationLevel)
        : base(new SqlConnection(&quot;Data Source=hogehoge;&quot;), isolationLevel)
    { }
}
</code></pre>
<p>中々悪くないのではないでしょーか。残念ながらStaticメソッドのほうは使えませんが。Staticメソッドのほうは、どうも上手いやり方が考えつかなくて色々と保留中。考えてはいるのですが。</p>
</div>
<h1 data-pagefind-sort="date:2011-06-03" data-pagefind-meta="published:2011-06-03"><a href="https://neue.cc/2011/06/03_326.html">C#のMicro-ORM(Dapper, Massive, PetaPoco)について</a></h1>
<ul class="date"><li>2011-06-03</li></ul>
<div class="entry_body"><p>最近、巷という名の極一部で話題になっているMicro-ORMという分野。何それ？うーん、MicroなORマッパーです。まんまですが。Entity FrameworkがUltra Hugeだとしたら、その対極にあるような。定義としては「SQL本文は手書き、マッピングは自動」だけの機能を持つもの、といったところでしょうか。Microであるために「1ファイルのみ」を入れても良さそう。少なくとも、用語の発生元っぽい<a href="http://code.google.com/p/dapper-dot-net/" title="dapper-dot-net - Simple SQL object mapper for SQL Server - Google Project Hosting">Dapper</a>, <a href="https://github.com/robconery/massive" title="robconery/massive - GitHub">Massive</a>, <a href="http://www.toptensoftware.com/petapoco/" title="Topten Software">PetaPoco</a>は1ファイルのみです。</p>
<p>他に、シンプルめなORマッパーを志している感じなのは<a href="https://github.com/markrendle/Simple.Data" title="markrendle/Simple.Data - GitHub">Simple.Data</a>や、そしてORマッパーじゃなくてただの実行機です！と言い張る私の作っている<a href="http://dbexecutor.codeplex.com/" title="DbExecutor - Simple and Lightweight Database Executor - Home">DbExecutor</a>などもMicro-ORMに入れちゃってもいいかしら？Simple.Dataは名前に反してあまりシンプルではない(MEF使ってる……)感じですが。DbExecutorは十分Microです！<a href="http://d.hatena.ne.jp/taedium/">id:taedium</a>さんの作られている<a href="http://soma.codeplex.com/" title="Soma - Sql Oriented MApping framework - Home">Soma</a>も比較的シンプルめなものに入るかしら……？</p>
<p>この中で注目株はDapperで、<a href="http://stackoverflow.com/" title="Stack Overflow">Stack Overflow</a>のエンジニアがパフォーマンスの問題を解消するために作成したもの、ということで、超巨大サイトでの利用で鍛えられているというのは何よりも信頼への担保がある。そして、この手のO/Rマッパーにはかかせない動的コード生成によるパフォーマンス向上に関しては、パフォーマンスのエキスパート中のエキスパートである<a href="http://code.google.com/p/protobuf-net/" title="protobuf-net - Fast, portable, binary serialization for .NET - Google Project Hosting">protobuf-net</a>の作者 Marc Gravell氏がIL生成部分を担当しているという、凄いコンビでそりゃ色々と叶わないね、という感。</p>
<h2>パフォーマンステスト</h2>
<p>Dapperは親切にもベンチマークプログラムも公開しているので、リポジトリにあるもの＋DbExecutor、それとDataTableを追加して計測してみました。</p>
<blockquote>
<p>hand coded took 53ms<br />
Mapper Query (buffered) took 55ms<br />
Dynamic Mapper Query (non-buffered) took 55ms<br />
Mapper Query (non-buffered) took 56ms<br />
Dynamic Mapper Query (buffered) took 56ms<br />
Dapper.Cotrib took 56ms<br />
PetaPoco (Fast) took 58ms<br />
<strong>DbExecutor Select took 58ms</strong><br />
<strong>DbExecutor ExecuteReader(Hand Coded) took 58ms</strong>
Dynamic Massive ORM Query took 62ms<br />
PetaPoco (Normal) took 62ms<br />
<strong>DbExecutor SelectDynamic took 62ms</strong><br />
<strong>DbExecutor ExecuteReaderDynamic(Hand Coded) 65ms</strong><br />
DataTable took 83ms<br />
BLToolkit took 85ms<br />
Simple.Data took 90ms<br />
Linq 2 SQL Compiled took 100ms<br />
SubSonic Coding Horror took 114ms<br />
Entity framework CompiledQuery took 119ms<br />
NHibernate SQL took 127ms<br />
NHibernate HQL took 149ms<br />
Soma took 168ms<br />
NHibernate Criteria took 191ms<br />
Linq 2 SQL ExecuteQuery took 215ms<br />
Linq 2 SQL took 671ms<br />
NHibernate LINQ took 708ms<br />
Entity framework ExecuteStoreQuery took 726ms<br />
Entity framework ESQL took 728ms<br />
Entity framework No Tracking took 966ms<br />
Entity framework took 969ms<br />
SubSonic ActiveRecord.SingleOrDefault took 4259ms</p>
</blockquote>
<p>hand codedがExecuteReaderを手で回した手書き、「Mapper Query」はDapperのことです。複数種類があるのはオプション違い。DbExecutor(太字にしています)も同様に4種類で測っています。</p>
<p>結果ですが、勿論Dapperは速いんですが、DbExecutorのSelectも悪くない位置にある。というか、これは普通に高速と名乗っていいレベルの速度は出てる。というか上位陣はほとんど誤差でいいんじゃないですかというところですね、実際何回か測ると若干入れ替わったりしますし。500回のループで3ms遅くて低速とか言われたら怒ります(笑)</p>
<p>ところでDbExecutorのDynamic類が十分すぎるほど速いのは少し驚いたり(dynamic経由だからもっとずっと遅くなるのかと思ってた……)。この計測結果を前にすると、手動マッピングするならExecuteReaderはダルいからExecuteReaderDynamic使いますねー、型変換とか不要でずっとシンプルに書けますから。Selectが使えるシーンではSelectで、柔軟なマッピングをする必要があるシーンではExecuteReaderDynamicで、というのがDbExecutorを使う場合の幸せシナリオになりそう。また、ExpandoObjectをDataTableのRowの代わりとして使うSelectDynamicも十分な速度が出ていて、これぐらい速度出るなら普通に使っちゃえますねえ。非常に良い感じ。</p>
<h2>何故速いのか、あるいは何故遅いのか</h2>
<p>動的コード生成しているから速い。といっても、真ん中ぐらいより上のコードはみんなやっているのではないかしら。勿論、DbExecutorも生成しています。では何でDbExecutorは大体の場合において僅差とはいえDapperより遅いのか。これはコード生成する範囲の問題です。Dapperはクエリ用に最適化してガッツシ固めて生成・キャッシュしてますが、DbExecutorは汎用的に、Typeに対して行っているので、そこで若干の差が出ています。</p>
<p>最初Dapperのコード見たときは、うわあ、これは凄い差がついちゃってるのでは？とか思ったんですが、蓋を開けてみると、誤差みたいに小さな差でたいしたことなかったので、このまんまで行きます(それと言い訳がましいですがCode Contractとかのハンデも若干あるので、どの程度響いているかは不明瞭ですが)。どちらにせよ、ようするところ、DBへのアクセス速度に比べれば、その程度のチューニングは大して差が出ないということでしょう。</p>
<p>動的コード生成も、ILでゴリゴリじゃなくてExpressionTreeを使ったゆとり全開の生成なので、それで上位にガッツリ肉薄しているのだから、十分以上です。</p>
<h2>まとめ</h2>
<p><a href="http://dbexecutor.codeplex.com/" title="DbExecutor - Simple and Lightweight Database Executor - Home">DbExecutor</a>は普通に速い。他のと比べると気が効いていて、かつ洗練されたAPIを持っていて、非常に使いやすいので、Dapperなどと比べても負けてない。Micro-ORMの最前線で全然戦えます(但し1ファイルではないけれど！)。次のアップデートでは、クエリ時の戻りが複数になる場合の対応と、ストアドプロシージャのOUTPUTの対応を予定してますので是非是非お試しを。</p>
<p>と、宣伝がましくなってて申し訳ないですね……。Micro-ORM自体については、まず、Entity Frameworkなど普通のORMを使わないようなら、必需品だと思います。完全手作業でデータベース触るのは馬鹿げてる。何らかの薄いラッパーぐらいは作っているだろうけれど、Dapperよりも優れていると確信持てなければ(そして多くの場合は持てるわけがない！)、そんなものは捨ててDapperを使ったほうがいいのではないかしら。いや、DbExecutorでもいいですけどね、というかDbExecutorは良いですよ。</p>
<p>Entity Frameworkなどを使っている場合はどうか、というと、重量級フレームワークの欠けた部分を補ってやる感じで、良い感じに使えそうです。その辺の小回りの良さ、大きめなものと一緒に使っても上手く馴染むのはMicro-ORMならではなのではかと思います。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-30" data-pagefind-meta="published:2011-05-30"><a href="https://neue.cc/2011/05/30_325.html">はぢめてのWindows Phone 7でのデータベース(Linq to Sql)</a></h1>
<ul class="date"><li>2011-05-30</li></ul>
<div class="entry_body"><p>Windows Phone 7に新しいSDKが来ました！9月頃リリースという話のMangoアップデート(Windows Phone 7.1)対応SDK。まだベータですが色々触れます。そしてついにデータベースが搭載されました。というわけで軽く触ってみました。</p>
<h2>Code First</h2>
<p>フツーだとSQLを書いてデータベースの定義を用意しなければならないところですが、WP7でのデータベースプログラミングにおいて、SQLは不要です。と、いうよりも、そもそも使えません。データベース本体(SQLCE)や、データベースにSQLを発行するクラス(ADO.NET)はMicrosoft.Phone.Data.Internalに格納されており、Internalという名のとおり、外から触ることは出来ません。ではどうするか、というと、WP7ではデータベースはLinq to Sqlを介して操作します。</p>
<p>じゃあテーブル定義どうするの、リレーションどうするの、というと、それはクラスから生成します。クラスを書いて、ある程度DB的に属性を付与して、CreateDatabaseとすれば、それらのテーブルを持ったデータベースが生成されます。まずコードを。あ、そうそう、System.Data.Linqの参照が別途必要です。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class Meibo : DataContext
{
    public Meibo()
        : base(&quot;isostore:/Meibo.sdf&quot;) // connection string
    { }

    public Table&lt;Person&gt; Persons { get { return GetTable&lt;Person&gt;(); } }
}

[Table]
public class Person
{
    [Column(IsPrimaryKey = true, IsDbGenerated = true)]
    public int Id { get; set; }

    [Column(CanBeNull = false)]
    public string Name { get; set; }

    [Column]
    public int Age { get; set; }
}
</code></pre>
<p>名前と年齢のあるPersonというテーブルを持つ、Meiboというデータベースを定義しました。データベースはDataContextを継承し、各Tableを持つプロパティを。そしてテーブルはTable属性とColumn属性を。IsPrimaryKeyは主キー、IsDbGeneratedは自動連番、CanBeNullはnull非許可です。Columnを付けて回るのが面倒くさそうですが、まぁ単純明快ではありますねん。</p>
<p>接続文字列は基底クラスに渡す形で。保存場所はIsolatedStorage内です。どうせ場所固定で弄らないでしょ？と思うので、上の例では直接定義しちゃっていますが、弄りたい場合はその辺調整で。ちなみにisostore:/です。isostore://にするとダメです（最初うっかり引っかかった）。</p>
<p>実際に使う場合は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 初回実行時はデータベースを作る、これはapp.xaml.csに書いておくといい
using (var db = new Meibo())
{
    if (!db.DatabaseExists())
    {
        db.CreateDatabase();
    }
}

// Insertの例
var meibo = new Meibo();

var person1 = new Person { Name = &quot;ほげほげ&quot;, Age = 20 };
var person2 = new Person { Name = &quot;ふがふが&quot;, Age = 15 };
var person3 = new Person { Name = &quot;たこたこ&quot;, Age = 23 };

meibo.Persons.InsertOnSubmit(person1); // Insertする
meibo.Persons.InsertAllOnSubmit(new[] { person2, person3 }); // 複数の場合

meibo.SubmitChanges(); // SubmitChangesまではDBへの挿入はされていない

// Selectの例(Ageが20以上のものを抽出)
var query = meibo.Persons.Where(p =&gt; p.Age &gt;= 20);

foreach (var item in query)
{
    MessageBox.Show(item.Id + &quot;:&quot; + item.Name + &quot;:&quot; + item.Age);
}
</code></pre>
<p>というわけで、DBの存在を全く意識せず自然に書けます。実に素晴らすぃー。</p>
<h2>リレーション</h2>
<p>リレーションも勿論張れます。例はマクドナルドのバーガーの価格表で。地域で価格が違うので、Burger(バーガー名)、Price(値段)、Place(地域)の3つをBurger-Price-Placeで関連付けてきませう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class McDonald : DataContext
{
    public McDonald()
        : base(&quot;isostore:/McD.sdf&quot;)
    { }

    public Table&lt;Burger&gt; Burgers { get { return GetTable&lt;Burger&gt;(); } }
    public Table&lt;Price&gt; Prices { get { return GetTable&lt;Price&gt;(); } }
    public Table&lt;Place&gt; Places { get { return GetTable&lt;Place&gt;(); } }
}

[Table]
public class Burger
{
    [Column(IsPrimaryKey = true, IsDbGenerated = true)]
    public int Id { get; set; }
    [Column]
    public string Name { get; set; }

    [Association(Storage = &quot;_Prices&quot;, OtherKey = &quot;BurgerId&quot;)]
    public EntitySet&lt;Price&gt; Prices
    {
        get { return this._Prices; }
        set { this._Prices.Assign(value); }
    }
    private EntitySet&lt;Price&gt; _Prices = new EntitySet&lt;Price&gt;();
}

[Table]
public class Price
{
    [Column(IsPrimaryKey = true, IsDbGenerated = true)]
    public int Id { get; set; }
    [Column]
    public int BurgerId { get; set; }
    [Column]
    public int PlaceId { get; set; }
    [Column]
    public int Value { get; set; }

    [Association(IsForeignKey = true, Storage = &quot;_Burger&quot;, ThisKey = &quot;BurgerId&quot;)]
    public Burger Burger
    {
        get { return _Burger.Entity; }
        set { _Burger.Entity = value; }
    }
    private EntityRef&lt;Burger&gt; _Burger = new EntityRef&lt;Burger&gt;();

    [Association(IsForeignKey = true, Storage = &quot;_Place&quot;, ThisKey = &quot;PlaceId&quot;)]
    public Place Place
    {
        get { return _Place.Entity; }
        set { _Place.Entity = value; }
    }
    private EntityRef&lt;Place&gt; _Place = new EntityRef&lt;Place&gt;();
}

[Table]
public class Place
{
    [Column(IsPrimaryKey = true, IsDbGenerated = true)]
    public int Id { get; set; }

    [Column]
    public string Name { get; set; }

    [Association(Storage = &quot;_Prices&quot;, OtherKey = &quot;PlaceId&quot;)]
    public EntitySet&lt;Price&gt; Prices
    {
        get { return this._Prices; }
        set { this._Prices.Assign(value); }
    }
    private EntitySet&lt;Price&gt; _Prices = new EntitySet&lt;Price&gt;();
}
</code></pre>
<p>ぎゃー。面倒くさ。本来のLinq to Sqlではデータベースが先にあって、そこから機械生成でこれを作るんですが、コードを先で作るのはちょっと骨が折れます。Entity Framework Code Firstは、コードを先に作るのが大前提だけあって書きやすいように色々調整してある感じですが、WP7/Linq to Sqlは、本当にただただ手で書きますというわけで全くイケてない。</p>
<p>さて、リレーションはAssociation属性でつけます。また、多を辿る場合はEntitySet、一を辿る場合はEntityRefのプロパティを用意します。これがまた面倒くさ……。たいしたことはない機械的作業ですが、自動プロパティで済ませられないとウザったいことこの上なく。コードスニペットでも用意しますかねえー。</p>
<p>しかし苦労するだけの価値は、あります！</p>
<p>まずデータを用意しなきゃということでInsertを。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Insertの例
var mcd = new McDonald();

var hamburger = new Burger() { Name = &quot;ハンバーガー&quot; };
var blt = new Burger() { Name = &quot;ベーコンレタストマト&quot; };

var kanto = new Place() { Name = &quot;関東&quot; };
var qshu = new Place() { Name = &quot;九州&quot; };
var hokkaido = new Place() { Name = &quot;北海道&quot; };

var prices = new[]
{
    new Price { Burger = hamburger, Place = kanto, Value = 100 },
    new Price { Burger = hamburger, Place = qshu, Value = 150 },
    new Price { Burger = hamburger, Place = hokkaido, Value = 160 },
    new Price { Burger = blt, Place = kanto, Value = 250 },
    new Price { Burger = blt, Place = qshu, Value = 230 },
    new Price { Burger = blt, Place = hokkaido, Value = 220 }
};

mcd.Places.InsertAllOnSubmit(new[] { kanto, qshu, hokkaido });
mcd.Burgers.InsertAllOnSubmit(new[] { hamburger, blt });
mcd.Prices.InsertAllOnSubmit(prices);

mcd.SubmitChanges();
</code></pre>
<p>リレーションを軽やかに片付けて、挿入してくれます。実に自然でイイ！それに、こういうののinsert文手書きはカッタルイですからねえ。更にSelectは</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var mcd = new McDonald();

// 関東のバーガーのNameとPriceを抽出
var query = mcd.Burgers.Select(b =&gt; new
{
    b.Name,
    Price = b.Prices.First(p =&gt; p.Place.Name == &quot;関東&quot;).Value
});

// ハンバーガー:100, ベーコンレタス:250
foreach (var item in query)
{
    MessageBox.Show(item.Name + &quot;:&quot; + item.Price);
}

// なお、IQueryable&lt;T&gt;をToStringすると手軽に発行されるSQLが確認出来る
// もう一つの手はDataContext.Logから取ること
MessageBox.Show(query.ToString());
</code></pre>
<p>コード上にjoinはないけど、発行されるSQLはjoinしています。手動でjoinすることも可能ですが、基本的にはオブジェクト間をドットで辿って操作します。その方が自然に書けるし、何より、楽ですもの。</p>
<h2>DataContextのDispose</h2>
<p>usingで括ってあげるのが礼儀正しいわけですが、WP7では実際どう考えるべきだろう。<a href="http://msdn.microsoft.com/en-us/library/hh202860.aspx">サンプル</a>見てると、CreateDatabaseやSchemaUpdateではusingで囲んでますが、そうでない普通の操作ではコードビハインド内でDataContext使い回してるんですね。基本的にIsolatedStorageに隔離されているわけだし、画面外に出るときだけ切った繋げたすればいいのかなあ、といったふうに思いましたがどうなのでしょ。</p>
<h2>.NET版との差分</h2>
<p>ほとんど.NET版のLinq to Sqlと同じなのですが、若干追加があります。一つはデータベースのスキーマのアップデート。<a href="http://msdn.microsoft.com/en-us/library/microsoft.phone.data.linq(VS.96).aspx">Microsoft.Phone.Data.Linq Namespace</a>名前空間の参照で、DataContextにCreateDatabaseSchemaUpdaterが追加されます。これにより、アップデートなどによるテーブル構造の変化にも対応出来ます。もう一つは
<a href="http://msdn.microsoft.com/en-us/library/microsoft.phone.data.linq.mapping.indexattribute(v=VS.96).aspx">IndexAttribute Class</a>。</p>
<p>これらは、通常Linq to Sqlが用いられていたデータベースからのクラス自動生成じゃなく、クラスからのデータベース生成になったことにより、テーブル作りに足りていなかった面の補足と見れるかな。また、その逆で.NET版でサポートされているけれど、WP7版にはないものも幾つかあります。詳しいリストはMSDNの<a href="http://msdn.microsoft.com/en-us/library/hh202872.aspx">LINQ to SQL Support for Windows Phone</a>を見ればいいんじゃないかな、ということで。</p>
<h2>学習リソース</h2>
<p>若干の差異はあるとはいえ、Linq to SqlはLinq to Sqlなので、<a href="http://msdn.microsoft.com/ja-jp/library/bb386976.aspx">MSDN - LINQ to SQL</a>を見るのが良いでしょう。また、慣れない間はWP7版ではなく.NET版で、ConsoleApplicationで挙動をあらかた確認しておいたほうが、スムースに行くかとは思います。属性貼ったりは、結構面倒だし罠もあるところですからね……。</p>
<h2>まとめ</h2>
<p>諸君らの愛したLinq to Sqlは死んだ！何故だ！そうしてEntity Frameworkに置き換えられる運命を辿ったLinq to Sqlですが、ここにきて華麗に復活するとは誰も予想だにしなかったところで、こういう展開は面白い。そして生SQLが使えないのは英断。縛りではあるのですが、Phoneでのアプリケーションの9.9割は、生SQLを必要とすることはないのではないか、とも。</p>
<p>生SQL触れるだろうと思ってWP7版も作るぜ！な勢いで用意していた<a href="http://dbexecutor.codeplex.com/">DbExecutor</a>のWP7版は永劫さようならになってしまいましたががが。DbExecutorはDbExecutorで、もう少し機能追加しますがー。</p>
<p>ところでMangoで、他に追加されたクラスを少し。System.Reflection.Emitが追加されました。これはILを直弄りして動的コード生成するためのクラスですが、WP7でIL生成とかヤラネーヨ。というわけでもなくはなく実は有益。シリアライザの高速化のために動的コード生成は常套手段となっているので、自分は直に使わなくても、普通にメリットは大きく。例えばJSON.NETのJSONシリアライズ/デシリアライズは、WP7版だけリフレクションを直に使ったもので見たところ遅そうでしたが、恐らく次からは.NET版と同じく動的コード生成になり、高速化されるでしょう。ORマッパーなどもそうです。そう、Linq to Sqlでも<a href="http://msdn.microsoft.com/ja-jp/library/system.data.linq.mapping.metaaccessor.aspx" title="MetaAccessor クラス (System.Data.Linq.Mapping)">MetaAccessor</a>クラスなどの辺りを覗いてみれば、ILをEmitしているコードが見えます。</p>
<p>そういえばLambdaExpressionもCompile出来るようになりました。が、AssignやLoopなどは搭載されていません、ぐぬー。コード生成したい人はExpressionTreeでお手軽、ではなく、まだまだILGeneratorでEmit頼りしかなさそうです。更に言えばExpressionVisitorも入っていませんね。SL4に近くなったけれどSL4とは言えない、WP7はWP7としか言いようのないAPIになってまいりました。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-24" data-pagefind-meta="published:2011-05-24"><a href="https://neue.cc/2011/05/24_324.html">基礎からのCode Contracts</a></h1>
<ul class="date"><li>2011-05-24</li></ul>
<div class="entry_body"><p>23日に<a href="http://msdn.microsoft.com/en-us/devlabs/dd491992">Code Contracts</a>についてのセッションを行いました。</p>
<div style="width:595px" id="__ss_8069150"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/code-contracts-8069150" title="基礎からのCode Contracts">基礎からのCode Contracts</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/8069150?rel=0" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/neuecc">neuecc</a> </div> </div>
<p>ufcppさんのレポートとセッション資料は<a href="http://csharp-users.jp/meeting/%E7%AC%AC7%E5%9B%9E%E6%97%A5%E6%9C%ACc-%E3%83%A6%E3%83%BC%E3%82%B5%E3%83%BC%E4%BC%9A-%E5%8B%89%E5%BC%B7%E4%BC%9A%E3%83%AC%E3%83%9B%E3%83%BC%E3%83%88">第7回日本C#ユーザー会 勉強会レポート - 日本 C# ユーザー会</a>に。Code Contractsを説明する場合、通常は背後にあるDesign By Contractの説明をしてから流れると思うのですが、今回はufcppさんが前の時間で受け持ってくれたので、その辺は完全スルーで.NET上のCode Contractsの話のみにフォーカスしています。</p>
<p>標準入りしているようだけど何なの？→実際は標準入りとは全然言えません というところから入って、主眼はバイナリリライター、ということで、セッションでは<a href="http://reflector.red-gate.com/">.NET Reflector</a>を片手にどのようにリライトされるかを見ていきました。どう展開されるのかをそうして確認すると、仕組みが理解しやすいのではないかと思います。Reflector有料化ということで、代替も色々出てきているようですが、私はReflector使い続けますね。他のはまだ低速だったりと色々引っかかるところが多いので。それとまあ、恩返しというか、今までお世話になっていますし。</p>
<p>Code Contractsは<a href="http://msdn.microsoft.com/en-us/devlabs">DevLabs</a>の中でも、Axumは死亡が確定(Blogに開発チームｵﾜﾀと書いてあった、ページから消えるのも時間の問題？)だし、Dolotoは明らかに開発止まってて何故残り続けているのかが分からないぐらいだし、というわけで最古株となっていますね。GT先輩いつ卒業するの！（やっとしました！）という感じな某車ゲーを少し思い起こしたり。卒業出来る日は来るのでしょうか。</p>
<p>それにしてもDevLabsはTC Labsばかりとなってしまい、何かツマラナサも感じてしまうような。というかtcのロゴの3って、最初にリリースされたSho, Dataflow, Dryadと3つだから3なのかと思ってましたが、最近Solver Foundationも入ってしまって4じゃねーか、という感。ていうかSolver Foundationは結構イケてるロゴがあるので、別にTCを冠しなくても良かったような。DryadはDryadで、<a href="http://blogs.technet.com/b/windowshpc/archive/2011/05/20/dryad-becomes-linq-to-hpc.aspx">'Dryad' becomes 'LINQ to HPC' !</a>だそうで、色々整理しきれてない感。</p>
<p>ところでスライド作りは結構楽しくはあるんですが、やっぱ大変ですねー。コードはコンパクトでなければならないし、全体的にしっかり流れが整ってなければならないし。かなり考えますが、そのお陰で、私の普段のだらだらブログ記事よりは分かりやすさアップしてるかな？というところです、前回のRxのスライド - <a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041">Reactive Extensionsで非同期処理を簡単に</a>もそうでしたが。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-21" data-pagefind-meta="published:2011-05-21"><a href="https://neue.cc/2011/05/21_323.html">Reactive Extensionsで非同期処理を簡単に</a></h1>
<ul class="date"><li>2011-05-21</li></ul>
<div class="entry_body"><p><a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a>にて、Reactive Extensionsの概要と、特に非同期を中心に話しました。以下、発表資料になります。</p>
<div style="width:640" id="__ss_8049041"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/reactive-extensions-8049041" title="Reactive Extensionsで非同期処理を簡単に">Reactive Extensionsで非同期処理を簡単に</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/8049041" width="640" height="534" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/">presentations</a> from <a href="http://www.slideshare.net/neuecc">neuecc</a> </div> </div>
<p>当初は初心者向け、と思ったんですが、どう見ても一回触ったことのある人向けですねこれ……。Rxを触ったことない人は、よくわからないけど普通に書くと大変なのがスッキリして何だか凄そう、触ってみようと思ってもらえれば。Rxを既に触っている人には使いこなしのTipsとして役立てて貰えればと思います。</p>
<p><object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" width="480" height="296" id="utv73143" name="utv_n_921786"><param name="flashvars" value="loc=%2F&amp;autoplay=false&amp;vid=14850251&amp;locale=ja_JP&amp;hasticket=false&amp;v3=1" /><param name="allowfullscreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="src" value="http://www.ustream.tv/flash/viewer.swf" /><embed flashvars="loc=%2F&amp;autoplay=false&amp;vid=14850251&amp;locale=ja_JP&amp;hasticket=false&amp;v3=1" width="480" height="296" allowfullscreen="true" allowscriptaccess="always" id="utv73143" name="utv_n_921786" src="http://www.ustream.tv/flash/viewer.swf" type="application/x-shockwave-flash" /></object></p>
<p>はい、Ustreamも残っています。マイクがなかったからという言い訳をしますが、声が全然入ってないですね、声入ってないということは会場でもモゴモゴーという感じで聞き取りにくかったはずで、すみません。それと、「まぁ」言い過ぎ。繋ぐ言葉を捜す枕詞として使いまくりで、うわちゃー、という感じ。慣れてないというか、こういうの（ほぼ）初めてで全然分かってなかったんですが、これを活かして次も頑張りたいです。（Usreamで自分の発表が自分で後から見れるのは自分が嬉しい(笑)）。スピーカーできて楽しかったです。機会をくれたすまべんの方々に感謝します。</p>
<p>……こういう機会がないと中々まとめないよね、というのもかなりあったり。合成系のメソッドの図はずーっと書こうと思っていて、書いてなくてこのセッションが初めてです。IObservableは時間軸に乗っているという話もこれが初めて。Twitterでボソッと書くだけじゃなくて、しっかりブログにまとめるようにならないといけないなぁ。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-17" data-pagefind-meta="published:2011-05-17"><a href="https://neue.cc/2011/05/17_322.html">Reactive Extensionsによる非同期クエリ</a></h1>
<ul class="date"><li>2011-05-17</li></ul>
<div class="entry_body"><p><a href="http://www.infoq.com/jp/news/2011/05/akka11">InfoQ: Future、性能、依存性の低減など多くの改善がされたAkka 1.1リリース</a>から「- Futureは完全にモナドになった。したがってfor内包表記を利用できる。」。リスト内包表記は、ようするところLINQなわけなので、では、とりあえず<a href="http://msdn.microsoft.com/en-us/data/gg577609" title="Reactive Extensions">C# + Reactive Extensions</a>で。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 非同期に対するLINQ(map, filter, etc...)
var asyncQuery =
    from a in Observable.Start(() =&gt; 10 / 2)
    from b in Observable.Start(() =&gt; a + 1)
    from c in Observable.Start(() =&gt; a - 1)
    select b * c;

// 非同期のまま実行したいならSubscribe
var canceler = asyncQuery.Subscribe(Console.WriteLine);

// 実行をキャンセルする場合はSubscribe時の戻り値をDispose
canceler.Dispose();

// 同期的に待って値取得したいならFirst
var result = asyncQuery.First();
</code></pre>
<p>Rx抜きで、TaskのContinueWithで↑を書くのはカッタルイ。また、Rxでもメソッド構文でSelectManyを連鎖でも辛い。何故か、というと、aの値をcの部分で使えないから。メソッドチェーンの形だと、どうしても一つ手前の値しか持ち越せない。そこで、クエリ構文が活きます。また、LINQであるが故にクエリ構文が使えるRxの嬉しさ。</p>
<p>じゃあ、調子にのって<a href="http://akka.io/docs/akka/1.1/scala/futures.html">Futures (Scala) — Akka Documentation</a>をRxで書き換えてみようかしら。同じような内容としては以前に<a href="http://neue.cc/2010/10/09_278.html" title="neue cc - Rxを使って非同期プログラミングを簡単に">Rxを使って非同期プログラミングを簡単に</a>という記事でTaskと比較していたのでそちらも参照を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// directly
var f1 = Observable.Return(&quot;Hello World&quot;);

// LINQが使える
var f2 = f1.Select(x =&gt; x.Length);

// Subscribeまで実行が遅延されるのでSleepしないよ
var f3 = Observable.Defer(() =&gt;
{
    Thread.Sleep(1000);
    return Observable.Return(&quot;Hello World&quot;);
});
var f4 = f3.Select(x =&gt; x.Length); // まだ実行されないよ
var result = f4.First(); // ここで実行

// Observableの連鎖はSelectManyで
var f5 = f1.SelectMany(x =&gt; f3);

// SelectManyはクエリ構文のfrom連打でも置き換えられる
var f6 = from a in Observable.Return(10 / 2)
         from b in Observable.Return(a + 1)
         from c in Observable.Return(a - 1)
         select b * c;
</code></pre>
<p>と、この辺まではいいんですが、Composing Futuresが何やってるのかよくわからないので(Scala知識ゼロですみません)、眺めながら<a href="http://msdn.microsoft.com/en-us/vstudio/gg316360" title="Visual Studio Asynchronous Programming">Async CTP</a>でも持ち出します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">async void HomuHomu()
{
    var f1 = Observable.Return(100); // IObservable&lt;int&gt;
    var f2 = TaskEx.FromResult(200); // Task&lt;int&gt;

    var a = await f1; // 何気にIObservable&lt;T&gt;はawait出来る
    var b = await f2; // 当然ですがTask&lt;T&gt;もawait出来る
    var result = a + b; // 300

    // じゃあObservableが幾つも値持ってる場合は？
    var f3 = new[] { &quot;homu&quot;, &quot;mado&quot; }.ToObservable();
    var c = await f3;
    Console.WriteLine(c); // &quot;mado&quot;

    // つまり、完了まで待って(OnCompleted)、最後の値が取得される

    // ところでObservable.Return = TaskEx.FromResultなわけですが
    // 以下の3つも同じと捉えていいです
    Task.Factory.StartNew(() =&gt; 100);
    TaskEx.Run(() =&gt; 200);
    Observable.Start(() =&gt; 300); // つまりfunc自体は即時実行
    
    // こちらも等しい(実行が遅延される)
    var t = new Task&lt;int&gt;(() =&gt; 100);
    var o = Observable.ToAsync(() =&gt; 100);
    // 実行するには
    t.Start();
    o.Invoke(); // もしくは o() ←ただのデリゲートなので

    // ToAsyncでは実行時に引数を渡すことも可能
    var o2 = Observable.ToAsync((int arg) =&gt; arg * 2);
    o2(1000).Select(x =&gt; x).Subscribe(Console.WriteLine);
}
</code></pre>
<p>雰囲気で何となくそうなのだろうと思いつつ、よくわからないので、適当に解釈しながら次。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// IObservable&lt;T&gt;はそのものがリスト状態とも言えるので、
// 複数値を持てるし、LINQなのでSelectしてAggregateも出来る
var futureSum = Observable.Range(1, 1000)
    .Select(x =&gt; x * 2)
    .Sum();
    
var sum = futureSum.First();
</code></pre>
<p>とりあえずこの辺で(特に言いたいことはない)。全く読めないとこういう時辛い。ActorとReactiveの関係とは、とか、見えそうな見えないような気持ち悪さが脳に渦巻いていて、勉強したいところです。F#で。</p>
<h2>上の話とは関係なく告知</h2>
<p>二件ほどお話を頂いたので、セッションします。まず、2011/05/21(Sat)にすまべん特別編でRxについて。内容はRx全般になるので、WP7ではなくても適用出来る話になります。</p>
<ul>
<li><a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a></li>
</ul>
<p>Rxの多くの機能のうち非同期に絞って、かつ、初心者向けに説明しますので、Rxって何それ食べれるのという感じでも全然大丈夫です。また、既に触っている人も、割とためになるTipsが得られるのではないかなと思いながら資料作成中。そうなるよう頑張ります。なので、是非聞きに来てください。セッション資料は、通信環境があればセッション終了後即座に上げるつもりです。なければまた後日で。Ustreamとかもあるのかな？あれば、そちらでも。</p>
<p>もう一件、5月23日(月)にC#ユーザー会でCode Contractsについて。</p>
<ul>
<li><a href="http://csharp-users.jp/meeting/%E7%AC%AC66%E5%9B%9Ecodeseek%E5%8B%89%E5%BC%B7%E4%BC%9A%EF%BC%86%E7%AC%AC7%E5%9B%9E%E6%97%A5%E6%9C%ACc-%E3%83%A6%E3%83%BC%E3%82%B5%E3%83%BC%E4%BC%9A-%E5%8B%89%E5%BC%B7%E4%BC%9A" title="第66回codeseek勉強会＆第7回日本C#ユーザー会 勉強会 - 日本 C# ユーザー会">第66回codeseek勉強会＆第7回日本C#ユーザー会 勉強会 - 日本 C# ユーザー会</a></li>
</ul>
<p>背景であるDbCなどについてはufcppさんが説明してくださるので、私はCode Contractsとして実装されていることを、Reflectorでこうリライトされるんですねー、とか見ながらデモ中心に、「一から使ってみよう」といった内容にしようと思っています。Code Contracts…… 名前だけなら聞いたことがある、いや、名前も聞いたことない何それ、ぐらいからが対象なのぜ、是非どうぞ。もう使っている、という人には物足りないかも(むしろそこは私が教えて欲しいもがもがもがもが)。</p>
<p>どちらも、まだ参加申し込み出来るようなので是非聞きにきてください。</p>
</div>
<h1 data-pagefind-sort="date:2011-05-11" data-pagefind-meta="published:2011-05-11"><a href="https://neue.cc/2011/05/11_321.html">Reactive Extensions RC0リリースによる変更点</a></h1>
<ul class="date"><li>2011-05-11</li></ul>
<div class="entry_body"><p>DevLabsの実験的プロジェクトから<a href="http://msdn.microsoft.com/en-us/data/gg577609">Data Developer Center</a>への正式プロジェクトとして昇格したRxですが、ついにDevLabsのページ自体が消滅(リダイレクトされる)し、いよいよ実験的なノリは一段落し、正式なプロジェクトとしての道を歩み始めたようです。その手始めとして、馬鹿デカい破壊的変更がやってきました。……っていきなりなんじゃそりゃ。</p>
<p>今回の変更はRC0、そしてStableであると銘打たれ、(今度こそ)APIの破壊的変更はないものと思われます。きっとAPIを変更するなら本当の本当に最後のタイミングだから、ということなのでしょうね、変更の嵐は。そんなわけで、DLLの分け方が変わってるし、名前空間も全部変わってるし、メソッド名もばかばか変わってるし、メソッドシグネチャも変わってるし、なくなったのもあるし、大量すぎて書ききれないほどに変更点がある。</p>
<p>しかし、本当の本当に安定版の始まりなので、つまり、学ぶなら今からが正に最適ということです！また、基本的な使い方が変わったわけではないので、既存の知識は生かせますしコード自体もそのままでも大体は行けます。大体は。</p>
<p>詳しい変更内容自体はフォーラム <a href="http://social.msdn.microsoft.com/Forums/en-US/rx/thread/527002a3-18af-4eda-8e35-760ca0006b98">New Release: Reactive Extensions v1.0.10425</a> に書かれています。こういうのはフォーラムじゃなくてBlogのほうでちゃんと告知してください……。リリースから半月近く経つのに、まだBlogのほうは更新されてないという。</p>
<h2>Rxの入手方法・パッケージ・DLL内容について Part2</h2>
<p>以前に<a href="http://neue.cc/2011/01/26_300.html">Reactive Extensionsを学習するためのリソースまとめ</a>としてまとめましたが、そのうちDLL内容がまるっと変わったので、そこの部分を修正します。なお、学習リソースについては変りないので、以前のまとめ記事をそのまま参照してください。また、Windows Phone 7に標準搭載されているものは(当然)変わりはありません。最近WP7本体のアップデートにコソッと紛れて更新(バグフィックス)されたようですけど。</p>
<p><a href="http://msdn.microsoft.com/en-us/data/gg577609">Reactive Extensions</a>のGet itからDownloadするといいでしょう。色々書いてありますが、2のDownload the Reactive ExtensionsからRx for all Platformsを選べばよいかと思います。</p>
<p>StableとExperimentalがあるように、安定版と実験版に分かれています。そして現時点ではそのページのExperimentalをクリックしてもExperimentalは手に入りません(なにそれ……)。Experimentalが欲しい人は<a href="http://www.microsoft.com/downloads/en/results.aspx?freetext=reactive+extensions&amp;displaylang=en&amp;stype=s_basic">Microsoft Download Center: Search Results</a>のExperimental Releaseから入手するといいでしょう。バージョン番号は、Stableは1.0.10425、Experimentalは1.1.10425になっています。</p>
<p>けれど、何だかんだで更新頻度が高いので、NuGet経由での利用が一番お薦めです。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/rxrc0nuget.jpg">
</p>
<p>が、NuGetの画面は新旧入り乱れていて何を入れていいか分からないカオスになっていたりして。説明すると、Rx-Mainとか、名前がRx-になっているものが新しいもので選ぶべきもの。Reactive Extensions -のものは古い残骸なので無視してください。また、NuGet経由で入るものはExperimentalのほうになります。</p>
<p>さて、今回からDLL類の分類がばっさり変わりました。</p>
<ul>
<li>System.Reactive (NuGetではRx-Main)</li>
</ul>
<p>以前あったCoreExは消滅し、コアコンポーネントはSystem.Reactiveのみとなりました。また、名前空間も全てSystem.Reactive以下に集められていて、例えば今までObservableクラスはSystem.Linqでしたが、今回よりSystem.Reactive.Linqに変更されました（拡張メソッドの利用に名前空間の参照は必須なので、この名前空間のusingは忘れずに）。</p>
<ul>
<li>System.Reactive.Windows.Threading (NuGetではRx-WPF/Rx-Silverlight)</li>
</ul>
<p>WPF/Silverlight向けでDispatcherに対するObserveOnとSubscribeOnのオーバーロードが追加されています。また、Dispatcher.CurrentDispatcherに対してObserveOn/SubscribeOnを行うObserveOnDispatcher/SubscribeOnDispatcherの利用もこのDLLの参照が必要になりました。それとDispatcherに対してBeginInvokeして実行するスケジューラDispatcherSchedulerが追加されました。</p>
<p>WPF/SilverlightでRxを使う場合はこれの参照は必需と思われます。NuGetを使う場合は依存の解決で、これを選択するとRx-Mainも入れてくれるので、こちらからInstallすると良いでしょう。</p>
<ul>
<li>System.Reactive.Windows.Forms (NuGetではRx-WinForms)</li>
</ul>
<p>WindowsFormsのControlに対するObserveOnとSubscribeOnのオーバーロードが追加されています。それとControlScheduler(Controlに対してBeginInvokeして実行するスケジューラ)。それだけです。というわけで、その名の通りWinFormsで使う場合だけ、あると便利。</p>
<ul>
<li>System.Reactive.Providers (NuGetではRx-Providers)</li>
</ul>
<p>Qbservableが収納されています。QbservableはIEnumerableに対するIQueryableみたいなもので、式木からObservableを生成するためのもの。今のとこ有効活用されている例も人もいないと思われます。(というかよく正式リリースにも生き残ったものだ、ぐらいの)。ちなみにQueryable Observableの略だそうで。QBみたいなものだと思えば可愛い！</p>
<p>例えばLinq to Twitterを非同期しかないSilverlightでやるなら、これを使うのが適切でしょう。現状だとコールバックでどうだのという格好悪い仕組みなので。(但し、System.Reactive.Providersは現状ではDesktop版にしか同梱されていませんが)。あとは公式の例として挙げられているWQL Provider。WMIに対するSQLで、クエリ結果はイベント(つまりRx)になる。非常に都合よくQbservableに当てはまるようになってますね。なってるんですが、そう都合よく当てはまるのはこれぐらいしかないのではないか、感もあったり。</p>
<p>いや、むしろ全て非同期なら全部Rxでいいんですよぅー、to SqlだってSqlCommandのBeginExecuteReaderでやればIQueryableじゃなくてIQbservableの出番なんですよぅー。……とはいっても、誰がやるかって話ですね。</p>
<ul>
<li>Microsoft.Reactive.Testing.dll (NuGetではRx-Testing)</li>
</ul>
<p>ユニットテスト用のモック生成クラス群。使いやすさ的には個人的にはちょっと微妙で、今一つ上手く活用出来なくて色々見送り中。</p>
<h2>FromEvent/FromEventPattern</h2>
<p>BufferWithCount/BufferWithTimeが統合されてメソッド名がBufferになった、程度の変更は割とどうでもいいのですが、Rxの中核であるFromEventに大きな変更があったのは見逃せません。簡単に解説します。</p>
<p>今までFromEventというメソッド名だったものはFromEventPatternに変わりました。また、戻り値がIEventからEventPatternというものになりましたが、中身はプロパティにSenderとEventArgsを持つという、ほとんど同じものなので、感覚的には一緒です。今までの私の記事や古いウェブ上の記事を見る際にFromEventが使われていたら、それはFromEventPatternに置き換えてください。そうすれば、そのままで動きます。</p>
<p>では新しく新設されたことになるFromEventは何なのかというと、よくわかりません:) そのうち使い方の説明とか出てくると思うのでそれ待ちで……。いやすみません。</p>
<h2>ところでInteractiveはどうしたの？ClientProfileは？Asyncは？</h2>
<p>死にました。というのもアレですが、とりあえず先行きは不透明です。少なくともStableに同梱されることはないそうです。Experimental側でのリリースは、一応計画はされているようですが、現状は同梱されていません。どうなるんでしょうかねえ……。Interactiveは欲しい人はNuGetに古いのが残っているので、それを使えば、ですね……。</p>
<h2>Experimental</h2>
<p>さて、今のところ、どのメソッドが実験的とされているのか、見てみましょう。幸いExperimentalAttributeでマークされているので、確認はコードで容易に出来ます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">typeof(System.Reactive.Linq.Observable)
    .GetMethods()
    .Where(mi =&gt; mi.GetCustomAttributes(typeof(ExperimentalAttribute), false).Any())
    .Select(mi =&gt; mi.Name)
    .Distinct()
    .OrderBy(s =&gt; s)
    .ToList() // Interactiveが消滅してしまったから...
    .ForEach(Console.WriteLine);

// 実行結果
Case
Create // 追加のオーバーロードのみ、通常のはExperimentalではない
DoWhile
Expand
For
ForEachAsync
ForkJoin
GetAwaiter
If
IsEmpty
Let
ManySelect
Remotable
Start // 追加のオーバーロードのみ、通常のはExperimentalではない
While
</code></pre>
<p>あまり大したものは入ってないようなので、そんな気にすることもないですね。Expandは是非入れてきて欲しいところなのだけど。CreateやStartのオーバーロードはかなりややこしい事になっているので、実験的扱いなのは納得。</p>
<h2>ReactiveOAuth ver.0.3.0.0</h2>
<p>そんな大移動があったわけでReactiveOAuthも動かなくなってしまった。というわけで更新しました(WP7版の人は気にしなくてもいいです)。</p>
<ul>
<li><a href="http://reactiveoauth.codeplex.com/">ReactiveOAuth</a></li>
</ul>
<p>機能は変わってなし。とりあえず最新版のRxで動くように、というだけです。コードが、とにかく名前空間が変わったので全部書き換えて、かなり面倒……。そして一部のメソッドは名前が変わったので、WP7版と完全にコードを共有していたので発狂。ifディレクティブでメソッド呼び出し部分をひたすら書き換え、などというのは見通しも悪いし格好悪いしで最悪なので、別の方法として、WP7側に拡張メソッド作ってコード上の互換を維持するようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class ObservableForCompatible
{
    // 本体のコードはRx RC0に合わせて、WP7側だけ拡張メソッドで同名のものを作って対処
    public static IObservable&lt;IList&lt;T&gt;&gt; Buffer&lt;T&gt;(this IObservable&lt;T&gt; source, int count)
    {
        return source.BufferWithCount(count);
    }
}
</code></pre>
<p>他にも挙動が若干変わってるのがあって原因掴むのに泣きそうになったりとか、思った以上に大変だった……。Stableと銘打ってるのに、次にこのクラスの大変更があったらさすがにブチ切れます。今回は、まあ、許す。</p>
<h2>Reactive Extensions Extensions(Rxx)</h2>
<p>コミュニティから面白いライブラリも上がってきています。</p>
<ul>
<li><a href="http://rxx.codeplex.com/" title="Reactive Extensions - Extensions (Rxx) - Home">Reactive Extensions - Extensions (Rxx) - Home</a></li>
</ul>
<p>Rx拡張メソッド集。C# 3.0の時も俺々拡張メソッドライブラリがいっぱい出てきましたが、そのノリですね。でも実際、Rx自体は原始的な機能のみなので、非同期処理とかイベント処理にフォーカスする場合は、もう一つ上の層で軽くラップしたライブラリは間違いなく必要だなと思っていますので、こういうのはいいな、と。私自身も非同期処理は<a href="http://neue.cc/2010/11/26_286.html" title="neue cc - Reactive Extensions用のWebRequest拡張メソッド">Reactive Extensions用のWebRequest拡張メソッド</a>として、結構ガッツし仕込んだものを使い回していて(ReactiveOAuthや<a href="http://neue.cc/2011/04/09_314.html" title="neue cc - Utakotoha - Windows Phone 7用の日本語歌詞表示アプリケーション">Utakotoha </a>の内部はこれ)かなり重宝しています。余裕が出たら、このRxxプロジェクトにJoinしたいな、と思ってます。</p>
<h2>Rxの本</h2>
<p>オライリーから出ているProgramming C#でお馴染みのJesse Libertyと、共著者として<a href="http://www.reactiveui.net/" title="ReactiveUI">ReactiveUI</a>というRxでWPFのGUI面をサポートするライブラリを作成しているPaul Betts(Microsoft Office Labsに所属)による、Rxの本が今年の秋頃に出る予定です。</p>
<iframe src="https://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=ilsgeometrati-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1430237473" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<p>執筆陣が豪華だしページ数も現時点amazon表示で300ページと、立派な仕上がりを予感させます。私は予約したよ！</p>
<h2>まとめ</h2>
<p>今回こそStableなはずなので、ようやーく人に自信を持って薦められるようになりました！いやマヂで。API的にも多分、じゃなくて絶対安定したわけなので、飛び込むなら今！です。</p>
<p>ところで本題とは関係ないんですが<a href="http://smartphone.techtalk.jp/?KantoSpecial01WindowsPhone7" title="スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東">スマートフォン勉強会 - すまべん特別編「Windows Phone 7 開発ブーストアップ」＠関東</a>でWP7+Rxのセッションをします。入門編として、主に非同期処理にフォーカスして、今すぐコピペで使ってコールバックを撲殺しよう、といった内容を考えていますので、是非聞きに来てください。</p>
</div>
<a href="https://neue.cc/16">Prev |</a>
<a href="https://neue.cc/18">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
