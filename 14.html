<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z51JP7Z8W"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4Z51JP7Z8W');
    </script>

    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js"></script>
        <div id="search"></div>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                new PagefindUI({ 
                    element: "#search", 
                    pageSize: 10,
                    highlightParam: "",
                    excerptLength: 80,
                    showImages: false,
                    showSubResults: false,
                    sort: { date: "desc" },
                    translations   : {
                        placeholder  : '',
                        clear_search : 'Clear',
                        load_more    : 'More',
                    }
                })
            });
        </script>
        <style>
            :root {
                --pagefind-ui-scale: 0.8;
                --pagefind-ui-primary: #9ba29f;
                --pagefind-ui-text: #9ba29f;
                --pagefind-ui-background: black;
                --pagefind-ui-border: #4d514f;
                --pagefind-ui-tag: #181818;
                --pagefind-ui-border-width: 0.5px;
                --pagefind-ui-border-radius: 0px;
                --pagefind-ui-image-border-radius: 8px;
                --pagefind-ui-image-box-ratio: 3 / 2;
                --pagefind-ui-font: 'Lucida Sans Unicode','Lucida Grande','Verdana','MS UI Gothic','sans-serif';
            }
            mark {
                background-color: blue;
                font-size: 99px;
            }
        </style>
        <div id="content"><h1 data-pagefind-sort="date:2012-10-12" data-pagefind-meta="published:2012-10-12"><a href="https://neue.cc/2012/10/12_382.html">linq.jsのTypeScript対応とTypeScript雑感</a></h1>
<ul class="date"><li>2012-10-12</li></ul>
<div class="entry_body"><p>Microsoftから<a href="http://www.typescriptlang.org/">TypeScript</a>という新言語が発表されました。驚くべきは、あのC#のAnders Hejlsbergが関わっている！これはもう触るしかない。そしてこれはコンパイル後にJavaScriptになる言語(CoffeeとかJSXとかみたいな)なわけで、じゃあlinq.jsを対応させるしかない！というわけで、させました。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// TypeScript
Enumerable.range(1, 10)
    .where(x =&gt; x % 2 == 0)
    .select(x =&gt; x * x)
    .writeLine();

// コンパイル後
Enumerable.range(1, 10).where(function (x) {
    return x % 2 == 0;
}).select(function (x) {
    return x * x;
}).writeLine();
</code></pre>
<p>ひゃっはー、もうfunction() { return }とはオサラバだ！そしてこの記述性と最強のコレクション操作であるLINQが合わさると最強に見える。</p>
<ul>
<li><a href="http://linqjs.codeplex.com/releases/view/91395">linq.js ver.3.0.3-Beta4</a></li>
</ul>
<p>に型定義ファイルは同梱してありますので、是非是非お試しを。NuGetのlinq.js -Preでも入ります。NPMは予定はありますが、まだです、すみません。</p>
<h2>TypeScriptについて</h2>
<p>型安全なCoffee Script、といった印象ですね。基本的にはCoffee Scriptに近いと思います。JavaScriptにプラスアルファな構文を採用することで、既存のJSライブラリとの繋がりを良くすることと、綺麗なJavaScriptを吐くことに重きが置かれている。TypeScriptは、比較的素直にJavaScriptに読み解くことが出来て、独自のコード生成は、現状はほぼほぼ無いし、意図的に省かれているようです（例えば非同期にたいしてasync構文を入れたりすると、大量のコード生成が入り、出力されるJavaScriptが機械的に汚れがち）。</p>
<p>そういった点、機能面では、TypeScriptには物足りなさを感じるところが多いかもしれません。じゃあJavaScriptに対する強みってどこなんだよ！といったら、一つはJavaScriptの冗長な記述性の補正(class,module, arrow function, Object.create/definePropertyとかも最低だしね)。もう一つは、無理なく自然に馴染んだ型付け。</p>
<p>型はないよりあったほうがいい。でも、型を付けるのがあまりにも苦痛だったら？ちょっとしたコードを書くのにも型！型！型！と押し付けられたら？そりゃあ、嫌だ。というわけで、型推論によって、比較的スムースに書けるようになっています。</p>
<p>型推論の性質というか範囲というか強さというかは、C#と非常に近いというかC#とまるで一緒なので、C#erならサクッと馴染めます。もっと強力な型推論のある言語に馴染んでいる人だと、え、ここで効かないの？みたいな違和感はあるかもですが。</p>
<p>また、さすがはMicrosoftというかAnders Hejlsbergというか、入力補完のことを念頭に置いた言語設計になっているので、IDEとの相性が非常に良い。そして最初からVisual StudioによるIDE環境が用意されていることで、型のある利点の一つであるリアルタイムエラー通知や入力補完をたっぷり満喫できます。さらに、それは<a href="http://www.typescriptlang.org/Playground/">TypeScript Playground</a>によってWeb上でも体感できます。というか、もはやPlaygroundはWeb IDEとでも言うべき驚異的な動き！</p>
<p>また、Windowsだけではなく、最初から<a href="http://blogs.msdn.com/b/interoperability/archive/2012/10/01/sublime-text-vi-emacs-typescript-enabled.aspx">Sublime, Vim, Emacs</a>の対応ファイルが用意されているというところからも、Windowsに限らず幅広く請求したい、という表れだと思います。そして実際、言語はプラットフォーム中立なわけです(最終的にはJavaScriptだしね！)。</p>
<h2>Structural Subtyping</h2>
<p>TypeScriptの最も面白いところは、ここです。C#とかのインターフェイスとLLのダックタイピングの中間、みたいな。実にゆるふわなJavaScriptと絶妙に合っててイイ！というかそもそも私はStructural Subtypingって名前だけでぜーんぜん分かってなかったのですが、TypeScriptだと自然と馴染めます。ほむ、どういうことか、というと、一例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">union(second: any[], compareSelector?: (element: any) =&gt; any): Enumerable;
union(second: Enumerable, compareSelector?: (element: any) =&gt; any): Enumerable;
union(second: { length: number;[index: number]: any; }, compareSelector?: (element: any) =&gt; any): Enumerable;
</code></pre>
<p>これはlinq.jsの型定義の一つでunion、和集合を生成するためのメソッドです。なので、元シーケンスと、対象シーケンス(second)が対象になるわけですが、じゃあシーケンスって何？と。列挙できればいいので、配列もそうだし、Enumerableもそう。そして、JavaScriptに特有の存在として、配列みたいだけど配列じゃあないもの(lengthを持っていてインデクサでアクセスできる)、例えばDOMのNodeListとか、もそう。</p>
<p>で、そういった「lengthを持っていてインデクサでアクセスできる」という型の定義が{ length: number;[index: number]: any; }。これにより、DOMのNodeListやjQuery([0]とかでHTMLElementが取れる)など、配列みたいだけど配列じゃないもの全てが型安全に定義されました。やったね！</p>
<p>もしC#だったら、対象はインターフェイスで指定するしかないので、IEnumerable&lt;T&gt;を実装していないクソコレクションクラスが存在したら、それは列挙不能になってしまいます。片っ端からオーバーロードを作るのは不可能だし、かといってdynamic secondなどとしてしまってはアレ。</p>
<p>とはいえ、基本的にC#では最初から全てのシーケンスはIEnumerable&lt;T&gt;を実装している、という前提が成り立っているので、問題はおこらない。でも、JavaScriptは違う。配列みたいだけど配列じゃあないもの、が跋扈してる。でも、そこをanyとして何でも受け入れられるようにしたら型安全じゃあない。安全にしたい。そこをStructural Subtypingが華麗に解決してくれました！惚れた……。</p>
<h2>TypeScriptはJavaScriptか？</h2>
<p>JavaScriptコードはそのままTypeScriptだ！ということにYesと言えるかというと、イエスでもあり、しかし割とノーです。私がこの話を聞いて、最初に思ったのは、既存JSコード、つまりライブラリ類もそのままで動くのかな？と。答えはNOです。JS固有の、実行時に切った貼ったして構造作っていくの、ああいうのTypeScriptだと軒並みコンパイルエラーになるので、ダメです。ほとんどのライブラリが絶滅でしょう。</p>
<p>と、勘違いしていたのですが(yharaさん指摘ありがとうございます！)</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">declare var $; // jQuery
declare var _; // underscore
declare var Enumerable; // linq.js
</code></pre>
<p>とかって定義すると、これはそれぞれ $:any, _:any, Enumerable:any という扱いになって、以降はどんなチェーンを繋げてもエラーが起こらない、つまりライブラリが正常に読み込めたかのようになります。</p>
<p>ただ、型チェックや入力補完が効かなくなるので、TypeScript用の型注釈ファイルはあったほうがいいですね。有名ライブラリはともあれ、無名プラグインとかは自前で型注釈書かなければならないかもり。手書きだとかったるいので、自動生成である程度テンプレート吐き出してくれないと、面倒くさい。この辺はMicrosoftだしやってくれるんじゃないかなあ、という淡い期待を抱いていますが……。</p>
<p>とはいえ、ちょっとしたコンパクトなプラグインを使ったり、ライブラリ使うとしても一部分だけだしー、などというのに、わざわざ型定義も馬鹿らしいわけで、さくっと動的な感じにdeclareできちゃう、というのは素晴らしい話。</p>
<p>そんなわけで、JavaScript→TypeScriptの相互運用性としては、繋がりはかなり良好。勿論、jQueryなどもスムースに扱うことができます。これは、文法がJavaScriptプラスアルファで構築されているがことの利点です。そしてTypeScript→JavaScriptは、というと、素直なJavaScriptを吐いてくれることもあり、良好です。TypeScriptで作られた生成物は、TypeScriptだけに閉じません。</p>
<p>JavaScriptを中間言語とする選択肢が増えた。JavaScriptを介することで他の言語とも自由に繋がる。ここには、Webの互換性、中立性を崩す要素は一切ありません。独自言語による囲い込みとかではありません。素直に歓迎できるはずです。ただし、言語としてはあくまでTypeScriptはTypeScriptです。そこだけは、誤解しないほうがいいと思います。文法的に、ES6を若干取り入れているとはいえ、違う言語です。将来的にもTypeScriptはEcmaScriptにならないでしょうし、EcmaScriptはTypeScriptにはならないでしょう。TypeScriptはEcmaScript6のただの代替なのではない、別の価値ある言語です。</p>
<p>変な期待をして、これJavaScriptじゃないじゃん、とかって難癖つけたりは、あまり良くないですね。</p>
<h2>TypeScriptとVisual Studio</h2>
<p>別にMicrosoft環境に閉じる言語ではないので、EmacsでもVimでもいいですが、やはりVisual Studioが第一な点は少なからずあります。LinuxでもIDEで書きたい？きっとJetBrainsがWebStormに搭載してくれるはずです！(実際、Voteはかなり集まってました)</p>
<p>ともあれ、Visual Studioです。専用拡張のインストールはTypeScriptのサイトから出来ます。プロジェクトテンプレートが何故かC#のところにあって気づきにくいことに注意！それともう一つ、<a href="http://visualstudiogallery.msdn.microsoft.com/07d54d12-7133-4e15-becb-6f451ea3bea6">Web Essentials</a>を入れましょう。元々Coffee ScriptとLESSに対応していたのですが、今回TypeScriptにも対応してくれました。Web Essentialsを入れることで、保存時のコンパイル（通常の拡張だとビルド時のみ）と、ウィンドウ分割での出力後のJS表示、それとSourceMapファイルの出力を行ってくれます。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_vs.jpg" />
</p>
<p>勿論、IntelliSenseはフルに効くしエラーはリアルタイムでがんがん通知してくれます。TypeScript Playgroundと違うのは、エラーがあるとJSに変換してくれないところですね。まあ、それは正しい挙動なのでいいです。Playgroundで中途半端なエラーのある状態でもガンガン変更表示してくれるのは、それはそれで便利なので、それもまたいいです。</p>
<p>ちなみに、TypeScript Playgroundでは赤波線が出ている状態は、一応、JSを出力してくれてますが、それはコンパイルエラーの状態で完全な出力がされていないと思って良いです。つまり、本来的には動いてないわけです。この動いていない出力を指して、(現状Firefoxにしか乗ってない)JavaScriptへの互換が不完全とかって難癖つけたりするのは、ほんと良くないですね……。</p>
<h2>SourceMap</h2>
<p>Web Essentialsの吐いてくれるSourceMapとは何ぞや、というと、これはTypeScriptのままデバッグができます。コンパイル時にJSを吐いてくれる系言語の欠点として、デバッガを使ったデバッグが困難、というのが挙げられますがSourceMapを使うとそれも解決、します。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_source.jpg" />
</p>
<p>現状、対応ブラウザはChromeと、まあ、他は知らないのですが、とりあえずChromeは対応しています。IE10(とVS2012内蔵デバッガ)も対応してくれると嬉しいなあ。Chromeのデバッガの不満点としては、ブレークポイントが行単位でしか貼れないことですね。ラムダ式の内側に貼れないと、特にLINQのような一行ラムダを多用するものではデバッグがとても不便でして。この辺、改善されていってくれると嬉しい話。</p>
<h2>vs JavaScript(のIntelliSense)</h2>
<p>実は、VisualStudio 2012のJavaScriptはかなりサポートが手厚く、裏で常にコードを実行して補完候補を出してくれたりします。</p>
<p class="noindent">
<img src="http://neue.cc/wp-content/uploads/image/typescript_js.jpg" />
</p>
<p>なので、純粋なIntelliSenseの効きだけでいうと、TypeScriptはJavaScriptに負けているかもしれない！如何せん、特にlinq.jsではシーケンスの要素がanyになってしまいますからね。JavaScript(を裏で動かして解釈する)ならば、ここも補完効いてしまうという。最近のJavaScript IDEは進化しすぎで恐ろしい……。</p>
<h2>ジェネリクス</h2>
<p>仕様書にも明言されていますが、正式リリースまでには搭載する予定があるそうです（ちなみに現在は0.8）。ジェネリクスが乗っかるとlinq.jsがすっごくパワフルになるんですよ。如何せん、今はシーケンスの要素の型が全てany扱いで補完が全く効かなくてTypeSafeでもなんでもないのですが、ここが型付けされると完璧なIntelliSense生活！C#並というかむしろC#超えるぐらいの勢いでパーフェクトなLINQ to Objects！なので、相当に待ち遠しいです。</p>
<h2>Compiler as a Serviceの未来</h2>
<p>TypeScriptのコンパイラはTypeScriptで書かれてます。これ、別にかっこつけとかでもなんでもなく、非常に重要な意味を持ちます。で、いきなり分かりやすく成果物として出してくれているのが<a href="http://www.typescriptlang.org/Playground/">TypeScript Playground</a>。構文解析がJavaScriptで可能だから、Web上で全て完結するIDEが作れる。C#も次のバージョンではC#コンパイラがC#で書かれるという計画があります。そのことがもたらす価値の一部分は、TypeScriptが教えてくれます。いや、むしろブラウザ上で全て完結というのは、C#以上の魅力がありますね、正直……。</p>
<h2>結論</h2>
<p>TypeScriptは、良い言語だと本当に本当に思います。私は、素のJavaScriptも別にそこまで嫌いではないのですけれど、やっぱ、違うなあ、と。なので今後は積極的に使っていきたいところです(CSSもLESSで！)。</p>
<p>言語設計者が同じということもありますが、特にC#erには絶対馴染むと思うので、(linq.jsとセットで)今までJavaScriptとは無縁だった人も手を出して欲しいですね。きっと気に入りますし、視点が変わります。勿論、ネイティブJSerも是非是非触ってみるといいと思います！というか触ってほしいです。</p>
<p>あ、あと、軽く流しましたがVisual StudioユーザーならWeb Essentialsも必ず入れておきましょう。これがあるのとないのとでは、TypeScriptの使い勝手全然違ってくるので、TypeScript試すならば必須です。</p>
</div>
<h1 data-pagefind-sort="date:2012-09-16" data-pagefind-meta="published:2012-09-16"><a href="https://neue.cc/2012/09/16_381.html">linq.js ver.3.0.2-RC, WinRT対応、最新RxJS対応など</a></h1>
<ul class="date"><li>2012-09-16</li></ul>
<div class="entry_body"><p>RCリリースしました！これでAPI弄りは終了で、あとはドキュメント周りの調整のみといったところです。</p>
<ul>
<li><a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a></li>
</ul>
<p>ダウンロードはダウンロードボタンからではなく、ダウンロードタブからlinq.js ver.3.0.2-RCを選択してください。というか<a href="http://linqjs.codeplex.com/releases/view/91395">ここからダイレクトに飛んでください</a>。</p>
<p>Beta2から結構立ちましたが、その間に、ノートPCがぶっ壊れたり（今もサポートで修理中、ちょうどうっかり未Pushなコミットが溜まってた状態で逝ってしまったのが痛手でどぅーにもこーにも）、そもそも日本にいなかったり（シンガポールにいましたというか、今は日本にいますが、これからは基本的にシンガポール中心になる感）とか、まぁ色々で色々で捗らずで。</p>
<p>さて、その間でもないですが、プログラミング生放送で8/25にセッションを持ちまして、そこでlinq.js ver.3の紹介をしましたので、スライド・録画ともどもにどうぞ。</p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/14066937" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/neuecc/linqjs-ver3-and-visual-studio-2012-in-javascript" title="linq.js ver.3 and JavaScript in Visual Studio 2012" target="_blank">linq.js ver.3 and JavaScript in Visual Studio 2012</a> </strong> from <strong><a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a></strong> </div>
<iframe width="312" height="176" src="http://ext.nicovideo.jp/thumb/sm18738964" scrolling="no" style="border:solid 1px #CCC;" frameborder="0"><a href="http://www.nicovideo.jp/watch/sm18738964">【ニコニコ動画】linq.js ver.3 (Part 1/2) - プロ生勉強会第17回＠品川 #pronama</a></iframe>
<iframe width="312" height="176" src="http://ext.nicovideo.jp/thumb/sm18739125" scrolling="no" style="border:solid 1px #CCC;" frameborder="0"><a href="http://www.nicovideo.jp/watch/sm18739125">【ニコニコ動画】linq.js ver.3 (Part 2/2) - プロ生勉強会第17回＠品川 #pronama</a></iframe>
<p>Visual Studio 2012はJavaScript関係がハイパー強化されているのですけれど、そのビッグウェーブにフルに乗っかって強力なんだぞ！みたいな。そういったVS2012のパワーとかの部分は、デモの比率が高いので、時間に余裕があれば、是非とも録画を見ていただけると嬉しいです。</p>
<p>あと、こそっとLINQ to XMLのアナウンスを、こそっと、ね。ふふり。</p>
<p>あ、そうだ、スライドに関しては一点、嘘があります。VS2012にはjQueryのIntelliSenseドキュメントの日本語版は入っていません。英語のみです。本当にごめんなさい、これ、確認していなくて、VS2010では日本語訳されたのが入ってたからそうなんだろうなあ、とか思ってたのですが、そんなことはなかったです。予算的な都合なのでしょうか……？ともあれ、申し訳ありませんでした。</p>
<h2>更新事項</h2>
<p>今回も破壊的変更が入っていて、firstOrDefault, lastOrDefault, singleOrDefaultの引数が変わりました。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// 以前
.firstOrDefault(defaultValue, [predicate]);

// これから
.firstOrDefault([predicate], [defaultValue]);
</code></pre>
<p>です。ようするに引数が逆になりました。predicateが先にあるのがC#のLINQと同じ並び順なわけで、ここだけ、何故かlinq.jsはC#に従ってなかったのですね。理由としてはJavaScriptにはdefault(T)は存在しないのでdefaultValueの指定を強制するために、第一引数に持ってきてやらなければならない。と、当時、3年前は思ってたらしーんですが、別に普通にないならないでnullでいいだろ馬鹿が、むしろ引数がこれだけ違うとか紛らわしいだろクソが。ということにやっと至りまして、変えられるのは今しかない！ということで変えました。</p>
<h2>コードスニペット</h2>
<p>そういえば3.0.1-Beta2のリリース時にはブログ書いてませんでしたが、そこでコードスニペットを改良したのを入れました。linq.js ver.2に同梱してたものよりずっと良くなってるのでリプレースするといいです。非常に捗ります。というか、もうこれなしで書く気しないぐらいに。</p>
<h2>RxJS</h2>
<p><a href="https://github.com/Reactive-Extensions/RxJS">Reactive Extensions for JavaScript(RxJS)</a>がオープンソースになりました、完全にソースコード公開です、ぱちぱちぱち。今までは<a href="http://scriptsharp.com/">ScriptSharp</a>で変換してたような気配だったのですが、完全手書きに移行したようです。</p>
<p>それに伴ってlinq.jsのRxJS連携も、若干手を加えました。ところで、今のところNuGetにあがっているものは、GitHubの最新に追随してません。古いままです。なので、NuGet版だとlinq.jsのRxJS連携は動かなかったりします(ビミョーに中身変わってるんですよ、いやはや……)</p>
<p>今のところ新RxJSに関してはリリースとかも打たれていないので、ステータスがどうなっているのか、よくわかりません。まあ、近日中に、かなあ？どうなのでしょうね。とりあえず、動向には注目、ということで。</p>
<h2>WinMD</h2>
<p>Windows 8のアプリケーション(Metroとは言えなくなりました！)はJavaScriptでも開発できるわけでして＆C++やC#で作成されたライブラリも条件付きというか専用のコンポーネントとして作れば、JavaScriptでも読み込むことができます。
コレクション周り、IList&lt;T&gt;はJavaScriptでは配列として扱えます。なので、これは何もなく普通に列挙できるし、今までのlinq.jsでも扱うことができました。しかし、IEnumerable&lt;T&gt;はIIterable&lt;T&gt;というものに化け、これは独特の列挙の仕方を要求するため、フツーには扱いづらく、また、今までのlinq.jsでも使えませんでした。</p>
<p>が、ver.3.0.2-RCからは、IIterable&lt;T&gt;対応を入れたので、列挙可能です！</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// IIterable&lt;T&gt;を列挙できるのはlinq.jsだけ！
var iterable = ToaruLib.GetIterable();
Enumerable.from(iterable).forEach();
</code></pre>
<p>WSH(JScript)対応といい、Windows固有のニッチ需要に100%応えるのはlinq.jsだけ。いやほんと。</p>
<h2>文字列ラムダと無名関数</h2>
<p>これは今までもの話なのですが、文字列ラムダに抵抗あるー、というのは分かります。しかし、無名関数を渡すこともできますぜ、というのは、分かって欲しいというか、利用シーンとしては半々なイメージなんですよね。例えばですが二つのJSONをJoinするのに</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">var jsArrayA = [{ &quot;projectid&quot;: 122, &quot;projecttype&quot;: &quot;radio&quot; },{ &quot;projectid&quot;: 133, &quot;projecttype&quot;: &quot;tv&quot; }];

var jsArrayB = [ { &quot;actionid&quot;: 1, &quot;name&quot;: &quot;kuow&quot;, &quot;pid&quot;: 122 }, { &quot;actionid&quot;: 2, &quot;name&quot;: &quot;kplu&quot;, &quot;pid&quot;: 122 }, { &quot;actionid&quot;: 3, &quot;name&quot;: &quot;abc&quot;, &quot;pid&quot;: 133 }, { &quot;actionid&quot;: 4, &quot;name&quot;: &quot;espn&quot;, &quot;pid&quot;: 133 } ];

var queryResult = Enumerable.from(jsArrayA)
    .join(jsArrayB, &quot;$.projectid&quot;, &quot;$.pid&quot;, function (a, b) {
        return {
            projectid: a.projectid,
            projecttype: a.projecttype,
            actionid: b.actionid,
            name: b.name,
            pid: b.pid
        }
    })
    .toArray();
</code></pre>
<p>これ、全部、無名関数で書くことも可能です。&quot;$.projectid&quot;をfunction(x){ return x.projectid} と書けばいいので。&quot;$.pid&quot;の部分もそうです。でも、それってすごくだるいですよね。</p>
<p>LINQはプロパティ名を指定するだけの無名関数を要求するシーンが多いです。どうせ、JavaScriptは動的言語、コンパイルチェックも働かないのですから、文字列で指定しても一緒でしょう。また、これは、jQueryのセレクターと同じようなものです。そう考えれば、文字列指定にもさして抵抗感はないのではないでしょうか？短くサラッと文字列でプロパティ名を指定したほうが、書きやすいし可読性も高いです。</p>
<p>同様に、最後のJOIN結果を新しいオブジェクトに変換しているところは、文字列ラムダで書くことも可能です。&quot;{projectid:$.projectid, projecttype:$.projecttype,....}&quot;といったように。でも、それって今度は逆にとても見づらくて可読性落ちますよね。長いコード、入り組んだコードになるようならば、素直に無名関数を使ってもらうのがいいな、と思っています。</p>
<h2>次回</h2>
<p>次は正式リリースです！いつになるかは、いつになるかしらん！8月末が正式リリースのつもりだったのに、一か月遅れでRCリリースですからねえ、んもぅー。ともあれ、間違いなく良い出来になっているので、楽しみにしてください。で、もうその前にRCじゃんじゃん使ってくだしあ。</p>
</div>
<h1 data-pagefind-sort="date:2012-08-10" data-pagefind-meta="published:2012-08-10"><a href="https://neue.cc/2012/08/10_380.html">複数の値とC# 5.0 Async再び、或いはAsyncEnumerableへの渇望とRx</a></h1>
<ul class="date"><li>2012-08-10</li></ul>
<div class="entry_body"><p>以前に<a href="http://neue.cc/2012/07/11_377.html">Reactive Extensions + asyncによるC#5.0の非同期処理</a>では、単体の値であったらasync、複数の値であったらIObservable&lt;T&gt;が使い分け、とかかんとかと言ってましたが、本当にそうなの？もしくは、そもそも複数の値のシチュエーションって分かるような分からないようななのだけど？などなどと思ったりする昨今を如何様にお過ごしでしょうか。というわけで、今回はグッとこの部分に深く迫ってみましょう。</p>
<h2>同期的なシチュエーション</h2>
<p>さて、例、なのですけれど、データベースで行きましょう。生DataReaderを転がしてます。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 接続文字列に Asynchronous Processing=true は非同期でやるなら欠かさずに
const string ConnectionString = @&quot;Data Source=.;Initial Catalog=AdventureWorks2012;Integrated Security=True;Asynchronous Processing=true;&quot;;

// こういうreader.Readが尽きるまで列挙するだけのヘルパーがあるだけで
static IEnumerable&lt;IDataRecord&gt; EachReader(IDbConnection connection, string query)
{
    using (var command = connection.CreateCommand())
    {
        command.CommandText = query;
        if (connection.State != ConnectionState.Open) connection.Open();

        using (var reader = command.ExecuteReader())
        {
            while (!reader.IsClosed &amp;&amp; reader.Read()) yield return reader;
        }
    }
}

static void Main(string[] args)
{
    using (var conn = new SqlConnection(ConnectionString))
    {
        // LINQでSelectとかいろいろ出来る！便利！抱いて！
        var result = EachReader(conn, &quot;select * from Sales.Customer&quot;)
            .Select(x =&gt; new
            {
                CustomerID = x.GetInt32(0),
                PersonID = !x.IsDBNull(1) ? (int?)x.GetValue(1) : null,
                StoreID = !x.IsDBNull(2) ? (int?)x.GetValue(2) : null,
                TerritoryID = !x.IsDBNull(3) ? (int?)x.GetValue(3) : null,
                AccountNumber = !x.IsDBNull(4) ? x.GetString(4) : null
            })
            .ToArray();

        // PKでとりたければFirstOrDefualtとかでいいわけです
        var customer = EachReader(conn, &quot;select * from Sales.Customer where CustomerID = 100&quot;)
            .Select(x =&gt; new
            {
                CustomerID = x.GetInt32(0),
                PersonID = !x.IsDBNull(1) ? (int?)x.GetValue(1) : null,
                StoreID = !x.IsDBNull(2) ? (int?)x.GetValue(2) : null,
                TerritoryID = !x.IsDBNull(3) ? (int?)x.GetValue(3) : null,
                AccountNumber = !x.IsDBNull(4) ? x.GetString(4) : null
            })
            .FirstOrDefault();
    }
}
</code></pre>
<p>ExecuteReaderの結果のIDataRederは、yield returnで列挙してやると、LINQで加工できるようになるので、SelectしてToArrayとか、SelectしてFirstOrDefaultとか、非常にやりやすくて便利なわけです。</p>
<p>ここまでは、いいと思います。じゃあ、非同期でやると、どうするの、と。</p>
<h2>内部イテレータ的に考える</h2>
<p>.NET Framework 4.5からは主要な非同期メソッドに全てXxxAsyncという名前のものがつきました。ADO.NETにおいては、OpenAsyncやExecuteReaderAyncなどがあります。というわけで、試してみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 非同期だったこうしたい、でもこれはコンパイル通らない！
static async Task&lt;IEnumerable&lt;DbDataReader&gt;&gt; EachReaderAsync(DbConnection connection, string query)
{
    using (var command = connection.CreateCommand())
    {
        command.CommandText = query;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync();

        using (var reader = await command.ExecuteReaderAsync(CommandBehavior.SequentialAccess)) // 基本的にはSequentialAccessにしておきたい
        {
            while (!reader.IsClosed &amp;&amp; reader.Read()) yield return reader;
        }
    }
}
</code></pre>
<p>残念ながら、asyncとyield returnを共存させることはできないので、どうにもなりません。……はい。しかし出来ない、では困る。さすがに、非同期実行するところに全部生のままで、こんなCreateCommand..., ExecuteReaderAsync, .... なんて書いてられないし。</p>
<p>じゃあどうするか、というと、内部イテレータ的にしましょう。つまりList&lt;T&gt;にあるようなForEachです。yield returnが外部イテレータ的であり、それが無理なら、内部イテレータ的にすればいいぢゃない。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// ループを回してる最中に実行するaction引数をつけた(FuncじゃなくてAction&lt;DbDataReader&gt;のオーバーロードも作るとベター)
static async Task ForEachAsync(DbConnection connection, string query, Func&lt;DbDataReader, Task&gt; action)
{
    using (var command = connection.CreateCommand())
    {
        command.CommandText = query;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync();

        using (var reader = await command.ExecuteReaderAsync(CommandBehavior.SequentialAccess)) // 基本的にはSequentialAccessにしておきたい
        {
            while (!reader.IsClosed &amp;&amp; reader.Read()) await action(reader);
        }
    }
}

static async Task&lt;List&lt;Customer&gt;&gt; GetCustomers()
{
    using (var conn = new SqlConnection(ConnectionString))
    {
        // これで、Selectっぽくできてないこともないと言えなくもない
        var list = new List&lt;Customer&gt;();

        await ForEachAsync(conn, &quot;select * from Sales.Customer&quot;, async x =&gt;
        {
            var customer = new Customer
            {
                CustomerID = await x.GetFieldValueAsync&lt;int&gt;(0),
                PersonID = !x.IsDBNull(1) ? await x.GetFieldValueAsync&lt;int?&gt;(1) : null,
                StoreID = !x.IsDBNull(2) ? await x.GetFieldValueAsync&lt;int?&gt;(2) : null,
                TerritoryID = !x.IsDBNull(3) ? await x.GetFieldValueAsync&lt;int?&gt;(3) : null,
                AccountNumber = !x.IsDBNull(4) ? await x.GetFieldValueAsync&lt;string&gt;(4) : null
            };
            list.Add(customer);
        });

        return list;
    }
}

// LINQじゃないので匿名型は使えないのね
public class Customer
{
    public int CustomerID { get; set; }
    public int? PersonID { get; set; }
    public int? StoreID { get; set; }
    public int? TerritoryID { get; set; }
    public string AccountNumber { get; set; }
}
</code></pre>
<p>ForEachAsync！というわけで、Actionを渡してやって、そこでグルグルッとすることにより制限を回避もどき。ToArrayしたい？古き良きListにAddすればいいぢゃない、といったものですよ、ははは。LINQじゃないので匿名型は使えないがね！</p>
<p>さて、匿名型が使えないのはいいとしても、問題は、LINQの特徴である合成可能性を欠いているところです。一番困るのは、これ、FirstOrDefaultできないね、って。全件取るんですか？まあ、PKだったら一件なのが保証されてるし、そうでないならtop 1とでも書いておけよ、と言えなくもないですが、しかしどうなのよこれ、と。</p>
<p>そんなわけでForEachAsyncと、もう一つ、ExecuteSingleAsyncという名前で、一件のみを列挙するようなものを別途作る必要があります。とはいえ、それでも対応できているのは一件と全件だけ。例えばTakeWhileみたいなのがやりたい、SkipWhileみたいなのがやりたいとなったらどうするの、と。答えは、どうにもなりません。諦めるしかない。</p>
<h2>AsyncEnumerableで救われる</h2>
<p>どうしても諦められないのならば、AsyncEnumerableを授けましょう。NuGetから<a href="http://nuget.org/packages/Ix_Experimental-Async">Ix_Experimental-Async</a>を引っ張ってきます。Ix、そう、みんな大好きReactive Extensionsの兄弟なわけですが、しかし紹介しておいてアレですが、このIx_Experimental-Asyncはお薦めはしません！完全に実験的に、できるから、というだけで実装例を掲示してみせてくれたというだけなノリがぷんぷんしているからです。実際、最初のAsync CTPが出た時に公開されて、それから更新されてませんしね……。</p>
<p>ともあれ、どんなコンセプトの代物なのかは見ておきましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こういうDB列挙用のIAsyncEnumerable/Enumeratorを作る。
// yield returnのようなコンパイラサポートはないので手書きするんだよ！
public class AsyncDbEnumerable : IAsyncEnumerable&lt;DbDataReader&gt;, IAsyncEnumerator&lt;DbDataReader&gt;
{
    DbConnection connection;
    DbCommand command;
    DbDataReader reader;
    string query;

    public AsyncDbEnumerable(DbConnection connection, string query)
    {
        this.connection = connection;
        this.query = query;
    }

    public IAsyncEnumerator&lt;DbDataReader&gt; GetEnumerator()
    {
        return this;
    }

    public DbDataReader Current
    {
        get { return reader; }
    }

    public async Task&lt;bool&gt; MoveNext(System.Threading.CancellationToken cancellationToken)
    {
        if (command == null)
        {
            if (connection.State != ConnectionState.Open) await connection.OpenAsync();

            command = connection.CreateCommand();
            command.CommandText = query;
            reader = await command.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
        }

        if (await reader.ReadAsync())
        {
            return true;
        }
        return false;
    }

    public void Dispose()
    {
        reader.Dispose();
        command.Dispose();
    }
}

static IAsyncEnumerable&lt;DbDataReader&gt; EachReaderAsync(SqlConnection connection, string query)
{
    return new AsyncDbEnumerable(connection, query);
}

static async Task Test()
{
    using (var conn = new SqlConnection(ConnectionString))
    {
        // 完全にLINQなのでSelectしてToArrayで匿名型もOK
        var result = await EachReaderAsync(new SqlConnection(ConnectionString), &quot;select * from Sales.Customer&quot;)
            .Select(x =&gt; new
            {
                CustomerID = x.GetFieldValue&lt;int&gt;(0),
                PersonID = !x.IsDBNull(1) ? x.GetFieldValue&lt;int?&gt;(1) : null,
                StoreID = !x.IsDBNull(2) ? x.GetFieldValue&lt;int?&gt;(2) : null,
                TerritoryID = !x.IsDBNull(3) ? x.GetFieldValue&lt;int?&gt;(3) : null,
                AccountNumber = !x.IsDBNull(4) ? x.GetFieldValue&lt;string&gt;(4) : null
            })
            .ToArray();

        // 勿論FirstOrDefaultもできる
        var customer = await EachReaderAsync(new SqlConnection(ConnectionString), &quot;select * from Sales.Customer where CustomerID = 100&quot;)
            .Select(x =&gt; new
            {
                CustomerID = x.GetFieldValue&lt;int&gt;(0),
                PersonID = !x.IsDBNull(1) ? x.GetFieldValue&lt;int?&gt;(1) : null,
                StoreID = !x.IsDBNull(2) ? x.GetFieldValue&lt;int?&gt;(2) : null,
                TerritoryID = !x.IsDBNull(3) ? x.GetFieldValue&lt;int?&gt;(3) : null,
                AccountNumber = !x.IsDBNull(4) ? x.GetFieldValue&lt;string&gt;(4) : null
            })
            .FirstOrDefault();
    }
}
</code></pre>
<p>IAsyncEnumerableの実装は完全に手作りです！真面目に使うなら、AnonymousAsyncEnumerableとかを作って、それを使って構築しますが、今回はてきとーな感じに実装しておきました。てきとーと言っても、ちゃんと動きますよ、はい。</p>
<p>さて、これによってIAsyncEnumerableに変換されたシロモノは、LINQのメソッドが全て使えます。おー、やったね、これなら完璧。</p>
<p>と、言いたいのですが、よーくSelectの中のラムダ式を見ると、ForEachAsyncの時のものと違うのが分かるでしょうか？ForEachAsyncの時はGetFieldValueAsyncといった、値取得まで非同期のものを使いました。でも、今回はそれは使ってない。何故かというと、そこでasyncにしてしまうと戻り値がIAsyncEnumerable&lt;Task&lt;T&gt;&gt;になってしまうから。</p>
<p>何がいけないのか、というと、例えばToArrayした結果で見るとresult[0]はTaskなんですよ。実態はresult[0].Resultとしなきゃあいけません。おまけに、全部Taskということは、実行中かもしれないわけです。じゃあ全部待てばいいのか、 await Task.WhenAll(result) とすればいいか、というと、そうなると、一つのコネクションで複数実行が走る、この場合Connectionは複数実行は許容されていないので、まあ例外が飛んできてしまうでしょう。</p>
<p>じゃあasyncは諦めるの？というと、幾つか手はある。ひとつはAwaitとかいうような拡張メソッドを作って、IAsyncEnumerable&lt;Task&lt;T&gt;&gt; から IAsyncEnumerable&lt;T&gt; に戻すようなものを作ればいい。作るのは、まあ、難しくはないのだけど結局yield returnがないので完全手書きしなきゃならないので面倒なので例は割愛。</p>
<p>もしくはSelectなどのselectorに、ラムダ式がasyncで書かれている場合(戻り値がTaskになっている場合)はawaitするようなオーバーロードがあっても良かったと思うのですがねえ。んー、まあ、それはさすがに大きなお世話っぽいからダメか……。</p>
<p>もしくは、ToArrayなどで外に出すのではなく、ForEachAsyncというメソッドが用意されているので、それを使ってawaitするか。こうなると内部イテレータとやってること同じになってきますが。</p>
<p>とはいえともかく、例に出したAwaitメソッドのような、そういうのがないと、実用性に欠けると言わざるを得ません。また、これはあくまでもAsyncEnumerableであって、IEnumerableへのLINQ to Objectsとは別物です。Select, Where, Firstなどは挙動が同じというだけで、中身は全然違います。で、当然ながらコンセプト実装なので、内部的にもあまりこなれてませんね。なので、Ix_Experimental-Asyncは所詮はコンセプト実装であり、面白いとは思いますし満喫はしましたが、実世的なものとは言いがたいと結論づけます。</p>
<h2>IObservable&lt;T&gt;の中へ</h2>
<p>と、ここまで見てきたので、最後はRxで〆ましょう。ちなみにRxはバージョンが幾つかありますが、私としてはRx 2.0-RCしか使う気はありません。正直、1.0系とは雲泥の差ですからねえ。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static IObservable&lt;DbDataReader&gt; EachReaderAsync(DbConnection connection, string query)
{
    // CreateAsyncで作る。OnErrorなどは手書きですが、十分に書きやすい
    return Observable.CreateAsync&lt;DbDataReader&gt;(async observer =&gt;
    {
        try
        {
            using (var command = connection.CreateCommand())
            {
                command.CommandText = query;
                if (connection.State != ConnectionState.Open) await connection.OpenAsync();

                using (var reader = await command.ExecuteReaderAsync(CommandBehavior.SequentialAccess))
                {
                    while (!reader.IsClosed &amp;&amp; reader.Read()) observer.OnNext(reader);
                }
            }
        }
        catch (Exception ex)
        {
            observer.OnError(ex);
            return;
        }
        observer.OnCompleted();
    });
}

static async Task Test()
{
    using (var conn = new SqlConnection(ConnectionString))
    {
        // Rxなので完全にLINQ、awaitableなのでToArrayをawaitしたりも出来るのでノリは完全に一緒
        var result = await EachReaderAsync(new SqlConnection(ConnectionString), &quot;select * from Sales.Customer&quot;)
            .Select(x =&gt; new
            {
                CustomerID = x.GetFieldValue&lt;int&gt;(0),
                PersonID = !x.IsDBNull(1) ? x.GetFieldValue&lt;int?&gt;(1) : null,
                StoreID = !x.IsDBNull(2) ? x.GetFieldValue&lt;int?&gt;(2) : null,
                TerritoryID = !x.IsDBNull(3) ? x.GetFieldValue&lt;int?&gt;(3) : null,
                AccountNumber = !x.IsDBNull(4) ? x.GetFieldValue&lt;string&gt;(4) : null
            })
            .ToArray();

        // もちろん、そのままSubscribeしたり、FirstOrDefaultAsyncしたりしてもいい
    }
}
</code></pre>
<p>というわけでRxでも生成はしやすいし、出力結果も相当扱いやすい。素晴らしい！けれど、これもIAsyncEnumerableと同様にSelectの中でasyncしちゃうと厄介なことになるので、基本的にはできない。</p>
<p>Await拡張メソッドを作るのは簡単だけど、Rxの場合はスレッドセーフの問題が結構難しくて、うまく決めるのは難しい……。</p>
<p>それに加えて、ほとんど決まりきっている、ただたんに列挙したいだけ、のものにRxを使うというのはやり過ぎ感があり、性能面でちょっとね、と。うーん、言うほど悪くはないし、今まで散々持ち上げといてなんだよそれって感じですが、目の前にTaskが転がっていて、そこまで利点が大きくない中で選ぶか？と迫られたら、選びにくいなあ、って。思ってしまうのです。</p>
<h2>おまけ：Entity Framework 6について</h2>
<p>Entity Frameworkはロードマップによりバージョン6から非同期対応すると明言しています。また、デザインノート<a href="http://entityframework.codeplex.com/wikipage?title=Task-based%20Asynchronous%20Pattern%20support%20in%20EF.">Task-based Asynchronous Pattern support in EF.</a>も公開されていたり、それとEFはソースコードが公開されているのですが、CodePlexから最新版を落としてくれば、そこには既にTaskによる実装が存在しています。</p>
<p>軽く見たところ、EF内部で使う用のAsyncEnumerableを定義してありました。それを使って、非同期系を動かしてましたね。ただ、完全に内部用なので外からは使えないし、色々限定的ですけれど。また、最終的に出力する場合は、やはり内部イテレータ的に、await ForEachAsyncしてListに変換するなりしていました。ふんふん、なるほどねー、と、結構眺めてて面白いのでお薦めです。</p>
<h2>まとめ</h2>
<p>C# 5.0で非同期は簡単になった！そして、同様に非同期はやはり難しい！こうして案を見ていったわけですが、結局どれを選ぶの？というと、まあ、内部イテレータ案が一番無難で良いと思います。</p>
<p>それにしても、いやあもう頭ぱっつんぱっつんです。で、何でDBがネタになっているかというと、新Micro-ORMライブラリを作成中で(DbExecutor v.Next)、今から作るなら非同期対応しないとかありえないよねー、ということで色々考えてはいるんですが、これが中々にビシッ！としっくり決めるのが大変で。結構良い感じにはなってきてつもりではあるんですが、全然まだまだで。あんま人に見られたくない段階なんですが諸事情で見れる人には見れるようになってしまってて恥ずかちい。</p>
<p>そんなわけでVS2012登場まで、もうすぐです(MSDN会員は一週間切ってる、そうでない人も一ヶ月後)。C# 5.0への備え、できてますか？さあ、カオスな非同期時代に突入しましょう！</p>
</div>
<h1 data-pagefind-sort="date:2012-07-29" data-pagefind-meta="published:2012-07-29"><a href="https://neue.cc/2012/07/29_379.html">XboxInfoTwit - ver.2.4.0.4</a></h1>
<ul class="date"><li>2012-07-29</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comが内部的にちょっと変わっていて動かなくなっていたので、それに対応しました。多分！</p>
<p>ちょっと今シンガポールに来ていまして、Xbox360の実機がないので動作確認してません！うわぁぁぁ。shoganaiので、ちょっとこちらでXbox360を調達しようか割と考え中。まあともあれ、動いたか動かなかったか報告頂ければ嬉すぃなあ。</p>
</div>
<h1 data-pagefind-sort="date:2012-07-20" data-pagefind-meta="published:2012-07-20"><a href="https://neue.cc/2012/07/20_378.html">linq.js ver.3.0.0-beta, メソッドlowerCamelCase化、など</a></h1>
<ul class="date"><li>2012-07-20</li></ul>
<div class="entry_body"><p>ずっとやるやる詐欺だったlinq.js ver.3ですが、ようやく始まりました！</p>
<ul>
<li><a href="http://linqjs.codeplex.com/">linq.js - LINQ for JavaScript</a></li>
</ul>
<p>トップページのボタンはstableのものになるので、DOWNLOADSタブからver.3.0.0-betaを選んでください。また、NuGetを使っている人はInstall-Package linq.js -Preで入ります。他にlinq.js-jQuery -Pre, linq.js-RxJS -Pre, linq.js-QUnit -Preなどり。</p>
<h2>lowerCamelCase化</h2>
<p>はい。ようやくJavaScriptらしくなりました。UpperCamelCaseにはC#っぽいとか、キーワードで衝突しなくなるとか、ちょっとした利点はなくもないのですが、そもそも.NETっぽくないほうがいい、というかJavaScriptの世界にちゃんと馴染ませたいという思いのほうが強い。そして、.NETの人以外にも使って欲しくて。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">Enumerable.range(1, 10)
    .where(function(x){ return x % 2 == 0})
    .select(function(x){ return x * x});
</code></pre>
<p>当然ながら超破壊的変更です。ver.2までのコードは一切動かなくなります。やりすぎですが、しょうがない。痛くてしょうがないけれどしょうがない。さて、ならばとついでにメソッド名の見直しもしました。</p>
<pre data-pagefind-ignore="all"><code class="language-text">Return -&gt; make
CascadeBreadthFirst -&gt; traverseBreadthFirst
CascadeDepthFirst -&gt; traverseDepthFirst
BufferWithCount -&gt; buffer
ToString -&gt; toJoinedString
Do -&gt; doAction
Let -&gt; letBind
MemoizeAll -&gt; memoize
Catch -&gt; catchError
Finally -&gt; finallyAction
ToJSON -&gt; toJSONString
</code></pre>
<p>これを機に、というかこういう機会じゃないとやれないですから。toStringやtoJSONは、上書きしてしまうとマズいので別名にしています。toStringは、まあそのままなので分かると思うのですが、toJSONのほうは、JSON.stringifyで特別扱いされるメソッドなので、こっそり注意が必要なんですね、というか実際ハマッて気づくのに時間かかりました。</p>
<h2>extendTo</h2>
<p>prototype.js以降、prototype拡張は悪、でしたが、最近のJavaScriptはfor inで列挙しない形での拡張(Object.definePropertyでenumerable:falseにする)が可能になっています。それを全面に押し出した<a href="http://sugarjs.com/">Sugar</a>といったライブラリもあり、確かに便利なのですよね。</p>
<p>さて、linq.jsでは配列などをLINQで扱うためにEnumerable.fromで包んでやる必要があって面倒でしたが、配列からそのままselectとかwhereとかが生えていれば、便利、ですよね？なので、任意に拡張できるようにしました。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// Arrayを拡張する
Enumerable.Utils.extendTo(Array);
        
[1, 3, 10, 1000].where(&quot;$%2==0&quot;).select(&quot;$*$&quot;);
</code></pre>
<p>Enumerable.Utils.extendToを一度呼べば、from不要で直接LINQのメソッドを呼ぶことができます。もしブラウザがObject.definePropertyに対応していなければ、その時はprototypeを直接拡張しています。</p>
<p>さて、LINQのメソッド名とネイティブのメソッド名が被っている場合は、ネイティブのメソッド名を優先して、上書きはしません。例えばjoinとか、concatとか。その場合はByLinqがメソッド名の末尾につきます。joinByLinq、など。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// 名称が被るものはByLinqというプリフィックスがつく
[1, 3, 10].reverseByLinq();

// もしくはasEnumerableメソッドを呼んであげればLINQのメソッドのみになります
[1, 10, 100].asEnumerable().forEach(function(x, index){alert(x + &quot;:&quot; + index)});
</code></pre>
<p>forEachなどは古いブラウザではそのまま、新しいブラウザではforEachByLinqになる、といったようにブラウザ互換性がなくなるので、個人的にはByLinqの形で呼ぶよりかは、asEnumerableを使うことのほうをお薦めします。</p>
<h2>Visual Studio 2012でのIntelliSense超拡張</h2>
<p>VS2012でlinq.jsを使うと、ただでさえ充実していたIntelliSenseが更に超補完されます。どのぐらい補完されるか、というと、selector関数でオブジェクトの候補が並んでしまうぐらいに。</p>
<p class="noindent">
	<img src="http://act.neue.cc/linq.js_3.0_intellisense.jpg">
</p>
<p>もはや完全にC#。あまりの快適さにチビる。勿論、↑の図ではFooは文字列なので、x.Foo.で文字列のメソッド候補がIntelliSenseに並びます。動的言語とは思えない超補完っぷりがヤバい。そして入力補完が最大限に活きるように設計されているLINQなので、組み合わさった時の快適度は半端ない。</p>
<h2>Chaining Assertion for QUnit</h2>
<p>ユニットテストを書く際に、equal(actual, expected)と書くのが嫌いでした。どちらがactualなのかexpectedなのか一瞬悩むし、そもそも外側から包むのがかったるくて。かといってshouldといった、英語的表現なのも冗長なだけで全く良いとは思っていませんでした。そこでC#では<a href="http://chainingassertion.codeplex.com/">Chaining Assertion</a>といった、actual.Is(expected)でアサートが書けるライブラリを作ったのですが、それをJavaScript用に移植しました。</p>
<pre data-pagefind-ignore="all"><code class="language-javascript">// 流れるように.isと打ち込むだけ
Math.pow(10, 2).is(100); // strictEqual(Math.pow(10, 2), 100)

// コレクションに対する適用は可変長にカンマ区切りで値を並べるだけ。勿論、配列にも使えます。
Enumerable.rangeTo(10, 15, 2).is(10, 12, 14); // deepEqual(Enumerable.rangeTo(10, 15, 2).toArray(), [10, 12, 14])

// LINQと組み合わさることでコレクション系のチェックが遥かに容易になる！
[1, 5, 10].all(&quot;$&lt;12&quot;).isTrue(); // collection assertion with linq.js!
</code></pre>
<p>といった感じに書けて、超楽ちんです。使うにはlinq.qunit.jsを別途読み込んでください。</p>
<h2>その他</h2>
<p>createEnumerable, createEnumerator, createLambdaといった、自作Enumerableメソッドを作るための道具を外部公開するようにしました。是非作っちゃってください。</p>
<pre data-pagefind-ignore="all"><code class="language-text">Enumerable.Utils.createLambda
Enumerable.Utils.createEnumerable
Enumerable.Utils.createEnumerator
</code></pre>
<p>更に、メソッドも追加されています。</p>
<pre data-pagefind-ignore="all"><code class="language-text">Enumerable.defer
asEnumerable
merge
choose
isEmpty
distinctUntilChanged
weightedSample
log
</code></pre>
<p>それらの細かい使い方などは追々書いていきます。また、merge, zip, concatは複数のシーケンスを引数に受け取れるようになりました。</p>
<p>そして、C#では、以前に<a href="http://neue.cc/2012/03/08_367.html">neue cc - LINQのWhereやSelect連打のパフォーマンス最適化について</a>という記事を書いた通り、Where連打やSelect連打、それにWhere-&gt;Selectといったよくあるパターンに対して最適化が入っているのですが、それをlinq.jsでも再現しました。なので、Where連打などによるパフォーマンス劣化が抑えられています。また、頻出パターンのWhere-&gt;Selectで高速化されたのはかなり大きいと思っています。</p>
<p>それに加えてrange, rangeDown, rangeToといったよく使う生成関数の速度を大幅に上げました（以前はtoInfinity().take()で生成していたのを、独自生成に変更したため）。</p>
<p>なので全体的にパフォーマンスも向上しています。</p>
<p>それと最後に、jQueryのプラグインとしてのものは今回からやめました。なんか混乱するし意味ないな、と思ったので、jQueryとの連携はlinq.jquery.jsによるtoEnumerable/tojQueryを追加するファイルのみとなっています。RxJSに関しても最新版のRxJSと連携できるようにしました(linq.rx.js)</p>
<h2>今後</h2>
<p>VS2012に対するIntelliSenseの充実化がまだ1/5ぐらいしか出来ていないので、それの充実が優先です。あと、リファレンスやサンプルが書けてないので追加。それらが出来たら、いったんver.3として正式公開します。<a href="http://atnd.org/events/30344">プログラミング生放送勉強会 第17回＠品川 #pronama : ATND</a>で話すつもりなので、その日、8/25までには正式公開を目指します！というわけで是非是非聞きに来てください。</p>
<p>あ、あとnode.js用にnpm公開も、ですね。</p>
</div>
<h1 data-pagefind-sort="date:2012-07-11" data-pagefind-meta="published:2012-07-11"><a href="https://neue.cc/2012/07/11_377.html">Reactive Extensions + asyncによるC#5.0の非同期処理</a></h1>
<ul class="date"><li>2012-07-11</li></ul>
<div class="entry_body"><p><a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions(Rx)</a>の利点ってなんですかー、というと、合成可能なんです！ということです。合成可能って何？というと、LINQが使えるということなんです！です。じゃあ他には、ということで…… 詳しくはこの動画/スライド見るといいです。 <a href="http://channel9.msdn.com/Events/TechEd/Europe/2012/DEV413">Curing Your Event Processing Blues with Reactive Extensions (Rx) | TechEd Europe 2012 | Channel 9</a>。最初のほうの例が非常に分かりやすいので、とりあえずその部分だけ引っ張ってきますと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// sender, argsの型がふわふわ
exchange.StockTick += (sender, args) =&gt; // senderの型が消えてる
{
    if (args.Quote.Symbol == &quot;MSFT&quot;)
    {
        // 合成できないからイベントの中でベタ書きしかない
    }
};

exchange.StockTick -= /* ラムダ式でイベント登録すると解除不能 */
</code></pre>
<p>これが通常のイベントの弱点です。Rxにすると</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// &lt;Quote&gt;という型が生きてる
IObservable&lt;Quote&gt; stockQuotes = ...; // 変数に渡せる

// LINQクエリ演算子が使える
var msft = stockQuotes
    .Where(quote =&gt; quote.Symbol == &quot;MSFT&quot;);

var subscription = msft.Subscribe(quote =&gt; /* */);

// イベント解除が容易
subscription.Dispose();
</code></pre>
<p>といった感じで、実に素晴らしい！じゃあEventはもうObsoleteでいいぢゃん、というと、まあいいと思うのですがそれはそれとして、C#ネイティブだからこそデザイナがイベントが大前提で考慮されていたり、軽くて実行速度が良かったり、といったところは勿論あります。あとRxだとイベントのIObservable化が面倒だとかもね。この辺は最初から言語サポートの効いてるF#のほうが強いんですよねー。</p>
<h2>非同期のリトライ</h2>
<p><a href="http://www.microsoft.com/visualstudio/11/ja-jp">Visual Studio 2012</a>も、もうRCということで間近感が相当にあります。一方で<a href="http://blogs.msdn.com/b/rxteam/archive/2012/06/20/reactive-extensions-v2-0-release-candidate-available-now.aspx">Reactive Extensions v2.0 Release Candidate available now!</a>ということで、こちらも間近感があります。一度2.0使うと1.0には戻れないよ！(NuGetではRx-Main -Preで入れられます)</p>
<p>じゃあRx 2.0の紹介でもしますかー、というと、しません！（ぉぃ）。その前に、asyncとRxの関係性にケリをつけておきましょう。</p>
<p>で、asyncの非同期とRxの非同期はやっぱり使い分けフワフワッという感じ。複数の値が来るときはRxでー、とか言われても、そもそも複数っていうのがそんなにー、とか。あと、それ以外にないの？というと、Rxの合成の強さが非同期にも発揮してRetry処理とか柔軟でー、とか。確かにそれっぽい。けれど、どうもフワッとしてピンと来ないかもしれない。</p>
<p>ので、例を出していきましょう。まず、リトライ処理。リトライ処理を素の非同期で書くと泣きたくなりますが、C# 5.0を使えばasync/awaitで何も悩むことなくスッキリと！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; DownloadStringAsyncWithRetry(string url, int retryCount)
{
    var count = 0;
RETRY:
    try
    {
        count++;
        var req = WebRequest.CreateHttp(url);

        using (var res = await req.GetResponseAsync())
        using (var stream = res.GetResponseStream())
        using (var sr = new StreamReader(stream))
        {
            return await sr.ReadToEndAsync();
        }

    }
    catch
    {
        if (count &gt;= retryCount) throw;
    }
    goto RETRY;
}

static void Main(string[] args)
{
    var google = DownloadStringAsyncWithRetry(&quot;http://google.com/404&quot;, 3);
    Console.WriteLine(google.Result);
}
</code></pre>
<p>簡単です。さて、ではこれをRxで書くと……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; DownloadStringAsyncWithRetry(string url, int retryCount)
{
    var req = WebRequest.CreateHttp(url);

    // retry処理は.Retryで済む
    using (var res = await req.GetResponseAsync().ToObservable().Retry(retryCount))
    using (var stream = res.GetResponseStream())
    using (var sr = new StreamReader(stream))
    {
        return await sr.ReadToEndAsync();
    }
}
</code></pre>
<p>はい。別にRxとasyncは排他じゃありません。使って効果のあるところに差し込んで、Mixしてやれば、ただでさえ強力なasyncが更に強力になります。TaskとIObservableは変換可能なので、ToObservableして、あとはRetryメソッドを繋げるだけ。そしてIObservableはawait可能(LastAsyncと同じ効果で、最後の値を取る。非同期処理の場合は値が一つなので問題なし)なので、まんまawaitしてasyncと繋げてやればいい。素敵ですねー。</p>
<p>が、上のコードはちょっと間違ってます。どこが間違っているか分かりますか？</p>
<p>エラーの帰ってくるページ(google/404などは404エラーを返してくれるのでテストに楽←別に500にすれば500を返してくれるわけじゃなくて、ただたんに存在しないページだから404なだけで、別にどこでもいいです)を指定して<a href="http://fiddler2.com/fiddler2/">Fiddler</a>などで観察すれば分かりますが、一回しかリクエスト飛ばしません。Retry(3)としても一回しか飛んでいません。ちゃんとRetryは3回しているのに。</p>
<p>どういうことかというと、GetResponseAsync()の時点でリクエストに失敗しているからです。失敗済みのリクエストに対しては、何回Retryしても失敗しか返しません。ここは本当にはまりやすくて注意所なので、よく気を付けてください！</p>
<p>解決策は、Retryで生成を毎回やり直すこと。Deferで包めばいいです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; DownloadStringAsyncWithRetry(string url, int retryCount)
{
    // Retry時に毎回WebRequestを作り直す
    var asyncQuery = Observable.Defer(() =&gt; WebRequest.CreateHttp(url).GetResponseAsync().ToObservable())
        .Retry(retryCount);

    // retry処理は.Retryで済む
    using (var res = await asyncQuery)
    using (var stream = res.GetResponseStream())
    using (var sr = new StreamReader(stream))
    {
        return await sr.ReadToEndAsync();
    }
}
</code></pre>
<p>ちょっと罠があるしコードも増えてしまったけれど、それでも、まあ、まだ割といいかな、って感じでしょうか？</p>
<p>さて、リトライは即時じゃなくて一定間隔置いた後にリトライして欲しいってことが多いと思います。同期処理だとThread.Sleepで待っちゃうところですが、それはちょっとスレッド勿体ない。C# 5.0からはawait Task.Delayを使いましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; DownloadStringAsyncWithRetry(string url, int retryCount, TimeSpan retryDelay)
{
    var count = 0;
RETRY:
    try
    {
        count++;
        var req = WebRequest.CreateHttp(url);

        using (var res = await req.GetResponseAsync())
        using (var stream = res.GetResponseStream())
        using (var sr = new StreamReader(stream))
        {
            return await sr.ReadToEndAsync();
        }

    }
    catch
    {
        if (count &gt;= retryCount) throw;
    }

    if (retryDelay &gt; TimeSpan.Zero)
    {
        await Task.Delay(retryDelay); // これで待つ
    }

    goto RETRY;
}
</code></pre>
<p>以前のものにTask.Delayを足しただけで簡単です。わーお、素晴らしい、なかなか強力強烈です。ではRxは、というと、同じように遅延する演算子を足すだけ。Delay、ではダメでDelaySubscription(Rx 2.0から追加)を使います。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; DownloadStringAsyncWithRetry(string url, int retryCount, TimeSpan retryDelay)
{
    // DelaySubscriptionで遅延させる
    var asyncQuery = Observable.Defer(() =&gt; WebRequest.CreateHttp(url).GetResponseAsync().ToObservable())
        .DelaySubscription(retryDelay)
        .Retry(retryCount);

    using (var res = await asyncQuery)
    using (var stream = res.GetResponseStream())
    using (var sr = new StreamReader(stream))
    {
        return await sr.ReadToEndAsync();
    }
}
</code></pre>
<p>できました！できました？いや、これだと初回リクエスト時にも遅延されちゃってて、ちょっとイケてない。修正しましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 外部変数用意するのがダサい
var count = 0;
var asyncQuery = Observable.Defer(() =&gt; WebRequest.CreateHttp(url).GetResponseAsync().ToObservable())
    .Let(xs =&gt; count++ == 0 ? xs : xs.DelaySubscription(retryDelay))
    .Retry(retryCount);
</code></pre>
<p>はい、ダサいし、なんだか何やってるのかさっぱりになってきました、サイテー。LetもRx 1.0にはなくて(それ以前にはあったのですが削られた)2.0から復活になります。Letは、一時変数を置かなくて済むというチェーン病にかかった人がお世話になる処方薬です。んなもん読みにくくさせるだけじゃねーか、という感じですが、もしLetがないと変数を置いて var xs = ToObservable(); xs = () ? xs : xs.Delay..; xs = xs.Retry(); としなければならなくて、非常に面倒くさいのです。だから、使いどころを守って乱用しなければ、割とイケてます。結構大事。</p>
<p>が、しかし、これも間違っています！（えー）。というかLetではなくて変数に展開してみるとオカシイとはっきり分かるのですが、Letの内部はRetryとか関係なく一回しか評価されないので、これだと必ずDelaySubscriptionなしのほうしか通りません。この路線で行くなら、更にやけくそでDeferを追加しましょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// Deferだらけとかダサすぎるにも程がある
var count = 0;
var asyncQuery = Observable.Defer(() =&gt; WebRequest.CreateHttp(url).GetResponseAsync().ToObservable())
    .Let(xs =&gt; Observable.Defer(() =&gt; count++ == 0 ? xs : xs.DelaySubscription(retryDelay)))
    .Retry(retryCount);
</code></pre>
<p>ダサすぎて話にならない。Defer連打ダサい。Deferまみれになったら、ちょっと根本から方針を疑いましょうか。ついでに外部変数を使うというのがそもそもダサい。もう少し頑張りましょう！クエリ演算子をこねくり回して、と。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// DelayなしのDeferとDelayありのDeferを連結して、DelayありのみをRetryさせている
var asyncQuery = Observable.Defer(() =&gt; WebRequest.CreateHttp(url).GetResponseAsync().ToObservable())
    .Let(xs =&gt; xs.Catch(xs.DelaySubscription(retryDelay).Retry(retryCount - 1)));
</code></pre>
<p>どうでしょう。他にもやりようは色々とあるかもですが、正直ワケガワカラナイのでこの辺でよしておいたほうがマシです。実際のところ、以下のような拡張メソッドを作るのがベストだと思っています。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// 結局これが一番なのではかという結論に至る
public static async Task&lt;string&gt; DownloadStringAsyncWithRetry(this WebClient client, string url, int retryCount, TimeSpan retryDelay)
{
    var count = 0;
RETRY:
    try
    {
        count++;
        return await client.DownloadStringTaskAsync(url);

    }
    catch
    {
        if (count &gt;= retryCount) throw;
    }

    if (retryDelay &gt; TimeSpan.Zero)
    {
        await Task.Delay(retryDelay);
    }

    goto RETRY;
}
</code></pre>
<p>new WebClient().DownloadStringAsyncWithRetry(&quot;hogehoge&quot;); だけですからねー。拡張メソッド万歳。Rx最終形のような短さとか魔術っぽさはゼロで面白くも何ともない、というか正直クソつまらないコードなわけですが、そこがC#のC#たる所以ですな、ということで。私はRxのようなクールさも勿論大好きなのですが、こういうイモさもまた、C#らしさであって、現実をより良くするための、目的を忘れない素敵な側面だと思っています。</p>
<p>ちなみにWebRequestの場合はそれ自体の作り直しが必要なので(一度エラーを受けたら何度GetResponseを繰り返してもダメぽ)、拡張メソッドダメです。WebClientはイベントベースなのでTask系と相性がアレで今一つなわけですが、WebRequestはWebRequestで、これベースに拡張メソッドだけで整えるのは無理があるのですね……。</p>
<p>.NET Framework 4.5からは<a href="http://msdn.microsoft.com/ja-jp/library/system.net.http.httpclient.aspx">HttpClient</a>というクラスが入るので、それを使うとちょっとだけモダンっぽい雰囲気。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// モダンなドトネト的にはHttpClientかしら
public static async Task&lt;string&gt; GetStringAsyncWithRetry(this HttpClient client, string url, int retryCount, TimeSpan retryDelay)
{
    var count = 0;
RETRY:
    try
    {
        count++;
        return await client.GetStringAsync(url);
    }
    catch
    {
        if (count &gt;= retryCount) throw;
    }

    if (retryDelay &gt; TimeSpan.Zero)
    {
        await Task.Delay(retryDelay);
    }

    goto RETRY;
}
</code></pre>
<p>別途System.Net.Httpの参照が必要なのが面倒ですが。</p>
<h2>非同期のタイムアウト</h2>
<p>Rxが色々できるのは分かったけれど、結局そういう部分って拡張メソッドとかに隔離してアプリケーションコードからは離れるので、やっぱそんなでもないんじゃないの！？というと、あー、まあそうかもねえ、とか思いつつ、複雑になればなるほど効果は加速しますが、そうなるとRxでも（見た目はスッキリしたとしても）やっぱ複雑ですからね。さておき、このままだとアレなのでもう少しまともな例を、一番最初に挙げた<a href="http://channel9.msdn.com/Events/TechEd/Europe/2012/DEV413">Curing Your Event Processing Blues with Reactive Extensions (Rx) | TechEd Europe 2012</a>から引っ張って来ましょうか。</p>
<p>タイムアウトを追加する例です。WebRequestだとTimeout設定すればいいぢゃーん、ではあるものの、そうではないシチュエーションも沢山ありますから、対策を知っていて損はないです。まず、asyncの例を。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; GetHtmlAsync(Uri url)
{
    var client = new WebClient();

    var download = client.DownloadStringTaskAsync(url);
    var timeout = Task.Delay(TimeSpan.FromSeconds(30));

    // これ結構トリッキーですよね
    if (await Task.WhenAny(download, timeout) == timeout)
    {
        throw new TimeoutException();
    }

    var html = await download;
    return html;
}
</code></pre>
<p>WhenAnyが中々トリッキーですね。慣用句として覚えてしまえばどうってことないのですが……。asyncもただawaitするだけじゃなくて、ちょっと慣れてきたらTask.WaitAll/Any, Task.WhenAll/Anyを使いこなすと、性能的な意味でも表現力的な意味でもグッと広がりますので、探究するのがお薦め。</p>
<p>さて、それをRxでやると……</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">static async Task&lt;string&gt; GetHtmlAsync(Uri url)
{
    var client = new WebClient();

    var download = client.DownloadStringTaskAsync(url)
        .ToObservable()
        .Timeout(TimeSpan.FromSeconds(30));
            
    var html = await download;
    return html;
}
</code></pre>
<p>ToObservableして、Retryの時のようにTimeoutを足すだけ。非常に直観的で、楽ちん、分かりやすい。演算子が豊富なのはRxの強みです。だからRetryにTimeoutがつけられるオーバーロードが最初から用意されていれば、Letとかで複雑になってしまった例もスッキリ仕上がって、ﾄﾞﾔｧと言えたんですけどね（笑）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">// こういうのを作っておけば！
static IObservable&lt;T&gt; Retry&lt;T&gt;(this IObservable&lt;T&gt; source, int retryCount, TimeSpan retryDelay)
{
    return source.Catch(source.DelaySubscription(retryDelay).Retry(retryCount - 1));
}

// 神がかってシンプルに！Rx最強！
public static async Task&lt;string&gt; GetStringAsyncWithRetry(this HttpClient client, string url, int retryCount, TimeSpan retryDelay)
{
    return await Observable.Defer(() =&gt; client.GetStringAsync(url).ToObservable()).Retry(retryCount, retryDelay);
}
</code></pre>
<p>標準で足りない演算子は自分で作ればいいので、また、asyncが出来たことで、今まで自作が大変だった演算子も作るのが大分容易になりました！ので、ガンガン作ってしまうといいです。汎用的に使える演算子が集まれば集まるほど、Rxの合成可能という性質が価値を発揮します。</p>
<h2>リトライやタイムアウトをC# 4.0でRxなしで書くと</h2>
<p>死ぬほど面倒なので書きません。いや無理でしょ常識的に考えて。</p>
<h2>まとめ</h2>
<p>というわけで、Rxとasyncは手を取り合って仲良く高みを目指せばいいわけです。使いこなしが必要なのはどっちも変わらない！</p>
<p>さて、@ITの連載、<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/index.html">Reactive Extensions（Rx）入門 － ＠IT</a>
の次回は非同期のはずですが(聞こえなーい)、ええと、はい、すみません……。ええと、あと次はRx 2.0の強化事項を、ええと、まあそのうちいつか……。はい、すみません。</p>
<p>諸事情あって今色々詰まってて本気でヤバいんですが、それはそれとして、現在全力で一年以上やるやる詐欺だったlinq.jsの改修を進めていまして、これは本当に本当に絶対近日中にベータを出すのでお楽しみに。相当にイイ出来で、割と革命的に凄い内容になってます。いやほんと。かなり自信ありますよ。</p>
<p>他の積みタスクは、ReactiveOAuth(バグ修正のPull Requestを放置中というサイテーな有様、OAuth 2.0対応しないの？とか)、ReactiveProperty(WinRT対応まだー？)、Utakotoha(現在動いてない模様なので要改修)、DbExecutor(全面再構築まだー？DataSet殺すんでしょー？)とかでしょうか、って結構ありますね、うわぉぅ。というかReactive系は2.0対応とWinRT対応をやらなきゃならないので作業量的に面倒くさくて、ついつい手が遠ざかってしまいですね。はい、でも、やります。</p>
<p>にゃー、という感じでブログも結構アレなWebFormsとDataSetディスもそろそろさようならして、通常営業に戻ってきませう。</p>
</div>
<h1 data-pagefind-sort="date:2012-06-30" data-pagefind-meta="published:2012-06-30"><a href="https://neue.cc/2012/06/30_376.html">DataSetについて</a></h1>
<ul class="date"><li>2012-06-30</li></ul>
<div class="entry_body"><p>けちょんけちょんに言ってるとか言ってないとかで言えば言ってるので、遅まきながらその理由などをつらつらと。正直なところDataSetなんて現代の観点から使ってみれば、一発でどれだけクソなのか自明だろう、ぐらいに思ってたので別に言うまでもないと思ってたので特に述べてなかったのですが、意外と支持の声も大きいのですね。困惑するぐらいです。</p>
<p>DataSetというと型付きと型無しがありますが、形無しのほうは、もういらないんじゃないかな。カジュアルな用途ならExpandoObjectを使ってくれという感じだし、そうでないなら、C#で型無しのヘヴィな入れ物とか利点を損ねるしかないわけで。せめてdynamicに合わせた作り直しが必要よね。</p>
<p>それでもADO.NETと密接に結びついていて、たとえばSqlBulkCopyはDataTableしか受け取らないなどがある。だから必要か、というと、そうじゃあなくて。そうじゃなくて、それは害悪なんだって。そのせいでストリームで流し込めないし。今時だったらIEnumerableに対応していて欲しいところだというのに（なお、専用のIDataReaderを手作りすればストリームで流し込めます）。腐った現状を肯定するんじゃなくて、どうあるべきなのかを認識しよう。</p>
<p>ちなみにLINQ to DataSetは型無しDataSetのためのキャスト要因でしかないので、ほとんど名前だけでドーデモイイ代物です。型付きDataSetのほうは一応IEnumerable&lt;TRow&gt;なので不要なんですよね。</p>
<p>さて、話の主題のStrongly Typed(笑) DataSetのほうは、死んでほしい。今すぐに跡形もなく消え去ってほしい。なんでそうも恨み言が多いのかと言ったら仕事で割とヘヴィに使い倒しているから、なのですけれど。</p>
<h2>Nullableに非対応</h2>
<p>分かりやすく最大の馬鹿げた点はここですね。マトモな神経ならどれだけ頭可笑しいのか分かるはずで。作られた年代が年代だからしょうがない？いや、今話しているのは現代のことで、そんなNullable非対応のまま更新されず、大昔に見捨てられた代物なんてどんな選ぶ理由あって？</p>
<p>なお、型付きDataSetを知らない人に説明すると、nullが入る可能性のある列に対してはIsHogeNullというメソッドが生成されているので、そちらで事前チェックすればいい、というシステムになっています。if(row.IsHogeNull()) row.Hoge; といった感じ。もしnullの状態でrow.Hogeにアクセスすると実行時例外。</p>
<p>これ、すごく気持ち良くないんですよね。型付き言語の良さって型がドキュメントなことであり、C#の良さってそれがIntelliSenseでコードを書いている最中からリアルタイムに立ち上がって教えてくれるところであって。なんでコード書いてIntelliSenseも出ているのに、それがnullが混じる可能性があるのかないのか分からないの？Hogeの型がNullableならば、そこから伝わるのに。こういうC#の利点を損なうような代物は全力で許さない。</p>
<h2>Enumに半分非対応</h2>
<p>データベースの数値とC#上のEnumを関連付けることは割とあるシチュエーションだと思うわけですが(EntityFrameworkでもずっと要望に上がっていて最近やっとようやく対応しましたね……)DataTableもプロパティに関してはDBの型ではなくEnumに変更できます。ただし、TableAdapterによるメソッドの引数のほうは変えられないんですねー、あははぁ、intだー、intだぁー、凄いね、キャストだね。クソが。</p>
<p>ただたんにキャストすればいいだけだから大したことないぢゃん、と思うかもですが、これは非常に大きなことなのです。タイプセーフ、というだけじゃなくて、引数の型がEnumだと、それに沿うようIntelliSenseの第一候補として優先的に表れてくれて、こういう些細な気配りがC#の気持ちのよいプログラミングを支えているのです。</p>
<p>これでどこがTypedなのか。ありえないレベル。</p>
<h2>使えないデザイナ</h2>
<p>デザイナ、重いんだよね、普通に。激しくストレスなぐらいに。そして位置の設定はすぐに吹き飛んで横一列に並びきった整列へ。重い状態でセーブするとDesginer1.cs, Designer2.csと数字が延々とインクリメント。そして、長大奇怪なXMLに保存されるのでコンフリクトが発生したらマージ不能。OK、DataSetは古の悪名高きVisual SourceShredder（ロック方式なのでコンフリクトは原理上一応発生しない）とセットで使うべきものなんだな、それならばしかたがない。つまり、現代で使うべきものではない。</p>
<p>そして、基本的にクエリはこのデザイナから書かせるものなのですが、うまくSQLを解釈してくれない。ちょっと凝ったクエリを書くだけで、機能しなくなる。例えばSQL Serverの共通テーブル式とかうまく作れない。生SQLを書かせるのに、シンプルなSQLしか書けない。whereのin句にパラメータを並べるとかもできない。それなら逐語的文字列で書かせてもらったほうが百億倍マシだわ。というか書かせろという感じですが。（できなくもないですけれどね、ただもうそれならそもそもDataSet使わなくていいぢゃん、ほかの余計な制約もあるのだから、といったところで）。</p>
<h2>お節介DataRowView</h2>
<p>私の今の主戦場はWebFormsなのですが、RepeaterにDataTableをバインドすると、あら不思議、DataRowがDataRowViewに化ける！わー、嬉しいー、死ね。余計なおせっかいとしか言いようがない。これ、まあ現代的なC#erならばDataTableをLINQ使って加工したのをバインドしたりもするわけで、IEnumerable&lt;DataRow&gt;の場合は、そのままのDataRowが来る。ええ、同じはずの型が、違う型でやってくるなんて、悪夢すぎる。狂ってる。</p>
<h2>文字列クエリ</h2>
<p>Selectメソッド！紛らわしいですが、DataTableのSelectはLINQにおけるWhereにあたります。「文字列」でクエリ書かせるものが存在します。おお、文字列、タイプセーフじゃあないねえ……。型付きDataTableであっても戻り値は型無しDataTable、なんだねえ……。すごい、すごいすごい。いらないね。現代的に強化するならExpressionに対応させてタイプセーフなクエリを発行するとか、やりようはあるはずですが2005年で更新止まってるのでそんな高尚な機能が追加されることは未来永劫ないでしょう。</p>
<p>おまけに型付きのDataTableはLINQ to Objectsで扱えるので、素直にLINQ to Objectsにまかせてしまったほうが遥かに良い。LINQ以前は、DataTableってインメモリDBとしてある程度のクエリが簡単に実装できる、というところがあったのですが、LINQ以後の世界では純粋なC#コードとして簡単にソートも射影もフィルタリングも可能、それどころか備え付きのクエリとは比較にならないほど柔軟で強力なクエリ能力を手にしているので、もはや中途半端なインメモリDBは不要で、純粋なコレクションだけで構わないぐらいなのですよね。</p>
<h2>モック作るのが面倒くさい</h2>
<p>専用のヘルパでも作りこまない限りは絶望的。</p>
<h2>じゃあどうするの？</h2>
<p>そうですね、ここの回答がない限りはDataSetから抜けられないのですしね。私としてはLINQ to SQLでいいぢゃん(EntityFrameworkじゃなくてね)、と思うのですけれど。MSのコンサルタント連中が2009年末にもなって<a href="http://www.atmarkit.co.jp/fdotnet/chushin/chushinmeeting_01/chushinmeeting_01_03.html">いま使うべき、学ぶべき.NETテクノロジはどれ？</a>という講演で「まずはデータセットやテーブルアダプタを活用できることが大事、とか」「更新系が弱い」とか言い続けているのが絶望的。なんでDataSetが基礎知識なんだよ、馬鹿じゃねーの。</p>
<p>オールドテクノロジーで縛り付けたいのかしらね。求められるのは、ある程度の弱さを知覚した上でのPOCO+DataContextでの使いこなしかたの説明が求めるわけで。まさか、2012年の現在でもEntityFrameworkは更新に弱くてDataSetがまずは基本ですね、とか言っていやあしないですよね、知らないけど。</p>
<p>何でも得手不得手があって使い分けが大事、とかいうのはすごく簡単な逃げ口上ですが、何にでもメリットデメリット、そして未来の潮流を踏まえたうえでの学習の投資で天秤にかけなければならない。DataSetに未来はどこにあるの？腐臭を放ってる資産の保守ぐらいでしょ。こういう影響力ある人らがどうしょうもないことを言うのには、猛烈に腹が立っていてずっと不信感しか持てない。今のところ最後の赤間本であるLINQ本も急いで作った感バリバリでとてもひどいしね（そのことが前説にも書いてあるしね！影響力があるのは分かっているのでしょうから、もう少し丁寧に書けなかったものなのか）。</p>
<p>まあ、WebFormsやWinFormsにはDataSetを前提においたコントロール資産が山のようにあるから……。というのは移れない理由にはなるでしょうね。その場合はプラットフォームごとサヨウナラするしかないんじゃないの？そこまでは知りませんよ。で、その完全に縛られたポトペタ成果物って、魅力的なの？公に出たときに競争力あるの？年々、競争力を失っていっていると思うんですよね。それが許される賞味期限はとうに過ぎていて、残っているのはガラクタだけ。</p>
<p>そして、これからは定型的な業務アプリへなら<a href="http://www.microsoft.com/japan/visualstudio/lightswitch">LightSwitch</a>も出てきましたしね(VS2012からは標準搭載で、出力先もSilverlightだけじゃなくHTML5が選べるので実用性高くなったと思う)</p>
<h2>じゃあEF使えばいいの？</h2>
<p>LINQ to SQLは更新されていなくて、今のMSが推してるデータアクセステクノロジはEntityFrameworkだからEF使おう、というと、うーん、私はEntityFrameworkあんま好きくないので、そんなに薦めないかなあ、とか言っちゃったりして。EntityFrameworkの思想に一ミリも魅力を感じないので。LINQ to SQLのほうがまだずっといいよ！更新されてないぢゃん、というならDataSetだって一緒だしさ！なんというか、DataSetといいEFといい、ADO.NETチームってとってもセンス悪いんじゃないか、と思ったり。（ちなみにLINQ to SQLはC#チーム側からの実装だそうで、さもありなん）。あと同じくセンス悪いなーって思うのはEnterprise Libraryとかですね！</p>
<p>ORMは信用ならねえがDataSetはクソだから、もはや生ADO.NETで、つまりDbConnectionからDbCommandでDbReaderで、というので手作業しかねえ！というのはあると思いますが、うーん、手作りはナシね、ナシ。生を生のまま扱うのはアレなので、ちょっとしたユーティリティ、独自マッパーっぽいものは作ると思うのですが、これがねえ。私は以前に、センスのない独自マッパーを使わされていたことがあったのですが、使いにくくて結構な不幸でした。</p>
<p>単純にマッピングする薄い代物だとはいえ、作るにはそれなりなセンスと技量が必要なのです。で、そういうのをMicro-ORMと称しています。生ADO.NETのちょこっとだけ上層にあって主にクエリ結果のマッピングを効率よく行う、程度な代物なので、実質的には生ADO.NETを扱ってると考えてもいいです。現在だと代表的なものに<a href="http://code.google.com/p/dapper-dot-net/">dapper</a>とか、色々と良いものがあるので、それらを選べばいいんじゃないですか。</p>
<p>フルORMにしたって、Microsoft純正以外にも<a href="http://www.mindscapehq.com/products/lightspeed">LightSpeed</a>とか良い選択肢がありますよ。NHibernateはどうかと思いますが。</p>
<p>ORMについてはLightSpeedの作者の語る<a href="http://www.infoq.com/jp/articles/optimizing-orm-performance">ORMのパフォーマンス最適化</a>という記事が良いと思います。特にDataSetからの移行を意識するのならば。LINQ to SQLの成り立ちについては<a href="http://d.hatena.ne.jp/NyaRuRu/20080101/p1">The Origin of LINQ to SQL を訳してみた - NyaRuRuの日記</a>を。</p>
<h2>Micro-ORMによるデータコンテキスト</h2>
<p>Micro-ORMは、当然ながらDataSetやORMが持つ作業単位の保持はないので、そういうのが必要だったら、ある程度は手作業で作りこむ必要はあります。</p>
<p>少し実例を挙げると私が作っているというか作ったものは、データ保存先がDBだけじゃなくてMemcached(キャッシュとしてだけじゃなくデータ保持にも使う)だったりRedis（ListやHashなどのデータ構造を持つKVS）だったりが、それぞれのパフォーマンス的に適していると思える箇所に挟み込まれたデータコンテキストをなしていて、一個のDBだけの世界を構築するORM系はどれも不適切でして。</p>
<p>かといってDapperなどの既存のMicro-ORMも若干、某弊社の事情に合わないところがあるので、自分で作ろうかなあ（上で作るな、と言ってたのに！）とはずっと思ってるところですね。ベースになるMicro-ORMは既にある→<a href="http://dbexecutor.codeplex.com/">DbExecutor - Simple and Lightweight Database Executor</a>のと、拡張のアイディアは沢山あるので、あとは実装時間ががが。</p>
<h2>まとめ</h2>
<p>DataSetは単純に言って古い。言語機能が年々強化されていく中で、2005年の時点でストップしている（しかも2005の時点の言語機能(Nullable)にすら非対応）なものを使うのは、プログラミングにおいて足枷でしかない。7年前ですよ、7年前。あんまり一般化して言うのもアレですが、ﾄﾞﾄﾈﾄの人って浦島太郎な雰囲気ありますよ、キャッチアップが遅すぎるというか枯れてるのが、とかかんとかって。エンタープライズだとどうだとか業務アプリだとどうだとかメンバーのレベルがどうだとか、そんな言い訳ばかりで、すごく格好悪い。</p>
<p>すっごくクールじゃないわけですよ。そんな言説が目立つところに、魅力を感じるのは難しい。せっかくC#や.NETは魅力的なのに。というわけで、私としては、資産がどうだとかこうだとかって言説は吐きたくないし、もっと活力ある感じになればいいな、って思います。2009年の<a href="http://www.atmarkit.co.jp/fdotnet/chushin/opinion_dotnetversion/opinion_dotnetversion.html">現実に最も使える.NETのバージョンはどれ？</a>→.NET 2.0が現時点でベスト、とか凄く絶望的じゃないですか。まあ、えんたーぷらいずの世界ではそれだししょうがないというのならそうなのでしょうが、なるべくそうじゃない世界を作りたい。</p>
<p>そのためにも、新しく、負の遺産を作るのだけはナシです。DataSetに別れを。</p>
</div>
<h1 data-pagefind-sort="date:2012-06-02" data-pagefind-meta="published:2012-06-02"><a href="https://neue.cc/2012/06/02_375.html">控えめなViewStateによるハイパフォーマンスASP.NET Web Forms開発</a></h1>
<ul class="date"><li>2012-06-02</li></ul>
<div class="entry_body"><p>今どきのウェブ開発はMVCだよねー、な昨今を皆様どうお過ごしでしょうか。そんな中であっても、Web Formsでモバイル向けにハイパフォーマンスサイトを作らなきゃいけない時だってあるんです。さて、そんなWeb Fromsですが、とりあえずの敵はViewStateです。ViewStateをどのように活かし、どのように殺害するか、そこに全てがかかっています。幾つかの典型的なシチュエーションを取り出して、ViewStateを抹消していきましょう。</p>
<h2>ViewStateMode = &quot;Disabled&quot;</h2>
<p>下準備として、ViewStateModeをDisabledにします。ViewStateModeは.NET Framework 4から入った新機能で、「ようやく」ViewStateのオン・オフをルート階層から切り替えることが出来るようになりました。それまではEnableViewStateのみで、falseにすると、その階層の下のViewStateが全てオフになってしまうという使いにくいものでした。全部OFFで済ませられるほど世の中は甘くなく、Web Formsでは部分的にONにする必要性があります。ViewStateModeとEnableViewStateの両方が記述されているとEnableViewStateのほうが優先されて害悪となります。というわけで、.NET Framework 4以降ならばViewStateModeのみを使いましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;%@ Master Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;Site1.master.cs&quot; Inherits=&quot;WebApplication3.Site1&quot; %&gt;

&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head runat=&quot;server&quot;&gt;
    &lt;title&gt;ViewState殺害教&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;asp:ContentPlaceHolder ID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot; ViewStateMode=&quot;Disabled&quot;&gt;
    &lt;/asp:ContentPlaceHolder&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>まずは、マスターページのContentPlaceHolderに対して、ViewStateModeをDisabledにしましょう。こうすることで全ページが強制的にデフォでViewStateオフが働きます。また、ページ単位でDisabledにしてしまうと、各Pageの this.ViewState[&quot;hogehoge&quot;] も無効になってしまって不便なので(PageのViewStateは便利なinput hiddenみたいなものですし、闇雲にすべてをオフにせず、便利なものは便利に使うのが大事です)、マスターページのContentPlaceHolderに仕込むのが最良だと私は考えています。</p>
<h2>テキストボックスやドロップダウンリストから値を取り出す</h2>
<p>そんなわけで、ViewStateを丸ごとオフにした状態からデータを取り出してみませう。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;%@ Page Title=&quot;&quot; Language=&quot;C#&quot; MasterPageFile=&quot;~/Site1.Master&quot; AutoEventWireup=&quot;true&quot;
    CodeBehind=&quot;WebForm1.aspx.cs&quot; Inherits=&quot;WebApplication3.WebForm1&quot; %&gt;

&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:TextBox runat=&quot;server&quot; ID=&quot;ToaruTextBox&quot; /&gt;
        &lt;asp:DropDownList runat=&quot;server&quot; ID=&quot;ToaruDropDownList&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; Text=&quot;ただのボタン&quot; OnClick=&quot;Button_Click&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_aiueo.jpg">
</p>
<p>こんなどうでもいい画面があるとして、コードビハインド側は</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruTextBox.ToolTip = &quot;ほげほげ&quot;;
        var items = Enumerable.Range(1, 10)
            .Select(x =&gt; new ListItem
            {
                Text = x + &quot;点&quot;,
                Value = x.ToString(),
                Selected = x == 5
            })
            .ToArray();
        ToaruDropDownList.Items.AddRange(items);
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            Response.Write(&quot;TextBox.Text:&quot; + ToaruTextBox.Text + &quot;&lt;br /&gt;&quot;);
            Response.Write(&quot;TextBox.ToolTip:&quot; + ToaruTextBox.ToolTip + &quot;&lt;br /&gt;&quot;);
            Response.Write(&quot;DropDownList:&quot; + ToaruDropDownList.SelectedValue);
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p>こんな感じとします。ところでどーでもいーんですが、DropDownListに値を突っ込むときはLINQでListItemの配列を作って、それをAddRangeで流し込むほうがDataSourceに入れてDataBindするよりも楽です。というのも、DataBindだとSelectedを指定するのが非常に難しいというか不可能に近いようなので。こういう色々と中途半端なとこがWeb Formsは嫌ですね。</p>
<p>さて、このボタンを押した実行結果は、「TextBox.Text:あいうえお」「TextBox.ToolTip:」「DropDownList:」になります。TextBox.Textは取り出せてるけど、ToolTipは取り出せてない。DropDownListも全滅。つまるところ、ViewStateをオフにしていると、復元できる（イベントで取り出せる）プロパティと、そうでないプロパティがあります。挙動としては、Web Formsが復元出来るものは自動で復元してくれて、復元できないものは復元してくれない、といった感じです。そして、それだと困るわけです。ToolTipはどうでもいいのですが、DropDownListの値とか取れないと困る。ViewStateがオンなら、全部取得できているのに！やっぱりViewStateはオンにしよう！ではなくて、何とかしましょう。</p>
<p>「復元出来るものは自動で復元してくれる」というけれど、その情報はどこにあるのでしょう。これは、別にWeb Formsだからって特殊なわけでもなんでもなく、Request.Formにあります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_formasenum.jpg">
</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public static class NameValueCollectionExtensions
{
    public static IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; AsEnumerable(this NameValueCollection collection)
    {
        return collection.Keys.Cast&lt;string&gt;().Select(x =&gt; new KeyValuePair&lt;string, string&gt;(x, collection[x]));
    }
}
</code></pre>
<p>Button_Clickのところでブレークポイント張って、Request.Formの中身を覗きましょう。AsEnumerableは独自拡張メソッドです。Request.FormはNameValueCollectionというゴミに格納されていて、Keysは見れるけどValuesが見れないというクソ仕様なので、そこはLINQで何とかしましょうというか、これは多用するのでNameValueCollectionへの拡張メソッドとして定義しておくと捗りますというか、ないと死ぬレベル。</p>
<p>そんなわけで、Formに普通に格納されていることが分かりました。そうそう、ViewStateをオフにしてるはずなのに__VIEWSTATEに値が入ってるぞ！とお怒りかもですが、ほんの少し入ってくるのは仕様なので、そこは我慢しましょう。大した量じゃないので。</p>
<p>では、どうすれば値を取得できるのか、というと</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">protected void Button_Click(object sender, EventArgs e)
{
    try
    {
        Response.Write(&quot;TextBox.Text:&quot; + Request.Form[ToaruTextBox.UniqueID] + &quot;&lt;br /&gt;&quot;);
        Response.Write(&quot;DropDownList:&quot; + Request.Form[ToaruDropDownList.UniqueID]);
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>こうです。コントロールのUniqueIDをFormに渡せば良いわけですね。ToolTipとかいうどうでもいいものは取れないので、そういう、HTMLのinputに存在しないものに関しては、PageのViewStateに保存しておけば良いでしょう。私としては、Web Forms使うならinput hiddenよりもthis.ViewState[&quot;hoge&quot;]を使うべきだと思います。せっかくある道具ならば、嫌々ながらも有効活用したほうが良いでしょう。</p>
<h2>リピーターとチェックボックス</h2>
<p>お次は、繰り返しなシチュエーションを考えてみましょう。繰り返しといったらRepeater一択です。それ以外は存在しません。BulletedListすら存在しません。書き出すHTMLを完全にコントロールできるものはRepeater以外存在しません。Web Formsとはなんだったのか。ともかく、Repeaterです。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot;&gt;
            &lt;ItemTemplate&gt;
                &lt;input runat=&quot;server&quot; id=&quot;ToaruCheckBox&quot; type=&quot;checkbox&quot; value=&quot;&lt;%# Container.DataItem %&gt;&quot; /&gt;
                チェック 値:&lt;%# Container.DataItem %&gt;
                &lt;br /&gt;
            &lt;/ItemTemplate&gt;
        &lt;/asp:Repeater&gt;
        &lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruRepeater.DataSource = Enumerable.Range(1, 10);
        DataBind();
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            // CheckされたCheckBoxの値をどう取り出す？
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_repeater.jpg">
</p>
<p>こんな、まあ簡単な画面があるとします。チェックされたCheckBoxの値をどうやって取り出しましょうか？そうそう、ちなみにですがasp:CheckBoxはvalueが指定できないというゴミ仕様なのでやめておきましょう（Web Formsってそんなのばっか、もうやだよ……。ちなみにコード側のInputAttributesで渡すことは一応できます、一応）。</p>
<p>例によってRequest.Formから取り出すことになるので、まずはデバッガで値を見てやります。</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_check.jpg">
</p>
<p>チェックしたチェックボックスの値、ToaruCheckBox,3とToaruCheckBox,8が確認できます。では、どうやって取り出してやろうか。Repeaterの中のコントロールなのでUniqueIDを使うことはできません。ただ、コントロール階層順に$で連結されてる、という法則は見えるわけなので、単純に$でSplitして文字列一致で見てやりましょうか。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">protected void Button_Click(object sender, EventArgs e)
{
    try
    {
        var checkedValues = Request.Form.AsEnumerable()
            .Where(x =&gt; x.Key.Split('$').Last() == &quot;ToaruCheckBox&quot;)
            .Select(x =&gt; x.Value);

        // Checked:3, Checked:8
        foreach (var item in checkedValues)
        {
            Response.Write(&quot;Checked:&quot; + item + &quot;&lt;br /&gt;&quot;);
        }
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>はい、これで完璧です！なお、ASP.NETのID生成ルールはそれなりに変更が聞くので、詳しくは<a href="http://www.amazon.co.jp/gp/product/4822294544/ref=as_li_ss_tl?ie=UTF8&tag=ilsgeometrati-22&linkCode=as2&camp=247&creative=7399&creativeASIN=4822294544">プログラミングMicrosoft ASP.NET 4 (マイクロソフト公式解説書)</a><img src="http://www.assoc-amazon.jp/e/ir?t=ilsgeometrati-22&l=as2&o=9&a=4822294544" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />でも読めばいいでしょう。</p>
<h2>ボタンとCommandArgument</h2>
<p>ボタンはOnClickではなくOnCommandを使うと、CommandArgument(とCommandName)を渡せて便利です。簡単な例としては</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Grape %&gt;&quot; Text=&quot;ぶどう!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Apple %&gt;&quot; Text=&quot;りんご!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Orange %&gt;&quot; Text=&quot;みかん!&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    public enum Fruit
    {
        Grape,
        Apple,
        Orange
    }
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        DataBind();
    }

    protected void Button_Command(object sender, CommandEventArgs e)
    {
        Response.Write(&quot;Clicked:&quot; + (Fruit)int.Parse((string)e.CommandArgument));
    }
}
</code></pre>
<p>注意しなければならないのは、aspx上でCommandArgumentに渡すと文字列になるので、enumを渡すときはintにキャストしておくことと、イベント側のCommandEventArgsに渡ってくるときは文字列なのでintにParseしなければならないこと、です。クソ面倒くさいですね、もう少し気が利いてもいいと思うんですが、まあWeb Formsなのでしょうがないと思っておきましょう。</p>
<p>さて、ViewStateがオンならばこれでいいのですが、オフの場合はe.CommandArgumentは常に空文字列になってしまいます。何故か、というと、CommandArgumentはViewStateに乗ってやってくるからです。さて、どうしましょう、というと、解決策は部分的にオンにすることです。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Grape %&gt;&quot; Text=&quot;ぶどう!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Apple %&gt;&quot; Text=&quot;りんご!&quot; /&gt;
        &lt;asp:Button runat=&quot;server&quot; ViewStateMode=&quot;Enabled&quot; OnCommand=&quot;Button_Command&quot; CommandArgument=&quot;&lt;%# (int)Fruit.Orange %&gt;&quot; Text=&quot;みかん!&quot; /&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p>ButtonのViewStateModeだけを&quot;Enabled&quot;にすることで、最小限のViewStateで最大限の成果を発揮することができます。ViewStateを嫌うならば、そもそもCommandなんて使わない！になるでしょうけれど、そこまでやってしまうと勿体ない。縁あってWeb Formsを使うわけなのですから、「控えめに」「隠し味」として、ViewStateを有効活用していきましょう。</p>
<h2>リピーターとボタン</h2>
<p>最後に、リピーターの中にボタンが仕込まれているパターンを見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
        &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot; ViewStateMode=&quot;Enabled&quot;&gt;
            &lt;ItemTemplate&gt;
                &lt;%# Container.DataItem %&gt;:&lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん！&quot; /&gt;&lt;br /&gt;
            &lt;/ItemTemplate&gt;
        &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">public partial class WebForm1 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (IsPostBack) return;

        ToaruRepeater.DataSource = Enumerable.Range(1, 10).Select(x =&gt; new string(Enumerable.Repeat('a', 10000).ToArray()));
        DataBind();
    }

    protected void Button_Click(object sender, EventArgs e)
    {
        try
        {
            Response.Write(&quot;Clicked!&quot;);
            Response.End();
        }
        catch (System.Threading.ThreadAbortException) { }
    }
}
</code></pre>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/webforms_aaa.jpg">
</p>
<p>a(x100000):ボタン という表示結果が得られます。ボタンをクリックするとClicked!と実行されて欲しいわけですが、ViewStateがオフだとうんともすんとも言いません。何故か、というと、イベントの選択もまたViewStateに乗ってくるからです。解決策はRepeaterのViewStateModeをEnabledにすること、です。</p>
<p>しかし、単純にRepeaterのViewStateModeをEnabledにしただけだと、それ以下の全てのViewStateがオンになってしまいます。どういうことかというと、ViewStateを見てみると、この場合の結果は「133656文字」もあります！どれだけデカいんだよ！なぜかというとaaaaaa...(x10000) x 10がViewStateに乗っかってしまったからです。ただたんにボタンクリックできればいいだけなのに！じゃあ、どうするか、というと、ViewStateのオンオフを入れ子にしてRepeaterだけをオンにします。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;asp:Content ContentPlaceHolderID=&quot;BodyPlaceHolder&quot; runat=&quot;server&quot;&gt;
    &lt;form runat=&quot;server&quot;&gt;
    &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;ToaruRepeater&quot; ViewStateMode=&quot;Enabled&quot;&gt;
        &lt;ItemTemplate&gt;
            &lt;asp:PlaceHolder runat=&quot;server&quot; ViewStateMode=&quot;Disabled&quot;&gt;
                &lt;%# Container.DataItem %&gt;:&lt;asp:Button runat=&quot;server&quot; OnClick=&quot;Button_Click&quot; Text=&quot;ぼたん！&quot; /&gt;&lt;br /&gt;
            &lt;/asp:PlaceHolder&gt;
        &lt;/ItemTemplate&gt;
    &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/asp:Content&gt;
</code></pre>
<p>これで解決。クソ面倒くさくて回りっくどくてイライラしますが、&quot;そういうもの&quot;だと思うしかないです。</p>
<h2>Web Formsの良さをスポイルしてまでWeb Forms使いたい？</h2>
<p>使いたくないです。それでもやらなきゃいけない時はあるんですDataSet死ね。</p>
<h2>(ところで関係なく)async event</h2>
<p><a href="http://www.microsoft.com/visualstudio/11/ja-jp">Visual Studio 2012 RC</a>出ました！<a href="http://neue.cc/2012/03/18_368.html">neue cc - Visual Studio 11の非同期(”C#, ASP.NET, Web Forms, MVC”)</a>で非同期系について特集しましたが、Web FormsではRegisterAsyncTask(new PageAsyncTask)しなきゃならなくて面倒くさい死ねという感じでしたが、ようやくイベントにasyncをつけるだけでよくなりました！</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">protected async void Button_Click(object sender, EventArgs e)
{
    await Task.Delay(TimeSpan.FromSeconds(3));
    try
    {
        Response.Write(&quot;hoge&quot;);
        Response.End();
    }
    catch (System.Threading.ThreadAbortException) { }
}
</code></pre>
<p>正式リリース前に対応してくれて本当に良かった。これでWeb Formsでももう少し戦える……、戦いたくないけど。</p>
<h2>まとめ</h2>
<p>世の中には<a href="http://en.wikipedia.org/wiki/Unobtrusive_JavaScript">Unobtrusive JavaScript</a>という言葉がありますが、そのように、私としてもUnobtrusive ViewStateを唱えたい。控えめに。とにかく控えめに。ほとんどないも同然なぐらいに。隠し味として使うのが、一番良いわけです。今までのWeb Formsはデフォルトオンで化学調味料をドバドバと投げ込んでいました。そんなものは食えたものじゃあありません。化学調味料を使うなら、超絶控えめに、ほんの少しでいいんです。そうすれば、革命的に美味しくなるのですから。それが正しい化学調味料の使い方。</p>
<p>そして、理想を言えば化学調味料はゼロがいいんですけれどね。ゼロにしたければWeb Formsはやめましょう。それ以外の答えはない。Web Formsを使う以上は正しく向き合うことが大事。</p>
<p>ViewStateをドバドバ使うことがWeb Formsの良さだというのも半分は事実ですが、半分はNOですね。ていうか馬鹿でしょ。そういう発想に未来はないし脳みそイカれてると思いますよ。DataSetを褒め称えていた狂った時代の発想なので、腐った部位はとっとと切り落としましょう。</p>
<p>さて、そうして控えめにしたWeb Formsですけれど、これはこれでそれなりに良いとは思います。最小限にしたとしても、依然としてパーツ配置してOnClickでほいほい、という楽ちんさは健在ですし、カスタムコントロールによるモジュール化というのは悪くない。絶賛はしませんが、悪くないとは思います、そこまで悪しざまにいうものでもない。でも、まあ、もはや時代じゃあないでしょうね。もう、さようなら。</p>
<p>と、まあ割とキツめにWeb Forms(やDataSet)にあたるのは日々苦しめられているからなので、罵詈雑言多いのは勘弁してね！別に現状がダメでも未来に良くなるとかならいいんですが、明らかに未来がないので、なんというかもうねえ、という。Web Formsも、これはこれで面白い仕組みだし、まっとうに進む道もあったとは思うんですが、舵取りにしくったと思います。結果的にこの閉塞感漂う現状と、明らかにリソース割かれてない感があるので、未来はないですね、残念ながら。しかし、最後の徒花としてやれるだけはやるのさぁ。</p>
</div>
<h1 data-pagefind-sort="date:2012-05-29" data-pagefind-meta="published:2012-05-29"><a href="https://neue.cc/2012/05/29_374.html">配列とGetEnumetorのお話</a></h1>
<ul class="date"><li>2012-05-29</li></ul>
<div class="entry_body"><p>LINQ書いていますか？<a href="http://rikunabi-next.yahoo.co.jp/tech/docs/ct_s03600.jsp?p=002219">LINQでデータベース活用</a>とか見出しにありますが、データベース活用といいつつ、その内実は100% LINQ to Objectsです。じゃあデータベースに何で問い合わせやってるの？というと（禁則事項です）。さて、そんなわけで毎日LINQ書いているわけですが、それとは全く関係なく、配列が結構困ったちゃん。例えば以下のような、配列を包んだコレクションを提供したいとします。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class WrappedCollection&lt;T&gt;
{
    T[] source;

    public WrappedCollection(T[] innerSource)
    {
        this.source = innerSource;
    }
}
</code></pre>
<p>で、T[]なsourceを元にメソッドを幾つか提供する、と。それ自体はないこともないと思われます。さて、Collectionを名乗っているので、IEnumerable&lt;T&gt;であってほしいですよね？</p>
<p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/wrappedcollection_error.jpg">
</p>
<p>なぜだ、って、配列のGetEnumeratorの戻り値はIEnumeratorなのです。IEnumerator&lt;T&gt;ではなくて。マジで！マジで。さて、どうしようかしら、と。foreach(var item in source) yield return item; をすれば解決ですが、そんなダサいことはやりたくない。正解は、AsEnumerableです。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class WrappedCollection&lt;T&gt; : IEnumerable&lt;T&gt;
{
    T[] source;

    public WrappedCollection(T[] innerSource)
    {
        this.source = innerSource;
    }

    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        return source.AsEnumerable().GetEnumerator();
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
</code></pre>
<p>これだけで解決。やったね、AsEnumerableは偉大で奥深いなあ。さて、以前に<a href="http://neue.cc/2011/07/27_335.html">Deep Dive AsEnumerable</a>で書きましたが、AsEnumerableの実態はただのキャストなので</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">return ((IEnumerable&lt;T&gt;)source).GetEnumerator();
</code></pre>
<p>でもOKです。</p>
<p>さて、それらの中身ですが</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var source = Enumerable.Range(1, 10).ToArray();

var e1 = source.GetEnumerator();
var e2 = source.AsEnumerable().GetEnumerator();

// System.Array+SZArrayEnumerator
Console.WriteLine(e1.GetType());
// System.SZArrayHelper+SZGenericArrayEnumerator`1[System.Int32]
Console.WriteLine(e2.GetType());
</code></pre>
<p>といった具合に、型が違うと渡ってくるEnumeratorも違うようですね。これ自体は別にスペシャルな機能ではなく<a href="http://msdn.microsoft.com/ja-jp/library/ms173157.aspx">明示的なインターフェイスの実装</a>をした時の挙動、ではありますが、まあ配列周りはそもそもに色々とややこしいですからね。私みたいなゆとりなんて、SZって何だよクソが(single-dimension zero-baseの意味だそうで)とか思ってしまいます。</p>
<h2>まとめ</h2>
<p>IEnumerable&lt;T&gt;じゃないコレクションは逝ってよし。つまりMatchCollectionは何で.NET 4.5になっても手を加えてくれないんだよぅううううぅぅぅ。</p>
</div>
<h1 data-pagefind-sort="date:2012-05-13" data-pagefind-meta="published:2012-05-13"><a href="https://neue.cc/2012/05/13_373.html">XboxInfoTwit - ver.2.4.0.3</a></h1>
<ul class="date"><li>2012-05-13</li></ul>
<div class="entry_body"><ul>
<li><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">neue cc - XboxInfoTwit</a></li>
</ul>
<p>Xbox.comが内部的にちょっと変わっていて動かなくなっていたので、それに対応しました。前々から報告されている不具合などに関する修正などは一切入ってません、すみません。最近割と普通に忙しくて全く手をかけられない状態でして……。落ち着いたらその時には必ず。</p>
</div>
<h1 data-pagefind-sort="date:2012-04-30" data-pagefind-meta="published:2012-04-30"><a href="https://neue.cc/2012/04/30_372.html">MetroStyleDeveloper #03の告知</a></h1>
<ul class="date"><li>2012-04-30</li></ul>
<div class="entry_body"><p>最近は告知ばかりで、まともにブログ記事書いてなくてすみませんすみません。Windows Developer Daysでのセッションはお陰様で立ち見が出るほどに大盛況で、うれしかったです。資料に関しては、公開できるように調整中です（いちおー会社身分で出てるので、公開するときは会社サイトのほうになるかしら、と思っています）。中々面白い感じに仕上がっているので、なるべく早いうちに出したいところです。</p>
<p>さて、WDDのキーノートで <a href="http://gloops.com/news/2012/04/425microsoft-windows-developer-days-windows8.html">4月25日に開催されたMicrosoft Windows Developer Days にて、Windows8ベースで開発したグループスの試作アプリが発表されました</a> ということで、シアトルクエストという試作アプリが公開されました。その詳細を、5/12に開催される<a href="http://metrostyledev.net/index.php/event/20120512/">MetroStyleDeveloper #03</a>で発表します！（予定）。会場、弊社ですお。</p>
<p>というわけで、気になった方はそちらも是非是非来ていただけたらと思います。</p>
</div>
<h1 data-pagefind-sort="date:2012-04-17" data-pagefind-meta="published:2012-04-17"><a href="https://neue.cc/2012/04/17_371.html">Windows Developer Daysで登壇します</a></h1>
<ul class="date"><li>2012-04-17</li></ul>
<div class="entry_body"><p>4/24-25に開催される<a href="http://www.microsoft.com/ja-jp/events/wdd/program.aspx">Microsoft Windows Developer Days</a>で登壇します。<a href="https://www.event-marketing.jp/events/wdd/Register/Session.aspx">セッション一覧</a>より、Day 2の11:30-13:00、Room Fでタイトルは「LINQ to Everything : データソース・言語を超える LINQ の未来」です。</p>
<p>これなのですが、私の勤め先の<a href="http://gloops.com/">gloops</a>がWDDのプラチナスポンサーで、そのスポンサー用のセッション枠を私が頂いた、みたいな形です。スポンサー枠なのに完全に趣味のLINQの話しかしない気満々とか非常にアレ。そんなわけなので是非来てください。ランチセッションなのでお昼も出るので、ご飯食べながらゆるゆると聞いてもらえればと思ってます。</p>
<p>弊社からは、他にSQL Azure MVPの大和屋さんが<a href="http://sqlazure.jp/b/sqlazure/1079/">gloops提供人気ソーシャルゲームでトラフィック限界に挑戦！SQL Azure Federation検証結果公開</a>というタイトルで4/24に出ますので、そちらも是非是非どうぞ。</p>
</div>
<h1 data-pagefind-sort="date:2012-04-02" data-pagefind-meta="published:2012-04-02"><a href="https://neue.cc/2012/04/02_370.html">Microsoft MVP for Visual C#を再受賞しました</a></h1>
<ul class="date"><li>2012-04-02</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2011/04/02_313.html">去年の報告</a>から一年、再受賞することができました。活動はあまり変わらずC#とLINQについてブログに書いて、小さめのライブラリを作って公開して、それと今回は少し、外での活動が増えましたね。つい一昨日もSilverlightを囲む会で<a href="http://www.slideshare.net/neuecc/reactive-extensions-v20">Reactive Extensions v2.0</a>としてお話しました。</p>
<p>日本の海外に比べて弱いところ、先端的な技術の紹介であったりディープに踏み込んだ使い方であったり、何かを作って公開することであったり。それらを埋めていきたいな、と思っています。そういったことを通してC#の良さを伝えられていければ何よりです。</p>
<h2>近況</h2>
<p>さて、しかし色々何かと停滞中です……。ライブラリは更新していない、ツールもバグ報告スルー中、Pull Requestすら放置、原稿……、などなどなどなど。はい、どうみてもダメ人間です。やりたいこと、はいっぱいあって、やらなければならないこと、もそれなりにあって、それらがかちあってどっちも出来ず仕舞いで時間を浪費してばかり。今年はその辺もしっかり整理して、より多くの何かを届けていきたいところです。実際のとこダラダラTwitterやってる時間が一番長くてマズいのは確定的に明らか。Twitterやってる時間をSkyrimに回したほうがよっぽど有意義ってものですよ！しかもなんと超絶楽しみにしていたSkyrimは未だ未開封という、もうアレ。悲しいですね。</p>
</div>
<h1 data-pagefind-sort="date:2012-03-28" data-pagefind-meta="published:2012-03-28"><a href="https://neue.cc/2012/03/28_369.html">ソーシャルゲームとわたくし</a></h1>
<ul class="date"><li>2012-03-28</li></ul>
<div class="entry_body"><p>最近のWeb業界の風潮にならって、ちゃんとロクロ回しました！</p>
<ul>
<li><a href="http://rikunabi-next.yahoo.co.jp/tech/docs/ct_s03600.jsp?p=002099">gloopsがWindows環境でソーシャルゲームをつくる理由｜【Tech総研】</a></li>
</ul>
<p>猫も杓子もみんなソーシャルゲーム業界に行くんだなあ、とかﾎﾟｹｰｯと眺めていましたが、まさか私も行くとは全然思ってもいませんでした。というわけで、1月から転職したと書きましたけれど、<a href="http://gloops.com/">株式会社gloops</a>で働いています。転職理由とかは、インタビューの通りです。C#を世間（といっても、技術系の人に、ですね）に強くアピールするにはどうすればいいのか、といったら、一番大事なのはそれで書かれたメジャーなアプリケーションなのです。PerlではてなやMixi、livedoorなどを思い浮かべる、RubyでCookpadを、ScalaでFoursquareやTwitterを、そういった憧れにも似た気持ちを浮かべさせるようなアプリケーションがなければいけなくて。</p>
<p><a href="http://stackoverflow.com/">Stack Overflow</a>はC#, ASP.NET MVCだし、<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">TIOBEのプログラミング言語ランキング</a>では三位など、海外でのC#の地位は十分に高い。のですが、国内ではそれと比べれば全くもってない。日本で誰もが知る会社の誰もが知るアプリケーション、それがC#で書かれている。そういう状態にならなければ、日本で強く普及は無理だな、と。</p>
<p>ギョーム系アプリでは十分に強いじゃん、とかそうじゃなくて、私としてはもっと学生とかも憧れてガンガン使う感じであって欲しいんですよ。Visual Studioは無料版ありますし、学生向けの支援(<a href="http://msdn.microsoft.com/ja-jp/academic/hh455217">DreamSpark</a>など)もやってはいますが、あまりリーチできてないのではないかなあ、って。そういうのって内からやりたいって気持ちが湧いてきて初めて支援があって嬉しい！になるわけで。</p>
<p>まあその領域だったら、やっぱゲームですよゲーム！なんというか、Unityブームのほうがずっと請求してるかもなのですかねー。というわけで<a href="http://atnd.org/events/26442">第77回codeseek勉強会＆第17回日本C#ユーザー会 勉強会 : C#とゲーム</a>では、C#とゲーム全般を取り扱って、そのなかで弊社CTOの池田もソーシャルゲーム枠でセッション持ちますので、残席まだありますので是非是非どうぞ（宣伝）</p>
<p>ゲームもいいのですが、デスクトップアプリケーションもいいし（最近はあんまし流行らないですって？そうかもですがー）、モバイルアプリもいいし（Windows Phone 7よりも、MonoTouchやMono for Androidのほうが受けますな）、そして、ウェブアプリもいい。C#の持つ強みや範囲というのは、本当に、もっともっと知られて欲しいなって。</p>
<p>そんなようなことは入社初日にも言ったりなどしていて、今も当然変わってませんし、3ヶ月働いてきて、実現できる会社であると実感しています。<a href="http://event.yomiuri.co.jp/mlb/">2012 グループス MLB開幕戦</a>の冠協賛や、最近はCMも増えてきたりなど、露出も増えてきて、勢いありますね。その勢いを止めない、加速させるためにも、まだまだ人が必要というわけで、求人バナーもかなり見かけてるんじゃないかと思います。というわけで弊社ではエンジニアを絶賛募集中なのでC#で書きたい！という人は是非是非お願いします（宣伝）</p>
<p>あと、私自身の目的としてはもう一つあって、日本ローカルだけじゃなく世界にも通用する技術力を掲示したいという欲求があります。その面でも、世界に向けても前進している(<a href="http://game.watch.impress.co.jp/docs/interview/20120323_520639.html">gloops International CEO冨田由紀治氏インタビュー - GAME Watch</a>)のは、マッチしていました。とはいえ、まずは日本、です。そもそも全然半人前だと痛感する毎日で寝言は寝てから言え状態なので、日々鍛錬ですね。</p>
<h2>ソーシャルゲーム</h2>
<p>このサイトの前身はゲーム攻略サイト(Xbox系)で、2002年からです（このサイトのアレゲな配色はその頃から全く変わってないから、というのが大きな理由です）。また、特に好きな<a href="http://www.nicovideo.jp/watch/sm221184">Geometry Wars</a>なんて世界ランキングでもかなり上位だったりニコ動にプレイ動画を投稿したりする程度には、一応そこそこハードなゲーマーを自称していたのですが、最近はめっきりゲームとは遠ざかってしまいました。あうあう。完全にプログラミング系サイトですしねー。</p>
<p>というわけで、元ゲーマーとでもしませうか。で、ソーシャルゲーム。ゲーマーといったらソーシャルゲームは割と忌み嫌うという感じの！ふむ。まあでも、ほら、最近はアイドルマスター シンデレラガールズが（色々な意味で）話題だったり、それはそれで独特に面白さってのはあるんですね。いや、モゲマス面白いですよ、ガチャ地獄とか除いても普通に。必ず人と繋がり合う（それが衣装泥棒であっても）、それも緩やかに非同期に（MMORPGや対戦系は同期的ですから）というのは、独特なものがあると思います。</p>
<p>正直いって、まだ完全に面白さには繋がってないとは思いますが（特にゲーマー向けには）、このシンプルで非常に限られた中からゲーム性（と○○）を引き出すチャンスは転がっている、かもしれません。ずっとガラケー向けに貧相な画面とボタン連打だけで変わらない、わけでは、ない。スマートフォンの時代は来ているし、HTML5の流れだってあるし、それはソーシャルゲームだって同じなのです。</p>
<p>フロントエンドはモバイル向けというのを考慮しながらもリッチしなければならないし、バックエンドはハイパフォーマンスに耐えなければならない。課題は大量にありますが、だからこそ技術者としては挑戦しがいのある面白いテーマが山のように転がっています。例えばC# 5.0が非同期でハイパフォーマンスといったって、別にそんなのそこまで必要じゃないしなー、で終わってしまう状況もいっぱいあると思うのです。でも、弊社では、今すぐにでも必要なのだというぐらいに切羽詰ってる。C#の能力をフルに使いきることが求められる。これは楽しいですね？はい、楽しいです。</p>
<h2>会社員ですからー</h2>
<p>インタビュー記事が求人記事なので、会社員として宣伝しました！なので基本的にイイ事しか言いませんが、勿論イクナイ面もそれなりにあります。例えば最近の私の記事を見ると某テクノロジーをやたらDisってますが、なんでなんでしょうかねー、ふふり。とはいえ、不満に思うなら自分でぶち壊して再構築すればいいし、それが許される（勿論ちゃんと能力を証明したうえで）環境だとは思います。スキルある人が何の制約もなく存分に腕をふるえるのなら、素敵な話ではないでしょうか。</p>
<p>ちなみに私のスキルはC#/LINQに偏っていてウェブとかASP.NETの知識は並なので、毎日勉強です、人はそれを付け焼刃とも言う。</p>
</div>
<h1 data-pagefind-sort="date:2012-03-18" data-pagefind-meta="published:2012-03-18"><a href="https://neue.cc/2012/03/18_368.html">Visual Studio 11の非同期("C#, ASP.NET, Web Forms, MVC")</a></h1>
<ul class="date"><li>2012-03-18</li></ul>
<div class="entry_body"><p>世の中ひどぅーきひどぅーきと騒ぐばかりで、猫も杓子もNode.js。でもですね、<a href="http://codezine.jp/article/detail/6461">【デブサミ2012】16-A-5 レポート　ソーシャルアプリケーションにおけるNode.jsの活かし方（1/2）：CodeZine</a>なんかを見ても、そこで独自に作りこんでる例外処理だの非同期フロー管理だのは、そりゃあ必要ですよね、まずはそこから始めるのは当然ですよね、と思いつつC#は最初から備えているんですよね。むしろ色々とC#のほうが、とか思ったりするわけですが（勿論Node.jsのほうがGoodなものもありますが）、こんなところで嘆いていても始まらないのでC#流の非同期の活かし方を見ていきましょうか。</p>
<h2>HttpTaskAsyncHandler</h2>
<p>ASP.NETの非同期ハンドラはIHttpAsyncHandlerなわけですが、VS11ではそれをTask(つまりC# 5.0 async/await)で扱いやすくした基底クラス、<a href="http://msdn.microsoft.com/ja-jp/library/system.web.httptaskasynchandler(v=vs.110).aspx">HttpTaskAsyncHandler</a>が用意されています。例えばTwitterの検索を叩いて返すだけどのものは以下のようになります。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class TwitterSearchHandler : HttpTaskAsyncHandler
{
    public async override Task ProcessRequestAsync(HttpContext context)
    {
        var term = context.Request.QueryString[&quot;q&quot;];
        var json = await new HttpClient().GetStringAsync(&quot;http://search.twitter.com/search.json?q=&quot; + term);

        context.Response.ContentType = &quot;application/json&quot;;
        context.Response.Write(json);
    }
}
</code></pre>
<p>普通と違うのはasyncとawaitだけなので、特に混乱もなく同期→非同期に乗り換えられると思います。非常に簡単。</p>
<p><a href="http://msdn.microsoft.com/ja-jp/library/system.net.http.httpclient(v=vs.110).aspx">HttpClient</a>も.NET 4.5からの新顔で、WebClientの後継的な位置付けでしょうか。細かいコントロールも可能で、かつ、WebRequestよりも簡単で、非同期にもきっちりマッチしている。というかHttpClientには同期的なメソッドは用意されていません。これからの非同期世代に完全準拠した新しいクラスということですね。</p>
<p>そして、テスト用のサーバー立てるのも非常に簡単で。Visual Studioで新規で空のASP.NETサイトプロジェクトを作って、↑のハンドラ足して、Ctrl + F5すればIIS Expressが立ち上がって、もうそれだけでOKなわけですよ。超簡単なわけですよ、マジでマジで。</p>
<p>こないだ、<a href="http://atnd.org/events/24951">RIA アーキテクチャー研究会　第3回</a>でのセッションではそうして作ったHttpTaskAsyncHandlerで、 context.Response.StatusCode = 404 にしてエラーを返した状態を再現したりしながらデモしていました。</p>
<div style="width:595px" id="__ss_11947538"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/neuecc/asynchronous-rx-andtask" title="C#次世代非同期処理概観 - Task vs Reactive Extensions" target="_blank">C#次世代非同期処理概観 - Task vs Reactive Extensions</a></strong> <iframe src="https://www.slideshare.net/slideshow/embed_code/11947538?rel=0" width="595" height="497" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/neuecc" target="_blank">neuecc</a> </div> </div>
<p>今回はTaskを中心にしましたが、Rxを中心にしたものを<a href="http://silverlightsquare.com/index.php/tokyo06.html">Silverlightを囲む会in東京#6</a>で3/31に話す予定なので、まだ募集中なので是非来て下さい。また、Rx v2.0に関しては<a href="http://blogs.msdn.com/b/rxteam/archive/2012/03/12/reactive-extensions-v2-0-beta-available-now.aspx">Reactive Extensions v2.0 Beta available now! - Reactive Extensions Team Blog - Site Home - MSDN Blogs</a>で超詳細に書かれていますね。私もちょいちょいと書きたいことは溜まってるのですが中々にぐぬぬぬ。</p>
<h2>非同期ページ</h2>
<p>今更Web Formsとか超どうでもいいって感じが世界全体に漂ってるし真面目に色々と腐ってると本気で思うしDataSetとWeb Formsは今となっては.NET三大汚点の筆頭かなとか思ったり思わなかったり適当に言ったり呪詛を吐いたり、もう色々アレなのですが、それでも現実とは戦わなければならないのです！</p>
<p>というわけでVS11のASP.NET Web Formsの非同期の強化でも見てみましょう。C# 5.0でasync/awaitが入るのでASP.NET MVCのほうは非同期コントローラーでﾋｬｯﾎｲなのですがWeb Formsも一応対応してきました、一応ね、一応。</p>
<pre data-pagefind-ignore="all"><code class="language-xml">// Web.config
&lt;appSettings&gt;
  &lt;add key=&quot;aspnet:UseTaskFriendlySynchronizationContext&quot; value=&quot;true&quot; /&gt;
&lt;/appSettings&gt; 
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;~/WebForm1.aspx.cs&quot; Inherits=&quot;WebApplication8.WebForm1&quot;
　　　　Async=&quot;true&quot; ViewStateMode=&quot;Disabled&quot; %&gt;

&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head runat=&quot;server&quot;&gt;
    &lt;title&gt;Async Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
    &lt;asp:TextBox ID=&quot;WordTextBox&quot; runat=&quot;server&quot; /&gt;
    &lt;asp:Button ID=&quot;SearchButton&quot; runat=&quot;server&quot; Text=&quot;Button&quot; OnClick=&quot;SearchButton_Click&quot; /&gt;
    &lt;asp:Repeater runat=&quot;server&quot; ID=&quot;TwitterStatuses&quot; ItemType=&quot;dynamic&quot;&gt;
        &lt;ItemTemplate&gt;
            &lt;p&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.from_user %&gt;&quot; /&gt;&lt;br /&gt;
                &lt;asp:Label runat=&quot;server&quot; Text=&quot;&lt;%#: Item.text %&gt;&quot; /&gt;
            &lt;/p&gt;
        &lt;/ItemTemplate&gt;
    &lt;/asp:Repeater&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-csharp">// namespace WebApplication8
public partial class WebForm1 : System.Web.UI.Page
{
    protected void SearchButton_Click(object sender, EventArgs e)
    {
        var task = new PageAsyncTask(async () =&gt;
        {
            var word = WordTextBox.Text;
            using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
            {
                var json = System.Json.JsonObject.Load(stream);
                TwitterStatuses.DataSource = json[&quot;results&quot;];
            }
            DataBind();
        });

        RegisterAsyncTask(task);
    }
}
</code></pre>
<p>非同期ページの利用には Async=&quot;true&quot; 属性をつける必要があります。.NET 4.0まではつけていない場合は、同期的に動作するようになっていたのですが、.NET 4.5からはエラーになるように挙動が変更されています。また、PageAsyncTaskを利用する場合はWeb.configにUseTaskFriendlySynchronizationContext = true する必要もあるっぽいです。</p>
<p>これ自体はテキストボックスに検索語を入れてボタンを押すとひどぅーきでTwitter検索して表示する、というだけのDoudemoii代物です。PageAsyncTaskが引数にTaskを受け入れるようになったので、そこでasyncなラムダ式を突っ込んでやればいい、というわけで、まあまあ簡単と言えなくもなく仕上がっています。理想的には/直感的にはasync void SearchButton_Clickと書けるようになるべきなのですが、そうはいかないようです、残念。</p>
<p>JSONは.NET 4.5からお目見えの<a href="http://msdn.microsoft.com/ja-jp/library/system.json(v=vs.110).aspx">System.Json</a>を使いました。これ、AsDynamic()とするとdynamicで扱えるのでサクサクッと使えて便利です。また、そのdynamicとして使える性質を活かして、dynamicのままバインドしてみました(AsDynamicはコード上dynamicにキャストするというだけで、JsonValueはそのもの自身がdynamic = IDynamicMetaObjectProviderなのです)。System.Jsonは<a href="http://nuget.org/packages/System.Json">NuGet - System.Json</a>にもあるので、.NET 4ではそれを使えばいいでしょう。<a href="http://dynamicjson.codeplex.com/">DynamicJson</a>はお払い箱で。</p>
<p>それとRepeaterのItemType=&quot;dynamic&quot;。これでItem.from_userといったように、dynamicに使えるようになっています。匿名型をバインドしたい時なんかも、同じようにItemType=&quot;dynamic&quot;にしてしまうといいかな、と思ったんですが、それは出来ませんでした。あともう一歩、気を利かせてくれても良かったですねえ。</p>
<p>まあ、VS11からは、念願のバインディング式の中でIntelliSenseが効くようになっていて、それはRepeaterのItemTypeも例外ではないので、ちゃんと型作ってあげるのも良いとは思います。あと%:でHtmlEncodeもしてくれますのも良いところ。</p>
<p>ViewStateMode=&quot;Disabled&quot;で無駄なViewStateは生成しないようにするのも大事。これは.NET 4.0からですね。EnableViewStateとは別物という紛らわしさが残っているのも、まあなんともかんとも。ところでPageのViewStateModeをDisableにしてしまうと、this.ViewState[]が使えなくなってしまうので、マスターページからの、asp:Contentにしかけたほうがいいかもです。</p>
<h2>EventHandlerTaskAsyncHelper</h2>
<p>ASP.NETの非同期関連はMSDNマガジンの<a href="http://msdn.microsoft.com/ja-jp/magazine/cc163463.aspx">WickedCode: ASP.NET の非同期プログラミングを使ったスケール変換可能なアプリケーション</a>にまとまっていますが、そこにあるとおり非同期ページの実現方法にはもうひとつ、AddOnPreRenderCompleteAsyncを使う方法があります。それにもTask用のやり方がありますので、見てみましょう。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">var helper = new EventHandlerTaskAsyncHelper(async (_, __) =&gt;
{
    var word = WordTextBox.Text;
    using (var stream = await new HttpClient().GetStreamAsync(&quot;http://search.twitter.com/search.json?q=&quot; + word))
    {
        var json = System.Json.JsonObject.Load(stream);
        TwitterStatuses.DataSource = json[&quot;results&quot;];
    }
    DataBind();
});

AddOnPreRenderCompleteAsync(helper.BeginEventHandler, helper.EndEventHandler);
</code></pre>
<p>EventHandlerTaskAsyncHelperを作り、それのBeginとEndをAddOnPreRenderCompleteAsyncに渡してあげます。ちょっとPageAsyncTaskより面倒ですね。まあ、でも、どちらでもいいでしょう。大した違いはありません。二つやり方があるとどちらにすればいいのかと迷ってしまうのが良くないところなんですよねえ、しかもどちらも似たようなものだと……。</p>
<h2>非同期モジュール</h2>
<p>Moduleについても見てみましょう。感覚的にはAddOnPreRenderCompleteAsyncと一緒で、EventHandlerTaskAsyncHelperを作り、追加したいイベントにBeginとEndを渡します。</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class MyModule : IHttpModule
{
    public void Init(HttpApplication application)
    {
        var helper = new EventHandlerTaskAsyncHelper(async (sender, e) =&gt;
        {
            var app = (HttpApplication)sender;
            var path = app.Server.MapPath(&quot;~/log.txt&quot;);

            using (var fs = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.Read, 4096, useAsync: true))
            using (var sw = new StreamWriter(fs, Encoding.UTF8))
            {
                await sw.WriteLineAsync(&quot;Request:&quot; + DateTime.Now);
            }
        });

        application.AddOnBeginRequestAsync(helper.BeginEventHandler, helper.EndEventHandler);
    }

    public void Dispose() { }
}
</code></pre>
<p>AddOnXxxAsyncは沢山あるので、追加したいイベントを選べばいいでしょう。また、非同期でファイルを扱いたい時は、useAsync: trueにするのが大事です。デフォルトはfalseになっているので、Begin-Endをしても非同期にならない（というかスレッドプールを使った挙動になってしまう）そうです（と、プログラミング.NET Frameworkに書いてあった）。</p>
<h2>非同期コントローラー</h2>
<p>一応ASP.NET MVCでも見てみましょうか。TwitterのPublicTimelineを表示するだけのものを（テキストボックスすら作るのが面倒になってきた）</p>
<pre data-pagefind-ignore="all"><code class="language-csharp">public class PublicTimelineController : AsyncController
{
    public async Task&lt;ActionResult&gt; Index()
    {
        using (var stream = await new HttpClient().GetStreamAsync(&quot;https://twitter.com/statuses/public_timeline.json&quot;))
        {
            var json = System.Json.JsonObject.Load(stream);
            return View(json);
        }
    }
}
</code></pre>
<pre data-pagefind-ignore="all"><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    @foreach (var item in Model)
    {
        &lt;p&gt;
            @item.user.screen_name
            &lt;br /&gt;
            @item.text
        &lt;/p&gt;
    }
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>AsyncControllerの自然さと、きゃーRazor最高ー抱いてー。</p>
<h2>まとめ</h2>
<p>HttpTaskAsyncHandlerにせよEventHandlerTaskAsyncHelperにせよ、中身は割とシンプルにTaskでラップしただけなので、それを自前で用意すればTask自体は.NET 4.0に存在するので、async/awaitは使えませんがそれなりに簡単に書けるようにはなります。とりあえず私はWeb Forms用のものを仕事で使うために用意しました。コードは会社で書いたものなので上げられませんが！というほど大したものでもないので上げちゃってもいいんですが上げません！Web Formsにはとっととお亡くなりになってもらいたいので。延命措置禁止。</p>
<p>Web Formsだって悪くないものだ、全力で頑張ればほら、こんなに出来るじゃないか、ということは容易い、ことはまったくなく全力なわけですが、しかし可能ではあるんですね、モバイル対応だろうがハイパフォーマンスサイトだろうが。きっとたぶん。でもね、なんかもうIE6にも対応しつつHTML5サイトです、とかやるぐらいに不毛感漂ってるし、その労力は別のとこに向けたいですよね、っていうか別のとこに向けばどれだけ幸せになれるだろうか、と思ってしまうのです。</p>
<p>考えてみると、こうもうぇぶけーな話を書くのも初めてな気がする。近頃はお仕事がそっち方面なので、出せる範囲でちょいちょい出してこうかと思います。とにかく結論としてはWeb Formsちゃんは、もう沢山頑張ったと思うのでそろそろ逝ってもらって構いません。</p>
</div>
<a href="https://neue.cc/13">Prev |</a>
<a href="https://neue.cc/15">| Next</a>
</div>
        <div id="side" data-pagefind-ignore="all">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(.NET)<br />
April 2011<br />
|<br />
July 2025<br />
<br />
X:<a href="https://x.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2024/08/">2024-08</a>
<li><a href="https://neue.cc/2024/07/">2024-07</a>
<li><a href="https://neue.cc/2024/06/">2024-06</a>
<li><a href="https://neue.cc/2024/05/">2024-05</a>
<li><a href="https://neue.cc/2024/03/">2024-03</a>
<li><a href="https://neue.cc/2024/02/">2024-02</a>
<li><a href="https://neue.cc/2024/01/">2024-01</a>
<li><a href="https://neue.cc/2023/12/">2023-12</a>
<li><a href="https://neue.cc/2023/10/">2023-10</a>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer" data-pagefind-ignore="all"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
