<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2834006-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-2834006-1');
    </script>
    <meta charset="utf-8" />
    <title>neue cc</title>
    <link rel="shortcut icon" href="https://neue.cc/favicon.ico" />
    <link rel="alternate" type="application/rss+xml" href="https://neue.cc/feed"/>
	<link rel="stylesheet" href="https://neue.cc/style.css" type="text/css" media="screen" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
 </head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <div id="wrapper">
        <a href="https://neue.cc/"><div id="header"></div></a>
        <div id="content"><h1><a href="https://neue.cc/2009/11/09_214.html">F# TutorialをC#と比較しながらでF#を学ぶ</a></h1>
<ul class="date"><li>2009-11-09</li></ul>
<div class="entry_body"><p class="noindent">
	<img src="http://neue.cc/wp-content/uploads/image/fsharpTutorial.jpg">
</p>
<p>F#はMicrosoft発の関数型言語で、Visual Studio 2010に標準搭載されます。<a href="http://msdn.microsoft.com/ja-jp/vstudio/dd582936(en-us).aspx" title="Visual Studio 2010 and .NET Framework 4 Beta 2">Visual Studio 2010 Beta 2</a>も出たことだし、話題の？新言語を少し勉強してみることにします。F#の新規プロジェクト一覧にTutorialというのが用意されているので、これの中身を、C#と比較しながら見ていきたいと思います。追記：<a href="http://www.microsoft.com/japan/visualstudio/products/2010/default.mspx" title="Microsoft Visual Studio 2010 First Look">Microsoft Visual Studio 2010 First Look</a> Beta 2日本語版も公開されました。</p>
<h2>基本</h2>
<p>```fsharp
open System
let int1 = 1
let int2 = int1 + 3
```
<pre><code class="language-csharp">using System;
var int1 = 1;
var int2 = int1 + 3;
```&lt;/p&gt;

名前空間の利用の設定と基本的な変数の代入方法。といったところでしょうか。そのまんまだし、別にC#と違いは特にないっぽい。C#ではvar、F#ではlet。どちらも推論が効くのでほとんど同じ。末尾セミコロンはいらないようです。#lightがどうたらこうたら、というのは略。それともう一つ、F#はこのように定義したint1に再代入は出来ません。int1 = 100とすると、比較になります(==ではなく=が比較)。再代入的なint1 &lt;- 1000はコンパイルが通らない。不変(immutable)なのです。C#だとreadonly、はフィールドにしかつけられないので、同じことを再現するのは無理なよう。

Print
---
```fsharp
printfn &quot;peekResult = %d&quot; peekResult
printfn &quot;listC = %A&quot; listC
</code></pre>
<p>F# TutorialではPrintは最後にあるのですが、あのですね、出来ればprintは冒頭にしていただきたいです。なんというか、私がF#で一番戸惑ったのが、printfn int1ってのが出来ないことなんですね。いやほら、とりあえずlet int1 = 1って書いたじゃないですか、最初に。で、書いたらとりあえず表示して確認したいでしょ？Console.WriteLineにあたるのはprintfnか、って来るわけです。でも、書いても動かないの。で、まあ、つまるところstring.Format的なものであり書式指定が必要、というところまで行くわけですが、そこで書式って何を書けばいいの？ということになるわけです。&quot;%d&quot;とか予告なく言われても分からないし。もうブチ切れですよ。え、Cの書式指定と一緒だって？いやあ、Cの書式指定も全然覚えてられません、あれあんま良くないと思うんですが……(ついでに言えば私はC#の書式指定も全然覚えてない、必要な度にMSDN見に行ってる)。しかもF#のは書式も色々拡張されてない？より一層分からん！int1の出力で挫折する！</p>
<p>ということなので、もっと頭の方にprintfnのきちんとした解説を載せてくれないと辛いです。ただ、どうしてもアレならConsole.WriteLine int1とでも書けば動く。おお、いきなり.NET Frameworkがそのまま使えることの有難味が(笑) と、冗談はさておき、この「書式指定に何が使えるのか分からない」状態はひっじょーに気持ち悪いので、検索してすぐ分かるような場所に一覧が、欲しい、です。真面目にこれは挫折理由になってます。しょうがないので検索して出てきた
<a href="http://books.google.co.jp/books?id=NcrMkjVxahMC&amp;pg=PA91&amp;dq=F%23+using+printf&amp;as_brr=3&amp;ei=HAT4SpvrG5OilQTrx6nSBQ#v=onepage&amp;q=F%23%20using%20printf&amp;f=false" title="Expert F# - Google ブックス">Google BooksのExpert F#の解説</a>を見てようやくホッとできた。</p>
<p>%b(bool), %s(string), %d(10進), %f(float), %O (Object.ToString()) それと%A(Any)を覚えておけば問題ない、でしょーか。ほんと予告なく%Aとか言われても困るんですよ、泣きたいですよ。%Oとの違いは、人間が見た時に良い感じに整形してくれるのが%A、でしょうか。文字列は&quot;&quot;で囲まれ、配列は展開して出力してくれる。</p>
<p>C#ではcw-&gt;TabTab-&gt;変数名、といった感じにコードスニペットを活かして手早く記述出来たわけですが、それに比べるとF#は書式指定が必要な時点で、非常にカッタルイ。カッタルイのですが、かわりに、より型に厳格です。printfn &quot;%s&quot; trueとか書くとコンパイル通らない。良し悪し、でしょうか。でも学習用にやってる間は面倒くさいだけですね。どうしても嫌ならば「let p x = printfn &quot;%A&quot; x」とでも定義しておけば良いのでしょうけれど。</p>
<p>gdgd言う前に<a href="http://msdn.microsoft.com/en-us/library/dd233181(ja-jp,VS.100).aspx">F C# 言語リファレンス</a>を見ろ、って話なのかもしれない。私は情けないことにここから書式指定を記した部分を見つけられませんでしたが。あと、選択範囲で囲んでAlt+EnterでF# Interactiveに送られるのでそれ見て確認しろって話も少しはありそう。</p>
<h2>関数</h2>
<p>```fsharp
let f x = 2*x*x - 5*x + 3
let result = f (int2 + 4)
let rec factorial n = if n=0 then 1 else n * factorial (n-1)
```
<pre><code class="language-csharp">Func&lt;int, int&gt; f = x =&gt; 2 * x * x - 5 * x + 3;
var result = f(int2 + 4);
Func&lt;int, int&gt; factorial = null;
factorial = n =&gt; (n == 0) ? 1 : n * factorial(--n);
```&lt;/p&gt;

Tutorialには最大公約数を求めるものもありましたがfactorialと同じなので省略。F#は関数型言語ということで、やっぱ関数ですよね！キーワードはletのままで、ふつーの変数と区別なく定義できる。 C#では汎用デリゲートであるFuncとActionを使うことでそっくり再現できる。C#では型を書いてやらなければならないのだけど、F#ではより強力に推論が効くようで型の明示は不要、のようです。

再帰は、F#はlet recキーワードでそのまま書けるのに対し、C#では一度nullを代入して名前を事前に宣言しておかなければならない。というぐらいで、見た目はほとんど変わらない。そういえばifが式ですね。なのでelseは省略できないようです。else ifの連打はelifで。というわけで、このif式（？）はC#の三項演算子とほとんど同じような感じです。

```fsharp
let add1 x y = x + y
printfn &quot;%A&quot; (add1 1.0 2.0)
printfn &quot;%A&quot; (add1 1 2) // Compile Error
let add2 x y = x + y
printfn &quot;%A&quot; (add2 1 2)
printfn &quot;%A&quot; (add2 1.0 2.0) // Compile Error
</code></pre>
<p>少し脱線して型推論の話を。C#の推論は単純なだけ分かりやすくて、これは型書いてやらないといけないな、推論させるための材料を与えてあげないといけないな、というのが結構直感的だったんですが、F#だと強力な分だけ、どう推論されるのか難しい。今は漠然と、全体を見るんだなー、ぐらいにしか分かっていません。例のコードですが、add1はfloat-&gt;float-&gt;floatで、add2はint-&gt;int-&gt;intに推論されます。let add1 x y = x + yの時点ではxの型もyの型も分からないけれど、「最初に呼ばれた時に」引数の型は判明する、ということは戻り値の型も判明する。なので、その型で決定する。ということなのかなー、と。この部分はC#と全然違っていて、面白いし強力だなー、と。</p>
<h2>Tuple</h2>
<p>```fsharp
let data = (1, "fred", 3.1415)
let Swap (a, b) = (b, a)
```
<pre><code class="language-csharp">var data = Tuple.Create(1, &quot;hogehoge&quot;);
static Tuple&lt;T2,T1&gt; Swap&lt;T1,T2&gt;(Tuple&lt;T1,T2&gt; tuple)
{
    return Tuple.Create(tuple.Item2, tuple.Item1);
}
```&lt;/p&gt;

TupleはC#4.0から導入されます。F#は括弧で括るという専用記法があるので簡単に記述出来る。のに対して、C#ではふつーのclassなのでふつーにclassとして使うしかないのが残念。Swapですが、Tupleはimmutable(不変)なので、新しく生成する。だけ。です。temp用意して入れ替えて、などしない。潔く新しく作る。

Boolean, Strings
---
&lt;p&gt;```fsharp
let boolean1 = false
let boolean2 = not boolean1 &amp;&amp; (boolean1 || false)
let stringA  = &quot;Hello&quot;
let stringB  = stringA + &quot; world.&quot;
</code></pre>
<pre><code class="language-csharp">var boolean1 = false;
var boolean2 = !boolean1 &amp;&amp; (boolean1 || false);
var stringA = &quot;Hello&quot;;
var stringB = stringA + &quot;world.&quot;;
```&lt;/p&gt;

F#では否定が!ではなくnotなのですね。あとは一緒。

List
---
&lt;p&gt;```fsharp
let listA = [ ]
let listB = [ 1; 2; 3 ]
let listC = 1 :: [2; 3]
let oneToTen = [1..10]
let squaresOfOneToTen = [ for x in 0..10 -&gt; x*x ]
</code></pre>
<pre><code class="language-csharp">var listA = Enumerable.Empty&lt;object&gt;();
var listB = new[] { 1, 2, 3 }.ToList();
var listC = Enumerable.Repeat(1, 1).Concat(new[] { 2, 3 }).ToList();
var oneToTen = Enumerable.Range(1, 10 - 1 + 1).ToList();
var squaresOfOneToTen = Enumerable.Range(0, 10 - 0 + 1).Select(x =&gt; x * x).ToList();
```&lt;/p&gt;

リストを扱うとC#と大分差が出てきます。まず第一に、空リストは、C#だと該当するものは作れない。と思う。とりあえずobjectで代替することにしましたが、多分正しくありません。listBはただの整数リストなわけですが、F#だと;で区切るようです。一応、配列とリストは違うということで、C#側のコードはListにしていますがListとも違うので、まあ、気分だけ。listCの::はConsということで、一つの値とリストを連結するものです。C#に該当する関数はありません。しいていえばConcatが近いので、Repeat(value, 1)で長さ1のシーケンスを作って連結、という手を取ることにしました。

F#は[1..10]で最小値-最大値の連続したリストが作れるのですが、これはC#のEnumerable.Rangeとは、違います。Rangeの第二引数は最大値ではなく個数なので。正直言って、個数よりも最大値のほうが使いやすいと思うのだけどなー。というわけで、最大値-最小値+1 = 個数。ということにしています。最後のリスト内包表記は、うん、ええと、私は苦手です。値の動きが右行ったり左行ったりなのが嫌です。Linqのほうが好き。C#でイメージするなら、foreach (var x in [0..10]) yield return x * x; ってとこですかね。

パターンマッチ
---
&lt;p&gt;```fsharp
let rec SumList xs =
    match xs with
    | []    -&gt; 0
    | y::ys -&gt; y + SumList ys
let listD = SumList [1; 2; 3]  
</code></pre>
<pre><code class="language-csharp">Func&lt;IEnumerable&lt;int&gt;, int&gt; SumList = null;
SumList = xs =&gt; (!xs.Any())
    ? 0
    : xs.First() + SumList(xs.Skip(1));

var sum1 = SumList(new[] { 1, 2, 3 });
var sum2 = new [] { 1, 2, 3 }.Sum(); // こらこら
```&lt;/p&gt;

まず、listDとかF# Tutorialには書いてあるんですが、これintなのでlistじゃないでしょ！紛らわしい。さて、match with | -&gt;という目新しい記述がパターンマッチという奴ですね？ 引数のリストxs(リストは通常変数名にxsとかysとかを用いるようです)が空配列の時は0を、そうでない時はyとysに分解して、ysの方は再帰して足し合わせる。ふむぬん。C#に直すとif-else if-else ifの連打。値を返すから、三項演算子のネストですな。という程度の理解しかしていません。三項演算子ネストより綺麗に書けて素敵。という浅すぎる理解しか、今はしていません。まあ、そのうちそのうち。

y::ysという表記ですが、これは配列中の最初のものがy、それ以外がysになります。つまりLinqだとFirst()とSkip(1)ですね。let x::xs = [3..5]とすれば、xが3でxsが4,5になる。警告出ますが。基本はパターンマッチ時用ってことなのかしらん。この辺はちょっと良く分かりません。

C#のほうの、IEnumerableのままSkipをゴロゴロと繋げていくのは実行効率がアレな悪寒。かといってToArrayを毎回使うのもなあ、というわけで上手い落し所が見つからない。QuickSortのように一本の配列に対し、境界の数字を渡していくってのやるとゴチャゴチャするし。あ、でもF#のも結局ysってのはxsとは別の、新しい配列ですよね？C#で表すのならば、xs.Skip(1).ToArray()ということかしらん。だとしたら、この程度の「効率」なんて奴は、気にしたら負けだと思っている。でいいのかもしれない。よくないかもしれない。

配列・コレクション
---
&lt;p&gt;```fsharp
let arr = Array.create 4 &quot;hello&quot;
arr.[1] &lt;- &quot;world&quot;
arr.[3] &lt;- &quot;don&quot;
let arrLength = arr.Length        
let front = arr.[0..2]
let lookupTable = dict [ (1, &quot;One&quot;); (2, &quot;Two&quot;) ]
let oneString = lookupTable.[1]
</code></pre>
<pre><code class="language-csharp">var arr = Enumerable.Repeat(&quot;hello&quot;, 4).ToArray();
arr[1] = &quot;world&quot;;
arr[3] = &quot;don&quot;;
var arrLength = arr.Length;
var front = new string[3];
Array.Copy(arr, 0, front, 0, 3);
// もしくはSkip-&gt;Take. 実行効率は劣りますが、私はこちらの記述方法のほうが好き
var front2 = arr.Skip(0).Take(3).ToArray();
var lookupTable = new Dictionary&lt;int, string&gt; { { 1, &quot;One&quot; }, { 2, &quot;Two&quot; } };
var oneString = lookupTable[1];
```&lt;/p&gt;

配列とlistとの違い。listは不変(immutable)で、配列は可変(mutable)ということかしらん。あと配列なら.NET Frameworkのメソッド・プロパティが全部使える。mutableなものへの値の再代入は=ではなく&amp;lt;-で行う。あとは、Array.createは中身がnullな配列ではなく、初期値を指定して全部それで埋めるメソッドのようです。ふむ。あ、最後のslicing notationはいいですね。C#だとArray.Copyを使うのが等しいでしょうけど、記述が冗長すぎてねえ……。どうせ実行時間に対して差は出ないでしょ、と思う場合はLinqでSkip-&gt;Takeにしたほうがすっきり書けて良い。あ、あとインデクサは.[]が対応してるようです。ドット。ドット。

辞書の初期化は、タプルを放り投げるだけ。素晴らしい！見た目に分かりやすくスッキリするのがいいです。C#だとコレクション初期化子で近い形にはなりますが、{ {と、全て波括弧で記述するのはどうかなあ、と思うところがあるので。あとは一応、[C# 3.0 における疑似 Map 生成リテラル - NyaRuRuの日記](http://d.hatena.ne.jp/NyaRuRu/20071211/p3)なんてことも出来ますけれど、やりませんものね。

関数(その2)
---
&lt;p&gt;```fsharp
let Square x = x*x              
let squares1 = List.map Square [1; 2; 3; 4]
let squares2 = List.map (fun x -&gt; x*x) [1; 2; 3; 4]
let squares3 = [1; 2; 3; 4] |&gt; List.map (fun x -&gt; x*x) 
let SumOfSquaresUpTo n = 
  [1..n] 
  |&gt; List.map Square 
  |&gt; List.sum
</code></pre>
<pre><code class="language-csharp">public static IEnumerable&lt;TR&gt; Map&lt;T, TR&gt;(this Func&lt;T, TR&gt; selector, IEnumerable&lt;T&gt; source)
{
    return source.Select(selector);
}

// ↑という拡張メソッドを定義して

Func&lt;int, int&gt; Square = x =&gt; x * x;
var squares1 = Map(Square, new[] { 1, 2, 3, 4 });
var squares2 = new Func&lt;int, int&gt;(x =&gt; x * x).Map(new[] { 1, 2, 3, 4 });
var squares3 = new[] { 1, 2, 3, 4 }.Select(x =&gt; x * x).ToArray();
// もしくは Array.ConvertAll(new[] { 1, 2, 3, 4 }, x =&gt; x * x)
Func&lt;int, int&gt; SumOfSquaresUpTo = n =&gt;
    Enumerable.Range(1, n - 1)
        .Select(i =&gt; Square(i))
        .Sum();
```&lt;/p&gt;

関数が先で、それに適用する配列を渡す、という順序はC#ばかり触ってる身としては、新鮮な印象です。そういえば[Achiral](http://d.hatena.ne.jp/NyaRuRu/20080115/p1)にも同種のオーバーロードが沢山定義されているのですが、私は違和感から、IEnumerable始点のものばかり使っています。あとSelect-&gt;ToArrayはArray.ConvertAllで書けるのですが、私はLinqで書くほうが好き。というかArrayの静的メソッドは、基本Obsoleteなぐらいの気持ちでいたりいなかったりする。

ラムダ式は「fun 引数 -&gt; 本体」ですね。C#のほうがキーワードが必要ない分だけすっきりしてガガガ。でもnew Func&lt;型&gt;という不格好なものをつけなければならなかったりする悪夢。var hoge = (int x) =&gt; x * xもダメなんですよねえ。理由は、例えば「delegate int Func2(int i);」というのが定義出来るから。引数intで戻り値intだから、Func&lt;int, int&gt;とFunc2は同じ。でも型は違う。なので、見分けがつかず推論できないので、どのデリゲートを使うか、まで指定する必要がある。これは、悲しくウザい話です。ActionとFunc以外のデリゲート型なんて滅びてしまえばいいのに。

「|&gt;」という見慣れない演算子が、パイプライン演算子で、左から右に値を流す。C#だと、Listに対してはLinqで、値に対しては、そういえば前に書いたような……。[neue cc - ver 1.3.0.3 / ちょっとした拡張メソッド群](http://neue.cc/2009/07/16_177.html)のTapの一個目が近い感じでしょーか。いいですよね、こういうの。

Mutable
---
&lt;p&gt;```fsharp
let mutable sum = 0
for i in 0..10 do
  sum &lt;- sum + i
while sum &lt; 100 do
  sum &lt;- sum + 5
</code></pre>
<pre><code class="language-csharp">var sum = 0;
foreach (var i in Enumerable.Range(0, 10))
{
    sum += i;
}
while (sum &lt; 100)
{
    sum += 5;
}
```&lt;/p&gt;

最初にF#の値はimmutableだと書きましたが、mutableにしたい時は、mutableキーワードを足せばおｋ。再代入時は&amp;lt;-演算子を使う、と。C#だとデフォルトがmutableなので、まんまです。そして、このforは、foreachですね。インデントが波括弧代わりなので、doだけどendは要りません。普通のforは「for i = 1 to 10 do」ですが、これならforeachでいいやあ、という気はする。

Types: unions
---
&lt;p&gt;```fsharp
type Expr = 
  | Num of int
  | Add of Expr * Expr
  | Mul of Expr * Expr
  | Var of string
  
let rec Evaluate (env:Map&lt;string,int&gt;) exp = 
    match exp with
    | Num n -&gt; n
    | Add (x,y) -&gt; Evaluate env x + Evaluate env y
    | Mul (x,y) -&gt; Evaluate env x * Evaluate env y
    | Var id    -&gt; env.[id]
  
let envA = Map.of_list [ &quot;a&quot;,1 ;
                         &quot;b&quot;,2 ;
                         &quot;c&quot;,3 ]
             
let expT1 = Add(Var &quot;a&quot;,Mul(Num 2,Var &quot;b&quot;))
let resT1 = Evaluate envA expT1
```&lt;/p&gt;

F# Tutorialですが、ここで途端に説明が無くなって放り出されます。鬼すぎる。今までのわりとゆるふわなところから途端にコレです。意味分からないし。unionsとか言われても分けわからない。と、嘆いていても始まらないので理解するよう頑張ります。そういえば(env:Map&amp;lt;string,int&gt;)も初出なのよね。推論じゃなく明示的に型を与える時は、こうするそうです。型定義がC#とは逆で、コロン後の末尾。違和感がシンドい。ActionScriptなんかも同じで非常にシンドい。

unionはC#だとenumが近いかなー、と思うのですが、enumがintのみなのに対し、F#のunionはそれぞれが別の型を持てる。といった認識。更に値は外から定義可能。というわけでenumとは全然違いますな。むしろ普通にclassに近い。of intで型を定義している(Expr * ExprはTuple)し、値は外から与えているし(コンストラクタのように！) けれど、値は一個。

じゃあclassで作れるかと言ったら、どうだろー。戻り値の型がバラバラになるので、interfaceで一個に纏められるわけでもなく上手いやり方ってあるのかしらん。パターンマッチと同じく、C#には無い概念、と素直にとらえた方が良いかも。一応、interface、じゃなくてダミーに近い型の下にぶら下げて、Evaluateのところでisで派生型を判定して分岐、といった感じでやってみましたが、ゴミですね……。

```csharp
public class Expr
{
    // privateにしたいつもり(これは酷い)
    public class _Num : Expr
    {
        public int Value { get; set; }
    }
    public class _Add : Expr
    {
        public Expr E1 { get; set; }
        public Expr E2 { get; set; }
    }
    public class _Mul : Expr
    {
        public Expr E1 { get; set; }
        public Expr E2 { get; set; }
    }
    public class _Var : Expr
    {
        public string Value { get; set; }
    }

    private Expr() { }

    public static Expr Num(int value)
    {
        return new _Num { Value = value };
    }
    public static Expr Add(Expr e1, Expr e2)
    {
        return new _Add { E1 = e1, E2 = e2 };
    }
    public static Expr Mul(Expr e1, Expr e2)
    {
        return new _Mul { E1 = e1, E2 = e2 };
    }
    public static Expr Var(string value)
    {
        return new _Var { Value = value };
    }
}

static int Evaluate(IDictionary&lt;string, int&gt; env, Expr exp)
{
    return // どうしょうもなく酷い
          (exp is Expr._Num) ? ((Expr._Num)exp).Value
        : (exp is Expr._Add) ? Evaluate(env, ((Expr._Add)exp).E1) + Evaluate(env, ((Expr._Add)exp).E2)
        : (exp is Expr._Mul) ? Evaluate(env, ((Expr._Mul)exp).E1) + Evaluate(env, ((Expr._Mul)exp).E2)
        : (exp is Expr._Var) ? env[((Expr._Var)exp).Value]
        : 0;
}

static void Main(string[] args)
{
    var envA = new Dictionary&lt;string, int&gt; { { &quot;a&quot;, 1 }, { &quot;b&quot;, 2 }, { &quot;c&quot;, 3 } };
    var expT1 = Expr.Add(Expr.Var(&quot;a&quot;), Expr.Mul(Expr.Num(2), Expr.Var(&quot;b&quot;)));
    var resT1 = Evaluate(envA, expT1);
    Console.WriteLine(resT1); // 確認
}
</code></pre>
<p>見なかったことにしてください。私の脳みそなんてこんなもんです。</p>
<h2>Types: records</h2>
<p>```fsharp
type Card = { Name  : string;
              Phone : string;
              Ok    : bool }
              
let cardA = { Name = "Alf" ; Phone = "(206) 555-8257" ; Ok = false }
let cardB = { cardA with Phone = "(206) 555-4112"; Ok = true }
let ShowCard c = 
  c.Name + " Phone: " + c.Phone + (if not c.Ok then " (unchecked)" else "")
```
<pre><code class="language-csharp">class Card
{
    public string Name { get; set; }
    public string Phone { get; set; }
    public bool Ok { get; set; }

    public Card() { }

    public Card(Card with)
    {
        // structならthis=withで一発なのですが
        // F#のrecordはstructじゃないとのことなので
        this.Name = with.Name;
        this.Phone = with.Phone;
        this.Ok = with.Ok;
    }
}

var cardA = new Card { Name = &quot;Alf&quot;, Phone = &quot;(206) 555-8257&quot;, Ok = false };
var cardB = new Card(cardA) { Phone = &quot;(206) 555-4112&quot;, Ok = true };
Func&lt;Card, string&gt; ShowCard = c =&gt;
    c.Name + &quot; Phone: &quot; + c.Phone + (!c.Ok ? &quot; (unchecked)&quot; : &quot;&quot;);
```&lt;/p&gt;
    
こちらは割とすんなりと何なのか分かる。withでコピーが作れているところが面白い。ふーむ、C#だとむしろ匿名型のほうが近い感じに見えるかもしれない。

Types: classes
---
&lt;p&gt;```fsharp
type Vector2D(dx:float, dy:float) = 
    let length = sqrt(dx*dx + dy*dy)
    member v.DX = dx
    member v.DY = dy
    member v.Length = length
    member v.Scale(k) = Vector2D(k*dx, k*dy)
</code></pre>
<pre><code class="language-csharp">class Vector2D
{
    public float DX { get; private set; }
    public float DY { get; private set; }
    public float Length { get; private set; }
    public Func&lt;int, Vector2D&gt; Scale { get; private set; }

    public Vector2D(float dx, float dy)
    {
        var length = (float)Math.Sqrt(dx * dx + dy * dy);
        this.DX = dx;
        this.DY = dy;
        this.Length = length;
        this.Scale = new Func&lt;int, Vector2D&gt;(k =&gt; new Vector2D(k * dx, k * dy));
    }
}
```&lt;/p&gt;

コンストラクタと定義が一体化していて、随分とシンプルに記述出来るようです。JavaScriptっぽい、なんて思ってしまったりして。C#で再現するとプロパティでメソッドかいな、という違和感があったりなかったり。private変数で蓄える必要がないから、定義が楽といえば楽。ところで思うのは、F#のv.DXとかの、vって何処から来てるの……？ これ、別にhogehogeにしてもaaaaaaにしても動くので、何でもいいみたいですが……。

Types: interfaces
----
&lt;p&gt;```fsharp
type IPeekPoke = 
    abstract Peek: unit -&gt; int
    abstract Poke: int -&gt; unit

type Widget(initialState:int) = 
    let mutable state = initialState
    interface IPeekPoke with 
        member x.Poke(n) = state &lt;- state + n
        member x.Peek() = state 
    member x.HasBeenPoked = (state &lt;&gt; 0)

let widget = Widget(12) :&gt; IPeekPoke
widget.Poke(4)
let peekResult = widget.Peek()
</code></pre>
<pre><code class="language-csharp">interface IPeekPoke
{
    int Peek();
    void Poke(int n);
}

class Widget : IPeekPoke
{
    private int state;
    public bool HasBeenPoked { get { return state != 0; } }

    public Widget(int initialState)
    {
        state = initialState;
    }

    public int Peek()
    {
        return state;
    }

    public void Poke(int n)
    {
        state = state + n;
    }
}

static void Main(string[] args)
{
    var widget = (IPeekPoke)new Widget(12);
    widget.Poke(4);
    var peekResult = widget.Peek();
}
```&lt;/p&gt;

interfaceはabstractな型定義を並べる。ということらしい。定義方法は「メソッド名:引数-&gt;引数-&gt;戻り値」ですねん。unitはC#でいうところのvoidみたいなもの。で、interfaceの実装は、そのまま中に記述してしまえばいいらしい。これは楽ちん。見慣れない「:&gt;」はキャストの記号。とても、カッコイイです……。

結論
---

以上、複数回に分けようかとも思ったのですが一気にやってみました。最初F# Tutorialを開いて、少な！こんなんでチュートリアルになってるの？と思ったのですが、意外とギッシリ詰まってた感じです。しっかりチュートリアルになってました。ただ、やっぱチュートリアルなのでこれを覚えたぐらいじゃF#凄い！F#嬉しい！的にはなりません(比較対象がC#2.0だとなったかもしれませんが)でした。日常的に使って、手に馴染ませないと、良さの理解まではいけなさそうです。

あとまあ、やっぱほとんど説明のない、このTutorialのコードだけじゃ適当な理解になってそうで怖い。きちんと時間割いてMSDN見るなりしないと……。ただ、今のとこがっつし覚えよう！と思えてないところはある。本音として、C#でいいぢゃん、と思っているところがかなりあります。これがJava-&gt;Scalaの関係だったら違ったかもしれないんですが、うーん。まあ、あとVisualStudioの補完具合とかかな。IntelliSenseに乗ってゴリゴリ書けるような感触がF#にはないので。別に補完効いてないってわけじゃあないのですけど。
</code></pre>
</div>
<h1><a href="https://neue.cc/2009/11/05_213.html">C#でTwitterのStreaming APIを使ってリスト自動追加</a></h1>
<ul class="date"><li>2009-11-05</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/software/xboxinfotwit" title="neue cc - XboxInfoTwit">XboxInfoTwit</a>の認証数は現在450を越えて、近いうちに500には届きそうです。現在の実装はIEを裏で動かすという、しょーもないものになっていて、それに起因する不具合や、どうしょうもない点が幾つかあるため、クローラー部分は全面的に書き変えようと思っています。あと、エラーメッセージがド不親切とか至らない点だらけでした、すみません。そんな次期バージョンの作業は全然捗ってないのですが、せめて年内ぐらいには何とかしたいです。</p>
<h2>@のお話</h2>
<p>ゲーム名に@が含まれるものをポストする(例えばTHE IDOLM@STER)と、STERさんに@が飛んで迷惑。というお話を見たので検証してみました。@は行頭かスペース + @ + 数字/アルファベットのものがあると飛びます。つまり、@の前にアルファベットがあれば@は飛びません。なので、別にIDOLM@STERだからってSTERさんに@が飛びまくる、なんてことはありません。正規表現で表すと「(?&lt;=^| )@[a-zA-Z0-9_]+」になります。ついでに、ハッシュタグのほうも軽く検証してみました。基本的には@と同じですが、英単語以外にもリンクが張られるようなので、正規表現は「(?&lt;=^| )#[^ ]+」になるようです。</p>
<h2>List</h2>
<p>Twitterにリストが実装されました。そこで、<a href="https://twitter.com/neuecc/xboxinfotwitusers" title="Twitter / @neuecc/XboxInfoTwitUsers">XboxInfoTwitユーザーのリスト</a>を作ってみることにしました。手動で探して登録も大変なので、プログラムでクロールして追加していきましょう。パブリックイタイムラインからXboxInfoTwit利用者(Source=XboxInfoTwit)の人を片っ端からリスト登録するという方針で行きます。以下、C#でのTwitterストリーミングAPIの使用法と実際のコードになります。同じようなことをやりたい人は、適当に書き替えてどうぞ使ってください。突っ込みどころ多数なのでむしろ突っ込んで欲しい……。</p>
<p>2010/4/29 追記：このコードはストリームAPIの利用法にしては冗長すぎるので、書き直しました → <a href="http://neue.cc/2010/04/29_255.html" title="neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions">neue cc - C#とLinq to JsonとTwitterのChirpUserStreamsとReactive Extensions</a> ストリームAPI取得コードを参考にする場合は、新しいほうを見てください。</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.Xml.Linq;
using System.Collections.Specialized;
using System.Threading;
using System.Xml;

static class Program
{
    // ザ・決めうち文字列s
    const string UserName = &quot;neuecc&quot;; // 自分のアカウントのユーザー名を
    const string Password = &quot;password&quot;; // 同じくパスワードを
    const string ListName = &quot;xboxinfotwitusers&quot;; // リストを、入力ですです
    const string StreamApi = &quot;http://stream.twitter.com/1/statuses/sample.xml&quot;;
    const string ListMembersApiFormat = &quot;http://twitter.com/{0}/{1}/members.xml&quot;;

    /// &lt;summary&gt;指定リストにメンバーを追加する&lt;/summary&gt;
    static void AddMemberToList(string userName, string listName, int id)
    {
        var url = string.Format(ListMembersApiFormat, userName, listName);
        var wc = new WebClient { Credentials = new NetworkCredential(UserName, Password) };
        wc.UploadValues(url, new NameValueCollection() { { &quot;id&quot;, id.ToString() } });
    }

    /// &lt;summary&gt;指定リストのメンバーIDを全て取得する&lt;/summary&gt;
    static IEnumerable&lt;int&gt; EnumerateListMemberID(string userName, string listName)
    {
        var format = string.Format(ListMembersApiFormat, userName, listName) + &quot;?cursor={0}&quot;;
        var cursor = -1L;
        var xmlReaderSettings = new XmlReaderSettings
        {
            XmlResolver = new XmlUrlResolver { Credentials = new NetworkCredential(UserName, Password) }
        };
        while (true)
        {
            using (var xr = XmlReader.Create(string.Format(format, cursor), xmlReaderSettings))
            {
                var xEle = XElement.Load(xr);
                foreach (var item in xEle.Descendants(&quot;user&quot;).Select(x =&gt; (int)x.Element(&quot;id&quot;)))
                {
                    yield return item;
                }
                cursor = long.Parse(xEle.Element(&quot;next_cursor&quot;).Value);
                if (cursor == 0) yield break;
            }
        }
    }

    /// &lt;summary&gt;ストリームAPIのパブリックタイムラインから無限に取得&lt;/summary&gt;
    static IEnumerable&lt;XElement&gt; EnumeratePublicTimeline(StreamReader reader)
    {
        while (true)
        {
            var xmlString = reader.EnumerateLines()
                .TakeWhile(s =&gt; s != &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;)
                .Join();
            if (xmlString == &quot;&quot;) continue;
            yield return XElement.Parse(xmlString);
        }
    }

    /// &lt;summary&gt;サーバーが死んでないか確認&lt;/summary&gt;
    static bool IsServerStatusOK()
    {
        var req = WebRequest.Create(&quot;http://twitter.com/help/test.xml&quot;);
        HttpWebResponse res = null;
        try
        {
            res = (HttpWebResponse)req.GetResponse();
            if (res.StatusCode == HttpStatusCode.OK) return true;
        }
        catch (WebException e) { Console.WriteLine(e); }
        finally { if (res != null) res.Close(); } // どうでもいいと思っていたり

        return false;
    }

    static void Main(string[] args)
    {
        ServicePointManager.Expect100Continue = false; // おまじない(笑)
        var count = 0; // モニタリング用のカウント変数(動作的には別に使わない)

        var following = new HashSet&lt;int&gt;(EnumerateListMemberID(UserName, ListName));
        var webRequest = (HttpWebRequest)HttpWebRequest.Create(StreamApi);
        webRequest.KeepAlive = true;
        webRequest.Credentials = new NetworkCredential(UserName, Password);

    LOOP:
        using (var res = webRequest.GetResponse())
        using (var stream = res.GetResponseStream())
        using (var reader = new StreamReader(stream))
        {
            try
            {
                // 例外が発生しなければ、無限リピートになっているのでこの部分を永久に続けます
                EnumeratePublicTimeline(reader)
                    .Do(_ =&gt; { if (++count % 100 == 0) Console.WriteLine(&quot;{0} : {1}&quot;, DateTime.Now, count); }) // 確認表示用
                    .Where(x =&gt; x.Name == &quot;status&quot;)
                    .Select(x =&gt; new
                    {
                        Source = x.Element(&quot;source&quot;).Value,
                        ID = (int)x.Element(&quot;user&quot;).Element(&quot;id&quot;),
                        Name = x.Element(&quot;user&quot;).Element(&quot;screen_name&quot;).Value
                    })
                    .Where(a =&gt; a.Source.Contains(&quot;XboxInfoTwit&quot;))
                    .Do(a =&gt; Console.WriteLine(&quot;Found:{0}&quot;, a.Name)) // ここでも確認表示用
                    .Where(a =&gt; following.Add(a.ID))
                    .ForEach(a =&gt;
                    {
                        AddMemberToList(UserName, ListName, a.ID);
                        Console.WriteLine(&quot;{0} : {1} : {2}&quot;, a.Name, DateTime.Now, count); // 確認表示用
                    });
            }
            catch (IOException e)
            {
                Console.WriteLine(e); // 接続が閉じられてたりするのでー。
                while (!IsServerStatusOK())
                {
                    Thread.Sleep(TimeSpan.FromMinutes(5)); // サーバー死んでたら5分間お休み
                }
            }
            finally
            {
                webRequest.Abort(); // これ呼ぶ前にCloseするとハング
            }
        }
        goto LOOP; // goto! goto!
    }

    // Extension Methods

    public static IEnumerable&lt;string&gt; EnumerateLines(this StreamReader streamReader)
    {
        while (!streamReader.EndOfStream)
        {
            yield return streamReader.ReadLine();
        }
    }

    public static string Join&lt;T&gt;(this IEnumerable&lt;T&gt; source)
    {
        return source.Aggregate(new StringBuilder(), (sb, s) =&gt; sb.Append(s)).ToString();
    }

    public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
    {
        foreach (var item in source)
        {
            action(item);
        }
    }

    public static IEnumerable&lt;T&gt; Do&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
    {
        foreach (var item in source)
        {
            action(item);
            yield return item;
        }
    }
}
</code></pre>
<p>ストリーミングAPIとは無関係のリスト関連の処理や、投げやりなtry-catch-gotoがあって、ちょっとゴチャゴチャしてますが、基本的にはusing三段重ねの部分だけです。無限にXMLが継ぎ足されてくるので、接続を切らさずひたすらReadLine。XMLの切れ目は、XML宣言部を使うことにしましたが、今一つスマートではないです。文字列にしてParseってのもあまり良い感じじゃなく。あ、あと例外処理は全然出来てませんので何かあると平然と死にます。</p>
<p>コードは、書き捨て感全開。例によって何でもLinq、何でもIEnumerable。コレクションになりそうな気配があると、すぐにじゃあyieldね、と考える癖がついてしまっていて。細かいことは後段に任せればいーんだよ、というのが楽ちんでして。リストメンバー全件取得の部分なんかは、わりとスマートに書けてるかと思うのですがどうでしょう。</p>
<p>なお、このストリーミングAPIは全件を漏れなく取得出来るわけではないので、それなり、というかかなり漏れが出ます。なのでXboxInfoTwit使ってるのに登録されねーぞ、という場合は、しょーがない。です。そのうち登録されると思います。あと、このプログラムはサーバー上で24時間動かしているわけじゃなく、私のローカルPC上で動かしているだけなので、私の気まぐれで動かしてたり動かしてなかったりします。私が寝てる間はPCがウルサイので動いてませんし、私が家に居ない時は省エネのために動いてません。なので、むしろ登録されるほうが珍しいです。レアです。効率的には20000件に1人登録出来るか出来ないか、って感じでした。一時間に一人見つかるかどうかも怪しいぐらいの頻度。とてもレア。ぶっちゃけgoogle経由で引っ張ってくるとかしたほうが遙かに効率良さそうですが、まあ、Streaming API使ってみたかったというだけなので。</p>
<p>そういえばですが、逆にリストに登録されてUZEEEE、という場合は、現状はリスト機能がベータのせいなのか拒否は出来ないようです。すみません。UZEEEE、と思っても我慢してください。どうしても嫌な場合は私の方にメッセージをくれれば、リストからの撤去と、プログラムから以後の追加をしないようなコードを入れたいと思っています。</p>
</div>
<h1><a href="https://neue.cc/2009/11/01_212.html">Replace, Intersperse, Init</a></h1>
<ul class="date"><li>2009-11-01</li></ul>
<div class="entry_body"><pre><code class="language-csharp">static void Main(string[] args)
{
    // 1,2,3,4,5,6,7,8,9,10
    var source = Enumerable.Range(1, 10);
    // 偶数を-1に置換する
    var replace = source.Replace(i =&gt; i % 2 == 0, -1);
    // 値を挟み込む(1,100,2,100,...9,100,10)
    var intersperse = source.Intersperse(100);
    // 末尾一個を省く(1..9)
    var init1 = source.Init();
    // 末尾三個を省く(1..7)
    var init2 = source.Init(3);
}

public static IEnumerable&lt;T&gt; Replace&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate, T replacement)
{
    foreach (var item in source)
    {
        if (predicate(item)) yield return replacement;
        else yield return item;
    }
}

public static IEnumerable&lt;T&gt; Intersperse&lt;T&gt;(this IEnumerable&lt;T&gt; source, T value)
{
    var isFirst = true;
    foreach (var item in source)
    {
        if (!isFirst) yield return value;
        yield return item;
        isFirst = false;
    }
}

public static IEnumerable&lt;T&gt; Init&lt;T&gt;(this IEnumerable&lt;T&gt; source)
{
    return source.Init(1);
}

public static IEnumerable&lt;T&gt; Init&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count)
{
    if (count == 0)
    {
        foreach (var item in source) yield return item;
        yield break;
    }

    var q = new Queue&lt;T&gt;(count);
    foreach (var item in source)
    {
        if (q.Count == count) yield return q.Dequeue();
        q.Enqueue(item);
    }
}
</code></pre>
<p>という拡張メソッド。もういい加減いつになるのか分からなくなってしまって悲しいlinq.jsの次のリリースにはこれらを入れます。IntersperseとInitの元ネタは<a href="http://anonsvn.mono-project.com/viewvc/trunk/rocks/Mono.Rocks/" title="[Mono] Index of /trunk/rocks/Mono.Rocks">Mono.Rocks</a>から。それの更に元はHaskellのようですねん。</p>
<p>Initは何度となく欲しい！と思ったシーンがあるので、きっと便利。長さが不定で前から後ろに走るLinqでは、後ろから幾つ、というのは標準では出来ないんですね。ReverseしてSkipしてReverseするか、一度ToArrayしてから切り出したりしか手がなくて。最後の一個だけ省きたいとか、よくあります。しかしInitって関数名は意味不明で少々アレかも。Mono.RocksではExceptLastに改称されていました。そうですねえ、CarとかCdrを引き摺る必要はないように、ExceptLastのほうが良さそうですね。</p>
<p>実のところInitがあればIntersperseも標準Linq演算子で定義出来ます。</p>
<pre><code class="language-csharp">var intersperse = source
    .SelectMany(i =&gt; Enumerable.Repeat(i, 1).Concat(Enumerable.Repeat(100, 1)))
    .Init();
</code></pre>
<p>Initの便利さが分かる。そう、こういうのやると、どうしても末尾に一個ゴミが付いてきちゃて、それをスマートに除去するのは出来ないのですよね。あって良かったInit。そしてSelectManyの万能さは異常。Repeat(value, 1)とかRepeat(value, int.MaxValue)も超多用。記述があまりにも冗長になって泣けますが。</p>
<p>RxFrameworkにはObservable.Return(value)という、Repeat(value, 1)と同様のものが定義されていたりします。それとObservable.Cons(value,IObservable)というConcatの単体バージョンみたいなものもあります(lispのconsと同じイメージです)。だから、上のをRxでやるならば</p>
<pre><code class="language-csharp">var intersperse = Observable.Range(1, 10)
    .SelectMany(i =&gt; Observable.Cons(i, Observable.Return(100)))
    .ToEnumerable();
    .Init();
</code></pre>
<p>となります。あまりスッキリしてない？ まあ、そうかも。でも、決め打ちの1って書くの嫌なものなので、それが省けるってのは嬉しいものです。定数を使うなら(int)decimal.Oneという手もありますが、まあ、馬鹿らしい。私はstring.Emptyよりも&quot;&quot;を使う派なので、それはちょっとありえない。ちなみに、&quot;&quot;を選ぶ理由は、タイプ数が少ないという他に、文字列であることが色分けされて表示されるため、string.Emptyよりも遥かに視認性が良いからです。こういうのはIDEを含めて考えないとね。パフォーマンス云々の話は些細なことなので個人的にはどうでもいい。</p>
<p>Rxの記事は、細かいネタは溜まっているので、近いうちにまた書きたいと思います。VS2010 Beta2ではIObservableが標準搭載されていますし。</p>
</div>
<h1><a href="https://neue.cc/2009/10/29_211.html">AnonymousComparer - lambda compare selector for Linq</a></h1>
<ul class="date"><li>2009-10-29</li></ul>
<div class="entry_body"><pre><code class="language-csharp">class MyClass
{
    public int MyProperty { get; set; }
}

static void Main()
{
    // 例として、こんな配列があったとします
    var mc1 = new MyClass { MyProperty = 3 };
    var mc2 = new MyClass { MyProperty = 3 };
    var array = new[] { mc1, mc2 };
    // Distinctは重複を取り除く。でも結果として、これは、2です。
    var result = array.Distinct().Count();
    // 参照の比較なので当然です。では、MyPropertyの値で比較したかったら？
    // DistinctにはIEqualityComparerインスタンスを受け付けるオーバーロードもあります
    // しかしIEqualityComparerはわざわざ実装したクラスを作らないと使えない

    // そこで、キー比較のための匿名Comparerを作りました。
    // ラムダ式を渡すことで、その場だけで使うキー比較のIEqualityComparerが作れます。
    array.Distinct(AnonymousComparer.Create((MyClass mc) =&gt; mc.MyProperty));

    // でも、長いし、型推論が効かないから型を書く必要がある
    // Linqに流れているものが匿名型だったりしたら対応できないよ！
    // というわけで、本来のLinqメソッドのオーバーロードとして、記述出来るようにしました
    // ちゃんと全てのIEqualityComparerを実装しているLinq標準演算子に定義してあります
    array.Distinct(mc =&gt; mc.MyProperty);

    // 短いし、型推論もちゃんと効くしで素晴らしいー。
    // 匿名型でもいけます(VBの匿名型はC#(全ての値が一致)と違ってKey指定らしいですね)
    var anonymous = new[] 
    {
        new { Foo = &quot;A&quot;, Key = 10 },
        new { Foo = &quot;B&quot;, Key = 15 }
    };
    // true
    anonymous.Contains(new { Foo = &quot;dummy&quot;, Key = 10 }, a =&gt; a.Key);
}
</code></pre>
<ul>
<li><a href="http://linqcomparer.codeplex.com/" title="AnonymousComparer - lambda compare selector for Linq">AnonymousComparer - lambda compare selector for Linq</a></li>
</ul>
<p>と、いう内容のコードをCodePlexで公開しました。LinqのIEqualityComparerって使いにくいよね、を何とかするためのものです。DLLでも何でもなく、ただの100行のコードなのでコピペで使ってくださいな。メソッドはAnonymousComparer.Createしかありません。newを使わせないのは型推論のためです。メソッド経由なら引数の型を書くだけで済み、戻り値の型を書く手間が省けるので……。あとはLinq標準演算子でIEqualityComparerを使うオーバーロードの全てに、キー比較用ラムダ式を受けるオーバーロードが追加されています。使い方、使い道は、まあ、見た通りです。</p>
<p>わざわざzipをダウンロードするのも面倒、という人は<a href="http://linqcomparer.codeplex.com/SourceControl/changeset/view/33772#570653" title="AnonymousComparer - lambda compare selector for Linq">CodePlexのソース直接表示</a>でどーぞ。どうせ.txtと.csしか入ってないので。でもダウンロード数とかが増えてると少し嬉しいですね。<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library">linq.js</a>もようやく50超えましたよ、あまりの少なさに笑えない。</p>
<p>以前にも同様のものを書いてた
<a href="http://neue.cc/2009/08/07_184.html" title="neue cc - LinqとIEqualityComparerへの疑問">LinqとIEqualityComparerへの疑問</a> のですが、今回やっと重い腰を上げてまとめてみました。GroupJoinのオーバーロードとか手書きだと死ぬほどダルいですからねえ。と、いっても、やっぱ手書きでやってたら洒落にならないほど面倒くさいので、機械生成でサッと作りました。全然サッとしてないんですけどね。むしろ泥臭い。Linqネタなのでワンライナーで強引に仕上げてみましたよ！</p>
<pre><code class="language-csharp">static string data  = @&quot;ここに定義へ移動で出てくるEnumerableのデータを貼り付けてね、と(4000行ぐらい)&quot;;

static void Main(string[] args)
{
    var result = data
        .Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
        .Where(s =&gt; Regex.IsMatch(s, &quot;public static.+IEqualityComparer&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;(&lt;.+)(&gt;\(this)&quot;, &quot;$1,TCompareKey$2&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;IEqualityComparer&lt;(.+?)&gt;&quot;, &quot;Func&lt;$1,TCompareKey&gt;&quot;))
        .Select(s =&gt; Regex.Replace(s, @&quot;comparer&quot;, &quot;compareKeySelector&quot;))
        .Select(s =&gt; s.Trim(' ', ';'))
        .Select(s =&gt; new { Signature = s, Groups = Regex.Match(s, @&quot;^(.+? ){3}(?&lt;method&gt;[^ ]+?)&lt;.+?&gt;\(this (?&lt;args&gt;.+)\)$&quot;).Groups })
        .Select(a =&gt; new
        {
            a.Signature,
            MethodName = a.Groups[&quot;method&quot;].Value,
            Args = a.Groups[&quot;args&quot;].Value
                .Split(new[] { &quot;, &quot; }, StringSplitOptions.None)
                .Select(s =&gt; s.Split(' ')).Where(ar =&gt; ar.Length == 2).Select(ar =&gt; ar.Last())
        })
        .Select(a =&gt; string.Format(&quot;{1} {0} {{ return {2}.{3}({4}{5}); {0}}}{0}{0}&quot;,
            Environment.NewLine,
            a.Signature,
            a.Args.First(),
            a.MethodName,
            string.Join(&quot;,&quot;, a.Args.Skip(1).TakeWhile(s =&gt; s != &quot;compareKeySelector&quot;).ToArray()),
            (a.Args.Count() == 2 ? &quot;&quot; : &quot;,&quot;) + &quot;AnonymousComparer.Create(compareKeySelector)&quot;))
        .Aggregate(new StringBuilder(), (sb, s) =&gt; sb.Append(s))
        .ToString();
}
</code></pre>
<p>string dataのところにEnumerable.Rangeなんかを右クリックして「定義へ移動」で出てくるメタデータから、のものを全部コピーしてペースト。あとは、それをLinqでゴリゴリ加工すれば出来上がり。です。Select7連打は悪ノリですね。別にRegexの部分は.Replaceを繋げればいいのにね。あと、かなり決めうち成分強めなのと、正規表現が苦手であんまり上手く書けてないところが多かったりとで全く褒められたコードではありません。正規表現は本当に何とかしたいなあ……。</p>
<p>ああ、あと英語が酷い(笑) CodePlexのちょっとしたプロジェクト説明みたいな部分だけですら破綻しまくってる、単語すら繋げられない、これは酷い。</p>
<p>そういえば作ってから気づいたんですが、普通にリフレクションで取得した方が……遙かに……楽！綺麗に……仕上がる！ と、気づいてしまったのだけど気づかなかったことにしようそうしよう。</p>
</div>
<h1><a href="https://neue.cc/2009/10/08_208.html">return IEnumerableとyield return</a></h1>
<ul class="date"><li>2009-10-08</li></ul>
<div class="entry_body"><pre><code class="language-csharp">static void Main(string[] args)
{
    var path = @&quot;C:\test.txt&quot;;
    var lines = EnumerateAllLines(path).ToArray();
}

static IEnumerable&lt;string&gt; EnumerateAllLines(string filePath)
{
    using (var sr = new StreamReader(filePath))
    {
        return Enumerable.Repeat(sr, int.MaxValue)
            .TakeWhile(s =&gt; !s.EndOfStream)
            .Select(s =&gt; s.ReadLine());
    }
}
</code></pre>
<p>これの実行結果はどうなるでしょうか。答えは、「閉じているTextReaderから読み取ることはできません。」という例外が発生します。当たり前ですか？ すみません。Linqばかり触っていると、ついついIEnumerableだから遅延評価だね！と単刀直入に思ってしまっていたりしたのですが、IEnumerableは決して必ずしも遅延評価であるということでは、ない。配列だってIEnumerableなんだよ！という。当然のようなことですが、すっかり頭から抜け落ちていました。反省。</p>
<p>何で例外が発生するかと言えば、EnumerateAllLines(path)の時点でメソッドが呼ばれ、returnで返した時点でusingを抜けてストリームが閉じられてしまう。ので、ToArray()で閉じられたストリームに対して読み込みを始めて、南無。というわけです。ではどうすればいいかというと……</p>
<pre><code class="language-csharp">static IEnumerable&lt;string&gt; EnumerateAllLines(string filePath)
{
    using (var streamReader = new StreamReader(filePath))
    {
        var seq = Enumerable.Repeat(streamReader, int.MaxValue)
            .TakeWhile(sr =&gt; !sr.EndOfStream)
            .Select(sr =&gt; sr.ReadLine());
        foreach (var item in seq) yield return item;
    }
}
</code></pre>
<p>yield returnを使ってやれば、コンパイラがイテレータを作るので、遅延実行される。EnumerateAllLines(path)の時点ではメソッド内部は一切通らない。MoveNextが呼ばれて初めてusingを通り、列挙が終わるかDisposeが呼ばれるまではusingを抜けない。という、なって欲しいであろう挙動を取ってくれるわけです。実行ファイルをReflectorで見ると、復元不可能なぐらいグチャグチャなものが出力されていて、あまりの難読化っぷりにビビりますが気にしないことにしませう。</p>
<p>そもそもEnumerable.Repeat(sr, int.MaxValue)のほうを改善して<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">RepeatWithUsing</a>作った方がいい、のではあるのですけど、まあ、それはそれということで。</p>
<h2>無限リピート + SQL</h2>
<p>上のはただの説明用の例でクソの役にもたたないので、もう少し実用的なものを一つ。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    var command = new SqlCommand();
    command.CommandText = @&quot;select hogehogehoge&quot;;
    var result = command.EnumerateAll(dr =&gt; new
    {
        AA = dr.GetString(0),
        BB = dr.GetInt32(1)
    });
}

static IEnumerable&lt;T&gt; EnumerateAll&lt;T&gt;(this IDbCommand command, Func&lt;IDataReader, T&gt; selector)
{
    using (var reader = command.ExecuteReader())
    {
        var seq = Enumerable.Repeat(reader, int.MaxValue)
            .TakeWhile(dr =&gt; dr.Read())
            .Select(selector);
        foreach (var item in seq) yield return item;
    }
}

static T[] ReadAll&lt;T&gt;(this IDbCommand command, Func&lt;IDataReader, T&gt; selector)
{
    return command.EnumerateAll(selector).ToArray();
}
</code></pre>
<p>シーケンス無限リピートをSQLの読み込みに応用してみるとかどうでしょう。Linq to Sqlのように、とまでは到底行きませんが、匿名型も使えるし、何となくそれっぽい雰囲気は出てるんじゃないかしらん。EnumerateAllの後段にTakeWhileを付けて条件で途中で止めるとか、Take(10)で10件のみ取得とか、それなりに自由に動かせます。</p>
</div>
<h1><a href="https://neue.cc/2009/10/05_207.html">ラムダ式の引数の名前</a></h1>
<ul class="date"><li>2009-10-05</li></ul>
<div class="entry_body"><p>Linqもそうですが、Linq意外でもFuncやActionのお陰様でラムダ式を渡しまくりな昨今。そうなるとちょろっとした引数の名前付けが面倒くさかったりします。ので、大抵は一文字で済ませるわけです。一文字ってどうなのよ、よくないんじゃないの？というと、ラムダ式のような極端にスコープが短いものは、しっかりした名前がついているもののほうが逆に見づらかったりするので、一文字でいいと思います。面倒くさいからって全て_だの__だので済ませると見づらいので一文字はなるべく死守します。但し引数を利用しない場合は_を使います。ネストしたり、式じゃなくて文になる場合はしっかりした名前を付けます。</p>
<pre><code class="language-csharp">a // AnonymousType
i // int
s // string
c // char
d // datetime
g // IGrouping
t // Type
e(ex) // exception
e(elem) // XElement
e(ev) // event
e(ie) // IEnumerable(あんま使わないですが)
ar // array(IEnumerableの時もこれ使ったりする(適当))
ar // IAsyncResult(うわ、被っとる)
fs // fileSystemとかラクダの頭文字を繋げる
x // 適当なのがない場合とか、x =&gt; xとか
xs // arrayやらIEnumerableやらどっちでもいー、とヤケクソな時
_ // 引数を式中で利用しない場合
</code></pre>
<p>大抵は型の頭文字一つです。AnonymousTypeは、前はtを使ってたんですが、IntelliSenseで出てくるのが'aだし、世間的にもaが主流だしTypeと紛らわしいので、最近はaで書くようにしています。Aggregateなんかは(a,b)=&gt;って昔は書いていたのですが、aが匿名型なので紛らわしいから、(x,y)=&gt;と書くようにしています。徹底はしてません。適当です。</p>
<p>それにしてもeの被りっぷりは酷い。こうなると、不人気頭文字を使いたい。というわけで、ライブラリからTypeの頭文字を取得してみる。アセンブリの取得部分は<a href="http://d.hatena.ne.jp/siokoshou/20090817#p1" title="2009-08-17 - 当面C#と.NETな記録">2009-08-17 - 当面C#と.NETな記録</a>のコードをお借りしました。</p>
<pre><code class="language-csharp">// asmNamesは http://d.hatena.ne.jp/siokoshou/20090817#p1 から
// Groupingをバラしているのは、デバッガで中身を見る時にかったるかったから
var list = asmNames
    .SelectMany(s =&gt; Assembly.LoadWithPartialName(s).GetExportedTypes())
    .Select(t =&gt; t.Name)
    .GroupBy(s =&gt; s.First())
    .OrderBy(g =&gt; g.Key)
    .Select(g =&gt; new { Key = g.Key, Types = g.ToArray() })
    .ToList();
list.ForEach(a =&gt; Console.WriteLine(&quot;{0} : {1}&quot;, a.Key, a.Types.Length));

A : 319
B : 252
C : 773
D : 715
E : 275
F : 263
G : 172
H : 264
I : 887
J : 14
K : 58
L : 249
M : 424
N : 140
O : 189
P : 526
Q : 31
R : 312
S : 1039
T : 644
U : 169
V : 118
W : 272
X : 372
Z : 7
_ : 32
</code></pre>
<p>IはInterfaceだから数が多いのはしょうがない。Zは当然としてJ, K, Qは不人気ワードなので狙いどころですね！そしてSは人気あり過ぎ、と。別に考察でも何でもないです、すみません。CamelCaseを短縮結合して、一文字の場合のみを取り上げたら</p>
<pre><code class="language-csharp">// SplitCamelWordはasmNamesと同じくsiokoshouさんのコードから
.Select(t =&gt; SplitCamelWord(t.Name).Aggregate(&quot;&quot;, (x, y) =&gt; x + y.First(), s =&gt; s.ToLower()))
.Where(s =&gt; s.Length == 1)
</code></pre>
<p>ちゃんと(?)、eが一番人気でした。</p>
</div>
<h1><a href="https://neue.cc/2009/09/30_206.html">C# Linqでクイックソート</a></h1>
<ul class="date"><li>2009-09-30</li></ul>
<div class="entry_body"><pre><code class="language-haskell">qsort []     = []
qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
                 where
                   elts_lt_x   = [y | y &lt;- xs, y &lt; x]
                   elts_greq_x = [y | y &lt;- xs, y &gt;= x]
</code></pre>
<p>これはHaskellのコードで、良く見かける定番のQuickSort。うん、短い。というわけでLinqでそれをやる。というネタは既出のン番煎じなのですが、気にせずやる。</p>
<pre><code class="language-csharp">// LinqでHaskell風のクイックソート
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    return source
        .GroupBy(x =&gt; x.CompareTo(pivot))
        .OrderBy(g =&gt; g.Key) // OrderBy使うのはどうかなー、というところはある
        .SelectMany(g =&gt; (g.Key == 0) ? g : QuickSort(g));
}
</code></pre>
<p>GroupBy-&gt;SelectManyと流れるように書けて美しいー。これならHaskellにも引けを取らないですね！但し問題なのは、OrderByを使用しているところ。CompareToの結果である-1, 0, 1を並べ替えるために使っているのだけど、OrderByの中身はシュワルツ変換の挟まったクイックソートそのものなので邪道な感は否めない。OrderBy使うなら、そもそもsource.OrderBy(x =&gt; x)でもいいぢゃん、って話になってしまう。</p>
<pre><code class="language-csharp">// 非GroupBy版。LookupはGroupByの即時評価版と考えていい。
public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    if (!source.Any()) return source;
    var pivot = source.First();
    var lookup = source.ToLookup(x =&gt; x.CompareTo(pivot));
    return QuickSort(lookup[-1]).Concat(lookup[0]).Concat(QuickSort(lookup[1]));
}
</code></pre>
<p>GroupByをToLookupに書き変えました。ToLookupはGroupByの即時評価版といった感じで、インデクサによるアクセスが可能。インデクサ使わないでそのままforeachで列挙する、なんて時はGroupByを使った方が良いです。今回はインデクサで順番を明示的に指定するため、ToLookupでパーティション切って、Concatで繋いでやれば出来あがり。やってることが非常に分かりやすくて良い。ソースの見た目も中々綺麗じゃないでしょうか。Haskellのものとも非常に近いです(ようするに++がConcatなので) ToLookupではなくWhereを使えば、見た目は更にHaskellに近づきますが、列挙が二回になるので、ここはToLookupで。</p>
<pre><code class="language-csharp">// 普通に？書いた場合。
public static void QuickSort&lt;T&gt;(IList&lt;T&gt; source, int lowerBound, int upperBound)
    where T : IComparable&lt;T&gt;
{
    var pivot = source[lowerBound + ((upperBound - lowerBound) &gt;&gt; 1)];
    var left = lowerBound - 1;
    var right = upperBound + 1;
    while (true)
    {
        while (source[++left].CompareTo(pivot) &lt; 0) ;
        while (source[--right].CompareTo(pivot) &gt; 0) ;
        if (left &gt;= right) break;
        var temp = source[left];
        source[left] = source[right];
        source[right] = temp;
    }
    if (lowerBound &lt; left - 1) QuickSort(source, lowerBound, left - 1);
    if (right + 1 &lt; upperBound) QuickSort(source, right + 1, upperBound);
}
</code></pre>
<p>今度は非Linqに一般的？な書き方で。あまりヘタな書き方するとアレだなあ、と思ったので<a href="http://blog.livedoor.jp/dankogai/archives/51182235.html">404 Blog Not Found:javascript - Array#sortはオレquicksortより遅い by Chrome</a>のコードをC#に移植しました。<a href="http://dic.nicovideo.jp/a/%E3%81%82%E3%81%9F%E3%81%97%E3%81%93%E3%81%AE%E3%83%91%E3%82%A4%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%82%88%E3%81%AD">あたしこの書き方嫌いなのよね</a>、という感じにゴチャゴチャした印象は否めないというか、まあ、嫌いなのよね。一本の配列で頑張るところが、ゆとりな私としてはしんどい。ビットシフトも嫌よね。</p>
<pre><code class="language-csharp">public static IEnumerable&lt;T&gt; QuickSort&lt;T&gt;(IEnumerable&lt;T&gt; source)
    where T : IComparable&lt;T&gt;
{
    var enumerator = source.GetEnumerator();
    if (!enumerator.MoveNext()) yield break;

    var pivot = enumerator.Current;
    var less = new List&lt;T&gt;();
    var equal = new List&lt;T&gt;();
    var greater = new List&lt;T&gt;();
    do
    {
        switch (enumerator.Current.CompareTo(pivot))
        {
            case -1: less.Add(enumerator.Current); break;
            case 0: equal.Add(enumerator.Current); break;
            case 1: greater.Add(enumerator.Current); break;
        }
    } while (enumerator.MoveNext());

    foreach (var item in QuickSort(less)) yield return item;
    foreach (var item in equal) yield return item;
    foreach (var item in QuickSort(greater)) yield return item;
}
</code></pre>
<p>最後に、非Linqで、ToLookup版を再現してみたものを。do-whileがToLookupでforeachの連発がConcat。ようするに富豪的にListを作りまくるってわけなんですね！書きやすいし分かりやすいので、一本配列版よりも遥かに好き度高い。現代人はListを贅沢に大量に好きなだけ使うのです。まあ、Linq版がない状態でこの書き方が浮かぶ or 実行に移せるかどうかといったら、かなり無理ですけど。</p>
</div>
<h1><a href="https://neue.cc/2009/09/28_205.html">.NET Reactive Framework メソッド探訪第五回:Scan</a></h1>
<ul class="date"><li>2009-09-28</li></ul>
<div class="entry_body"><p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">var random = new Random();
Func&lt;byte&gt; nextByte = () =&gt; (byte)random.Next(0, byte.MaxValue + 1);

// CenterEllipseは真ん中の円のこと。
// 1000秒以内に3回クリックするとランダムで色が変わる
// GetMultiClickScan関数が今回の主題で、解説は後で。
CenterEllipse.GetMultiClickScan(3, 1000).Subscribe(() =&gt;
    CenterEllipse.Fill = new SolidColorBrush(Color.FromArgb(255, nextByte(), nextByte(), nextByte())));
</code></pre>
<p>円を1秒以内にトリプルクリックすると色が変わります。右側のログ表示はミリセカンド単位でトリプルクリック時の経過時間を表しています。つまり、これが1000以内ならば色が変わり、1000より上ならば色は変わりません。このサンプルのテーマは、トリプルクリックの検出です。トリプルだけではなく、クアドラプルでもクインタプルでも、1秒以内じゃなくて5秒でも10秒でも応用できる形で書くとしたら、どう書く？ グローバル変数に、クリックイベントを格納する配列でも置くかしらん。それがきっと簡単で分かりやすくて、でも……。</p>
<p>今回はRx Frameworkの関数から、Scanを取り上げます。この例題は私が考えたわけではなく、<a href="http://blogs.msdn.com/jeffva/archive/2009/08/14/my-solutions-to-the-reactive-framework-tripple-click-puzzle.aspx">Ramblings of a Lazy Coder : My solutions to the Reactive Framework Tripple-click puzzle</a>という問題からです。URLリンク先は解答編、というわけで、この解答を解説します。</p>
<p>考え方としては、クリックイベントに「クリックされた時間」という情報を付加。更に、クリック回数分の「前のデータ」を参照して指定時間内で連続クリックかどうかを確認する。時間情報の付加は匿名型を作るだけなので簡単ですが、「前のデータ」を参照するのが厄介。Linqは前にしか進まないし、送られてくるデータは過去のものなど知らない。このことはReactive Frameworkだけの話ではなく、以前にも<a href="http://neue.cc/2009/03/06_138.html">LINQで左外部自己結合</a>や<a href="http://neue.cc/2009/03/16_141.html">Scan?</a>という記事で書きましたが、そこで出てくる解決策がScan。そうそう、ScanはAchiralにあるので(ということでlinq.jsにもあります)、動作は分かってます。ようするにAggregateの計算過程吐きだし版です。とりあえず<a href="http://neue.cc/reference.htm" title="linq.js Reference">linq.js Reference</a>でE.Range(1,10).Scan(&quot;x,y=&gt;x+y&quot;)と打ってみてください(宣伝宣伝)</p>
<p>Scanならば「一個前」の情報が手に入る。しかし「複数個前」の情報はどうすれば？ 答えは配列使えばいいぢゃない。だそうです。過程のデータをとりあえず配列に入れて、次に送り出してやれば、そりゃ簡単に取り出せますね。何だか邪道な気がしますが、気にしない気にしない。URL先の解答例では生の配列を使って、インデックスをゴニャゴニャとしていて非常に正しいとは思いますが、あまり生の配列のインデックスは扱いたくないので、Queueを使ってみました。別にQueueのClear()のコストなんてたかが知れてるっしょ(中ではArray.Clearを呼んでいて、Array.Clearは……以下略)という割り切りで。</p>
<pre><code class="language-csharp">public static IObservable&lt;MouseButtonEventArgs&gt; GetMultiClickScan
    (this UIElement element, int count, int multiClickSpeedInMilliSeconds)
{
    return Observable.FromEvent&lt;MouseButtonEventArgs&gt;(element, &quot;MouseLeftButtonDown&quot;)
        .Select(e =&gt; e.EventArgs)
        .Scan(new
        {
            Times = new Queue&lt;DateTime&gt;(count),
            Hit = false,
            Event = (MouseButtonEventArgs)null // ダミーなのでnullをキャストするのが楽
        }, (a, e) =&gt;
        {
            var isHit = false;
            var now = DateTime.Now;
            a.Times.Enqueue(now);
            if (a.Times.Count == count)
            {
                var first = a.Times.Dequeue();
                Debug.WriteLine((now - first).TotalMilliseconds); // Debug
                if ((now - first).TotalMilliseconds &lt;= multiClickSpeedInMilliSeconds)
                {
                    isHit = true;
                    a.Times.Clear();
                }
            }

            return new
            {
                Times = a.Times,
                Hit = isHit,
                Event = e
            };
        })
        .Where(a =&gt; a.Hit)
        .Select(a =&gt; a.Event);
}
</code></pre>
<p>ScanはAggregateと全く同じで、accumlatorのみの実行の他に、第一引数でseedを渡すこともできます。Scanのseedで、変数と判定を行うためのフラグを保持するクラスを作り、accumlatorで判定と変数の持ち越しを行い、Whereで判定をフィルタリング。このコンボは非常に強力で、幾らでも応用が効きそう。LinqでのAggregateはほとんど使われませんが、RxにおけるScanはよく見かけることになるのではないかと思います。</p>
<p>で、理屈は分かったけれど、何だかゴチャゴチャとしてない？ という感想は否めない。ただ、グローバル領域に変数を置く必要なくフラグを閉じ込められていること、そして、応用の効きそうな柔らかさが見えたり見えなかったりしませんか？ 応用的なものも、追々考えていきたいです。</p>
<h2>次元の狭間へ</h2>
<p>Scanが出たので、Aggregateもついでにおさらい。これはLinq to ObjectsのAggregateと変わりません。ちなみにRx Frameworkでの内部実装はScan().Last()だったりするので、Scanとほんとーに丸っきり変わりません。じゃあ、無限リピートのFromEventにたいしてAggregateって、実行するとどうなるの？というのは気になるところですが、答えは次元の狭間に入ってしまって、その行からコードが一切進まなくなります。AggregateだけじゃなくCountやLast、ToEnumerableなど全てを列挙してから答えを返す系のメソッドは全て同じ結果になります。コンソールアプリの簡単なコードで試してみると、こうなる。</p>
<pre><code class="language-csharp">class MyClass
{
    public event EventHandler&lt;EventArgs&gt; Ev;

    public void Fire()
    {
        Ev(this, new EventArgs());
    }
}

static void Main(string[] args)
{
    var mc = new MyClass();
    var count = Observable.FromEvent&lt;EventArgs&gt;(mc, &quot;Ev&quot;)
        .Count(); // ここで次元の狭間にダイブする

    mc.Fire(); // ここに到達することは未来永劫無い
}
</code></pre>
<p>恐ろしや。ただ、前段階でTakeやTakeWhileを挟めば、無限リストは有限リストとなるので、面白い感じに制限が出来ます。この辺も応用例として、そのうち紹介していければと思います。</p>
<h2>カウンター</h2>
<p>もう一度Scanを見ます。トリプルクリックの例題は捻りすぎな感が否めないので、もっとストレートに、Scanの「前の値を保持し続けることが出来る」という点を見せる例題を一つ。<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3" title="クロージャ - Wikipedia">クロージャの例</a>なんかでも定番のカウンターで。</p>
<p class="noindent">
    <object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="200px" height="50px">
        <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/Silverlight_Rx_Scan_Counter.xap"/>
        <param name="background" value="white" />
        <param name="minRuntimeVersion" value="3.0.40624.0" />
        <param name="autoUpgrade" value="true" />
        <a href="http://go.microsoft.com/fwlink/?LinkID=149156&#038;v=3.0.40624.0" style="text-decoration:none">
        <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
        </a>
    </object>
</p>
<pre><code class="language-csharp">Observable.FromEvent&lt;RoutedEventArgs&gt;(CounterButton, &quot;Click&quot;)
    .Scan(0, (x, y) =&gt; ++x)
    .Subscribe(i =&gt; CounterButton.Content = i + &quot;Clicked&quot;);
</code></pre>
<p>とても簡潔で、変数が全て閉じ込められていて、綺麗……。</p>
</div>
<h1><a href="https://neue.cc/2009/09/25_204.html">Linqは美人</a></h1>
<ul class="date"><li>2009-09-25</li></ul>
<div class="entry_body"><pre><code class="language-csharp">public class Stamp
{
    public int Year { get; set; }
    public string Name { get; set; }
    public Stamp(int year, string name) { this.Year = year; this.Name = name; }
    public override string ToString() { return this.Year + &quot;:&quot; + this.Name; }
}

public class StampCollection : IEnumerable&lt;Stamp&gt;
{
    private Dictionary&lt;string, Stamp&gt; stamps = new Dictionary&lt;string, Stamp&gt;();

    public void Add(Stamp s) { stamps.Add(s.Name, s); }
    public void Add(int year, string name) { stamps.Add(name, new Stamp(year, name)); }

    // yield returnを通さなくてもそのままreturn可能
    public IEnumerator&lt;Stamp&gt; GetEnumerator()
    {
        return stamps.Values.OrderBy(s =&gt; s.Year).GetEnumerator();
    }

    // GetEnumeratorと名乗りながらGetEnumeratorじゃないのが少しアレですね
    public IEnumerable&lt;Stamp&gt; GetEnumerator2()
    {
        return stamps.Values.OrderByDescending(s =&gt; s.Year);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}

// 利用時例
static void Main(string[] args)
{
    // コレクション初期化子は、複数引数時は更に{}で囲む
    var stamps = new StampCollection()
    {
        {1998, &quot;hoge1&quot;},
        {1999, &quot;hoge2&quot;},
        {2000, &quot;hoge3&quot;}
    };
    
    // GenericsにしておくとCast&lt;T&gt;を使わずLinqでコンボ出来る
    stamps.GetEnumerator2().Select(s =&gt; s.Name).ToList().ForEach(Console.WriteLine);
}
</code></pre>
<p><a href="http://d.hatena.ne.jp/cast_everything/20090924/1253786494" title="memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋">memo:C#の反復と例外 - ニート=&gt;(vb=&gt;..なんて無かった)=&gt;ネトゲ屋</a>のものを少し書き換えました。コレクション初期化子と、yield returnせずにそのまま投げ返すように変えただけですが。Linqは美人。ですです。</p>
</div>
<h1><a href="https://neue.cc/2009/09/18_203.html">JavaScriptでString.Format的な超簡易テンプレート置換</a></h1>
<ul class="date"><li>2009-09-18</li></ul>
<div class="entry_body"><pre><code class="language-javascript">// String.Format的な超簡易テンプレート置換関数
var Format = function(template, replacement)
{
    if (typeof replacement != &quot;object&quot;) // 可変長引数時はreplacementを詰め替え
    {
        replacement = Array.prototype.slice.call(arguments, 1);
    }
    return template.replace(/\{(.+?)\}/g, function(m, c)
    {
        return (replacement[c] != null) ? replacement[c] : m
    });
}

// 例。可変長引数渡しでも配列渡しでもオブジェクト渡しでも可。
var case1 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, &quot;あいでぃ&quot;, &quot;要素&quot;);
var case2 = Format(&quot;&lt;div id={0}&gt;{1}&lt;/div&gt;&quot;, [&quot;あいでぃ&quot;, &quot;要素&quot;]);
var case3 = Format(&quot;&lt;div id={ID}&gt;{ELEM}&lt;/div&gt;&quot;, { ID: &quot;あいでぃ&quot;, ELEM: &quot;要素&quot; })
</code></pre>
<p>.NET FrameworkのString.Formatは文字を連結するのに、非常にお手軽で良いです。というわけでJavaScriptでもそれをやる。ついでにテンプレート置換風にオブジェクト渡しにも対応させる。単純な置換時は数字で、長ったらしい置換時はオブジェクトで。両方に対応させなければ、詰め替えが必要ないので正規表現でカカッと一行なんですねえ。詰め替えも別にslice.callで一発だし。<a href="http://neue.cc/2009/04/28_154.html" title="neue cc - JavaScriptでString.Format">以前にlinq.jsを絡めてgdgdとやってた</a>のですが、<a href="http://neue.cc/2009/05/14_158.html" title="neue cc - JavaScriptで文字列テンプレート">二度もね！</a>、あんなにgdgdやらずとも、もんのすごーく単純明快に書ける。無理やり使おうとして、無駄に複雑になるのはイクない。</p>
<p>と、恥ずかしくなったので今回載せました。あと、JavaScriptは文字連結面倒くせー、って時にササッとコピペで取り出して使いたい時のために(笑) ちゃんとDateTime等も含めたフォーマット変換に対応させるとか、テンプレートだったらちゃんとテンプレートエンジンな感じでforやifも動くように、とかの話は知りません。</p>
<p>そういえば、置換部分の関数ですけど、最初は格好つけて「return replacement[c] || m」って書いたんですが、これだとマッチがハッシュ内に見つからなかった場合(undefinedになってる)だけでなく、 空文字列の場合もfalse扱いになってしまってダメなんですね。C#の??のように使いたいのですが、例えば数字だと「var i = 0 || 3」だったら3になるしで使いづらい。というわけで、結局==nullばかり使うことになる。===undefinedって書けって話でもありますが、まあ、==nullのほうが色々考えなくて済むから楽で。</p>
</div>
<h1><a href="https://neue.cc/2009/09/16_202.html">ログ吐き骨組み</a></h1>
<ul class="date"><li>2009-09-16</li></ul>
<div class="entry_body"><p class="noindent">
<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="640px" height="300px">
  <param name="source" value="http://neue.cc/wp-content/uploads/silverlight/LogBrowseBase.xap"/>
  <param name="background" value="white" />
  <param name="minRuntimeVersion" value="3.0.40624.0" />
  <param name="autoUpgrade" value="true" />
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=3.0.40624.0" style="text-decoration:none">
      <img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Microsoft Silverlight を入手" style="border-style:none"/>
  </a>
</object>
</p>
<p>デモ大事。<a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">Subscribe</a>の時にConsole.WriteLine並べて、実行結果想像つきますよね、というのがいまひとつすぎたので、出力が見える骨組みを作りました。今後のReactive Frameworkの紹介時にソースコード上のDebug.WriteLineは、こーいうことなんですねー、と思ってください。毎回これ乗っけてると長ったらしいので、暗黙の、ということで。</p>
<pre><code class="language-xml">&lt;UserControl x:Class=&quot;SilverlightApplication4.MainPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; 
    mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;640&quot; d:DesignHeight=&quot;480&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition /&gt;
            &lt;ColumnDefinition Width=&quot;200&quot; /&gt;
        &lt;/Grid.ColumnDefinitions&gt;

        &lt;StackPanel Grid.Column=&quot;0&quot;&gt;
            &lt;Button Name=&quot;ExecuteButton&quot; Content=&quot;Execute&quot; /&gt;
            &lt;Button Name=&quot;ErrorButton&quot; Content=&quot;Error&quot; /&gt;
            &lt;Button Name=&quot;ObservableButton&quot; Content=&quot;Observable&quot; /&gt;
            &lt;Button Name=&quot;EnumerableButton&quot; Content=&quot;Enumerable&quot; /&gt;
        &lt;/StackPanel&gt;
        &lt;ScrollViewer Grid.Column=&quot;1&quot;&gt;
            &lt;TextBlock Name=&quot;LogBrowseTextBlock&quot;&gt;&lt;/TextBlock&gt;
        &lt;/ScrollViewer&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Reflection;

namespace SilverlightApplication4
{
    public partial class MainPage : UserControl
    {
        public MainPage()
        {
            InitializeComponent();
            Debug.Set(LogBrowseTextBlock, Dispatcher);

            ExecuteButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10).Subscribe(
                    i =&gt; Debug.WriteLine(i),
                    e =&gt; Debug.WriteLine(e),
                    () =&gt; Debug.WriteLine(&quot;completed&quot;)
                )
            );

            ErrorButton.GetClick().Subscribe(() =&gt;
                Observable.Range(1, 10)
                    .Do(i =&gt; { if (i == 5) throw new Exception(); })
                    .Subscribe(
                        i =&gt; Debug.WriteLine(i),
                        e =&gt; Debug.WriteLine(&quot;onError&quot;),
                        () =&gt; Debug.WriteLine(&quot;onCompleted&quot;)
                    )
            );

            ObservableButton.GetClick().Subscribe(() =&gt;
                GetMethodNames(typeof(Observable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );

            EnumerableButton.GetClick().Subscribe(() =&gt;
                  GetMethodNames(typeof(Enumerable)).ToList().ForEach(s =&gt; Debug.WriteLine(s))
            );
        }

        IEnumerable&lt;string&gt; GetMethodNames(Type type)
        {
            return type.GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Select(mi =&gt; mi.Name)
                .OrderBy(s =&gt; s)
                .Distinct();
        }
    }

    public static class Debug
    {
        private static TextBlock textBlock;
        private static Dispatcher dispatcher;

        public static void Set(TextBlock textBlock, Dispatcher dispatcher)
        {
            Debug.textBlock = textBlock;
            Debug.dispatcher = dispatcher;
        }

        public static void WriteLine(object message)
        {
            if (textBlock != null)
            {
                dispatcher.BeginInvoke(() =&gt;
                    textBlock.Text = message.ToString() + Environment.NewLine + textBlock.Text);
            }
        }
    }

    public static class ControlExtensions
    {
        public static IObservable&lt;Event&lt;RoutedEventArgs&gt;&gt; GetClick(this ButtonBase button)
        {
            return Observable.FromEvent&lt;RoutedEventArgs&gt;(button, &quot;Click&quot;);
        }
    }
}
</code></pre>
<p>幾ら簡易的なものだから、という言い訳がましさを考えても、かなり微妙なコードな気がする。原型はWPFでTraceListenerにTextBlockに書きだすものを追加して、Trace.WriteLineで処理していたもの。SilverlightにはTraceがなかったので、そのまま静的クラス・メソッドに置き換えて、Silverlightにも本来あるDebugを塗り替えちゃうという……。ようするにそのままコピペしても動くよね！的な感じでやりたいな、というところなわけです。ダメ？</p>
<p>ついでにSubscribeの中でObservableって、汚い、ように見えるかも。でも実際これはなんてことなくて、ようはJavaScriptっぽいんですよね、ほんと。DOMContentLoadedにイベント登録のaddEventListener並べるのと一緒で。じゃあ実際こうしてグチャグチャ並べるかというとそうではないようで、実際は拡張メソッドへ記述する、という形で分散していくようですが、まだまだ分からず。Microsoft側の実例やドキュメントが整ってくれないと何とも言えない感じ。</p>
<h2>作業環境</h2>
<p class="noindent">
	<a href="http://neue.cc/wp-content/uploads/image/vsorig.jpg"><img src="http://neue.cc/wp-content/uploads/image/vsmin.jpg"></a>
</p>
<p>画像クリックで原寸サイズ。最近思うところあってVisual Studioの配置をごにょごにょと弄っています。今は、こんな感じに落ち着きました。左にエラー一覧・検索など。右にソリューションエクスプローラー・クラスビュー・スタートページなど。そして左右にそれぞれコードウィンドウを分割。原則的にメインウィンドウは左。コード定義ウィンドウを右ウィンドウに開いて常時表示。もしくはXAML編集と並列したり。といったところです。コード定義ウィンドウはデカい画面で常時表示で初めて効果を発揮しますね、素晴らしく便利。</p>
<p>30インチ 2560x1600の無駄遣いが火を吹く！というわけですが、やっぱ広いって便利、エディタウィンドウ2面同時表示って便利、です。30インチでなくても、横2560は19インチ1280x1024のデュアルで行けます。ただ、実際はこれに加えてデバッグ時のプログラム本体なりブラウザなりを置いておく場所が欲しいので、その場合はデュアルじゃ足りないですね……。グラフィックボードが一枚でトリプルをサポートしてくれれば、というか、するべき、ですよね。ATIの<a href="http://pc.watch.impress.co.jp/docs/news/20090911_315056.html" title="【PC Watch】 AMDが次世代GPUに搭載するマルチディスプレイ機能「Eyefinity」を披露">Eyefinity</a>にはとても期待してます。</p>
</div>
<h1><a href="https://neue.cc/2009/09/14_201.html">.NET Reactive Framework メソッド探訪第四回:メソッド一覧</a></h1>
<ul class="date"><li>2009-09-14</li></ul>
<div class="entry_body"><p><a href="http://neue.cc/2009/09/13_200.html" title="neue cc - .NET Reactive Framework メソッド探訪第三回:Subscribe">前回</a>が少し、明らかに説明不足でした……。Subscribeが原則としてIObserverを受ける(直接ラムダ式でonNextを記述するのはただの省略記法)ということは、IObserverを別に作っておける。もっと進めると、Subscribeで実行されるコード本体は自由に入れ替え可能。ということになります。ここが、イベント直記入に対するReactive Frameworkの強みの一つ。それ○○パターンだって？そうですね？その○○パターンがデフォルトで何も考えず使えるのならば、素晴らしいと思います。</p>
<p>では、ここからようやくメソッド探訪。の前に、全メソッド一覧を見てみます。IObservable&lt;T&gt;拡張メソッド一覧。そう、最初感動したのは、ドット打ってIntelliSenseに並んだこのメソッド名を見て、なのよね。いかにも素晴らしいことが出来そうな予感だったという。</p>
<pre><code class="language-text">Aggregate
Amb
AsObservable
Catch
CombineLatest
Concat
Cons
Contains
Count
Create
Defer
Delay
Dispatch
Do
Empty
Finally
First
FirstOrDefault
Flatten
ForkJoin
FromEvent
Generate
GetEnumerator
HoldUntilChanged
Interval
Last
LastOrDefault
Latest
Let
LetRec
LongCount
Merge
MostRecent
Never
Next
Post
Range
Reify
Repeat
Retry
Return
Sample
Scan
Select
SelectMany
Send
Single
SingleOrDefault
Skip
SkipWhile
Spawn
Start
Subscribe
Synchronize
Take
TakeWhile
Throttle
Throw
Timeout
ToAsync
ToBehavior
ToEnumerable
ToObservable
ToSubject
Until
WaitUntil
Where
Zip
</code></pre>
<p>かなり多い。68個ある。名前から想像つくのもあれば全くつかないものも。順番はどうしようかな、LinqではGenerating, Projection and Filtering, Join, Set, Ordering, Grouping, Aggregate, Paging, Convertで分けられたので、何らかの指針でもって分けた方が良いのは間違いないのですが、実際に中を突っつかないと何が何なのか全く分からない。</p>
<pre><code class="language-csharp">Func&lt;Type, IEnumerable&lt;string&gt;&gt; GetMethodNames = 
    type =&gt; type
        .GetMethods(BindingFlags.Static|BindingFlags.Public)
        .Select(mi =&gt; mi.Name)
        .OrderBy(s =&gt; s)
        .Distinct();

var enumerable = GetMethodNames(typeof(Enumerable));
var observable = GetMethodNames(typeof(Observable));

observable.Except(enumerable).ToList().ForEach(Console.WriteLine);
</code></pre>
<p>メソッド名一覧はobservableのみを吐いたもので、上のコードはEnumerableとの差分も取ってみたものです。Enumerableと重複しないものは47個でした。そんなに被ってる、というわけではないですね……。ちなみに、Enumerableは50個。覚えきれているので、もっと少ないと思ってたんですが、意外と多かった。Linq to Objectsもきちんと理解して使えるようになるのに半年ぐらいかかってしまっているので、今回も長期戦かなー。ちんたらやってる間にドキュメントが出てくるのを期待したい。</p>
</div>
<h1><a href="https://neue.cc/2009/09/13_200.html">.NET Reactive Framework メソッド探訪第三回:Subscribe</a></h1>
<ul class="date"><li>2009-09-13</li></ul>
<div class="entry_body"><p>メソッド探訪とか言いながら、ちっとも探訪してません。今回までが基礎知識で、Linq to Objectsで言ったらイテレータがどうこう、という段階。次回以降はメソッドを見ていきたいと思います。では、最後の予習ということで、Subscribe。SubscribeはIObservable&lt;T&gt;連鎖の終点となるもので(但し、別にSubscribeだけが終点というわけではない、FirstとかCountとか、終点になるものは他にもあります)ForEachのようなもの。戻り値はIDisposableで、イベント発生の監視を止めたい時はDisposeを呼ぶ。と、第一回の時に書きましたので、今回は別の方向から見ていきます。</p>
<pre><code class="language-csharp">static void Main(string[] args)
{
    Observable.Range(1, 10).Subscribe(Observer.Create(
        (int i) =&gt; Console.WriteLine(i), // OnNext
        e =&gt; { throw e; }, // OnError
        () =&gt; Console.WriteLine(&quot;Completed&quot;) // OnCompleted
    ));

    Console.ReadLine();
}
</code></pre>
<p>今回はコンソールアプリで。結果は想像つくとおり、1から10、最後にCompletedを表示。Observable.RangeはEnumerable.Rangeと同じです。というか中身的にはEnumerable.Range.ToObservableで変換されているだけです。RepeatとEmptyも用意されているので、ちょっとしたメソッド確認用に便利に使えると思います。それにしてもコード、ゴチャゴチャしてますねえ、わけわかんない書き方してわざと難解にやってるんじゃないだろうかって感じですが、その通りです、ので、普通の書き方も下の方でちゃんと書きます。で、SubscribeはIObservable&lt;T&gt;のメソッドとして定義されています。IEnumerable&lt;T&gt;がGetEnumeratorを持つように、IObservableはSubscribeを持つ。そして、原則Subscribeの引数はIObserver&lt;T&gt;です。</p>
<pre><code class="language-csharp">public interface IObservable&lt;T&gt;
{
    IDisposable Subscribe(IObserver&lt;T&gt; observer);
}

public interface IObserver&lt;T&gt;
{
    void OnCompleted();
    void OnError(Exception exception);
    void OnNext(T value);
}
</code></pre>
<p>インターフェイスなので直接生成することは出来ない。よってファクトリメソッドObserver.Createを用いて生成します。生成されるのは前回見たAnonymousEnumeratorと同じくinternalのジェネリッククラス「AnonymousObserver&lt;T&gt;」で、インターフェイスの各メソッドにデリゲートを直接放り込むだけの単純明快なものです。勿論、IObservable&lt;T&gt;を継承して自前の専用のものを用意しても構いませんが、クロージャを活かせば、自前で定義する意味など少しもありません。コンパイラの自動生成クラス任せでOK。</p>
<p>これの動作はメソッド名通りで、OnNextは値が来るたびに実行されるメソッド。OnCompletedは全て完了した時(FromEvent経由のものなど、実質無限リピート状態の場合は、Disposeが呼ばれた時)に実行されるメソッド。OnErrorは例外が発生した時に実行されるメソッド。発生した例外は原則catchされるので、再スローしたい時は、そのまんまですがthrow eの明示が必要です。</p>
<p>……それにしても面倒くさい。Observer.Createは。onNextだけが書ければいいんだよ！ってシーンにわざわざ空の式を書けとでも？（ちなみに空は()=&gt;{}です) 大体がして、推論出来ないから(int i)だとか、型を書かなければならないのもかったるい。というわけで、拡張メソッドが用意されています。</p>
<pre><code class="language-csharp">public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action onNext, Action&lt;Exception&gt; onError, Action onCompleted);
public static IDisposable Subscribe&lt;TSource&gt;(this IObservable&lt;TSource&gt; source, Action&lt;TSource&gt; onNext, Action&lt;Exception&gt; onError, Action onCompleted);
</code></pre>
<p>いっぱいありますけど、ようするに無視した部分は空のメソッドが代わりに埋められる、というだけの話。これを使えば、最初の例は、onNextだけにすると</p>
<pre><code class="language-csharp">Observable.Range(1, 10).Subscribe(i =&gt; Console.WriteLine(i));
</code></pre>
<p>と、簡潔明快に記述出来るわけです。メデタシメデタシ。</p>
<h2>過去記事</h2>
<p><a href="http://neue.cc/2009/09/04_197.html" title="neue cc - .NET Reactive Framework メソッド探訪第一回:FromEvent">.NET Reactive Framework メソッド探訪第一回:FromEvent</a><br />
<a href="http://neue.cc/2009/09/07_198.html" title="neue cc - .NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></p>
</div>
<h1><a href="https://neue.cc/2009/09/09_199.html">無限リピートの幸福</a></h1>
<ul class="date"><li>2009-09-09</li></ul>
<div class="entry_body"><p>Reactive Frameworkが、結構に無限リピートな感じなので、関連してC# Linqで<a href="http://ja.doukaku.org/197/lang/csharp/">どう書くにあった13日金曜日問題</a>を今更書いてみた。n番煎じ。</p>
<pre><code class="language-csharp">// 今日から2013年12月31日までの、13日の金曜日とその総数を表示してください。
// 「今日」を無限リピートという方針で書いてみたりして(総数は省略)
// 利点はTodayを変数として外側に定義する必要が無くLinq内に閉じ込められる
// Toを求めるのに足したり引いたりする必要がなく自然に書ける、の二つかしらん
// 「まで」という問いに対してTakeWhileで解答するのは自然で良いと思う

Enumerable.Repeat(DateTime.Now, int.MaxValue)
    .Select((d, i) =&gt; d.AddDays(i))
    .TakeWhile(d =&gt; d.Year &lt; 2014)
    .Where(d =&gt; (d.DayOfWeek == DayOfWeek.Friday) &amp;&amp; (d.Day == 13))
    .ToList()
    .ForEach(d =&gt; Console.WriteLine(d.ToShortDateString()));
</code></pre>
<p>TakeWhileが好きです。問題文に対して、自然に解答出来るような気がするので。「今日から(Repeat)」「2013年12月31日までの(TakeWhile)」「13日の金曜日(Where)」。実に自然に記述できる。いやまあ、Repeatが直感的かというと結構微妙なところではありますが。Rangeでfrom,toのほうが自然だろ常識的に考えて、というのも確かなんですけど、Rangeだとtoを作るのに計算式が必要ってのが、ちょっと違うかな、と。</p>
<p><a href="http://en.wikipedia.org/wiki/Pizza_(programming_language)">Pizza (programming language)</a>のexampleにもあるような、Streamを始めとして何かを無限リピートしてTakeWhileで終了条件を設定、というのはパターンとして結構幅広く使える、と思う。ある種のデザインパターン。イディオムイディオム。参考リンクは<a href="http://d.hatena.ne.jp/NyaRuRu/20080108/p1">C# 3.0 と while(true) と Iterator - NyaRuRuの日記</a>この辺り。</p>
<p>例えばVS2010から搭載されるEnumerable.Zipや、あとCycleを定義してみる。</p>
<pre><code class="language-csharp">// この二つを混ぜ合わす(VS2010で搭載されるZip関数)
var seq1 = Enumerable.Range(1, 10);
var seq2 = Enumerable.Range(10, 10);
Enumerable.Repeat(new { e1 = seq1.GetEnumerator(), e2 = seq2.GetEnumerator() }, int.MaxValue)
    .TakeWhile(t =&gt; t.e1.MoveNext() &amp;&amp; t.e2.MoveNext())
    .Select(t =&gt; t.e1.Current + t.e2.Current); // ここがZipのSelectorの部分
// foo,bar,hoge,foo,bar,hogeを無限に繰り返す
var elements = new[] { &quot;foo&quot;, &quot;bar&quot;, &quot;hoge&quot; };
var cycle = Enumerable.Repeat(elements, int.MaxValue).SelectMany(ar =&gt; ar);
</code></pre>
<p>Linqのお陰でかつてない勢いでint.MaxValueを使っているこの頃。Repeatも万能ですねえ。いやまあ、もう素直にAchiral使えよって話なんですが、標準メソッドのみで粘るのも面白くて。そういえばでついでなので<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>でもやってみた。</p>
<pre><code class="language-javascript">// JavaScriptはAddDaysがないので副作用全開でTodayを
// setHours(24)で翌日にしてしまう、という方針でやってみた

E.Repeat(new Date())
 .Do(&quot;$.setHours(24)&quot;)
 .TakeWhile(&quot;$.getFullYear() &lt; 2014&quot;)
 .Where(&quot;$.getDay() == 5 &amp;&amp; $.getDate() == 13&quot;)
 .ForEach(&quot;alert($)&quot;);
</code></pre>
<p>DoはReactive Frameworkにもありました。副作用を加えた上で素通しするメソッド。副作用は嫌なものです。汚いです。何が嫌かというと、動作を考えるのに見る範囲を広げなきゃいかんところかなあ。そしてLinqの何がいいかというと、見る範囲が物凄く限定される(ラムダ式一文だけを見ればいい)と思っている。だからLinq内でクロージャ(というか外部の変数をキャプチャして使う)もあんま好ましくないし、C#クエリ構文のletも好きじゃない。なるべくなら使いたくない。長文耐性なのは分かるけれど、カッコやインデントがなくてスマートだけれど、その分だけスコープが不明瞭になるという側面が否めない。まあ、letが必要なシチュエーションをSelectManyでやると、大抵はもっと奇怪になるのですけど。</p>
<p>んでまあ、この場合だとAddDaysのかわりにnew Date(year,month,day)で新しいのを作れば副作用なくSelectが使えるわけですが、ありきたりで面白くないと思ったので別な方向に走ってみた。というか、無限リピートは、無限リピートする何かに対して副作用全開で操作を加え続ける、という形の方が面白いというか実用的というか普通だとは思う。冒頭の例みたいなやつだと、別にRangeでよくね？って感じですし。Haskellじゃないんだから、潔癖症にならずに、副作用といかに楽しくお付き合いするかが大事なのですかね。</p>
<p>あ、ちなみに$は引数が一つの場合の省略記法です。こういった機能は<a href="http://ja.wikipedia.org/wiki/Scala">Scala</a>にもある。引数が一つのみの場合が大半なので、記述がグッと縮まるし、何よりも引数名を付ける必要がないのが嬉しい。C#でも使えるようになると嬉しいなあ、とずっと思ってるんですが中々どうして無理なんですかねえ、残念。</p>
</div>
<h1><a href="https://neue.cc/2009/09/07_198.html">.NET Reactive Framework メソッド探訪第二回:AnonymousEnumerable</a></h1>
<ul class="date"><li>2009-09-07</li></ul>
<div class="entry_body"><p>予定は常に変更されるもの、というわけで、今回はAnonymousEnumerableとAnonymousEnumeratorを見たいと思います。表に出てこない、internalのクラスな上に、内部でも全然使われていないので、見る必要はあんまりない。のですが、これと対になるAnonymousObservableとAnonymousObserverを見るにあたって、先に慣れ親しんだIEnumerable/Enumeratorで考えたほうが分かりやすかったので、これを先に考えます。</p>
<pre><code class="language-csharp">class AnonymousEnumerable&lt;T&gt; : IEnumerable&lt;T&gt;
{
    private Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator;
    public AnonymousEnumerable(Func&lt;IEnumerator&lt;T&gt;&gt; getEnumerator)
    {
        // 以下略
}

class AnonymousEnumerator&lt;T&gt; : IEnumerator&lt;T&gt;
{
    private Func&lt;T&gt; current;
    private Action dispose;
    private Func&lt;bool&gt; moveNext;

    public AnonymousEnumerator(Func&lt;bool&gt; moveNext, Func&lt;T&gt; current, Action dispose)
    {
        this.moveNext = moveNext;
        this.current = current;
        this.dispose = dispose;
    }

    public T Current
    {
        get { return this.current(); }
    }

    public bool MoveNext()
    {
        return this.moveNext();
    }
    
    // 以下略
}
</code></pre>
<p>Reflectorで見ちゃってるので、一部だけ(ライセンス！)。ただ、どれも一行なので見るまでもなく何をやってるのか想像付くと思います。 お馴染みのインターフェイスを実装しているだけですが、その実装を全てコンストラクタで受ける関数に任せています。ようするにこれはどういうことなのかというと、実例としてEnumerable.RepeatとSelectをAnonymousEnumerableで実装してみるとこうなります。</p>
<pre><code class="language-csharp">public static class Enumerable
{
    public static IEnumerable&lt;T&gt; Repeat&lt;T&gt;(T element, int count)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var index = 0;
            var current = default(T);
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; // MoveNext
                {
                    if (index == 0) current = element;
                    return (index++ &lt; count);
                },
                () =&gt; current, // Current
                () =&gt; { } // Dispose
            );
        });
    }
    
    // 実際のSelectは&lt;TSource,TResult&gt;ですが、都合により略
    public static IEnumerable&lt;T&gt; Select&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, T&gt; selector)
    {
        return new AnonymousEnumerable&lt;T&gt;(() =&gt;
        {
            var enumerator = source.GetEnumerator();
            return new AnonymousEnumerator&lt;T&gt;(
                () =&gt; enumerator.MoveNext(),
                () =&gt; selector(enumerator.Current),
                () =&gt; enumerator.Dispose()
            );
        });
    }
}
</code></pre>
<p>勿論、普通はyieldを使えばいいわけですが、もしyieldがなければ、こういう形で実装するのが簡潔でベスト、に見える。クロージャでコンパイラにクラス生成を任せているわけですねー。外部イテレータですが、外部のクラスに分割せず中に書けるため、すっきり分かりやすい。この発想はあったけどC#でやるという発想はなかったわ、というわけで結構感動しました。</p>
<p>そうそう、この仕組みは<a href="http://linqjs.codeplex.com/" title="linq.js - LINQ for JavaScript Library - Home">linq.js</a>と丸っきり同じなのです。感動ってのは、私の基本方針は間違ってなかったんだ！の裏付けでの喜びなので不純です。そのJavaScriptでの実装はこんな感じ。</p>
<pre><code class="language-javascript">Linq.Object = function(getEnumerator)
{
    this.GetEnumerator = getEnumerator;
}

Linq.Enumerator = function(moveNext)
{
    this.Current = null;
    this.MoveNext = moveNext;
}

Repeat: function(element, count)
{
    return new Linq.Object(function()
    {
        var index = 0;
        return new Linq.Enumerator(function()
        {
            if (this.Current == null) this.Current = element;
            return (index++ &lt; count);
        });
    });
}

Select: function(selector)
{
    var source = this;
    selector = Linq.Utils.CreateFunctor(selector);

    return new Linq.Object(function()
    {
        var enumerator = source.GetEnumerator();
        var index = 0;

        return new Linq.Enumerator(function()
        {
            if (enumerator.MoveNext())
            {
                this.Current = selector(enumerator.Current, index++);
                return true;
            }
            else
            {
                return false;
            }
        });
    });
}
</code></pre>
<p>スコープが若干違うかなって感じですが、大体同じです。(Linq.ObjectはLinq.Enumerableに名前変えよう……)。JavaScriptだからこそ、yieldがなくてもスッキリ定義出来る！と思っていただけに、そっかあ、そういう手を使えば良かったのかと少しショックだったりして。ほんとC#は柔軟な言語で、むしろもうJavaScriptよりもLightWeightだよ！</p>
<p>さて、次回はAnonymousObservableとAnonymousObserverを見てみることにします。勿論、予定は未定です。ていうかSubscribeはどうした、というと、Subscribeの中身はAnonymousObserverなので全然横道にそれてません、大丈夫です、まだ一直線です。</p>
</div>
<a href="https://neue.cc/23">Prev |</a>
<a href="https://neue.cc/25">| Next</a>
</div>
        <div id="side">
<h3>Profile</h3>
<div class="side_body" align="center">
<b>Yoshifumi Kawai</b><br />
<br />
<a href="https://cysharp.co.jp/">Cysharp, Inc</a><br />
CEO/CTO<br />
<br />
Microsoft MVP for Developer Technologies(C#)<br />
April 2011<br />
|<br />
July 2024<br />
<br />
Twitter:<a href="https://twitter.com/neuecc/">@neuecc</a>
GitHub:<a href="https://github.com/neuecc/">neuecc</a>
</div>

<h3>Archive</h3>
<div class="side_body">
<ul>
<li><a href="https://neue.cc/2023/09/">2023-09</a>
<li><a href="https://neue.cc/2023/07/">2023-07</a>
<li><a href="https://neue.cc/2023/03/">2023-03</a>
<li><a href="https://neue.cc/2023/01/">2023-01</a>
<li><a href="https://neue.cc/2022/12/">2022-12</a>
<li><a href="https://neue.cc/2022/11/">2022-11</a>
<li><a href="https://neue.cc/2022/07/">2022-07</a>
<li><a href="https://neue.cc/2022/05/">2022-05</a>
<li><a href="https://neue.cc/2022/04/">2022-04</a>
<li><a href="https://neue.cc/2022/02/">2022-02</a>
<li><a href="https://neue.cc/2022/01/">2022-01</a>
<li><a href="https://neue.cc/2021/12/">2021-12</a>
<li><a href="https://neue.cc/2021/11/">2021-11</a>
<li><a href="https://neue.cc/2021/08/">2021-08</a>
<li><a href="https://neue.cc/2021/07/">2021-07</a>
<li><a href="https://neue.cc/2021/05/">2021-05</a>
<li><a href="https://neue.cc/2021/02/">2021-02</a>
<li><a href="https://neue.cc/2020/12/">2020-12</a>
<li><a href="https://neue.cc/2020/11/">2020-11</a>
<li><a href="https://neue.cc/2020/10/">2020-10</a>
<li><a href="https://neue.cc/2020/08/">2020-08</a>
<li><a href="https://neue.cc/2020/07/">2020-07</a>
<li><a href="https://neue.cc/2020/04/">2020-04</a>
<li><a href="https://neue.cc/2020/01/">2020-01</a>
<li><a href="https://neue.cc/2019/12/">2019-12</a>
<li><a href="https://neue.cc/2019/09/">2019-09</a>
<li><a href="https://neue.cc/2019/08/">2019-08</a>
<li><a href="https://neue.cc/2019/07/">2019-07</a>
<li><a href="https://neue.cc/2019/06/">2019-06</a>
<li><a href="https://neue.cc/2019/05/">2019-05</a>
<li><a href="https://neue.cc/2019/04/">2019-04</a>
<li><a href="https://neue.cc/2018/12/">2018-12</a>
<li><a href="https://neue.cc/2018/10/">2018-10</a>
<li><a href="https://neue.cc/2018/08/">2018-08</a>
<li><a href="https://neue.cc/2018/07/">2018-07</a>
<li><a href="https://neue.cc/2018/05/">2018-05</a>
<li><a href="https://neue.cc/2018/04/">2018-04</a>
<li><a href="https://neue.cc/2018/01/">2018-01</a>
<li><a href="https://neue.cc/2017/12/">2017-12</a>
<li><a href="https://neue.cc/2017/09/">2017-09</a>
<li><a href="https://neue.cc/2017/08/">2017-08</a>
<li><a href="https://neue.cc/2017/07/">2017-07</a>
<li><a href="https://neue.cc/2017/06/">2017-06</a>
<li><a href="https://neue.cc/2017/04/">2017-04</a>
<li><a href="https://neue.cc/2017/03/">2017-03</a>
<li><a href="https://neue.cc/2016/12/">2016-12</a>
<li><a href="https://neue.cc/2016/11/">2016-11</a>
<li><a href="https://neue.cc/2016/10/">2016-10</a>
<li><a href="https://neue.cc/2016/09/">2016-09</a>
<li><a href="https://neue.cc/2016/08/">2016-08</a>
<li><a href="https://neue.cc/2016/07/">2016-07</a>
<li><a href="https://neue.cc/2016/06/">2016-06</a>
<li><a href="https://neue.cc/2016/05/">2016-05</a>
<li><a href="https://neue.cc/2016/04/">2016-04</a>
<li><a href="https://neue.cc/2016/03/">2016-03</a>
<li><a href="https://neue.cc/2016/01/">2016-01</a>
<li><a href="https://neue.cc/2015/12/">2015-12</a>
<li><a href="https://neue.cc/2015/11/">2015-11</a>
<li><a href="https://neue.cc/2015/10/">2015-10</a>
<li><a href="https://neue.cc/2015/09/">2015-09</a>
<li><a href="https://neue.cc/2015/06/">2015-06</a>
<li><a href="https://neue.cc/2015/05/">2015-05</a>
<li><a href="https://neue.cc/2015/04/">2015-04</a>
<li><a href="https://neue.cc/2015/03/">2015-03</a>
<li><a href="https://neue.cc/2015/02/">2015-02</a>
<li><a href="https://neue.cc/2015/01/">2015-01</a>
<li><a href="https://neue.cc/2014/12/">2014-12</a>
<li><a href="https://neue.cc/2014/11/">2014-11</a>
<li><a href="https://neue.cc/2014/10/">2014-10</a>
<li><a href="https://neue.cc/2014/09/">2014-09</a>
<li><a href="https://neue.cc/2014/08/">2014-08</a>
<li><a href="https://neue.cc/2014/07/">2014-07</a>
<li><a href="https://neue.cc/2014/05/">2014-05</a>
<li><a href="https://neue.cc/2014/04/">2014-04</a>
<li><a href="https://neue.cc/2014/03/">2014-03</a>
<li><a href="https://neue.cc/2014/01/">2014-01</a>
<li><a href="https://neue.cc/2013/12/">2013-12</a>
<li><a href="https://neue.cc/2013/11/">2013-11</a>
<li><a href="https://neue.cc/2013/10/">2013-10</a>
<li><a href="https://neue.cc/2013/09/">2013-09</a>
<li><a href="https://neue.cc/2013/08/">2013-08</a>
<li><a href="https://neue.cc/2013/07/">2013-07</a>
<li><a href="https://neue.cc/2013/06/">2013-06</a>
<li><a href="https://neue.cc/2013/05/">2013-05</a>
<li><a href="https://neue.cc/2013/04/">2013-04</a>
<li><a href="https://neue.cc/2013/03/">2013-03</a>
<li><a href="https://neue.cc/2013/02/">2013-02</a>
<li><a href="https://neue.cc/2013/01/">2013-01</a>
<li><a href="https://neue.cc/2012/12/">2012-12</a>
<li><a href="https://neue.cc/2012/11/">2012-11</a>
<li><a href="https://neue.cc/2012/10/">2012-10</a>
<li><a href="https://neue.cc/2012/09/">2012-09</a>
<li><a href="https://neue.cc/2012/08/">2012-08</a>
<li><a href="https://neue.cc/2012/07/">2012-07</a>
<li><a href="https://neue.cc/2012/06/">2012-06</a>
<li><a href="https://neue.cc/2012/05/">2012-05</a>
<li><a href="https://neue.cc/2012/04/">2012-04</a>
<li><a href="https://neue.cc/2012/03/">2012-03</a>
<li><a href="https://neue.cc/2012/02/">2012-02</a>
<li><a href="https://neue.cc/2012/01/">2012-01</a>
<li><a href="https://neue.cc/2011/12/">2011-12</a>
<li><a href="https://neue.cc/2011/11/">2011-11</a>
<li><a href="https://neue.cc/2011/10/">2011-10</a>
<li><a href="https://neue.cc/2011/09/">2011-09</a>
<li><a href="https://neue.cc/2011/08/">2011-08</a>
<li><a href="https://neue.cc/2011/07/">2011-07</a>
<li><a href="https://neue.cc/2011/06/">2011-06</a>
<li><a href="https://neue.cc/2011/05/">2011-05</a>
<li><a href="https://neue.cc/2011/04/">2011-04</a>
<li><a href="https://neue.cc/2011/03/">2011-03</a>
<li><a href="https://neue.cc/2011/02/">2011-02</a>
<li><a href="https://neue.cc/2011/01/">2011-01</a>
<li><a href="https://neue.cc/2010/12/">2010-12</a>
<li><a href="https://neue.cc/2010/11/">2010-11</a>
<li><a href="https://neue.cc/2010/10/">2010-10</a>
<li><a href="https://neue.cc/2010/09/">2010-09</a>
<li><a href="https://neue.cc/2010/08/">2010-08</a>
<li><a href="https://neue.cc/2010/07/">2010-07</a>
<li><a href="https://neue.cc/2010/06/">2010-06</a>
<li><a href="https://neue.cc/2010/05/">2010-05</a>
<li><a href="https://neue.cc/2010/04/">2010-04</a>
<li><a href="https://neue.cc/2010/03/">2010-03</a>
<li><a href="https://neue.cc/2010/02/">2010-02</a>
<li><a href="https://neue.cc/2010/01/">2010-01</a>
<li><a href="https://neue.cc/2009/12/">2009-12</a>
<li><a href="https://neue.cc/2009/11/">2009-11</a>
<li><a href="https://neue.cc/2009/10/">2009-10</a>
<li><a href="https://neue.cc/2009/09/">2009-09</a>
<li><a href="https://neue.cc/2009/08/">2009-08</a>
<li><a href="https://neue.cc/2009/07/">2009-07</a>
<li><a href="https://neue.cc/2009/06/">2009-06</a>
<li><a href="https://neue.cc/2009/05/">2009-05</a>
<li><a href="https://neue.cc/2009/04/">2009-04</a>
<li><a href="https://neue.cc/2009/03/">2009-03</a>
<li><a href="https://neue.cc/2009/02/">2009-02</a>
<li><a href="https://neue.cc/2009/01/">2009-01</a>
</ul>
</div>
</div>
        <div id="footer"><ul>
<li>Index: <a href="https://neue.cc">neue.cc</a><li>
<li>RSS feed: <a href="https://neue.cc/feed">neue.cc/feed</a><li>
<li>Powered by: <a href="https://github.com/neuecc/Blog2">https://github.com/neuecc/Blog2</a>
</ul></div>
    </div>
</body>
